{"files_changed":[["808","use super::{FixedOutput, Reset, Update};\nuse generic_array::typenum::Unsigned;\nuse generic_array::{ArrayLength, GenericArray};\n\n/// The `Digest` trait specifies an interface common for digest functions.\n///\n/// It's a convenience wrapper around [`Update`], [`FixedOutput`], [`Reset`],\n/// [`Clone`], and [`Default`] traits. It also provides additional convenience methods.\npub trait Digest {\n    /// Output size for `Digest`\n    type OutputSize: ArrayLength<u8>;\n\n    /// Create new hasher instance\n    fn new() -> Self;\n\n    /// Digest data, updating the internal state.\n    ///\n    /// This method can be called repeatedly for use with streaming messages.\n    fn update(&mut self, data: impl AsRef<[u8]>);\n\n    /// Digest input data in a chained manner.\n    fn chain(self, data: impl AsRef<[u8]>) -> Self\n    where\n        Self: Sized;\n\n    /// Retrieve result and consume hasher instance.\n    fn finalize(self) -> Output<Self>;\n\n    /// Retrieve result and reset hasher instance.\n    ///\n    /// This method sometimes can be more efficient compared to hasher\n    /// re-creation.\n    fn finalize_reset(&mut self) -> Output<Self>;\n\n    /// Reset hasher instance to its initial state.\n    fn reset(&mut self);\n\n    /// Get output size of the hasher\n    fn output_size() -> usize;\n\n    /// Convenience function to compute hash of the `data`. It will handle\n    /// hasher creation, data feeding and finalization.\n    ///\n    /// Example:\n    ///\n    /// ```rust,ignore\n    /// println!(\"{:x}\", sha2::Sha256::digest(b\"Hello world\"));\n    /// ```\n    fn digest(data: &[u8]) -> Output<Self>;\n}\n\nimpl<D: Update + FixedOutput + Reset + Clone + Default> Digest for D {\n    type OutputSize = <Self as FixedOutput>::OutputSize;\n\n    fn new() -> Self {\n        Self::default()\n    }\n\n    fn update(&mut self, data: impl AsRef<[u8]>) {\n        Update::update(self, data);\n    }\n\n    fn chain(self, data: impl AsRef<[u8]>) -> Self\n    where\n        Self: Sized,\n    {\n        Update::chain(self, data)\n    }\n\n    fn finalize(self) -> Output<Self> {\n        self.finalize_fixed()\n    }\n\n    fn finalize_reset(&mut self) -> Output<Self> {\n        let res = self.clone().finalize_fixed();\n        self.reset();\n        res\n    }\n\n    fn reset(&mut self) {\n        <Self as Reset>::reset(self)\n    }\n\n    fn output_size() -> usize {\n        Self::OutputSize::to_usize()\n    }\n\n    fn digest(data: &[u8]) -> Output<Self> {\n        let mut hasher = Self::default();\n        Update::update(&mut hasher, data);\n        hasher.finalize_fixed()\n    }\n}\n\n/// Output of a [`Digest`] function\npub type Output<D> = GenericArray<u8, <D as Digest>::OutputSize>;\n"],["809","//! Development-related functionality\n\npub use blobby;\n\nuse super::{ExtendableOutput, Reset, Update, VariableOutput, XofReader};\nuse core::fmt::Debug;\n\n/// Define test\n#[macro_export]\n#[cfg_attr(docsrs, doc(cfg(feature = \"dev\")))]\nmacro_rules! new_test {\n    ($name:ident, $test_name:expr, $hasher:ty, $test_func:ident) => {\n        #[test]\n        fn $name() {\n            use digest::dev::blobby::Blob2Iterator;\n            let data = include_bytes!(concat!(\"data/\", $test_name, \".blb\"));\n\n            for (i, row) in Blob2Iterator::new(data).unwrap().enumerate() {\n                let input = row[0];\n                let output = row[1];\n                if let Some(desc) = $test_func::<$hasher>(input, output) {\n                    panic!(\n                        \"\\n\\\n                         Failed test â„–{}: {}\\n\\\n                         input:\\t{:?}\\n\\\n                         output:\\t{:?}\\n\",\n                        i, desc, input, output,\n                    );\n                }\n            }\n        }\n    };\n}\n\n/// Module to separate Digest from other traits\nmod foo {\n    use super::super::Digest;\n    use core::fmt::Debug;\n\n    /// Digest test\n    pub fn digest_test<D>(input: &[u8], output: &[u8]) -> Option<&'static str>\n    where\n        D: Digest + Debug + Clone,\n    {\n        let mut hasher = D::new();\n        // Test that it works when accepting the message all at once\n        hasher.update(input);\n        let mut hasher2 = hasher.clone();\n        if hasher.finalize().as_slice() != output {\n            return Some(\"whole message\");\n        }\n\n        // Test if reset works correctly\n        hasher2.reset();\n        hasher2.update(input);\n        if hasher2.finalize().as_slice() != output {\n            return Some(\"whole message after reset\");\n        }\n\n        // Test that it works when accepting the message in pieces\n        let mut hasher = D::new();\n        let len = input.len();\n        let mut left = len;\n        while left > 0 {\n            let take = (left + 1) / 2;\n            hasher.update(&input[len - left..take + len - left]);\n            left -= take;\n        }\n        if hasher.finalize().as_slice() != output {\n            return Some(\"message in pieces\");\n        }\n\n        // Test processing byte-by-byte\n        let mut hasher = D::new();\n        for chunk in input.chunks(1) {\n            hasher.update(chunk)\n        }\n        if hasher.finalize().as_slice() != output {\n            return Some(\"message byte-by-byte\");\n        }\n        None\n    }\n\n    /// Compute digest of one million `a` bytes\n    pub fn one_million_a<D>(expected: &[u8])\n    where\n        D: Digest + Debug + Clone,\n    {\n        let mut sh = D::new();\n        for _ in 0..50_000 {\n            sh.update(&[b'a'; 10]);\n        }\n        sh.update(&[b'a'; 500_000][..]);\n        let out = sh.finalize();\n        assert_eq!(out[..], expected[..]);\n    }\n}\n\npub use self::foo::{digest_test, one_million_a};\n\n/// XOF test\npub fn xof_test<D>(input: &[u8], output: &[u8]) -> Option<&'static str>\nwhere\n    D: Update + ExtendableOutput + Default + Debug + Reset + Clone,\n{\n    let mut hasher = D::default();\n    let mut buf = [0u8; 1024];\n    // Test that it works when accepting the message all at once\n    hasher.update(input);\n\n    let mut hasher2 = hasher.clone();\n    {\n        let out = &mut buf[..output.len()];\n        hasher.finalize_xof().read(out);\n\n        if out != output {\n            return Some(\"whole message\");\n        }\n    }\n\n    // Test if hasher resets correctly\n    hasher2.reset();\n    hasher2.update(input);\n\n    {\n        let out = &mut buf[..output.len()];\n        hasher2.finalize_xof().read(out);\n\n        if out != output {\n            return Some(\"whole message after reset\");\n        }\n    }\n\n    // Test if hasher accepts message in pieces correctly\n    let mut hasher = D::default();\n    let len = input.len();\n    let mut left = len;\n    while left > 0 {\n        let take = (left + 1) / 2;\n        hasher.update(&input[len - left..take + len - left]);\n        left -= take;\n    }\n\n    {\n        let out = &mut buf[..output.len()];\n        hasher.finalize_xof().read(out);\n        if out != output {\n            return Some(\"message in pieces\");\n        }\n    }\n\n    // Test reading from reader byte by byte\n    let mut hasher = D::default();\n    hasher.update(input);\n\n    let mut reader = hasher.finalize_xof();\n    let out = &mut buf[..output.len()];\n    for chunk in out.chunks_mut(1) {\n        reader.read(chunk);\n    }\n\n    if out != output {\n        return Some(\"message in pieces\");\n    }\n    None\n}\n\n/// Variable-output digest test\npub fn variable_test<D>(input: &[u8], output: &[u8]) -> Option<&'static str>\nwhere\n    D: Update + VariableOutput + Reset + Debug + Clone,\n{\n    let mut hasher = D::new(output.len()).unwrap();\n    let mut buf = [0u8; 128];\n    let buf = &mut buf[..output.len()];\n    // Test that it works when accepting the message all at once\n    hasher.update(input);\n    let mut hasher2 = hasher.clone();\n    hasher.finalize_variable(|res| buf.copy_from_slice(res));\n    if buf != output {\n        return Some(\"whole message\");\n    }\n\n    // Test if reset works correctly\n    hasher2.reset();\n    hasher2.update(input);\n    hasher2.finalize_variable(|res| buf.copy_from_slice(res));\n    if buf != output {\n        return Some(\"whole message after reset\");\n    }\n\n    // Test that it works when accepting the message in pieces\n    let mut hasher = D::new(output.len()).unwrap();\n    let len = input.len();\n    let mut left = len;\n    while left > 0 {\n        let take = (left + 1) / 2;\n        hasher.update(&input[len - left..take + len - left]);\n        left -= take;\n    }\n    hasher.finalize_variable(|res| buf.copy_from_slice(res));\n    if buf != output {\n        return Some(\"message in pieces\");\n    }\n\n    // Test processing byte-by-byte\n    let mut hasher = D::new(output.len()).unwrap();\n    for chunk in input.chunks(1) {\n        hasher.update(chunk)\n    }\n    hasher.finalize_variable(|res| buf.copy_from_slice(res));\n    if buf != output {\n        return Some(\"message byte-by-byte\");\n    }\n    None\n}\n\n/// Define benchmark\n#[macro_export]\n#[cfg_attr(docsrs, doc(cfg(feature = \"dev\")))]\nmacro_rules! bench {\n    ($name:ident, $engine:path, $bs:expr) => {\n        #[bench]\n        fn $name(b: &mut Bencher) {\n            let mut d = <$engine>::default();\n            let data = [0; $bs];\n\n            b.iter(|| {\n                d.update(&data[..]);\n            });\n\n            b.bytes = $bs;\n        }\n    };\n\n    ($engine:path) => {\n        extern crate test;\n\n        use digest::Digest;\n        use test::Bencher;\n\n        $crate::bench!(bench1_10, $engine, 10);\n        $crate::bench!(bench2_100, $engine, 100);\n        $crate::bench!(bench3_1000, $engine, 1000);\n        $crate::bench!(bench4_10000, $engine, 10000);\n    };\n}\n"],["810","//! Fixed-size output digest support\n\nuse crate::Reset;\nuse generic_array::{ArrayLength, GenericArray};\n\n/// Trait for returning digest result with the fixed size\npub trait FixedOutput {\n    /// Output size for fixed output digest\n    type OutputSize: ArrayLength<u8>;\n\n    /// Write result into provided array and consume the hasher instance.\n    fn finalize_into(self, out: &mut GenericArray<u8, Self::OutputSize>);\n\n    /// Write result into provided array and reset the hasher instance.\n    fn finalize_into_reset(&mut self, out: &mut GenericArray<u8, Self::OutputSize>);\n\n    /// Retrieve result and consume the hasher instance.\n    #[inline]\n    fn finalize_fixed(self) -> GenericArray<u8, Self::OutputSize>\n    where\n        Self: Sized,\n    {\n        let mut out = Default::default();\n        self.finalize_into(&mut out);\n        out\n    }\n\n    /// Retrieve result and reset the hasher instance.\n    #[inline]\n    fn finalize_fixed_reset(&mut self) -> GenericArray<u8, Self::OutputSize> {\n        let mut out = Default::default();\n        self.finalize_into_reset(&mut out);\n        out\n    }\n}\n\n/// Trait for fixed-output digest implementations to use to retrieve the\n/// hash output.\n///\n/// Usage of this trait in user code is discouraged. Instead use the\n/// [`FixedOutput::finalize_fixed`] or [`FixedOutput::finalize_fixed_reset`]\n/// methods.\n///\n/// Types which impl this trait along with [`Reset`] will receive a blanket\n/// impl of [`FixedOutput`].\npub trait FixedOutputDirty {\n    /// Output size for fixed output digest\n    type OutputSize: ArrayLength<u8>;\n\n    /// Retrieve result into provided buffer and leave hasher in a dirty state.\n    ///\n    /// This method is expected to only be called once unless\n    /// [`Reset::reset`] is called, after which point it can be\n    /// called again and reset again (and so on).\n    fn finalize_into_dirty(&mut self, out: &mut GenericArray<u8, Self::OutputSize>);\n}\n\nimpl<D: FixedOutputDirty + Reset> FixedOutput for D {\n    type OutputSize = D::OutputSize;\n\n    #[inline]\n    fn finalize_into(mut self, out: &mut GenericArray<u8, Self::OutputSize>) {\n        self.finalize_into_dirty(out);\n    }\n\n    #[inline]\n    fn finalize_into_reset(&mut self, out: &mut GenericArray<u8, Self::OutputSize>) {\n        self.finalize_into_dirty(out);\n        self.reset();\n    }\n}\n"],["811","use core::fmt;\n\n/// The error type for variable hasher initialization\n#[derive(Clone, Copy, Debug, Default)]\npub struct InvalidOutputSize;\n\nimpl fmt::Display for InvalidOutputSize {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(\"invalid output size\")\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl std::error::Error for InvalidOutputSize {}\n"],["812","//! Untagged serialization/deserialization support for Either<L, R>.\n//!\n//! `Either` uses default, externally-tagged representation.\n//! However, sometimes it is useful to support several alternative types.\n//! For example, we may have a field which is generally Map<String, i32>\n//! but in typical cases Vec<String> would suffice, too.\n//!\n//! ```rust\n//! #[macro_use]\n//! extern crate serde;\n//! // or `use serde::{Serialize, Deserialize};` in newer rust versions.\n//!\n//! # fn main() -> Result<(), Box<dyn std::error::Error>> {\n//! use either::Either;\n//! use std::collections::HashMap;\n//!\n//! #[derive(Serialize, Deserialize, Debug)]\n//! #[serde(transparent)]\n//! struct IntOrString {\n//!     #[serde(with = \"either::serde_untagged\")]\n//!     inner: Either<Vec<String>, HashMap<String, i32>>\n//! };\n//!\n//! // serialization\n//! let data = IntOrString {\n//!     inner: Either::Left(vec![\"Hello\".to_string()])\n//! };\n//! // notice: no tags are emitted.\n//! assert_eq!(serde_json::to_string(&data)?, r#\"[\"Hello\"]\"#);\n//!\n//! // deserialization\n//! let data: IntOrString = serde_json::from_str(\n//!     r#\"{\"a\": 0, \"b\": 14}\"#\n//! )?;\n//! println!(\"found {:?}\", data);\n//! # Ok(())\n//! # }\n//! ```\n\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\n#[derive(Serialize, Deserialize)]\n#[serde(untagged)]\nenum Either<L, R> {\n    Left(L),\n    Right(R),\n}\n\npub fn serialize<L, R, S>(this: &super::Either<L, R>, serializer: S) -> Result<S::Ok, S::Error>\nwhere\n    S: Serializer,\n    L: Serialize,\n    R: Serialize,\n{\n    let untagged = match this {\n        &super::Either::Left(ref left) => Either::Left(left),\n        &super::Either::Right(ref right) => Either::Right(right),\n    };\n    untagged.serialize(serializer)\n}\n\npub fn deserialize<'de, L, R, D>(deserializer: D) -> Result<super::Either<L, R>, D::Error>\nwhere\n    D: Deserializer<'de>,\n    L: Deserialize<'de>,\n    R: Deserialize<'de>,\n{\n    match Either::deserialize(deserializer) {\n        Ok(Either::Left(left)) => Ok(super::Either::Left(left)),\n        Ok(Either::Right(right)) => Ok(super::Either::Right(right)),\n        Err(error) => Err(error),\n    }\n}\n"],["813","//! Untagged serialization/deserialization support for Option<Either<L, R>>.\n//!\n//! `Either` uses default, externally-tagged representation.\n//! However, sometimes it is useful to support several alternative types.\n//! For example, we may have a field which is generally Map<String, i32>\n//! but in typical cases Vec<String> would suffice, too.\n//!\n//! ```rust\n//! #[macro_use]\n//! extern crate serde;\n//! // or `use serde::{Serialize, Deserialize};` in newer rust versions.\n//!\n//! # fn main() -> Result<(), Box<dyn std::error::Error>> {\n//! use either::Either;\n//! use std::collections::HashMap;\n//!\n//! #[derive(Serialize, Deserialize, Debug)]\n//! #[serde(transparent)]\n//! struct IntOrString {\n//!     #[serde(with = \"either::serde_untagged_optional\")]\n//!     inner: Option<Either<Vec<String>, HashMap<String, i32>>>\n//! };\n//!\n//! // serialization\n//! let data = IntOrString {\n//!     inner: Some(Either::Left(vec![\"Hello\".to_string()]))\n//! };\n//! // notice: no tags are emitted.\n//! assert_eq!(serde_json::to_string(&data)?, r#\"[\"Hello\"]\"#);\n//!\n//! // deserialization\n//! let data: IntOrString = serde_json::from_str(\n//!     r#\"{\"a\": 0, \"b\": 14}\"#\n//! )?;\n//! println!(\"found {:?}\", data);\n//! # Ok(())\n//! # }\n//! ```\n\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\n#[derive(Serialize, Deserialize)]\n#[serde(untagged)]\nenum Either<L, R> {\n    Left(L),\n    Right(R),\n}\n\npub fn serialize<L, R, S>(\n    this: &Option<super::Either<L, R>>,\n    serializer: S,\n) -> Result<S::Ok, S::Error>\nwhere\n    S: Serializer,\n    L: Serialize,\n    R: Serialize,\n{\n    let untagged = match this {\n        &Some(super::Either::Left(ref left)) => Some(Either::Left(left)),\n        &Some(super::Either::Right(ref right)) => Some(Either::Right(right)),\n        &None => None,\n    };\n    untagged.serialize(serializer)\n}\n\npub fn deserialize<'de, L, R, D>(deserializer: D) -> Result<Option<super::Either<L, R>>, D::Error>\nwhere\n    D: Deserializer<'de>,\n    L: Deserialize<'de>,\n    R: Deserialize<'de>,\n{\n    match Option::deserialize(deserializer) {\n        Ok(Some(Either::Left(left))) => Ok(Some(super::Either::Left(left))),\n        Ok(Some(Either::Right(right))) => Ok(Some(super::Either::Right(right))),\n        Ok(None) => Ok(None),\n        Err(error) => Err(error),\n    }\n}\n"],["814","//! `GenericArray` iterator implementation.\r\n\r\nuse super::{ArrayLength, GenericArray};\r\nuse core::iter::FusedIterator;\r\nuse core::mem::{MaybeUninit, ManuallyDrop};\r\nuse core::{cmp, fmt, ptr, mem};\r\n\r\n/// An iterator that moves out of a `GenericArray`\r\npub struct GenericArrayIter<T, N: ArrayLength<T>> {\r\n    // Invariants: index <= index_back <= N\r\n    // Only values in array[index..index_back] are alive at any given time.\r\n    // Values from array[..index] and array[index_back..] are already moved/dropped.\r\n    array: ManuallyDrop<GenericArray<T, N>>,\r\n    index: usize,\r\n    index_back: usize,\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use super::*;\r\n\r\n    fn send<I: Send>(_iter: I) {}\r\n\r\n    #[test]\r\n    fn test_send_iter() {\r\n        send(GenericArray::from([1, 2, 3, 4]).into_iter());\r\n    }\r\n}\r\n\r\nimpl<T, N> GenericArrayIter<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n{\r\n    /// Returns the remaining items of this iterator as a slice\r\n    #[inline]\r\n    pub fn as_slice(&self) -> &[T] {\r\n        &self.array.as_slice()[self.index..self.index_back]\r\n    }\r\n\r\n    /// Returns the remaining items of this iterator as a mutable slice\r\n    #[inline]\r\n    pub fn as_mut_slice(&mut self) -> &mut [T] {\r\n        &mut self.array.as_mut_slice()[self.index..self.index_back]\r\n    }\r\n}\r\n\r\nimpl<T, N> IntoIterator for GenericArray<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n{\r\n    type Item = T;\r\n    type IntoIter = GenericArrayIter<T, N>;\r\n\r\n    fn into_iter(self) -> Self::IntoIter {\r\n        GenericArrayIter {\r\n            array: ManuallyDrop::new(self),\r\n            index: 0,\r\n            index_back: N::USIZE,\r\n        }\r\n    }\r\n}\r\n\r\n// Based on work in rust-lang/rust#49000\r\nimpl<T: fmt::Debug, N> fmt::Debug for GenericArrayIter<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n{\r\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\r\n        f.debug_tuple(\"GenericArrayIter\")\r\n            .field(&self.as_slice())\r\n            .finish()\r\n    }\r\n}\r\n\r\nimpl<T, N> Drop for GenericArrayIter<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n{\r\n    #[inline]\r\n    fn drop(&mut self) {\r\n        if mem::needs_drop::<T>() {\r\n            // Drop values that are still alive.\r\n            for p in self.as_mut_slice() {\r\n                unsafe {\r\n                    ptr::drop_in_place(p);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Based on work in rust-lang/rust#49000\r\nimpl<T: Clone, N> Clone for GenericArrayIter<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n{\r\n    fn clone(&self) -> Self {\r\n        // This places all cloned elements at the start of the new array iterator,\r\n        // not at their original indices.\r\n        unsafe {\r\n            let mut array: MaybeUninit<GenericArray<T, N>> = MaybeUninit::uninit();\r\n            let mut index_back = 0;\r\n\r\n            for (dst, src) in (&mut *array.as_mut_ptr()).iter_mut().zip(self.as_slice()) {\r\n                ptr::write(dst, src.clone());\r\n\r\n                index_back += 1;\r\n            }\r\n\r\n            GenericArrayIter {\r\n                array: ManuallyDrop::new(array.assume_init()),\r\n                index: 0,\r\n                index_back\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl<T, N> Iterator for GenericArrayIter<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n{\r\n    type Item = T;\r\n\r\n    #[inline]\r\n    fn next(&mut self) -> Option<T> {\r\n        if self.index < self.index_back {\r\n            let p = unsafe { Some(ptr::read(self.array.get_unchecked(self.index))) };\r\n\r\n            self.index += 1;\r\n\r\n            p\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    fn fold<B, F>(mut self, init: B, mut f: F) -> B\r\n    where\r\n        F: FnMut(B, Self::Item) -> B,\r\n    {\r\n        let ret = unsafe {\r\n            let GenericArrayIter {\r\n                ref array,\r\n                ref mut index,\r\n                index_back,\r\n            } = self;\r\n\r\n            let remaining = &array[*index..index_back];\r\n\r\n            remaining.iter().fold(init, |acc, src| {\r\n                let value = ptr::read(src);\r\n\r\n                *index += 1;\r\n\r\n                f(acc, value)\r\n            })\r\n        };\r\n\r\n        // ensure the drop happens here after iteration\r\n        drop(self);\r\n\r\n        ret\r\n    }\r\n\r\n    #[inline]\r\n    fn size_hint(&self) -> (usize, Option<usize>) {\r\n        let len = self.len();\r\n        (len, Some(len))\r\n    }\r\n\r\n    #[inline]\r\n    fn count(self) -> usize {\r\n        self.len()\r\n    }\r\n\r\n    fn nth(&mut self, n: usize) -> Option<T> {\r\n        // First consume values prior to the nth.\r\n        let ndrop = cmp::min(n, self.len());\r\n\r\n        for p in &mut self.array[self.index..self.index + ndrop] {\r\n            self.index += 1;\r\n\r\n            unsafe {\r\n                ptr::drop_in_place(p);\r\n            }\r\n        }\r\n\r\n        self.next()\r\n    }\r\n\r\n    #[inline]\r\n    fn last(mut self) -> Option<T> {\r\n        // Note, everything else will correctly drop first as `self` leaves scope.\r\n        self.next_back()\r\n    }\r\n}\r\n\r\nimpl<T, N> DoubleEndedIterator for GenericArrayIter<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n{\r\n    fn next_back(&mut self) -> Option<T> {\r\n        if self.index < self.index_back {\r\n            self.index_back -= 1;\r\n\r\n            unsafe { Some(ptr::read(self.array.get_unchecked(self.index_back))) }\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    fn rfold<B, F>(mut self, init: B, mut f: F) -> B\r\n    where\r\n        F: FnMut(B, Self::Item) -> B,\r\n    {\r\n        let ret = unsafe {\r\n            let GenericArrayIter {\r\n                ref array,\r\n                index,\r\n                ref mut index_back,\r\n            } = self;\r\n\r\n            let remaining = &array[index..*index_back];\r\n\r\n            remaining.iter().rfold(init, |acc, src| {\r\n                let value = ptr::read(src);\r\n\r\n                *index_back -= 1;\r\n\r\n                f(acc, value)\r\n            })\r\n        };\r\n\r\n        // ensure the drop happens here after iteration\r\n        drop(self);\r\n\r\n        ret\r\n    }\r\n}\r\n\r\nimpl<T, N> ExactSizeIterator for GenericArrayIter<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n{\r\n    fn len(&self) -> usize {\r\n        self.index_back - self.index\r\n    }\r\n}\r\n\r\nimpl<T, N> FusedIterator for GenericArrayIter<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n{\r\n}\r\n\r\n// TODO: Implement `TrustedLen` when stabilized\r\n"],["815","//! Implementation for `arr!` macro.\n\nuse super::ArrayLength;\nuse core::ops::Add;\nuse typenum::U1;\n\n/// Helper trait for `arr!` macro\npub trait AddLength<T, N: ArrayLength<T>>: ArrayLength<T> {\n    /// Resulting length\n    type Output: ArrayLength<T>;\n}\n\nimpl<T, N1, N2> AddLength<T, N2> for N1\nwhere\n    N1: ArrayLength<T> + Add<N2>,\n    N2: ArrayLength<T>,\n    <N1 as Add<N2>>::Output: ArrayLength<T>,\n{\n    type Output = <N1 as Add<N2>>::Output;\n}\n\n/// Helper type for `arr!` macro\npub type Inc<T, U> = <U as AddLength<T, U1>>::Output;\n\n#[doc(hidden)]\n#[macro_export]\nmacro_rules! arr_impl {\n    (@replace_expr $e:expr) => { 1 };\n    ($T:ty; $N:ty, [$($x:expr),*], []) => ({\n        const __ARR_LENGTH: usize = 0 $(+ $crate::arr_impl!(@replace_expr $x) )*;\n\n        #[inline(always)]\n        fn __do_transmute<T, N: $crate::ArrayLength<T>>(arr: [T; __ARR_LENGTH]) -> $crate::GenericArray<T, N> {\n            unsafe { $crate::transmute(arr) }\n        }\n\n        let _: [(); <$N as $crate::typenum::Unsigned>::USIZE] = [(); __ARR_LENGTH];\n\n        __do_transmute::<$T, $N>([$($x as $T),*])\n    });\n    ($T:ty; $N:ty, [], [$x1:expr]) => (\n        $crate::arr_impl!($T; $crate::arr::Inc<$T, $N>, [$x1], [])\n    );\n    ($T:ty; $N:ty, [], [$x1:expr, $($x:expr),+]) => (\n        $crate::arr_impl!($T; $crate::arr::Inc<$T, $N>, [$x1], [$($x),+])\n    );\n    ($T:ty; $N:ty, [$($y:expr),+], [$x1:expr]) => (\n        $crate::arr_impl!($T; $crate::arr::Inc<$T, $N>, [$($y),+, $x1], [])\n    );\n    ($T:ty; $N:ty, [$($y:expr),+], [$x1:expr, $($x:expr),+]) => (\n        $crate::arr_impl!($T; $crate::arr::Inc<$T, $N>, [$($y),+, $x1], [$($x),+])\n    );\n}\n\n/// Macro allowing for easy generation of Generic Arrays.\n/// Example: `let test = arr![u32; 1, 2, 3];`\n#[macro_export]\nmacro_rules! arr {\n    ($T:ty; $(,)*) => ({\n        unsafe { $crate::transmute::<[$T; 0], $crate::GenericArray<$T, $crate::typenum::U0>>([]) }\n    });\n    ($T:ty; $($x:expr),* $(,)*) => (\n        $crate::arr_impl!($T; $crate::typenum::U0, [], [$($x),*])\n    );\n    ($($x:expr,)+) => (arr![$($x),+]);\n    () => (\"\"\"Macro requires a type, e.g. `let array = arr![u32; 1, 2, 3];`\")\n}\n\nmod doctests_only {\n    ///\n    /// # With ellision\n    ///\n    /// Testing that lifetimes aren't transmuted when they're ellided.\n    ///\n    /// ```compile_fail\n    /// #[macro_use] extern crate generic_array;\n    /// fn main() {\n    ///    fn unsound_lifetime_extension<'a, A>(a: &'a A) -> &'static A {\n    ///        arr![&A; a][0]\n    ///    }\n    /// }\n    /// ```\n    ///\n    /// ```rust\n    /// #[macro_use] extern crate generic_array;\n    /// fn main() {\n    ///    fn unsound_lifetime_extension<'a, A>(a: &'a A) -> &'a A {\n    ///        arr![&A; a][0]\n    ///    }\n    /// }\n    /// ```\n    ///\n    /// # Without ellision\n    ///\n    /// Testing that lifetimes aren't transmuted when they're specified explicitly.\n    ///\n    /// ```compile_fail\n    /// #[macro_use] extern crate generic_array;\n    /// fn main() {\n    ///    fn unsound_lifetime_extension<'a, A>(a: &'a A) -> &'static A {\n    ///        arr![&'a A; a][0]\n    ///    }\n    /// }\n    /// ```\n    ///\n    /// ```compile_fail\n    /// #[macro_use] extern crate generic_array;\n    /// fn main() {\n    ///    fn unsound_lifetime_extension<'a, A>(a: &'a A) -> &'static A {\n    ///        arr![&'static A; a][0]\n    ///    }\n    /// }\n    /// ```\n    ///\n    /// ```rust\n    /// #[macro_use] extern crate generic_array;\n    /// fn main() {\n    ///    fn unsound_lifetime_extension<'a, A>(a: &'a A) -> &'a A {\n    ///        arr![&'a A; a][0]\n    ///    }\n    /// }\n    /// ```\n    #[allow(dead_code)]\n    pub enum DocTests {}\n}\n"],["816","//! Generic array are commonly used as a return value for hash digests, so\r\n//! it's a good idea to allow to hexlify them easily. This module implements\r\n//! `std::fmt::LowerHex` and `std::fmt::UpperHex` traits.\r\n//!\r\n//! Example:\r\n//!\r\n//! ```rust\r\n//! # #[macro_use]\r\n//! # extern crate generic_array;\r\n//! # extern crate typenum;\r\n//! # fn main() {\r\n//! let array = arr![u8; 10, 20, 30];\r\n//! assert_eq!(format!(\"{:x}\", array), \"0a141e\");\r\n//! # }\r\n//! ```\r\n//!\r\n\r\nuse core::{fmt, str, ops::Add, cmp::min};\r\n\r\nuse typenum::*;\r\n\r\nuse crate::{ArrayLength, GenericArray};\r\n\r\nstatic LOWER_CHARS: &'static [u8] = b\"0123456789abcdef\";\r\nstatic UPPER_CHARS: &'static [u8] = b\"0123456789ABCDEF\";\r\n\r\nimpl<T: ArrayLength<u8>> fmt::LowerHex for GenericArray<u8, T>\r\nwhere\r\n    T: Add<T>,\r\n    <T as Add<T>>::Output: ArrayLength<u8>,\r\n{\r\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\r\n        let max_digits = f.precision().unwrap_or_else(|| self.len() * 2);\r\n        let max_hex = (max_digits >> 1) + (max_digits & 1);\r\n\r\n        if T::USIZE < 1024 {\r\n            // For small arrays use a stack allocated\r\n            // buffer of 2x number of bytes\r\n            let mut res = GenericArray::<u8, Sum<T, T>>::default();\r\n\r\n            self.iter().take(max_hex).enumerate().for_each(|(i, c)| {\r\n                res[i * 2] = LOWER_CHARS[(c >> 4) as usize];\r\n                res[i * 2 + 1] = LOWER_CHARS[(c & 0xF) as usize];\r\n            });\r\n\r\n            f.write_str(unsafe { str::from_utf8_unchecked(&res[..max_digits]) })?;\r\n        } else {\r\n            // For large array use chunks of up to 1024 bytes (2048 hex chars)\r\n            let mut buf = [0u8; 2048];\r\n            let mut digits_left = max_digits;\r\n\r\n            for chunk in self[..max_hex].chunks(1024) {\r\n                chunk.iter().enumerate().for_each(|(i, c)| {\r\n                    buf[i * 2] = LOWER_CHARS[(c >> 4) as usize];\r\n                    buf[i * 2 + 1] = LOWER_CHARS[(c & 0xF) as usize];\r\n                });\r\n\r\n                let n = min(chunk.len() * 2, digits_left);\r\n                f.write_str(unsafe { str::from_utf8_unchecked(&buf[..n]) })?;\r\n                digits_left -= n;\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl<T: ArrayLength<u8>> fmt::UpperHex for GenericArray<u8, T>\r\nwhere\r\n    T: Add<T>,\r\n    <T as Add<T>>::Output: ArrayLength<u8>,\r\n{\r\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\r\n        let max_digits = f.precision().unwrap_or_else(|| self.len() * 2);\r\n        let max_hex = (max_digits >> 1) + (max_digits & 1);\r\n\r\n        if T::USIZE < 1024 {\r\n            // For small arrays use a stack allocated\r\n            // buffer of 2x number of bytes\r\n            let mut res = GenericArray::<u8, Sum<T, T>>::default();\r\n\r\n            self.iter().take(max_hex).enumerate().for_each(|(i, c)| {\r\n                res[i * 2] = UPPER_CHARS[(c >> 4) as usize];\r\n                res[i * 2 + 1] = UPPER_CHARS[(c & 0xF) as usize];\r\n            });\r\n\r\n            f.write_str(unsafe { str::from_utf8_unchecked(&res[..max_digits]) })?;\r\n        } else {\r\n            // For large array use chunks of up to 1024 bytes (2048 hex chars)\r\n            let mut buf = [0u8; 2048];\r\n            let mut digits_left = max_digits;\r\n\r\n            for chunk in self[..max_hex].chunks(1024) {\r\n                chunk.iter().enumerate().for_each(|(i, c)| {\r\n                    buf[i * 2] = UPPER_CHARS[(c >> 4) as usize];\r\n                    buf[i * 2 + 1] = UPPER_CHARS[(c & 0xF) as usize];\r\n                });\r\n\r\n                let n = min(chunk.len() * 2, digits_left);\r\n                f.write_str(unsafe { str::from_utf8_unchecked(&buf[..n]) })?;\r\n                digits_left -= n;\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n"],["817","//! Serde serialization/deserialization implementation\r\n\r\nuse core::fmt;\r\nuse core::marker::PhantomData;\r\nuse serde::de::{self, SeqAccess, Visitor};\r\nuse serde::{ser::SerializeTuple, Deserialize, Deserializer, Serialize, Serializer};\r\nuse {ArrayLength, GenericArray};\r\n\r\nimpl<T, N> Serialize for GenericArray<T, N>\r\nwhere\r\n    T: Serialize,\r\n    N: ArrayLength<T>,\r\n{\r\n    #[inline]\r\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\r\n    where\r\n        S: Serializer,\r\n    {\r\n        let mut tup = serializer.serialize_tuple(N::USIZE)?;\r\n        for el in self {\r\n            tup.serialize_element(el)?;\r\n        }\r\n\r\n        tup.end()\r\n    }\r\n}\r\n\r\nstruct GAVisitor<T, N> {\r\n    _t: PhantomData<T>,\r\n    _n: PhantomData<N>,\r\n}\r\n\r\nimpl<'de, T, N> Visitor<'de> for GAVisitor<T, N>\r\nwhere\r\n    T: Deserialize<'de> + Default,\r\n    N: ArrayLength<T>,\r\n{\r\n    type Value = GenericArray<T, N>;\r\n\r\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\r\n        formatter.write_str(\"struct GenericArray\")\r\n    }\r\n\r\n    fn visit_seq<A>(self, mut seq: A) -> Result<GenericArray<T, N>, A::Error>\r\n    where\r\n        A: SeqAccess<'de>,\r\n    {\r\n        let mut result = GenericArray::default();\r\n        for i in 0..N::USIZE {\r\n            result[i] = seq\r\n                .next_element()?\r\n                .ok_or_else(|| de::Error::invalid_length(i, &self))?;\r\n        }\r\n        Ok(result)\r\n    }\r\n}\r\n\r\nimpl<'de, T, N> Deserialize<'de> for GenericArray<T, N>\r\nwhere\r\n    T: Deserialize<'de> + Default,\r\n    N: ArrayLength<T>,\r\n{\r\n    fn deserialize<D>(deserializer: D) -> Result<GenericArray<T, N>, D::Error>\r\n    where\r\n        D: Deserializer<'de>,\r\n    {\r\n        let visitor = GAVisitor {\r\n            _t: PhantomData,\r\n            _n: PhantomData,\r\n        };\r\n        deserializer.deserialize_tuple(N::USIZE, visitor)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use bincode;\r\n    use typenum;\r\n\r\n    #[test]\r\n    fn test_serialize() {\r\n        let array = GenericArray::<u8, typenum::U2>::default();\r\n        let serialized = bincode::serialize(&array);\r\n        assert!(serialized.is_ok());\r\n    }\r\n\r\n    #[test]\r\n    fn test_deserialize() {\r\n        let mut array = GenericArray::<u8, typenum::U2>::default();\r\n        array[0] = 1;\r\n        array[1] = 2;\r\n        let serialized = bincode::serialize(&array).unwrap();\r\n        let deserialized = bincode::deserialize::<GenericArray<u8, typenum::U2>>(&serialized);\r\n        assert!(deserialized.is_ok());\r\n        let array = deserialized.unwrap();\r\n        assert_eq!(array[0], 1);\r\n        assert_eq!(array[1], 2);\r\n    }\r\n\r\n    #[test]\r\n    fn test_serialized_size() {\r\n        let array = GenericArray::<u8, typenum::U1>::default();\r\n        let size = bincode::serialized_size(&array).unwrap();\r\n        assert_eq!(size, 1);\r\n    }\r\n\r\n}\r\n"],["818","use core::borrow::{Borrow, BorrowMut};\r\nuse core::cmp::Ordering;\r\nuse core::fmt::{self, Debug};\r\nuse core::hash::{Hash, Hasher};\r\n\r\nuse super::{ArrayLength, GenericArray};\r\n\r\nuse crate::functional::*;\r\nuse crate::sequence::*;\r\n\r\nimpl<T: Default, N> Default for GenericArray<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n{\r\n    #[inline(always)]\r\n    fn default() -> Self {\r\n        Self::generate(|_| T::default())\r\n    }\r\n}\r\n\r\nimpl<T: Clone, N> Clone for GenericArray<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n{\r\n    fn clone(&self) -> GenericArray<T, N> {\r\n        self.map(Clone::clone)\r\n    }\r\n}\r\n\r\nimpl<T: Copy, N> Copy for GenericArray<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n    N::ArrayType: Copy,\r\n{\r\n}\r\n\r\nimpl<T: PartialEq, N> PartialEq for GenericArray<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n{\r\n    fn eq(&self, other: &Self) -> bool {\r\n        **self == **other\r\n    }\r\n}\r\nimpl<T: Eq, N> Eq for GenericArray<T, N> where N: ArrayLength<T> {}\r\n\r\nimpl<T: PartialOrd, N> PartialOrd for GenericArray<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n{\r\n    fn partial_cmp(&self, other: &GenericArray<T, N>) -> Option<Ordering> {\r\n        PartialOrd::partial_cmp(self.as_slice(), other.as_slice())\r\n    }\r\n}\r\n\r\nimpl<T: Ord, N> Ord for GenericArray<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n{\r\n    fn cmp(&self, other: &GenericArray<T, N>) -> Ordering {\r\n        Ord::cmp(self.as_slice(), other.as_slice())\r\n    }\r\n}\r\n\r\nimpl<T: Debug, N> Debug for GenericArray<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n{\r\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\r\n        self[..].fmt(fmt)\r\n    }\r\n}\r\n\r\nimpl<T, N> Borrow<[T]> for GenericArray<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n{\r\n    #[inline(always)]\r\n    fn borrow(&self) -> &[T] {\r\n        &self[..]\r\n    }\r\n}\r\n\r\nimpl<T, N> BorrowMut<[T]> for GenericArray<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n{\r\n    #[inline(always)]\r\n    fn borrow_mut(&mut self) -> &mut [T] {\r\n        &mut self[..]\r\n    }\r\n}\r\n\r\nimpl<T, N> AsRef<[T]> for GenericArray<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n{\r\n    #[inline(always)]\r\n    fn as_ref(&self) -> &[T] {\r\n        &self[..]\r\n    }\r\n}\r\n\r\nimpl<T, N> AsMut<[T]> for GenericArray<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n{\r\n    #[inline(always)]\r\n    fn as_mut(&mut self) -> &mut [T] {\r\n        &mut self[..]\r\n    }\r\n}\r\n\r\nimpl<T: Hash, N> Hash for GenericArray<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n{\r\n    fn hash<H>(&self, state: &mut H)\r\n    where\r\n        H: Hasher,\r\n    {\r\n        Hash::hash(&self[..], state)\r\n    }\r\n}\r\n\r\nmacro_rules! impl_from {\r\n    ($($n: expr => $ty: ty),*) => {\r\n        $(\r\n            impl<T> From<[T; $n]> for GenericArray<T, $ty> {\r\n                #[inline(always)]\r\n                fn from(arr: [T; $n]) -> Self {\r\n                    unsafe { $crate::transmute(arr) }\r\n                }\r\n            }\r\n\r\n            #[cfg(relaxed_coherence)]\r\n            impl<T> From<GenericArray<T, $ty>> for [T; $n] {\r\n                #[inline(always)]\r\n                fn from(sel: GenericArray<T, $ty>) -> [T; $n] {\r\n                    unsafe { $crate::transmute(sel) }\r\n                }\r\n            }\r\n\r\n            impl<'a, T> From<&'a [T; $n]> for &'a GenericArray<T, $ty> {\r\n                #[inline]\r\n                fn from(slice: &[T; $n]) -> &GenericArray<T, $ty> {\r\n                    unsafe { &*(slice.as_ptr() as *const GenericArray<T, $ty>) }\r\n                }\r\n            }\r\n\r\n            impl<'a, T> From<&'a mut [T; $n]> for &'a mut GenericArray<T, $ty> {\r\n                #[inline]\r\n                fn from(slice: &mut [T; $n]) -> &mut GenericArray<T, $ty> {\r\n                    unsafe { &mut *(slice.as_mut_ptr() as *mut GenericArray<T, $ty>) }\r\n                }\r\n            }\r\n\r\n            #[cfg(not(relaxed_coherence))]\r\n            impl<T> Into<[T; $n]> for GenericArray<T, $ty> {\r\n                #[inline(always)]\r\n                fn into(self) -> [T; $n] {\r\n                    unsafe { $crate::transmute(self) }\r\n                }\r\n            }\r\n\r\n            impl<T> AsRef<[T; $n]> for GenericArray<T, $ty> {\r\n                #[inline]\r\n                fn as_ref(&self) -> &[T; $n] {\r\n                    unsafe { $crate::transmute(self) }\r\n                }\r\n            }\r\n\r\n            impl<T> AsMut<[T; $n]> for GenericArray<T, $ty> {\r\n                #[inline]\r\n                fn as_mut(&mut self) -> &mut [T; $n] {\r\n                    unsafe { $crate::transmute(self) }\r\n                }\r\n            }\r\n        )*\r\n    }\r\n}\r\n\r\nimpl_from! {\r\n    1  => ::typenum::U1,\r\n    2  => ::typenum::U2,\r\n    3  => ::typenum::U3,\r\n    4  => ::typenum::U4,\r\n    5  => ::typenum::U5,\r\n    6  => ::typenum::U6,\r\n    7  => ::typenum::U7,\r\n    8  => ::typenum::U8,\r\n    9  => ::typenum::U9,\r\n    10 => ::typenum::U10,\r\n    11 => ::typenum::U11,\r\n    12 => ::typenum::U12,\r\n    13 => ::typenum::U13,\r\n    14 => ::typenum::U14,\r\n    15 => ::typenum::U15,\r\n    16 => ::typenum::U16,\r\n    17 => ::typenum::U17,\r\n    18 => ::typenum::U18,\r\n    19 => ::typenum::U19,\r\n    20 => ::typenum::U20,\r\n    21 => ::typenum::U21,\r\n    22 => ::typenum::U22,\r\n    23 => ::typenum::U23,\r\n    24 => ::typenum::U24,\r\n    25 => ::typenum::U25,\r\n    26 => ::typenum::U26,\r\n    27 => ::typenum::U27,\r\n    28 => ::typenum::U28,\r\n    29 => ::typenum::U29,\r\n    30 => ::typenum::U30,\r\n    31 => ::typenum::U31,\r\n    32 => ::typenum::U32\r\n}\r\n\r\n#[cfg(feature = \"more_lengths\")]\r\nimpl_from! {\r\n    33 => ::typenum::U33,\r\n    34 => ::typenum::U34,\r\n    35 => ::typenum::U35,\r\n    36 => ::typenum::U36,\r\n    37 => ::typenum::U37,\r\n    38 => ::typenum::U38,\r\n    39 => ::typenum::U39,\r\n    40 => ::typenum::U40,\r\n    41 => ::typenum::U41,\r\n    42 => ::typenum::U42,\r\n    43 => ::typenum::U43,\r\n    44 => ::typenum::U44,\r\n    45 => ::typenum::U45,\r\n    46 => ::typenum::U46,\r\n    47 => ::typenum::U47,\r\n    48 => ::typenum::U48,\r\n    49 => ::typenum::U49,\r\n    50 => ::typenum::U50,\r\n    51 => ::typenum::U51,\r\n    52 => ::typenum::U52,\r\n    53 => ::typenum::U53,\r\n    54 => ::typenum::U54,\r\n    55 => ::typenum::U55,\r\n    56 => ::typenum::U56,\r\n    57 => ::typenum::U57,\r\n    58 => ::typenum::U58,\r\n    59 => ::typenum::U59,\r\n    60 => ::typenum::U60,\r\n    61 => ::typenum::U61,\r\n    62 => ::typenum::U62,\r\n    63 => ::typenum::U63,\r\n    64 => ::typenum::U64,\r\n\r\n    70 => ::typenum::U70,\r\n    80 => ::typenum::U80,\r\n    90 => ::typenum::U90,\r\n\r\n    100 => ::typenum::U100,\r\n    200 => ::typenum::U200,\r\n    300 => ::typenum::U300,\r\n    400 => ::typenum::U400,\r\n    500 => ::typenum::U500,\r\n\r\n    128 => ::typenum::U128,\r\n    256 => ::typenum::U256,\r\n    512 => ::typenum::U512,\r\n\r\n    1000 => ::typenum::U1000,\r\n    1024 => ::typenum::U1024\r\n}\r\n"],["819","//! Useful traits for manipulating sequences of data stored in `GenericArray`s\r\n\r\nuse super::*;\r\nuse core::ops::{Add, Sub};\r\nuse core::mem::MaybeUninit;\r\nuse core::ptr;\r\nuse typenum::operator_aliases::*;\r\n\r\n/// Defines some sequence with an associated length and iteration capabilities.\r\n///\r\n/// This is useful for passing N-length generic arrays as generics.\r\npub unsafe trait GenericSequence<T>: Sized + IntoIterator {\r\n    /// `GenericArray` associated length\r\n    type Length: ArrayLength<T>;\r\n\r\n    /// Concrete sequence type used in conjuction with reference implementations of `GenericSequence`\r\n    type Sequence: GenericSequence<T, Length = Self::Length> + FromIterator<T>;\r\n\r\n    /// Initializes a new sequence instance using the given function.\r\n    ///\r\n    /// If the generator function panics while initializing the sequence,\r\n    /// any already initialized elements will be dropped.\r\n    fn generate<F>(f: F) -> Self::Sequence\r\n    where\r\n        F: FnMut(usize) -> T;\r\n\r\n    #[doc(hidden)]\r\n    fn inverted_zip<B, U, F>(\r\n        self,\r\n        lhs: GenericArray<B, Self::Length>,\r\n        mut f: F,\r\n    ) -> MappedSequence<GenericArray<B, Self::Length>, B, U>\r\n    where\r\n        GenericArray<B, Self::Length>: GenericSequence<B, Length = Self::Length>\r\n            + MappedGenericSequence<B, U>,\r\n        Self: MappedGenericSequence<T, U>,\r\n        Self::Length: ArrayLength<B> + ArrayLength<U>,\r\n        F: FnMut(B, Self::Item) -> U,\r\n    {\r\n        unsafe {\r\n            let mut left = ArrayConsumer::new(lhs);\r\n\r\n            let (left_array_iter, left_position) = left.iter_position();\r\n\r\n            FromIterator::from_iter(left_array_iter.zip(self.into_iter()).map(\r\n                |(l, right_value)| {\r\n                        let left_value = ptr::read(l);\r\n\r\n                        *left_position += 1;\r\n\r\n                        f(left_value, right_value)\r\n                },\r\n            ))\r\n        }\r\n    }\r\n\r\n    #[doc(hidden)]\r\n    fn inverted_zip2<B, Lhs, U, F>(self, lhs: Lhs, mut f: F) -> MappedSequence<Lhs, B, U>\r\n    where\r\n        Lhs: GenericSequence<B, Length = Self::Length> + MappedGenericSequence<B, U>,\r\n        Self: MappedGenericSequence<T, U>,\r\n        Self::Length: ArrayLength<B> + ArrayLength<U>,\r\n        F: FnMut(Lhs::Item, Self::Item) -> U,\r\n    {\r\n        FromIterator::from_iter(lhs.into_iter().zip(self.into_iter()).map(|(l, r)| f(l, r)))\r\n    }\r\n}\r\n\r\n/// Accessor for `GenericSequence` item type, which is really `IntoIterator::Item`\r\n///\r\n/// For deeply nested generic mapped sequence types, like shown in `tests/generics.rs`,\r\n/// this can be useful for keeping things organized.\r\npub type SequenceItem<T> = <T as IntoIterator>::Item;\r\n\r\nunsafe impl<'a, T: 'a, S: GenericSequence<T>> GenericSequence<T> for &'a S\r\nwhere\r\n    &'a S: IntoIterator,\r\n{\r\n    type Length = S::Length;\r\n    type Sequence = S::Sequence;\r\n\r\n    #[inline]\r\n    fn generate<F>(f: F) -> Self::Sequence\r\n    where\r\n        F: FnMut(usize) -> T,\r\n    {\r\n        S::generate(f)\r\n    }\r\n}\r\n\r\nunsafe impl<'a, T: 'a, S: GenericSequence<T>> GenericSequence<T> for &'a mut S\r\nwhere\r\n    &'a mut S: IntoIterator,\r\n{\r\n    type Length = S::Length;\r\n    type Sequence = S::Sequence;\r\n\r\n    #[inline]\r\n    fn generate<F>(f: F) -> Self::Sequence\r\n    where\r\n        F: FnMut(usize) -> T,\r\n    {\r\n        S::generate(f)\r\n    }\r\n}\r\n\r\n/// Defines any `GenericSequence` which can be lengthened or extended by appending\r\n/// or prepending an element to it.\r\n///\r\n/// Any lengthened sequence can be shortened back to the original using `pop_front` or `pop_back`\r\npub unsafe trait Lengthen<T>: Sized + GenericSequence<T> {\r\n    /// `GenericSequence` that has one more element than `Self`\r\n    type Longer: Shorten<T, Shorter = Self>;\r\n\r\n    /// Returns a new array with the given element appended to the end of it.\r\n    ///\r\n    /// Example:\r\n    ///\r\n    /// ```rust\r\n    /// # use generic_array::{arr, sequence::Lengthen};\r\n    /// # fn main() {\r\n    /// let a = arr![i32; 1, 2, 3];\r\n    ///\r\n    /// let b = a.append(4);\r\n    ///\r\n    /// assert_eq!(b, arr![i32; 1, 2, 3, 4]);\r\n    /// # }\r\n    /// ```\r\n    fn append(self, last: T) -> Self::Longer;\r\n\r\n    /// Returns a new array with the given element prepended to the front of it.\r\n    ///\r\n    /// Example:\r\n    ///\r\n    /// ```rust\r\n    /// # use generic_array::{arr, sequence::Lengthen};\r\n    /// # fn main() {\r\n    /// let a = arr![i32; 1, 2, 3];\r\n    ///\r\n    /// let b = a.prepend(4);\r\n    ///\r\n    /// assert_eq!(b, arr![i32; 4, 1, 2, 3]);\r\n    /// # }\r\n    /// ```\r\n    fn prepend(self, first: T) -> Self::Longer;\r\n}\r\n\r\n/// Defines a `GenericSequence` which can be shortened by removing the first or last element from it.\r\n///\r\n/// Additionally, any shortened sequence can be lengthened by\r\n/// appending or prepending an element to it.\r\npub unsafe trait Shorten<T>: Sized + GenericSequence<T> {\r\n    /// `GenericSequence` that has one less element than `Self`\r\n    type Shorter: Lengthen<T, Longer = Self>;\r\n\r\n    /// Returns a new array without the last element, and the last element.\r\n    ///\r\n    /// Example:\r\n    ///\r\n    /// ```rust\r\n    /// # use generic_array::{arr, sequence::Shorten};\r\n    /// # fn main() {\r\n    /// let a = arr![i32; 1, 2, 3, 4];\r\n    ///\r\n    /// let (init, last) = a.pop_back();\r\n    ///\r\n    /// assert_eq!(init, arr![i32; 1, 2, 3]);\r\n    /// assert_eq!(last, 4);\r\n    /// # }\r\n    /// ```\r\n    fn pop_back(self) -> (Self::Shorter, T);\r\n\r\n    /// Returns a new array without the first element, and the first element.\r\n    /// Example:\r\n    ///\r\n    /// ```rust\r\n    /// # use generic_array::{arr, sequence::Shorten};\r\n    /// # fn main() {\r\n    /// let a = arr![i32; 1, 2, 3, 4];\r\n    ///\r\n    /// let (head, tail) = a.pop_front();\r\n    ///\r\n    /// assert_eq!(head, 1);\r\n    /// assert_eq!(tail, arr![i32; 2, 3, 4]);\r\n    /// # }\r\n    /// ```\r\n    fn pop_front(self) -> (T, Self::Shorter);\r\n}\r\n\r\nunsafe impl<T, N: ArrayLength<T>> Lengthen<T> for GenericArray<T, N>\r\nwhere\r\n    N: Add<B1>,\r\n    Add1<N>: ArrayLength<T>,\r\n    Add1<N>: Sub<B1, Output = N>,\r\n    Sub1<Add1<N>>: ArrayLength<T>,\r\n{\r\n    type Longer = GenericArray<T, Add1<N>>;\r\n\r\n    fn append(self, last: T) -> Self::Longer {\r\n        let mut longer: MaybeUninit<Self::Longer> = MaybeUninit::uninit();\r\n\r\n        // Note this is *mut Self, so add(1) increments by the whole array\r\n        let out_ptr = longer.as_mut_ptr() as *mut Self;\r\n\r\n        unsafe {\r\n            // write self first\r\n            ptr::write(out_ptr, self);\r\n            // increment past self, then write the last\r\n            ptr::write(out_ptr.add(1) as *mut T, last);\r\n\r\n            longer.assume_init()\r\n        }\r\n    }\r\n\r\n    fn prepend(self, first: T) -> Self::Longer {\r\n        let mut longer: MaybeUninit<Self::Longer> = MaybeUninit::uninit();\r\n\r\n        // Note this is *mut T, so add(1) increments by a single T\r\n        let out_ptr = longer.as_mut_ptr() as *mut T;\r\n\r\n        unsafe {\r\n            // write the first at the start\r\n            ptr::write(out_ptr, first);\r\n            // increment past the first, then write self\r\n            ptr::write(out_ptr.add(1) as *mut Self, self);\r\n\r\n            longer.assume_init()\r\n        }\r\n    }\r\n}\r\n\r\nunsafe impl<T, N: ArrayLength<T>> Shorten<T> for GenericArray<T, N>\r\nwhere\r\n    N: Sub<B1>,\r\n    Sub1<N>: ArrayLength<T>,\r\n    Sub1<N>: Add<B1, Output = N>,\r\n    Add1<Sub1<N>>: ArrayLength<T>,\r\n{\r\n    type Shorter = GenericArray<T, Sub1<N>>;\r\n\r\n    fn pop_back(self) -> (Self::Shorter, T) {\r\n        let whole = ManuallyDrop::new(self);\r\n\r\n        unsafe {\r\n            let init = ptr::read(whole.as_ptr() as _);\r\n            let last = ptr::read(whole.as_ptr().add(Sub1::<N>::USIZE) as _);\r\n\r\n            (init, last)\r\n        }\r\n    }\r\n\r\n    fn pop_front(self) -> (T, Self::Shorter) {\r\n        // ensure this doesn't get dropped\r\n        let whole = ManuallyDrop::new(self);\r\n\r\n        unsafe {\r\n            let head = ptr::read(whole.as_ptr() as _);\r\n            let tail = ptr::read(whole.as_ptr().offset(1) as _);\r\n\r\n            (head, tail)\r\n        }\r\n    }\r\n}\r\n\r\n/// Defines a `GenericSequence` that can be split into two parts at a given pivot index.\r\npub unsafe trait Split<T, K>: GenericSequence<T>\r\nwhere\r\n    K: ArrayLength<T>,\r\n{\r\n    /// First part of the resulting split array\r\n    type First: GenericSequence<T>;\r\n    /// Second part of the resulting split array\r\n    type Second: GenericSequence<T>;\r\n\r\n    /// Splits an array at the given index, returning the separate parts of the array.\r\n    fn split(self) -> (Self::First, Self::Second);\r\n}\r\n\r\nunsafe impl<T, N, K> Split<T, K> for GenericArray<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n    K: ArrayLength<T>,\r\n    N: Sub<K>,\r\n    Diff<N, K>: ArrayLength<T>,\r\n{\r\n    type First = GenericArray<T, K>;\r\n    type Second = GenericArray<T, Diff<N, K>>;\r\n\r\n    fn split(self) -> (Self::First, Self::Second) {\r\n        unsafe {\r\n            // ensure this doesn't get dropped\r\n            let whole = ManuallyDrop::new(self);\r\n\r\n            let head = ptr::read(whole.as_ptr() as *const _);\r\n            let tail = ptr::read(whole.as_ptr().add(K::USIZE) as *const _);\r\n\r\n            (head, tail)\r\n        }\r\n    }\r\n}\r\n\r\nunsafe impl<'a, T, N, K> Split<T, K> for &'a GenericArray<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n    K: ArrayLength<T> + 'static,\r\n    N: Sub<K>,\r\n    Diff<N, K>: ArrayLength<T>,\r\n{\r\n    type First = &'a GenericArray<T, K>;\r\n    type Second = &'a GenericArray<T, Diff<N, K>>;\r\n\r\n    fn split(self) -> (Self::First, Self::Second) {\r\n        unsafe {\r\n            let ptr_to_first: *const T = self.as_ptr();\r\n            let head = &*(ptr_to_first as *const _);\r\n            let tail = &*(ptr_to_first.add(K::USIZE) as *const _);\r\n            (head, tail)\r\n        }\r\n    }\r\n}\r\n\r\nunsafe impl<'a, T, N, K> Split<T, K> for &'a mut GenericArray<T, N>\r\nwhere\r\n    N: ArrayLength<T>,\r\n    K: ArrayLength<T> + 'static,\r\n    N: Sub<K>,\r\n    Diff<N, K>: ArrayLength<T>,\r\n{\r\n    type First = &'a mut GenericArray<T, K>;\r\n    type Second = &'a mut GenericArray<T, Diff<N, K>>;\r\n\r\n    fn split(self) -> (Self::First, Self::Second) {\r\n        unsafe {\r\n            let ptr_to_first: *mut T = self.as_mut_ptr();\r\n            let head = &mut *(ptr_to_first as *mut _);\r\n            let tail = &mut *(ptr_to_first.add(K::USIZE) as *mut _);\r\n            (head, tail)\r\n        }\r\n    }\r\n}\r\n\r\n/// Defines `GenericSequence`s which can be joined together, forming a larger array.\r\npub unsafe trait Concat<T, M>: GenericSequence<T>\r\nwhere\r\n    M: ArrayLength<T>,\r\n{\r\n    /// Sequence to be concatenated with `self`\r\n    type Rest: GenericSequence<T, Length = M>;\r\n\r\n    /// Resulting sequence formed by the concatenation.\r\n    type Output: GenericSequence<T>;\r\n\r\n    /// Concatenate, or join, two sequences.\r\n    fn concat(self, rest: Self::Rest) -> Self::Output;\r\n}\r\n\r\nunsafe impl<T, N, M> Concat<T, M> for GenericArray<T, N>\r\nwhere\r\n    N: ArrayLength<T> + Add<M>,\r\n    M: ArrayLength<T>,\r\n    Sum<N, M>: ArrayLength<T>,\r\n{\r\n    type Rest = GenericArray<T, M>;\r\n    type Output = GenericArray<T, Sum<N, M>>;\r\n\r\n    fn concat(self, rest: Self::Rest) -> Self::Output {\r\n        let mut output: MaybeUninit<Self::Output> = MaybeUninit::uninit();\r\n\r\n        let out_ptr = output.as_mut_ptr() as *mut Self;\r\n\r\n        unsafe {\r\n            // write all of self to the pointer\r\n            ptr::write(out_ptr, self);\r\n            // increment past self, then write the rest\r\n            ptr::write(out_ptr.add(1) as *mut _, rest);\r\n\r\n            output.assume_init()\r\n        }\r\n    }\r\n}\r\n"],["820","//! Functional programming with generic sequences\r\n//!\r\n//! Please see `tests/generics.rs` for examples of how to best use these in your generic functions.\r\n\r\nuse super::ArrayLength;\r\nuse core::iter::FromIterator;\r\n\r\nuse crate::sequence::*;\r\n\r\n/// Defines the relationship between one generic sequence and another,\r\n/// for operations such as `map` and `zip`.\r\npub unsafe trait MappedGenericSequence<T, U>: GenericSequence<T>\r\nwhere\r\n    Self::Length: ArrayLength<U>,\r\n{\r\n    /// Mapped sequence type\r\n    type Mapped: GenericSequence<U, Length = Self::Length>;\r\n}\r\n\r\nunsafe impl<'a, T, U, S: MappedGenericSequence<T, U>> MappedGenericSequence<T, U> for &'a S\r\nwhere\r\n    &'a S: GenericSequence<T>,\r\n    S: GenericSequence<T, Length = <&'a S as GenericSequence<T>>::Length>,\r\n    <S as GenericSequence<T>>::Length: ArrayLength<U>,\r\n{\r\n    type Mapped = <S as MappedGenericSequence<T, U>>::Mapped;\r\n}\r\n\r\nunsafe impl<'a, T, U, S: MappedGenericSequence<T, U>> MappedGenericSequence<T, U> for &'a mut S\r\nwhere\r\n    &'a mut S: GenericSequence<T>,\r\n    S: GenericSequence<T, Length = <&'a mut S as GenericSequence<T>>::Length>,\r\n    <S as GenericSequence<T>>::Length: ArrayLength<U>,\r\n{\r\n    type Mapped = <S as MappedGenericSequence<T, U>>::Mapped;\r\n}\r\n\r\n/// Accessor type for a mapped generic sequence\r\npub type MappedSequence<S, T, U> =\r\n    <<S as MappedGenericSequence<T, U>>::Mapped as GenericSequence<U>>::Sequence;\r\n\r\n/// Defines functional programming methods for generic sequences\r\npub unsafe trait FunctionalSequence<T>: GenericSequence<T> {\r\n    /// Maps a `GenericSequence` to another `GenericSequence`.\r\n    ///\r\n    /// If the mapping function panics, any already initialized elements in the new sequence\r\n    /// will be dropped, AND any unused elements in the source sequence will also be dropped.\r\n    fn map<U, F>(self, f: F) -> MappedSequence<Self, T, U>\r\n    where\r\n        Self: MappedGenericSequence<T, U>,\r\n        Self::Length: ArrayLength<U>,\r\n        F: FnMut(Self::Item) -> U,\r\n    {\r\n        FromIterator::from_iter(self.into_iter().map(f))\r\n    }\r\n\r\n    /// Combines two `GenericSequence` instances and iterates through both of them,\r\n    /// initializing a new `GenericSequence` with the result of the zipped mapping function.\r\n    ///\r\n    /// If the mapping function panics, any already initialized elements in the new sequence\r\n    /// will be dropped, AND any unused elements in the source sequences will also be dropped.\r\n    #[inline]\r\n    fn zip<B, Rhs, U, F>(self, rhs: Rhs, f: F) -> MappedSequence<Self, T, U>\r\n    where\r\n        Self: MappedGenericSequence<T, U>,\r\n        Rhs: MappedGenericSequence<B, U, Mapped = MappedSequence<Self, T, U>>,\r\n        Self::Length: ArrayLength<B> + ArrayLength<U>,\r\n        Rhs: GenericSequence<B, Length = Self::Length>,\r\n        F: FnMut(Self::Item, Rhs::Item) -> U,\r\n    {\r\n        rhs.inverted_zip2(self, f)\r\n    }\r\n\r\n    /// Folds (or reduces) a sequence of data into a single value.\r\n    ///\r\n    /// If the fold function panics, any unused elements will be dropped.\r\n    fn fold<U, F>(self, init: U, f: F) -> U\r\n    where\r\n        F: FnMut(U, Self::Item) -> U,\r\n    {\r\n        self.into_iter().fold(init, f)\r\n    }\r\n}\r\n\r\nunsafe impl<'a, T, S: GenericSequence<T>> FunctionalSequence<T> for &'a S\r\nwhere\r\n    &'a S: GenericSequence<T>,\r\n{\r\n}\r\n\r\nunsafe impl<'a, T, S: GenericSequence<T>> FunctionalSequence<T> for &'a mut S\r\nwhere\r\n    &'a mut S: GenericSequence<T>,\r\n{\r\n}\r\n"],["821","// Copyright 2018 Developers of the Rand project.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation for FreeBSD and NetBSD\nuse crate::{util_libc::sys_fill_exact, Error};\nuse core::ptr;\n\nfn kern_arnd(buf: &mut [u8]) -> libc::ssize_t {\n    static MIB: [libc::c_int; 2] = [libc::CTL_KERN, libc::KERN_ARND];\n    let mut len = buf.len();\n    let ret = unsafe {\n        libc::sysctl(\n            MIB.as_ptr(),\n            MIB.len() as libc::c_uint,\n            buf.as_mut_ptr() as *mut _,\n            &mut len,\n            ptr::null(),\n            0,\n        )\n    };\n    if ret == -1 {\n        -1\n    } else {\n        len as libc::ssize_t\n    }\n}\n\npub fn getrandom_inner(dest: &mut [u8]) -> Result<(), Error> {\n    #[cfg(target_os = \"freebsd\")]\n    {\n        use crate::util_libc::Weak;\n        static GETRANDOM: Weak = unsafe { Weak::new(\"getrandom\\0\") };\n        type GetRandomFn =\n            unsafe extern \"C\" fn(*mut u8, libc::size_t, libc::c_uint) -> libc::ssize_t;\n\n        if let Some(fptr) = GETRANDOM.ptr() {\n            let func: GetRandomFn = unsafe { core::mem::transmute(fptr) };\n            return sys_fill_exact(dest, |buf| unsafe { func(buf.as_mut_ptr(), buf.len(), 0) });\n        }\n    }\n    // Both FreeBSD and NetBSD will only return up to 256 bytes at a time, and\n    // older NetBSD kernels will fail on longer buffers.\n    for chunk in dest.chunks_mut(256) {\n        sys_fill_exact(chunk, kern_arnd)?\n    }\n    Ok(())\n}\n"],["822","// Copyright 2018 Developers of the Rand project.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation for SGX using RDRAND instruction\nuse crate::Error;\nuse core::mem;\n\ncfg_if! {\n    if #[cfg(target_arch = \"x86_64\")] {\n        use core::arch::x86_64 as arch;\n        use arch::_rdrand64_step as rdrand_step;\n    } else if #[cfg(target_arch = \"x86\")] {\n        use core::arch::x86 as arch;\n        use arch::_rdrand32_step as rdrand_step;\n    }\n}\n\n// Recommendation from \"IntelÂ® Digital Random Number Generator (DRNG) Software\n// Implementation Guide\" - Section 5.2.1 and \"IntelÂ® 64 and IA-32 Architectures\n// Software Developerâ€™s Manual\" - Volume 1 - Section 7.3.17.1.\nconst RETRY_LIMIT: usize = 10;\nconst WORD_SIZE: usize = mem::size_of::<usize>();\n\n#[target_feature(enable = \"rdrand\")]\nunsafe fn rdrand() -> Result<[u8; WORD_SIZE], Error> {\n    for _ in 0..RETRY_LIMIT {\n        let mut el = mem::zeroed();\n        if rdrand_step(&mut el) == 1 {\n            // AMD CPUs from families 14h to 16h (pre Ryzen) sometimes fail to\n            // set CF on bogus random data, so we check these values explicitly.\n            // See https://github.com/systemd/systemd/issues/11810#issuecomment-489727505\n            // We perform this check regardless of target to guard against\n            // any implementation that incorrectly fails to set CF.\n            if el != 0 && el != !0 {\n                return Ok(el.to_ne_bytes());\n            }\n            // Keep looping in case this was a false positive.\n        }\n    }\n    Err(Error::FAILED_RDRAND)\n}\n\n// \"rdrand\" target feature requires \"+rdrnd\" flag, see https://github.com/rust-lang/rust/issues/49653.\n#[cfg(all(target_env = \"sgx\", not(target_feature = \"rdrand\")))]\ncompile_error!(\n    \"SGX targets require 'rdrand' target feature. Enable by using -C target-feature=+rdrnd.\"\n);\n\n#[cfg(target_feature = \"rdrand\")]\nfn is_rdrand_supported() -> bool {\n    true\n}\n\n// TODO use is_x86_feature_detected!(\"rdrand\") when that works in core. See:\n// https://github.com/rust-lang-nursery/stdsimd/issues/464\n#[cfg(not(target_feature = \"rdrand\"))]\nfn is_rdrand_supported() -> bool {\n    use crate::util::LazyBool;\n\n    // SAFETY: All Rust x86 targets are new enough to have CPUID, and if CPUID\n    // is supported, CPUID leaf 1 is always supported.\n    const FLAG: u32 = 1 << 30;\n    static HAS_RDRAND: LazyBool = LazyBool::new();\n    HAS_RDRAND.unsync_init(|| unsafe { (arch::__cpuid(1).ecx & FLAG) != 0 })\n}\n\npub fn getrandom_inner(dest: &mut [u8]) -> Result<(), Error> {\n    if !is_rdrand_supported() {\n        return Err(Error::NO_RDRAND);\n    }\n\n    // SAFETY: After this point, rdrand is supported, so calling the rdrand\n    // functions is not undefined behavior.\n    unsafe { rdrand_exact(dest) }\n}\n\n#[target_feature(enable = \"rdrand\")]\nunsafe fn rdrand_exact(dest: &mut [u8]) -> Result<(), Error> {\n    // We use chunks_exact_mut instead of chunks_mut as it allows almost all\n    // calls to memcpy to be elided by the compiler.\n    let mut chunks = dest.chunks_exact_mut(WORD_SIZE);\n    for chunk in chunks.by_ref() {\n        chunk.copy_from_slice(&rdrand()?);\n    }\n\n    let tail = chunks.into_remainder();\n    let n = tail.len();\n    if n > 0 {\n        tail.copy_from_slice(&rdrand()?[..n]);\n    }\n    Ok(())\n}\n"],["823","// Copyright 2018 Developers of the Rand project.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation for the Solaris family\n//!\n//! Read from `/dev/random`, with chunks of limited size (256 bytes).\n//! `/dev/random` uses the Hash_DRBG with SHA512 algorithm from NIST SP 800-90A.\n//! `/dev/urandom` uses the FIPS 186-2 algorithm, which is considered less\n//! secure. We choose to read from `/dev/random`.\n//!\n//! Since Solaris 11.3 and mid-2015 illumos, the `getrandom` syscall is available.\n//! To make sure we can compile on both Solaris and its derivatives, as well as\n//! function, we check for the existence of getrandom(2) in libc by calling\n//! libc::dlsym.\nuse crate::{\n    use_file,\n    util_libc::{sys_fill_exact, Weak},\n    Error,\n};\nuse core::mem;\n\n#[cfg(target_os = \"illumos\")]\ntype GetRandomFn = unsafe extern \"C\" fn(*mut u8, libc::size_t, libc::c_uint) -> libc::ssize_t;\n#[cfg(target_os = \"solaris\")]\ntype GetRandomFn = unsafe extern \"C\" fn(*mut u8, libc::size_t, libc::c_uint) -> libc::c_int;\n\npub fn getrandom_inner(dest: &mut [u8]) -> Result<(), Error> {\n    static GETRANDOM: Weak = unsafe { Weak::new(\"getrandom\\0\") };\n    if let Some(fptr) = GETRANDOM.ptr() {\n        let func: GetRandomFn = unsafe { mem::transmute(fptr) };\n        // 256 bytes is the lowest common denominator across all the Solaris\n        // derived platforms for atomically obtaining random data.\n        for chunk in dest.chunks_mut(256) {\n            sys_fill_exact(chunk, |buf| unsafe {\n                func(buf.as_mut_ptr(), buf.len(), 0) as libc::ssize_t\n            })?\n        }\n        Ok(())\n    } else {\n        use_file::getrandom_inner(dest)\n    }\n}\n"],["824","// Copyright 2018 Developers of the Rand project.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation for Linux / Android\nuse crate::{\n    util::LazyBool,\n    util_libc::{last_os_error, sys_fill_exact},\n    {use_file, Error},\n};\n\npub fn getrandom_inner(dest: &mut [u8]) -> Result<(), Error> {\n    static HAS_GETRANDOM: LazyBool = LazyBool::new();\n    if HAS_GETRANDOM.unsync_init(is_getrandom_available) {\n        sys_fill_exact(dest, |buf| unsafe {\n            getrandom(buf.as_mut_ptr() as *mut libc::c_void, buf.len(), 0)\n        })\n    } else {\n        use_file::getrandom_inner(dest)\n    }\n}\n\nfn is_getrandom_available() -> bool {\n    let res = unsafe { getrandom(core::ptr::null_mut(), 0, libc::GRND_NONBLOCK) };\n    if res < 0 {\n        match last_os_error().raw_os_error() {\n            Some(libc::ENOSYS) => false, // No kernel support\n            Some(libc::EPERM) => false,  // Blocked by seccomp\n            _ => true,\n        }\n    } else {\n        true\n    }\n}\n\nunsafe fn getrandom(\n    buf: *mut libc::c_void,\n    buflen: libc::size_t,\n    flags: libc::c_uint,\n) -> libc::ssize_t {\n    libc::syscall(libc::SYS_getrandom, buf, buflen, flags) as libc::ssize_t\n}\n"],["825","// Copyright 2018 Developers of the Rand project.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation for iOS\nuse crate::Error;\nuse core::{ffi::c_void, ptr::null};\n\n#[link(name = \"Security\", kind = \"framework\")]\nextern \"C\" {\n    fn SecRandomCopyBytes(rnd: *const c_void, count: usize, bytes: *mut u8) -> i32;\n}\n\npub fn getrandom_inner(dest: &mut [u8]) -> Result<(), Error> {\n    // Apple's documentation guarantees kSecRandomDefault is a synonym for NULL.\n    let ret = unsafe { SecRandomCopyBytes(null(), dest.len(), dest.as_mut_ptr()) };\n    if ret == -1 {\n        Err(Error::IOS_SEC_RANDOM)\n    } else {\n        Ok(())\n    }\n}\n"],["826","// Copyright 2018 Developers of the Rand project.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation for Fuchsia Zircon\nuse crate::Error;\n\n#[link(name = \"zircon\")]\nextern \"C\" {\n    fn zx_cprng_draw(buffer: *mut u8, length: usize);\n}\n\npub fn getrandom_inner(dest: &mut [u8]) -> Result<(), Error> {\n    unsafe { zx_cprng_draw(dest.as_mut_ptr(), dest.len()) }\n    Ok(())\n}\n"],["827","// Copyright 2021 Developers of the Rand project.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation for DragonFly BSD\nuse crate::{\n    use_file,\n    util_libc::{sys_fill_exact, Weak},\n    Error,\n};\n\npub fn getrandom_inner(dest: &mut [u8]) -> Result<(), Error> {\n    static GETRANDOM: Weak = unsafe { Weak::new(\"getrandom\\0\") };\n    type GetRandomFn = unsafe extern \"C\" fn(*mut u8, libc::size_t, libc::c_uint) -> libc::ssize_t;\n\n    if let Some(fptr) = GETRANDOM.ptr() {\n        let func: GetRandomFn = unsafe { core::mem::transmute(fptr) };\n        return sys_fill_exact(dest, |buf| unsafe { func(buf.as_mut_ptr(), buf.len(), 0) });\n    } else {\n        use_file::getrandom_inner(dest)\n    }\n}\n"],["828","// Copyright 2018 Developers of the Rand project.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation for WASI\nuse crate::Error;\nuse core::num::NonZeroU32;\nuse wasi::random_get;\n\npub fn getrandom_inner(dest: &mut [u8]) -> Result<(), Error> {\n    unsafe { random_get(dest.as_mut_ptr(), dest.len()) }.map_err(|e: wasi::Error| {\n        // convert wasi's Error into getrandom's NonZeroU32 error\n        NonZeroU32::new(e.raw_error() as u32).unwrap().into()\n    })\n}\n"],["829","// Copyright 2018 Developers of the Rand project.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\nuse crate::Error;\n\nextern crate std;\nuse std::thread_local;\n\nuse js_sys::Uint8Array;\nuse wasm_bindgen::{prelude::*, JsCast};\n\n// Maximum is 65536 bytes see https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues\nconst BROWSER_CRYPTO_BUFFER_SIZE: usize = 256;\n\nenum RngSource {\n    Node(NodeCrypto),\n    Browser(BrowserCrypto, Uint8Array),\n}\n\n// JsValues are always per-thread, so we initialize RngSource for each thread.\n//   See: https://github.com/rustwasm/wasm-bindgen/pull/955\nthread_local!(\n    static RNG_SOURCE: Result<RngSource, Error> = getrandom_init();\n);\n\npub(crate) fn getrandom_inner(dest: &mut [u8]) -> Result<(), Error> {\n    RNG_SOURCE.with(|result| {\n        let source = result.as_ref().map_err(|&e| e)?;\n\n        match source {\n            RngSource::Node(n) => {\n                if n.random_fill_sync(dest).is_err() {\n                    return Err(Error::NODE_RANDOM_FILL_SYNC);\n                }\n            }\n            RngSource::Browser(crypto, buf) => {\n                // getRandomValues does not work with all types of WASM memory,\n                // so we initially write to browser memory to avoid exceptions.\n                for chunk in dest.chunks_mut(BROWSER_CRYPTO_BUFFER_SIZE) {\n                    // The chunk can be smaller than buf's length, so we call to\n                    // JS to create a smaller view of buf without allocation.\n                    let sub_buf = buf.subarray(0, chunk.len() as u32);\n\n                    if crypto.get_random_values(&sub_buf).is_err() {\n                        return Err(Error::WEB_GET_RANDOM_VALUES);\n                    }\n                    sub_buf.copy_to(chunk);\n                }\n            }\n        };\n        Ok(())\n    })\n}\n\nfn getrandom_init() -> Result<RngSource, Error> {\n    let global: Global = js_sys::global().unchecked_into();\n    if is_node(&global) {\n        let crypto = require(\"crypto\").map_err(|_| Error::NODE_CRYPTO)?;\n        return Ok(RngSource::Node(crypto));\n    }\n\n    // Assume we are in some Web environment (browser or web worker). We get\n    // `self.crypto` (called `msCrypto` on IE), so we can call\n    // `crypto.getRandomValues`. If `crypto` isn't defined, we assume that\n    // we are in an older web browser and the OS RNG isn't available.\n    let crypto = match (global.crypto(), global.ms_crypto()) {\n        (c, _) if c.is_object() => c,\n        (_, c) if c.is_object() => c,\n        _ => return Err(Error::WEB_CRYPTO),\n    };\n\n    let buf = Uint8Array::new_with_length(BROWSER_CRYPTO_BUFFER_SIZE as u32);\n    Ok(RngSource::Browser(crypto, buf))\n}\n\n// Taken from https://www.npmjs.com/package/browser-or-node\nfn is_node(global: &Global) -> bool {\n    let process = global.process();\n    if process.is_object() {\n        let versions = process.versions();\n        if versions.is_object() {\n            return versions.node().is_string();\n        }\n    }\n    false\n}\n\n#[wasm_bindgen]\nextern \"C\" {\n    type Global; // Return type of js_sys::global()\n\n    // Web Crypto API (https://www.w3.org/TR/WebCryptoAPI/)\n    #[wasm_bindgen(method, getter, js_name = \"msCrypto\")]\n    fn ms_crypto(this: &Global) -> BrowserCrypto;\n    #[wasm_bindgen(method, getter)]\n    fn crypto(this: &Global) -> BrowserCrypto;\n    type BrowserCrypto;\n    #[wasm_bindgen(method, js_name = getRandomValues, catch)]\n    fn get_random_values(this: &BrowserCrypto, buf: &Uint8Array) -> Result<(), JsValue>;\n\n    // Node JS crypto module (https://nodejs.org/api/crypto.html)\n    #[wasm_bindgen(catch, js_name = \"module.require\")]\n    fn require(s: &str) -> Result<NodeCrypto, JsValue>;\n    type NodeCrypto;\n    #[wasm_bindgen(method, js_name = randomFillSync, catch)]\n    fn random_fill_sync(this: &NodeCrypto, buf: &mut [u8]) -> Result<(), JsValue>;\n\n    // Node JS process Object (https://nodejs.org/api/process.html)\n    #[wasm_bindgen(method, getter)]\n    fn process(this: &Global) -> Process;\n    type Process;\n    #[wasm_bindgen(method, getter)]\n    fn versions(this: &Process) -> Versions;\n    type Versions;\n    #[wasm_bindgen(method, getter)]\n    fn node(this: &Versions) -> JsValue;\n}\n"],["830","// Copyright 2018 Developers of the Rand project.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n#![cfg_attr(docsrs, doc(cfg(feature = \"std\")))]\nextern crate std;\n\nuse crate::Error;\nuse core::convert::From;\nuse std::io;\n\nimpl From<Error> for io::Error {\n    fn from(err: Error) -> Self {\n        match err.raw_os_error() {\n            Some(errno) => io::Error::from_raw_os_error(errno),\n            None => io::Error::new(io::ErrorKind::Other, err),\n        }\n    }\n}\n\nimpl std::error::Error for Error {}\n"],["831","// Copyright 2018 Developers of the Rand project.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! An implementation which calls out to an externally defined function.\nuse crate::Error;\nuse core::num::NonZeroU32;\n\n/// Register a function to be invoked by `getrandom` on unsupported targets.\n///\n/// ## Writing a custom `getrandom` implementation\n///\n/// The function to register must have the same signature as\n/// [`getrandom::getrandom`](crate::getrandom). The function can be defined\n/// wherever you want, either in root crate or a dependant crate.\n///\n/// For example, if we wanted a `failure-getrandom` crate containing an\n/// implementation that always fails, we would first depend on `getrandom`\n/// (for the [`Error`] type) in `failure-getrandom/Cargo.toml`:\n/// ```toml\n/// [dependencies]\n/// getrandom = \"0.2\"\n/// ```\n/// Note that the crate containing this function does **not** need to enable the\n/// `\"custom\"` Cargo feature.\n///\n/// Next, in `failure-getrandom/src/lib.rs`, we define our function:\n/// ```rust\n/// use core::num::NonZeroU32;\n/// use getrandom::Error;\n///\n/// // Some application-specific error code\n/// const MY_CUSTOM_ERROR_CODE: u32 = Error::CUSTOM_START + 42;\n/// pub fn always_fail(buf: &mut [u8]) -> Result<(), Error> {\n///     let code = NonZeroU32::new(MY_CUSTOM_ERROR_CODE).unwrap();\n///     Err(Error::from(code))\n/// }\n/// ```\n///\n/// ## Registering a custom `getrandom` implementation\n///\n/// Functions can only be registered in the root binary crate. Attempting to\n/// register a function in a non-root crate will result in a linker error.\n/// This is similar to\n/// [`#[panic_handler]`](https://doc.rust-lang.org/nomicon/panic-handler.html) or\n/// [`#[global_allocator]`](https://doc.rust-lang.org/edition-guide/rust-2018/platform-and-target-support/global-allocators.html),\n/// where helper crates define handlers/allocators but only the binary crate\n/// actually _uses_ the functionality.\n///\n/// To register the function, we first depend on `failure-getrandom` _and_\n/// `getrandom` in `Cargo.toml`:\n/// ```toml\n/// [dependencies]\n/// failure-getrandom = \"0.1\"\n/// getrandom = { version = \"0.2\", features = [\"custom\"] }\n/// ```\n///\n/// Then, we register the function in `src/main.rs`:\n/// ```rust\n/// # mod failure_getrandom { pub fn always_fail(_: &mut [u8]) -> Result<(), getrandom::Error> { unimplemented!() } }\n/// use failure_getrandom::always_fail;\n/// use getrandom::register_custom_getrandom;\n///\n/// register_custom_getrandom!(always_fail);\n/// ```\n///\n/// Now any user of `getrandom` (direct or indirect) on this target will use the\n/// registered function. As noted in the\n/// [top-level documentation](index.html#custom-implementations) this\n/// registration only has an effect on unsupported targets.\n#[macro_export]\n#[cfg_attr(docsrs, doc(cfg(feature = \"custom\")))]\nmacro_rules! register_custom_getrandom {\n    ($path:path) => {\n        // We use an extern \"C\" function to get the guarantees of a stable ABI.\n        #[no_mangle]\n        extern \"C\" fn __getrandom_custom(dest: *mut u8, len: usize) -> u32 {\n            let f: fn(&mut [u8]) -> Result<(), ::getrandom::Error> = $path;\n            let slice = unsafe { ::core::slice::from_raw_parts_mut(dest, len) };\n            match f(slice) {\n                Ok(()) => 0,\n                Err(e) => e.code().get(),\n            }\n        }\n    };\n}\n\n#[allow(dead_code)]\npub fn getrandom_inner(dest: &mut [u8]) -> Result<(), Error> {\n    extern \"C\" {\n        fn __getrandom_custom(dest: *mut u8, len: usize) -> u32;\n    }\n    let ret = unsafe { __getrandom_custom(dest.as_mut_ptr(), dest.len()) };\n    match NonZeroU32::new(ret) {\n        None => Ok(()),\n        Some(code) => Err(Error::from(code)),\n    }\n}\n"],["832","// Copyright 2019 Developers of the Rand project.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation for macOS\nuse crate::{\n    use_file,\n    util_libc::{last_os_error, Weak},\n    Error,\n};\nuse core::mem;\n\ntype GetEntropyFn = unsafe extern \"C\" fn(*mut u8, libc::size_t) -> libc::c_int;\n\npub fn getrandom_inner(dest: &mut [u8]) -> Result<(), Error> {\n    static GETENTROPY: Weak = unsafe { Weak::new(\"getentropy\\0\") };\n    if let Some(fptr) = GETENTROPY.ptr() {\n        let func: GetEntropyFn = unsafe { mem::transmute(fptr) };\n        for chunk in dest.chunks_mut(256) {\n            let ret = unsafe { func(chunk.as_mut_ptr(), chunk.len()) };\n            if ret != 0 {\n                return Err(last_os_error());\n            }\n        }\n        Ok(())\n    } else {\n        // We fallback to reading from /dev/random instead of SecRandomCopyBytes\n        // to avoid high startup costs and linking the Security framework.\n        use_file::getrandom_inner(dest)\n    }\n}\n"],["833","// Copyright 2018 Developers of the Rand project.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation for VxWorks\nuse crate::{util_libc::last_os_error, Error};\nuse core::sync::atomic::{AtomicBool, Ordering::Relaxed};\n\npub fn getrandom_inner(dest: &mut [u8]) -> Result<(), Error> {\n    static RNG_INIT: AtomicBool = AtomicBool::new(false);\n    while !RNG_INIT.load(Relaxed) {\n        let ret = unsafe { libc::randSecure() };\n        if ret < 0 {\n            return Err(Error::VXWORKS_RAND_SECURE);\n        } else if ret > 0 {\n            RNG_INIT.store(true, Relaxed);\n            break;\n        }\n        unsafe { libc::usleep(10) };\n    }\n\n    // Prevent overflow of i32\n    for chunk in dest.chunks_mut(i32::max_value() as usize) {\n        let ret = unsafe { libc::randABytes(chunk.as_mut_ptr(), chunk.len() as i32) };\n        if ret != 0 {\n            return Err(last_os_error());\n        }\n    }\n    Ok(())\n}\n"],["834","// Copyright 2019 Developers of the Rand project.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n#![allow(dead_code)]\nuse core::sync::atomic::{AtomicUsize, Ordering::Relaxed};\n\n// This structure represents a lazily initialized static usize value. Useful\n// when it is preferable to just rerun initialization instead of locking.\n// Both unsync_init and sync_init will invoke an init() function until it\n// succeeds, then return the cached value for future calls.\n//\n// Both methods support init() \"failing\". If the init() method returns UNINIT,\n// that value will be returned as normal, but will not be cached.\n//\n// Users should only depend on the _value_ returned by init() functions.\n// Specifically, for the following init() function:\n//      fn init() -> usize {\n//          a();\n//          let v = b();\n//          c();\n//          v\n//      }\n// the effects of c() or writes to shared memory will not necessarily be\n// observed and additional synchronization methods with be needed.\npub struct LazyUsize(AtomicUsize);\n\nimpl LazyUsize {\n    pub const fn new() -> Self {\n        Self(AtomicUsize::new(Self::UNINIT))\n    }\n\n    // The initialization is not completed.\n    pub const UNINIT: usize = usize::max_value();\n\n    // Runs the init() function at least once, returning the value of some run\n    // of init(). Multiple callers can run their init() functions in parallel.\n    // init() should always return the same value, if it succeeds.\n    pub fn unsync_init(&self, init: impl FnOnce() -> usize) -> usize {\n        // Relaxed ordering is fine, as we only have a single atomic variable.\n        let mut val = self.0.load(Relaxed);\n        if val == Self::UNINIT {\n            val = init();\n            self.0.store(val, Relaxed);\n        }\n        val\n    }\n}\n\n// Identical to LazyUsize except with bool instead of usize.\npub struct LazyBool(LazyUsize);\n\nimpl LazyBool {\n    pub const fn new() -> Self {\n        Self(LazyUsize::new())\n    }\n\n    pub fn unsync_init(&self, init: impl FnOnce() -> bool) -> bool {\n        self.0.unsync_init(|| init() as usize) != 0\n    }\n}\n"],["835","// Copyright 2018 Developers of the Rand project.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse crate::Error;\nuse core::{ffi::c_void, num::NonZeroU32, ptr};\n\nconst BCRYPT_USE_SYSTEM_PREFERRED_RNG: u32 = 0x00000002;\n\n#[link(name = \"bcrypt\")]\nextern \"system\" {\n    fn BCryptGenRandom(\n        hAlgorithm: *mut c_void,\n        pBuffer: *mut u8,\n        cbBuffer: u32,\n        dwFlags: u32,\n    ) -> u32;\n}\n\npub fn getrandom_inner(dest: &mut [u8]) -> Result<(), Error> {\n    // Prevent overflow of u32\n    for chunk in dest.chunks_mut(u32::max_value() as usize) {\n        let ret = unsafe {\n            BCryptGenRandom(\n                ptr::null_mut(),\n                chunk.as_mut_ptr(),\n                chunk.len() as u32,\n                BCRYPT_USE_SYSTEM_PREFERRED_RNG,\n            )\n        };\n        // NTSTATUS codes use the two highest bits for severity status.\n        if ret >> 30 == 0b11 {\n            // We zeroize the highest bit, so the error code will reside\n            // inside the range designated for OS codes.\n            let code = ret ^ (1 << 31);\n            // SAFETY: the second highest bit is always equal to one,\n            // so it's impossible to get zero. Unfortunately the type\n            // system does not have a way to express this yet.\n            let code = unsafe { NonZeroU32::new_unchecked(code) };\n            return Err(Error::from(code));\n        }\n    }\n    Ok(())\n}\n"],["836","// Copyright 2018 Developers of the Rand project.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementations that just need to read from a file\nuse crate::{\n    util::LazyUsize,\n    util_libc::{open_readonly, sys_fill_exact},\n    Error,\n};\nuse core::{\n    cell::UnsafeCell,\n    sync::atomic::{AtomicUsize, Ordering::Relaxed},\n};\n\n#[cfg(target_os = \"redox\")]\nconst FILE_PATH: &str = \"rand:\\0\";\n#[cfg(any(\n    target_os = \"dragonfly\",\n    target_os = \"emscripten\",\n    target_os = \"haiku\",\n    target_os = \"macos\",\n    target_os = \"solaris\",\n    target_os = \"illumos\"\n))]\nconst FILE_PATH: &str = \"/dev/random\\0\";\n#[cfg(any(target_os = \"android\", target_os = \"linux\"))]\nconst FILE_PATH: &str = \"/dev/urandom\\0\";\n\npub fn getrandom_inner(dest: &mut [u8]) -> Result<(), Error> {\n    let fd = get_rng_fd()?;\n    let read = |buf: &mut [u8]| unsafe { libc::read(fd, buf.as_mut_ptr() as *mut _, buf.len()) };\n\n    if cfg!(target_os = \"emscripten\") {\n        // `Crypto.getRandomValues` documents `dest` should be at most 65536 bytes.\n        for chunk in dest.chunks_mut(65536) {\n            sys_fill_exact(chunk, read)?;\n        }\n    } else {\n        sys_fill_exact(dest, read)?;\n    }\n    Ok(())\n}\n\n// Returns the file descriptor for the device file used to retrieve random\n// bytes. The file will be opened exactly once. All successful calls will\n// return the same file descriptor. This file descriptor is never closed.\nfn get_rng_fd() -> Result<libc::c_int, Error> {\n    static FD: AtomicUsize = AtomicUsize::new(LazyUsize::UNINIT);\n    fn get_fd() -> Option<libc::c_int> {\n        match FD.load(Relaxed) {\n            LazyUsize::UNINIT => None,\n            val => Some(val as libc::c_int),\n        }\n    }\n\n    // Use double-checked locking to avoid acquiring the lock if possible.\n    if let Some(fd) = get_fd() {\n        return Ok(fd);\n    }\n\n    // SAFETY: We use the mutex only in this method, and we always unlock it\n    // before returning, making sure we don't violate the pthread_mutex_t API.\n    static MUTEX: Mutex = Mutex::new();\n    unsafe { MUTEX.lock() };\n    let _guard = DropGuard(|| unsafe { MUTEX.unlock() });\n\n    if let Some(fd) = get_fd() {\n        return Ok(fd);\n    }\n\n    // On Linux, /dev/urandom might return insecure values.\n    #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n    wait_until_rng_ready()?;\n\n    let fd = unsafe { open_readonly(FILE_PATH)? };\n    // The fd always fits in a usize without conflicting with UNINIT.\n    debug_assert!(fd >= 0 && (fd as usize) < LazyUsize::UNINIT);\n    FD.store(fd as usize, Relaxed);\n\n    Ok(fd)\n}\n\n// Succeeds once /dev/urandom is safe to read from\n#[cfg(any(target_os = \"android\", target_os = \"linux\"))]\nfn wait_until_rng_ready() -> Result<(), Error> {\n    // Poll /dev/random to make sure it is ok to read from /dev/urandom.\n    let fd = unsafe { open_readonly(\"/dev/random\\0\")? };\n    let mut pfd = libc::pollfd {\n        fd,\n        events: libc::POLLIN,\n        revents: 0,\n    };\n    let _guard = DropGuard(|| unsafe {\n        libc::close(fd);\n    });\n\n    loop {\n        // A negative timeout means an infinite timeout.\n        let res = unsafe { libc::poll(&mut pfd, 1, -1) };\n        if res >= 0 {\n            debug_assert_eq!(res, 1); // We only used one fd, and cannot timeout.\n            return Ok(());\n        }\n        let err = crate::util_libc::last_os_error();\n        match err.raw_os_error() {\n            Some(libc::EINTR) | Some(libc::EAGAIN) => continue,\n            _ => return Err(err),\n        }\n    }\n}\n\nstruct Mutex(UnsafeCell<libc::pthread_mutex_t>);\n\nimpl Mutex {\n    const fn new() -> Self {\n        Self(UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER))\n    }\n    unsafe fn lock(&self) {\n        let r = libc::pthread_mutex_lock(self.0.get());\n        debug_assert_eq!(r, 0);\n    }\n    unsafe fn unlock(&self) {\n        let r = libc::pthread_mutex_unlock(self.0.get());\n        debug_assert_eq!(r, 0);\n    }\n}\n\nunsafe impl Sync for Mutex {}\n\nstruct DropGuard<F: FnMut()>(F);\n\nimpl<F: FnMut()> Drop for DropGuard<F> {\n    fn drop(&mut self) {\n        self.0()\n    }\n}\n"],["837","// Copyright 2019 Developers of the Rand project.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n#![allow(dead_code)]\nuse crate::{util::LazyUsize, Error};\nuse core::{num::NonZeroU32, ptr::NonNull};\n\ncfg_if! {\n    if #[cfg(any(target_os = \"netbsd\", target_os = \"openbsd\", target_os = \"android\"))] {\n        use libc::__errno as errno_location;\n    } else if #[cfg(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"redox\"))] {\n        use libc::__errno_location as errno_location;\n    } else if #[cfg(any(target_os = \"solaris\", target_os = \"illumos\"))] {\n        use libc::___errno as errno_location;\n    } else if #[cfg(any(target_os = \"macos\", target_os = \"freebsd\"))] {\n        use libc::__error as errno_location;\n    } else if #[cfg(target_os = \"haiku\")] {\n        use libc::_errnop as errno_location;\n    }\n}\n\ncfg_if! {\n    if #[cfg(target_os = \"vxworks\")] {\n        use libc::errnoGet as get_errno;\n    } else if #[cfg(target_os = \"dragonfly\")] {\n        // Until rust-lang/rust#29594 is stable, we cannot get the errno value\n        // on DragonFlyBSD. So we just return an out-of-range errno.\n        unsafe fn get_errno() -> libc::c_int { -1 }\n    } else {\n        unsafe fn get_errno() -> libc::c_int { *errno_location() }\n    }\n}\n\npub fn last_os_error() -> Error {\n    let errno = unsafe { get_errno() };\n    if errno > 0 {\n        Error::from(NonZeroU32::new(errno as u32).unwrap())\n    } else {\n        Error::ERRNO_NOT_POSITIVE\n    }\n}\n\n// Fill a buffer by repeatedly invoking a system call. The `sys_fill` function:\n//   - should return -1 and set errno on failure\n//   - should return the number of bytes written on success\npub fn sys_fill_exact(\n    mut buf: &mut [u8],\n    sys_fill: impl Fn(&mut [u8]) -> libc::ssize_t,\n) -> Result<(), Error> {\n    while !buf.is_empty() {\n        let res = sys_fill(buf);\n        if res < 0 {\n            let err = last_os_error();\n            // We should try again if the call was interrupted.\n            if err.raw_os_error() != Some(libc::EINTR) {\n                return Err(err);\n            }\n        } else {\n            // We don't check for EOF (ret = 0) as the data we are reading\n            // should be an infinite stream of random bytes.\n            buf = &mut buf[(res as usize)..];\n        }\n    }\n    Ok(())\n}\n\n// A \"weak\" binding to a C function that may or may not be present at runtime.\n// Used for supporting newer OS features while still building on older systems.\n// F must be a function pointer of type `unsafe extern \"C\" fn`. Based off of the\n// weak! macro in libstd.\npub struct Weak {\n    name: &'static str,\n    addr: LazyUsize,\n}\n\nimpl Weak {\n    // Construct a binding to a C function with a given name. This function is\n    // unsafe because `name` _must_ be null terminated.\n    pub const unsafe fn new(name: &'static str) -> Self {\n        Self {\n            name,\n            addr: LazyUsize::new(),\n        }\n    }\n\n    // Return a function pointer if present at runtime. Otherwise, return null.\n    pub fn ptr(&self) -> Option<NonNull<libc::c_void>> {\n        let addr = self.addr.unsync_init(|| unsafe {\n            libc::dlsym(libc::RTLD_DEFAULT, self.name.as_ptr() as *const _) as usize\n        });\n        NonNull::new(addr as *mut _)\n    }\n}\n\ncfg_if! {\n    if #[cfg(any(target_os = \"linux\", target_os = \"emscripten\"))] {\n        use libc::open64 as open;\n    } else {\n        use libc::open;\n    }\n}\n\n// SAFETY: path must be null terminated, FD must be manually closed.\npub unsafe fn open_readonly(path: &str) -> Result<libc::c_int, Error> {\n    debug_assert_eq!(path.as_bytes().last(), Some(&0));\n    let fd = open(path.as_ptr() as *const _, libc::O_RDONLY | libc::O_CLOEXEC);\n    if fd < 0 {\n        return Err(last_os_error());\n    }\n    Ok(fd)\n}\n"],["838","// Copyright 2018 Developers of the Rand project.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\nuse core::{fmt, num::NonZeroU32};\n\n/// A small and `no_std` compatible error type\n///\n/// The [`Error::raw_os_error()`] will indicate if the error is from the OS, and\n/// if so, which error code the OS gave the application. If such an error is\n/// encountered, please consult with your system documentation.\n///\n/// Internally this type is a NonZeroU32, with certain values reserved for\n/// certain purposes, see [`Error::INTERNAL_START`] and [`Error::CUSTOM_START`].\n///\n/// *If this crate's `\"std\"` Cargo feature is enabled*, then:\n/// - [`getrandom::Error`][Error] implements\n///   [`std::error::Error`](https://doc.rust-lang.org/std/error/trait.Error.html)\n/// - [`std::io::Error`](https://doc.rust-lang.org/std/io/struct.Error.html) implements\n///   [`From<getrandom::Error>`](https://doc.rust-lang.org/std/convert/trait.From.html).\n#[derive(Copy, Clone, Eq, PartialEq)]\npub struct Error(NonZeroU32);\n\nconst fn internal_error(n: u16) -> Error {\n    // SAFETY: code > 0 as INTERNAL_START > 0 and adding n won't overflow a u32.\n    let code = Error::INTERNAL_START + (n as u32);\n    Error(unsafe { NonZeroU32::new_unchecked(code) })\n}\n\nimpl Error {\n    /// This target/platform is not supported by `getrandom`.\n    pub const UNSUPPORTED: Error = internal_error(0);\n    /// The platform-specific `errno` returned a non-positive value.\n    pub const ERRNO_NOT_POSITIVE: Error = internal_error(1);\n    /// Call to iOS [`SecRandomCopyBytes`](https://developer.apple.com/documentation/security/1399291-secrandomcopybytes) failed.\n    pub const IOS_SEC_RANDOM: Error = internal_error(3);\n    /// Call to Windows [`RtlGenRandom`](https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom) failed.\n    pub const WINDOWS_RTL_GEN_RANDOM: Error = internal_error(4);\n    /// RDRAND instruction failed due to a hardware issue.\n    pub const FAILED_RDRAND: Error = internal_error(5);\n    /// RDRAND instruction unsupported on this target.\n    pub const NO_RDRAND: Error = internal_error(6);\n    /// The browser does not have support for `self.crypto`.\n    pub const WEB_CRYPTO: Error = internal_error(7);\n    /// The browser does not have support for `crypto.getRandomValues`.\n    pub const WEB_GET_RANDOM_VALUES: Error = internal_error(8);\n    /// On VxWorks, call to `randSecure` failed (random number generator is not yet initialized).\n    pub const VXWORKS_RAND_SECURE: Error = internal_error(11);\n    /// NodeJS does not have support for the `crypto` module.\n    pub const NODE_CRYPTO: Error = internal_error(12);\n    /// NodeJS does not have support for `crypto.randomFillSync`.\n    pub const NODE_RANDOM_FILL_SYNC: Error = internal_error(13);\n\n    /// Codes below this point represent OS Errors (i.e. positive i32 values).\n    /// Codes at or above this point, but below [`Error::CUSTOM_START`] are\n    /// reserved for use by the `rand` and `getrandom` crates.\n    pub const INTERNAL_START: u32 = 1 << 31;\n\n    /// Codes at or above this point can be used by users to define their own\n    /// custom errors.\n    pub const CUSTOM_START: u32 = (1 << 31) + (1 << 30);\n\n    /// Extract the raw OS error code (if this error came from the OS)\n    ///\n    /// This method is identical to [`std::io::Error::raw_os_error()`][1], except\n    /// that it works in `no_std` contexts. If this method returns `None`, the\n    /// error value can still be formatted via the `Display` implementation.\n    ///\n    /// [1]: https://doc.rust-lang.org/std/io/struct.Error.html#method.raw_os_error\n    #[inline]\n    pub fn raw_os_error(self) -> Option<i32> {\n        if self.0.get() < Self::INTERNAL_START {\n            Some(self.0.get() as i32)\n        } else {\n            None\n        }\n    }\n\n    /// Extract the bare error code.\n    ///\n    /// This code can either come from the underlying OS, or be a custom error.\n    /// Use [`Error::raw_os_error()`] to disambiguate.\n    #[inline]\n    pub const fn code(self) -> NonZeroU32 {\n        self.0\n    }\n}\n\ncfg_if! {\n    if #[cfg(unix)] {\n        fn os_err(errno: i32, buf: &mut [u8]) -> Option<&str> {\n            let buf_ptr = buf.as_mut_ptr() as *mut libc::c_char;\n            if unsafe { libc::strerror_r(errno, buf_ptr, buf.len()) } != 0 {\n                return None;\n            }\n\n            // Take up to trailing null byte\n            let n = buf.len();\n            let idx = buf.iter().position(|&b| b == 0).unwrap_or(n);\n            core::str::from_utf8(&buf[..idx]).ok()\n        }\n    } else if #[cfg(target_os = \"wasi\")] {\n        fn os_err(errno: i32, _buf: &mut [u8]) -> Option<wasi::Error> {\n            wasi::Error::from_raw_error(errno as _)\n        }\n    } else {\n        fn os_err(_errno: i32, _buf: &mut [u8]) -> Option<&str> {\n            None\n        }\n    }\n}\n\nimpl fmt::Debug for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut dbg = f.debug_struct(\"Error\");\n        if let Some(errno) = self.raw_os_error() {\n            dbg.field(\"os_error\", &errno);\n            let mut buf = [0u8; 128];\n            if let Some(err) = os_err(errno, &mut buf) {\n                dbg.field(\"description\", &err);\n            }\n        } else if let Some(desc) = internal_desc(*self) {\n            dbg.field(\"internal_code\", &self.0.get());\n            dbg.field(\"description\", &desc);\n        } else {\n            dbg.field(\"unknown_code\", &self.0.get());\n        }\n        dbg.finish()\n    }\n}\n\nimpl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if let Some(errno) = self.raw_os_error() {\n            let mut buf = [0u8; 128];\n            match os_err(errno, &mut buf) {\n                Some(err) => err.fmt(f),\n                None => write!(f, \"OS Error: {}\", errno),\n            }\n        } else if let Some(desc) = internal_desc(*self) {\n            f.write_str(desc)\n        } else {\n            write!(f, \"Unknown Error: {}\", self.0.get())\n        }\n    }\n}\n\nimpl From<NonZeroU32> for Error {\n    fn from(code: NonZeroU32) -> Self {\n        Self(code)\n    }\n}\n\nfn internal_desc(error: Error) -> Option<&'static str> {\n    match error {\n        Error::UNSUPPORTED => Some(\"getrandom: this target is not supported\"),\n        Error::ERRNO_NOT_POSITIVE => Some(\"errno: did not return a positive value\"),\n        Error::IOS_SEC_RANDOM => Some(\"SecRandomCopyBytes: iOS Security framework failure\"),\n        Error::WINDOWS_RTL_GEN_RANDOM => Some(\"RtlGenRandom: Windows system function failure\"),\n        Error::FAILED_RDRAND => Some(\"RDRAND: failed multiple times: CPU issue likely\"),\n        Error::NO_RDRAND => Some(\"RDRAND: instruction not supported\"),\n        Error::WEB_CRYPTO => Some(\"Web Crypto API is unavailable\"),\n        Error::WEB_GET_RANDOM_VALUES => Some(\"Web API crypto.getRandomValues is unavailable\"),\n        Error::VXWORKS_RAND_SECURE => Some(\"randSecure: VxWorks RNG module is not initialized\"),\n        Error::NODE_CRYPTO => Some(\"Node.js crypto module is unavailable\"),\n        Error::NODE_RANDOM_FILL_SYNC => Some(\"Node.js API crypto.randomFillSync is unavailable\"),\n        _ => None,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Error;\n    use core::mem::size_of;\n\n    #[test]\n    fn test_size() {\n        assert_eq!(size_of::<Error>(), 4);\n        assert_eq!(size_of::<Result<(), Error>>(), 4);\n    }\n}\n"],["839","// Copyright 2018 Developers of the Rand project.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation for OpenBSD\nuse crate::{util_libc::last_os_error, Error};\n\npub fn getrandom_inner(dest: &mut [u8]) -> Result<(), Error> {\n    for chunk in dest.chunks_mut(256) {\n        let ret = unsafe { libc::getentropy(chunk.as_mut_ptr() as *mut libc::c_void, chunk.len()) };\n        if ret == -1 {\n            return Err(last_os_error());\n        }\n    }\n    Ok(())\n}\n"],["840","//! Contains utility functions and traits to convert between slices of `u16` bits and `f16` or\n//! `bf16` numbers.\n//!\n//! The utility [`HalfBitsSliceExt`] sealed extension trait is implemented for `[u16]` slices,\n//! while the utility [`HalfFloatSliceExt`] sealed extension trait is implemented for both `[f16]`\n//! and `[bf16]` slices. These traits provide efficient conversions and reinterpret casting of\n//! larger buffers of floating point values, and are automatically included in the [`prelude`]\n//! module.\n//!\n//! [`HalfBitsSliceExt`]: trait.HalfBitsSliceExt.html\n//! [`HalfFloatSliceExt`]: trait.HalfFloatSliceExt.html\n//! [`prelude`]: ../prelude/index.html\n\nuse crate::{bf16, binary16::convert, f16};\nuse core::slice;\n\n#[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\nuse alloc::vec::Vec;\n\n/// Extensions to `[f16]` and `[bf16]` slices to support conversion and reinterpret operations.\n///\n/// This trait is sealed and cannot be implemented outside of this crate.\npub trait HalfFloatSliceExt: private::SealedHalfFloatSlice {\n    /// Reinterpret a slice of [`f16`](../struct.f16.html) or [`bf16`](../struct.bf16.html)\n    /// numbers as a slice of `u16` bits.\n    ///\n    /// This is a zero-copy operation. The reinterpreted slice has the same lifetime and memory\n    /// location as `self`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    /// let float_buffer = [f16::from_f32(1.), f16::from_f32(2.), f16::from_f32(3.)];\n    /// let int_buffer = float_buffer.reinterpret_cast();\n    ///\n    /// assert_eq!(int_buffer, [float_buffer[0].to_bits(), float_buffer[1].to_bits(), float_buffer[2].to_bits()]);\n    /// ```\n    fn reinterpret_cast(&self) -> &[u16];\n\n    /// Reinterpret a mutable slice of [`f16`](../struct.f16.html) or\n    /// [`bf16`](../struct.bf16.html) numbers as a mutable slice of `u16` bits.\n    ///\n    /// This is a zero-copy operation. The transmuted slice has the same lifetime as the original,\n    /// which prevents mutating `self` as long as the returned `&mut [u16]` is borrowed.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    /// let mut float_buffer = [f16::from_f32(1.), f16::from_f32(2.), f16::from_f32(3.)];\n    ///\n    /// {\n    ///     let int_buffer = float_buffer.reinterpret_cast_mut();\n    ///\n    ///     assert_eq!(int_buffer, [f16::from_f32(1.).to_bits(), f16::from_f32(2.).to_bits(), f16::from_f32(3.).to_bits()]);\n    ///\n    ///     // Mutating the u16 slice will mutating the original\n    ///     int_buffer[0] = 0;\n    /// }\n    ///\n    /// // Note that we need to drop int_buffer before using float_buffer again or we will get a borrow error.\n    /// assert_eq!(float_buffer, [f16::from_f32(0.), f16::from_f32(2.), f16::from_f32(3.)]);\n    /// ```\n    fn reinterpret_cast_mut(&mut self) -> &mut [u16];\n\n    /// Convert all of the elements of a `[f32]` slice into [`f16`](../struct.f16.html) or\n    /// [`bf16`](../struct.bf16.html) values in `self`.\n    ///\n    /// The length of `src` must be the same as `self`.\n    ///\n    /// The conversion operation is vectorized over the slice, meaning the conversion may be more\n    /// efficient than converting individual elements on some hardware that supports SIMD\n    /// conversions. See [crate documentation](../index.html) for more information on hardware\n    /// conversion support.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the two slices have different lengths.\n    ///\n    /// # Examples\n    /// ```rust\n    /// # use half::prelude::*;\n    /// // Initialize an empty buffer\n    /// let mut buffer = [0u16; 4];\n    /// let buffer = buffer.reinterpret_cast_mut::<f16>();\n    ///\n    /// let float_values = [1., 2., 3., 4.];\n    ///\n    /// // Now convert\n    /// buffer.convert_from_f32_slice(&float_values);\n    ///\n    /// assert_eq!(buffer, [f16::from_f32(1.), f16::from_f32(2.), f16::from_f32(3.), f16::from_f32(4.)]);\n    /// ```\n    fn convert_from_f32_slice(&mut self, src: &[f32]);\n\n    /// Convert all of the elements of a `[f64]` slice into [`f16`](../struct.f16.html) or\n    /// [`bf16`](../struct.bf16.html) values in `self`.\n    ///\n    /// The length of `src` must be the same as `self`.\n    ///\n    /// The conversion operation is vectorized over the slice, meaning the conversion may be more\n    /// efficient than converting individual elements on some hardware that supports SIMD\n    /// conversions. See [crate documentation](../index.html) for more information on hardware\n    /// conversion support.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the two slices have different lengths.\n    ///\n    /// # Examples\n    /// ```rust\n    /// # use half::prelude::*;\n    /// // Initialize an empty buffer\n    /// let mut buffer = [0u16; 4];\n    /// let buffer = buffer.reinterpret_cast_mut::<f16>();\n    ///\n    /// let float_values = [1., 2., 3., 4.];\n    ///\n    /// // Now convert\n    /// buffer.convert_from_f64_slice(&float_values);\n    ///\n    /// assert_eq!(buffer, [f16::from_f64(1.), f16::from_f64(2.), f16::from_f64(3.), f16::from_f64(4.)]);\n    /// ```\n    fn convert_from_f64_slice(&mut self, src: &[f64]);\n\n    /// Convert all of the [`f16`](../struct.f16.html) or [`bf16`](../struct.bf16.html)\n    /// elements of `self` into `f32` values in `dst`.\n    ///\n    /// The length of `src` must be the same as `self`.\n    ///\n    /// The conversion operation is vectorized over the slice, meaning the conversion may be more\n    /// efficient than converting individual elements on some hardware that supports SIMD\n    /// conversions. See [crate documentation](../index.html) for more information on hardware\n    /// conversion support.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the two slices have different lengths.\n    ///\n    /// # Examples\n    /// ```rust\n    /// # use half::prelude::*;\n    /// // Initialize an empty buffer\n    /// let mut buffer = [0f32; 4];\n    ///\n    /// let half_values = [f16::from_f32(1.), f16::from_f32(2.), f16::from_f32(3.), f16::from_f32(4.)];\n    ///\n    /// // Now convert\n    /// half_values.convert_to_f32_slice(&mut buffer);\n    ///\n    /// assert_eq!(buffer, [1., 2., 3., 4.]);\n    /// ```\n    fn convert_to_f32_slice(&self, dst: &mut [f32]);\n\n    /// Convert all of the [`f16`](../struct.f16.html) or [`bf16`](../struct.bf16.html)\n    /// elements of `self` into `f64` values in `dst`.\n    ///\n    /// The length of `src` must be the same as `self`.\n    ///\n    /// The conversion operation is vectorized over the slice, meaning the conversion may be more\n    /// efficient than converting individual elements on some hardware that supports SIMD\n    /// conversions. See [crate documentation](../index.html) for more information on hardware\n    /// conversion support.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the two slices have different lengths.\n    ///\n    /// # Examples\n    /// ```rust\n    /// # use half::prelude::*;\n    /// // Initialize an empty buffer\n    /// let mut buffer = [0f64; 4];\n    ///\n    /// let half_values = [f16::from_f64(1.), f16::from_f64(2.), f16::from_f64(3.), f16::from_f64(4.)];\n    ///\n    /// // Now convert\n    /// half_values.convert_to_f64_slice(&mut buffer);\n    ///\n    /// assert_eq!(buffer, [1., 2., 3., 4.]);\n    /// ```\n    fn convert_to_f64_slice(&self, dst: &mut [f64]);\n\n    // Because trait is sealed, we can get away with different interfaces between features\n\n    #[cfg(any(feature = \"alloc\", feature = \"std\"))]\n    /// Convert all of the [`f16`](../struct.f16.html) or [`bf16`](../struct.bf16.html)\n    /// elements of `self` into `f32` values in a new vector.\n    ///\n    /// The conversion operation is vectorized over the slice, meaning the conversion may be more\n    /// efficient than converting individual elements on some hardware that supports SIMD\n    /// conversions. See [crate documentation](../index.html) for more information on hardware\n    /// conversion support.\n    ///\n    /// This method is only available with the `std` or `alloc` feature.\n    ///\n    /// # Examples\n    /// ```rust\n    /// # use half::prelude::*;\n    /// let half_values = [f16::from_f32(1.), f16::from_f32(2.), f16::from_f32(3.), f16::from_f32(4.)];\n    /// let vec = half_values.to_f32_vec();\n    ///\n    /// assert_eq!(vec, vec![1., 2., 3., 4.]);\n    /// ```\n    fn to_f32_vec(&self) -> Vec<f32>;\n\n    /// Convert all of the [`f16`](../struct.f16.html) or [`bf16`](../struct.bf16.html)\n    /// elements of `self` into `f64` values in a new vector.\n    ///\n    /// The conversion operation is vectorized over the slice, meaning the conversion may be more\n    /// efficient than converting individual elements on some hardware that supports SIMD\n    /// conversions. See [crate documentation](../index.html) for more information on hardware\n    /// conversion support.\n    ///\n    /// This method is only available with the `std` or `alloc` feature.\n    ///\n    /// # Examples\n    /// ```rust\n    /// # use half::prelude::*;\n    /// let half_values = [f16::from_f64(1.), f16::from_f64(2.), f16::from_f64(3.), f16::from_f64(4.)];\n    /// let vec = half_values.to_f64_vec();\n    ///\n    /// assert_eq!(vec, vec![1., 2., 3., 4.]);\n    /// ```\n    #[cfg(any(feature = \"alloc\", feature = \"std\"))]\n    fn to_f64_vec(&self) -> Vec<f64>;\n}\n\n/// Extensions to `[u16]` slices to support reinterpret operations.\n///\n/// This trait is sealed and cannot be implemented outside of this crate.\npub trait HalfBitsSliceExt: private::SealedHalfBitsSlice {\n    /// Reinterpret a slice of `u16` bits as a slice of [`f16`](../struct.f16.html) or\n    /// [`bf16`](../struct.bf16.html) numbers.\n    ///\n    /// `H` is the type to cast to, and must be either the [`f16`](../struct.f16.html) or\n    /// [`bf16`](../struct.bf16.html) type.\n    ///\n    /// This is a zero-copy operation. The reinterpreted slice has the same lifetime and memory\n    /// location as `self`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    /// let int_buffer = [f16::from_f32(1.).to_bits(), f16::from_f32(2.).to_bits(), f16::from_f32(3.).to_bits()];\n    /// let float_buffer: &[f16] = int_buffer.reinterpret_cast();\n    ///\n    /// assert_eq!(float_buffer, [f16::from_f32(1.), f16::from_f32(2.), f16::from_f32(3.)]);\n    ///\n    /// // You may have to specify the cast type directly if the compiler can't infer the type.\n    /// // The following is also valid in Rust.\n    /// let typed_buffer = int_buffer.reinterpret_cast::<f16>();\n    /// ```\n    fn reinterpret_cast<H>(&self) -> &[H]\n    where\n        H: crate::private::SealedHalf;\n\n    /// Reinterpret a mutable slice of `u16` bits as a mutable slice of [`f16`](../struct.f16.html)\n    /// or [`bf16`](../struct.bf16.html)  numbers.\n    ///\n    /// `H` is the type to cast to, and must be either the [`f16`](../struct.f16.html) or\n    /// [`bf16`](../struct.bf16.html) type.\n    ///\n    /// This is a zero-copy operation. The transmuted slice has the same lifetime as the original,\n    /// which prevents mutating `self` as long as the returned `&mut [f16]` is borrowed.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    /// let mut int_buffer = [f16::from_f32(1.).to_bits(), f16::from_f32(2.).to_bits(), f16::from_f32(3.).to_bits()];\n    ///\n    /// {\n    ///     let float_buffer: &mut [f16] = int_buffer.reinterpret_cast_mut();\n    ///\n    ///     assert_eq!(float_buffer, [f16::from_f32(1.), f16::from_f32(2.), f16::from_f32(3.)]);\n    ///\n    ///     // Mutating the f16 slice will mutating the original\n    ///     float_buffer[0] = f16::from_f32(0.);\n    /// }\n    ///\n    /// // Note that we need to drop float_buffer before using int_buffer again or we will get a borrow error.\n    /// assert_eq!(int_buffer, [f16::from_f32(0.).to_bits(), f16::from_f32(2.).to_bits(), f16::from_f32(3.).to_bits()]);\n    ///\n    /// // You may have to specify the cast type directly if the compiler can't infer the type.\n    /// // The following is also valid in Rust.\n    /// let typed_buffer = int_buffer.reinterpret_cast_mut::<f16>();\n    /// ```\n    fn reinterpret_cast_mut<H>(&mut self) -> &mut [H]\n    where\n        H: crate::private::SealedHalf;\n}\n\nmod private {\n    use crate::{bf16, f16};\n\n    pub trait SealedHalfFloatSlice {}\n    impl SealedHalfFloatSlice for [f16] {}\n    impl SealedHalfFloatSlice for [bf16] {}\n\n    pub trait SealedHalfBitsSlice {}\n    impl SealedHalfBitsSlice for [u16] {}\n}\n\nimpl HalfFloatSliceExt for [f16] {\n    #[inline]\n    fn reinterpret_cast(&self) -> &[u16] {\n        let pointer = self.as_ptr() as *const u16;\n        let length = self.len();\n        // SAFETY: We are reconstructing full length of original slice, using its same lifetime,\n        // and the size of elements are identical\n        unsafe { slice::from_raw_parts(pointer, length) }\n    }\n\n    #[inline]\n    fn reinterpret_cast_mut(&mut self) -> &mut [u16] {\n        let pointer = self.as_ptr() as *mut u16;\n        let length = self.len();\n        // SAFETY: We are reconstructing full length of original slice, using its same lifetime,\n        // and the size of elements are identical\n        unsafe { slice::from_raw_parts_mut(pointer, length) }\n    }\n\n    fn convert_from_f32_slice(&mut self, src: &[f32]) {\n        assert_eq!(\n            self.len(),\n            src.len(),\n            \"destination and source slices have different lengths\"\n        );\n\n        let mut chunks = src.chunks_exact(4);\n        let mut chunk_count = 0usize; // Not using .enumerate() because we need this value for remainder\n        for chunk in &mut chunks {\n            let vec = convert::f32x4_to_f16x4(chunk);\n            let dst_idx = chunk_count * 4;\n            self[dst_idx..dst_idx + 4].copy_from_slice(vec.reinterpret_cast());\n            chunk_count += 1;\n        }\n\n        // Process remainder\n        if !chunks.remainder().is_empty() {\n            let mut buf = [0f32; 4];\n            buf[..chunks.remainder().len()].copy_from_slice(chunks.remainder());\n            let vec = convert::f32x4_to_f16x4(&buf);\n            let dst_idx = chunk_count * 4;\n            self[dst_idx..dst_idx + chunks.remainder().len()]\n                .copy_from_slice(vec[..chunks.remainder().len()].reinterpret_cast());\n        }\n    }\n\n    fn convert_from_f64_slice(&mut self, src: &[f64]) {\n        assert_eq!(\n            self.len(),\n            src.len(),\n            \"destination and source slices have different lengths\"\n        );\n\n        let mut chunks = src.chunks_exact(4);\n        let mut chunk_count = 0usize; // Not using .enumerate() because we need this value for remainder\n        for chunk in &mut chunks {\n            let vec = convert::f64x4_to_f16x4(chunk);\n            let dst_idx = chunk_count * 4;\n            self[dst_idx..dst_idx + 4].copy_from_slice(vec.reinterpret_cast());\n            chunk_count += 1;\n        }\n\n        // Process remainder\n        if !chunks.remainder().is_empty() {\n            let mut buf = [0f64; 4];\n            buf[..chunks.remainder().len()].copy_from_slice(chunks.remainder());\n            let vec = convert::f64x4_to_f16x4(&buf);\n            let dst_idx = chunk_count * 4;\n            self[dst_idx..dst_idx + chunks.remainder().len()]\n                .copy_from_slice(vec[..chunks.remainder().len()].reinterpret_cast());\n        }\n    }\n\n    fn convert_to_f32_slice(&self, dst: &mut [f32]) {\n        assert_eq!(\n            self.len(),\n            dst.len(),\n            \"destination and source slices have different lengths\"\n        );\n\n        let mut chunks = self.chunks_exact(4);\n        let mut chunk_count = 0usize; // Not using .enumerate() because we need this value for remainder\n        for chunk in &mut chunks {\n            let vec = convert::f16x4_to_f32x4(chunk.reinterpret_cast());\n            let dst_idx = chunk_count * 4;\n            dst[dst_idx..dst_idx + 4].copy_from_slice(&vec);\n            chunk_count += 1;\n        }\n\n        // Process remainder\n        if !chunks.remainder().is_empty() {\n            let mut buf = [0u16; 4];\n            buf[..chunks.remainder().len()].copy_from_slice(chunks.remainder().reinterpret_cast());\n            let vec = convert::f16x4_to_f32x4(&buf);\n            let dst_idx = chunk_count * 4;\n            dst[dst_idx..dst_idx + chunks.remainder().len()]\n                .copy_from_slice(&vec[..chunks.remainder().len()]);\n        }\n    }\n\n    fn convert_to_f64_slice(&self, dst: &mut [f64]) {\n        assert_eq!(\n            self.len(),\n            dst.len(),\n            \"destination and source slices have different lengths\"\n        );\n\n        let mut chunks = self.chunks_exact(4);\n        let mut chunk_count = 0usize; // Not using .enumerate() because we need this value for remainder\n        for chunk in &mut chunks {\n            let vec = convert::f16x4_to_f64x4(chunk.reinterpret_cast());\n            let dst_idx = chunk_count * 4;\n            dst[dst_idx..dst_idx + 4].copy_from_slice(&vec);\n            chunk_count += 1;\n        }\n\n        // Process remainder\n        if !chunks.remainder().is_empty() {\n            let mut buf = [0u16; 4];\n            buf[..chunks.remainder().len()].copy_from_slice(chunks.remainder().reinterpret_cast());\n            let vec = convert::f16x4_to_f64x4(&buf);\n            let dst_idx = chunk_count * 4;\n            dst[dst_idx..dst_idx + chunks.remainder().len()]\n                .copy_from_slice(&vec[..chunks.remainder().len()]);\n        }\n    }\n\n    #[cfg(any(feature = \"alloc\", feature = \"std\"))]\n    #[inline]\n    fn to_f32_vec(&self) -> Vec<f32> {\n        let mut vec = Vec::with_capacity(self.len());\n        // SAFETY: convert will initialize every value in the vector without reading them,\n        // so this is safe to do instead of double initialize from resize, and we're setting it to\n        // same value as capacity.\n        unsafe { vec.set_len(self.len()) };\n        self.convert_to_f32_slice(&mut vec);\n        vec\n    }\n\n    #[cfg(any(feature = \"alloc\", feature = \"std\"))]\n    #[inline]\n    fn to_f64_vec(&self) -> Vec<f64> {\n        let mut vec = Vec::with_capacity(self.len());\n        // SAFETY: convert will initialize every value in the vector without reading them,\n        // so this is safe to do instead of double initialize from resize, and we're setting it to\n        // same value as capacity.\n        unsafe { vec.set_len(self.len()) };\n        self.convert_to_f64_slice(&mut vec);\n        vec\n    }\n}\n\nimpl HalfFloatSliceExt for [bf16] {\n    #[inline]\n    fn reinterpret_cast(&self) -> &[u16] {\n        let pointer = self.as_ptr() as *const u16;\n        let length = self.len();\n        // SAFETY: We are reconstructing full length of original slice, using its same lifetime,\n        // and the size of elements are identical\n        unsafe { slice::from_raw_parts(pointer, length) }\n    }\n\n    #[inline]\n    fn reinterpret_cast_mut(&mut self) -> &mut [u16] {\n        let pointer = self.as_ptr() as *mut u16;\n        let length = self.len();\n        // SAFETY: We are reconstructing full length of original slice, using its same lifetime,\n        // and the size of elements are identical\n        unsafe { slice::from_raw_parts_mut(pointer, length) }\n    }\n\n    fn convert_from_f32_slice(&mut self, src: &[f32]) {\n        assert_eq!(\n            self.len(),\n            src.len(),\n            \"destination and source slices have different lengths\"\n        );\n\n        // Just use regular loop here until there's any bf16 SIMD support.\n        for (i, f) in src.iter().enumerate() {\n            self[i] = bf16::from_f32(*f);\n        }\n    }\n\n    fn convert_from_f64_slice(&mut self, src: &[f64]) {\n        assert_eq!(\n            self.len(),\n            src.len(),\n            \"destination and source slices have different lengths\"\n        );\n\n        // Just use regular loop here until there's any bf16 SIMD support.\n        for (i, f) in src.iter().enumerate() {\n            self[i] = bf16::from_f64(*f);\n        }\n    }\n\n    fn convert_to_f32_slice(&self, dst: &mut [f32]) {\n        assert_eq!(\n            self.len(),\n            dst.len(),\n            \"destination and source slices have different lengths\"\n        );\n\n        // Just use regular loop here until there's any bf16 SIMD support.\n        for (i, f) in self.iter().enumerate() {\n            dst[i] = f.to_f32();\n        }\n    }\n\n    fn convert_to_f64_slice(&self, dst: &mut [f64]) {\n        assert_eq!(\n            self.len(),\n            dst.len(),\n            \"destination and source slices have different lengths\"\n        );\n\n        // Just use regular loop here until there's any bf16 SIMD support.\n        for (i, f) in self.iter().enumerate() {\n            dst[i] = f.to_f64();\n        }\n    }\n\n    #[cfg(any(feature = \"alloc\", feature = \"std\"))]\n    #[inline]\n    fn to_f32_vec(&self) -> Vec<f32> {\n        let mut vec = Vec::with_capacity(self.len());\n        // SAFETY: convert will initialize every value in the vector without reading them,\n        // so this is safe to do instead of double initialize from resize, and we're setting it to\n        // same value as capacity.\n        unsafe { vec.set_len(self.len()) };\n        self.convert_to_f32_slice(&mut vec);\n        vec\n    }\n\n    #[cfg(any(feature = \"alloc\", feature = \"std\"))]\n    #[inline]\n    fn to_f64_vec(&self) -> Vec<f64> {\n        let mut vec = Vec::with_capacity(self.len());\n        // SAFETY: convert will initialize every value in the vector without reading them,\n        // so this is safe to do instead of double initialize from resize, and we're setting it to\n        // same value as capacity.\n        unsafe { vec.set_len(self.len()) };\n        self.convert_to_f64_slice(&mut vec);\n        vec\n    }\n}\n\nimpl HalfBitsSliceExt for [u16] {\n    // Since we sealed all the traits involved, these are safe.\n    #[inline]\n    fn reinterpret_cast<H>(&self) -> &[H]\n    where\n        H: crate::private::SealedHalf,\n    {\n        let pointer = self.as_ptr() as *const H;\n        let length = self.len();\n        // SAFETY: We are reconstructing full length of original slice, using its same lifetime,\n        // and the size of elements are identical\n        unsafe { slice::from_raw_parts(pointer, length) }\n    }\n\n    #[inline]\n    fn reinterpret_cast_mut<H>(&mut self) -> &mut [H]\n    where\n        H: crate::private::SealedHalf,\n    {\n        let pointer = self.as_mut_ptr() as *mut H;\n        let length = self.len();\n        // SAFETY: We are reconstructing full length of original slice, using its same lifetime,\n        // and the size of elements are identical\n        unsafe { slice::from_raw_parts_mut(pointer, length) }\n    }\n}\n\n/// Reinterpret a mutable slice of `u16` bits as a mutable slice of [`f16`](../struct.f16.html)\n/// numbers.\n///\n/// The transmuted slice has the same life time as the original, which prevents mutating the borrowed\n/// `mut [u16]` argument as long as the returned `mut [f16]` is borrowed.\n#[deprecated(\n    since = \"1.4.0\",\n    note = \"use [`HalfBitsSliceExt::reinterpret_cast_mut`](trait.HalfBitsSliceExt.html#tymethod.reinterpret_cast_mut) instead\"\n)]\n#[inline]\npub fn from_bits_mut(bits: &mut [u16]) -> &mut [f16] {\n    bits.reinterpret_cast_mut()\n}\n\n/// Reinterpret a mutable slice of [`f16`](../struct.f16.html) numbers as a mutable slice of `u16`\n/// bits.\n///\n///The transmuted slice has the same life time as the original, which prevents mutating the\n/// borrowed `mut [f16]` argument as long as the returned `mut [u16]` is borrowed.\n#[deprecated(\n    since = \"1.4.0\",\n    note = \"use [`HalfFloatSliceExt::reinterpret_cast_mut`](trait.HalfFloatSliceExt.html#tymethod.reinterpret_cast_mut) instead\"\n)]\n#[inline]\npub fn to_bits_mut(bits: &mut [f16]) -> &mut [u16] {\n    bits.reinterpret_cast_mut()\n}\n\n/// Reinterpret a slice of `u16` bits as a slice of [`f16`](../struct.f16.html) numbers.\n///\n/// The transmuted slice has the same life time as the original.\n#[deprecated(\n    since = \"1.4.0\",\n    note = \"use [`HalfBitsSliceExt::reinterpret_cast`](trait.HalfBitsSliceExt.html#tymethod.reinterpret_cast) instead\"\n)]\n#[inline]\npub fn from_bits(bits: &[u16]) -> &[f16] {\n    bits.reinterpret_cast()\n}\n\n/// Reinterpret a slice of [`f16`](../struct.f16.html) numbers as a slice of `u16` bits.\n///\n/// The transmuted slice has the same life time as the original.\n#[deprecated(\n    since = \"1.4.0\",\n    note = \"use [`HalfFloatSliceExt::reinterpret_cast`](trait.HalfFloatSliceExt.html#tymethod.reinterpret_cast) instead\"\n)]\n#[inline]\npub fn to_bits(bits: &[f16]) -> &[u16] {\n    bits.reinterpret_cast()\n}\n\n#[cfg(test)]\nmod test {\n    use super::{HalfBitsSliceExt, HalfFloatSliceExt};\n    use crate::{bf16, f16};\n\n    #[test]\n    fn test_slice_conversions_f16() {\n        let bits = &[\n            f16::E.to_bits(),\n            f16::PI.to_bits(),\n            f16::EPSILON.to_bits(),\n            f16::FRAC_1_SQRT_2.to_bits(),\n        ];\n        let numbers = &[f16::E, f16::PI, f16::EPSILON, f16::FRAC_1_SQRT_2];\n\n        // Convert from bits to numbers\n        let from_bits = bits.reinterpret_cast::<f16>();\n        assert_eq!(from_bits, numbers);\n\n        // Convert from numbers back to bits\n        let to_bits = from_bits.reinterpret_cast();\n        assert_eq!(to_bits, bits);\n    }\n\n    #[test]\n    fn test_mutablility_f16() {\n        let mut bits_array = [f16::PI.to_bits()];\n        let bits = &mut bits_array[..];\n\n        {\n            // would not compile without these braces\n            // TODO: add automated test to check that it does not compile without braces\n            let numbers = bits.reinterpret_cast_mut();\n            numbers[0] = f16::E;\n        }\n\n        assert_eq!(bits, &[f16::E.to_bits()]);\n\n        bits[0] = f16::LN_2.to_bits();\n        assert_eq!(bits, &[f16::LN_2.to_bits()]);\n    }\n\n    #[test]\n    fn test_slice_conversions_bf16() {\n        let bits = &[\n            bf16::E.to_bits(),\n            bf16::PI.to_bits(),\n            bf16::EPSILON.to_bits(),\n            bf16::FRAC_1_SQRT_2.to_bits(),\n        ];\n        let numbers = &[bf16::E, bf16::PI, bf16::EPSILON, bf16::FRAC_1_SQRT_2];\n\n        // Convert from bits to numbers\n        let from_bits = bits.reinterpret_cast::<bf16>();\n        assert_eq!(from_bits, numbers);\n\n        // Convert from numbers back to bits\n        let to_bits = from_bits.reinterpret_cast();\n        assert_eq!(to_bits, bits);\n    }\n\n    #[test]\n    fn test_mutablility_bf16() {\n        let mut bits_array = [bf16::PI.to_bits()];\n        let bits = &mut bits_array[..];\n\n        {\n            // would not compile without these braces\n            // TODO: add automated test to check that it does not compile without braces\n            let numbers = bits.reinterpret_cast_mut();\n            numbers[0] = bf16::E;\n        }\n\n        assert_eq!(bits, &[bf16::E.to_bits()]);\n\n        bits[0] = bf16::LN_2.to_bits();\n        assert_eq!(bits, &[bf16::LN_2.to_bits()]);\n    }\n\n    #[test]\n    fn slice_convert_f16_f32() {\n        // Exact chunks\n        let vf32 = [1., 2., 3., 4., 5., 6., 7., 8.];\n        let vf16 = [\n            f16::from_f32(1.),\n            f16::from_f32(2.),\n            f16::from_f32(3.),\n            f16::from_f32(4.),\n            f16::from_f32(5.),\n            f16::from_f32(6.),\n            f16::from_f32(7.),\n            f16::from_f32(8.),\n        ];\n        let mut buf32 = vf32;\n        let mut buf16 = vf16;\n\n        vf16.convert_to_f32_slice(&mut buf32);\n        assert_eq!(&vf32, &buf32);\n\n        buf16.convert_from_f32_slice(&vf32);\n        assert_eq!(&vf16, &buf16);\n\n        // Partial with chunks\n        let vf32 = [1., 2., 3., 4., 5., 6., 7., 8., 9.];\n        let vf16 = [\n            f16::from_f32(1.),\n            f16::from_f32(2.),\n            f16::from_f32(3.),\n            f16::from_f32(4.),\n            f16::from_f32(5.),\n            f16::from_f32(6.),\n            f16::from_f32(7.),\n            f16::from_f32(8.),\n            f16::from_f32(9.),\n        ];\n        let mut buf32 = vf32;\n        let mut buf16 = vf16;\n\n        vf16.convert_to_f32_slice(&mut buf32);\n        assert_eq!(&vf32, &buf32);\n\n        buf16.convert_from_f32_slice(&vf32);\n        assert_eq!(&vf16, &buf16);\n\n        // Partial with chunks\n        let vf32 = [1., 2.];\n        let vf16 = [f16::from_f32(1.), f16::from_f32(2.)];\n        let mut buf32 = vf32;\n        let mut buf16 = vf16;\n\n        vf16.convert_to_f32_slice(&mut buf32);\n        assert_eq!(&vf32, &buf32);\n\n        buf16.convert_from_f32_slice(&vf32);\n        assert_eq!(&vf16, &buf16);\n    }\n\n    #[test]\n    fn slice_convert_bf16_f32() {\n        // Exact chunks\n        let vf32 = [1., 2., 3., 4., 5., 6., 7., 8.];\n        let vf16 = [\n            bf16::from_f32(1.),\n            bf16::from_f32(2.),\n            bf16::from_f32(3.),\n            bf16::from_f32(4.),\n            bf16::from_f32(5.),\n            bf16::from_f32(6.),\n            bf16::from_f32(7.),\n            bf16::from_f32(8.),\n        ];\n        let mut buf32 = vf32;\n        let mut buf16 = vf16;\n\n        vf16.convert_to_f32_slice(&mut buf32);\n        assert_eq!(&vf32, &buf32);\n\n        buf16.convert_from_f32_slice(&vf32);\n        assert_eq!(&vf16, &buf16);\n\n        // Partial with chunks\n        let vf32 = [1., 2., 3., 4., 5., 6., 7., 8., 9.];\n        let vf16 = [\n            bf16::from_f32(1.),\n            bf16::from_f32(2.),\n            bf16::from_f32(3.),\n            bf16::from_f32(4.),\n            bf16::from_f32(5.),\n            bf16::from_f32(6.),\n            bf16::from_f32(7.),\n            bf16::from_f32(8.),\n            bf16::from_f32(9.),\n        ];\n        let mut buf32 = vf32;\n        let mut buf16 = vf16;\n\n        vf16.convert_to_f32_slice(&mut buf32);\n        assert_eq!(&vf32, &buf32);\n\n        buf16.convert_from_f32_slice(&vf32);\n        assert_eq!(&vf16, &buf16);\n\n        // Partial with chunks\n        let vf32 = [1., 2.];\n        let vf16 = [bf16::from_f32(1.), bf16::from_f32(2.)];\n        let mut buf32 = vf32;\n        let mut buf16 = vf16;\n\n        vf16.convert_to_f32_slice(&mut buf32);\n        assert_eq!(&vf32, &buf32);\n\n        buf16.convert_from_f32_slice(&vf32);\n        assert_eq!(&vf16, &buf16);\n    }\n\n    #[test]\n    fn slice_convert_f16_f64() {\n        // Exact chunks\n        let vf64 = [1., 2., 3., 4., 5., 6., 7., 8.];\n        let vf16 = [\n            f16::from_f64(1.),\n            f16::from_f64(2.),\n            f16::from_f64(3.),\n            f16::from_f64(4.),\n            f16::from_f64(5.),\n            f16::from_f64(6.),\n            f16::from_f64(7.),\n            f16::from_f64(8.),\n        ];\n        let mut buf64 = vf64;\n        let mut buf16 = vf16;\n\n        vf16.convert_to_f64_slice(&mut buf64);\n        assert_eq!(&vf64, &buf64);\n\n        buf16.convert_from_f64_slice(&vf64);\n        assert_eq!(&vf16, &buf16);\n\n        // Partial with chunks\n        let vf64 = [1., 2., 3., 4., 5., 6., 7., 8., 9.];\n        let vf16 = [\n            f16::from_f64(1.),\n            f16::from_f64(2.),\n            f16::from_f64(3.),\n            f16::from_f64(4.),\n            f16::from_f64(5.),\n            f16::from_f64(6.),\n            f16::from_f64(7.),\n            f16::from_f64(8.),\n            f16::from_f64(9.),\n        ];\n        let mut buf64 = vf64;\n        let mut buf16 = vf16;\n\n        vf16.convert_to_f64_slice(&mut buf64);\n        assert_eq!(&vf64, &buf64);\n\n        buf16.convert_from_f64_slice(&vf64);\n        assert_eq!(&vf16, &buf16);\n\n        // Partial with chunks\n        let vf64 = [1., 2.];\n        let vf16 = [f16::from_f64(1.), f16::from_f64(2.)];\n        let mut buf64 = vf64;\n        let mut buf16 = vf16;\n\n        vf16.convert_to_f64_slice(&mut buf64);\n        assert_eq!(&vf64, &buf64);\n\n        buf16.convert_from_f64_slice(&vf64);\n        assert_eq!(&vf16, &buf16);\n    }\n\n    #[test]\n    fn slice_convert_bf16_f64() {\n        // Exact chunks\n        let vf64 = [1., 2., 3., 4., 5., 6., 7., 8.];\n        let vf16 = [\n            bf16::from_f64(1.),\n            bf16::from_f64(2.),\n            bf16::from_f64(3.),\n            bf16::from_f64(4.),\n            bf16::from_f64(5.),\n            bf16::from_f64(6.),\n            bf16::from_f64(7.),\n            bf16::from_f64(8.),\n        ];\n        let mut buf64 = vf64;\n        let mut buf16 = vf16;\n\n        vf16.convert_to_f64_slice(&mut buf64);\n        assert_eq!(&vf64, &buf64);\n\n        buf16.convert_from_f64_slice(&vf64);\n        assert_eq!(&vf16, &buf16);\n\n        // Partial with chunks\n        let vf64 = [1., 2., 3., 4., 5., 6., 7., 8., 9.];\n        let vf16 = [\n            bf16::from_f64(1.),\n            bf16::from_f64(2.),\n            bf16::from_f64(3.),\n            bf16::from_f64(4.),\n            bf16::from_f64(5.),\n            bf16::from_f64(6.),\n            bf16::from_f64(7.),\n            bf16::from_f64(8.),\n            bf16::from_f64(9.),\n        ];\n        let mut buf64 = vf64;\n        let mut buf16 = vf16;\n\n        vf16.convert_to_f64_slice(&mut buf64);\n        assert_eq!(&vf64, &buf64);\n\n        buf16.convert_from_f64_slice(&vf64);\n        assert_eq!(&vf16, &buf16);\n\n        // Partial with chunks\n        let vf64 = [1., 2.];\n        let vf16 = [bf16::from_f64(1.), bf16::from_f64(2.)];\n        let mut buf64 = vf64;\n        let mut buf16 = vf16;\n\n        vf16.convert_to_f64_slice(&mut buf64);\n        assert_eq!(&vf64, &buf64);\n\n        buf16.convert_from_f64_slice(&vf64);\n        assert_eq!(&vf16, &buf16);\n    }\n\n    #[test]\n    #[should_panic]\n    fn convert_from_f32_slice_len_mismatch_panics() {\n        let mut slice1 = [f16::ZERO; 3];\n        let slice2 = [0f32; 4];\n        slice1.convert_from_f32_slice(&slice2);\n    }\n\n    #[test]\n    #[should_panic]\n    fn convert_from_f64_slice_len_mismatch_panics() {\n        let mut slice1 = [f16::ZERO; 3];\n        let slice2 = [0f64; 4];\n        slice1.convert_from_f64_slice(&slice2);\n    }\n\n    #[test]\n    #[should_panic]\n    fn convert_to_f32_slice_len_mismatch_panics() {\n        let slice1 = [f16::ZERO; 3];\n        let mut slice2 = [0f32; 4];\n        slice1.convert_to_f32_slice(&mut slice2);\n    }\n\n    #[test]\n    #[should_panic]\n    fn convert_to_f64_slice_len_mismatch_panics() {\n        let slice1 = [f16::ZERO; 3];\n        let mut slice2 = [0f64; 4];\n        slice1.convert_to_f64_slice(&mut slice2);\n    }\n}\n"],["841","#![allow(dead_code, unused_imports)]\n\nmacro_rules! convert_fn {\n    (fn $name:ident($var:ident : $vartype:ty) -> $restype:ty {\n            if feature(\"f16c\") { $f16c:expr }\n            else { $fallback:expr }}) => {\n        #[inline]\n        pub(crate) fn $name($var: $vartype) -> $restype {\n            // Use CPU feature detection if using std\n            #[cfg(all(\n                feature = \"use-intrinsics\",\n                feature = \"std\",\n                any(target_arch = \"x86\", target_arch = \"x86_64\"),\n                not(target_feature = \"f16c\")\n            ))]\n            {\n                if is_x86_feature_detected!(\"f16c\") {\n                    $f16c\n                } else {\n                    $fallback\n                }\n            }\n            // Use intrinsics directly when a compile target or using no_std\n            #[cfg(all(\n                feature = \"use-intrinsics\",\n                any(target_arch = \"x86\", target_arch = \"x86_64\"),\n                target_feature = \"f16c\"\n            ))]\n            {\n                $f16c\n            }\n            // Fallback to software\n            #[cfg(any(\n                not(feature = \"use-intrinsics\"),\n                not(any(target_arch = \"x86\", target_arch = \"x86_64\")),\n                all(not(feature = \"std\"), not(target_feature = \"f16c\"))\n            ))]\n            {\n                $fallback\n            }\n        }\n    };\n}\n\nconvert_fn! {\n    fn f32_to_f16(f: f32) -> u16 {\n        if feature(\"f16c\") {\n            unsafe { x86::f32_to_f16_x86_f16c(f) }\n        } else {\n            f32_to_f16_fallback(f)\n        }\n    }\n}\n\nconvert_fn! {\n    fn f64_to_f16(f: f64) -> u16 {\n        if feature(\"f16c\") {\n            unsafe { x86::f32_to_f16_x86_f16c(f as f32) }\n        } else {\n            f64_to_f16_fallback(f)\n        }\n    }\n}\n\nconvert_fn! {\n    fn f16_to_f32(i: u16) -> f32 {\n        if feature(\"f16c\") {\n            unsafe { x86::f16_to_f32_x86_f16c(i) }\n        } else {\n            f16_to_f32_fallback(i)\n        }\n    }\n}\n\nconvert_fn! {\n    fn f16_to_f64(i: u16) -> f64 {\n        if feature(\"f16c\") {\n            unsafe { x86::f16_to_f32_x86_f16c(i) as f64 }\n        } else {\n            f16_to_f64_fallback(i)\n        }\n    }\n}\n\n// TODO: While SIMD versions are faster, further improvements can be made by doing runtime feature\n// detection once at beginning of convert slice method, rather than per chunk\n\nconvert_fn! {\n    fn f32x4_to_f16x4(f: &[f32]) -> [u16; 4] {\n        if feature(\"f16c\") {\n            unsafe { x86::f32x4_to_f16x4_x86_f16c(f) }\n        } else {\n            f32x4_to_f16x4_fallback(f)\n        }\n    }\n}\n\nconvert_fn! {\n    fn f16x4_to_f32x4(i: &[u16]) -> [f32; 4] {\n        if feature(\"f16c\") {\n            unsafe { x86::f16x4_to_f32x4_x86_f16c(i) }\n        } else {\n            f16x4_to_f32x4_fallback(i)\n        }\n    }\n}\n\nconvert_fn! {\n    fn f64x4_to_f16x4(f: &[f64]) -> [u16; 4] {\n        if feature(\"f16c\") {\n            unsafe { x86::f64x4_to_f16x4_x86_f16c(f) }\n        } else {\n            f64x4_to_f16x4_fallback(f)\n        }\n    }\n}\n\nconvert_fn! {\n    fn f16x4_to_f64x4(i: &[u16]) -> [f64; 4] {\n        if feature(\"f16c\") {\n            unsafe { x86::f16x4_to_f64x4_x86_f16c(i) }\n        } else {\n            f16x4_to_f64x4_fallback(i)\n        }\n    }\n}\n\n/////////////// Fallbacks ////////////////\n\n// In the below functions, round to nearest, with ties to even.\n// Let us call the most significant bit that will be shifted out the round_bit.\n//\n// Round up if either\n//  a) Removed part > tie.\n//     (mantissa & round_bit) != 0 && (mantissa & (round_bit - 1)) != 0\n//  b) Removed part == tie, and retained part is odd.\n//     (mantissa & round_bit) != 0 && (mantissa & (2 * round_bit)) != 0\n// (If removed part == tie and retained part is even, do not round up.)\n// These two conditions can be combined into one:\n//     (mantissa & round_bit) != 0 && (mantissa & ((round_bit - 1) | (2 * round_bit))) != 0\n// which can be simplified into\n//     (mantissa & round_bit) != 0 && (mantissa & (3 * round_bit - 1)) != 0\n\nfn f32_to_f16_fallback(value: f32) -> u16 {\n    // Convert to raw bytes\n    let x = value.to_bits();\n\n    // Extract IEEE754 components\n    let sign = x & 0x8000_0000u32;\n    let exp = x & 0x7F80_0000u32;\n    let man = x & 0x007F_FFFFu32;\n\n    // Check for all exponent bits being set, which is Infinity or NaN\n    if exp == 0x7F80_0000u32 {\n        // Set mantissa MSB for NaN (and also keep shifted mantissa bits)\n        let nan_bit = if man == 0 { 0 } else { 0x0200u32 };\n        return ((sign >> 16) | 0x7C00u32 | nan_bit | (man >> 13)) as u16;\n    }\n\n    // The number is normalized, start assembling half precision version\n    let half_sign = sign >> 16;\n    // Unbias the exponent, then bias for half precision\n    let unbiased_exp = ((exp >> 23) as i32) - 127;\n    let half_exp = unbiased_exp + 15;\n\n    // Check for exponent overflow, return +infinity\n    if half_exp >= 0x1F {\n        return (half_sign | 0x7C00u32) as u16;\n    }\n\n    // Check for underflow\n    if half_exp <= 0 {\n        // Check mantissa for what we can do\n        if 14 - half_exp > 24 {\n            // No rounding possibility, so this is a full underflow, return signed zero\n            return half_sign as u16;\n        }\n        // Don't forget about hidden leading mantissa bit when assembling mantissa\n        let man = man | 0x0080_0000u32;\n        let mut half_man = man >> (14 - half_exp);\n        // Check for rounding (see comment above functions)\n        let round_bit = 1 << (13 - half_exp);\n        if (man & round_bit) != 0 && (man & (3 * round_bit - 1)) != 0 {\n            half_man += 1;\n        }\n        // No exponent for subnormals\n        return (half_sign | half_man) as u16;\n    }\n\n    // Rebias the exponent\n    let half_exp = (half_exp as u32) << 10;\n    let half_man = man >> 13;\n    // Check for rounding (see comment above functions)\n    let round_bit = 0x0000_1000u32;\n    if (man & round_bit) != 0 && (man & (3 * round_bit - 1)) != 0 {\n        // Round it\n        ((half_sign | half_exp | half_man) + 1) as u16\n    } else {\n        (half_sign | half_exp | half_man) as u16\n    }\n}\n\nfn f64_to_f16_fallback(value: f64) -> u16 {\n    // Convert to raw bytes, truncating the last 32-bits of mantissa; that precision will always\n    // be lost on half-precision.\n    let val = value.to_bits();\n    let x = (val >> 32) as u32;\n\n    // Extract IEEE754 components\n    let sign = x & 0x8000_0000u32;\n    let exp = x & 0x7FF0_0000u32;\n    let man = x & 0x000F_FFFFu32;\n\n    // Check for all exponent bits being set, which is Infinity or NaN\n    if exp == 0x7FF0_0000u32 {\n        // Set mantissa MSB for NaN (and also keep shifted mantissa bits).\n        // We also have to check the last 32 bits.\n        let nan_bit = if man == 0 && (val as u32 == 0) {\n            0\n        } else {\n            0x0200u32\n        };\n        return ((sign >> 16) | 0x7C00u32 | nan_bit | (man >> 10)) as u16;\n    }\n\n    // The number is normalized, start assembling half precision version\n    let half_sign = sign >> 16;\n    // Unbias the exponent, then bias for half precision\n    let unbiased_exp = ((exp >> 20) as i64) - 1023;\n    let half_exp = unbiased_exp + 15;\n\n    // Check for exponent overflow, return +infinity\n    if half_exp >= 0x1F {\n        return (half_sign | 0x7C00u32) as u16;\n    }\n\n    // Check for underflow\n    if half_exp <= 0 {\n        // Check mantissa for what we can do\n        if 10 - half_exp > 21 {\n            // No rounding possibility, so this is a full underflow, return signed zero\n            return half_sign as u16;\n        }\n        // Don't forget about hidden leading mantissa bit when assembling mantissa\n        let man = man | 0x0010_0000u32;\n        let mut half_man = man >> (11 - half_exp);\n        // Check for rounding (see comment above functions)\n        let round_bit = 1 << (10 - half_exp);\n        if (man & round_bit) != 0 && (man & (3 * round_bit - 1)) != 0 {\n            half_man += 1;\n        }\n        // No exponent for subnormals\n        return (half_sign | half_man) as u16;\n    }\n\n    // Rebias the exponent\n    let half_exp = (half_exp as u32) << 10;\n    let half_man = man >> 10;\n    // Check for rounding (see comment above functions)\n    let round_bit = 0x0000_0200u32;\n    if (man & round_bit) != 0 && (man & (3 * round_bit - 1)) != 0 {\n        // Round it\n        ((half_sign | half_exp | half_man) + 1) as u16\n    } else {\n        (half_sign | half_exp | half_man) as u16\n    }\n}\n\nfn f16_to_f32_fallback(i: u16) -> f32 {\n    // Check for signed zero\n    if i & 0x7FFFu16 == 0 {\n        return f32::from_bits((i as u32) << 16);\n    }\n\n    let half_sign = (i & 0x8000u16) as u32;\n    let half_exp = (i & 0x7C00u16) as u32;\n    let half_man = (i & 0x03FFu16) as u32;\n\n    // Check for an infinity or NaN when all exponent bits set\n    if half_exp == 0x7C00u32 {\n        // Check for signed infinity if mantissa is zero\n        if half_man == 0 {\n            return f32::from_bits((half_sign << 16) | 0x7F80_0000u32);\n        } else {\n            // NaN, keep current mantissa but also set most significiant mantissa bit\n            return f32::from_bits((half_sign << 16) | 0x7FC0_0000u32 | (half_man << 13));\n        }\n    }\n\n    // Calculate single-precision components with adjusted exponent\n    let sign = half_sign << 16;\n    // Unbias exponent\n    let unbiased_exp = ((half_exp as i32) >> 10) - 15;\n\n    // Check for subnormals, which will be normalized by adjusting exponent\n    if half_exp == 0 {\n        // Calculate how much to adjust the exponent by\n        let e = (half_man as u16).leading_zeros() - 6;\n\n        // Rebias and adjust exponent\n        let exp = (127 - 15 - e) << 23;\n        let man = (half_man << (14 + e)) & 0x7F_FF_FFu32;\n        return f32::from_bits(sign | exp | man);\n    }\n\n    // Rebias exponent for a normalized normal\n    let exp = ((unbiased_exp + 127) as u32) << 23;\n    let man = (half_man & 0x03FFu32) << 13;\n    f32::from_bits(sign | exp | man)\n}\n\nfn f16_to_f64_fallback(i: u16) -> f64 {\n    // Check for signed zero\n    if i & 0x7FFFu16 == 0 {\n        return f64::from_bits((i as u64) << 48);\n    }\n\n    let half_sign = (i & 0x8000u16) as u64;\n    let half_exp = (i & 0x7C00u16) as u64;\n    let half_man = (i & 0x03FFu16) as u64;\n\n    // Check for an infinity or NaN when all exponent bits set\n    if half_exp == 0x7C00u64 {\n        // Check for signed infinity if mantissa is zero\n        if half_man == 0 {\n            return f64::from_bits((half_sign << 48) | 0x7FF0_0000_0000_0000u64);\n        } else {\n            // NaN, keep current mantissa but also set most significiant mantissa bit\n            return f64::from_bits((half_sign << 48) | 0x7FF8_0000_0000_0000u64 | (half_man << 42));\n        }\n    }\n\n    // Calculate double-precision components with adjusted exponent\n    let sign = half_sign << 48;\n    // Unbias exponent\n    let unbiased_exp = ((half_exp as i64) >> 10) - 15;\n\n    // Check for subnormals, which will be normalized by adjusting exponent\n    if half_exp == 0 {\n        // Calculate how much to adjust the exponent by\n        let e = (half_man as u16).leading_zeros() - 6;\n\n        // Rebias and adjust exponent\n        let exp = ((1023 - 15 - e) as u64) << 52;\n        let man = (half_man << (43 + e)) & 0xF_FFFF_FFFF_FFFFu64;\n        return f64::from_bits(sign | exp | man);\n    }\n\n    // Rebias exponent for a normalized normal\n    let exp = ((unbiased_exp + 1023) as u64) << 52;\n    let man = (half_man & 0x03FFu64) << 42;\n    f64::from_bits(sign | exp | man)\n}\n\n#[inline]\nfn f16x4_to_f32x4_fallback(v: &[u16]) -> [f32; 4] {\n    debug_assert!(v.len() >= 4);\n\n    [\n        f16_to_f32_fallback(v[0]),\n        f16_to_f32_fallback(v[1]),\n        f16_to_f32_fallback(v[2]),\n        f16_to_f32_fallback(v[3]),\n    ]\n}\n\n#[inline]\nfn f32x4_to_f16x4_fallback(v: &[f32]) -> [u16; 4] {\n    debug_assert!(v.len() >= 4);\n\n    [\n        f32_to_f16_fallback(v[0]),\n        f32_to_f16_fallback(v[1]),\n        f32_to_f16_fallback(v[2]),\n        f32_to_f16_fallback(v[3]),\n    ]\n}\n\n#[inline]\nfn f16x4_to_f64x4_fallback(v: &[u16]) -> [f64; 4] {\n    debug_assert!(v.len() >= 4);\n\n    [\n        f16_to_f64_fallback(v[0]),\n        f16_to_f64_fallback(v[1]),\n        f16_to_f64_fallback(v[2]),\n        f16_to_f64_fallback(v[3]),\n    ]\n}\n\n#[inline]\nfn f64x4_to_f16x4_fallback(v: &[f64]) -> [u16; 4] {\n    debug_assert!(v.len() >= 4);\n\n    [\n        f64_to_f16_fallback(v[0]),\n        f64_to_f16_fallback(v[1]),\n        f64_to_f16_fallback(v[2]),\n        f64_to_f16_fallback(v[3]),\n    ]\n}\n\n/////////////// x86/x86_64 f16c ////////////////\n#[cfg(all(\n    feature = \"use-intrinsics\",\n    any(target_arch = \"x86\", target_arch = \"x86_64\")\n))]\nmod x86 {\n    use core::{mem::MaybeUninit, ptr};\n\n    #[cfg(target_arch = \"x86\")]\n    use core::arch::x86::{__m128, __m128i, _mm_cvtph_ps, _mm_cvtps_ph, _MM_FROUND_TO_NEAREST_INT};\n    #[cfg(target_arch = \"x86_64\")]\n    use core::arch::x86_64::{\n        __m128, __m128i, _mm_cvtph_ps, _mm_cvtps_ph, _MM_FROUND_TO_NEAREST_INT,\n    };\n\n    #[target_feature(enable = \"f16c\")]\n    #[inline]\n    pub(super) unsafe fn f16_to_f32_x86_f16c(i: u16) -> f32 {\n        let mut vec = MaybeUninit::<__m128i>::zeroed();\n        vec.as_mut_ptr().cast::<u16>().write(i);\n        let retval = _mm_cvtph_ps(vec.assume_init());\n        *(&retval as *const __m128).cast()\n    }\n\n    #[target_feature(enable = \"f16c\")]\n    #[inline]\n    pub(super) unsafe fn f32_to_f16_x86_f16c(f: f32) -> u16 {\n        let mut vec = MaybeUninit::<__m128>::zeroed();\n        vec.as_mut_ptr().cast::<f32>().write(f);\n        let retval = _mm_cvtps_ph(vec.assume_init(), _MM_FROUND_TO_NEAREST_INT);\n        *(&retval as *const __m128i).cast()\n    }\n\n    #[target_feature(enable = \"f16c\")]\n    #[inline]\n    pub(super) unsafe fn f16x4_to_f32x4_x86_f16c(v: &[u16]) -> [f32; 4] {\n        debug_assert!(v.len() >= 4);\n\n        let mut vec = MaybeUninit::<__m128i>::zeroed();\n        ptr::copy_nonoverlapping(v.as_ptr(), vec.as_mut_ptr().cast(), 4);\n        let retval = _mm_cvtph_ps(vec.assume_init());\n        *(&retval as *const __m128).cast()\n    }\n\n    #[target_feature(enable = \"f16c\")]\n    #[inline]\n    pub(super) unsafe fn f32x4_to_f16x4_x86_f16c(v: &[f32]) -> [u16; 4] {\n        debug_assert!(v.len() >= 4);\n\n        let mut vec = MaybeUninit::<__m128>::uninit();\n        ptr::copy_nonoverlapping(v.as_ptr(), vec.as_mut_ptr().cast(), 4);\n        let retval = _mm_cvtps_ph(vec.assume_init(), _MM_FROUND_TO_NEAREST_INT);\n        *(&retval as *const __m128i).cast()\n    }\n\n    #[target_feature(enable = \"f16c\")]\n    #[inline]\n    pub(super) unsafe fn f16x4_to_f64x4_x86_f16c(v: &[u16]) -> [f64; 4] {\n        debug_assert!(v.len() >= 4);\n\n        let mut vec = MaybeUninit::<__m128i>::zeroed();\n        ptr::copy_nonoverlapping(v.as_ptr(), vec.as_mut_ptr().cast(), 4);\n        let retval = _mm_cvtph_ps(vec.assume_init());\n        let array = *(&retval as *const __m128).cast::<[f32; 4]>();\n        // Let compiler vectorize this regular cast for now.\n        // TODO: investigate auto-detecting sse2/avx convert features\n        [\n            array[0] as f64,\n            array[1] as f64,\n            array[2] as f64,\n            array[3] as f64,\n        ]\n    }\n\n    #[target_feature(enable = \"f16c\")]\n    #[inline]\n    pub(super) unsafe fn f64x4_to_f16x4_x86_f16c(v: &[f64]) -> [u16; 4] {\n        debug_assert!(v.len() >= 4);\n\n        // Let compiler vectorize this regular cast for now.\n        // TODO: investigate auto-detecting sse2/avx convert features\n        let v = [v[0] as f32, v[1] as f32, v[2] as f32, v[3] as f32];\n\n        let mut vec = MaybeUninit::<__m128>::uninit();\n        ptr::copy_nonoverlapping(v.as_ptr(), vec.as_mut_ptr().cast(), 4);\n        let retval = _mm_cvtps_ph(vec.assume_init(), _MM_FROUND_TO_NEAREST_INT);\n        *(&retval as *const __m128i).cast()\n    }\n}\n"],["842","#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Serialize};\n\n#[cfg(feature = \"bytemuck\")]\nuse bytemuck::{Pod, Zeroable};\n\nuse core::{\n    cmp::Ordering,\n    fmt::{\n        Binary, Debug, Display, Error, Formatter, LowerExp, LowerHex, Octal, UpperExp, UpperHex,\n    },\n    num::{FpCategory, ParseFloatError},\n    str::FromStr,\n};\n\npub(crate) mod convert;\n\n/// A 16-bit floating point type implementing the IEEE 754-2008 standard [`binary16`] a.k.a `half`\n/// format.\n///\n/// This 16-bit floating point type is intended for efficient storage where the full range and\n/// precision of a larger floating point value is not required. Because [`f16`] is primarily for\n/// efficient storage, floating point operations such as addition, multiplication, etc. are not\n/// implemented. Operations should be performed with `f32` or higher-precision types and converted\n/// to/from [`f16`] as necessary.\n///\n/// [`f16`]: struct.f16.html\n/// [`binary16`]: https://en.wikipedia.org/wiki/Half-precision_floating-point_format\n#[allow(non_camel_case_types)]\n#[derive(Clone, Copy, Default)]\n#[repr(transparent)]\n#[cfg_attr(feature = \"serde\", derive(Serialize, Deserialize))]\n#[cfg_attr(feature = \"bytemuck\", derive(Zeroable, Pod))]\npub struct f16(u16);\n\n#[cfg(feature = \"num-traits\")]\nmod impl_num_traits {\n    use super::f16;\n    use num_traits::{FromPrimitive, ToPrimitive};\n\n    impl ToPrimitive for f16 {\n        fn to_i64(&self) -> Option<i64> {\n            Self::to_f32(*self).to_i64()\n        }\n        fn to_u64(&self) -> Option<u64> {\n            Self::to_f32(*self).to_u64()\n        }\n        fn to_i8(&self) -> Option<i8> {\n            Self::to_f32(*self).to_i8()\n        }\n        fn to_u8(&self) -> Option<u8> {\n            Self::to_f32(*self).to_u8()\n        }\n        fn to_i16(&self) -> Option<i16> {\n            Self::to_f32(*self).to_i16()\n        }\n        fn to_u16(&self) -> Option<u16> {\n            Self::to_f32(*self).to_u16()\n        }\n        fn to_i32(&self) -> Option<i32> {\n            Self::to_f32(*self).to_i32()\n        }\n        fn to_u32(&self) -> Option<u32> {\n            Self::to_f32(*self).to_u32()\n        }\n        fn to_f32(&self) -> Option<f32> {\n            Some(Self::to_f32(*self))\n        }\n        fn to_f64(&self) -> Option<f64> {\n            Some(Self::to_f64(*self))\n        }\n    }\n\n    impl FromPrimitive for f16 {\n        fn from_i64(n: i64) -> Option<Self> {\n            n.to_f32().map(|x| Self::from_f32(x))\n        }\n        fn from_u64(n: u64) -> Option<Self> {\n            n.to_f32().map(|x| Self::from_f32(x))\n        }\n        fn from_i8(n: i8) -> Option<Self> {\n            n.to_f32().map(|x| Self::from_f32(x))\n        }\n        fn from_u8(n: u8) -> Option<Self> {\n            n.to_f32().map(|x| Self::from_f32(x))\n        }\n        fn from_i16(n: i16) -> Option<Self> {\n            n.to_f32().map(|x| Self::from_f32(x))\n        }\n        fn from_u16(n: u16) -> Option<Self> {\n            n.to_f32().map(|x| Self::from_f32(x))\n        }\n        fn from_i32(n: i32) -> Option<Self> {\n            n.to_f32().map(|x| Self::from_f32(x))\n        }\n        fn from_u32(n: u32) -> Option<Self> {\n            n.to_f32().map(|x| Self::from_f32(x))\n        }\n        fn from_f32(n: f32) -> Option<Self> {\n            n.to_f32().map(|x| Self::from_f32(x))\n        }\n        fn from_f64(n: f64) -> Option<Self> {\n            n.to_f64().map(|x| Self::from_f64(x))\n        }\n    }\n}\n\n#[deprecated(\n    since = \"1.4.0\",\n    note = \"all constants moved to associated constants of [`f16`](../struct.f16.html)\"\n)]\npub mod consts {\n    //! Useful `f16` constants.\n\n    use super::f16;\n\n    /// Approximate number of [`f16`](../struct.f16.html) significant digits in base 10.\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::DIGITS`](../struct.f16.html#associatedconstant.DIGITS)\"\n    )]\n    pub const DIGITS: u32 = f16::DIGITS;\n    /// [`f16`](../struct.f16.html)\n    /// [machine epsilon](https://en.wikipedia.org/wiki/Machine_epsilon) value.\n    ///\n    /// This is the difference between 1.0 and the next largest representable number.\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::EPSILON`](../struct.f16.html#associatedconstant.EPSILON)\"\n    )]\n    pub const EPSILON: f16 = f16::EPSILON;\n    /// [`f16`](../struct.f16.html) positive Infinity (+âˆž).\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::INFINITY`](../struct.f16.html#associatedconstant.INFINITY)\"\n    )]\n    pub const INFINITY: f16 = f16::INFINITY;\n    /// Number of [`f16`](../struct.f16.html) significant digits in base 2.\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::MANTISSA_DIGITS`](../struct.f16.html#associatedconstant.MANTISSA_DIGITS)\"\n    )]\n    pub const MANTISSA_DIGITS: u32 = f16::MANTISSA_DIGITS;\n    /// Largest finite [`f16`](../struct.f16.html) value.\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::MAX`](../struct.f16.html#associatedconstant.MAX)\"\n    )]\n    pub const MAX: f16 = f16::MAX;\n    /// Maximum possible [`f16`](../struct.f16.html) power of 10 exponent.\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::MAX_10_EXP`](../struct.f16.html#associatedconstant.MAX_10_EXP)\"\n    )]\n    pub const MAX_10_EXP: i32 = f16::MAX_10_EXP;\n    /// Maximum possible [`f16`](../struct.f16.html) power of 2 exponent.\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::MAX_EXP`](../struct.f16.html#associatedconstant.MAX_EXP)\"\n    )]\n    pub const MAX_EXP: i32 = f16::MAX_EXP;\n    /// Smallest finite [`f16`](../struct.f16.html) value.\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::MIN`](../struct.f16.html#associatedconstant.MIN)\"\n    )]\n    pub const MIN: f16 = f16::MIN;\n    /// Minimum possible normal [`f16`](../struct.f16.html) power of 10 exponent.\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::MIN_10_EXP`](../struct.f16.html#associatedconstant.MIN_10_EXP)\"\n    )]\n    pub const MIN_10_EXP: i32 = f16::MIN_10_EXP;\n    /// One greater than the minimum possible normal [`f16`](../struct.f16.html) power of 2 exponent.\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::MIN_EXP`](../struct.f16.html#associatedconstant.MIN_EXP)\"\n    )]\n    pub const MIN_EXP: i32 = f16::MIN_EXP;\n    /// Smallest positive normal [`f16`](../struct.f16.html) value.\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::MIN_POSITIVE`](../struct.f16.html#associatedconstant.MIN_POSITIVE)\"\n    )]\n    pub const MIN_POSITIVE: f16 = f16::MIN_POSITIVE;\n    /// [`f16`](../struct.f16.html) Not a Number (NaN).\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::NAN`](../struct.f16.html#associatedconstant.NAN)\"\n    )]\n    pub const NAN: f16 = f16::NAN;\n    /// [`f16`](../struct.f16.html) negative infinity (-âˆž).\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::NEG_INFINITY`](../struct.f16.html#associatedconstant.NEG_INFINITY)\"\n    )]\n    pub const NEG_INFINITY: f16 = f16::NEG_INFINITY;\n    /// The radix or base of the internal representation of [`f16`](../struct.f16.html).\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::RADIX`](../struct.f16.html#associatedconstant.RADIX)\"\n    )]\n    pub const RADIX: u32 = f16::RADIX;\n\n    /// Minimum positive subnormal [`f16`](../struct.f16.html) value.\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::MIN_POSITIVE_SUBNORMAL`](../struct.f16.html#associatedconstant.MIN_POSITIVE_SUBNORMAL)\"\n    )]\n    pub const MIN_POSITIVE_SUBNORMAL: f16 = f16::MIN_POSITIVE_SUBNORMAL;\n    /// Maximum subnormal [`f16`](../struct.f16.html) value.\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::MAX_SUBNORMAL`](../struct.f16.html#associatedconstant.MAX_SUBNORMAL)\"\n    )]\n    pub const MAX_SUBNORMAL: f16 = f16::MAX_SUBNORMAL;\n\n    /// [`f16`](../struct.f16.html) 1\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::ONE`](../struct.f16.html#associatedconstant.ONE)\"\n    )]\n    pub const ONE: f16 = f16::ONE;\n    /// [`f16`](../struct.f16.html) 0\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::ZERO`](../struct.f16.html#associatedconstant.ZERO)\"\n    )]\n    pub const ZERO: f16 = f16::ZERO;\n    /// [`f16`](../struct.f16.html) -0\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::NEG_ZERO`](../struct.f16.html#associatedconstant.NEG_ZERO)\"\n    )]\n    pub const NEG_ZERO: f16 = f16::NEG_ZERO;\n\n    /// [`f16`](../struct.f16.html) Euler's number (â„¯).\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::E`](../struct.f16.html#associatedconstant.E)\"\n    )]\n    pub const E: f16 = f16::E;\n    /// [`f16`](../struct.f16.html) Archimedes' constant (Ï€).\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::PI`](../struct.f16.html#associatedconstant.PI)\"\n    )]\n    pub const PI: f16 = f16::PI;\n    /// [`f16`](../struct.f16.html) 1/Ï€\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::FRAC_1_PI`](../struct.f16.html#associatedconstant.FRAC_1_PI)\"\n    )]\n    pub const FRAC_1_PI: f16 = f16::FRAC_1_PI;\n    /// [`f16`](../struct.f16.html) 1/âˆš2\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::FRAC_1_SQRT_2`](../struct.f16.html#associatedconstant.FRAC_1_SQRT_2)\"\n    )]\n    pub const FRAC_1_SQRT_2: f16 = f16::FRAC_1_SQRT_2;\n    /// [`f16`](../struct.f16.html) 2/Ï€\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::FRAC_2_PI`](../struct.f16.html#associatedconstant.FRAC_2_PI)\"\n    )]\n    pub const FRAC_2_PI: f16 = f16::FRAC_2_PI;\n    /// [`f16`](../struct.f16.html) 2/âˆšÏ€\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::FRAC_2_SQRT_PI`](../struct.f16.html#associatedconstant.FRAC_2_SQRT_PI)\"\n    )]\n    pub const FRAC_2_SQRT_PI: f16 = f16::FRAC_2_SQRT_PI;\n    /// [`f16`](../struct.f16.html) Ï€/2\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::FRAC_PI_2`](../struct.f16.html#associatedconstant.FRAC_PI_2)\"\n    )]\n    pub const FRAC_PI_2: f16 = f16::FRAC_PI_2;\n    /// [`f16`](../struct.f16.html) Ï€/3\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::FRAC_PI_3`](../struct.f16.html#associatedconstant.FRAC_PI_3)\"\n    )]\n    pub const FRAC_PI_3: f16 = f16::FRAC_PI_3;\n    /// [`f16`](../struct.f16.html) Ï€/4\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::FRAC_PI_4`](../struct.f16.html#associatedconstant.FRAC_PI_4)\"\n    )]\n    pub const FRAC_PI_4: f16 = f16::FRAC_PI_4;\n    /// [`f16`](../struct.f16.html) Ï€/6\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::FRAC_PI_6`](../struct.f16.html#associatedconstant.FRAC_PI_6)\"\n    )]\n    pub const FRAC_PI_6: f16 = f16::FRAC_PI_6;\n    /// [`f16`](../struct.f16.html) Ï€/8\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::FRAC_PI_8`](../struct.f16.html#associatedconstant.FRAC_PI_8)\"\n    )]\n    pub const FRAC_PI_8: f16 = f16::FRAC_PI_8;\n    /// [`f16`](../struct.f16.html) ð—…ð—‡ 10\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::LN_10`](../struct.f16.html#associatedconstant.LN_10)\"\n    )]\n    pub const LN_10: f16 = f16::LN_10;\n    /// [`f16`](../struct.f16.html) ð—…ð—‡ 2\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::LN_2`](../struct.f16.html#associatedconstant.LN_2)\"\n    )]\n    pub const LN_2: f16 = f16::LN_2;\n    /// [`f16`](../struct.f16.html) ð—…ð—ˆð—€â‚â‚€â„¯\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::LOG10_E`](../struct.f16.html#associatedconstant.LOG10_E)\"\n    )]\n    pub const LOG10_E: f16 = f16::LOG10_E;\n    /// [`f16`](../struct.f16.html) ð—…ð—ˆð—€â‚‚â„¯\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::LOG2_E`](../struct.f16.html#associatedconstant.LOG2_E)\"\n    )]\n    pub const LOG2_E: f16 = f16::LOG2_E;\n    /// [`f16`](../struct.f16.html) âˆš2\n    #[deprecated(\n        since = \"1.4.0\",\n        note = \"moved to [`f16::SQRT_2`](../struct.f16.html#associatedconstant.SQRT_2)\"\n    )]\n    pub const SQRT_2: f16 = f16::SQRT_2;\n}\n\nimpl f16 {\n    /// Constructs a 16-bit floating point value from the raw bits.\n    #[inline]\n    pub const fn from_bits(bits: u16) -> f16 {\n        f16(bits)\n    }\n\n    /// Constructs a 16-bit floating point value from a 32-bit floating point value.\n    ///\n    /// If the 32-bit value is to large to fit in 16-bits, Â±âˆž will result. NaN values are\n    /// preserved. 32-bit subnormal values are too tiny to be represented in 16-bits and result in\n    /// Â±0. Exponents that underflow the minimum 16-bit exponent will result in 16-bit subnormals\n    /// or Â±0. All other values are truncated and rounded to the nearest representable 16-bit\n    /// value.\n    #[inline]\n    pub fn from_f32(value: f32) -> f16 {\n        f16(convert::f32_to_f16(value))\n    }\n\n    /// Constructs a 16-bit floating point value from a 64-bit floating point value.\n    ///\n    /// If the 64-bit value is to large to fit in 16-bits, Â±âˆž will result. NaN values are\n    /// preserved. 64-bit subnormal values are too tiny to be represented in 16-bits and result in\n    /// Â±0. Exponents that underflow the minimum 16-bit exponent will result in 16-bit subnormals\n    /// or Â±0. All other values are truncated and rounded to the nearest representable 16-bit\n    /// value.\n    #[inline]\n    pub fn from_f64(value: f64) -> f16 {\n        f16(convert::f64_to_f16(value))\n    }\n\n    /// Converts a [`f16`](struct.f16.html) into the underlying bit representation.\n    #[inline]\n    pub const fn to_bits(self) -> u16 {\n        self.0\n    }\n\n    /// Return the memory representation of the underlying bit representation as a byte array in\n    /// little-endian byte order.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    /// let bytes = f16::from_f32(12.5).to_le_bytes();\n    /// assert_eq!(bytes, [0x40, 0x4A]);\n    /// ```\n    #[inline]\n    pub fn to_le_bytes(self) -> [u8; 2] {\n        self.0.to_le_bytes()\n    }\n\n    /// Return the memory representation of the underlying bit representation as a byte array in\n    /// big-endian (network) byte order.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    /// let bytes = f16::from_f32(12.5).to_be_bytes();\n    /// assert_eq!(bytes, [0x4A, 0x40]);\n    /// ```\n    #[inline]\n    pub fn to_be_bytes(self) -> [u8; 2] {\n        self.0.to_be_bytes()\n    }\n\n    /// Return the memory representation of the underlying bit representation as a byte array in\n    /// native byte order.\n    ///\n    /// As the target platform's native endianness is used, portable code should use `to_be_bytes`\n    /// or `to_le_bytes`, as appropriate, instead.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    /// let bytes = f16::from_f32(12.5).to_ne_bytes();\n    /// assert_eq!(bytes, if cfg!(target_endian = \"big\") {\n    ///     [0x4A, 0x40]\n    /// } else {\n    ///     [0x40, 0x4A]\n    /// });\n    /// ```\n    #[inline]\n    pub fn to_ne_bytes(self) -> [u8; 2] {\n        self.0.to_ne_bytes()\n    }\n\n    /// Create a floating point value from its representation as a byte array in little endian.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    /// let value = f16::from_le_bytes([0x40, 0x4A]);\n    /// assert_eq!(value, f16::from_f32(12.5));\n    /// ```\n    #[inline]\n    pub fn from_le_bytes(bytes: [u8; 2]) -> f16 {\n        f16::from_bits(u16::from_le_bytes(bytes))\n    }\n\n    /// Create a floating point value from its representation as a byte array in big endian.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    /// let value = f16::from_be_bytes([0x4A, 0x40]);\n    /// assert_eq!(value, f16::from_f32(12.5));\n    /// ```\n    #[inline]\n    pub fn from_be_bytes(bytes: [u8; 2]) -> f16 {\n        f16::from_bits(u16::from_be_bytes(bytes))\n    }\n\n    /// Create a floating point value from its representation as a byte array in native endian.\n    ///\n    /// As the target platform's native endianness is used, portable code likely wants to use\n    /// `from_be_bytes` or `from_le_bytes`, as appropriate instead.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    /// let value = f16::from_ne_bytes(if cfg!(target_endian = \"big\") {\n    ///     [0x4A, 0x40]\n    /// } else {\n    ///     [0x40, 0x4A]\n    /// });\n    /// assert_eq!(value, f16::from_f32(12.5));\n    /// ```\n    #[inline]\n    pub fn from_ne_bytes(bytes: [u8; 2]) -> f16 {\n        f16::from_bits(u16::from_ne_bytes(bytes))\n    }\n\n    /// Converts a [`f16`](struct.f16.html) into the underlying bit representation.\n    #[deprecated(since = \"1.2.0\", note = \"renamed to [`to_bits`](#method.to_bits)\")]\n    #[inline]\n    pub fn as_bits(self) -> u16 {\n        self.to_bits()\n    }\n\n    /// Converts a [`f16`](struct.f16.html) value into a `f32` value.\n    ///\n    /// This conversion is lossless as all 16-bit floating point values can be represented exactly\n    /// in 32-bit floating point.\n    #[inline]\n    pub fn to_f32(self) -> f32 {\n        convert::f16_to_f32(self.0)\n    }\n\n    /// Converts a [`f16`](struct.f16.html) value into a `f64` value.\n    ///\n    /// This conversion is lossless as all 16-bit floating point values can be represented exactly\n    /// in 64-bit floating point.\n    #[inline]\n    pub fn to_f64(self) -> f64 {\n        convert::f16_to_f64(self.0)\n    }\n\n    /// Returns `true` if this value is `NaN` and `false` otherwise.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    ///\n    /// let nan = f16::NAN;\n    /// let f = f16::from_f32(7.0_f32);\n    ///\n    /// assert!(nan.is_nan());\n    /// assert!(!f.is_nan());\n    /// ```\n    #[inline]\n    pub const fn is_nan(self) -> bool {\n        self.0 & 0x7FFFu16 > 0x7C00u16\n    }\n\n    /// Returns `true` if this value is Â±âˆž and `false`\n    /// otherwise.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    ///\n    /// let f = f16::from_f32(7.0f32);\n    /// let inf = f16::INFINITY;\n    /// let neg_inf = f16::NEG_INFINITY;\n    /// let nan = f16::NAN;\n    ///\n    /// assert!(!f.is_infinite());\n    /// assert!(!nan.is_infinite());\n    ///\n    /// assert!(inf.is_infinite());\n    /// assert!(neg_inf.is_infinite());\n    /// ```\n    #[inline]\n    pub const fn is_infinite(self) -> bool {\n        self.0 & 0x7FFFu16 == 0x7C00u16\n    }\n\n    /// Returns `true` if this number is neither infinite nor `NaN`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    ///\n    /// let f = f16::from_f32(7.0f32);\n    /// let inf = f16::INFINITY;\n    /// let neg_inf = f16::NEG_INFINITY;\n    /// let nan = f16::NAN;\n    ///\n    /// assert!(f.is_finite());\n    ///\n    /// assert!(!nan.is_finite());\n    /// assert!(!inf.is_finite());\n    /// assert!(!neg_inf.is_finite());\n    /// ```\n    #[inline]\n    pub const fn is_finite(self) -> bool {\n        self.0 & 0x7C00u16 != 0x7C00u16\n    }\n\n    /// Returns `true` if the number is neither zero, infinite, subnormal, or `NaN`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    ///\n    /// let min = f16::MIN_POSITIVE;\n    /// let max = f16::MAX;\n    /// let lower_than_min = f16::from_f32(1.0e-10_f32);\n    /// let zero = f16::from_f32(0.0_f32);\n    ///\n    /// assert!(min.is_normal());\n    /// assert!(max.is_normal());\n    ///\n    /// assert!(!zero.is_normal());\n    /// assert!(!f16::NAN.is_normal());\n    /// assert!(!f16::INFINITY.is_normal());\n    /// // Values between `0` and `min` are Subnormal.\n    /// assert!(!lower_than_min.is_normal());\n    /// ```\n    #[inline]\n    pub fn is_normal(self) -> bool {\n        let exp = self.0 & 0x7C00u16;\n        exp != 0x7C00u16 && exp != 0\n    }\n\n    /// Returns the floating point category of the number.\n    ///\n    /// If only one property is going to be tested, it is generally faster to use the specific\n    /// predicate instead.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::num::FpCategory;\n    /// # use half::prelude::*;\n    ///\n    /// let num = f16::from_f32(12.4_f32);\n    /// let inf = f16::INFINITY;\n    ///\n    /// assert_eq!(num.classify(), FpCategory::Normal);\n    /// assert_eq!(inf.classify(), FpCategory::Infinite);\n    /// ```\n    pub fn classify(self) -> FpCategory {\n        let exp = self.0 & 0x7C00u16;\n        let man = self.0 & 0x03FFu16;\n        match (exp, man) {\n            (0, 0) => FpCategory::Zero,\n            (0, _) => FpCategory::Subnormal,\n            (0x7C00u16, 0) => FpCategory::Infinite,\n            (0x7C00u16, _) => FpCategory::Nan,\n            _ => FpCategory::Normal,\n        }\n    }\n\n    /// Returns a number that represents the sign of `self`.\n    ///\n    /// * `1.0` if the number is positive, `+0.0` or `INFINITY`\n    /// * `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n    /// * `NAN` if the number is `NAN`\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    ///\n    /// let f = f16::from_f32(3.5_f32);\n    ///\n    /// assert_eq!(f.signum(), f16::from_f32(1.0));\n    /// assert_eq!(f16::NEG_INFINITY.signum(), f16::from_f32(-1.0));\n    ///\n    /// assert!(f16::NAN.signum().is_nan());\n    /// ```\n    pub fn signum(self) -> f16 {\n        if self.is_nan() {\n            self\n        } else if self.0 & 0x8000u16 != 0 {\n            f16::from_f32(-1.0)\n        } else {\n            f16::from_f32(1.0)\n        }\n    }\n\n    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaNs` with a\n    /// positive sign bit and +âˆž.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    ///\n    /// let nan = f16::NAN;\n    /// let f = f16::from_f32(7.0_f32);\n    /// let g = f16::from_f32(-7.0_f32);\n    ///\n    /// assert!(f.is_sign_positive());\n    /// assert!(!g.is_sign_positive());\n    /// // `NaN` can be either positive or negative\n    /// assert!(nan.is_sign_positive() != nan.is_sign_negative());\n    /// ```\n    #[inline]\n    pub const fn is_sign_positive(self) -> bool {\n        self.0 & 0x8000u16 == 0\n    }\n\n    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaNs` with a\n    /// negative sign bit and âˆ’âˆž.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    ///\n    /// let nan = f16::NAN;\n    /// let f = f16::from_f32(7.0f32);\n    /// let g = f16::from_f32(-7.0f32);\n    ///\n    /// assert!(!f.is_sign_negative());\n    /// assert!(g.is_sign_negative());\n    /// // `NaN` can be either positive or negative\n    /// assert!(nan.is_sign_positive() != nan.is_sign_negative());\n    /// ```\n    #[inline]\n    pub const fn is_sign_negative(self) -> bool {\n        self.0 & 0x8000u16 != 0\n    }\n\n    /// Approximate number of [`f16`](struct.f16.html) significant digits in base 10.\n    pub const DIGITS: u32 = 3;\n    /// [`f16`](struct.f16.html)\n    /// [machine epsilon](https://en.wikipedia.org/wiki/Machine_epsilon) value.\n    ///\n    /// This is the difference between 1.0 and the next largest representable number.\n    pub const EPSILON: f16 = f16(0x1400u16);\n    /// [`f16`](struct.f16.html) positive Infinity (+âˆž).\n    pub const INFINITY: f16 = f16(0x7C00u16);\n    /// Number of [`f16`](struct.f16.html) significant digits in base 2.\n    pub const MANTISSA_DIGITS: u32 = 11;\n    /// Largest finite [`f16`](struct.f16.html) value.\n    pub const MAX: f16 = f16(0x7BFF);\n    /// Maximum possible [`f16`](struct.f16.html) power of 10 exponent.\n    pub const MAX_10_EXP: i32 = 4;\n    /// Maximum possible [`f16`](struct.f16.html) power of 2 exponent.\n    pub const MAX_EXP: i32 = 16;\n    /// Smallest finite [`f16`](struct.f16.html) value.\n    pub const MIN: f16 = f16(0xFBFF);\n    /// Minimum possible normal [`f16`](struct.f16.html) power of 10 exponent.\n    pub const MIN_10_EXP: i32 = -4;\n    /// One greater than the minimum possible normal [`f16`](struct.f16.html) power of 2 exponent.\n    pub const MIN_EXP: i32 = -13;\n    /// Smallest positive normal [`f16`](struct.f16.html) value.\n    pub const MIN_POSITIVE: f16 = f16(0x0400u16);\n    /// [`f16`](struct.f16.html) Not a Number (NaN).\n    pub const NAN: f16 = f16(0x7E00u16);\n    /// [`f16`](struct.f16.html) negative infinity (-âˆž).\n    pub const NEG_INFINITY: f16 = f16(0xFC00u16);\n    /// The radix or base of the internal representation of [`f16`](struct.f16.html).\n    pub const RADIX: u32 = 2;\n\n    /// Minimum positive subnormal [`f16`](struct.f16.html) value.\n    pub const MIN_POSITIVE_SUBNORMAL: f16 = f16(0x0001u16);\n    /// Maximum subnormal [`f16`](struct.f16.html) value.\n    pub const MAX_SUBNORMAL: f16 = f16(0x03FFu16);\n\n    /// [`f16`](struct.f16.html) 1\n    pub const ONE: f16 = f16(0x3C00u16);\n    /// [`f16`](struct.f16.html) 0\n    pub const ZERO: f16 = f16(0x0000u16);\n    /// [`f16`](struct.f16.html) -0\n    pub const NEG_ZERO: f16 = f16(0x8000u16);\n\n    /// [`f16`](struct.f16.html) Euler's number (â„¯).\n    pub const E: f16 = f16(0x4170u16);\n    /// [`f16`](struct.f16.html) Archimedes' constant (Ï€).\n    pub const PI: f16 = f16(0x4248u16);\n    /// [`f16`](struct.f16.html) 1/Ï€\n    pub const FRAC_1_PI: f16 = f16(0x3518u16);\n    /// [`f16`](struct.f16.html) 1/âˆš2\n    pub const FRAC_1_SQRT_2: f16 = f16(0x39A8u16);\n    /// [`f16`](struct.f16.html) 2/Ï€\n    pub const FRAC_2_PI: f16 = f16(0x3918u16);\n    /// [`f16`](struct.f16.html) 2/âˆšÏ€\n    pub const FRAC_2_SQRT_PI: f16 = f16(0x3C83u16);\n    /// [`f16`](struct.f16.html) Ï€/2\n    pub const FRAC_PI_2: f16 = f16(0x3E48u16);\n    /// [`f16`](struct.f16.html) Ï€/3\n    pub const FRAC_PI_3: f16 = f16(0x3C30u16);\n    /// [`f16`](struct.f16.html) Ï€/4\n    pub const FRAC_PI_4: f16 = f16(0x3A48u16);\n    /// [`f16`](struct.f16.html) Ï€/6\n    pub const FRAC_PI_6: f16 = f16(0x3830u16);\n    /// [`f16`](struct.f16.html) Ï€/8\n    pub const FRAC_PI_8: f16 = f16(0x3648u16);\n    /// [`f16`](struct.f16.html) ð—…ð—‡ 10\n    pub const LN_10: f16 = f16(0x409Bu16);\n    /// [`f16`](struct.f16.html) ð—…ð—‡ 2\n    pub const LN_2: f16 = f16(0x398Cu16);\n    /// [`f16`](struct.f16.html) ð—…ð—ˆð—€â‚â‚€â„¯\n    pub const LOG10_E: f16 = f16(0x36F3u16);\n    /// [`f16`](struct.f16.html) ð—…ð—ˆð—€â‚â‚€2\n    pub const LOG10_2: f16 = f16(0x34D1u16);\n    /// [`f16`](struct.f16.html) ð—…ð—ˆð—€â‚‚â„¯\n    pub const LOG2_E: f16 = f16(0x3DC5u16);\n    /// [`f16`](struct.f16.html) ð—…ð—ˆð—€â‚‚10\n    pub const LOG2_10: f16 = f16(0x42A5u16);\n    /// [`f16`](struct.f16.html) âˆš2\n    pub const SQRT_2: f16 = f16(0x3DA8u16);\n}\n\nimpl From<f16> for f32 {\n    #[inline]\n    fn from(x: f16) -> f32 {\n        x.to_f32()\n    }\n}\n\nimpl From<f16> for f64 {\n    #[inline]\n    fn from(x: f16) -> f64 {\n        x.to_f64()\n    }\n}\n\nimpl From<i8> for f16 {\n    #[inline]\n    fn from(x: i8) -> f16 {\n        // Convert to f32, then to f16\n        f16::from_f32(f32::from(x))\n    }\n}\n\nimpl From<u8> for f16 {\n    #[inline]\n    fn from(x: u8) -> f16 {\n        // Convert to f32, then to f16\n        f16::from_f32(f32::from(x))\n    }\n}\n\nimpl PartialEq for f16 {\n    fn eq(&self, other: &f16) -> bool {\n        if self.is_nan() || other.is_nan() {\n            false\n        } else {\n            (self.0 == other.0) || ((self.0 | other.0) & 0x7FFFu16 == 0)\n        }\n    }\n}\n\nimpl PartialOrd for f16 {\n    fn partial_cmp(&self, other: &f16) -> Option<Ordering> {\n        if self.is_nan() || other.is_nan() {\n            None\n        } else {\n            let neg = self.0 & 0x8000u16 != 0;\n            let other_neg = other.0 & 0x8000u16 != 0;\n            match (neg, other_neg) {\n                (false, false) => Some(self.0.cmp(&other.0)),\n                (false, true) => {\n                    if (self.0 | other.0) & 0x7FFFu16 == 0 {\n                        Some(Ordering::Equal)\n                    } else {\n                        Some(Ordering::Greater)\n                    }\n                }\n                (true, false) => {\n                    if (self.0 | other.0) & 0x7FFFu16 == 0 {\n                        Some(Ordering::Equal)\n                    } else {\n                        Some(Ordering::Less)\n                    }\n                }\n                (true, true) => Some(other.0.cmp(&self.0)),\n            }\n        }\n    }\n\n    fn lt(&self, other: &f16) -> bool {\n        if self.is_nan() || other.is_nan() {\n            false\n        } else {\n            let neg = self.0 & 0x8000u16 != 0;\n            let other_neg = other.0 & 0x8000u16 != 0;\n            match (neg, other_neg) {\n                (false, false) => self.0 < other.0,\n                (false, true) => false,\n                (true, false) => (self.0 | other.0) & 0x7FFFu16 != 0,\n                (true, true) => self.0 > other.0,\n            }\n        }\n    }\n\n    fn le(&self, other: &f16) -> bool {\n        if self.is_nan() || other.is_nan() {\n            false\n        } else {\n            let neg = self.0 & 0x8000u16 != 0;\n            let other_neg = other.0 & 0x8000u16 != 0;\n            match (neg, other_neg) {\n                (false, false) => self.0 <= other.0,\n                (false, true) => (self.0 | other.0) & 0x7FFFu16 == 0,\n                (true, false) => true,\n                (true, true) => self.0 >= other.0,\n            }\n        }\n    }\n\n    fn gt(&self, other: &f16) -> bool {\n        if self.is_nan() || other.is_nan() {\n            false\n        } else {\n            let neg = self.0 & 0x8000u16 != 0;\n            let other_neg = other.0 & 0x8000u16 != 0;\n            match (neg, other_neg) {\n                (false, false) => self.0 > other.0,\n                (false, true) => (self.0 | other.0) & 0x7FFFu16 != 0,\n                (true, false) => false,\n                (true, true) => self.0 < other.0,\n            }\n        }\n    }\n\n    fn ge(&self, other: &f16) -> bool {\n        if self.is_nan() || other.is_nan() {\n            false\n        } else {\n            let neg = self.0 & 0x8000u16 != 0;\n            let other_neg = other.0 & 0x8000u16 != 0;\n            match (neg, other_neg) {\n                (false, false) => self.0 >= other.0,\n                (false, true) => true,\n                (true, false) => (self.0 | other.0) & 0x7FFFu16 == 0,\n                (true, true) => self.0 <= other.0,\n            }\n        }\n    }\n}\n\nimpl FromStr for f16 {\n    type Err = ParseFloatError;\n    fn from_str(src: &str) -> Result<f16, ParseFloatError> {\n        f32::from_str(src).map(f16::from_f32)\n    }\n}\n\nimpl Debug for f16 {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        write!(f, \"{:?}\", self.to_f32())\n    }\n}\n\nimpl Display for f16 {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        write!(f, \"{}\", self.to_f32())\n    }\n}\n\nimpl LowerExp for f16 {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        write!(f, \"{:e}\", self.to_f32())\n    }\n}\n\nimpl UpperExp for f16 {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        write!(f, \"{:E}\", self.to_f32())\n    }\n}\n\nimpl Binary for f16 {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        write!(f, \"{:b}\", self.0)\n    }\n}\n\nimpl Octal for f16 {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        write!(f, \"{:o}\", self.0)\n    }\n}\n\nimpl LowerHex for f16 {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        write!(f, \"{:x}\", self.0)\n    }\n}\n\nimpl UpperHex for f16 {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        write!(f, \"{:X}\", self.0)\n    }\n}\n\n#[allow(\n    clippy::cognitive_complexity,\n    clippy::float_cmp,\n    clippy::neg_cmp_op_on_partial_ord\n)]\n#[cfg(test)]\nmod test {\n    use super::*;\n    use core;\n    use core::cmp::Ordering;\n    use quickcheck_macros::quickcheck;\n\n    #[test]\n    fn test_f16_consts() {\n        // DIGITS\n        let digits = ((f16::MANTISSA_DIGITS as f32 - 1.0) * 2f32.log10()).floor() as u32;\n        assert_eq!(f16::DIGITS, digits);\n        // sanity check to show test is good\n        let digits32 = ((core::f32::MANTISSA_DIGITS as f32 - 1.0) * 2f32.log10()).floor() as u32;\n        assert_eq!(core::f32::DIGITS, digits32);\n\n        // EPSILON\n        let one = f16::from_f32(1.0);\n        let one_plus_epsilon = f16::from_bits(one.to_bits() + 1);\n        let epsilon = f16::from_f32(one_plus_epsilon.to_f32() - 1.0);\n        assert_eq!(f16::EPSILON, epsilon);\n        // sanity check to show test is good\n        let one_plus_epsilon32 = f32::from_bits(1.0f32.to_bits() + 1);\n        let epsilon32 = one_plus_epsilon32 - 1f32;\n        assert_eq!(core::f32::EPSILON, epsilon32);\n\n        // MAX, MIN and MIN_POSITIVE\n        let max = f16::from_bits(f16::INFINITY.to_bits() - 1);\n        let min = f16::from_bits(f16::NEG_INFINITY.to_bits() - 1);\n        let min_pos = f16::from_f32(2f32.powi(f16::MIN_EXP - 1));\n        assert_eq!(f16::MAX, max);\n        assert_eq!(f16::MIN, min);\n        assert_eq!(f16::MIN_POSITIVE, min_pos);\n        // sanity check to show test is good\n        let max32 = f32::from_bits(core::f32::INFINITY.to_bits() - 1);\n        let min32 = f32::from_bits(core::f32::NEG_INFINITY.to_bits() - 1);\n        let min_pos32 = 2f32.powi(core::f32::MIN_EXP - 1);\n        assert_eq!(core::f32::MAX, max32);\n        assert_eq!(core::f32::MIN, min32);\n        assert_eq!(core::f32::MIN_POSITIVE, min_pos32);\n\n        // MIN_10_EXP and MAX_10_EXP\n        let ten_to_min = 10f32.powi(f16::MIN_10_EXP);\n        assert!(ten_to_min / 10.0 < f16::MIN_POSITIVE.to_f32());\n        assert!(ten_to_min > f16::MIN_POSITIVE.to_f32());\n        let ten_to_max = 10f32.powi(f16::MAX_10_EXP);\n        assert!(ten_to_max < f16::MAX.to_f32());\n        assert!(ten_to_max * 10.0 > f16::MAX.to_f32());\n        // sanity check to show test is good\n        let ten_to_min32 = 10f64.powi(core::f32::MIN_10_EXP);\n        assert!(ten_to_min32 / 10.0 < f64::from(core::f32::MIN_POSITIVE));\n        assert!(ten_to_min32 > f64::from(core::f32::MIN_POSITIVE));\n        let ten_to_max32 = 10f64.powi(core::f32::MAX_10_EXP);\n        assert!(ten_to_max32 < f64::from(core::f32::MAX));\n        assert!(ten_to_max32 * 10.0 > f64::from(core::f32::MAX));\n    }\n\n    #[test]\n    fn test_f16_consts_from_f32() {\n        let one = f16::from_f32(1.0);\n        let zero = f16::from_f32(0.0);\n        let neg_zero = f16::from_f32(-0.0);\n        let inf = f16::from_f32(core::f32::INFINITY);\n        let neg_inf = f16::from_f32(core::f32::NEG_INFINITY);\n        let nan = f16::from_f32(core::f32::NAN);\n\n        assert_eq!(f16::ONE, one);\n        assert_eq!(f16::ZERO, zero);\n        assert!(zero.is_sign_positive());\n        assert_eq!(f16::NEG_ZERO, neg_zero);\n        assert!(neg_zero.is_sign_negative());\n        assert_eq!(f16::INFINITY, inf);\n        assert_eq!(f16::NEG_INFINITY, neg_inf);\n        assert!(nan.is_nan());\n        assert!(f16::NAN.is_nan());\n\n        let e = f16::from_f32(core::f32::consts::E);\n        let pi = f16::from_f32(core::f32::consts::PI);\n        let frac_1_pi = f16::from_f32(core::f32::consts::FRAC_1_PI);\n        let frac_1_sqrt_2 = f16::from_f32(core::f32::consts::FRAC_1_SQRT_2);\n        let frac_2_pi = f16::from_f32(core::f32::consts::FRAC_2_PI);\n        let frac_2_sqrt_pi = f16::from_f32(core::f32::consts::FRAC_2_SQRT_PI);\n        let frac_pi_2 = f16::from_f32(core::f32::consts::FRAC_PI_2);\n        let frac_pi_3 = f16::from_f32(core::f32::consts::FRAC_PI_3);\n        let frac_pi_4 = f16::from_f32(core::f32::consts::FRAC_PI_4);\n        let frac_pi_6 = f16::from_f32(core::f32::consts::FRAC_PI_6);\n        let frac_pi_8 = f16::from_f32(core::f32::consts::FRAC_PI_8);\n        let ln_10 = f16::from_f32(core::f32::consts::LN_10);\n        let ln_2 = f16::from_f32(core::f32::consts::LN_2);\n        let log10_e = f16::from_f32(core::f32::consts::LOG10_E);\n        // core::f32::consts::LOG10_2 requires rustc 1.43.0\n        let log10_2 = f16::from_f32(2f32.log10());\n        let log2_e = f16::from_f32(core::f32::consts::LOG2_E);\n        // core::f32::consts::LOG2_10 requires rustc 1.43.0\n        let log2_10 = f16::from_f32(10f32.log2());\n        let sqrt_2 = f16::from_f32(core::f32::consts::SQRT_2);\n\n        assert_eq!(f16::E, e);\n        assert_eq!(f16::PI, pi);\n        assert_eq!(f16::FRAC_1_PI, frac_1_pi);\n        assert_eq!(f16::FRAC_1_SQRT_2, frac_1_sqrt_2);\n        assert_eq!(f16::FRAC_2_PI, frac_2_pi);\n        assert_eq!(f16::FRAC_2_SQRT_PI, frac_2_sqrt_pi);\n        assert_eq!(f16::FRAC_PI_2, frac_pi_2);\n        assert_eq!(f16::FRAC_PI_3, frac_pi_3);\n        assert_eq!(f16::FRAC_PI_4, frac_pi_4);\n        assert_eq!(f16::FRAC_PI_6, frac_pi_6);\n        assert_eq!(f16::FRAC_PI_8, frac_pi_8);\n        assert_eq!(f16::LN_10, ln_10);\n        assert_eq!(f16::LN_2, ln_2);\n        assert_eq!(f16::LOG10_E, log10_e);\n        assert_eq!(f16::LOG10_2, log10_2);\n        assert_eq!(f16::LOG2_E, log2_e);\n        assert_eq!(f16::LOG2_10, log2_10);\n        assert_eq!(f16::SQRT_2, sqrt_2);\n    }\n\n    #[test]\n    fn test_f16_consts_from_f64() {\n        let one = f16::from_f64(1.0);\n        let zero = f16::from_f64(0.0);\n        let neg_zero = f16::from_f64(-0.0);\n        let inf = f16::from_f64(core::f64::INFINITY);\n        let neg_inf = f16::from_f64(core::f64::NEG_INFINITY);\n        let nan = f16::from_f64(core::f64::NAN);\n\n        assert_eq!(f16::ONE, one);\n        assert_eq!(f16::ZERO, zero);\n        assert!(zero.is_sign_positive());\n        assert_eq!(f16::NEG_ZERO, neg_zero);\n        assert!(neg_zero.is_sign_negative());\n        assert_eq!(f16::INFINITY, inf);\n        assert_eq!(f16::NEG_INFINITY, neg_inf);\n        assert!(nan.is_nan());\n        assert!(f16::NAN.is_nan());\n\n        let e = f16::from_f64(core::f64::consts::E);\n        let pi = f16::from_f64(core::f64::consts::PI);\n        let frac_1_pi = f16::from_f64(core::f64::consts::FRAC_1_PI);\n        let frac_1_sqrt_2 = f16::from_f64(core::f64::consts::FRAC_1_SQRT_2);\n        let frac_2_pi = f16::from_f64(core::f64::consts::FRAC_2_PI);\n        let frac_2_sqrt_pi = f16::from_f64(core::f64::consts::FRAC_2_SQRT_PI);\n        let frac_pi_2 = f16::from_f64(core::f64::consts::FRAC_PI_2);\n        let frac_pi_3 = f16::from_f64(core::f64::consts::FRAC_PI_3);\n        let frac_pi_4 = f16::from_f64(core::f64::consts::FRAC_PI_4);\n        let frac_pi_6 = f16::from_f64(core::f64::consts::FRAC_PI_6);\n        let frac_pi_8 = f16::from_f64(core::f64::consts::FRAC_PI_8);\n        let ln_10 = f16::from_f64(core::f64::consts::LN_10);\n        let ln_2 = f16::from_f64(core::f64::consts::LN_2);\n        let log10_e = f16::from_f64(core::f64::consts::LOG10_E);\n        // core::f64::consts::LOG10_2 requires rustc 1.43.0\n        let log10_2 = f16::from_f64(2f64.log10());\n        let log2_e = f16::from_f64(core::f64::consts::LOG2_E);\n        // core::f64::consts::LOG2_10 requires rustc 1.43.0\n        let log2_10 = f16::from_f64(10f64.log2());\n        let sqrt_2 = f16::from_f64(core::f64::consts::SQRT_2);\n\n        assert_eq!(f16::E, e);\n        assert_eq!(f16::PI, pi);\n        assert_eq!(f16::FRAC_1_PI, frac_1_pi);\n        assert_eq!(f16::FRAC_1_SQRT_2, frac_1_sqrt_2);\n        assert_eq!(f16::FRAC_2_PI, frac_2_pi);\n        assert_eq!(f16::FRAC_2_SQRT_PI, frac_2_sqrt_pi);\n        assert_eq!(f16::FRAC_PI_2, frac_pi_2);\n        assert_eq!(f16::FRAC_PI_3, frac_pi_3);\n        assert_eq!(f16::FRAC_PI_4, frac_pi_4);\n        assert_eq!(f16::FRAC_PI_6, frac_pi_6);\n        assert_eq!(f16::FRAC_PI_8, frac_pi_8);\n        assert_eq!(f16::LN_10, ln_10);\n        assert_eq!(f16::LN_2, ln_2);\n        assert_eq!(f16::LOG10_E, log10_e);\n        assert_eq!(f16::LOG10_2, log10_2);\n        assert_eq!(f16::LOG2_E, log2_e);\n        assert_eq!(f16::LOG2_10, log2_10);\n        assert_eq!(f16::SQRT_2, sqrt_2);\n    }\n\n    #[test]\n    fn test_nan_conversion_to_smaller() {\n        let nan64 = f64::from_bits(0x7FF0_0000_0000_0001u64);\n        let neg_nan64 = f64::from_bits(0xFFF0_0000_0000_0001u64);\n        let nan32 = f32::from_bits(0x7F80_0001u32);\n        let neg_nan32 = f32::from_bits(0xFF80_0001u32);\n        let nan32_from_64 = nan64 as f32;\n        let neg_nan32_from_64 = neg_nan64 as f32;\n        let nan16_from_64 = f16::from_f64(nan64);\n        let neg_nan16_from_64 = f16::from_f64(neg_nan64);\n        let nan16_from_32 = f16::from_f32(nan32);\n        let neg_nan16_from_32 = f16::from_f32(neg_nan32);\n\n        assert!(nan64.is_nan() && nan64.is_sign_positive());\n        assert!(neg_nan64.is_nan() && neg_nan64.is_sign_negative());\n        assert!(nan32.is_nan() && nan32.is_sign_positive());\n        assert!(neg_nan32.is_nan() && neg_nan32.is_sign_negative());\n        assert!(nan32_from_64.is_nan() && nan32_from_64.is_sign_positive());\n        assert!(neg_nan32_from_64.is_nan() && neg_nan32_from_64.is_sign_negative());\n        assert!(nan16_from_64.is_nan() && nan16_from_64.is_sign_positive());\n        assert!(neg_nan16_from_64.is_nan() && neg_nan16_from_64.is_sign_negative());\n        assert!(nan16_from_32.is_nan() && nan16_from_32.is_sign_positive());\n        assert!(neg_nan16_from_32.is_nan() && neg_nan16_from_32.is_sign_negative());\n    }\n\n    #[test]\n    fn test_nan_conversion_to_larger() {\n        let nan16 = f16::from_bits(0x7C01u16);\n        let neg_nan16 = f16::from_bits(0xFC01u16);\n        let nan32 = f32::from_bits(0x7F80_0001u32);\n        let neg_nan32 = f32::from_bits(0xFF80_0001u32);\n        let nan32_from_16 = f32::from(nan16);\n        let neg_nan32_from_16 = f32::from(neg_nan16);\n        let nan64_from_16 = f64::from(nan16);\n        let neg_nan64_from_16 = f64::from(neg_nan16);\n        let nan64_from_32 = f64::from(nan32);\n        let neg_nan64_from_32 = f64::from(neg_nan32);\n\n        assert!(nan16.is_nan() && nan16.is_sign_positive());\n        assert!(neg_nan16.is_nan() && neg_nan16.is_sign_negative());\n        assert!(nan32.is_nan() && nan32.is_sign_positive());\n        assert!(neg_nan32.is_nan() && neg_nan32.is_sign_negative());\n        assert!(nan32_from_16.is_nan() && nan32_from_16.is_sign_positive());\n        assert!(neg_nan32_from_16.is_nan() && neg_nan32_from_16.is_sign_negative());\n        assert!(nan64_from_16.is_nan() && nan64_from_16.is_sign_positive());\n        assert!(neg_nan64_from_16.is_nan() && neg_nan64_from_16.is_sign_negative());\n        assert!(nan64_from_32.is_nan() && nan64_from_32.is_sign_positive());\n        assert!(neg_nan64_from_32.is_nan() && neg_nan64_from_32.is_sign_negative());\n    }\n\n    #[test]\n    fn test_f16_to_f32() {\n        let f = f16::from_f32(7.0);\n        assert_eq!(f.to_f32(), 7.0f32);\n\n        // 7.1 is NOT exactly representable in 16-bit, it's rounded\n        let f = f16::from_f32(7.1);\n        let diff = (f.to_f32() - 7.1f32).abs();\n        // diff must be <= 4 * EPSILON, as 7 has two more significant bits than 1\n        assert!(diff <= 4.0 * f16::EPSILON.to_f32());\n\n        assert_eq!(f16::from_bits(0x0000_0001).to_f32(), 2.0f32.powi(-24));\n        assert_eq!(f16::from_bits(0x0000_0005).to_f32(), 5.0 * 2.0f32.powi(-24));\n\n        assert_eq!(f16::from_bits(0x0000_0001), f16::from_f32(2.0f32.powi(-24)));\n        assert_eq!(\n            f16::from_bits(0x0000_0005),\n            f16::from_f32(5.0 * 2.0f32.powi(-24))\n        );\n    }\n\n    #[test]\n    fn test_f16_to_f64() {\n        let f = f16::from_f64(7.0);\n        assert_eq!(f.to_f64(), 7.0f64);\n\n        // 7.1 is NOT exactly representable in 16-bit, it's rounded\n        let f = f16::from_f64(7.1);\n        let diff = (f.to_f64() - 7.1f64).abs();\n        // diff must be <= 4 * EPSILON, as 7 has two more significant bits than 1\n        assert!(diff <= 4.0 * f16::EPSILON.to_f64());\n\n        assert_eq!(f16::from_bits(0x0000_0001).to_f64(), 2.0f64.powi(-24));\n        assert_eq!(f16::from_bits(0x0000_0005).to_f64(), 5.0 * 2.0f64.powi(-24));\n\n        assert_eq!(f16::from_bits(0x0000_0001), f16::from_f64(2.0f64.powi(-24)));\n        assert_eq!(\n            f16::from_bits(0x0000_0005),\n            f16::from_f64(5.0 * 2.0f64.powi(-24))\n        );\n    }\n\n    #[test]\n    fn test_comparisons() {\n        let zero = f16::from_f64(0.0);\n        let one = f16::from_f64(1.0);\n        let neg_zero = f16::from_f64(-0.0);\n        let neg_one = f16::from_f64(-1.0);\n\n        assert_eq!(zero.partial_cmp(&neg_zero), Some(Ordering::Equal));\n        assert_eq!(neg_zero.partial_cmp(&zero), Some(Ordering::Equal));\n        assert!(zero == neg_zero);\n        assert!(neg_zero == zero);\n        assert!(!(zero != neg_zero));\n        assert!(!(neg_zero != zero));\n        assert!(!(zero < neg_zero));\n        assert!(!(neg_zero < zero));\n        assert!(zero <= neg_zero);\n        assert!(neg_zero <= zero);\n        assert!(!(zero > neg_zero));\n        assert!(!(neg_zero > zero));\n        assert!(zero >= neg_zero);\n        assert!(neg_zero >= zero);\n\n        assert_eq!(one.partial_cmp(&neg_zero), Some(Ordering::Greater));\n        assert_eq!(neg_zero.partial_cmp(&one), Some(Ordering::Less));\n        assert!(!(one == neg_zero));\n        assert!(!(neg_zero == one));\n        assert!(one != neg_zero);\n        assert!(neg_zero != one);\n        assert!(!(one < neg_zero));\n        assert!(neg_zero < one);\n        assert!(!(one <= neg_zero));\n        assert!(neg_zero <= one);\n        assert!(one > neg_zero);\n        assert!(!(neg_zero > one));\n        assert!(one >= neg_zero);\n        assert!(!(neg_zero >= one));\n\n        assert_eq!(one.partial_cmp(&neg_one), Some(Ordering::Greater));\n        assert_eq!(neg_one.partial_cmp(&one), Some(Ordering::Less));\n        assert!(!(one == neg_one));\n        assert!(!(neg_one == one));\n        assert!(one != neg_one);\n        assert!(neg_one != one);\n        assert!(!(one < neg_one));\n        assert!(neg_one < one);\n        assert!(!(one <= neg_one));\n        assert!(neg_one <= one);\n        assert!(one > neg_one);\n        assert!(!(neg_one > one));\n        assert!(one >= neg_one);\n        assert!(!(neg_one >= one));\n    }\n\n    #[test]\n    #[allow(clippy::erasing_op, clippy::identity_op)]\n    fn round_to_even_f32() {\n        // smallest positive subnormal = 0b0.0000_0000_01 * 2^-14 = 2^-24\n        let min_sub = f16::from_bits(1);\n        let min_sub_f = (-24f32).exp2();\n        assert_eq!(f16::from_f32(min_sub_f).to_bits(), min_sub.to_bits());\n        assert_eq!(f32::from(min_sub).to_bits(), min_sub_f.to_bits());\n\n        // 0.0000000000_011111 rounded to 0.0000000000 (< tie, no rounding)\n        // 0.0000000000_100000 rounded to 0.0000000000 (tie and even, remains at even)\n        // 0.0000000000_100001 rounded to 0.0000000001 (> tie, rounds up)\n        assert_eq!(\n            f16::from_f32(min_sub_f * 0.49).to_bits(),\n            min_sub.to_bits() * 0\n        );\n        assert_eq!(\n            f16::from_f32(min_sub_f * 0.50).to_bits(),\n            min_sub.to_bits() * 0\n        );\n        assert_eq!(\n            f16::from_f32(min_sub_f * 0.51).to_bits(),\n            min_sub.to_bits() * 1\n        );\n\n        // 0.0000000001_011111 rounded to 0.0000000001 (< tie, no rounding)\n        // 0.0000000001_100000 rounded to 0.0000000010 (tie and odd, rounds up to even)\n        // 0.0000000001_100001 rounded to 0.0000000010 (> tie, rounds up)\n        assert_eq!(\n            f16::from_f32(min_sub_f * 1.49).to_bits(),\n            min_sub.to_bits() * 1\n        );\n        assert_eq!(\n            f16::from_f32(min_sub_f * 1.50).to_bits(),\n            min_sub.to_bits() * 2\n        );\n        assert_eq!(\n            f16::from_f32(min_sub_f * 1.51).to_bits(),\n            min_sub.to_bits() * 2\n        );\n\n        // 0.0000000010_011111 rounded to 0.0000000010 (< tie, no rounding)\n        // 0.0000000010_100000 rounded to 0.0000000010 (tie and even, remains at even)\n        // 0.0000000010_100001 rounded to 0.0000000011 (> tie, rounds up)\n        assert_eq!(\n            f16::from_f32(min_sub_f * 2.49).to_bits(),\n            min_sub.to_bits() * 2\n        );\n        assert_eq!(\n            f16::from_f32(min_sub_f * 2.50).to_bits(),\n            min_sub.to_bits() * 2\n        );\n        assert_eq!(\n            f16::from_f32(min_sub_f * 2.51).to_bits(),\n            min_sub.to_bits() * 3\n        );\n\n        assert_eq!(\n            f16::from_f32(2000.49f32).to_bits(),\n            f16::from_f32(2000.0).to_bits()\n        );\n        assert_eq!(\n            f16::from_f32(2000.50f32).to_bits(),\n            f16::from_f32(2000.0).to_bits()\n        );\n        assert_eq!(\n            f16::from_f32(2000.51f32).to_bits(),\n            f16::from_f32(2001.0).to_bits()\n        );\n        assert_eq!(\n            f16::from_f32(2001.49f32).to_bits(),\n            f16::from_f32(2001.0).to_bits()\n        );\n        assert_eq!(\n            f16::from_f32(2001.50f32).to_bits(),\n            f16::from_f32(2002.0).to_bits()\n        );\n        assert_eq!(\n            f16::from_f32(2001.51f32).to_bits(),\n            f16::from_f32(2002.0).to_bits()\n        );\n        assert_eq!(\n            f16::from_f32(2002.49f32).to_bits(),\n            f16::from_f32(2002.0).to_bits()\n        );\n        assert_eq!(\n            f16::from_f32(2002.50f32).to_bits(),\n            f16::from_f32(2002.0).to_bits()\n        );\n        assert_eq!(\n            f16::from_f32(2002.51f32).to_bits(),\n            f16::from_f32(2003.0).to_bits()\n        );\n    }\n\n    #[test]\n    #[allow(clippy::erasing_op, clippy::identity_op)]\n    fn round_to_even_f64() {\n        // smallest positive subnormal = 0b0.0000_0000_01 * 2^-14 = 2^-24\n        let min_sub = f16::from_bits(1);\n        let min_sub_f = (-24f64).exp2();\n        assert_eq!(f16::from_f64(min_sub_f).to_bits(), min_sub.to_bits());\n        assert_eq!(f64::from(min_sub).to_bits(), min_sub_f.to_bits());\n\n        // 0.0000000000_011111 rounded to 0.0000000000 (< tie, no rounding)\n        // 0.0000000000_100000 rounded to 0.0000000000 (tie and even, remains at even)\n        // 0.0000000000_100001 rounded to 0.0000000001 (> tie, rounds up)\n        assert_eq!(\n            f16::from_f64(min_sub_f * 0.49).to_bits(),\n            min_sub.to_bits() * 0\n        );\n        assert_eq!(\n            f16::from_f64(min_sub_f * 0.50).to_bits(),\n            min_sub.to_bits() * 0\n        );\n        assert_eq!(\n            f16::from_f64(min_sub_f * 0.51).to_bits(),\n            min_sub.to_bits() * 1\n        );\n\n        // 0.0000000001_011111 rounded to 0.0000000001 (< tie, no rounding)\n        // 0.0000000001_100000 rounded to 0.0000000010 (tie and odd, rounds up to even)\n        // 0.0000000001_100001 rounded to 0.0000000010 (> tie, rounds up)\n        assert_eq!(\n            f16::from_f64(min_sub_f * 1.49).to_bits(),\n            min_sub.to_bits() * 1\n        );\n        assert_eq!(\n            f16::from_f64(min_sub_f * 1.50).to_bits(),\n            min_sub.to_bits() * 2\n        );\n        assert_eq!(\n            f16::from_f64(min_sub_f * 1.51).to_bits(),\n            min_sub.to_bits() * 2\n        );\n\n        // 0.0000000010_011111 rounded to 0.0000000010 (< tie, no rounding)\n        // 0.0000000010_100000 rounded to 0.0000000010 (tie and even, remains at even)\n        // 0.0000000010_100001 rounded to 0.0000000011 (> tie, rounds up)\n        assert_eq!(\n            f16::from_f64(min_sub_f * 2.49).to_bits(),\n            min_sub.to_bits() * 2\n        );\n        assert_eq!(\n            f16::from_f64(min_sub_f * 2.50).to_bits(),\n            min_sub.to_bits() * 2\n        );\n        assert_eq!(\n            f16::from_f64(min_sub_f * 2.51).to_bits(),\n            min_sub.to_bits() * 3\n        );\n\n        assert_eq!(\n            f16::from_f64(2000.49f64).to_bits(),\n            f16::from_f64(2000.0).to_bits()\n        );\n        assert_eq!(\n            f16::from_f64(2000.50f64).to_bits(),\n            f16::from_f64(2000.0).to_bits()\n        );\n        assert_eq!(\n            f16::from_f64(2000.51f64).to_bits(),\n            f16::from_f64(2001.0).to_bits()\n        );\n        assert_eq!(\n            f16::from_f64(2001.49f64).to_bits(),\n            f16::from_f64(2001.0).to_bits()\n        );\n        assert_eq!(\n            f16::from_f64(2001.50f64).to_bits(),\n            f16::from_f64(2002.0).to_bits()\n        );\n        assert_eq!(\n            f16::from_f64(2001.51f64).to_bits(),\n            f16::from_f64(2002.0).to_bits()\n        );\n        assert_eq!(\n            f16::from_f64(2002.49f64).to_bits(),\n            f16::from_f64(2002.0).to_bits()\n        );\n        assert_eq!(\n            f16::from_f64(2002.50f64).to_bits(),\n            f16::from_f64(2002.0).to_bits()\n        );\n        assert_eq!(\n            f16::from_f64(2002.51f64).to_bits(),\n            f16::from_f64(2003.0).to_bits()\n        );\n    }\n\n    impl quickcheck::Arbitrary for f16 {\n        fn arbitrary<G: quickcheck::Gen>(g: &mut G) -> Self {\n            use rand::Rng;\n            f16(g.gen())\n        }\n    }\n\n    #[quickcheck]\n    fn qc_roundtrip_f16_f32_is_identity(f: f16) -> bool {\n        let roundtrip = f16::from_f32(f.to_f32());\n        if f.is_nan() {\n            roundtrip.is_nan() && f.is_sign_negative() == roundtrip.is_sign_negative()\n        } else {\n            f.0 == roundtrip.0\n        }\n    }\n\n    #[quickcheck]\n    fn qc_roundtrip_f16_f64_is_identity(f: f16) -> bool {\n        let roundtrip = f16::from_f64(f.to_f64());\n        if f.is_nan() {\n            roundtrip.is_nan() && f.is_sign_negative() == roundtrip.is_sign_negative()\n        } else {\n            f.0 == roundtrip.0\n        }\n    }\n}\n"],["843","//! Contains utility functions and traits to convert between vectors of `u16` bits and `f16` or\n//! `bf16` vectors.\n//!\n//! The utility [`HalfBitsVecExt`] sealed extension trait is implemented for `Vec<u16>` vectors,\n//! while the utility [`HalfFloatVecExt`] sealed extension trait is implemented for both `Vec<f16>`\n//! and `Vec<bf16>` vectors. These traits provide efficient conversions and reinterpret casting of\n//! larger buffers of floating point values, and are automatically included in the [`prelude`]\n//! module.\n//!\n//! This module is only available with the `std` or `alloc` feature.\n//!\n//! [`HalfBitsVecExt`]: trait.HalfBitsVecExt.html\n//! [`HalfFloatVecExt`]: trait.HalfFloatVecExt.html\n//! [`prelude`]: ../prelude/index.html\n\n#![cfg(any(feature = \"alloc\", feature = \"std\"))]\n\nuse super::{bf16, f16, slice::HalfFloatSliceExt};\n#[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\nuse alloc::vec::Vec;\nuse core::mem;\n\n/// Extensions to `Vec<f16>` and `Vec<bf16>` to support reinterpret operations.\n///\n/// This trait is sealed and cannot be implemented outside of this crate.\npub trait HalfFloatVecExt: private::SealedHalfFloatVec {\n    /// Reinterpret a vector of [`f16`](../struct.f16.html) or [`bf16`](../struct.bf16.html)\n    /// numbers as a vector of `u16` bits.\n    ///\n    /// This is a zero-copy operation. The reinterpreted vector has the same memory location as\n    /// `self`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    /// let float_buffer = vec![f16::from_f32(1.), f16::from_f32(2.), f16::from_f32(3.)];\n    /// let int_buffer = float_buffer.reinterpret_into();\n    ///\n    /// assert_eq!(int_buffer, [f16::from_f32(1.).to_bits(), f16::from_f32(2.).to_bits(), f16::from_f32(3.).to_bits()]);\n    /// ```\n    fn reinterpret_into(self) -> Vec<u16>;\n\n    /// Convert all of the elements of a `[f32]` slice into a new [`f16`](../struct.f16.html) or\n    /// [`bf16`](../struct.bf16.html) vector.\n    ///\n    /// The conversion operation is vectorized over the slice, meaning the conversion may be more\n    /// efficient than converting individual elements on some hardware that supports SIMD\n    /// conversions. See [crate documentation](../index.html) for more information on hardware\n    /// conversion support.\n    ///\n    /// # Examples\n    /// ```rust\n    /// # use half::prelude::*;\n    /// let float_values = [1., 2., 3., 4.];\n    /// let vec: Vec<f16> = Vec::from_f32_slice(&float_values);\n    ///\n    /// assert_eq!(vec, vec![f16::from_f32(1.), f16::from_f32(2.), f16::from_f32(3.), f16::from_f32(4.)]);\n    /// ```\n    fn from_f32_slice(slice: &[f32]) -> Self;\n\n    /// Convert all of the elements of a `[f64]` slice into a new [`f16`](../struct.f16.html) or\n    /// [`bf16`](../struct.bf16.html) vector.\n    ///\n    /// The conversion operation is vectorized over the slice, meaning the conversion may be more\n    /// efficient than converting individual elements on some hardware that supports SIMD\n    /// conversions. See [crate documentation](../index.html) for more information on hardware\n    /// conversion support.\n    ///\n    /// # Examples\n    /// ```rust\n    /// # use half::prelude::*;\n    /// let float_values = [1., 2., 3., 4.];\n    /// let vec: Vec<f16> = Vec::from_f64_slice(&float_values);\n    ///\n    /// assert_eq!(vec, vec![f16::from_f64(1.), f16::from_f64(2.), f16::from_f64(3.), f16::from_f64(4.)]);\n    /// ```\n    fn from_f64_slice(slice: &[f64]) -> Self;\n}\n\n/// Extensions to `Vec<u16>` to support reinterpret operations.\n///\n/// This trait is sealed and cannot be implemented outside of this crate.\npub trait HalfBitsVecExt: private::SealedHalfBitsVec {\n    /// Reinterpret a vector of `u16` bits as a vector of [`f16`](../struct.f16.html) or\n    /// [`bf16`](../struct.bf16.html) numbers.\n    ///\n    /// `H` is the type to cast to, and must be either the [`f16`](../struct.f16.html) or\n    /// [`bf16`](../struct.bf16.html) type.\n    ///\n    /// This is a zero-copy operation. The reinterpreted vector has the same memory location as\n    /// `self`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    /// let int_buffer = vec![f16::from_f32(1.).to_bits(), f16::from_f32(2.).to_bits(), f16::from_f32(3.).to_bits()];\n    /// let float_buffer = int_buffer.reinterpret_into::<f16>();\n    ///\n    /// assert_eq!(float_buffer, [f16::from_f32(1.), f16::from_f32(2.), f16::from_f32(3.)]);\n    /// ```\n    fn reinterpret_into<H>(self) -> Vec<H>\n    where\n        H: crate::private::SealedHalf;\n}\n\nmod private {\n    use crate::{bf16, f16};\n    #[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\n    use alloc::vec::Vec;\n\n    pub trait SealedHalfFloatVec {}\n    impl SealedHalfFloatVec for Vec<f16> {}\n    impl SealedHalfFloatVec for Vec<bf16> {}\n\n    pub trait SealedHalfBitsVec {}\n    impl SealedHalfBitsVec for Vec<u16> {}\n}\n\nimpl HalfFloatVecExt for Vec<f16> {\n    #[inline]\n    fn reinterpret_into(mut self) -> Vec<u16> {\n        // An f16 array has same length and capacity as u16 array\n        let length = self.len();\n        let capacity = self.capacity();\n\n        // Actually reinterpret the contents of the Vec<f16> as u16,\n        // knowing that structs are represented as only their members in memory,\n        // which is the u16 part of `f16(u16)`\n        let pointer = self.as_mut_ptr() as *mut u16;\n\n        // Prevent running a destructor on the old Vec<u16>, so the pointer won't be deleted\n        mem::forget(self);\n\n        // Finally construct a new Vec<f16> from the raw pointer\n        // SAFETY: We are reconstructing full length and capacity of original vector,\n        // using its original pointer, and the size of elements are identical.\n        unsafe { Vec::from_raw_parts(pointer, length, capacity) }\n    }\n\n    fn from_f32_slice(slice: &[f32]) -> Self {\n        let mut vec = Vec::with_capacity(slice.len());\n        // SAFETY: convert will initialize every value in the vector without reading them,\n        // so this is safe to do instead of double initialize from resize, and we're setting it to\n        // same value as capacity.\n        unsafe { vec.set_len(slice.len()) };\n        vec.convert_from_f32_slice(&slice);\n        vec\n    }\n\n    fn from_f64_slice(slice: &[f64]) -> Self {\n        let mut vec = Vec::with_capacity(slice.len());\n        // SAFETY: convert will initialize every value in the vector without reading them,\n        // so this is safe to do instead of double initialize from resize, and we're setting it to\n        // same value as capacity.\n        unsafe { vec.set_len(slice.len()) };\n        vec.convert_from_f64_slice(&slice);\n        vec\n    }\n}\n\nimpl HalfFloatVecExt for Vec<bf16> {\n    #[inline]\n    fn reinterpret_into(mut self) -> Vec<u16> {\n        // An f16 array has same length and capacity as u16 array\n        let length = self.len();\n        let capacity = self.capacity();\n\n        // Actually reinterpret the contents of the Vec<f16> as u16,\n        // knowing that structs are represented as only their members in memory,\n        // which is the u16 part of `f16(u16)`\n        let pointer = self.as_mut_ptr() as *mut u16;\n\n        // Prevent running a destructor on the old Vec<u16>, so the pointer won't be deleted\n        mem::forget(self);\n\n        // Finally construct a new Vec<f16> from the raw pointer\n        // SAFETY: We are reconstructing full length and capacity of original vector,\n        // using its original pointer, and the size of elements are identical.\n        unsafe { Vec::from_raw_parts(pointer, length, capacity) }\n    }\n\n    fn from_f32_slice(slice: &[f32]) -> Self {\n        let mut vec = Vec::with_capacity(slice.len());\n        // SAFETY: convert will initialize every value in the vector without reading them,\n        // so this is safe to do instead of double initialize from resize, and we're setting it to\n        // same value as capacity.\n        unsafe { vec.set_len(slice.len()) };\n        vec.convert_from_f32_slice(&slice);\n        vec\n    }\n\n    fn from_f64_slice(slice: &[f64]) -> Self {\n        let mut vec = Vec::with_capacity(slice.len());\n        // SAFETY: convert will initialize every value in the vector without reading them,\n        // so this is safe to do instead of double initialize from resize, and we're setting it to\n        // same value as capacity.\n        unsafe { vec.set_len(slice.len()) };\n        vec.convert_from_f64_slice(&slice);\n        vec\n    }\n}\n\nimpl HalfBitsVecExt for Vec<u16> {\n    // This is safe because all traits are sealed\n    #[inline]\n    fn reinterpret_into<H>(mut self) -> Vec<H>\n    where\n        H: crate::private::SealedHalf,\n    {\n        // An f16 array has same length and capacity as u16 array\n        let length = self.len();\n        let capacity = self.capacity();\n\n        // Actually reinterpret the contents of the Vec<u16> as f16,\n        // knowing that structs are represented as only their members in memory,\n        // which is the u16 part of `f16(u16)`\n        let pointer = self.as_mut_ptr() as *mut H;\n\n        // Prevent running a destructor on the old Vec<u16>, so the pointer won't be deleted\n        mem::forget(self);\n\n        // Finally construct a new Vec<f16> from the raw pointer\n        // SAFETY: We are reconstructing full length and capacity of original vector,\n        // using its original pointer, and the size of elements are identical.\n        unsafe { Vec::from_raw_parts(pointer, length, capacity) }\n    }\n}\n\n/// Converts a vector of `u16` elements into a vector of [`f16`](../struct.f16.html) elements.\n///\n/// This function merely reinterprets the contents of the vector, so it's a zero-copy operation.\n#[deprecated(\n    since = \"1.4.0\",\n    note = \"use [`HalfBitsVecExt::reinterpret_into`](trait.HalfBitsVecExt.html#tymethod.reinterpret_into) instead\"\n)]\n#[inline]\npub fn from_bits(bits: Vec<u16>) -> Vec<f16> {\n    bits.reinterpret_into()\n}\n\n/// Converts a vector of [`f16`](../struct.f16.html) elements into a vector of `u16` elements.\n///\n/// This function merely reinterprets the contents of the vector, so it's a zero-copy operation.\n#[deprecated(\n    since = \"1.4.0\",\n    note = \"use [`HalfFloatVecExt::reinterpret_into`](trait.HalfFloatVecExt.html#tymethod.reinterpret_into) instead\"\n)]\n#[inline]\npub fn to_bits(numbers: Vec<f16>) -> Vec<u16> {\n    numbers.reinterpret_into()\n}\n\n#[cfg(test)]\nmod test {\n    use super::{HalfBitsVecExt, HalfFloatVecExt};\n    use crate::{bf16, f16};\n    #[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\n    use alloc::vec;\n\n    #[test]\n    fn test_vec_conversions_f16() {\n        let numbers = vec![f16::E, f16::PI, f16::EPSILON, f16::FRAC_1_SQRT_2];\n        let bits = vec![\n            f16::E.to_bits(),\n            f16::PI.to_bits(),\n            f16::EPSILON.to_bits(),\n            f16::FRAC_1_SQRT_2.to_bits(),\n        ];\n        let bits_cloned = bits.clone();\n\n        // Convert from bits to numbers\n        let from_bits = bits.reinterpret_into::<f16>();\n        assert_eq!(&from_bits[..], &numbers[..]);\n\n        // Convert from numbers back to bits\n        let to_bits = from_bits.reinterpret_into();\n        assert_eq!(&to_bits[..], &bits_cloned[..]);\n    }\n\n    #[test]\n    fn test_vec_conversions_bf16() {\n        let numbers = vec![bf16::E, bf16::PI, bf16::EPSILON, bf16::FRAC_1_SQRT_2];\n        let bits = vec![\n            bf16::E.to_bits(),\n            bf16::PI.to_bits(),\n            bf16::EPSILON.to_bits(),\n            bf16::FRAC_1_SQRT_2.to_bits(),\n        ];\n        let bits_cloned = bits.clone();\n\n        // Convert from bits to numbers\n        let from_bits = bits.reinterpret_into::<bf16>();\n        assert_eq!(&from_bits[..], &numbers[..]);\n\n        // Convert from numbers back to bits\n        let to_bits = from_bits.reinterpret_into();\n        assert_eq!(&to_bits[..], &bits_cloned[..]);\n    }\n}\n"],["844","#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Serialize};\n\n#[cfg(feature = \"bytemuck\")]\nuse bytemuck::{Pod, Zeroable};\n\nuse core::{\n    cmp::Ordering,\n    fmt::{\n        Binary, Debug, Display, Error, Formatter, LowerExp, LowerHex, Octal, UpperExp, UpperHex,\n    },\n    num::{FpCategory, ParseFloatError},\n    str::FromStr,\n};\n\npub(crate) mod convert;\n\n/// A 16-bit floating point type implementing the [`bfloat16`] format.\n///\n/// The [`bfloat16`] floating point format is a truncated 16-bit version of the IEEE 754 standard\n/// `binary32`, a.k.a `f32`. [`bf16`] has approximately the same dynamic range as `f32` by having\n/// a lower precision than [`f16`]. While [`f16`] has a precision of 11 bits, [`bf16`] has a\n/// precision of only 8 bits.\n///\n/// Like [`f16`], [`bf16`] does not offer arithmetic operations as it is intended for compact\n/// storage rather than calculations. Operations should be performed with `f32` or higher-precision\n/// types and converted to/from [`bf16`] as necessary.\n///\n/// [`bfloat16`]: https://en.wikipedia.org/wiki/Bfloat16_floating-point_format\n/// [`bf16`]: struct.bf16.html\n/// [`f16`]: struct.f16.html\n#[allow(non_camel_case_types)]\n#[derive(Clone, Copy, Default)]\n#[repr(transparent)]\n#[cfg_attr(feature = \"serde\", derive(Serialize, Deserialize))]\n#[cfg_attr(feature = \"bytemuck\", derive(Zeroable, Pod))]\npub struct bf16(u16);\n\nimpl bf16 {\n    /// Constructs a [`bf16`](struct.bf16.html) value from the raw bits.\n    #[inline]\n    pub const fn from_bits(bits: u16) -> bf16 {\n        bf16(bits)\n    }\n\n    /// Constructs a [`bf16`](struct.bf16.html) value from a 32-bit floating point value.\n    ///\n    /// If the 32-bit value is too large to fit, Â±âˆž will result. NaN values are preserved.\n    /// Subnormal values that are too tiny to be represented will result in Â±0. All other values\n    /// are truncated and rounded to the nearest representable value.\n    #[inline]\n    pub fn from_f32(value: f32) -> bf16 {\n        bf16(convert::f32_to_bf16(value))\n    }\n\n    /// Constructs a [`bf16`](struct.bf16.html) value from a 64-bit floating point value.\n    ///\n    /// If the 64-bit value is to large to fit, Â±âˆž will result. NaN values are preserved.\n    /// 64-bit subnormal values are too tiny to be represented and result in Â±0. Exponents that\n    /// underflow the minimum exponent will result in subnormals or Â±0. All other values are\n    /// truncated and rounded to the nearest representable value.\n    #[inline]\n    pub fn from_f64(value: f64) -> bf16 {\n        bf16(convert::f64_to_bf16(value))\n    }\n\n    /// Converts a [`bf16`](struct.bf16.html) into the underlying bit representation.\n    #[inline]\n    pub const fn to_bits(self) -> u16 {\n        self.0\n    }\n\n    /// Return the memory representation of the underlying bit representation as a byte array in\n    /// little-endian byte order.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    /// let bytes = bf16::from_f32(12.5).to_le_bytes();\n    /// assert_eq!(bytes, [0x48, 0x41]);\n    /// ```\n    #[inline]\n    pub fn to_le_bytes(self) -> [u8; 2] {\n        self.0.to_le_bytes()\n    }\n\n    /// Return the memory representation of the underlying bit representation as a byte array in\n    /// big-endian (network) byte order.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    /// let bytes = bf16::from_f32(12.5).to_be_bytes();\n    /// assert_eq!(bytes, [0x41, 0x48]);\n    /// ```\n    #[inline]\n    pub fn to_be_bytes(self) -> [u8; 2] {\n        self.0.to_be_bytes()\n    }\n\n    /// Return the memory representation of the underlying bit representation as a byte array in\n    /// native byte order.\n    ///\n    /// As the target platform's native endianness is used, portable code should use `to_be_bytes`\n    /// or `to_le_bytes`, as appropriate, instead.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    /// let bytes = bf16::from_f32(12.5).to_ne_bytes();\n    /// assert_eq!(bytes, if cfg!(target_endian = \"big\") {\n    ///     [0x41, 0x48]\n    /// } else {\n    ///     [0x48, 0x41]\n    /// });\n    /// ```\n    #[inline]\n    pub fn to_ne_bytes(self) -> [u8; 2] {\n        self.0.to_ne_bytes()\n    }\n\n    /// Create a floating point value from its representation as a byte array in little endian.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    /// let value = bf16::from_le_bytes([0x48, 0x41]);\n    /// assert_eq!(value, bf16::from_f32(12.5));\n    /// ```\n    #[inline]\n    pub fn from_le_bytes(bytes: [u8; 2]) -> bf16 {\n        bf16::from_bits(u16::from_le_bytes(bytes))\n    }\n\n    /// Create a floating point value from its representation as a byte array in big endian.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    /// let value = bf16::from_be_bytes([0x41, 0x48]);\n    /// assert_eq!(value, bf16::from_f32(12.5));\n    /// ```\n    #[inline]\n    pub fn from_be_bytes(bytes: [u8; 2]) -> bf16 {\n        bf16::from_bits(u16::from_be_bytes(bytes))\n    }\n\n    /// Create a floating point value from its representation as a byte array in native endian.\n    ///\n    /// As the target platform's native endianness is used, portable code likely wants to use\n    /// `from_be_bytes` or `from_le_bytes`, as appropriate instead.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    /// let value = bf16::from_ne_bytes(if cfg!(target_endian = \"big\") {\n    ///     [0x41, 0x48]\n    /// } else {\n    ///     [0x48, 0x41]\n    /// });\n    /// assert_eq!(value, bf16::from_f32(12.5));\n    /// ```\n    #[inline]\n    pub fn from_ne_bytes(bytes: [u8; 2]) -> bf16 {\n        bf16::from_bits(u16::from_ne_bytes(bytes))\n    }\n\n    /// Converts a [`bf16`](struct.bf16.html) value into an `f32` value.\n    ///\n    /// This conversion is lossless as all values can be represented exactly in `f32`.\n    #[inline]\n    pub fn to_f32(self) -> f32 {\n        convert::bf16_to_f32(self.0)\n    }\n\n    /// Converts a [`bf16`](struct.bf16.html) value into an `f64` value.\n    ///\n    /// This conversion is lossless as all values can be represented exactly in `f64`.\n    #[inline]\n    pub fn to_f64(self) -> f64 {\n        convert::bf16_to_f64(self.0)\n    }\n\n    /// Returns `true` if this value is NaN and `false` otherwise.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    ///\n    /// let nan = bf16::NAN;\n    /// let f = bf16::from_f32(7.0_f32);\n    ///\n    /// assert!(nan.is_nan());\n    /// assert!(!f.is_nan());\n    /// ```\n    #[inline]\n    pub const fn is_nan(self) -> bool {\n        self.0 & 0x7FFFu16 > 0x7F80u16\n    }\n\n    /// Returns `true` if this value is Â±âˆž and `false` otherwise.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    ///\n    /// let f = bf16::from_f32(7.0f32);\n    /// let inf = bf16::INFINITY;\n    /// let neg_inf = bf16::NEG_INFINITY;\n    /// let nan = bf16::NAN;\n    ///\n    /// assert!(!f.is_infinite());\n    /// assert!(!nan.is_infinite());\n    ///\n    /// assert!(inf.is_infinite());\n    /// assert!(neg_inf.is_infinite());\n    /// ```\n    #[inline]\n    pub const fn is_infinite(self) -> bool {\n        self.0 & 0x7FFFu16 == 0x7F80u16\n    }\n\n    /// Returns `true` if this number is neither infinite nor NaN.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    ///\n    /// let f = bf16::from_f32(7.0f32);\n    /// let inf = bf16::INFINITY;\n    /// let neg_inf = bf16::NEG_INFINITY;\n    /// let nan = bf16::NAN;\n    ///\n    /// assert!(f.is_finite());\n    ///\n    /// assert!(!nan.is_finite());\n    /// assert!(!inf.is_finite());\n    /// assert!(!neg_inf.is_finite());\n    /// ```\n    #[inline]\n    pub const fn is_finite(self) -> bool {\n        self.0 & 0x7F80u16 != 0x7F80u16\n    }\n\n    /// Returns `true` if the number is neither zero, infinite, subnormal, or NaN.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    ///\n    /// let min = bf16::MIN_POSITIVE;\n    /// let max = bf16::MAX;\n    /// let lower_than_min = bf16::from_f32(1.0e-39_f32);\n    /// let zero = bf16::from_f32(0.0_f32);\n    ///\n    /// assert!(min.is_normal());\n    /// assert!(max.is_normal());\n    ///\n    /// assert!(!zero.is_normal());\n    /// assert!(!bf16::NAN.is_normal());\n    /// assert!(!bf16::INFINITY.is_normal());\n    /// // Values between 0 and `min` are subnormal.\n    /// assert!(!lower_than_min.is_normal());\n    /// ```\n    #[inline]\n    pub fn is_normal(self) -> bool {\n        let exp = self.0 & 0x7F80u16;\n        exp != 0x7F80u16 && exp != 0\n    }\n\n    /// Returns the floating point category of the number.\n    ///\n    /// If only one property is going to be tested, it is generally faster to use the specific\n    /// predicate instead.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::num::FpCategory;\n    /// # use half::prelude::*;\n    ///\n    /// let num = bf16::from_f32(12.4_f32);\n    /// let inf = bf16::INFINITY;\n    ///\n    /// assert_eq!(num.classify(), FpCategory::Normal);\n    /// assert_eq!(inf.classify(), FpCategory::Infinite);\n    /// ```\n    pub fn classify(self) -> FpCategory {\n        let exp = self.0 & 0x7F80u16;\n        let man = self.0 & 0x007Fu16;\n        match (exp, man) {\n            (0, 0) => FpCategory::Zero,\n            (0, _) => FpCategory::Subnormal,\n            (0x7F80u16, 0) => FpCategory::Infinite,\n            (0x7F80u16, _) => FpCategory::Nan,\n            _ => FpCategory::Normal,\n        }\n    }\n\n    /// Returns a number that represents the sign of `self`.\n    ///\n    /// * 1.0 if the number is positive, +0.0 or `INFINITY`\n    /// * âˆ’1.0 if the number is negative, âˆ’0.0` or `NEG_INFINITY`\n    /// * NaN if the number is NaN\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    ///\n    /// let f = bf16::from_f32(3.5_f32);\n    ///\n    /// assert_eq!(f.signum(), bf16::from_f32(1.0));\n    /// assert_eq!(bf16::NEG_INFINITY.signum(), bf16::from_f32(-1.0));\n    ///\n    /// assert!(bf16::NAN.signum().is_nan());\n    /// ```\n    pub fn signum(self) -> bf16 {\n        if self.is_nan() {\n            self\n        } else if self.0 & 0x8000u16 != 0 {\n            bf16::from_f32(-1.0)\n        } else {\n            bf16::from_f32(1.0)\n        }\n    }\n\n    /// Returns `true` if and only if `self` has a positive sign, including +0.0, NaNs with a\n    /// positive sign bit and +âˆž.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    ///\n    /// let nan = bf16::NAN;\n    /// let f = bf16::from_f32(7.0_f32);\n    /// let g = bf16::from_f32(-7.0_f32);\n    ///\n    /// assert!(f.is_sign_positive());\n    /// assert!(!g.is_sign_positive());\n    /// // NaN can be either positive or negative\n    /// assert!(nan.is_sign_positive() != nan.is_sign_negative());\n    /// ```\n    #[inline]\n    pub const fn is_sign_positive(self) -> bool {\n        self.0 & 0x8000u16 == 0\n    }\n\n    /// Returns `true` if and only if `self` has a negative sign, including âˆ’0.0, NaNs with a\n    /// negative sign bit and âˆ’âˆž.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use half::prelude::*;\n    ///\n    /// let nan = bf16::NAN;\n    /// let f = bf16::from_f32(7.0f32);\n    /// let g = bf16::from_f32(-7.0f32);\n    ///\n    /// assert!(!f.is_sign_negative());\n    /// assert!(g.is_sign_negative());\n    /// // NaN can be either positive or negative\n    /// assert!(nan.is_sign_positive() != nan.is_sign_negative());\n    /// ```\n    #[inline]\n    pub const fn is_sign_negative(self) -> bool {\n        self.0 & 0x8000u16 != 0\n    }\n\n    /// Approximate number of [`bf16`](struct.bf16.html) significant digits in base 10.\n    pub const DIGITS: u32 = 2;\n    /// [`bf16`](struct.bf16.html)\n    /// [machine epsilon](https://en.wikipedia.org/wiki/Machine_epsilon) value.\n    ///\n    /// This is the difference between 1.0 and the next largest representable number.\n    pub const EPSILON: bf16 = bf16(0x3C00u16);\n    /// [`bf16`](struct.bf16.html) positive Infinity (+âˆž).\n    pub const INFINITY: bf16 = bf16(0x7F80u16);\n    /// Number of [`bf16`](struct.bf16.html) significant digits in base 2.\n    pub const MANTISSA_DIGITS: u32 = 8;\n    /// Largest finite [`bf16`](struct.bf16.html) value.\n    pub const MAX: bf16 = bf16(0x7F7F);\n    /// Maximum possible [`bf16`](struct.bf16.html) power of 10 exponent.\n    pub const MAX_10_EXP: i32 = 38;\n    /// Maximum possible [`bf16`](struct.bf16.html) power of 2 exponent.\n    pub const MAX_EXP: i32 = 128;\n    /// Smallest finite [`bf16`](struct.bf16.html) value.\n    pub const MIN: bf16 = bf16(0xFF7F);\n    /// Minimum possible normal [`bf16`](struct.bf16.html) power of 10 exponent.\n    pub const MIN_10_EXP: i32 = -37;\n    /// One greater than the minimum possible normal [`bf16`](struct.bf16.html) power of 2 exponent.\n    pub const MIN_EXP: i32 = -125;\n    /// Smallest positive normal [`bf16`](struct.bf16.html) value.\n    pub const MIN_POSITIVE: bf16 = bf16(0x0080u16);\n    /// [`bf16`](struct.bf16.html) Not a Number (NaN).\n    pub const NAN: bf16 = bf16(0x7FC0u16);\n    /// [`bf16`](struct.bf16.html) negative infinity (-âˆž).\n    pub const NEG_INFINITY: bf16 = bf16(0xFF80u16);\n    /// The radix or base of the internal representation of [`bf16`](struct.bf16.html).\n    pub const RADIX: u32 = 2;\n\n    /// Minimum positive subnormal [`bf16`](struct.bf16.html) value.\n    pub const MIN_POSITIVE_SUBNORMAL: bf16 = bf16(0x0001u16);\n    /// Maximum subnormal [`bf16`](struct.bf16.html) value.\n    pub const MAX_SUBNORMAL: bf16 = bf16(0x007Fu16);\n\n    /// [`bf16`](struct.bf16.html) 1\n    pub const ONE: bf16 = bf16(0x3F80u16);\n    /// [`bf16`](struct.bf16.html) 0\n    pub const ZERO: bf16 = bf16(0x0000u16);\n    /// [`bf16`](struct.bf16.html) -0\n    pub const NEG_ZERO: bf16 = bf16(0x8000u16);\n\n    /// [`bf16`](struct.bf16.html) Euler's number (â„¯).\n    pub const E: bf16 = bf16(0x402Eu16);\n    /// [`bf16`](struct.bf16.html) Archimedes' constant (Ï€).\n    pub const PI: bf16 = bf16(0x4049u16);\n    /// [`bf16`](struct.bf16.html) 1/Ï€\n    pub const FRAC_1_PI: bf16 = bf16(0x3EA3u16);\n    /// [`bf16`](struct.bf16.html) 1/âˆš2\n    pub const FRAC_1_SQRT_2: bf16 = bf16(0x3F35u16);\n    /// [`bf16`](struct.bf16.html) 2/Ï€\n    pub const FRAC_2_PI: bf16 = bf16(0x3F23u16);\n    /// [`bf16`](struct.bf16.html) 2/âˆšÏ€\n    pub const FRAC_2_SQRT_PI: bf16 = bf16(0x3F90u16);\n    /// [`bf16`](struct.bf16.html) Ï€/2\n    pub const FRAC_PI_2: bf16 = bf16(0x3FC9u16);\n    /// [`bf16`](struct.bf16.html) Ï€/3\n    pub const FRAC_PI_3: bf16 = bf16(0x3F86u16);\n    /// [`bf16`](struct.bf16.html) Ï€/4\n    pub const FRAC_PI_4: bf16 = bf16(0x3F49u16);\n    /// [`bf16`](struct.bf16.html) Ï€/6\n    pub const FRAC_PI_6: bf16 = bf16(0x3F06u16);\n    /// [`bf16`](struct.bf16.html) Ï€/8\n    pub const FRAC_PI_8: bf16 = bf16(0x3EC9u16);\n    /// [`bf16`](struct.bf16.html) ð—…ð—‡ 10\n    pub const LN_10: bf16 = bf16(0x4013u16);\n    /// [`bf16`](struct.bf16.html) ð—…ð—‡ 2\n    pub const LN_2: bf16 = bf16(0x3F31u16);\n    /// [`bf16`](struct.bf16.html) ð—…ð—ˆð—€â‚â‚€â„¯\n    pub const LOG10_E: bf16 = bf16(0x3EDEu16);\n    /// [`bf16`](struct.bf16.html) ð—…ð—ˆð—€â‚â‚€2\n    pub const LOG10_2: bf16 = bf16(0x3E9Au16);\n    /// [`bf16`](struct.bf16.html) ð—…ð—ˆð—€â‚‚â„¯\n    pub const LOG2_E: bf16 = bf16(0x3FB9u16);\n    /// [`bf16`](struct.bf16.html) ð—…ð—ˆð—€â‚‚10\n    pub const LOG2_10: bf16 = bf16(0x4055u16);\n    /// [`bf16`](struct.bf16.html) âˆš2\n    pub const SQRT_2: bf16 = bf16(0x3FB5u16);\n}\n\nimpl From<bf16> for f32 {\n    #[inline]\n    fn from(x: bf16) -> f32 {\n        x.to_f32()\n    }\n}\n\nimpl From<bf16> for f64 {\n    #[inline]\n    fn from(x: bf16) -> f64 {\n        x.to_f64()\n    }\n}\n\nimpl From<i8> for bf16 {\n    #[inline]\n    fn from(x: i8) -> bf16 {\n        // Convert to f32, then to bf16\n        bf16::from_f32(f32::from(x))\n    }\n}\n\nimpl From<u8> for bf16 {\n    #[inline]\n    fn from(x: u8) -> bf16 {\n        // Convert to f32, then to f16\n        bf16::from_f32(f32::from(x))\n    }\n}\n\nimpl PartialEq for bf16 {\n    fn eq(&self, other: &bf16) -> bool {\n        if self.is_nan() || other.is_nan() {\n            false\n        } else {\n            (self.0 == other.0) || ((self.0 | other.0) & 0x7FFFu16 == 0)\n        }\n    }\n}\n\nimpl PartialOrd for bf16 {\n    fn partial_cmp(&self, other: &bf16) -> Option<Ordering> {\n        if self.is_nan() || other.is_nan() {\n            None\n        } else {\n            let neg = self.0 & 0x8000u16 != 0;\n            let other_neg = other.0 & 0x8000u16 != 0;\n            match (neg, other_neg) {\n                (false, false) => Some(self.0.cmp(&other.0)),\n                (false, true) => {\n                    if (self.0 | other.0) & 0x7FFFu16 == 0 {\n                        Some(Ordering::Equal)\n                    } else {\n                        Some(Ordering::Greater)\n                    }\n                }\n                (true, false) => {\n                    if (self.0 | other.0) & 0x7FFFu16 == 0 {\n                        Some(Ordering::Equal)\n                    } else {\n                        Some(Ordering::Less)\n                    }\n                }\n                (true, true) => Some(other.0.cmp(&self.0)),\n            }\n        }\n    }\n\n    fn lt(&self, other: &bf16) -> bool {\n        if self.is_nan() || other.is_nan() {\n            false\n        } else {\n            let neg = self.0 & 0x8000u16 != 0;\n            let other_neg = other.0 & 0x8000u16 != 0;\n            match (neg, other_neg) {\n                (false, false) => self.0 < other.0,\n                (false, true) => false,\n                (true, false) => (self.0 | other.0) & 0x7FFFu16 != 0,\n                (true, true) => self.0 > other.0,\n            }\n        }\n    }\n\n    fn le(&self, other: &bf16) -> bool {\n        if self.is_nan() || other.is_nan() {\n            false\n        } else {\n            let neg = self.0 & 0x8000u16 != 0;\n            let other_neg = other.0 & 0x8000u16 != 0;\n            match (neg, other_neg) {\n                (false, false) => self.0 <= other.0,\n                (false, true) => (self.0 | other.0) & 0x7FFFu16 == 0,\n                (true, false) => true,\n                (true, true) => self.0 >= other.0,\n            }\n        }\n    }\n\n    fn gt(&self, other: &bf16) -> bool {\n        if self.is_nan() || other.is_nan() {\n            false\n        } else {\n            let neg = self.0 & 0x8000u16 != 0;\n            let other_neg = other.0 & 0x8000u16 != 0;\n            match (neg, other_neg) {\n                (false, false) => self.0 > other.0,\n                (false, true) => (self.0 | other.0) & 0x7FFFu16 != 0,\n                (true, false) => false,\n                (true, true) => self.0 < other.0,\n            }\n        }\n    }\n\n    fn ge(&self, other: &bf16) -> bool {\n        if self.is_nan() || other.is_nan() {\n            false\n        } else {\n            let neg = self.0 & 0x8000u16 != 0;\n            let other_neg = other.0 & 0x8000u16 != 0;\n            match (neg, other_neg) {\n                (false, false) => self.0 >= other.0,\n                (false, true) => true,\n                (true, false) => (self.0 | other.0) & 0x7FFFu16 == 0,\n                (true, true) => self.0 <= other.0,\n            }\n        }\n    }\n}\n\nimpl FromStr for bf16 {\n    type Err = ParseFloatError;\n    fn from_str(src: &str) -> Result<bf16, ParseFloatError> {\n        f32::from_str(src).map(bf16::from_f32)\n    }\n}\n\nimpl Debug for bf16 {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        write!(f, \"{:?}\", self.to_f32())\n    }\n}\n\nimpl Display for bf16 {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        write!(f, \"{}\", self.to_f32())\n    }\n}\n\nimpl LowerExp for bf16 {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        write!(f, \"{:e}\", self.to_f32())\n    }\n}\n\nimpl UpperExp for bf16 {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        write!(f, \"{:E}\", self.to_f32())\n    }\n}\n\nimpl Binary for bf16 {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        write!(f, \"{:b}\", self.0)\n    }\n}\n\nimpl Octal for bf16 {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        write!(f, \"{:o}\", self.0)\n    }\n}\n\nimpl LowerHex for bf16 {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        write!(f, \"{:x}\", self.0)\n    }\n}\n\nimpl UpperHex for bf16 {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        write!(f, \"{:X}\", self.0)\n    }\n}\n\n#[cfg(feature = \"num-traits\")]\nmod impl_num_traits {\n    use super::bf16;\n    use num_traits::{FromPrimitive, ToPrimitive};\n\n    impl ToPrimitive for bf16 {\n        fn to_i64(&self) -> Option<i64> {\n            Self::to_f32(*self).to_i64()\n        }\n        fn to_u64(&self) -> Option<u64> {\n            Self::to_f32(*self).to_u64()\n        }\n        fn to_i8(&self) -> Option<i8> {\n            Self::to_f32(*self).to_i8()\n        }\n        fn to_u8(&self) -> Option<u8> {\n            Self::to_f32(*self).to_u8()\n        }\n        fn to_i16(&self) -> Option<i16> {\n            Self::to_f32(*self).to_i16()\n        }\n        fn to_u16(&self) -> Option<u16> {\n            Self::to_f32(*self).to_u16()\n        }\n        fn to_i32(&self) -> Option<i32> {\n            Self::to_f32(*self).to_i32()\n        }\n        fn to_u32(&self) -> Option<u32> {\n            Self::to_f32(*self).to_u32()\n        }\n        fn to_f32(&self) -> Option<f32> {\n            Some(Self::to_f32(*self))\n        }\n        fn to_f64(&self) -> Option<f64> {\n            Some(Self::to_f64(*self))\n        }\n    }\n\n    impl FromPrimitive for bf16 {\n        fn from_i64(n: i64) -> Option<Self> {\n            n.to_f32().map(|x| Self::from_f32(x))\n        }\n        fn from_u64(n: u64) -> Option<Self> {\n            n.to_f32().map(|x| Self::from_f32(x))\n        }\n        fn from_i8(n: i8) -> Option<Self> {\n            n.to_f32().map(|x| Self::from_f32(x))\n        }\n        fn from_u8(n: u8) -> Option<Self> {\n            n.to_f32().map(|x| Self::from_f32(x))\n        }\n        fn from_i16(n: i16) -> Option<Self> {\n            n.to_f32().map(|x| Self::from_f32(x))\n        }\n        fn from_u16(n: u16) -> Option<Self> {\n            n.to_f32().map(|x| Self::from_f32(x))\n        }\n        fn from_i32(n: i32) -> Option<Self> {\n            n.to_f32().map(|x| Self::from_f32(x))\n        }\n        fn from_u32(n: u32) -> Option<Self> {\n            n.to_f32().map(|x| Self::from_f32(x))\n        }\n        fn from_f32(n: f32) -> Option<Self> {\n            n.to_f32().map(|x| Self::from_f32(x))\n        }\n        fn from_f64(n: f64) -> Option<Self> {\n            n.to_f64().map(|x| Self::from_f64(x))\n        }\n    }\n}\n\n#[allow(\n    clippy::cognitive_complexity,\n    clippy::float_cmp,\n    clippy::neg_cmp_op_on_partial_ord\n)]\n#[cfg(test)]\nmod test {\n    use super::*;\n    use core;\n    use core::cmp::Ordering;\n    use quickcheck_macros::quickcheck;\n\n    #[test]\n    fn test_bf16_consts_from_f32() {\n        let one = bf16::from_f32(1.0);\n        let zero = bf16::from_f32(0.0);\n        let neg_zero = bf16::from_f32(-0.0);\n        let inf = bf16::from_f32(core::f32::INFINITY);\n        let neg_inf = bf16::from_f32(core::f32::NEG_INFINITY);\n        let nan = bf16::from_f32(core::f32::NAN);\n\n        assert_eq!(bf16::ONE, one);\n        assert_eq!(bf16::ZERO, zero);\n        assert_eq!(bf16::NEG_ZERO, neg_zero);\n        assert_eq!(bf16::INFINITY, inf);\n        assert_eq!(bf16::NEG_INFINITY, neg_inf);\n        assert!(nan.is_nan());\n        assert!(bf16::NAN.is_nan());\n\n        let e = bf16::from_f32(core::f32::consts::E);\n        let pi = bf16::from_f32(core::f32::consts::PI);\n        let frac_1_pi = bf16::from_f32(core::f32::consts::FRAC_1_PI);\n        let frac_1_sqrt_2 = bf16::from_f32(core::f32::consts::FRAC_1_SQRT_2);\n        let frac_2_pi = bf16::from_f32(core::f32::consts::FRAC_2_PI);\n        let frac_2_sqrt_pi = bf16::from_f32(core::f32::consts::FRAC_2_SQRT_PI);\n        let frac_pi_2 = bf16::from_f32(core::f32::consts::FRAC_PI_2);\n        let frac_pi_3 = bf16::from_f32(core::f32::consts::FRAC_PI_3);\n        let frac_pi_4 = bf16::from_f32(core::f32::consts::FRAC_PI_4);\n        let frac_pi_6 = bf16::from_f32(core::f32::consts::FRAC_PI_6);\n        let frac_pi_8 = bf16::from_f32(core::f32::consts::FRAC_PI_8);\n        let ln_10 = bf16::from_f32(core::f32::consts::LN_10);\n        let ln_2 = bf16::from_f32(core::f32::consts::LN_2);\n        let log10_e = bf16::from_f32(core::f32::consts::LOG10_E);\n        // core::f32::consts::LOG10_2 requires rustc 1.43.0\n        let log10_2 = bf16::from_f32(2f32.log10());\n        let log2_e = bf16::from_f32(core::f32::consts::LOG2_E);\n        // core::f32::consts::LOG2_10 requires rustc 1.43.0\n        let log2_10 = bf16::from_f32(10f32.log2());\n        let sqrt_2 = bf16::from_f32(core::f32::consts::SQRT_2);\n\n        assert_eq!(bf16::E, e);\n        assert_eq!(bf16::PI, pi);\n        assert_eq!(bf16::FRAC_1_PI, frac_1_pi);\n        assert_eq!(bf16::FRAC_1_SQRT_2, frac_1_sqrt_2);\n        assert_eq!(bf16::FRAC_2_PI, frac_2_pi);\n        assert_eq!(bf16::FRAC_2_SQRT_PI, frac_2_sqrt_pi);\n        assert_eq!(bf16::FRAC_PI_2, frac_pi_2);\n        assert_eq!(bf16::FRAC_PI_3, frac_pi_3);\n        assert_eq!(bf16::FRAC_PI_4, frac_pi_4);\n        assert_eq!(bf16::FRAC_PI_6, frac_pi_6);\n        assert_eq!(bf16::FRAC_PI_8, frac_pi_8);\n        assert_eq!(bf16::LN_10, ln_10);\n        assert_eq!(bf16::LN_2, ln_2);\n        assert_eq!(bf16::LOG10_E, log10_e);\n        assert_eq!(bf16::LOG10_2, log10_2);\n        assert_eq!(bf16::LOG2_E, log2_e);\n        assert_eq!(bf16::LOG2_10, log2_10);\n        assert_eq!(bf16::SQRT_2, sqrt_2);\n    }\n\n    #[test]\n    fn test_bf16_consts_from_f64() {\n        let one = bf16::from_f64(1.0);\n        let zero = bf16::from_f64(0.0);\n        let neg_zero = bf16::from_f64(-0.0);\n        let inf = bf16::from_f64(core::f64::INFINITY);\n        let neg_inf = bf16::from_f64(core::f64::NEG_INFINITY);\n        let nan = bf16::from_f64(core::f64::NAN);\n\n        assert_eq!(bf16::ONE, one);\n        assert_eq!(bf16::ZERO, zero);\n        assert_eq!(bf16::NEG_ZERO, neg_zero);\n        assert_eq!(bf16::INFINITY, inf);\n        assert_eq!(bf16::NEG_INFINITY, neg_inf);\n        assert!(nan.is_nan());\n        assert!(bf16::NAN.is_nan());\n\n        let e = bf16::from_f64(core::f64::consts::E);\n        let pi = bf16::from_f64(core::f64::consts::PI);\n        let frac_1_pi = bf16::from_f64(core::f64::consts::FRAC_1_PI);\n        let frac_1_sqrt_2 = bf16::from_f64(core::f64::consts::FRAC_1_SQRT_2);\n        let frac_2_pi = bf16::from_f64(core::f64::consts::FRAC_2_PI);\n        let frac_2_sqrt_pi = bf16::from_f64(core::f64::consts::FRAC_2_SQRT_PI);\n        let frac_pi_2 = bf16::from_f64(core::f64::consts::FRAC_PI_2);\n        let frac_pi_3 = bf16::from_f64(core::f64::consts::FRAC_PI_3);\n        let frac_pi_4 = bf16::from_f64(core::f64::consts::FRAC_PI_4);\n        let frac_pi_6 = bf16::from_f64(core::f64::consts::FRAC_PI_6);\n        let frac_pi_8 = bf16::from_f64(core::f64::consts::FRAC_PI_8);\n        let ln_10 = bf16::from_f64(core::f64::consts::LN_10);\n        let ln_2 = bf16::from_f64(core::f64::consts::LN_2);\n        let log10_e = bf16::from_f64(core::f64::consts::LOG10_E);\n        // core::f64::consts::LOG10_2 requires rustc 1.43.0\n        let log10_2 = bf16::from_f64(2f64.log10());\n        let log2_e = bf16::from_f64(core::f64::consts::LOG2_E);\n        // core::f64::consts::LOG2_10 requires rustc 1.43.0\n        let log2_10 = bf16::from_f64(10f64.log2());\n        let sqrt_2 = bf16::from_f64(core::f64::consts::SQRT_2);\n\n        assert_eq!(bf16::E, e);\n        assert_eq!(bf16::PI, pi);\n        assert_eq!(bf16::FRAC_1_PI, frac_1_pi);\n        assert_eq!(bf16::FRAC_1_SQRT_2, frac_1_sqrt_2);\n        assert_eq!(bf16::FRAC_2_PI, frac_2_pi);\n        assert_eq!(bf16::FRAC_2_SQRT_PI, frac_2_sqrt_pi);\n        assert_eq!(bf16::FRAC_PI_2, frac_pi_2);\n        assert_eq!(bf16::FRAC_PI_3, frac_pi_3);\n        assert_eq!(bf16::FRAC_PI_4, frac_pi_4);\n        assert_eq!(bf16::FRAC_PI_6, frac_pi_6);\n        assert_eq!(bf16::FRAC_PI_8, frac_pi_8);\n        assert_eq!(bf16::LN_10, ln_10);\n        assert_eq!(bf16::LN_2, ln_2);\n        assert_eq!(bf16::LOG10_E, log10_e);\n        assert_eq!(bf16::LOG10_2, log10_2);\n        assert_eq!(bf16::LOG2_E, log2_e);\n        assert_eq!(bf16::LOG2_10, log2_10);\n        assert_eq!(bf16::SQRT_2, sqrt_2);\n    }\n\n    #[test]\n    fn test_nan_conversion_to_smaller() {\n        let nan64 = f64::from_bits(0x7FF0_0000_0000_0001u64);\n        let neg_nan64 = f64::from_bits(0xFFF0_0000_0000_0001u64);\n        let nan32 = f32::from_bits(0x7F80_0001u32);\n        let neg_nan32 = f32::from_bits(0xFF80_0001u32);\n        let nan32_from_64 = nan64 as f32;\n        let neg_nan32_from_64 = neg_nan64 as f32;\n        let nan16_from_64 = bf16::from_f64(nan64);\n        let neg_nan16_from_64 = bf16::from_f64(neg_nan64);\n        let nan16_from_32 = bf16::from_f32(nan32);\n        let neg_nan16_from_32 = bf16::from_f32(neg_nan32);\n\n        assert!(nan64.is_nan() && nan64.is_sign_positive());\n        assert!(neg_nan64.is_nan() && neg_nan64.is_sign_negative());\n        assert!(nan32.is_nan() && nan32.is_sign_positive());\n        assert!(neg_nan32.is_nan() && neg_nan32.is_sign_negative());\n        assert!(nan32_from_64.is_nan() && nan32_from_64.is_sign_positive());\n        assert!(neg_nan32_from_64.is_nan() && neg_nan32_from_64.is_sign_negative());\n        assert!(nan16_from_64.is_nan() && nan16_from_64.is_sign_positive());\n        assert!(neg_nan16_from_64.is_nan() && neg_nan16_from_64.is_sign_negative());\n        assert!(nan16_from_32.is_nan() && nan16_from_32.is_sign_positive());\n        assert!(neg_nan16_from_32.is_nan() && neg_nan16_from_32.is_sign_negative());\n    }\n\n    #[test]\n    fn test_nan_conversion_to_larger() {\n        let nan16 = bf16::from_bits(0x7F81u16);\n        let neg_nan16 = bf16::from_bits(0xFF81u16);\n        let nan32 = f32::from_bits(0x7F80_0001u32);\n        let neg_nan32 = f32::from_bits(0xFF80_0001u32);\n        let nan32_from_16 = f32::from(nan16);\n        let neg_nan32_from_16 = f32::from(neg_nan16);\n        let nan64_from_16 = f64::from(nan16);\n        let neg_nan64_from_16 = f64::from(neg_nan16);\n        let nan64_from_32 = f64::from(nan32);\n        let neg_nan64_from_32 = f64::from(neg_nan32);\n\n        assert!(nan16.is_nan() && nan16.is_sign_positive());\n        assert!(neg_nan16.is_nan() && neg_nan16.is_sign_negative());\n        assert!(nan32.is_nan() && nan32.is_sign_positive());\n        assert!(neg_nan32.is_nan() && neg_nan32.is_sign_negative());\n        assert!(nan32_from_16.is_nan() && nan32_from_16.is_sign_positive());\n        assert!(neg_nan32_from_16.is_nan() && neg_nan32_from_16.is_sign_negative());\n        assert!(nan64_from_16.is_nan() && nan64_from_16.is_sign_positive());\n        assert!(neg_nan64_from_16.is_nan() && neg_nan64_from_16.is_sign_negative());\n        assert!(nan64_from_32.is_nan() && nan64_from_32.is_sign_positive());\n        assert!(neg_nan64_from_32.is_nan() && neg_nan64_from_32.is_sign_negative());\n    }\n\n    #[test]\n    fn test_bf16_to_f32() {\n        let f = bf16::from_f32(7.0);\n        assert_eq!(f.to_f32(), 7.0f32);\n\n        // 7.1 is NOT exactly representable in 16-bit, it's rounded\n        let f = bf16::from_f32(7.1);\n        let diff = (f.to_f32() - 7.1f32).abs();\n        // diff must be <= 4 * EPSILON, as 7 has two more significant bits than 1\n        assert!(diff <= 4.0 * bf16::EPSILON.to_f32());\n\n        let tiny32 = f32::from_bits(0x0001_0000u32);\n        assert_eq!(bf16::from_bits(0x0001).to_f32(), tiny32);\n        assert_eq!(bf16::from_bits(0x0005).to_f32(), 5.0 * tiny32);\n\n        assert_eq!(bf16::from_bits(0x0001), bf16::from_f32(tiny32));\n        assert_eq!(bf16::from_bits(0x0005), bf16::from_f32(5.0 * tiny32));\n    }\n\n    #[test]\n    fn test_bf16_to_f64() {\n        let f = bf16::from_f64(7.0);\n        assert_eq!(f.to_f64(), 7.0f64);\n\n        // 7.1 is NOT exactly representable in 16-bit, it's rounded\n        let f = bf16::from_f64(7.1);\n        let diff = (f.to_f64() - 7.1f64).abs();\n        // diff must be <= 4 * EPSILON, as 7 has two more significant bits than 1\n        assert!(diff <= 4.0 * bf16::EPSILON.to_f64());\n\n        let tiny64 = 2.0f64.powi(-133);\n        assert_eq!(bf16::from_bits(0x0001).to_f64(), tiny64);\n        assert_eq!(bf16::from_bits(0x0005).to_f64(), 5.0 * tiny64);\n\n        assert_eq!(bf16::from_bits(0x0001), bf16::from_f64(tiny64));\n        assert_eq!(bf16::from_bits(0x0005), bf16::from_f64(5.0 * tiny64));\n    }\n\n    #[test]\n    fn test_comparisons() {\n        let zero = bf16::from_f64(0.0);\n        let one = bf16::from_f64(1.0);\n        let neg_zero = bf16::from_f64(-0.0);\n        let neg_one = bf16::from_f64(-1.0);\n\n        assert_eq!(zero.partial_cmp(&neg_zero), Some(Ordering::Equal));\n        assert_eq!(neg_zero.partial_cmp(&zero), Some(Ordering::Equal));\n        assert!(zero == neg_zero);\n        assert!(neg_zero == zero);\n        assert!(!(zero != neg_zero));\n        assert!(!(neg_zero != zero));\n        assert!(!(zero < neg_zero));\n        assert!(!(neg_zero < zero));\n        assert!(zero <= neg_zero);\n        assert!(neg_zero <= zero);\n        assert!(!(zero > neg_zero));\n        assert!(!(neg_zero > zero));\n        assert!(zero >= neg_zero);\n        assert!(neg_zero >= zero);\n\n        assert_eq!(one.partial_cmp(&neg_zero), Some(Ordering::Greater));\n        assert_eq!(neg_zero.partial_cmp(&one), Some(Ordering::Less));\n        assert!(!(one == neg_zero));\n        assert!(!(neg_zero == one));\n        assert!(one != neg_zero);\n        assert!(neg_zero != one);\n        assert!(!(one < neg_zero));\n        assert!(neg_zero < one);\n        assert!(!(one <= neg_zero));\n        assert!(neg_zero <= one);\n        assert!(one > neg_zero);\n        assert!(!(neg_zero > one));\n        assert!(one >= neg_zero);\n        assert!(!(neg_zero >= one));\n\n        assert_eq!(one.partial_cmp(&neg_one), Some(Ordering::Greater));\n        assert_eq!(neg_one.partial_cmp(&one), Some(Ordering::Less));\n        assert!(!(one == neg_one));\n        assert!(!(neg_one == one));\n        assert!(one != neg_one);\n        assert!(neg_one != one);\n        assert!(!(one < neg_one));\n        assert!(neg_one < one);\n        assert!(!(one <= neg_one));\n        assert!(neg_one <= one);\n        assert!(one > neg_one);\n        assert!(!(neg_one > one));\n        assert!(one >= neg_one);\n        assert!(!(neg_one >= one));\n    }\n\n    #[test]\n    #[allow(clippy::erasing_op, clippy::identity_op)]\n    fn round_to_even_f32() {\n        // smallest positive subnormal = 0b0.0000_001 * 2^-126 = 2^-133\n        let min_sub = bf16::from_bits(1);\n        let min_sub_f = (-133f32).exp2();\n        assert_eq!(bf16::from_f32(min_sub_f).to_bits(), min_sub.to_bits());\n        assert_eq!(f32::from(min_sub).to_bits(), min_sub_f.to_bits());\n\n        // 0.0000000_011111 rounded to 0.0000000 (< tie, no rounding)\n        // 0.0000000_100000 rounded to 0.0000000 (tie and even, remains at even)\n        // 0.0000000_100001 rounded to 0.0000001 (> tie, rounds up)\n        assert_eq!(\n            bf16::from_f32(min_sub_f * 0.49).to_bits(),\n            min_sub.to_bits() * 0\n        );\n        assert_eq!(\n            bf16::from_f32(min_sub_f * 0.50).to_bits(),\n            min_sub.to_bits() * 0\n        );\n        assert_eq!(\n            bf16::from_f32(min_sub_f * 0.51).to_bits(),\n            min_sub.to_bits() * 1\n        );\n\n        // 0.0000001_011111 rounded to 0.0000001 (< tie, no rounding)\n        // 0.0000001_100000 rounded to 0.0000010 (tie and odd, rounds up to even)\n        // 0.0000001_100001 rounded to 0.0000010 (> tie, rounds up)\n        assert_eq!(\n            bf16::from_f32(min_sub_f * 1.49).to_bits(),\n            min_sub.to_bits() * 1\n        );\n        assert_eq!(\n            bf16::from_f32(min_sub_f * 1.50).to_bits(),\n            min_sub.to_bits() * 2\n        );\n        assert_eq!(\n            bf16::from_f32(min_sub_f * 1.51).to_bits(),\n            min_sub.to_bits() * 2\n        );\n\n        // 0.0000010_011111 rounded to 0.0000010 (< tie, no rounding)\n        // 0.0000010_100000 rounded to 0.0000010 (tie and even, remains at even)\n        // 0.0000010_100001 rounded to 0.0000011 (> tie, rounds up)\n        assert_eq!(\n            bf16::from_f32(min_sub_f * 2.49).to_bits(),\n            min_sub.to_bits() * 2\n        );\n        assert_eq!(\n            bf16::from_f32(min_sub_f * 2.50).to_bits(),\n            min_sub.to_bits() * 2\n        );\n        assert_eq!(\n            bf16::from_f32(min_sub_f * 2.51).to_bits(),\n            min_sub.to_bits() * 3\n        );\n\n        assert_eq!(\n            bf16::from_f32(250.49f32).to_bits(),\n            bf16::from_f32(250.0).to_bits()\n        );\n        assert_eq!(\n            bf16::from_f32(250.50f32).to_bits(),\n            bf16::from_f32(250.0).to_bits()\n        );\n        assert_eq!(\n            bf16::from_f32(250.51f32).to_bits(),\n            bf16::from_f32(251.0).to_bits()\n        );\n        assert_eq!(\n            bf16::from_f32(251.49f32).to_bits(),\n            bf16::from_f32(251.0).to_bits()\n        );\n        assert_eq!(\n            bf16::from_f32(251.50f32).to_bits(),\n            bf16::from_f32(252.0).to_bits()\n        );\n        assert_eq!(\n            bf16::from_f32(251.51f32).to_bits(),\n            bf16::from_f32(252.0).to_bits()\n        );\n        assert_eq!(\n            bf16::from_f32(252.49f32).to_bits(),\n            bf16::from_f32(252.0).to_bits()\n        );\n        assert_eq!(\n            bf16::from_f32(252.50f32).to_bits(),\n            bf16::from_f32(252.0).to_bits()\n        );\n        assert_eq!(\n            bf16::from_f32(252.51f32).to_bits(),\n            bf16::from_f32(253.0).to_bits()\n        );\n    }\n\n    #[test]\n    #[allow(clippy::erasing_op, clippy::identity_op)]\n    fn round_to_even_f64() {\n        // smallest positive subnormal = 0b0.0000_001 * 2^-126 = 2^-133\n        let min_sub = bf16::from_bits(1);\n        let min_sub_f = (-133f64).exp2();\n        assert_eq!(bf16::from_f64(min_sub_f).to_bits(), min_sub.to_bits());\n        assert_eq!(f64::from(min_sub).to_bits(), min_sub_f.to_bits());\n\n        // 0.0000000_011111 rounded to 0.0000000 (< tie, no rounding)\n        // 0.0000000_100000 rounded to 0.0000000 (tie and even, remains at even)\n        // 0.0000000_100001 rounded to 0.0000001 (> tie, rounds up)\n        assert_eq!(\n            bf16::from_f64(min_sub_f * 0.49).to_bits(),\n            min_sub.to_bits() * 0\n        );\n        assert_eq!(\n            bf16::from_f64(min_sub_f * 0.50).to_bits(),\n            min_sub.to_bits() * 0\n        );\n        assert_eq!(\n            bf16::from_f64(min_sub_f * 0.51).to_bits(),\n            min_sub.to_bits() * 1\n        );\n\n        // 0.0000001_011111 rounded to 0.0000001 (< tie, no rounding)\n        // 0.0000001_100000 rounded to 0.0000010 (tie and odd, rounds up to even)\n        // 0.0000001_100001 rounded to 0.0000010 (> tie, rounds up)\n        assert_eq!(\n            bf16::from_f64(min_sub_f * 1.49).to_bits(),\n            min_sub.to_bits() * 1\n        );\n        assert_eq!(\n            bf16::from_f64(min_sub_f * 1.50).to_bits(),\n            min_sub.to_bits() * 2\n        );\n        assert_eq!(\n            bf16::from_f64(min_sub_f * 1.51).to_bits(),\n            min_sub.to_bits() * 2\n        );\n\n        // 0.0000010_011111 rounded to 0.0000010 (< tie, no rounding)\n        // 0.0000010_100000 rounded to 0.0000010 (tie and even, remains at even)\n        // 0.0000010_100001 rounded to 0.0000011 (> tie, rounds up)\n        assert_eq!(\n            bf16::from_f64(min_sub_f * 2.49).to_bits(),\n            min_sub.to_bits() * 2\n        );\n        assert_eq!(\n            bf16::from_f64(min_sub_f * 2.50).to_bits(),\n            min_sub.to_bits() * 2\n        );\n        assert_eq!(\n            bf16::from_f64(min_sub_f * 2.51).to_bits(),\n            min_sub.to_bits() * 3\n        );\n\n        assert_eq!(\n            bf16::from_f64(250.49f64).to_bits(),\n            bf16::from_f64(250.0).to_bits()\n        );\n        assert_eq!(\n            bf16::from_f64(250.50f64).to_bits(),\n            bf16::from_f64(250.0).to_bits()\n        );\n        assert_eq!(\n            bf16::from_f64(250.51f64).to_bits(),\n            bf16::from_f64(251.0).to_bits()\n        );\n        assert_eq!(\n            bf16::from_f64(251.49f64).to_bits(),\n            bf16::from_f64(251.0).to_bits()\n        );\n        assert_eq!(\n            bf16::from_f64(251.50f64).to_bits(),\n            bf16::from_f64(252.0).to_bits()\n        );\n        assert_eq!(\n            bf16::from_f64(251.51f64).to_bits(),\n            bf16::from_f64(252.0).to_bits()\n        );\n        assert_eq!(\n            bf16::from_f64(252.49f64).to_bits(),\n            bf16::from_f64(252.0).to_bits()\n        );\n        assert_eq!(\n            bf16::from_f64(252.50f64).to_bits(),\n            bf16::from_f64(252.0).to_bits()\n        );\n        assert_eq!(\n            bf16::from_f64(252.51f64).to_bits(),\n            bf16::from_f64(253.0).to_bits()\n        );\n    }\n\n    impl quickcheck::Arbitrary for bf16 {\n        fn arbitrary<G: quickcheck::Gen>(g: &mut G) -> Self {\n            use rand::Rng;\n            bf16(g.gen())\n        }\n    }\n\n    #[quickcheck]\n    fn qc_roundtrip_bf16_f32_is_identity(f: bf16) -> bool {\n        let roundtrip = bf16::from_f32(f.to_f32());\n        if f.is_nan() {\n            roundtrip.is_nan() && f.is_sign_negative() == roundtrip.is_sign_negative()\n        } else {\n            f.0 == roundtrip.0\n        }\n    }\n\n    #[quickcheck]\n    fn qc_roundtrip_bf16_f64_is_identity(f: bf16) -> bool {\n        let roundtrip = bf16::from_f64(f.to_f64());\n        if f.is_nan() {\n            roundtrip.is_nan() && f.is_sign_negative() == roundtrip.is_sign_negative()\n        } else {\n            f.0 == roundtrip.0\n        }\n    }\n}\n"],["845","pub(crate) fn f32_to_bf16(value: f32) -> u16 {\n    // Convert to raw bytes\n    let x = value.to_bits();\n\n    // check for NaN\n    if x & 0x7FFF_FFFFu32 > 0x7F80_0000u32 {\n        // Keep high part of current mantissa but also set most significiant mantissa bit\n        return ((x >> 16) | 0x0040u32) as u16;\n    }\n\n    // round and shift\n    let round_bit = 0x0000_8000u32;\n    if (x & round_bit) != 0 && (x & (3 * round_bit - 1)) != 0 {\n        (x >> 16) as u16 + 1\n    } else {\n        (x >> 16) as u16\n    }\n}\n\npub(crate) fn f64_to_bf16(value: f64) -> u16 {\n    // Convert to raw bytes, truncating the last 32-bits of mantissa; that precision will always\n    // be lost on half-precision.\n    let val = value.to_bits();\n    let x = (val >> 32) as u32;\n\n    // Extract IEEE754 components\n    let sign = x & 0x8000_0000u32;\n    let exp = x & 0x7FF0_0000u32;\n    let man = x & 0x000F_FFFFu32;\n\n    // Check for all exponent bits being set, which is Infinity or NaN\n    if exp == 0x7FF0_0000u32 {\n        // Set mantissa MSB for NaN (and also keep shifted mantissa bits).\n        // We also have to check the last 32 bits.\n        let nan_bit = if man == 0 && (val as u32 == 0) {\n            0\n        } else {\n            0x0040u32\n        };\n        return ((sign >> 16) | 0x7F80u32 | nan_bit | (man >> 13)) as u16;\n    }\n\n    // The number is normalized, start assembling half precision version\n    let half_sign = sign >> 16;\n    // Unbias the exponent, then bias for bfloat16 precision\n    let unbiased_exp = ((exp >> 20) as i64) - 1023;\n    let half_exp = unbiased_exp + 127;\n\n    // Check for exponent overflow, return +infinity\n    if half_exp >= 0xFF {\n        return (half_sign | 0x7F80u32) as u16;\n    }\n\n    // Check for underflow\n    if half_exp <= 0 {\n        // Check mantissa for what we can do\n        if 7 - half_exp > 21 {\n            // No rounding possibility, so this is a full underflow, return signed zero\n            return half_sign as u16;\n        }\n        // Don't forget about hidden leading mantissa bit when assembling mantissa\n        let man = man | 0x0010_0000u32;\n        let mut half_man = man >> (14 - half_exp);\n        // Check for rounding\n        let round_bit = 1 << (13 - half_exp);\n        if (man & round_bit) != 0 && (man & (3 * round_bit - 1)) != 0 {\n            half_man += 1;\n        }\n        // No exponent for subnormals\n        return (half_sign | half_man) as u16;\n    }\n\n    // Rebias the exponent\n    let half_exp = (half_exp as u32) << 7;\n    let half_man = man >> 13;\n    // Check for rounding\n    let round_bit = 0x0000_1000u32;\n    if (man & round_bit) != 0 && (man & (3 * round_bit - 1)) != 0 {\n        // Round it\n        ((half_sign | half_exp | half_man) + 1) as u16\n    } else {\n        (half_sign | half_exp | half_man) as u16\n    }\n}\n\npub(crate) fn bf16_to_f32(i: u16) -> f32 {\n    // If NaN, keep current mantissa but also set most significiant mantissa bit\n    if i & 0x7FFFu16 > 0x7F80u16 {\n        f32::from_bits((i as u32 | 0x0040u32) << 16)\n    } else {\n        f32::from_bits((i as u32) << 16)\n    }\n}\n\npub(crate) fn bf16_to_f64(i: u16) -> f64 {\n    // Check for signed zero\n    if i & 0x7FFFu16 == 0 {\n        return f64::from_bits((i as u64) << 48);\n    }\n\n    let half_sign = (i & 0x8000u16) as u64;\n    let half_exp = (i & 0x7F80u16) as u64;\n    let half_man = (i & 0x007Fu16) as u64;\n\n    // Check for an infinity or NaN when all exponent bits set\n    if half_exp == 0x7F80u64 {\n        // Check for signed infinity if mantissa is zero\n        if half_man == 0 {\n            return f64::from_bits((half_sign << 48) | 0x7FF0_0000_0000_0000u64);\n        } else {\n            // NaN, keep current mantissa but also set most significiant mantissa bit\n            return f64::from_bits((half_sign << 48) | 0x7FF8_0000_0000_0000u64 | (half_man << 45));\n        }\n    }\n\n    // Calculate double-precision components with adjusted exponent\n    let sign = half_sign << 48;\n    // Unbias exponent\n    let unbiased_exp = ((half_exp as i64) >> 7) - 127;\n\n    // Check for subnormals, which will be normalized by adjusting exponent\n    if half_exp == 0 {\n        // Calculate how much to adjust the exponent by\n        let e = (half_man as u16).leading_zeros() - 9;\n\n        // Rebias and adjust exponent\n        let exp = ((1023 - 127 - e) as u64) << 52;\n        let man = (half_man << (46 + e)) & 0xF_FFFF_FFFF_FFFFu64;\n        return f64::from_bits(sign | exp | man);\n    }\n    // Rebias exponent for a normalized normal\n    let exp = ((unbiased_exp + 1023) as u64) << 52;\n    let man = (half_man & 0x007Fu64) << 45;\n    f64::from_bits(sign | exp | man)\n}\n"],["846","use crate::{capitalize, transform};\n\n/// This trait defines a camel case conversion.\n///\n/// In CamelCase, word boundaries are indicated by capital letters, including\n/// the first word.\n///\n/// ## Example:\n///\n/// ```rust\n/// use heck::CamelCase;\n///\n/// let sentence = \"We are not in the least afraid of ruins.\";\n/// assert_eq!(sentence.to_camel_case(), \"WeAreNotInTheLeastAfraidOfRuins\");\n/// ```\npub trait CamelCase: ToOwned {\n    /// Convert this type to camel case.\n    fn to_camel_case(&self) -> Self::Owned;\n}\n\nimpl CamelCase for str {\n    fn to_camel_case(&self) -> String {\n        transform(self, capitalize, |_| {})\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::CamelCase;\n\n    macro_rules! t {\n        ($t:ident : $s1:expr => $s2:expr) => {\n            #[test]\n            fn $t() {\n                assert_eq!($s1.to_camel_case(), $s2)\n            }\n        }\n    }\n\n    t!(test1: \"CamelCase\" => \"CamelCase\");\n    t!(test2: \"This is Human case.\" => \"ThisIsHumanCase\");\n    t!(test3: \"MixedUP_CamelCase, with some Spaces\" => \"MixedUpCamelCaseWithSomeSpaces\");\n    t!(test4: \"mixed_up_ snake_case, with some _spaces\" => \"MixedUpSnakeCaseWithSomeSpaces\");\n    t!(test5: \"kebab-case\" => \"KebabCase\");\n    t!(test6: \"SHOUTY_SNAKE_CASE\" => \"ShoutySnakeCase\");\n    t!(test7: \"snake_case\" => \"SnakeCase\");\n    t!(test8: \"this-contains_ ALLKinds OfWord_Boundaries\" => \"ThisContainsAllKindsOfWordBoundaries\");\n    t!(test9: \"XÎ£XÎ£ baï¬„e\" => \"XÏƒxÏ‚Baï¬„e\");\n    t!(test10: \"XMLHttpRequest\" => \"XmlHttpRequest\");\n}\n"],["847","use crate::{lowercase, transform};\n\n/// This trait defines a snake case conversion.\n///\n/// In snake_case, word boundaries are indicated by underscores.\n///\n/// ## Example:\n///\n/// ```rust\n/// use heck::SnakeCase;\n///\n/// let sentence = \"We carry a new world here, in our hearts.\";\n/// assert_eq!(sentence.to_snake_case(), \"we_carry_a_new_world_here_in_our_hearts\");\n/// ```\npub trait SnakeCase: ToOwned {\n    /// Convert this type to snake case.\n    fn to_snake_case(&self) -> Self::Owned;\n}\n\n/// Oh heck, SnekCase is an alias for SnakeCase. See SnakeCase for\n/// more documentation.\npub trait SnekCase: ToOwned {\n    /// Convert this type to snek case.\n    fn to_snek_case(&self) -> Self::Owned;\n}\n\nimpl<T: ?Sized + SnakeCase> SnekCase for T {\n    fn to_snek_case(&self) -> Self::Owned {\n        self.to_snake_case()\n    }\n}\n\nimpl SnakeCase for str {\n    fn to_snake_case(&self) -> String {\n        transform(self, lowercase, |s| s.push('_'))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::SnakeCase;\n\n    macro_rules! t {\n        ($t:ident : $s1:expr => $s2:expr) => {\n            #[test]\n            fn $t() {\n                assert_eq!($s1.to_snake_case(), $s2)\n            }\n        }\n    }\n\n    t!(test1: \"CamelCase\" => \"camel_case\");\n    t!(test2: \"This is Human case.\" => \"this_is_human_case\");\n    t!(test3: \"MixedUP CamelCase, with some Spaces\" => \"mixed_up_camel_case_with_some_spaces\");\n    t!(test4: \"mixed_up_ snake_case with some _spaces\" => \"mixed_up_snake_case_with_some_spaces\");\n    t!(test5: \"kebab-case\" => \"kebab_case\");\n    t!(test6: \"SHOUTY_SNAKE_CASE\" => \"shouty_snake_case\");\n    t!(test7: \"snake_case\" => \"snake_case\");\n    t!(test8: \"this-contains_ ALLKinds OfWord_Boundaries\" => \"this_contains_all_kinds_of_word_boundaries\");\n    t!(test9: \"XÎ£XÎ£ baï¬„e\" => \"xÏƒxÏ‚_baï¬„e\");\n    t!(test10: \"XMLHttpRequest\" => \"xml_http_request\");\n    t!(test11: \"FIELD_NAME11\" => \"field_name11\");\n    t!(test12: \"99BOTTLES\" => \"99bottles\");\n    t!(test13: \"FieldNamE11\" => \"field_nam_e11\");\n\n    t!(test14: \"abc123def456\" => \"abc123def456\");\n    t!(test16: \"abc123DEF456\" => \"abc123_def456\");\n    t!(test17: \"abc123Def456\" => \"abc123_def456\");\n    t!(test18: \"abc123DEf456\" => \"abc123_d_ef456\");\n    t!(test19: \"ABC123def456\" => \"abc123def456\");\n    t!(test20: \"ABC123DEF456\" => \"abc123def456\");\n    t!(test21: \"ABC123Def456\" => \"abc123_def456\");\n    t!(test22: \"ABC123DEf456\" => \"abc123d_ef456\");\n    t!(test23: \"ABC123dEEf456FOO\" => \"abc123d_e_ef456_foo\");\n    t!(test24: \"abcDEF\" => \"abc_def\");\n    t!(test25: \"ABcDE\" => \"a_bc_de\");\n}\n"],["848","use crate::{transform, uppercase};\n\n/// This trait defines a shouty kebab case conversion.\n///\n/// In SHOUTY-KEBAB-CASE, word boundaries are indicated by hyphens and all\n/// words are in uppercase.\n///\n/// ## Example:\n///\n/// ```rust\n/// use heck::ShoutyKebabCase;\n///\n/// let sentence = \"We are going to inherit the earth.\";\n/// assert_eq!(sentence.to_shouty_kebab_case(), \"WE-ARE-GOING-TO-INHERIT-THE-EARTH\");\n/// ```\npub trait ShoutyKebabCase: ToOwned {\n    /// Convert this type to shouty kebab case.\n    fn to_shouty_kebab_case(&self) -> Self::Owned;\n}\n\nimpl ShoutyKebabCase for str {\n    fn to_shouty_kebab_case(&self) -> Self::Owned {\n        transform(self, uppercase, |s| s.push('-'))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::ShoutyKebabCase;\n\n    macro_rules! t {\n        ($t:ident : $s1:expr => $s2:expr) => {\n            #[test]\n            fn $t() {\n                assert_eq!($s1.to_shouty_kebab_case(), $s2)\n            }\n        }\n    }\n\n    t!(test1: \"CamelCase\" => \"CAMEL-CASE\");\n    t!(test2: \"This is Human case.\" => \"THIS-IS-HUMAN-CASE\");\n    t!(test3: \"MixedUP CamelCase, with some Spaces\" => \"MIXED-UP-CAMEL-CASE-WITH-SOME-SPACES\");\n    t!(test4: \"mixed_up_ snake_case with some _spaces\" => \"MIXED-UP-SNAKE-CASE-WITH-SOME-SPACES\");\n    t!(test5: \"kebab-case\" => \"KEBAB-CASE\");\n    t!(test6: \"SHOUTY_SNAKE_CASE\" => \"SHOUTY-SNAKE-CASE\");\n    t!(test7: \"snake_case\" => \"SNAKE-CASE\");\n    t!(test8: \"this-contains_ ALLKinds OfWord_Boundaries\" => \"THIS-CONTAINS-ALL-KINDS-OF-WORD-BOUNDARIES\");\n    t!(test9: \"XÎ£XÎ£ baï¬„e\" => \"XÎ£XÎ£-BAFFLE\");\n    t!(test10: \"XMLHttpRequest\" => \"XML-HTTP-REQUEST\");\n    t!(test11: \"SHOUTY-KEBAB-CASE\" => \"SHOUTY-KEBAB-CASE\");\n}\n"],["849","use crate::{capitalize, transform};\n\n/// This trait defines a title case conversion.\n///\n/// In Title Case, word boundaries are indicated by spaces, and every word is\n/// capitalized.\n///\n/// ## Example:\n///\n/// ```rust\n/// use heck::TitleCase;\n///\n/// let sentence = \"We have always lived in slums and holes in the wall.\";\n/// assert_eq!(sentence.to_title_case(), \"We Have Always Lived In Slums And Holes In The Wall\");\n/// ```\npub trait TitleCase: ToOwned {\n    /// Convert this type to title case.\n    fn to_title_case(&self) -> Self::Owned;\n}\n\nimpl TitleCase for str {\n    fn to_title_case(&self) -> String {\n        transform(self, capitalize, |s| s.push(' '))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::TitleCase;\n\n    macro_rules! t {\n        ($t:ident : $s1:expr => $s2:expr) => {\n            #[test]\n            fn $t() {\n                assert_eq!($s1.to_title_case(), $s2)\n            }\n        }\n    }\n\n    t!(test1: \"CamelCase\" => \"Camel Case\");\n    t!(test2: \"This is Human case.\" => \"This Is Human Case\");\n    t!(test3: \"MixedUP CamelCase, with some Spaces\" => \"Mixed Up Camel Case With Some Spaces\");\n    t!(test4: \"mixed_up_ snake_case, with some _spaces\" => \"Mixed Up Snake Case With Some Spaces\");\n    t!(test5: \"kebab-case\" => \"Kebab Case\");\n    t!(test6: \"SHOUTY_SNAKE_CASE\" => \"Shouty Snake Case\");\n    t!(test7: \"snake_case\" => \"Snake Case\");\n    t!(test8: \"this-contains_ ALLKinds OfWord_Boundaries\" => \"This Contains All Kinds Of Word Boundaries\");\n    t!(test9: \"XÎ£XÎ£ baï¬„e\" => \"XÏƒxÏ‚ Baï¬„e\");\n    t!(test10: \"XMLHttpRequest\" => \"Xml Http Request\");\n}\n"],["850","use crate::{transform, uppercase};\n\n/// This trait defines a shouty snake case conversion.\n///\n/// In SHOUTY_SNAKE_CASE, word boundaries are indicated by underscores and all\n/// words are in uppercase.\n///\n/// ## Example:\n///\n/// ```rust\n/// use heck::ShoutySnakeCase;\n///     \n/// let sentence = \"That world is growing in this minute.\";\n/// assert_eq!(sentence.to_shouty_snake_case(), \"THAT_WORLD_IS_GROWING_IN_THIS_MINUTE\");\n/// ```\npub trait ShoutySnakeCase: ToOwned {\n    /// Convert this type to shouty snake case.\n    fn to_shouty_snake_case(&self) -> Self::Owned;\n}\n\n/// Oh heck, ShoutySnekCase is an alias for ShoutySnakeCase. See ShoutySnakeCase for\n/// more documentation.\npub trait ShoutySnekCase: ToOwned {\n    /// CONVERT THIS TYPE TO SNEK CASE.\n    #[allow(non_snake_case)]\n    fn TO_SHOUTY_SNEK_CASE(&self) -> Self::Owned;\n}\n\nimpl<T: ?Sized + ShoutySnakeCase> ShoutySnekCase for T {\n    fn TO_SHOUTY_SNEK_CASE(&self) -> Self::Owned {\n        self.to_shouty_snake_case()\n    }\n}\n\n\nimpl ShoutySnakeCase for str {\n    fn to_shouty_snake_case(&self) -> Self::Owned {\n        transform(self, uppercase, |s| s.push('_'))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::ShoutySnakeCase;\n\n    macro_rules! t {\n        ($t:ident : $s1:expr => $s2:expr) => {\n            #[test]\n            fn $t() {\n                assert_eq!($s1.to_shouty_snake_case(), $s2)\n            }\n        }\n    }\n\n    t!(test1: \"CamelCase\" => \"CAMEL_CASE\");\n    t!(test2: \"This is Human case.\" => \"THIS_IS_HUMAN_CASE\");\n    t!(test3: \"MixedUP CamelCase, with some Spaces\" => \"MIXED_UP_CAMEL_CASE_WITH_SOME_SPACES\");\n    t!(test4: \"mixed_up_snake_case with some _spaces\" => \"MIXED_UP_SNAKE_CASE_WITH_SOME_SPACES\");\n    t!(test5: \"kebab-case\" => \"KEBAB_CASE\");\n    t!(test6: \"SHOUTY_SNAKE_CASE\" => \"SHOUTY_SNAKE_CASE\");\n    t!(test7: \"snake_case\" => \"SNAKE_CASE\");\n    t!(test8: \"this-contains_ ALLKinds OfWord_Boundaries\" => \"THIS_CONTAINS_ALL_KINDS_OF_WORD_BOUNDARIES\");\n    t!(test9: \"XÎ£XÎ£ baï¬„e\" => \"XÎ£XÎ£_BAFFLE\");\n    t!(test10: \"XMLHttpRequest\" => \"XML_HTTP_REQUEST\");\n}\n"],["851","use crate::{capitalize, lowercase, transform};\n\n/// This trait defines a mixed case conversion.\n///\n/// In mixedCase, word boundaries are indicated by capital letters, excepting\n/// the first word.\n///\n/// ## Example:\n///\n/// ```rust\n/// use heck::MixedCase;\n///\n/// let sentence = \"It is we who built these palaces and cities.\";\n/// assert_eq!(sentence.to_mixed_case(), \"itIsWeWhoBuiltThesePalacesAndCities\");\n/// ```\npub trait MixedCase: ToOwned {\n    /// Convert this type to mixed case.\n    fn to_mixed_case(&self) -> Self::Owned;\n}\n\nimpl MixedCase for str {\n    fn to_mixed_case(&self) -> String {\n        transform(self, |s, out| {\n            if out.is_empty() { lowercase(s, out); }\n            else { capitalize(s, out) }\n        }, |_| {})\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::MixedCase;\n\n    macro_rules! t {\n        ($t:ident : $s1:expr => $s2:expr) => {\n            #[test]\n            fn $t() {\n                assert_eq!($s1.to_mixed_case(), $s2)\n            }\n        }\n    }\n\n    t!(test1: \"CamelCase\" => \"camelCase\");\n    t!(test2: \"This is Human case.\" => \"thisIsHumanCase\");\n    t!(test3: \"MixedUP CamelCase, with some Spaces\" => \"mixedUpCamelCaseWithSomeSpaces\");\n    t!(test4: \"mixed_up_ snake_case, with some _spaces\" => \"mixedUpSnakeCaseWithSomeSpaces\");\n    t!(test5: \"kebab-case\" => \"kebabCase\");\n    t!(test6: \"SHOUTY_SNAKE_CASE\" => \"shoutySnakeCase\");\n    t!(test7: \"snake_case\" => \"snakeCase\");\n    t!(test8: \"this-contains_ ALLKinds OfWord_Boundaries\" => \"thisContainsAllKindsOfWordBoundaries\");\n    t!(test9: \"XÎ£XÎ£ baï¬„e\" => \"xÏƒxÏ‚Baï¬„e\");\n    t!(test10: \"XMLHttpRequest\" => \"xmlHttpRequest\");\n    // TODO unicode tests\n}\n"],["852","use crate::{lowercase, transform};\n\n/// This trait defines a kebab case conversion.\n///\n/// In kebab-case, word boundaries are indicated by hyphens.\n///\n/// ## Example:\n///\n/// ```rust\n/// use heck::KebabCase;\n///\n/// let sentence = \"We are going to inherit the earth.\";\n/// assert_eq!(sentence.to_kebab_case(), \"we-are-going-to-inherit-the-earth\");\n/// ```\npub trait KebabCase: ToOwned {\n    /// Convert this type to kebab case.\n    fn to_kebab_case(&self) -> Self::Owned;\n}\n\nimpl KebabCase for str {\n    fn to_kebab_case(&self) -> Self::Owned {\n        transform(self, lowercase, |s| s.push('-'))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::KebabCase;\n\n    macro_rules! t {\n        ($t:ident : $s1:expr => $s2:expr) => {\n            #[test]\n            fn $t() {\n                assert_eq!($s1.to_kebab_case(), $s2)\n            }\n        }\n    }\n\n    t!(test1: \"CamelCase\" => \"camel-case\");\n    t!(test2: \"This is Human case.\" => \"this-is-human-case\");\n    t!(test3: \"MixedUP CamelCase, with some Spaces\" => \"mixed-up-camel-case-with-some-spaces\");\n    t!(test4: \"mixed_up_ snake_case with some _spaces\" => \"mixed-up-snake-case-with-some-spaces\");\n    t!(test5: \"kebab-case\" => \"kebab-case\");\n    t!(test6: \"SHOUTY_SNAKE_CASE\" => \"shouty-snake-case\");\n    t!(test7: \"snake_case\" => \"snake-case\");\n    t!(test8: \"this-contains_ ALLKinds OfWord_Boundaries\" => \"this-contains-all-kinds-of-word-boundaries\");\n    t!(test9: \"XÎ£XÎ£ baï¬„e\" => \"xÏƒxÏ‚-baï¬„e\");\n    t!(test10: \"XMLHttpRequest\" => \"xml-http-request\");\n}\n"],["853","// Copyright 2020 Parity Technologies\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse alloc::string::String;\nuse alloc::vec::Vec;\nuse core::fmt;\nuse core::result::Result;\nuse serde::{de, Deserializer, Serializer};\n\nstatic CHARS: &[u8] = b\"0123456789abcdef\";\n\n/// Serialize given bytes to a 0x-prefixed hex string.\n///\n/// If `skip_leading_zero` initial 0s will not be printed out,\n/// unless the byte string is empty, in which case `0x0` will be returned.\n/// The results are consistent with `serialize_uint` output if the flag is\n/// on and `serialize_raw` if the flag is off.\npub fn to_hex(bytes: &[u8], skip_leading_zero: bool) -> String {\n\tlet bytes = if skip_leading_zero {\n\t\tlet non_zero = bytes.iter().take_while(|b| **b == 0).count();\n\t\tlet bytes = &bytes[non_zero..];\n\t\tif bytes.is_empty() {\n\t\t\treturn \"0x0\".into();\n\t\t} else {\n\t\t\tbytes\n\t\t}\n\t} else if bytes.is_empty() {\n\t\treturn \"0x\".into();\n\t} else {\n\t\tbytes\n\t};\n\n\tlet mut slice = vec![0u8; (bytes.len() + 1) * 2];\n\tto_hex_raw(&mut slice, bytes, skip_leading_zero).into()\n}\n\nfn to_hex_raw<'a>(v: &'a mut [u8], bytes: &[u8], skip_leading_zero: bool) -> &'a str {\n\tassert!(v.len() > 1 + bytes.len() * 2);\n\n\tv[0] = b'0';\n\tv[1] = b'x';\n\n\tlet mut idx = 2;\n\tlet first_nibble = bytes[0] >> 4;\n\tif first_nibble != 0 || !skip_leading_zero {\n\t\tv[idx] = CHARS[first_nibble as usize];\n\t\tidx += 1;\n\t}\n\tv[idx] = CHARS[(bytes[0] & 0xf) as usize];\n\tidx += 1;\n\n\tfor &byte in bytes.iter().skip(1) {\n\t\tv[idx] = CHARS[(byte >> 4) as usize];\n\t\tv[idx + 1] = CHARS[(byte & 0xf) as usize];\n\t\tidx += 2;\n\t}\n\n\t// SAFETY: all characters come either from CHARS or \"0x\", therefore valid UTF8\n\tunsafe { core::str::from_utf8_unchecked(&v[0..idx]) }\n}\n\n/// Decoding bytes from hex string error.\n#[derive(Debug, PartialEq, Eq)]\npub enum FromHexError {\n\t/// The `0x` prefix is missing.\n\tMissingPrefix,\n\t/// Invalid (non-hex) character encountered.\n\tInvalidHex {\n\t\t/// The unexpected character.\n\t\tcharacter: char,\n\t\t/// Index of that occurrence.\n\t\tindex: usize,\n\t},\n}\n\n#[cfg(feature = \"std\")]\nimpl std::error::Error for FromHexError {}\n\nimpl fmt::Display for FromHexError {\n\tfn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n\t\tmatch *self {\n\t\t\tSelf::MissingPrefix => write!(fmt, \"0x prefix is missing\"),\n\t\t\tSelf::InvalidHex { character, index } => write!(fmt, \"invalid hex character: {}, at {}\", character, index),\n\t\t}\n\t}\n}\n\n/// Decode given hex string into a vector of bytes.\n///\n/// Returns an error if the string is not prefixed with `0x`\n/// or non-hex characters are present.\npub fn from_hex(v: &str) -> Result<Vec<u8>, FromHexError> {\n\tif !v.starts_with(\"0x\") {\n\t\treturn Err(FromHexError::MissingPrefix);\n\t}\n\n\tlet mut bytes = vec![0u8; (v.len() - 1) / 2];\n\tfrom_hex_raw(v, &mut bytes)?;\n\tOk(bytes)\n}\n\n/// Decode given 0x-prefixed hex string into provided slice.\n/// Used internally by `from_hex` and `deserialize_check_len`.\n///\n/// The method will panic if:\n/// 1. `v` is shorter than 2 characters (you need to check 0x prefix outside).\n/// 2. `bytes` have incorrect length (make sure to allocate enough beforehand).\nfn from_hex_raw<'a>(v: &str, bytes: &mut [u8]) -> Result<usize, FromHexError> {\n\tlet bytes_len = v.len() - 2;\n\tlet mut modulus = bytes_len % 2;\n\tlet mut buf = 0;\n\tlet mut pos = 0;\n\tfor (index, byte) in v.bytes().enumerate().skip(2) {\n\t\tbuf <<= 4;\n\n\t\tmatch byte {\n\t\t\tb'A'..=b'F' => buf |= byte - b'A' + 10,\n\t\t\tb'a'..=b'f' => buf |= byte - b'a' + 10,\n\t\t\tb'0'..=b'9' => buf |= byte - b'0',\n\t\t\tb' ' | b'\\r' | b'\\n' | b'\\t' => {\n\t\t\t\tbuf >>= 4;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tb => {\n\t\t\t\tlet character = char::from(b);\n\t\t\t\treturn Err(FromHexError::InvalidHex { character, index });\n\t\t\t}\n\t\t}\n\n\t\tmodulus += 1;\n\t\tif modulus == 2 {\n\t\t\tmodulus = 0;\n\t\t\tbytes[pos] = buf;\n\t\t\tpos += 1;\n\t\t}\n\t}\n\n\tOk(pos)\n}\n\n/// Serializes a slice of bytes.\npub fn serialize_raw<S>(slice: &mut [u8], bytes: &[u8], serializer: S) -> Result<S::Ok, S::Error>\nwhere\n\tS: Serializer,\n{\n\tif bytes.is_empty() {\n\t\tserializer.serialize_str(\"0x\")\n\t} else {\n\t\tserializer.serialize_str(to_hex_raw(slice, bytes, false))\n\t}\n}\n\n/// Serializes a slice of bytes.\npub fn serialize<S>(bytes: &[u8], serializer: S) -> Result<S::Ok, S::Error>\nwhere\n\tS: Serializer,\n{\n\tlet mut slice = vec![0u8; (bytes.len() + 1) * 2];\n\tserialize_raw(&mut slice, bytes, serializer)\n}\n\n/// Serialize a slice of bytes as uint.\n///\n/// The representation will have all leading zeros trimmed.\npub fn serialize_uint<S>(slice: &mut [u8], bytes: &[u8], serializer: S) -> Result<S::Ok, S::Error>\nwhere\n\tS: Serializer,\n{\n\tlet non_zero = bytes.iter().take_while(|b| **b == 0).count();\n\tlet bytes = &bytes[non_zero..];\n\tif bytes.is_empty() {\n\t\tserializer.serialize_str(\"0x0\")\n\t} else {\n\t\tserializer.serialize_str(to_hex_raw(slice, bytes, true))\n\t}\n}\n\n/// Expected length of bytes vector.\n#[derive(Debug, PartialEq, Eq)]\npub enum ExpectedLen<'a> {\n\t/// Exact length in bytes.\n\tExact(&'a mut [u8]),\n\t/// A bytes length between (min; slice.len()].\n\tBetween(usize, &'a mut [u8]),\n}\n\nimpl<'a> fmt::Display for ExpectedLen<'a> {\n\tfn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n\t\tmatch *self {\n\t\t\tExpectedLen::Exact(ref v) => write!(fmt, \"length of {}\", v.len() * 2),\n\t\t\tExpectedLen::Between(min, ref v) => write!(fmt, \"length between ({}; {}]\", min * 2, v.len() * 2),\n\t\t}\n\t}\n}\n\n/// Deserialize into vector of bytes.  This will allocate an O(n) intermediate\n/// string.\npub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<u8>, D::Error>\nwhere\n\tD: Deserializer<'de>,\n{\n\tstruct Visitor;\n\n\timpl<'b> de::Visitor<'b> for Visitor {\n\t\ttype Value = Vec<u8>;\n\n\t\tfn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n\t\t\twrite!(formatter, \"a 0x-prefixed hex string\")\n\t\t}\n\n\t\tfn visit_str<E: de::Error>(self, v: &str) -> Result<Self::Value, E> {\n\t\t\tfrom_hex(v).map_err(E::custom)\n\t\t}\n\n\t\tfn visit_string<E: de::Error>(self, v: String) -> Result<Self::Value, E> {\n\t\t\tself.visit_str(&v)\n\t\t}\n\t}\n\n\tdeserializer.deserialize_str(Visitor)\n}\n\n/// Deserialize into vector of bytes with additional size check.\n/// Returns number of bytes written.\npub fn deserialize_check_len<'a, 'de, D>(deserializer: D, len: ExpectedLen<'a>) -> Result<usize, D::Error>\nwhere\n\tD: Deserializer<'de>,\n{\n\tstruct Visitor<'a> {\n\t\tlen: ExpectedLen<'a>,\n\t}\n\n\timpl<'a, 'b> de::Visitor<'b> for Visitor<'a> {\n\t\ttype Value = usize;\n\n\t\tfn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n\t\t\twrite!(formatter, \"a 0x-prefixed hex string with {}\", self.len)\n\t\t}\n\n\t\tfn visit_str<E: de::Error>(self, v: &str) -> Result<Self::Value, E> {\n\t\t\tif !v.starts_with(\"0x\") {\n\t\t\t\treturn Err(E::custom(FromHexError::MissingPrefix));\n\t\t\t}\n\n\t\t\tlet len = v.len();\n\t\t\tlet is_len_valid = match self.len {\n\t\t\t\tExpectedLen::Exact(ref slice) => len == 2 * slice.len() + 2,\n\t\t\t\tExpectedLen::Between(min, ref slice) => len <= 2 * slice.len() + 2 && len > 2 * min + 2,\n\t\t\t};\n\n\t\t\tif !is_len_valid {\n\t\t\t\treturn Err(E::invalid_length(v.len() - 2, &self));\n\t\t\t}\n\n\t\t\tlet bytes = match self.len {\n\t\t\t\tExpectedLen::Exact(slice) => slice,\n\t\t\t\tExpectedLen::Between(_, slice) => slice,\n\t\t\t};\n\n\t\t\tfrom_hex_raw(v, bytes).map_err(E::custom)\n\t\t}\n\n\t\tfn visit_string<E: de::Error>(self, v: String) -> Result<Self::Value, E> {\n\t\t\tself.visit_str(&v)\n\t\t}\n\t}\n\n\tdeserializer.deserialize_str(Visitor { len })\n}\n\n#[cfg(test)]\nmod tests {\n\tuse super::*;\n\tuse serde_derive::{Deserialize, Serialize};\n\n\t#[derive(Serialize, Deserialize)]\n\tstruct Bytes(#[serde(with = \"super\")] Vec<u8>);\n\n\t#[test]\n\tfn should_not_fail_on_short_string() {\n\t\tlet a: Bytes = serde_json::from_str(\"\\\"0x\\\"\").unwrap();\n\t\tlet b: Bytes = serde_json::from_str(\"\\\"0x1\\\"\").unwrap();\n\t\tlet c: Bytes = serde_json::from_str(\"\\\"0x12\\\"\").unwrap();\n\t\tlet d: Bytes = serde_json::from_str(\"\\\"0x123\\\"\").unwrap();\n\t\tlet e: Bytes = serde_json::from_str(\"\\\"0x1234\\\"\").unwrap();\n\t\tlet f: Bytes = serde_json::from_str(\"\\\"0x12345\\\"\").unwrap();\n\n\t\tassert!(a.0.is_empty());\n\t\tassert_eq!(b.0, vec![1]);\n\t\tassert_eq!(c.0, vec![0x12]);\n\t\tassert_eq!(d.0, vec![0x1, 0x23]);\n\t\tassert_eq!(e.0, vec![0x12, 0x34]);\n\t\tassert_eq!(f.0, vec![0x1, 0x23, 0x45]);\n\t}\n\n\t#[test]\n\tfn should_not_fail_on_other_strings() {\n\t\tlet a: Bytes =\n\t\t\tserde_json::from_str(\"\\\"0x7f864e18e3dd8b58386310d2fe0919eef27c6e558564b7f67f22d99d20f587\\\"\").unwrap();\n\t\tlet b: Bytes =\n\t\t\tserde_json::from_str(\"\\\"0x7f864e18e3dd8b58386310d2fe0919eef27c6e558564b7f67f22d99d20f587b\\\"\").unwrap();\n\t\tlet c: Bytes =\n\t\t\tserde_json::from_str(\"\\\"0x7f864e18e3dd8b58386310d2fe0919eef27c6e558564b7f67f22d99d20f587b4\\\"\").unwrap();\n\n\t\tassert_eq!(a.0.len(), 31);\n\t\tassert_eq!(b.0.len(), 32);\n\t\tassert_eq!(c.0.len(), 32);\n\t}\n\n\t#[test]\n\tfn should_serialize_and_deserialize_empty_bytes() {\n\t\tlet bytes = Bytes(Vec::new());\n\n\t\tlet data = serde_json::to_string(&bytes).unwrap();\n\n\t\tassert_eq!(\"\\\"0x\\\"\", &data);\n\n\t\tlet deserialized: Bytes = serde_json::from_str(&data).unwrap();\n\t\tassert!(deserialized.0.is_empty())\n\t}\n\n\t#[test]\n\tfn should_encode_to_and_from_hex() {\n\t\tassert_eq!(to_hex(&[0, 1, 2], true), \"0x102\");\n\t\tassert_eq!(to_hex(&[0, 1, 2], false), \"0x000102\");\n\t\tassert_eq!(to_hex(&[0], true), \"0x0\");\n\t\tassert_eq!(to_hex(&[], true), \"0x0\");\n\t\tassert_eq!(to_hex(&[], false), \"0x\");\n\t\tassert_eq!(to_hex(&[0], false), \"0x00\");\n\t\tassert_eq!(from_hex(\"0x0102\"), Ok(vec![1, 2]));\n\t\tassert_eq!(from_hex(\"0x102\"), Ok(vec![1, 2]));\n\t\tassert_eq!(from_hex(\"0xf\"), Ok(vec![0xf]));\n\t}\n}\n"],["854","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#[alloc_error_handler]\nfn oom(_: core::alloc::Layout) -> ! {\n    core::intrinsics::abort()\n}\n"],["855","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Types for the default environment.\n//!\n//! These are simple mirrored types from the default substrate FRAME configuration.\n//! Their interfaces and functionality might not be complete.\n//!\n//! Users are required to provide their own type definitions and `Environment`\n//! implementations in order to write ink! contracts for other chain configurations.\n//!\n//! # Note\n//!\n//! When authoring a contract, the concrete `Environment` are available via aliases\n//! generated by the `lang` macro. Therefore all functionality of the concrete\n//! types is accessible in the contract, not constrained by the required trait\n//! bounds.\n//!\n//! Outside of the contract and its tests (e.g. in the offchain environment), where\n//! there is no knowledge of the concrete types, the functionality is restricted to\n//! the trait bounds on the `Environment` trait types.\n\nuse super::arithmetic::AtLeast32BitUnsigned;\nuse core::{\n    array::TryFromSliceError,\n    convert::TryFrom,\n};\nuse derive_more::From;\nuse scale::{\n    Decode,\n    Encode,\n};\n#[cfg(feature = \"std\")]\nuse scale_info::TypeInfo;\n\n/// The environmental types usable by contracts defined with ink!.\npub trait Environment {\n    /// The maximum number of supported event topics provided by the runtime.\n    ///\n    /// The value must match the maximum number of supported event topics of the used runtime.\n    const MAX_EVENT_TOPICS: usize;\n\n    /// The type of an address.\n    type AccountId: 'static + scale::Codec + Clone + PartialEq + Eq + Ord;\n\n    /// The type of balances.\n    type Balance: 'static\n        + scale::Codec\n        + Copy\n        + Clone\n        + PartialEq\n        + Eq\n        + AtLeast32BitUnsigned;\n\n    /// The type of hash.\n    type Hash: 'static\n        + scale::Codec\n        + Copy\n        + Clone\n        + Clear\n        + PartialEq\n        + Eq\n        + Ord\n        + AsRef<[u8]>\n        + AsMut<[u8]>;\n\n    /// The type of timestamps.\n    type Timestamp: 'static\n        + scale::Codec\n        + Copy\n        + Clone\n        + PartialEq\n        + Eq\n        + AtLeast32BitUnsigned;\n\n    /// The type of block number.\n    type BlockNumber: 'static\n        + scale::Codec\n        + Copy\n        + Clone\n        + PartialEq\n        + Eq\n        + AtLeast32BitUnsigned;\n\n    /// The chain extension for the environment.\n    ///\n    /// This is a type that is defined through the `#[ink::chain_extension]` proc. macro.\n    /// For more information about usage and definition click [this][chain_extension] link.\n    ///\n    /// [chain_extension]: https://paritytech.github.io/ink/ink_lang/attr.chain_extension.html\n    type ChainExtension;\n}\n\n/// Placeholder for chains that have no defined chain extension.\npub enum NoChainExtension {}\n\n/// The fundamental types of the default configuration.\n#[derive(Debug, Clone, PartialEq, Eq)]\n#[cfg_attr(feature = \"std\", derive(TypeInfo))]\npub enum DefaultEnvironment {}\n\nimpl Environment for DefaultEnvironment {\n    const MAX_EVENT_TOPICS: usize = 4;\n\n    type AccountId = AccountId;\n    type Balance = Balance;\n    type Hash = Hash;\n    type Timestamp = Timestamp;\n    type BlockNumber = BlockNumber;\n    type ChainExtension = NoChainExtension;\n}\n\n/// The default balance type.\npub type Balance = u128;\n\n/// The default timestamp type.\npub type Timestamp = u64;\n\n/// The default block number type.\npub type BlockNumber = u32;\n\n/// The default environment `AccountId` type.\n///\n/// # Note\n///\n/// This is a mirror of the `AccountId` type used in the default configuration\n/// of PALLET contracts.\n#[derive(\n    Debug,\n    Copy,\n    Clone,\n    PartialEq,\n    Eq,\n    Ord,\n    PartialOrd,\n    Hash,\n    Encode,\n    Decode,\n    From,\n    Default,\n)]\n#[cfg_attr(feature = \"std\", derive(TypeInfo))]\npub struct AccountId([u8; 32]);\n\nimpl<'a> TryFrom<&'a [u8]> for AccountId {\n    type Error = TryFromSliceError;\n\n    fn try_from(bytes: &'a [u8]) -> Result<Self, TryFromSliceError> {\n        let address = <[u8; 32]>::try_from(bytes)?;\n        Ok(Self(address))\n    }\n}\n\n/// The default environment `Hash` type.\n///\n/// # Note\n///\n/// This is a mirror of the `Hash` type used in the default configuration\n/// of PALLET contracts.\n#[derive(\n    Debug,\n    Copy,\n    Clone,\n    PartialEq,\n    Eq,\n    Ord,\n    PartialOrd,\n    Hash,\n    Encode,\n    Decode,\n    From,\n    Default,\n)]\n#[cfg_attr(feature = \"std\", derive(TypeInfo))]\npub struct Hash([u8; 32]);\n\nimpl<'a> TryFrom<&'a [u8]> for Hash {\n    type Error = TryFromSliceError;\n\n    fn try_from(bytes: &'a [u8]) -> Result<Self, TryFromSliceError> {\n        let address = <[u8; 32]>::try_from(bytes)?;\n        Ok(Self(address))\n    }\n}\n\nimpl AsRef<[u8]> for Hash {\n    fn as_ref(&self) -> &[u8] {\n        &self.0[..]\n    }\n}\n\nimpl AsMut<[u8]> for Hash {\n    fn as_mut(&mut self) -> &mut [u8] {\n        &mut self.0[..]\n    }\n}\n\n/// The equivalent of `Zero` for hashes.\n///\n/// A hash that consists only of 0 bits is clear.\npub trait Clear {\n    /// Returns `true` if the hash is clear.\n    fn is_clear(&self) -> bool;\n\n    /// Returns a clear hash.\n    fn clear() -> Self;\n}\n\nimpl Clear for [u8; 32] {\n    fn is_clear(&self) -> bool {\n        self.as_ref().iter().all(|&byte| byte == 0x00)\n    }\n\n    fn clear() -> Self {\n        [0x00; 32]\n    }\n}\n\nimpl Clear for Hash {\n    fn is_clear(&self) -> bool {\n        <[u8; 32] as Clear>::is_clear(&self.0)\n    }\n\n    fn clear() -> Self {\n        Self(<[u8; 32] as Clear>::clear())\n    }\n}\n"],["856","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::{\n    ext,\n    EnvInstance,\n    Error as ExtError,\n    ScopedBuffer,\n};\nuse crate::{\n    call::{\n        utils::ReturnType,\n        CallParams,\n        CreateParams,\n    },\n    hash::{\n        Blake2x128,\n        Blake2x256,\n        CryptoHash,\n        HashOutput,\n        Keccak256,\n        Sha2x256,\n    },\n    topics::{\n        Topics,\n        TopicsBuilderBackend,\n    },\n    Clear,\n    EnvBackend,\n    Environment,\n    Error,\n    Result,\n    ReturnFlags,\n    TypedEnvBackend,\n};\nuse ink_primitives::Key;\n\nimpl CryptoHash for Blake2x128 {\n    fn hash(input: &[u8], output: &mut <Self as HashOutput>::Type) {\n        type OutputType = [u8; 16];\n        static_assertions::assert_type_eq_all!(\n            <Blake2x128 as HashOutput>::Type,\n            OutputType\n        );\n        let output: &mut OutputType = arrayref::array_mut_ref!(output, 0, 16);\n        ext::hash_blake2_128(input, output);\n    }\n}\n\nimpl CryptoHash for Blake2x256 {\n    fn hash(input: &[u8], output: &mut <Self as HashOutput>::Type) {\n        type OutputType = [u8; 32];\n        static_assertions::assert_type_eq_all!(\n            <Blake2x256 as HashOutput>::Type,\n            OutputType\n        );\n        let output: &mut OutputType = arrayref::array_mut_ref!(output, 0, 32);\n        ext::hash_blake2_256(input, output);\n    }\n}\n\nimpl CryptoHash for Sha2x256 {\n    fn hash(input: &[u8], output: &mut <Self as HashOutput>::Type) {\n        type OutputType = [u8; 32];\n        static_assertions::assert_type_eq_all!(\n            <Sha2x256 as HashOutput>::Type,\n            OutputType\n        );\n        let output: &mut OutputType = arrayref::array_mut_ref!(output, 0, 32);\n        ext::hash_sha2_256(input, output);\n    }\n}\n\nimpl CryptoHash for Keccak256 {\n    fn hash(input: &[u8], output: &mut <Self as HashOutput>::Type) {\n        type OutputType = [u8; 32];\n        static_assertions::assert_type_eq_all!(\n            <Keccak256 as HashOutput>::Type,\n            OutputType\n        );\n        let output: &mut OutputType = arrayref::array_mut_ref!(output, 0, 32);\n        ext::hash_keccak_256(input, output);\n    }\n}\n\nimpl From<ext::Error> for Error {\n    fn from(ext_error: ext::Error) -> Self {\n        match ext_error {\n            ext::Error::UnknownError => Self::UnknownError,\n            ext::Error::CalleeTrapped => Self::CalleeTrapped,\n            ext::Error::CalleeReverted => Self::CalleeReverted,\n            ext::Error::KeyNotFound => Self::KeyNotFound,\n            ext::Error::BelowSubsistenceThreshold => Self::BelowSubsistenceThreshold,\n            ext::Error::TransferFailed => Self::TransferFailed,\n            ext::Error::NewContractNotFunded => Self::NewContractNotFunded,\n            ext::Error::CodeNotFound => Self::CodeNotFound,\n            ext::Error::NotCallable => Self::NotCallable,\n        }\n    }\n}\n\npub struct TopicsBuilder<'a, E> {\n    scoped_buffer: ScopedBuffer<'a>,\n    marker: core::marker::PhantomData<fn() -> E>,\n}\n\nimpl<'a, E> From<ScopedBuffer<'a>> for TopicsBuilder<'a, E>\nwhere\n    E: Environment,\n{\n    fn from(scoped_buffer: ScopedBuffer<'a>) -> Self {\n        Self {\n            scoped_buffer,\n            marker: Default::default(),\n        }\n    }\n}\n\nimpl<'a, E> TopicsBuilderBackend<E> for TopicsBuilder<'a, E>\nwhere\n    E: Environment,\n{\n    type Output = (ScopedBuffer<'a>, &'a mut [u8]);\n\n    fn expect(&mut self, expected_topics: usize) {\n        self.scoped_buffer\n            .append_encoded(&scale::Compact(expected_topics as u32));\n    }\n\n    fn push_topic<T>(&mut self, topic_value: &T)\n    where\n        T: scale::Encode,\n    {\n        let mut split = self.scoped_buffer.split();\n        let encoded = split.take_encoded(topic_value);\n        let len_encoded = encoded.len();\n        let mut result = <E as Environment>::Hash::clear();\n        let len_result = result.as_ref().len();\n        if len_encoded <= len_result {\n            result.as_mut()[..len_encoded].copy_from_slice(encoded);\n        } else {\n            let mut hash_output = <Blake2x256 as HashOutput>::Type::default();\n            <Blake2x256 as CryptoHash>::hash(encoded, &mut hash_output);\n            let copy_len = core::cmp::min(hash_output.len(), len_result);\n            result.as_mut()[0..copy_len].copy_from_slice(&hash_output[0..copy_len]);\n        }\n        self.scoped_buffer.append_encoded(&result);\n    }\n\n    fn output(mut self) -> Self::Output {\n        let encoded_topics = self.scoped_buffer.take_appended();\n        (self.scoped_buffer, encoded_topics)\n    }\n}\n\nimpl EnvInstance {\n    /// Returns a new scoped buffer for the entire scope of the static 16kB buffer.\n    fn scoped_buffer(&mut self) -> ScopedBuffer {\n        ScopedBuffer::from(&mut self.buffer[..])\n    }\n\n    /// Returns the contract property value.\n    fn get_property<T>(&mut self, ext_fn: fn(output: &mut &mut [u8])) -> Result<T>\n    where\n        T: scale::Decode,\n    {\n        let full_scope = &mut self.scoped_buffer().take_rest();\n        ext_fn(full_scope);\n        scale::Decode::decode(&mut &full_scope[..]).map_err(Into::into)\n    }\n\n    /// Reusable implementation for invoking another contract message.\n    fn invoke_contract_impl<T, Args, RetType, R>(\n        &mut self,\n        params: &CallParams<T, Args, RetType>,\n    ) -> Result<R>\n    where\n        T: Environment,\n        Args: scale::Encode,\n        R: scale::Decode,\n    {\n        let mut scope = self.scoped_buffer();\n        let gas_limit = params.gas_limit();\n        let enc_callee = scope.take_encoded(params.callee());\n        let enc_transferred_value = scope.take_encoded(params.transferred_value());\n        let enc_input = scope.take_encoded(params.exec_input());\n        let output = &mut scope.take_rest();\n        ext::call(\n            enc_callee,\n            gas_limit,\n            enc_transferred_value,\n            enc_input,\n            output,\n        )?;\n        let decoded = scale::Decode::decode(&mut &output[..])?;\n        Ok(decoded)\n    }\n}\n\nimpl EnvBackend for EnvInstance {\n    fn set_contract_storage<V>(&mut self, key: &Key, value: &V)\n    where\n        V: scale::Encode,\n    {\n        let buffer = self.scoped_buffer().take_encoded(value);\n        ext::set_storage(key.as_bytes(), &buffer[..]);\n    }\n\n    fn get_contract_storage<R>(&mut self, key: &Key) -> Result<Option<R>>\n    where\n        R: scale::Decode,\n    {\n        let output = &mut self.scoped_buffer().take_rest();\n        match ext::get_storage(key.as_bytes(), output) {\n            Ok(_) => (),\n            Err(ExtError::KeyNotFound) => return Ok(None),\n            Err(_) => panic!(\"encountered unexpected error\"),\n        }\n        let decoded = scale::Decode::decode(&mut &output[..])?;\n        Ok(Some(decoded))\n    }\n\n    fn clear_contract_storage(&mut self, key: &Key) {\n        ext::clear_storage(key.as_bytes())\n    }\n\n    fn decode_input<T>(&mut self) -> Result<T>\n    where\n        T: scale::Decode,\n    {\n        self.get_property::<T>(ext::input)\n    }\n\n    fn return_value<R>(&mut self, flags: ReturnFlags, return_value: &R) -> !\n    where\n        R: scale::Encode,\n    {\n        let mut scope = self.scoped_buffer();\n        let enc_return_value = scope.take_encoded(return_value);\n        ext::return_value(flags, enc_return_value);\n    }\n\n    fn println(&mut self, content: &str) {\n        ext::println(content)\n    }\n\n    fn hash_bytes<H>(&mut self, input: &[u8], output: &mut <H as HashOutput>::Type)\n    where\n        H: CryptoHash,\n    {\n        <H as CryptoHash>::hash(input, output)\n    }\n\n    fn hash_encoded<H, T>(&mut self, input: &T, output: &mut <H as HashOutput>::Type)\n    where\n        H: CryptoHash,\n        T: scale::Encode,\n    {\n        let mut scope = self.scoped_buffer();\n        let enc_input = scope.take_encoded(input);\n        <H as CryptoHash>::hash(enc_input, output)\n    }\n\n    fn call_chain_extension<I, T, E, ErrorCode, F, D>(\n        &mut self,\n        func_id: u32,\n        input: &I,\n        status_to_result: F,\n        decode_to_result: D,\n    ) -> ::core::result::Result<T, E>\n    where\n        I: scale::Encode,\n        T: scale::Decode,\n        E: From<ErrorCode>,\n        F: FnOnce(u32) -> ::core::result::Result<(), ErrorCode>,\n        D: FnOnce(&[u8]) -> ::core::result::Result<T, E>,\n    {\n        let mut scope = self.scoped_buffer();\n        let enc_input = scope.take_encoded(input);\n        let output = &mut scope.take_rest();\n        status_to_result(ext::call_chain_extension(func_id, enc_input, output))?;\n        let decoded = decode_to_result(&mut &output[..])?;\n        Ok(decoded)\n    }\n}\n\nimpl TypedEnvBackend for EnvInstance {\n    fn caller<T: Environment>(&mut self) -> Result<T::AccountId> {\n        self.get_property::<T::AccountId>(ext::caller)\n    }\n\n    fn transferred_balance<T: Environment>(&mut self) -> Result<T::Balance> {\n        self.get_property::<T::Balance>(ext::value_transferred)\n    }\n\n    fn gas_left<T: Environment>(&mut self) -> Result<T::Balance> {\n        self.get_property::<T::Balance>(ext::gas_left)\n    }\n\n    fn block_timestamp<T: Environment>(&mut self) -> Result<T::Timestamp> {\n        self.get_property::<T::Timestamp>(ext::now)\n    }\n\n    fn account_id<T: Environment>(&mut self) -> Result<T::AccountId> {\n        self.get_property::<T::AccountId>(ext::address)\n    }\n\n    fn balance<T: Environment>(&mut self) -> Result<T::Balance> {\n        self.get_property::<T::Balance>(ext::balance)\n    }\n\n    fn rent_allowance<T: Environment>(&mut self) -> Result<T::Balance> {\n        self.get_property::<T::Balance>(ext::rent_allowance)\n    }\n\n    fn block_number<T: Environment>(&mut self) -> Result<T::BlockNumber> {\n        self.get_property::<T::BlockNumber>(ext::block_number)\n    }\n\n    fn minimum_balance<T: Environment>(&mut self) -> Result<T::Balance> {\n        self.get_property::<T::Balance>(ext::minimum_balance)\n    }\n\n    fn tombstone_deposit<T: Environment>(&mut self) -> Result<T::Balance> {\n        self.get_property::<T::Balance>(ext::tombstone_deposit)\n    }\n\n    fn emit_event<T, Event>(&mut self, event: Event)\n    where\n        T: Environment,\n        Event: Topics + scale::Encode,\n    {\n        let (mut scope, enc_topics) =\n            event.topics::<T, _>(TopicsBuilder::from(self.scoped_buffer()).into());\n        let enc_data = scope.take_encoded(&event);\n        ext::deposit_event(enc_topics, enc_data);\n    }\n\n    fn set_rent_allowance<T>(&mut self, new_value: T::Balance)\n    where\n        T: Environment,\n    {\n        let buffer = self.scoped_buffer().take_encoded(&new_value);\n        ext::set_rent_allowance(&buffer[..])\n    }\n\n    fn invoke_contract<T, Args>(\n        &mut self,\n        call_params: &CallParams<T, Args, ()>,\n    ) -> Result<()>\n    where\n        T: Environment,\n        Args: scale::Encode,\n    {\n        self.invoke_contract_impl(call_params)\n    }\n\n    fn eval_contract<T, Args, R>(\n        &mut self,\n        call_params: &CallParams<T, Args, ReturnType<R>>,\n    ) -> Result<R>\n    where\n        T: Environment,\n        Args: scale::Encode,\n        R: scale::Decode,\n    {\n        self.invoke_contract_impl(call_params)\n    }\n\n    fn instantiate_contract<T, Args, Salt, C>(\n        &mut self,\n        params: &CreateParams<T, Args, Salt, C>,\n    ) -> Result<T::AccountId>\n    where\n        T: Environment,\n        Args: scale::Encode,\n        Salt: AsRef<[u8]>,\n    {\n        let mut scoped = self.scoped_buffer();\n        let gas_limit = params.gas_limit();\n        let enc_code_hash = scoped.take_encoded(params.code_hash());\n        let enc_endowment = scoped.take_encoded(params.endowment());\n        let enc_input = scoped.take_encoded(params.exec_input());\n        // We support `AccountId` types with an encoding that requires up to\n        // 1024 bytes. Beyond that limit ink! contracts will trap for now.\n        // In the default configuration encoded `AccountId` require 32 bytes.\n        let out_address = &mut scoped.take(1024);\n        let salt = params.salt_bytes().as_ref();\n        let out_return_value = &mut scoped.take_rest();\n        // We currently do nothing with the `out_return_value` buffer.\n        // This should change in the future but for that we need to add support\n        // for constructors that may return values.\n        // This is useful to support fallible constructors for example.\n        ext::instantiate(\n            enc_code_hash,\n            gas_limit,\n            enc_endowment,\n            enc_input,\n            out_address,\n            out_return_value,\n            salt,\n        )?;\n        let account_id = scale::Decode::decode(&mut &out_address[..])?;\n        Ok(account_id)\n    }\n\n    fn restore_contract<T>(\n        &mut self,\n        account_id: T::AccountId,\n        code_hash: T::Hash,\n        rent_allowance: T::Balance,\n        filtered_keys: &[Key],\n    ) where\n        T: Environment,\n    {\n        let mut scope = self.scoped_buffer();\n        let enc_account_id = scope.take_encoded(&account_id);\n        let enc_code_hash = scope.take_encoded(&code_hash);\n        let enc_rent_allowance = scope.take_encoded(&rent_allowance);\n        ext::restore_to(\n            enc_account_id,\n            enc_code_hash,\n            enc_rent_allowance,\n            filtered_keys,\n        );\n    }\n\n    fn terminate_contract<T>(&mut self, beneficiary: T::AccountId) -> !\n    where\n        T: Environment,\n    {\n        let buffer = self.scoped_buffer().take_encoded(&beneficiary);\n        ext::terminate(&buffer[..]);\n    }\n\n    fn transfer<T>(&mut self, destination: T::AccountId, value: T::Balance) -> Result<()>\n    where\n        T: Environment,\n    {\n        let mut scope = self.scoped_buffer();\n        let enc_destination = scope.take_encoded(&destination);\n        let enc_value = scope.take_encoded(&value);\n        ext::transfer(enc_destination, enc_value).map_err(Into::into)\n    }\n\n    fn weight_to_fee<T: Environment>(&mut self, gas: u64) -> Result<T::Balance> {\n        let output = &mut self.scoped_buffer().take_rest();\n        ext::weight_to_fee(gas, output);\n        scale::Decode::decode(&mut &output[..]).map_err(Into::into)\n    }\n\n    fn random<T>(&mut self, subject: &[u8]) -> Result<T::Hash>\n    where\n        T: Environment,\n    {\n        let mut scope = self.scoped_buffer();\n        let enc_subject = scope.take_bytes(subject);\n        let output = &mut scope.take_rest();\n        ext::random(enc_subject, output);\n        scale::Decode::decode(&mut &output[..]).map_err(Into::into)\n    }\n}\n"],["857","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/// A static buffer with 16kB of capacity.\npub struct StaticBuffer {\n    /// The static buffer with a total capacity of 16kB.\n    buffer: [u8; Self::CAPACITY],\n}\n\nimpl StaticBuffer {\n    /// The capacity of the static buffer.\n    const CAPACITY: usize = 1 << 14; // 16kB\n\n    /// Creates a new static buffer.\n    pub const fn new() -> Self {\n        Self {\n            buffer: [0; Self::CAPACITY],\n        }\n    }\n}\n\nimpl core::ops::Index<core::ops::RangeFull> for StaticBuffer {\n    type Output = [u8];\n\n    fn index(&self, index: core::ops::RangeFull) -> &Self::Output {\n        core::ops::Index::index(&self.buffer[..], index)\n    }\n}\n\nimpl core::ops::IndexMut<core::ops::RangeFull> for StaticBuffer {\n    fn index_mut(&mut self, index: core::ops::RangeFull) -> &mut Self::Output {\n        core::ops::IndexMut::index_mut(&mut self.buffer[..], index)\n    }\n}\n\n/// Utility to allow for non-heap allocating encoding into a static buffer.\n///\n/// Required by `ScopedBuffer` internals.\nstruct EncodeScope<'a> {\n    buffer: &'a mut [u8],\n    len: usize,\n}\n\nimpl<'a> From<&'a mut [u8]> for EncodeScope<'a> {\n    fn from(buffer: &'a mut [u8]) -> Self {\n        Self { buffer, len: 0 }\n    }\n}\n\nimpl<'a> EncodeScope<'a> {\n    /// Returns the capacity of the encoded scope.\n    pub fn capacity(&self) -> usize {\n        self.buffer.len()\n    }\n\n    /// Returns the length of the encoded scope.\n    pub fn len(&self) -> usize {\n        self.len\n    }\n\n    /// Returns the internal mutable byte slice.\n    pub fn into_buffer(self) -> &'a mut [u8] {\n        self.buffer\n    }\n}\n\nimpl<'a> scale::Output for EncodeScope<'a> {\n    fn write(&mut self, bytes: &[u8]) {\n        debug_assert!(\n            self.len() + bytes.len() <= self.capacity(),\n            \"encode scope buffer overflowed. capacity is {} but last write index is {}\",\n            self.capacity(),\n            self.len() + bytes.len(),\n        );\n        let start = self.len;\n        let len_bytes = bytes.len();\n        self.buffer[start..(start + len_bytes)].copy_from_slice(bytes);\n        self.len += len_bytes;\n    }\n\n    fn push_byte(&mut self, byte: u8) {\n        debug_assert_ne!(\n            self.len(),\n            self.capacity(),\n            \"encode scope buffer overflowed. capacity is {} and buffer is already full\",\n            self.capacity(),\n        );\n        self.buffer[self.len] = byte;\n        self.len += 1;\n    }\n}\n\n/// Scoped access to an underlying bytes buffer.\n///\n/// # Note\n///\n/// This is used to efficiently chunk up ink!'s internal static 16kB buffer\n/// into smaller sub buffers for processing different parts of computations.\n#[derive(Debug)]\npub struct ScopedBuffer<'a> {\n    offset: usize,\n    buffer: &'a mut [u8],\n}\n\nimpl<'a> From<&'a mut [u8]> for ScopedBuffer<'a> {\n    fn from(buffer: &'a mut [u8]) -> Self {\n        Self { offset: 0, buffer }\n    }\n}\n\nimpl<'a> ScopedBuffer<'a> {\n    /// Splits the scoped buffer into yet another piece to operate on it temporarily.\n    ///\n    /// The splitted buffer will have an offset of 0 but be offset by `self`'s offset.\n    pub fn split(&mut self) -> ScopedBuffer {\n        ScopedBuffer {\n            offset: 0,\n            buffer: &mut self.buffer[self.offset..],\n        }\n    }\n\n    /// Returns the first `len` bytes of the buffer as mutable slice.\n    pub fn take(&mut self, len: usize) -> &'a mut [u8] {\n        debug_assert_eq!(self.offset, 0);\n        debug_assert!(len <= self.buffer.len());\n        let len_before = self.buffer.len();\n        let buffer = core::mem::take(&mut self.buffer);\n        let (lhs, rhs) = buffer.split_at_mut(len);\n        self.buffer = rhs;\n        debug_assert_eq!(lhs.len(), len);\n        let len_after = self.buffer.len();\n        debug_assert_eq!(len_before - len_after, len);\n        lhs\n    }\n\n    /// Returns a buffer scope filled with `bytes` with the proper length.\n    pub fn take_bytes(&mut self, bytes: &[u8]) -> &'a mut [u8] {\n        debug_assert_eq!(self.offset, 0);\n        let buffer = self.take(bytes.len());\n        buffer.copy_from_slice(bytes);\n        buffer\n    }\n\n    /// Encode the given value into the scoped buffer and return the sub slice\n    /// containing all the encoded bytes.\n    pub fn take_encoded<T>(&mut self, value: &T) -> &'a mut [u8]\n    where\n        T: scale::Encode,\n    {\n        debug_assert_eq!(self.offset, 0);\n        let buffer = core::mem::take(&mut self.buffer);\n        let mut encode_scope = EncodeScope::from(buffer);\n        scale::Encode::encode_to(&value, &mut encode_scope);\n        let encode_len = encode_scope.len();\n        let _ = core::mem::replace(&mut self.buffer, encode_scope.into_buffer());\n        self.take(encode_len)\n    }\n\n    /// Appends the encoding of `value` to the scoped buffer.\n    ///\n    /// Does not return the buffer immediately so that other values can be appended\n    /// afterwards. The [`take_appended`] method shall be used to return the buffer\n    /// that includes all appended encodings as a single buffer.\n    pub fn append_encoded<T>(&mut self, value: &T)\n    where\n        T: scale::Encode,\n    {\n        let offset = self.offset;\n        let buffer = core::mem::take(&mut self.buffer);\n        let mut encode_scope = EncodeScope::from(&mut buffer[offset..]);\n        scale::Encode::encode_to(&value, &mut encode_scope);\n        let encode_len = encode_scope.len();\n        self.offset += encode_len;\n        let _ = core::mem::replace(&mut self.buffer, buffer);\n    }\n\n    /// Returns the buffer containing all encodings appended via [`append_encoded`]\n    /// in a single byte buffer.\n    pub fn take_appended(&mut self) -> &'a mut [u8] {\n        debug_assert_ne!(self.offset, 0);\n        let offset = self.offset;\n        self.offset = 0;\n        self.take(offset)\n    }\n\n    /// Returns all of the remaining bytes of the buffer as mutable slice.\n    pub fn take_rest(self) -> &'a mut [u8] {\n        debug_assert_eq!(self.offset, 0);\n        debug_assert!(!self.buffer.is_empty());\n        self.buffer\n    }\n}\n"],["858","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nmod buffer;\nmod ext;\nmod impls;\n\nuse self::{\n    buffer::{\n        ScopedBuffer,\n        StaticBuffer,\n    },\n    ext::Error,\n};\nuse super::OnInstance;\n\n/// The on-chain environment.\npub struct EnvInstance {\n    /// Encode & decode buffer with static size of 16kB.\n    ///\n    /// If operations require more than that they will fail.\n    /// This limit was chosen after benchmarking Substrate storage\n    /// storage and load performance and was found to be a sweet spot.\n    ///\n    /// Please note that this is still an implementation detail and\n    /// might change. Users should generally avoid storing too big values\n    /// into single storage entries.\n    buffer: StaticBuffer,\n}\n\nimpl OnInstance for EnvInstance {\n    fn on_instance<F, R>(f: F) -> R\n    where\n        F: FnOnce(&mut Self) -> R,\n    {\n        static mut INSTANCE: EnvInstance = EnvInstance {\n            buffer: StaticBuffer::new(),\n        };\n        f(unsafe { &mut INSTANCE })\n    }\n}\n"],["859","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! External C API to communicate with substrate contracts runtime module.\n//!\n//! Refer to substrate SRML contract module for more documentation.\n\nuse crate::ReturnFlags;\nuse core::marker::PhantomData;\nuse ink_primitives::Key;\n\nmacro_rules! define_error_codes {\n    (\n        $(\n            $( #[$attr:meta] )*\n            $name:ident = $discr:literal,\n        )*\n    ) => {\n        /// Every error that can be returned to a contract when it calls any of the host functions.\n        #[repr(u32)]\n        pub enum Error {\n            $(\n                $( #[$attr] )*\n                $name = $discr,\n            )*\n            /// Returns if an unknown error was received from the host module.\n            UnknownError,\n        }\n\n        impl From<ReturnCode> for Result {\n            #[inline]\n            fn from(return_code: ReturnCode) -> Self {\n                match return_code.0 {\n                    0 => Ok(()),\n                    $(\n                        $discr => Err(Error::$name),\n                    )*\n                    _ => Err(Error::UnknownError),\n                }\n            }\n        }\n    };\n}\ndefine_error_codes! {\n    /// The called function trapped and has its state changes reverted.\n    /// In this case no output buffer is returned.\n    /// Can only be returned from `seal_call` and `seal_instantiate`.\n    CalleeTrapped = 1,\n    /// The called function ran to completion but decided to revert its state.\n    /// An output buffer is returned when one was supplied.\n    /// Can only be returned from `seal_call` and `seal_instantiate`.\n    CalleeReverted = 2,\n    /// The passed key does not exist in storage.\n    KeyNotFound = 3,\n    /// Transfer failed because it would have brought the sender's total balance\n    /// below the subsistence threshold.\n    BelowSubsistenceThreshold = 4,\n    /// Transfer failed for other not further specified reason. Most probably\n    /// reserved or locked balance of the sender that was preventing the transfer.\n    TransferFailed = 5,\n    /// The newly created contract is below the subsistence threshold after executing\n    /// its constructor so no usable contract instance will be created.\n    NewContractNotFunded = 6,\n    /// No code could be found at the supplied code hash.\n    CodeNotFound = 7,\n    /// The account that was called is either no contract (e.g. user account) or is a tombstone.\n    NotCallable = 8,\n}\n\n/// Thin-wrapper around a `u32` representing a pointer for Wasm32.\n///\n/// Only for shared references.\n///\n/// # Note\n///\n/// Can only be constructed from shared reference types and encapsulates the\n/// conversion from reference to raw `u32`.\n/// Does not allow accessing the internal `u32` value.\n#[derive(Debug)]\n#[repr(transparent)]\npub struct Ptr32<'a, T>\nwhere\n    T: ?Sized,\n{\n    /// The internal Wasm32 raw pointer value.\n    ///\n    /// Must not be readable or directly usable by any safe Rust code.\n    value: u32,\n    /// We handle types like these as if the associated lifetime was exclusive.\n    marker: PhantomData<fn() -> &'a T>,\n}\n\nimpl<'a, T> Ptr32<'a, T>\nwhere\n    T: ?Sized,\n{\n    /// Creates a new Wasm32 pointer for the given raw pointer value.\n    fn new(value: u32) -> Self {\n        Self {\n            value,\n            marker: Default::default(),\n        }\n    }\n}\n\nimpl<'a, T> Ptr32<'a, [T]> {\n    /// Creates a new Wasm32 pointer from the given shared slice.\n    pub fn from_slice(slice: &'a [T]) -> Self {\n        Self::new(slice.as_ptr() as u32)\n    }\n}\n\n/// Thin-wrapper around a `u32` representing a pointer for Wasm32.\n///\n/// Only for exclusive references.\n///\n/// # Note\n///\n/// Can only be constructed from exclusive reference types and encapsulates the\n/// conversion from reference to raw `u32`.\n/// Does not allow accessing the internal `u32` value.\n#[derive(Debug)]\n#[repr(transparent)]\npub struct Ptr32Mut<'a, T>\nwhere\n    T: ?Sized,\n{\n    /// The internal Wasm32 raw pointer value.\n    ///\n    /// Must not be readable or directly usable by any safe Rust code.\n    value: u32,\n    /// We handle types like these as if the associated lifetime was exclusive.\n    marker: PhantomData<fn() -> &'a mut T>,\n}\n\nimpl<'a, T> Ptr32Mut<'a, T>\nwhere\n    T: ?Sized,\n{\n    /// Creates a new Wasm32 pointer for the given raw pointer value.\n    fn new(value: u32) -> Self {\n        Self {\n            value,\n            marker: Default::default(),\n        }\n    }\n}\n\nimpl<'a, T> Ptr32Mut<'a, [T]> {\n    /// Creates a new Wasm32 pointer from the given exclusive slice.\n    pub fn from_slice(slice: &'a mut [T]) -> Self {\n        Self::new(slice.as_ptr() as u32)\n    }\n}\n\nimpl<'a, T> Ptr32Mut<'a, T>\nwhere\n    T: Sized,\n{\n    /// Creates a new Wasm32 pointer from the given exclusive reference.\n    pub fn from_ref(a_ref: &'a mut T) -> Self {\n        let a_ptr: *mut T = a_ref;\n        Self::new(a_ptr as u32)\n    }\n}\n\n/// The raw return code returned by the host side.\n#[repr(transparent)]\npub struct ReturnCode(u32);\n\nimpl ReturnCode {\n    /// Returns the raw underlying `u32` representation.\n    pub fn into_u32(self) -> u32 {\n        self.0\n    }\n}\n\ntype Result = core::result::Result<(), Error>;\n\nmod sys {\n    use super::{\n        Key,\n        Ptr32,\n        Ptr32Mut,\n        ReturnCode,\n    };\n\n    #[link(wasm_import_module = \"seal0\")]\n    extern \"C\" {\n        pub fn seal_instantiate(\n            init_code_ptr: Ptr32<[u8]>,\n            init_code_len: u32,\n            gas: u64,\n            endowment_ptr: Ptr32<[u8]>,\n            endowment_len: u32,\n            input_ptr: Ptr32<[u8]>,\n            input_len: u32,\n            address_ptr: Ptr32Mut<[u8]>,\n            address_len_ptr: Ptr32Mut<u32>,\n            output_ptr: Ptr32Mut<[u8]>,\n            output_len_ptr: Ptr32Mut<u32>,\n            salt_ptr: Ptr32<[u8]>,\n            salt_len: u32,\n        ) -> ReturnCode;\n\n        pub fn seal_call(\n            callee_ptr: Ptr32<[u8]>,\n            callee_len: u32,\n            gas: u64,\n            transferred_value_ptr: Ptr32<[u8]>,\n            transferred_value_len: u32,\n            input_ptr: Ptr32<[u8]>,\n            input_len: u32,\n            output_ptr: Ptr32Mut<[u8]>,\n            output_len_ptr: Ptr32Mut<u32>,\n        ) -> ReturnCode;\n\n        pub fn seal_transfer(\n            account_id_ptr: Ptr32<[u8]>,\n            account_id_len: u32,\n            transferred_value_ptr: Ptr32<[u8]>,\n            transferred_value_len: u32,\n        ) -> ReturnCode;\n\n        pub fn seal_deposit_event(\n            topics_ptr: Ptr32<[u8]>,\n            topics_len: u32,\n            data_ptr: Ptr32<[u8]>,\n            data_len: u32,\n        );\n\n        pub fn seal_set_storage(\n            key_ptr: Ptr32<[u8]>,\n            value_ptr: Ptr32<[u8]>,\n            value_len: u32,\n        );\n        pub fn seal_get_storage(\n            key_ptr: Ptr32<[u8]>,\n            output_ptr: Ptr32Mut<[u8]>,\n            output_len_ptr: Ptr32Mut<u32>,\n        ) -> ReturnCode;\n        pub fn seal_clear_storage(key_ptr: Ptr32<[u8]>);\n\n        pub fn seal_restore_to(\n            dest_ptr: Ptr32<[u8]>,\n            dest_len: u32,\n            code_hash_ptr: Ptr32<[u8]>,\n            code_hash_len: u32,\n            rent_allowance_ptr: Ptr32<[u8]>,\n            rent_allowance_len: u32,\n            delta_ptr: Ptr32<[Key]>,\n            delta_count: u32,\n        );\n        pub fn seal_terminate(beneficiary_ptr: Ptr32<[u8]>, beneficiary_len: u32) -> !;\n\n        pub fn seal_call_chain_extension(\n            func_id: u32,\n            input_ptr: Ptr32<[u8]>,\n            input_len: u32,\n            output_ptr: Ptr32Mut<[u8]>,\n            output_len_ptr: Ptr32Mut<u32>,\n        ) -> ReturnCode;\n\n        pub fn seal_input(buf_ptr: Ptr32Mut<[u8]>, buf_len_ptr: Ptr32Mut<u32>);\n        pub fn seal_return(flags: u32, data_ptr: Ptr32<[u8]>, data_len: u32) -> !;\n\n        pub fn seal_caller(output_ptr: Ptr32Mut<[u8]>, output_len_ptr: Ptr32Mut<u32>);\n        pub fn seal_block_number(\n            output_ptr: Ptr32Mut<[u8]>,\n            output_len_ptr: Ptr32Mut<u32>,\n        );\n        pub fn seal_address(output_ptr: Ptr32Mut<[u8]>, output_len_ptr: Ptr32Mut<u32>);\n        pub fn seal_balance(output_ptr: Ptr32Mut<[u8]>, output_len_ptr: Ptr32Mut<u32>);\n        pub fn seal_weight_to_fee(\n            gas: u64,\n            output_ptr: Ptr32Mut<[u8]>,\n            output_len_ptr: Ptr32Mut<u32>,\n        );\n        pub fn seal_gas_left(output_ptr: Ptr32Mut<[u8]>, output_len_ptr: Ptr32Mut<u32>);\n        pub fn seal_value_transferred(\n            output_ptr: Ptr32Mut<[u8]>,\n            output_len_ptr: Ptr32Mut<u32>,\n        );\n        pub fn seal_now(output_ptr: Ptr32Mut<[u8]>, output_len_ptr: Ptr32Mut<u32>);\n        pub fn seal_rent_allowance(\n            output_ptr: Ptr32Mut<[u8]>,\n            output_len_ptr: Ptr32Mut<u32>,\n        );\n        pub fn seal_minimum_balance(\n            output_ptr: Ptr32Mut<[u8]>,\n            output_len_ptr: Ptr32Mut<u32>,\n        );\n        pub fn seal_tombstone_deposit(\n            output_ptr: Ptr32Mut<[u8]>,\n            output_len_ptr: Ptr32Mut<u32>,\n        );\n\n        pub fn seal_set_rent_allowance(value_ptr: Ptr32<[u8]>, value_len: u32);\n\n        pub fn seal_random(\n            subject_ptr: Ptr32<[u8]>,\n            subject_len: u32,\n            output_ptr: Ptr32Mut<[u8]>,\n            output_len_ptr: Ptr32Mut<u32>,\n        );\n        pub fn seal_println(str_ptr: Ptr32<[u8]>, str_len: u32);\n\n        pub fn seal_hash_keccak_256(\n            input_ptr: Ptr32<[u8]>,\n            input_len: u32,\n            output_ptr: Ptr32Mut<[u8]>,\n        );\n        pub fn seal_hash_blake2_256(\n            input_ptr: Ptr32<[u8]>,\n            input_len: u32,\n            output_ptr: Ptr32Mut<[u8]>,\n        );\n        pub fn seal_hash_blake2_128(\n            input_ptr: Ptr32<[u8]>,\n            input_len: u32,\n            output_ptr: Ptr32Mut<[u8]>,\n        );\n        pub fn seal_hash_sha2_256(\n            input_ptr: Ptr32<[u8]>,\n            input_len: u32,\n            output_ptr: Ptr32Mut<[u8]>,\n        );\n    }\n}\n\nfn extract_from_slice(output: &mut &mut [u8], new_len: usize) {\n    debug_assert!(new_len <= output.len());\n    let tmp = core::mem::take(output);\n    *output = &mut tmp[..new_len];\n}\n\npub fn instantiate(\n    code_hash: &[u8],\n    gas_limit: u64,\n    endowment: &[u8],\n    input: &[u8],\n    out_address: &mut &mut [u8],\n    out_return_value: &mut &mut [u8],\n    salt: &[u8],\n) -> Result {\n    let mut address_len = out_address.len() as u32;\n    let mut return_value_len = out_return_value.len() as u32;\n    let ret_code = {\n        unsafe {\n            sys::seal_instantiate(\n                Ptr32::from_slice(code_hash),\n                code_hash.len() as u32,\n                gas_limit,\n                Ptr32::from_slice(endowment),\n                endowment.len() as u32,\n                Ptr32::from_slice(input),\n                input.len() as u32,\n                Ptr32Mut::from_slice(out_address),\n                Ptr32Mut::from_ref(&mut address_len),\n                Ptr32Mut::from_slice(out_return_value),\n                Ptr32Mut::from_ref(&mut return_value_len),\n                Ptr32::from_slice(salt),\n                salt.len() as u32,\n            )\n        }\n    };\n    extract_from_slice(out_address, address_len as usize);\n    extract_from_slice(out_return_value, return_value_len as usize);\n    ret_code.into()\n}\n\npub fn call(\n    callee: &[u8],\n    gas_limit: u64,\n    value: &[u8],\n    input: &[u8],\n    output: &mut &mut [u8],\n) -> Result {\n    let mut output_len = output.len() as u32;\n    let ret_code = {\n        unsafe {\n            sys::seal_call(\n                Ptr32::from_slice(callee),\n                callee.len() as u32,\n                gas_limit,\n                Ptr32::from_slice(value),\n                value.len() as u32,\n                Ptr32::from_slice(input),\n                input.len() as u32,\n                Ptr32Mut::from_slice(output),\n                Ptr32Mut::from_ref(&mut output_len),\n            )\n        }\n    };\n    extract_from_slice(output, output_len as usize);\n    ret_code.into()\n}\n\npub fn transfer(account_id: &[u8], value: &[u8]) -> Result {\n    let ret_code = unsafe {\n        sys::seal_transfer(\n            Ptr32::from_slice(account_id),\n            account_id.len() as u32,\n            Ptr32::from_slice(value),\n            value.len() as u32,\n        )\n    };\n    ret_code.into()\n}\n\npub fn deposit_event(topics: &[u8], data: &[u8]) {\n    unsafe {\n        sys::seal_deposit_event(\n            Ptr32::from_slice(topics),\n            topics.len() as u32,\n            Ptr32::from_slice(data),\n            data.len() as u32,\n        )\n    }\n}\n\npub fn set_storage(key: &[u8], encoded_value: &[u8]) {\n    unsafe {\n        sys::seal_set_storage(\n            Ptr32::from_slice(key),\n            Ptr32::from_slice(encoded_value),\n            encoded_value.len() as u32,\n        )\n    }\n}\n\npub fn clear_storage(key: &[u8]) {\n    unsafe { sys::seal_clear_storage(Ptr32::from_slice(key)) }\n}\n\npub fn get_storage(key: &[u8], output: &mut &mut [u8]) -> Result {\n    let mut output_len = output.len() as u32;\n    let ret_code = {\n        unsafe {\n            sys::seal_get_storage(\n                Ptr32::from_slice(key),\n                Ptr32Mut::from_slice(output),\n                Ptr32Mut::from_ref(&mut output_len),\n            )\n        }\n    };\n    extract_from_slice(output, output_len as usize);\n    ret_code.into()\n}\n\n/// Restores a tombstone to the original smart contract.\n///\n/// # Params\n///\n/// - `account_id`: Encoded bytes of the `AccountId` of the to-be-restored contract.\n/// - `code_hash`: Encoded code hash of the to-be-restored contract.\n/// - `rent_allowance`: The encoded rent allowance of the restored contract\n///                     upon successful restoration.\n/// - `filtered_keys`: Storage keys that will be ignored for the tombstone hash\n///                    match calculation that decide whether the original contract\n///                    storage and the storage of the restorer contract is equal.\npub fn restore_to(\n    account_id: &[u8],\n    code_hash: &[u8],\n    rent_allowance: &[u8],\n    filtered_keys: &[Key],\n) {\n    unsafe {\n        sys::seal_restore_to(\n            Ptr32::from_slice(account_id),\n            account_id.len() as u32,\n            Ptr32::from_slice(code_hash),\n            code_hash.len() as u32,\n            Ptr32::from_slice(rent_allowance),\n            rent_allowance.len() as u32,\n            Ptr32::from_slice(filtered_keys),\n            filtered_keys.len() as u32,\n        )\n    }\n}\n\npub fn terminate(beneficiary: &[u8]) -> ! {\n    unsafe {\n        sys::seal_terminate(Ptr32::from_slice(beneficiary), beneficiary.len() as u32)\n    }\n}\n\npub fn call_chain_extension(func_id: u32, input: &[u8], output: &mut &mut [u8]) -> u32 {\n    let mut output_len = output.len() as u32;\n    let ret_code = {\n        unsafe {\n            sys::seal_call_chain_extension(\n                func_id,\n                Ptr32::from_slice(input),\n                input.len() as u32,\n                Ptr32Mut::from_slice(output),\n                Ptr32Mut::from_ref(&mut output_len),\n            )\n        }\n    };\n    extract_from_slice(output, output_len as usize);\n    ret_code.into_u32()\n}\n\npub fn input(output: &mut &mut [u8]) {\n    let mut output_len = output.len() as u32;\n    {\n        unsafe {\n            sys::seal_input(\n                Ptr32Mut::from_slice(output),\n                Ptr32Mut::from_ref(&mut output_len),\n            )\n        };\n    }\n    extract_from_slice(output, output_len as usize);\n}\n\npub fn return_value(flags: ReturnFlags, return_value: &[u8]) -> ! {\n    unsafe {\n        sys::seal_return(\n            flags.into_u32(),\n            Ptr32::from_slice(return_value),\n            return_value.len() as u32,\n        )\n    }\n}\n\nmacro_rules! impl_seal_wrapper_for {\n    ( $( ($name:ident => $seal_name:ident), )* ) => {\n        $(\n            pub fn $name(output: &mut &mut [u8]) {\n                let mut output_len = output.len() as u32;\n                {\n                    unsafe {\n                        sys::$seal_name(\n                            Ptr32Mut::from_slice(output),\n                            Ptr32Mut::from_ref(&mut output_len),\n                        )\n                    };\n                }\n                extract_from_slice(output, output_len as usize);\n            }\n        )*\n    }\n}\nimpl_seal_wrapper_for! {\n    (caller => seal_caller),\n    (block_number => seal_block_number),\n    (address => seal_address),\n    (balance => seal_balance),\n    (gas_left => seal_gas_left),\n    (value_transferred => seal_value_transferred),\n    (now => seal_now),\n    (rent_allowance => seal_rent_allowance),\n    (minimum_balance => seal_minimum_balance),\n    (tombstone_deposit => seal_tombstone_deposit),\n}\n\npub fn weight_to_fee(gas: u64, output: &mut &mut [u8]) {\n    let mut output_len = output.len() as u32;\n    {\n        unsafe {\n            sys::seal_weight_to_fee(\n                gas,\n                Ptr32Mut::from_slice(output),\n                Ptr32Mut::from_ref(&mut output_len),\n            )\n        };\n    }\n    extract_from_slice(output, output_len as usize);\n}\n\npub fn set_rent_allowance(value: &[u8]) {\n    unsafe { sys::seal_set_rent_allowance(Ptr32::from_slice(value), value.len() as u32) }\n}\n\npub fn random(subject: &[u8], output: &mut &mut [u8]) {\n    let mut output_len = output.len() as u32;\n    {\n        unsafe {\n            sys::seal_random(\n                Ptr32::from_slice(subject),\n                subject.len() as u32,\n                Ptr32Mut::from_slice(output),\n                Ptr32Mut::from_ref(&mut output_len),\n            )\n        };\n    }\n    extract_from_slice(output, output_len as usize);\n}\n\npub fn println(content: &str) {\n    let bytes = content.as_bytes();\n    unsafe { sys::seal_println(Ptr32::from_slice(bytes), bytes.len() as u32) }\n}\n\nmacro_rules! impl_hash_fn {\n    ( $name:ident, $bytes_result:literal ) => {\n        paste::item! {\n            pub fn [<hash_ $name>](input: &[u8], output: &mut [u8; $bytes_result]) {\n                unsafe {\n                    sys::[<seal_hash_ $name>](\n                        Ptr32::from_slice(input),\n                        input.len() as u32,\n                        Ptr32Mut::from_slice(output),\n                    )\n                }\n            }\n        }\n    };\n}\nimpl_hash_fn!(sha2_256, 32);\nimpl_hash_fn!(keccak_256, 32);\nimpl_hash_fn!(blake2_256, 32);\nimpl_hash_fn!(blake2_128, 16);\n"],["860","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Operations on the off-chain testing environment.\n\nuse super::{\n    chain_extension::ChainExtension,\n    db::ExecContext,\n    AccountError,\n    EnvInstance,\n    OnInstance,\n};\npub use super::{\n    db::ChainSpec,\n    CallData,\n    EmittedEvent,\n};\nuse crate::{\n    Environment,\n    Result,\n};\nuse ink_prelude::string::String;\nuse std::str::FromStr;\n\n/// Pushes a contract execution context.\n///\n/// This is the data behind a single instance of a contract call.\n///\n/// # Note\n///\n/// Together with [`pop_execution_context`] this can be used to emulated\n/// nested calls.\npub fn push_execution_context<T>(\n    caller: T::AccountId,\n    callee: T::AccountId,\n    gas_limit: T::Balance,\n    endowment: T::Balance,\n    call_data: CallData,\n) where\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        instance.exec_context.push(\n            ExecContext::build::<T>()\n                .caller(caller)\n                .callee(callee)\n                .gas(gas_limit)\n                .transferred_value(endowment)\n                .call_data(call_data)\n                .finish(),\n        )\n    })\n}\n\n/// Pops the top contract execution context.\n///\n/// # Note\n///\n/// Together with [`push_execution_context`] this can be used to emulated\n/// nested calls.\npub fn pop_execution_context() {\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        instance.exec_context.pop();\n    })\n}\n\n/// Sets the balance of the account to the given balance.\n///\n/// # Note\n///\n/// Note that account could refer to either a user account or\n/// a smart contract account.\n///\n/// # Errors\n///\n/// - If `account` does not exist.\n/// - If the underlying `account` type does not match.\n/// - If the underlying `new_balance` type does not match.\npub fn set_account_balance<T>(\n    account_id: T::AccountId,\n    new_balance: T::Balance,\n) -> Result<()>\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        instance\n            .accounts\n            .get_account_mut::<T>(&account_id)\n            .ok_or_else(|| AccountError::no_account_for_id::<T>(&account_id))\n            .map_err(Into::into)\n            .and_then(|account| account.set_balance::<T>(new_balance).map_err(Into::into))\n    })\n}\n\n/// Returns the balance of the account.\n///\n/// # Note\n///\n/// Note that account could refer to either a user account or\n/// a smart contract account. This returns the same as `env::api::balance`\n/// if given the account ID of the currently executed smart contract.\n///\n/// # Errors\n///\n/// - If `account` does not exist.\n/// - If the underlying `account` type does not match.\npub fn get_account_balance<T>(account_id: T::AccountId) -> Result<T::Balance>\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        instance\n            .accounts\n            .get_account::<T>(&account_id)\n            .ok_or_else(|| AccountError::no_account_for_id::<T>(&account_id))\n            .map_err(Into::into)\n            .and_then(|account| account.balance::<T>().map_err(Into::into))\n    })\n}\n\n/// Sets the rent allowance of the contract account to the given rent allowance.\n///\n/// # Errors\n///\n/// - If `account` does not exist.\n/// - If the underlying `account` type does not match.\n/// - If the underlying `new_rent_allowance` type does not match.\npub fn set_contract_rent_allowance<T>(\n    account_id: T::AccountId,\n    new_rent_allowance: T::Balance,\n) -> Result<()>\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        instance\n            .accounts\n            .get_account_mut::<T>(&account_id)\n            .ok_or_else(|| AccountError::no_account_for_id::<T>(&account_id))\n            .map_err(Into::into)\n            .and_then(|account| {\n                account\n                    .set_rent_allowance::<T>(new_rent_allowance)\n                    .map_err(Into::into)\n            })\n    })\n}\n\n/// Returns the rent allowance of the contract account.\n///\n/// # Errors\n///\n/// - If `account` does not exist.\n/// - If the underlying `account` type does not match.\n/// - If the returned rent allowance cannot be properly decoded.\npub fn get_contract_rent_allowance<T>(account_id: T::AccountId) -> Result<T::Balance>\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        instance\n            .accounts\n            .get_account::<T>(&account_id)\n            .ok_or_else(|| AccountError::no_account_for_id::<T>(&account_id))\n            .map_err(Into::into)\n            .and_then(|account| account.rent_allowance::<T>().map_err(Into::into))\n    })\n}\n\n/// Registers a new chain extension.\npub fn register_chain_extension<E>(extension: E)\nwhere\n    E: ChainExtension + 'static,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        instance\n            .chain_extension_handler\n            .register(Box::new(extension));\n    })\n}\n\n/// Set the entropy hash of the current block.\n///\n/// # Note\n///\n/// This allows to control what [`random`][`crate::random`] returns.\npub fn set_block_entropy<T>(entropy: T::Hash) -> Result<()>\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        instance.current_block_mut()?.set_entropy::<T>(entropy)\n    })\n    .map_err(Into::into)\n}\n\n/// Update the [ChainSpec](`crate::test::ChainSpec`) for the test environment\npub fn update_chain_spec<F>(f: F) -> Result<()>\nwhere\n    F: FnOnce(&mut ChainSpec),\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| f(instance.chain_spec_mut()));\n    Ok(())\n}\n\n/// Returns the contents of the past performed environmental `println` in order.\npub fn recorded_printlns() -> impl Iterator<Item = String> {\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        // We return a clone of the recorded strings instead of\n        // references to them since this would require the whole `on_instance`\n        // API to operate on `'static` environmental instances which would\n        // ultimately allow leaking those `'static` references to the outside\n        // and potentially lead to terrible bugs such as iterator invalidation.\n        instance\n            .console\n            .past_prints()\n            .map(ToOwned::to_owned)\n            .collect::<Vec<_>>()\n            .into_iter()\n    })\n}\n\n/// Returns the recorded emitted events in order.\npub fn recorded_events() -> impl Iterator<Item = EmittedEvent> {\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        // We return a clone of the recorded emitted events instead of\n        // references to them since this would require the whole `on_instance`\n        // API to operate on `'static` environmental instances which would\n        // ultimately allow leaking those `'static` references to the outside\n        // and potentially lead to terrible bugs such as iterator invalidation.\n        instance\n            .emitted_events\n            .emitted_events()\n            .map(Clone::clone)\n            .collect::<Vec<_>>()\n            .into_iter()\n    })\n}\n\n/// Advances the chain by a single block.\npub fn advance_block<T>() -> Result<()>\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| instance.advance_block::<T>())\n}\n\n/// Set to true to disable clearing storage\n///\n/// # Note\n///\n/// Useful for benchmarking because it ensures the initialized storage is maintained across runs,\n/// because lazy storage structures automatically clear their associated cells when they are dropped.\npub fn set_clear_storage_disabled(disable: bool) {\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        instance.clear_storage_disabled = disable\n    })\n}\n\n/// The default accounts.\npub struct DefaultAccounts<T>\nwhere\n    T: Environment,\n{\n    /// The predefined `ALICE` account holding substantial amounts of value.\n    pub alice: T::AccountId,\n    /// The predefined `BOB` account holding some amounts of value.\n    pub bob: T::AccountId,\n    /// The predefined `CHARLIE` account holding some amounts of value.\n    pub charlie: T::AccountId,\n    /// The predefined `DJANGO` account holding no value.\n    pub django: T::AccountId,\n    /// The predefined `EVE` account holding no value.\n    pub eve: T::AccountId,\n    /// The predefined `FRANK` account holding no value.\n    pub frank: T::AccountId,\n}\n\n/// Returns the default accounts for testing purposes:\n/// Alice, Bob, Charlie, Django, Eve and Frank.\npub fn default_accounts<T>() -> Result<DefaultAccounts<T>>\nwhere\n    T: Environment,\n    <T as Environment>::AccountId: From<[u8; 32]>,\n{\n    Ok(DefaultAccounts {\n        alice: T::AccountId::from([0x01; 32]),\n        bob: T::AccountId::from([0x02; 32]),\n        charlie: T::AccountId::from([0x03; 32]),\n        django: T::AccountId::from([0x04; 32]),\n        eve: T::AccountId::from([0x05; 32]),\n        frank: T::AccountId::from([0x06; 32]),\n    })\n}\n\n/// Initializes the whole off-chain environment.\n///\n/// # Note\n///\n/// - Initializes the off-chain environment with default values that fit most\n/// uses cases.\npub fn initialize_or_reset_as_default<T>() -> Result<()>\nwhere\n    T: Environment,\n    <T as Environment>::AccountId: From<[u8; 32]>,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        instance.initialize_or_reset_as_default::<T>()\n    })\n}\n\n/// Runs the given closure test function with the default configuartion\n/// for the off-chain environment.\npub fn run_test<T, F>(f: F) -> Result<()>\nwhere\n    T: Environment,\n    F: FnOnce(DefaultAccounts<T>) -> Result<()>,\n    <T as Environment>::AccountId: From<[u8; 32]>,\n{\n    initialize_or_reset_as_default::<T>()?;\n    let default_accounts = default_accounts::<T>()?;\n    f(default_accounts)\n}\n\n/// Returns the total number of reads and writes of the contract's storage.\npub fn get_contract_storage_rw<T>(account_id: &T::AccountId) -> Result<(usize, usize)>\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        instance\n            .accounts\n            .get_account::<T>(account_id)\n            .ok_or_else(|| AccountError::no_account_for_id::<T>(account_id))\n            .map_err(Into::into)\n            .and_then(|account| account.get_storage_rw().map_err(Into::into))\n    })\n}\n\n/// Returns the amount of storage cells used by the account `account_id`.\n///\n/// Returns `None` if the `account_id` is non-existent.\npub fn count_used_storage_cells<T>(account_id: &T::AccountId) -> Result<usize>\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        instance\n            .accounts\n            .get_account::<T>(account_id)\n            .ok_or_else(|| AccountError::no_account_for_id::<T>(account_id))\n            .map_err(Into::into)\n            .and_then(|account| account.count_used_storage_cells().map_err(Into::into))\n    })\n}\n\n/// Returns the account id of the currently executing contract.\npub fn get_current_contract_account_id<T>() -> Result<T::AccountId>\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        let exec_context = instance.exec_context()?;\n        let callee = exec_context.callee.decode()?;\n        Ok(callee)\n    })\n}\n\n/// The result of a successful contract termination.\n#[derive(scale::Encode, scale::Decode)]\npub struct ContractTerminationResult<E>\nwhere\n    E: Environment,\n{\n    /// The beneficiary account who received the remaining value in the contract.\n    pub beneficiary: <E as Environment>::AccountId,\n    /// The value which was transferred to the `beneficiary`.\n    pub transferred: <E as Environment>::Balance,\n}\n\n#[cfg(feature = \"std\")]\nuse std::panic::UnwindSafe;\n\n/// Tests if a contract terminates successfully after `self.env().terminate()`\n/// has been called.\n///\n/// # Usage\n///\n/// ```no_compile\n/// let should_terminate = move || your_contract.fn_which_should_terminate();\n/// ink_env::test::assert_contract_termination::<ink_env::DefaultEnvironment, _>(\n///     should_terminate,\n///     expected_beneficiary,\n///     expected_value_transferred_to_beneficiary\n/// );\n/// ```\n///\n/// See `examples/contract-terminate` for a complete usage example.\n#[cfg(feature = \"std\")]\npub fn assert_contract_termination<T, F>(\n    should_terminate: F,\n    expected_beneficiary: T::AccountId,\n    expected_balance: T::Balance,\n) where\n    T: Environment,\n    F: FnMut() + UnwindSafe,\n    <T as Environment>::AccountId: core::fmt::Debug,\n    <T as Environment>::Balance: core::fmt::Debug,\n{\n    let value_any = ::std::panic::catch_unwind(should_terminate)\n        .expect_err(\"contract did not terminate\");\n    let encoded_input = value_any\n        .downcast_ref::<String>()\n        .expect(\"panic object can not be cast\");\n    let deserialized_vec = encoded_input\n        .replace(\"[\", \"\")\n        .replace(\"]\", \"\")\n        .split(\", \")\n        .map(|s| u8::from_str(s).expect(\"u8 cannot be extracted from str\"))\n        .collect::<Vec<u8>>();\n    let res: ContractTerminationResult<T> =\n        scale::Decode::decode(&mut &deserialized_vec[..])\n            .expect(\"input can not be decoded\");\n\n    assert_eq!(res.beneficiary, expected_beneficiary);\n    assert_eq!(res.transferred, expected_balance);\n}\n"],["861","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nmod call_data;\nmod chain_extension;\nmod db;\nmod hashing;\nmod impls;\npub mod test_api;\nmod typed_encoded;\nmod types;\n\n#[cfg(test)]\nmod tests;\n\npub use self::{\n    call_data::CallData,\n    db::{\n        AccountError,\n        EmittedEvent,\n        PastPrints,\n    },\n    typed_encoded::TypedEncodedError,\n};\nuse self::{\n    chain_extension::ChainExtensionHandler,\n    db::{\n        Account,\n        AccountsDb,\n        Block,\n        ChainSpec,\n        Console,\n        EmittedEventsRecorder,\n        ExecContext,\n    },\n    typed_encoded::TypedEncoded,\n    types::{\n        OffAccountId,\n        OffBalance,\n        OffBlockNumber,\n        OffHash,\n        OffTimestamp,\n    },\n};\nuse super::OnInstance;\nuse crate::Environment;\nuse core::cell::RefCell;\nuse derive_more::From;\n\n#[derive(Debug, From, PartialEq, Eq)]\npub enum OffChainError {\n    Account(AccountError),\n    TypedEncoded(TypedEncodedError),\n    #[from(ignore)]\n    UninitializedBlocks,\n    #[from(ignore)]\n    UninitializedExecutionContext,\n    #[from(ignore)]\n    UnregisteredChainExtension,\n}\n\npub type Result<T> = core::result::Result<T, OffChainError>;\n\n/// The off-chain environment.\n///\n/// Mainly used for off-chain testing.\npub struct EnvInstance {\n    /// The accounts database of the environment.\n    accounts: AccountsDb,\n    /// Current execution context and context.\n    exec_context: Vec<ExecContext>,\n    /// The general chain spec.\n    chain_spec: ChainSpec,\n    /// The blocks of the chain.\n    blocks: Vec<Block>,\n    /// The console to print debug contents.\n    console: Console,\n    /// Handler for registered chain extensions.\n    chain_extension_handler: ChainExtensionHandler,\n    /// Emitted events recorder.\n    emitted_events: EmittedEventsRecorder,\n    /// Set to true to disable clearing storage\n    clear_storage_disabled: bool,\n}\n\nimpl EnvInstance {\n    /// Creates a new uninitialized off-chain environment.\n    pub fn uninitialized() -> Self {\n        Self {\n            accounts: AccountsDb::new(),\n            exec_context: Vec::new(),\n            chain_spec: ChainSpec::uninitialized(),\n            blocks: Vec::new(),\n            console: Console::new(),\n            chain_extension_handler: ChainExtensionHandler::new(),\n            emitted_events: EmittedEventsRecorder::new(),\n            clear_storage_disabled: false,\n        }\n    }\n\n    /// Returns `true` if the off-chain environment is uninitialized.\n    pub fn is_initialized(&self) -> bool {\n        !self.exec_context.is_empty()\n    }\n\n    /// Either resets or initializes the off-chain environment to default values.\n    pub fn initialize_or_reset_as_default<T>(&mut self) -> crate::Result<()>\n    where\n        T: Environment,\n        <T as Environment>::AccountId: From<[u8; 32]>,\n    {\n        if self.is_initialized() {\n            self.reset()\n        }\n        self.initialize_as_default::<T>()?;\n        Ok(())\n    }\n\n    /// Resets the off-chain environment to unintialized state.\n    pub fn reset(&mut self) {\n        self.accounts.reset();\n        self.exec_context.clear();\n        self.chain_spec.reset();\n        self.blocks.clear();\n        self.console.reset();\n        self.chain_extension_handler.reset();\n        self.emitted_events.reset();\n        self.clear_storage_disabled = false;\n    }\n\n    /// Initializes the whole off-chain environment.\n    ///\n    /// # Note\n    ///\n    /// This is needed since we operate on a static instance that cannot be\n    /// made generic over all environmental types and thus we are required to\n    /// initialize it upon program start uninitialized which is why we have\n    /// `TypedEncoded` wrappers.\n    ///\n    /// The off-chain environment requires to be initialized before every usage.\n    ///\n    /// This routine implements a default initialization that should be fine\n    /// for most use cases.\n    pub fn initialize_as_default<T>(&mut self) -> crate::Result<()>\n    where\n        T: Environment,\n        <T as Environment>::AccountId: From<[u8; 32]>,\n    {\n        use core::ops::Div as _;\n        use num_traits::{\n            Bounded as _,\n            Zero as _,\n        };\n        let default_accounts = test_api::default_accounts::<T>()?;\n        // Alice has half of the maximum possible amount.\n        self.accounts.add_user_account::<T>(\n            default_accounts.alice.clone(),\n            T::Balance::max_value().div(T::Balance::from(2u32)),\n        );\n        // Bob has half the balance that alice got.\n        self.accounts.add_user_account::<T>(\n            default_accounts.bob,\n            T::Balance::max_value().div(T::Balance::from(4u32)),\n        );\n        // All other default accounts have zero balance.\n        self.accounts\n            .add_user_account::<T>(default_accounts.charlie, T::Balance::zero());\n        self.accounts\n            .add_user_account::<T>(default_accounts.django, T::Balance::zero());\n        self.accounts\n            .add_user_account::<T>(default_accounts.eve, T::Balance::zero());\n        self.accounts\n            .add_user_account::<T>(default_accounts.frank, T::Balance::zero());\n        // Initialize our first block.\n        self.blocks.push(Block::new::<T>(\n            T::BlockNumber::from(0u32),\n            T::Timestamp::from(0u32),\n        ));\n        // Initialize chain specification.\n        self.chain_spec.initialize_as_default::<T>()?;\n        // Initialize the called contract account.\n        let contract_account_id = T::AccountId::from([0x07; 32]);\n        self.accounts.add_contract_account::<T>(\n            contract_account_id.clone(),\n            T::Balance::from(0u32),\n            T::Balance::from(20u32),\n        );\n        // Initialize the execution context for the first contract execution.\n        use crate::call::Selector;\n        // The below selector bytes are incorrect but since calling doesn't work\n        // yet we do not have to fix this now.\n        let selector_bytes_for_call = [0x00; 4];\n        self.exec_context.push(\n            ExecContext::build::<T>()\n                .caller(default_accounts.alice)\n                .callee(contract_account_id)\n                .gas(T::Balance::from(500_000u32))\n                .transferred_value(T::Balance::from(500u32))\n                .call_data(CallData::new(Selector::new(selector_bytes_for_call)))\n                .finish(),\n        );\n        Ok(())\n    }\n\n    /// Advances the chain by a single block.\n    pub fn advance_block<T>(&mut self) -> crate::Result<()>\n    where\n        T: Environment,\n    {\n        let new_block_number = T::BlockNumber::from(self.blocks.len() as u32);\n        let new_timestamp = self.current_block()?.timestamp::<T>()?\n            + self.chain_spec.block_time::<T>()?;\n        self.blocks\n            .push(Block::new::<T>(new_block_number, new_timestamp));\n        Ok(())\n    }\n\n    /// Returns the current execution context.\n    fn exec_context(&self) -> Result<&ExecContext> {\n        self.exec_context\n            .last()\n            .ok_or(OffChainError::UninitializedExecutionContext)\n    }\n\n    /// Returns the current execution context.\n    fn exec_context_mut(&mut self) -> Result<&mut ExecContext> {\n        self.exec_context\n            .last_mut()\n            .ok_or(OffChainError::UninitializedExecutionContext)\n    }\n\n    /// Returns the current block of the chain.\n    fn current_block(&self) -> Result<&Block> {\n        self.blocks.last().ok_or(OffChainError::UninitializedBlocks)\n    }\n\n    /// Returns a mutable reference to the current block of the chain.\n    fn current_block_mut(&mut self) -> Result<&mut Block> {\n        self.blocks\n            .last_mut()\n            .ok_or(OffChainError::UninitializedBlocks)\n    }\n\n    fn chain_spec_mut(&mut self) -> &mut ChainSpec {\n        &mut self.chain_spec\n    }\n}\n\nimpl OnInstance for EnvInstance {\n    fn on_instance<F, R>(f: F) -> R\n    where\n        F: FnOnce(&mut Self) -> R,\n    {\n        thread_local!(\n            static INSTANCE: RefCell<EnvInstance> = RefCell::new(\n                EnvInstance::uninitialized()\n            )\n        );\n        INSTANCE.with(|instance| f(&mut instance.borrow_mut()))\n    }\n}\n"],["862","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::{\n    super::{\n        Result,\n        TypedEncoded,\n    },\n    OffBlockNumber,\n    OffHash,\n    OffTimestamp,\n};\nuse crate::Environment;\n\n/// An emulated block in the chain.\npub struct Block {\n    /// The current block number.\n    number: OffBlockNumber,\n    /// The timestamp of the block.\n    timestamp: OffTimestamp,\n    /// The randomization entropy for a block.\n    ///\n    /// # Note\n    ///\n    /// - Can optionally be set for more control via\n    ///   [`test::set_block_entropy`][`crate::test::set_block_entropy`].\n    entropy: OffHash,\n}\n\nimpl Block {\n    /// Creates a new block for the given number and time stamp.\n    pub fn new<T>(number: T::BlockNumber, timestamp: T::Timestamp) -> Self\n    where\n        T: Environment,\n    {\n        use crate::Clear;\n        use rand::Rng as _;\n        let mut entropy = <T as Environment>::Hash::clear();\n        rand::thread_rng().fill(entropy.as_mut());\n        Self {\n            number: TypedEncoded::new(&number),\n            timestamp: TypedEncoded::new(&timestamp),\n            entropy: TypedEncoded::new(&entropy),\n        }\n    }\n\n    /// Returns the block number.\n    pub fn number<T>(&self) -> Result<T::BlockNumber>\n    where\n        T: Environment,\n    {\n        self.number.decode().map_err(Into::into)\n    }\n\n    /// Returns the timestamp of the block.\n    pub fn timestamp<T>(&self) -> Result<T::Timestamp>\n    where\n        T: Environment,\n    {\n        self.timestamp.decode().map_err(Into::into)\n    }\n\n    /// Sets the entropy of this block to the given entropy.\n    ///\n    /// # Note\n    ///\n    /// This is mainly used to control what [`random`][`crate::random`] returns\n    /// in the off-chain environment.\n    pub fn set_entropy<T>(&mut self, new_entropy: T::Hash) -> Result<()>\n    where\n        T: Environment,\n    {\n        self.entropy.assign(&new_entropy).map_err(Into::into)\n    }\n\n    /// Returns a randomized hash.\n    ///\n    /// # Note\n    ///\n    /// - This is the off-chain environment implementation of\n    /// [`random`][`crate::random`]. It provides the same behaviour in that it\n    /// will likely yield the same hash for the same subjects within the same\n    /// block (or execution context).\n    ///\n    /// - Returned hashes on the surface might appear random, however for\n    /// testability purposes the actual implementation is quite simple and\n    /// computes those \"random\" hashes by wrapping XOR of the internal entry hash\n    /// with the eventually repeated sequence of the subject buffer.\n    pub fn random<T>(&self, subject: &[u8]) -> Result<T::Hash>\n    where\n        T: Environment,\n    {\n        let mut entropy = self.entropy.clone();\n        let entropy_bytes = entropy.encoded_bytes_mut()?;\n        let len_entropy = entropy_bytes.len();\n        for (n, subject) in subject.iter().enumerate() {\n            let id = n % len_entropy;\n            entropy_bytes[id] = entropy_bytes[id] ^ subject ^ (n as u8);\n        }\n        Ok(entropy.decode::<T::Hash>()?)\n    }\n}\n"],["863","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::{\n    super::{\n        CallData,\n        Result,\n        TypedEncoded,\n    },\n    OffAccountId,\n    OffBalance,\n};\nuse crate::Environment;\nuse ink_prelude::vec::Vec;\n\npub type Bytes = Vec<u8>;\n\n/// The context of a contract execution.\npub struct ExecContext {\n    /// The caller of the contract execution.\n    ///\n    /// Might be user or another contract.\n    pub caller: OffAccountId,\n    /// The callee of the contract execution.\n    pub callee: OffAccountId,\n    /// The transferred value from caller to callee.\n    pub transferred_value: OffBalance,\n    /// The gas provided for the whole execution.\n    pub gas: OffBalance,\n    /// The inputs provided for the whole execution.\n    ///\n    /// # Note\n    ///\n    /// This includes selector and encoded arguments.\n    pub call_data: CallData,\n    /// The output of the contract execution.\n    pub output: Option<Bytes>,\n}\n\nimpl ExecContext {\n    /// Constructs a new execution context.\n    pub fn build<T>() -> ExecContextBuilder<T>\n    where\n        T: Environment,\n    {\n        ExecContextBuilder::new()\n    }\n\n    /// Returns the caller.\n    pub fn caller<T>(&self) -> Result<T::AccountId>\n    where\n        T: Environment,\n    {\n        self.caller.decode().map_err(Into::into)\n    }\n\n    /// Returns the callee.\n    pub fn callee<T>(&self) -> Result<T::AccountId>\n    where\n        T: Environment,\n    {\n        self.callee.decode().map_err(Into::into)\n    }\n\n    /// Returns the transferred value.\n    pub fn transferred_value<T>(&self) -> Result<T::Balance>\n    where\n        T: Environment,\n    {\n        self.transferred_value.decode().map_err(Into::into)\n    }\n\n    /// Returns the gas.\n    pub fn gas<T>(&self) -> Result<T::Balance>\n    where\n        T: Environment,\n    {\n        self.gas.decode().map_err(Into::into)\n    }\n\n    /// Returns the call data.\n    #[allow(\n        dead_code,\n        // Needed as soon as we support to execute contracts\n        // directly through the off-chain environment.\n    )]\n    pub fn call_data(&self) -> &CallData {\n        &self.call_data\n    }\n\n    /// Returns the contract execution output.\n    #[allow(\n        dead_code,\n        // Needed as soon as we support to execute contracts\n        // directly through the off-chain environment.\n    )]\n    pub fn output(&self) -> Option<&Bytes> {\n        self.output.as_ref()\n    }\n}\n\n/// Builder for execution contexts.\npub struct ExecContextBuilder<T>\nwhere\n    T: Environment,\n{\n    /// The caller of the newly created execution context.\n    caller: Option<T::AccountId>,\n    /// The callee of the newly created execution context.\n    callee: Option<T::AccountId>,\n    /// The transferred value from caller to callee.\n    transferred_value: Option<T::Balance>,\n    /// The gas provided for the contract execution from caller to callee.\n    gas: Option<T::Balance>,\n    /// The inputs given to the contract execution.\n    call_data: Option<CallData>,\n}\n\nimpl<T> ExecContextBuilder<T>\nwhere\n    T: Environment,\n{\n    /// Constructs a new execution context builder.\n    pub fn new() -> Self {\n        Self {\n            caller: None,\n            callee: None,\n            transferred_value: None,\n            gas: None,\n            call_data: None,\n        }\n    }\n\n    /// Sets caller of the execution context.\n    ///\n    /// # Panics\n    ///\n    /// If there has already been set a caller.\n    pub fn caller(mut self, caller: T::AccountId) -> Self {\n        if self.caller.is_some() {\n            panic!(\"already has a caller\");\n        }\n        self.caller = Some(caller);\n        self\n    }\n\n    /// Sets callee of the execution context.\n    ///\n    /// # Panics\n    ///\n    /// If there has already been set a callee.\n    pub fn callee(mut self, callee: T::AccountId) -> Self {\n        if self.callee.is_some() {\n            panic!(\"already has a callee\");\n        }\n        self.callee = Some(callee);\n        self\n    }\n\n    /// Sets the provided gas for the execution.\n    ///\n    /// # Panics\n    ///\n    /// If there has already been set provided gas.\n    pub fn gas(mut self, gas: T::Balance) -> Self {\n        if self.gas.is_some() {\n            panic!(\"already has provided gas\");\n        }\n        self.gas = Some(gas);\n        self\n    }\n\n    /// Sets the transferred value (endowment) for the execution.\n    ///\n    /// # Panics\n    ///\n    /// If there has already been set transferred value (endowment).\n    pub fn transferred_value(mut self, transferred_value: T::Balance) -> Self {\n        if self.transferred_value.is_some() {\n            panic!(\"already has set transferred value (endowment)\");\n        }\n        self.transferred_value = Some(transferred_value);\n        self\n    }\n\n    /// Sets the call data for the execution.\n    ///\n    /// # Panics\n    ///\n    /// If there has already been set call data.\n    pub fn call_data(mut self, call_data: CallData) -> Self {\n        if self.call_data.is_some() {\n            panic!(\"already has set call data\");\n        }\n        self.call_data = Some(call_data);\n        self\n    }\n\n    /// Finishes construction of execution context.\n    ///\n    /// # Panics\n    ///\n    /// If any parameter has not yet been set.\n    pub fn finish(self) -> ExecContext {\n        let caller = self.caller.expect(\"need a valid caller at this point\");\n        let callee = self.callee.expect(\"need a valid callee at this point\");\n        let transferred_value = self\n            .transferred_value\n            .expect(\"need a valid transferred value (endowment) at this point\");\n        let gas = self.gas.expect(\"need valid provided gas at this point\");\n        ExecContext {\n            caller: TypedEncoded::new(&caller),\n            callee: TypedEncoded::new(&callee),\n            transferred_value: TypedEncoded::new(&transferred_value),\n            gas: TypedEncoded::new(&gas),\n            call_data: self.call_data.unwrap(),\n            output: None,\n        }\n    }\n}\n"],["864","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nmod accounts;\nmod block;\nmod chain_spec;\nmod console;\nmod events;\nmod exec_context;\n\npub use self::{\n    accounts::{\n        Account,\n        AccountError,\n        AccountKind,\n        AccountsDb,\n        ContractAccount,\n        ContractStorage,\n    },\n    block::Block,\n    chain_spec::ChainSpec,\n    console::{\n        Console,\n        PastPrints,\n    },\n    events::{\n        EmittedEvent,\n        EmittedEventsRecorder,\n    },\n    exec_context::ExecContext,\n};\nuse super::{\n    OffAccountId,\n    OffBalance,\n    OffBlockNumber,\n    OffHash,\n    OffTimestamp,\n};\n"],["865","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse ink_prelude::string::String;\n\n/// A debug console used to print console contents and store them.\npub struct Console {\n    /// The buffer to store the already pasted contents.\n    past_prints: Vec<String>,\n}\n\nimpl Console {\n    /// Creates a new empty console.\n    pub fn new() -> Self {\n        Self {\n            past_prints: Vec::new(),\n        }\n    }\n\n    /// Resets the console to uninitialized state.\n    pub fn reset(&mut self) {\n        self.past_prints.clear();\n    }\n\n    /// Prints the contents to the actual console and stores them.\n    pub fn println(&mut self, contents: &str) {\n        self.past_prints.push(contents.to_string());\n        println!(\"{}\", contents);\n    }\n\n    /// Returns an iterator over the past console prints.\n    pub fn past_prints(&self) -> PastPrints {\n        PastPrints::new(self)\n    }\n}\n\n/// Iterator over the past prints to the console.\npub struct PastPrints<'a> {\n    /// Iterator over the past printlns.\n    iter: core::slice::Iter<'a, String>,\n}\n\nimpl<'a> PastPrints<'a> {\n    /// Creates a new iterator over the past console prints.\n    fn new(console: &'a Console) -> Self {\n        Self {\n            iter: console.past_prints.iter(),\n        }\n    }\n}\n\nimpl<'a> Iterator for PastPrints<'a> {\n    type Item = &'a str;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(AsRef::as_ref)\n    }\n}\n\nimpl<'a> ExactSizeIterator for PastPrints<'a> {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}\n\nimpl<'a> DoubleEndedIterator for PastPrints<'a> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.iter.next_back().map(AsRef::as_ref)\n    }\n}\n"],["866","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::{\n    super::{\n        OffChainError,\n        TypedEncodedError,\n    },\n    OffAccountId,\n    OffBalance,\n};\nuse crate::{\n    Environment,\n    Error,\n};\nuse core::cell::Cell;\nuse derive_more::From;\nuse ink_prelude::collections::BTreeMap;\nuse ink_primitives::Key;\n\n/// Errors encountered upon interacting with the accounts database.\n#[derive(Debug, From, PartialEq, Eq)]\npub enum AccountError {\n    TypedEncoded(TypedEncodedError),\n    #[from(ignore)]\n    UnexpectedUserAccount,\n    #[from(ignore)]\n    NoAccountForId(OffAccountId),\n}\n\nimpl From<AccountError> for Error {\n    fn from(account_error: AccountError) -> Self {\n        Error::OffChain(OffChainError::Account(account_error))\n    }\n}\n\nimpl AccountError {\n    /// Creates a new error to indicate a missing account.\n    pub fn no_account_for_id<T>(account_id: &T::AccountId) -> Self\n    where\n        T: Environment,\n    {\n        Self::NoAccountForId(OffAccountId::new(account_id))\n    }\n}\n\nimpl From<scale::Error> for AccountError {\n    fn from(err: scale::Error) -> Self {\n        AccountError::TypedEncoded(err.into())\n    }\n}\n\n/// Result type encountered while operating on accounts.\npub type Result<T> = core::result::Result<T, AccountError>;\n\n/// The database that stores all accounts.\npub struct AccountsDb {\n    /// The mapping from account ID to an actual account.\n    accounts: BTreeMap<OffAccountId, Account>,\n}\n\nimpl AccountsDb {\n    /// Creates a new empty accounts database.\n    pub fn new() -> Self {\n        Self {\n            accounts: BTreeMap::new(),\n        }\n    }\n\n    /// Resets the account DB to uninitialized state.\n    pub fn reset(&mut self) {\n        self.accounts.clear()\n    }\n\n    /// Returns the account at the given account ID or creates it.\n    pub fn get_or_create_account<T>(&mut self, at: &T::AccountId) -> &mut Account\n    where\n        T: Environment,\n    {\n        // Note: We cannot do a normal match for `Some(account)` here since\n        //       the borrow-checker somehow cannot make sense of it according\n        //       to its lifetime analysis. Consider this to be a hack until\n        //       the borrow-checker eventually let's us do this.\n        if self.get_account::<T>(&at).is_some() {\n            self.get_account_mut::<T>(at)\n                .expect(\"just checked that account exists\")\n        } else {\n            self.add_user_account::<T>(at.clone(), 0u32.into());\n            self.get_account_mut::<T>(at)\n                .expect(\"just added the account so it must exist\")\n        }\n    }\n\n    /// Returns the account for the given account ID if any.\n    pub fn get_account<T>(&self, at: &T::AccountId) -> Option<&Account>\n    where\n        T: Environment,\n    {\n        self.accounts.get(&OffAccountId::new(at))\n    }\n\n    /// Returns the account for the given account ID if any.\n    pub fn get_account_mut<T>(&mut self, at: &T::AccountId) -> Option<&mut Account>\n    where\n        T: Environment,\n    {\n        self.accounts.get_mut(&OffAccountId::new(at))\n    }\n\n    /// Returns the account for the given off-account ID if any.\n    pub fn get_account_off<'a>(&'a self, at: &OffAccountId) -> Option<&'a Account> {\n        self.accounts.get(at)\n    }\n\n    /// Returns the account for the given off-account ID if any.\n    pub fn get_account_off_mut(&mut self, at: &OffAccountId) -> Option<&mut Account> {\n        self.accounts.get_mut(at)\n    }\n\n    /// Adds the given user account with the initial balance.\n    pub fn add_user_account<T>(\n        &mut self,\n        account_id: T::AccountId,\n        initial_balance: T::Balance,\n    ) where\n        T: Environment,\n    {\n        self.accounts.insert(\n            OffAccountId::new(&account_id),\n            Account {\n                balance: OffBalance::new(&initial_balance),\n                kind: AccountKind::User,\n            },\n        );\n    }\n\n    /// Creates a new contract account.\n    pub fn add_contract_account<T>(\n        &mut self,\n        account_id: T::AccountId,\n        initial_balance: T::Balance,\n        rent_allowance: T::Balance,\n    ) where\n        T: Environment,\n    {\n        self.accounts.insert(\n            OffAccountId::new(&account_id),\n            Account {\n                balance: OffBalance::new(&initial_balance),\n                kind: AccountKind::Contract(ContractAccount::new::<T>(rent_allowance)),\n            },\n        );\n    }\n\n    /// Removes an account.\n    pub fn remove_account<T>(&mut self, account_id: T::AccountId)\n    where\n        T: Environment,\n    {\n        self.accounts.remove(&OffAccountId::new(&account_id));\n    }\n}\n\n/// An account within the chain.\npub struct Account {\n    /// The balance of the account.\n    balance: OffBalance,\n    /// The kind of the account.\n    kind: AccountKind,\n}\n\nimpl Account {\n    /// Returns the balance of the account.\n    pub fn balance<T>(&self) -> Result<T::Balance>\n    where\n        T: Environment,\n    {\n        self.balance.decode().map_err(Into::into)\n    }\n\n    /// Sets the balance of the account.\n    pub fn set_balance<T>(&mut self, new_balance: T::Balance) -> Result<()>\n    where\n        T: Environment,\n    {\n        self.balance.assign(&new_balance).map_err(Into::into)\n    }\n\n    /// Returns the contract account or an error if it is a user account.\n    fn contract_or_err(&self) -> Result<&ContractAccount> {\n        match &self.kind {\n            AccountKind::User => {\n                Err(AccountError::UnexpectedUserAccount).map_err(Into::into)\n            }\n            AccountKind::Contract(contract_account) => Ok(contract_account),\n        }\n    }\n\n    /// Returns the contract account or an error if it is a user account.\n    fn contract_or_err_mut(&mut self) -> Result<&mut ContractAccount> {\n        match &mut self.kind {\n            AccountKind::User => {\n                Err(AccountError::UnexpectedUserAccount).map_err(Into::into)\n            }\n            AccountKind::Contract(contract_account) => Ok(contract_account),\n        }\n    }\n\n    /// Returns the rent allowance of the contract account or an error.\n    pub fn rent_allowance<T>(&self) -> Result<T::Balance>\n    where\n        T: Environment,\n    {\n        self.contract_or_err()\n            .and_then(|contract| contract.rent_allowance.decode().map_err(Into::into))\n    }\n\n    /// Sets the rent allowance for the contract account or returns an error.\n    pub fn set_rent_allowance<T>(&mut self, new_rent_allowance: T::Balance) -> Result<()>\n    where\n        T: Environment,\n    {\n        self.contract_or_err_mut().and_then(|contract| {\n            contract\n                .rent_allowance\n                .assign(&new_rent_allowance)\n                .map_err(Into::into)\n        })\n    }\n\n    /// Sets the contract storage of key to the new value.\n    pub fn set_storage<T>(&mut self, at: Key, new_value: &T) -> Result<()>\n    where\n        T: scale::Encode,\n    {\n        self.contract_or_err_mut()\n            .map(|contract| contract.storage.set_storage::<T>(at, new_value))\n    }\n\n    /// Clears the contract storage at key.\n    pub fn clear_storage(&mut self, at: Key) -> Result<()> {\n        self.contract_or_err_mut()\n            .map(|contract| contract.storage.clear_storage(at))\n    }\n\n    /// Returns the value stored in the contract storage at the given key.\n    pub fn get_storage<T>(&self, at: Key) -> Result<Option<T>>\n    where\n        T: scale::Decode,\n    {\n        self.contract_or_err()\n            .and_then(|contract| contract.storage.get_storage::<T>(at))\n    }\n\n    /// Returns the total number of reads and write from and to the contract's storage.\n    pub fn get_storage_rw(&self) -> Result<(usize, usize)> {\n        self.contract_or_err().map(|contract| contract.get_rw())\n    }\n\n    /// Returns the amount of used storage entries.\n    pub fn count_used_storage_cells(&self) -> Result<usize> {\n        self.contract_or_err()\n            .map(|contract| contract.count_used_storage_cells())\n    }\n}\n\n/// The kind of the account.\n///\n/// Can be either a user account or a (more complicated) contract account.\npub enum AccountKind {\n    User,\n    Contract(ContractAccount),\n}\n\n/// Extraneous fields for contract accounts.\npub struct ContractAccount {\n    /// The contract's rent allowance.\n    rent_allowance: OffBalance,\n    /// The contract storage.\n    pub storage: ContractStorage,\n}\n\nimpl ContractAccount {\n    /// Creates a new contract account with the given initial rent allowance.\n    pub fn new<T>(rent_allowance: T::Balance) -> Self\n    where\n        T: Environment,\n    {\n        Self {\n            rent_allowance: OffBalance::new(&rent_allowance),\n            storage: ContractStorage::new(),\n        }\n    }\n\n    /// Returns the number of reads and writes from and to the contract storage.\n    pub fn get_rw(&self) -> (usize, usize) {\n        self.storage.get_rw()\n    }\n\n    /// Returns the number of used storage entries.\n    pub fn count_used_storage_cells(&self) -> usize {\n        self.storage.count_used_storage_cells()\n    }\n}\n\n/// The storage of a contract instance.\npub struct ContractStorage {\n    /// The entries within the contract storage.\n    entries: BTreeMap<Key, Vec<u8>>,\n    /// The total number of reads to the storage.\n    count_reads: Cell<usize>,\n    /// The total number of writes to the storage.\n    count_writes: usize,\n}\n\nimpl ContractStorage {\n    /// Creates a new empty contract storage.\n    pub fn new() -> Self {\n        Self {\n            entries: BTreeMap::new(),\n            count_reads: Cell::new(0),\n            count_writes: 0,\n        }\n    }\n\n    /// Returns the number of reads and writes from and to the contract storage.\n    pub fn get_rw(&self) -> (usize, usize) {\n        (self.count_reads.get(), self.count_writes)\n    }\n\n    /// Returns the decoded storage at the key if any.\n    pub fn get_storage<T>(&self, at: Key) -> Result<Option<T>>\n    where\n        T: scale::Decode,\n    {\n        self.count_reads.set(self.count_reads.get() + 1);\n        self.entries\n            .get(&at)\n            .map(|encoded| T::decode(&mut &encoded[..]))\n            .transpose()\n            .map_err(Into::into)\n    }\n\n    /// Writes the encoded value into the contract storage at the given key.\n    pub fn set_storage<T>(&mut self, at: Key, new_value: &T)\n    where\n        T: scale::Encode,\n    {\n        self.count_writes += 1;\n        self.entries.insert(at, new_value.encode());\n    }\n\n    /// Removes the value from storage entries at the given key.\n    pub fn clear_storage(&mut self, at: Key) {\n        self.count_writes += 1;\n        self.entries.remove(&at);\n    }\n\n    /// Returns the number of used storage entries.\n    pub fn count_used_storage_cells(&self) -> usize {\n        self.entries.len()\n    }\n}\n"],["867","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::super::OffHash;\nuse crate::{\n    hash::{\n        Blake2x256,\n        CryptoHash,\n        HashOutput,\n    },\n    topics::{\n        Topics,\n        TopicsBuilderBackend,\n    },\n    Clear,\n    Environment,\n};\n\n#[derive(Default)]\npub struct TopicsBuilder {\n    topics: Vec<OffHash>,\n}\n\nimpl<E> TopicsBuilderBackend<E> for TopicsBuilder\nwhere\n    E: Environment,\n{\n    type Output = Vec<OffHash>;\n\n    fn expect(&mut self, _expected_topics: usize) {}\n\n    fn push_topic<T>(&mut self, topic_value: &T)\n    where\n        T: scale::Encode,\n    {\n        let encoded = topic_value.encode();\n        let len_encoded = encoded.len();\n        let mut result = <E as Environment>::Hash::clear();\n        let len_result = result.as_ref().len();\n        if len_encoded <= len_result {\n            result.as_mut()[..len_encoded].copy_from_slice(&encoded[..]);\n        } else {\n            let mut hash_output = <Blake2x256 as HashOutput>::Type::default();\n            <Blake2x256 as CryptoHash>::hash(&encoded[..], &mut hash_output);\n            let copy_len = core::cmp::min(hash_output.len(), len_result);\n            result.as_mut()[0..copy_len].copy_from_slice(&hash_output[0..copy_len]);\n        }\n        let off_hash = OffHash::new(&result);\n        debug_assert!(\n            !self.topics.contains(&off_hash),\n            \"duplicate topic hash discovered!\"\n        );\n        self.topics.push(off_hash);\n    }\n\n    fn output(self) -> Self::Output {\n        self.topics\n    }\n}\n\n/// Record for an emitted event.\n#[derive(Debug, Clone)]\npub struct EmittedEvent {\n    /// Recorded topics of the emitted event.\n    pub topics: Vec<OffHash>,\n    /// Recorded encoding of the emitted event.\n    pub data: Vec<u8>,\n}\n\nimpl EmittedEvent {\n    /// Creates a new emitted event.\n    pub fn new<T, E>(emitted_event: E) -> Self\n    where\n        T: Environment,\n        E: Topics + scale::Encode,\n    {\n        let topics = emitted_event.topics::<T, _>(TopicsBuilder::default().into());\n        Self {\n            topics,\n            data: emitted_event.encode(),\n        }\n    }\n}\n\n/// Records all emitted events for later inspection.\npub struct EmittedEventsRecorder {\n    emitted_events: Vec<EmittedEvent>,\n}\n\nimpl EmittedEventsRecorder {\n    /// Creates a new empty emitted event recorder.\n    pub fn new() -> Self {\n        Self {\n            emitted_events: Vec::new(),\n        }\n    }\n\n    /// Resets the emitted events to none.\n    pub fn reset(&mut self) {\n        self.emitted_events.clear();\n    }\n\n    /// Records a new emitted event.\n    pub fn record<T, E>(&mut self, new_event: E)\n    where\n        T: Environment,\n        E: Topics + scale::Encode,\n    {\n        self.emitted_events\n            .push(EmittedEvent::new::<T, E>(new_event));\n    }\n\n    /// Returns an iterator over the emitted events in their emission order.\n    pub fn emitted_events(&self) -> core::slice::Iter<EmittedEvent> {\n        self.emitted_events.iter()\n    }\n}\n"],["868","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::{\n    super::Result,\n    OffBalance,\n    OffTimestamp,\n};\nuse crate::Environment;\n\n/// The chain specification.\npub struct ChainSpec {\n    /// The current gas price.\n    gas_price: OffBalance,\n    /// The minimum value an account of the chain may have.\n    minimum_balance: OffBalance,\n    /// The tombstone deposit.\n    tombstone_deposit: OffBalance,\n    /// The targeted block time.\n    block_time: OffTimestamp,\n}\n\nimpl ChainSpec {\n    /// Creates a new uninitialized chain specification.\n    pub fn uninitialized() -> Self {\n        Self {\n            gas_price: OffBalance::uninitialized(),\n            minimum_balance: OffBalance::uninitialized(),\n            tombstone_deposit: OffBalance::uninitialized(),\n            block_time: OffTimestamp::uninitialized(),\n        }\n    }\n\n    /// Resets the chain spec to uninitialized state.\n    pub fn reset(&mut self) {\n        self.gas_price = OffBalance::uninitialized();\n        self.minimum_balance = OffBalance::uninitialized();\n        self.tombstone_deposit = OffBalance::uninitialized();\n        self.block_time = OffTimestamp::uninitialized();\n    }\n\n    /// Default initialization for the off-chain specification.\n    pub fn initialize_as_default<T>(&mut self) -> crate::Result<()>\n    where\n        T: Environment,\n        <T as Environment>::AccountId: From<[u8; 32]>,\n    {\n        self.gas_price\n            .try_initialize::<T::Balance>(&T::Balance::from(100u32))?;\n        self.minimum_balance\n            .try_initialize::<T::Balance>(&T::Balance::from(42u32))?;\n        self.tombstone_deposit\n            .try_initialize::<T::Balance>(&T::Balance::from(16u32))?;\n        self.block_time\n            .try_initialize::<T::Timestamp>(&T::Timestamp::from(5u32))?;\n        Ok(())\n    }\n\n    /// Returns the gas price for the chain.\n    pub fn gas_price<T>(&self) -> Result<T::Balance>\n    where\n        T: Environment,\n    {\n        self.gas_price.decode().map_err(Into::into)\n    }\n\n    /// Set the gas price for the chain.\n    pub fn set_gas_price<T>(&mut self, gas_price: T::Balance)\n    where\n        T: Environment,\n    {\n        self.gas_price = OffBalance::new(&gas_price)\n    }\n\n    /// Returns the minimum balance that is required for creating an account.\n    pub fn minimum_balance<T>(&self) -> Result<T::Balance>\n    where\n        T: Environment,\n    {\n        self.minimum_balance.decode().map_err(Into::into)\n    }\n\n    /// Returns the tombstone deposit for the chain.\n    pub fn tombstone_deposit<T>(&self) -> Result<T::Balance>\n    where\n        T: Environment,\n    {\n        self.tombstone_deposit.decode().map_err(Into::into)\n    }\n\n    /// Returns the targeted block time for the chain.\n    pub fn block_time<T>(&self) -> Result<T::Timestamp>\n    where\n        T: Environment,\n    {\n        self.block_time.decode().map_err(Into::into)\n    }\n}\n"],["869","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::OffChainError;\nuse crate::Error;\nuse core::{\n    any::TypeId,\n    cmp::Ordering,\n    hash::{\n        Hash,\n        Hasher,\n    },\n    marker::PhantomData,\n};\nuse derive_more::From;\n\n/// A wrapper around an encoded entity that only allows type safe accesses.\n///\n/// # Note\n///\n/// Checks are implemented at runtime.\n#[derive(Debug, Clone)]\npub struct TypedEncoded<T> {\n    /// The bytes of the encoded representation of the type.\n    encoded: Vec<u8>,\n    /// The unique identifier of the encoded type.\n    ///\n    /// # Note\n    ///\n    /// - If this is `None` it means that the instance is currently untyped\n    /// and will take over any given type upon the first typed interaction.\n    /// - This is needed since instances of `TypedEncoded` are going to be used\n    /// in static memory where it isn't possible to decide about the used types\n    /// given by `Environment` at initialization.\n    type_id: Option<TypeId>,\n    /// Classification marker.\n    ///\n    /// # Note\n    ///\n    /// - This shouldn't be the typed that is actually stored as encoded\n    ///   representation in `self.encoded` but should primarily be an\n    ///   abstract marker type that may be used for classification.\n    /// - The idea behind the marker is to say that whenever two instances\n    ///   of `TypedEncoded` share a marker they are guaranteed to also have\n    ///   a common (but unknown) `type_id` so they can decode to the same\n    ///   original type and thus we can allow to interoperate on them.\n    ///\n    /// # Example\n    ///\n    /// The `TestEnv` might use one abstract marker for every\n    /// of the fundamental FRAME types: `Balance`, `AccountId`, `Hash`, etc.\n    /// With this and the explicit guarantee that two instances of `TypedEncoded`\n    /// with the same abstract marker also share the same (unknown) `type_id`\n    /// it is possible to allow them to interoperate.\n    marker: PhantomData<fn() -> T>,\n}\n\n/// Errors that may be encountered upon operating on typed encoded instances.\n#[derive(Debug, From, PartialEq, Eq)]\npub enum TypedEncodedError {\n    /// Error upon decoding.\n    Decode(scale::Error),\n    /// When operating on instances with different types.\n    #[from(ignore)]\n    DifferentTypes {\n        lhs: core::any::TypeId,\n        rhs: core::any::TypeId,\n    },\n    /// When an already initialized instance is about to be initialized.\n    #[from(ignore)]\n    AlreadyInitialized {\n        initialized_id: core::any::TypeId,\n        new_id: core::any::TypeId,\n    },\n    /// When operating on still uninitialized types.\n    #[from(ignore)]\n    StillUninitialized,\n}\n\nimpl From<TypedEncodedError> for Error {\n    fn from(typed_encoded_error: TypedEncodedError) -> Self {\n        Error::OffChain(OffChainError::TypedEncoded(typed_encoded_error))\n    }\n}\n\n/// The result type for typed encoded operations.\npub type Result<T> = core::result::Result<T, TypedEncodedError>;\n\nimpl<M> Default for TypedEncoded<M> {\n    /// Creates an uninitialized instance.\n    ///\n    /// # Note\n    ///\n    /// The resulting instance can be properly initialized at a later point\n    /// using a call to [`TypedEncoded::try_initialize`].\n    fn default() -> Self {\n        Self {\n            encoded: Vec::new(),\n            type_id: None,\n            marker: Default::default(),\n        }\n    }\n}\n\nimpl<M> TypedEncoded<M> {\n    /// Creates a new uninitialized instance.\n    pub fn uninitialized() -> Self {\n        Self {\n            encoded: Vec::new(),\n            type_id: None,\n            marker: Default::default(),\n        }\n    }\n\n    /// Creates a new typed-encoded initialized by `value` of type `T`.\n    pub fn new<T>(value: &T) -> Self\n    where\n        T: scale::Encode + 'static,\n    {\n        Self {\n            encoded: value.encode(),\n            type_id: Some(core::any::TypeId::of::<T>()),\n            marker: Default::default(),\n        }\n    }\n\n    /// Initializes `self` with a given encodable value.\n    ///\n    /// # Errors\n    ///\n    /// If `self` has already been initialized or is an initialized instance.\n    pub fn try_initialize<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: scale::Encode + 'static,\n    {\n        if let Some(id) = self.type_id {\n            return Err(TypedEncodedError::AlreadyInitialized {\n                initialized_id: id,\n                new_id: core::any::TypeId::of::<T>(),\n            })\n        }\n        value.encode_to(&mut self.encoded);\n        self.type_id = Some(core::any::TypeId::of::<T>());\n        Ok(())\n    }\n\n    /// Returns the encoded bytes representation.\n    ///\n    /// # Errors\n    ///\n    /// If the instance is still uninitialized.\n    pub fn encoded_bytes(&self) -> Result<&[u8]> {\n        if self.type_id.is_none() {\n            return Err(TypedEncodedError::StillUninitialized)\n        }\n        Ok(&self.encoded[..])\n    }\n\n    /// Returns a mutable reference to the encoded bytes representation.\n    ///\n    /// # Errors\n    ///\n    /// If the instance is still uninitialized.\n    pub fn encoded_bytes_mut(&mut self) -> Result<&mut [u8]> {\n        if self.type_id.is_none() {\n            return Err(TypedEncodedError::StillUninitialized)\n        }\n        Ok(&mut self.encoded[..])\n    }\n\n    /// Returns the type ID if the instance has already been initialized.\n    ///\n    /// # Errors\n    ///\n    /// Returns an appropriate error in case the instance is uninitialized.\n    fn type_id(&self) -> Result<core::any::TypeId> {\n        match self.type_id {\n            Some(type_id) => Ok(type_id),\n            None => Err(TypedEncodedError::StillUninitialized),\n        }\n    }\n\n    /// Returns `Ok` if both types are encoded with the same type.\n    fn check_matching_types(&self, other: &Self) -> Result<()> {\n        let id_lhs = self.type_id()?;\n        let id_rhs = other.type_id()?;\n        if id_lhs != id_rhs {\n            return Err(TypedEncodedError::DifferentTypes {\n                lhs: id_lhs,\n                rhs: id_rhs,\n            })\n        }\n        Ok(())\n    }\n\n    /// Returns `Ok` if `T` is the type represented by the typed encoded instance.\n    fn check_enforced_type<T>(&self) -> Result<()>\n    where\n        T: 'static,\n    {\n        let id_self = self.type_id()?;\n        let id_enforced = core::any::TypeId::of::<T>();\n        if core::any::TypeId::of::<T>() != id_self {\n            return Err(TypedEncodedError::DifferentTypes {\n                lhs: id_self,\n                rhs: id_enforced,\n            })\n        }\n        Ok(())\n    }\n\n    /// Decodes the instance.\n    ///\n    /// # Note\n    ///\n    /// This effectively creates a clone of the encoded value.\n    pub fn decode<T>(&self) -> Result<T>\n    where\n        T: scale::Decode + 'static,\n    {\n        self.check_enforced_type::<T>()?;\n        <T as scale::Decode>::decode(&mut &self.encoded[..]).map_err(Into::into)\n    }\n\n    /// Assigns the given `T` to `self`.\n    pub fn assign<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: scale::Encode + 'static,\n    {\n        self.check_enforced_type::<T>()?;\n        self.encoded.clear();\n        value.encode_to(&mut self.encoded);\n        self.type_id = Some(core::any::TypeId::of::<T>());\n        Ok(())\n    }\n\n    /// Evaluates the given clousure on the given typed encoded instances.\n    pub fn eval<T, F, R>(&self, other: &Self, f: F) -> Result<R>\n    where\n        T: scale::Decode + 'static,\n        F: FnOnce(&T, &T) -> R,\n    {\n        Self::check_matching_types(self, other)?;\n        let decoded_self = self.decode::<T>()?;\n        let decoded_other = other.decode::<T>()?;\n        Ok(f(&decoded_self, &decoded_other))\n    }\n\n    /// Evaluates the given clousure on the given typed decoded instances\n    /// and writes back the result into the typed encoded instance.\n    pub fn eval_mut<T, F, R>(&mut self, other: &Self, f: F) -> Result<R>\n    where\n        T: scale::Decode + scale::Encode + 'static,\n        F: FnOnce(&mut T, &T) -> R,\n    {\n        Self::check_matching_types(self, other)?;\n        let mut decoded_self = self.decode::<T>()?;\n        let decoded_other = other.decode::<T>()?;\n        let result = f(&mut decoded_self, &decoded_other);\n        self.encoded.clear();\n        scale::Encode::encode_to(&decoded_self, &mut self.encoded);\n        Ok(result)\n    }\n\n    /// Returns `true` if both instances are of type `T` and are equal.\n    ///\n    /// # Note\n    ///\n    /// The equality check is performed on decoded instances.\n    pub fn eq<T>(&self, other: &Self) -> Result<bool>\n    where\n        T: PartialEq + scale::Decode + 'static,\n    {\n        self.eval::<T, _, _>(other, |lhs, rhs| core::cmp::PartialEq::eq(lhs, rhs))\n    }\n\n    /// Returns order relation if both instances are of type `T`.\n    ///\n    /// # Note\n    ///\n    /// The order relation is performed on the decoded instances.\n    pub fn cmp<T>(&self, other: &Self) -> Result<Ordering>\n    where\n        T: PartialOrd + Ord + scale::Decode + 'static,\n    {\n        self.eval::<T, _, _>(other, |lhs, rhs| core::cmp::Ord::cmp(lhs, rhs))\n    }\n\n    /// Computes the hash of the decoded typed instance if types match.\n    pub fn hash<T, H>(&self, state: &mut H) -> Result<()>\n    where\n        T: scale::Decode + Hash + 'static,\n        H: Hasher,\n    {\n        self.decode::<T>()?.hash(state);\n        Ok(())\n    }\n}\n\nimpl<T> PartialEq for TypedEncoded<T> {\n    fn eq(&self, other: &Self) -> bool {\n        self.type_id == other.type_id && self.encoded == other.encoded\n    }\n}\n\nimpl<T> Eq for TypedEncoded<T> {}\n\nimpl<T> PartialOrd for TypedEncoded<T> {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(Ord::cmp(self, other))\n    }\n}\n\nimpl<T> Ord for TypedEncoded<T> {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.encoded.cmp(&other.encoded)\n    }\n}\n"],["870","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Implementations of supported cryptographic hash functions.\n\n/// Helper routine implementing variable size BLAKE2b hash computation.\nfn blake2b_var(size: usize, input: &[u8], output: &mut [u8]) {\n    use ::blake2::digest::{\n        Update as _,\n        VariableOutput as _,\n    };\n    let mut blake2 = blake2::VarBlake2b::new_keyed(&[], size);\n    blake2.update(input);\n    blake2.finalize_variable(|result| output.copy_from_slice(result));\n}\n\n/// Conduct the BLAKE2 256-bit hash and place the result into `output`.\npub fn blake2b_256(input: &[u8], output: &mut [u8; 32]) {\n    blake2b_var(32, input, output)\n}\n\n/// Conduct the BLAKE2 128-bit hash and place the result into `output`.\npub fn blake2b_128(input: &[u8], output: &mut [u8; 16]) {\n    blake2b_var(16, input, output)\n}\n\n/// Conduct the KECCAK 256-bit hash and place the result into `output`.\npub fn keccak_256(input: &[u8], output: &mut [u8; 32]) {\n    use ::sha3::{\n        digest::{\n            generic_array::GenericArray,\n            FixedOutput as _,\n        },\n        Digest as _,\n    };\n    let mut hasher = ::sha3::Keccak256::new();\n    hasher.update(input);\n    hasher.finalize_into(<&mut GenericArray<u8, _>>::from(&mut output[..]));\n}\n\n/// Conduct the SHA2 256-bit hash and place the result into `output`.\npub fn sha2_256(input: &[u8], output: &mut [u8; 32]) {\n    use ::sha2::{\n        digest::{\n            generic_array::GenericArray,\n            FixedOutput as _,\n        },\n        Digest as _,\n    };\n    let mut hasher = ::sha2::Sha256::new();\n    hasher.update(input);\n    hasher.finalize_into(<&mut GenericArray<u8, _>>::from(&mut output[..]));\n}\n"],["871","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Emulated environmental types of the test environment.\n//!\n//! Due to technical constraints it is not possible to define the test\n//! environment instance thread-locally and generically over the actual\n//! environmental types.\n//!\n//! For that reason we store the type information of all the environmental\n//! types at runtime to at least have some kind of type safety upon access.\n//! This is done via the `TypedEncoded` abstraction that stores the\n//! SCALE encoded bytes and also has a runtime type information marker\n//! assigned upon initialization to check whether accesses to it are\n//! type safe.\n\nuse super::TypedEncoded;\n\n/// Type markers used in conjunction with `TypedEncoded`.\n#[rustfmt::skip]\nmod type_marker {\n    /// Type marker representing an environmental `AccountId`.\n    #[derive(Debug, Clone)] pub enum AccountId {}\n    /// Type marker representing an environmental `Balance`.\n    #[derive(Debug, Clone)] pub enum Balance {}\n    /// Type marker representing an environmental `Hash`.\n    #[derive(Debug, Clone)] pub enum Hash {}\n    /// Type marker representing an environmental `Timestamp`.\n    #[derive(Debug, Clone)] pub enum OffTimestamp {}\n    /// Type marker representing an environmental `BlockNumber`.\n    #[derive(Debug, Clone)] pub enum BlockNumber {}\n}\n\n/// Off-chain environment account ID type.\npub type OffAccountId = TypedEncoded<type_marker::AccountId>;\n/// Off-chain environment balance type.\npub type OffBalance = TypedEncoded<type_marker::Balance>;\n/// Off-chain environment hash type.\npub type OffHash = TypedEncoded<type_marker::Hash>;\n/// Off-chain environment timestamp type.\npub type OffTimestamp = TypedEncoded<type_marker::OffTimestamp>;\n/// Off-chain environment block number type.\npub type OffBlockNumber = TypedEncoded<type_marker::BlockNumber>;\n"],["872","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::Result;\nuse ink_primitives::Key;\n\n#[test]\nfn store_load_clear() -> Result<()> {\n    crate::test::run_test::<crate::DefaultEnvironment, _>(|_| {\n        let key = Key::from([0x42; 32]);\n        assert_eq!(crate::get_contract_storage::<()>(&key), Ok(None));\n        crate::set_contract_storage(&key, &[0x05_u8; 5]);\n        assert_eq!(\n            crate::get_contract_storage::<[i8; 5]>(&key),\n            Ok(Some([0x05; 5])),\n        );\n        crate::clear_contract_storage(&key);\n        assert_eq!(crate::get_contract_storage::<[u8; 5]>(&key), Ok(None));\n        Ok(())\n    })\n}\n\n#[test]\nfn key_add() -> Result<()> {\n    crate::test::run_test::<crate::DefaultEnvironment, _>(|_| {\n        let key00 = Key::from([0x0; 32]);\n        let key05 = key00 + 05_u64; // -> 5\n        let key10 = key00 + 10_u64; // -> 10         | same as key55\n        let key55 = key05 + 05_u64; // -> 5 + 5 = 10 | same as key10\n        crate::set_contract_storage(&key55, &42);\n        assert_eq!(crate::get_contract_storage::<i32>(&key10), Ok(Some(42)));\n        crate::set_contract_storage(&key10, &1337);\n        assert_eq!(crate::get_contract_storage::<i32>(&key55), Ok(Some(1337)));\n        Ok(())\n    })\n}\n\n#[test]\nfn key_add_sub() -> Result<()> {\n    crate::test::run_test::<crate::DefaultEnvironment, _>(|_| {\n        // given\n        let key0a = Key::from([0x0; 32]);\n        let key1a = key0a + 1337_u64;\n        let key2a = key0a + 42_u64;\n        let key3a = key0a + 52_u64;\n\n        // when\n        crate::set_contract_storage(&key0a, &1);\n        crate::set_contract_storage(&key1a, &2);\n        crate::set_contract_storage(&key2a, &3);\n        crate::set_contract_storage(&key3a, &4);\n\n        // then\n        assert_eq!(crate::get_contract_storage::<i32>(&key0a), Ok(Some(1)));\n        assert_eq!(crate::get_contract_storage::<i32>(&key1a), Ok(Some(2)));\n        assert_eq!(crate::get_contract_storage::<i32>(&key2a), Ok(Some(3)));\n        assert_eq!(crate::get_contract_storage::<i32>(&key3a), Ok(Some(4)));\n        Ok(())\n    })\n}\n\n#[test]\nfn gas_price() -> crate::Result<()> {\n    crate::test::run_test::<crate::DefaultEnvironment, _>(|_| {\n        let gas_price = 2u32;\n        crate::test::update_chain_spec(|chain_spec| {\n            chain_spec.set_gas_price::<crate::DefaultEnvironment>(gas_price.into())\n        })?;\n\n        assert_eq!(\n            2u128,\n            crate::weight_to_fee::<crate::DefaultEnvironment>(1).unwrap()\n        );\n        assert_eq!(\n            20u128,\n            crate::weight_to_fee::<crate::DefaultEnvironment>(10).unwrap()\n        );\n        assert_eq!(\n            6u128,\n            crate::weight_to_fee::<crate::DefaultEnvironment>(3).unwrap()\n        );\n\n        Ok(())\n    })\n}\n"],["873","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::call::Selector;\nuse ink_prelude::{\n    vec,\n    vec::Vec,\n};\n\n/// The raw ABI respecting input data to a call.\n///\n/// # Note\n///\n/// The first four bytes are the function selector and the rest are SCALE encoded inputs.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct CallData {\n    /// Already encoded function selector and inputs.\n    ///\n    /// # Note\n    ///\n    /// Has the invariant of always holding at least 4 bytes (the selector).\n    bytes: Vec<u8>,\n}\n\nimpl CallData {\n    /// Creates new call ABI data for the given selector.\n    pub fn new(selector: Selector) -> Self {\n        let bytes = selector.to_bytes();\n        Self {\n            bytes: vec![bytes[0], bytes[1], bytes[2], bytes[3]],\n        }\n    }\n\n    /// Pushes the given argument onto the call ABI data in encoded form.\n    pub fn push_arg<A>(&mut self, arg: &A)\n    where\n        A: scale::Encode,\n    {\n        arg.encode_to(&mut self.bytes)\n    }\n\n    /// Returns the selector of `self`.\n    pub fn selector(&self) -> Selector {\n        debug_assert!(self.bytes.len() >= 4);\n        let bytes = [self.bytes[0], self.bytes[1], self.bytes[2], self.bytes[3]];\n        bytes.into()\n    }\n\n    /// Returns the underlying bytes of the encoded input parameters.\n    pub fn params(&self) -> &[u8] {\n        debug_assert!(self.bytes.len() >= 4);\n        &self.bytes[4..]\n    }\n\n    /// Returns the underlying byte representation.\n    pub fn to_bytes(&self) -> &[u8] {\n        &self.bytes\n    }\n}\n\nimpl scale::Encode for CallData {\n    fn size_hint(&self) -> usize {\n        self.bytes.len()\n    }\n\n    fn encode_to<T: scale::Output + ?Sized>(&self, dest: &mut T) {\n        dest.write(self.bytes.as_slice());\n    }\n}\n\nimpl scale::Decode for CallData {\n    fn decode<I: scale::Input>(\n        input: &mut I,\n    ) -> core::result::Result<Self, scale::Error> {\n        let remaining_len = input.remaining_len().unwrap_or(None).unwrap_or(0);\n        let mut bytes = Vec::with_capacity(remaining_len);\n        while let Ok(byte) = input.read_byte() {\n            bytes.push(byte);\n        }\n        if bytes.len() < 4 {\n            return Err(scale::Error::from(\n                \"require at least 4 bytes for input data\",\n            ))\n        }\n        Ok(Self { bytes })\n    }\n}\n"],["874","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::{\n    hashing,\n    Account,\n    EnvInstance,\n};\nuse crate::{\n    call::{\n        utils::ReturnType,\n        CallParams,\n        CreateParams,\n    },\n    hash::{\n        Blake2x128,\n        Blake2x256,\n        CryptoHash,\n        HashOutput,\n        Keccak256,\n        Sha2x256,\n    },\n    topics::Topics,\n    EnvBackend,\n    Environment,\n    Error,\n    Result,\n    ReturnFlags,\n    TypedEnvBackend,\n};\nuse core::convert::TryInto;\nuse ink_primitives::Key;\nuse num_traits::Bounded;\n\nconst UNITIALIZED_EXEC_CONTEXT: &str = \"unitialized execution context: \\\na possible source of error could be that you are using `#[test]` instead of `#[ink::test]`.\";\n\nimpl EnvInstance {\n    /// Returns the callee account.\n    fn callee_account(&self) -> &Account {\n        let callee = self\n            .exec_context()\n            .expect(UNITIALIZED_EXEC_CONTEXT)\n            .callee\n            .clone();\n        self.accounts\n            .get_account_off(&callee)\n            .expect(\"callee account does not exist\")\n    }\n\n    /// Returns the callee account as mutable reference.\n    fn callee_account_mut(&mut self) -> &mut Account {\n        let callee = self\n            .exec_context()\n            .expect(UNITIALIZED_EXEC_CONTEXT)\n            .callee\n            .clone();\n        self.accounts\n            .get_account_off_mut(&callee)\n            .expect(\"callee account does not exist\")\n    }\n}\n\nimpl CryptoHash for Blake2x128 {\n    fn hash(input: &[u8], output: &mut <Self as HashOutput>::Type) {\n        type OutputType = [u8; 16];\n        static_assertions::assert_type_eq_all!(\n            <Blake2x128 as HashOutput>::Type,\n            OutputType\n        );\n        let output: &mut OutputType = arrayref::array_mut_ref!(output, 0, 16);\n        hashing::blake2b_128(input, output);\n    }\n}\n\nimpl CryptoHash for Blake2x256 {\n    fn hash(input: &[u8], output: &mut <Self as HashOutput>::Type) {\n        type OutputType = [u8; 32];\n        static_assertions::assert_type_eq_all!(\n            <Blake2x256 as HashOutput>::Type,\n            OutputType\n        );\n        let output: &mut OutputType = arrayref::array_mut_ref!(output, 0, 32);\n        hashing::blake2b_256(input, output);\n    }\n}\n\nimpl CryptoHash for Sha2x256 {\n    fn hash(input: &[u8], output: &mut <Self as HashOutput>::Type) {\n        type OutputType = [u8; 32];\n        static_assertions::assert_type_eq_all!(\n            <Sha2x256 as HashOutput>::Type,\n            OutputType\n        );\n        let output: &mut OutputType = arrayref::array_mut_ref!(output, 0, 32);\n        hashing::sha2_256(input, output);\n    }\n}\n\nimpl CryptoHash for Keccak256 {\n    fn hash(input: &[u8], output: &mut <Self as HashOutput>::Type) {\n        type OutputType = [u8; 32];\n        static_assertions::assert_type_eq_all!(\n            <Keccak256 as HashOutput>::Type,\n            OutputType\n        );\n        let output: &mut OutputType = arrayref::array_mut_ref!(output, 0, 32);\n        hashing::keccak_256(input, output);\n    }\n}\n\nimpl EnvBackend for EnvInstance {\n    fn set_contract_storage<V>(&mut self, key: &Key, value: &V)\n    where\n        V: scale::Encode,\n    {\n        self.callee_account_mut()\n            .set_storage(*key, value)\n            .expect(\"callee account is not a smart contract\");\n    }\n\n    fn get_contract_storage<R>(&mut self, key: &Key) -> Result<Option<R>>\n    where\n        R: scale::Decode,\n    {\n        self.callee_account()\n            .get_storage::<R>(*key)\n            .map_err(Into::into)\n    }\n\n    fn clear_contract_storage(&mut self, key: &Key) {\n        if !self.clear_storage_disabled {\n            self.callee_account_mut()\n                .clear_storage(*key)\n                .expect(\"callee account is not a smart contract\");\n        }\n    }\n\n    fn decode_input<T>(&mut self) -> Result<T>\n    where\n        T: scale::Decode,\n    {\n        self.exec_context()\n            .map(|exec_ctx| &exec_ctx.call_data)\n            .map(|call_data| scale::Encode::encode(call_data))\n            .map_err(Into::into)\n            .and_then(|encoded| {\n                <T as scale::Decode>::decode(&mut &encoded[..])\n                    .map_err(|_| scale::Error::from(\"could not decode input call data\"))\n                    .map_err(Into::into)\n            })\n    }\n\n    fn return_value<R>(&mut self, flags: ReturnFlags, return_value: &R) -> !\n    where\n        R: scale::Encode,\n    {\n        let ctx = self.exec_context_mut().expect(UNITIALIZED_EXEC_CONTEXT);\n        ctx.output = Some(return_value.encode());\n        std::process::exit(flags.into_u32() as i32)\n    }\n\n    fn println(&mut self, content: &str) {\n        self.console.println(content)\n    }\n\n    fn hash_bytes<H>(&mut self, input: &[u8], output: &mut <H as HashOutput>::Type)\n    where\n        H: CryptoHash,\n    {\n        <H as CryptoHash>::hash(input, output)\n    }\n\n    fn hash_encoded<H, T>(&mut self, input: &T, output: &mut <H as HashOutput>::Type)\n    where\n        H: CryptoHash,\n        T: scale::Encode,\n    {\n        let encoded = input.encode();\n        self.hash_bytes::<H>(&encoded[..], output)\n    }\n\n    fn call_chain_extension<I, T, E, ErrorCode, F, D>(\n        &mut self,\n        func_id: u32,\n        input: &I,\n        status_to_result: F,\n        decode_to_result: D,\n    ) -> ::core::result::Result<T, E>\n    where\n        I: scale::Encode,\n        T: scale::Decode,\n        E: From<ErrorCode>,\n        F: FnOnce(u32) -> ::core::result::Result<(), ErrorCode>,\n        D: FnOnce(&[u8]) -> ::core::result::Result<T, E>,\n    {\n        let encoded_input = input.encode();\n        let (status_code, mut output) = self\n            .chain_extension_handler\n            .eval(func_id, &encoded_input)\n            .expect(\"encountered unexpected missing chain extension method\");\n        status_to_result(status_code)?;\n        let decoded = decode_to_result(&mut output)?;\n        Ok(decoded)\n    }\n}\n\nimpl EnvInstance {\n    fn transfer_impl<T>(\n        &mut self,\n        destination: &T::AccountId,\n        value: T::Balance,\n    ) -> Result<()>\n    where\n        T: Environment,\n    {\n        let src_id = self.account_id::<T>()?;\n        let src_value = self\n            .accounts\n            .get_account::<T>(&src_id)\n            .expect(\"account of executed contract must exist\")\n            .balance::<T>()?;\n        if src_value < value {\n            return Err(Error::TransferFailed)\n        }\n        let dst_value = self\n            .accounts\n            .get_or_create_account::<T>(destination)\n            .balance::<T>()?;\n        self.accounts\n            .get_account_mut::<T>(&src_id)\n            .expect(\"account of executed contract must exist\")\n            .set_balance::<T>(src_value - value)?;\n        self.accounts\n            .get_account_mut::<T>(destination)\n            .expect(\"the account must exist already or has just been created\")\n            .set_balance::<T>(dst_value + value)?;\n        Ok(())\n    }\n\n    // Remove the calling account and transfer remaining balance.\n    //\n    // This function never returns. Either the termination was successful and the\n    // execution of the destroyed contract is halted. Or it failed during the termination\n    // which is considered fatal.\n    fn terminate_contract_impl<T>(&mut self, beneficiary: T::AccountId) -> !\n    where\n        T: Environment,\n    {\n        // Send the remaining balance to the beneficiary\n        let all: T::Balance = self.balance::<T>().expect(\"could not decode balance\");\n        self.transfer_impl::<T>(&beneficiary, all)\n            .expect(\"transfer did not work \");\n\n        // Remove account\n        let contract_id = self.account_id::<T>().expect(\"could not decode account id\");\n        self.accounts.remove_account::<T>(contract_id);\n\n        // The on-chain implementation would set a tombstone with a code hash here\n        // and remove the contract storage subsequently. Both is not easily achievable\n        // with our current off-chain env, hence we left it out here for the moment.\n\n        // Encode the result of the termination and panic with it.\n        // This enables testing for the proper result and makes sure this\n        // method returns `Never`.\n        let res = crate::test::ContractTerminationResult::<T> {\n            beneficiary,\n            transferred: all,\n        };\n        panic!(\"{:?}\", scale::Encode::encode(&res));\n    }\n}\n\nimpl TypedEnvBackend for EnvInstance {\n    fn caller<T: Environment>(&mut self) -> Result<T::AccountId> {\n        self.exec_context()\n            .expect(UNITIALIZED_EXEC_CONTEXT)\n            .caller::<T>()\n            .map_err(|_| scale::Error::from(\"could not decode caller\"))\n            .map_err(Into::into)\n    }\n\n    fn transferred_balance<T: Environment>(&mut self) -> Result<T::Balance> {\n        self.exec_context()\n            .expect(UNITIALIZED_EXEC_CONTEXT)\n            .transferred_value::<T>()\n            .map_err(|_| scale::Error::from(\"could not decode transferred balance\"))\n            .map_err(Into::into)\n    }\n\n    /// Emulates gas price calculation\n    fn weight_to_fee<T: Environment>(&mut self, gas: u64) -> Result<T::Balance> {\n        use crate::arithmetic::Saturating as _;\n\n        let gas_price = self\n            .chain_spec\n            .gas_price::<T>()\n            .map_err(|_| scale::Error::from(\"could not decode gas price\"))?;\n\n        Ok(gas_price\n            .saturating_mul(gas.try_into().unwrap_or_else(|_| Bounded::max_value())))\n    }\n\n    fn gas_left<T: Environment>(&mut self) -> Result<T::Balance> {\n        self.exec_context()\n            .expect(UNITIALIZED_EXEC_CONTEXT)\n            .gas::<T>()\n            .map_err(|_| scale::Error::from(\"could not decode gas left\"))\n            .map_err(Into::into)\n    }\n\n    fn block_timestamp<T: Environment>(&mut self) -> Result<T::Timestamp> {\n        self.current_block()\n            .expect(UNITIALIZED_EXEC_CONTEXT)\n            .timestamp::<T>()\n            .map_err(|_| scale::Error::from(\"could not decode block time\"))\n            .map_err(Into::into)\n    }\n\n    fn account_id<T: Environment>(&mut self) -> Result<T::AccountId> {\n        self.exec_context()\n            .expect(UNITIALIZED_EXEC_CONTEXT)\n            .callee::<T>()\n            .map_err(|_| scale::Error::from(\"could not decode callee\"))\n            .map_err(Into::into)\n    }\n\n    fn balance<T: Environment>(&mut self) -> Result<T::Balance> {\n        self.callee_account()\n            .balance::<T>()\n            .map_err(|_| scale::Error::from(\"could not decode callee balance\"))\n            .map_err(Into::into)\n    }\n\n    fn rent_allowance<T: Environment>(&mut self) -> Result<T::Balance> {\n        self.callee_account()\n            .rent_allowance::<T>()\n            .map_err(|_| scale::Error::from(\"could not decode callee rent allowance\"))\n            .map_err(Into::into)\n    }\n\n    fn block_number<T: Environment>(&mut self) -> Result<T::BlockNumber> {\n        self.current_block()\n            .expect(UNITIALIZED_EXEC_CONTEXT)\n            .number::<T>()\n            .map_err(|_| scale::Error::from(\"could not decode block number\"))\n            .map_err(Into::into)\n    }\n\n    fn minimum_balance<T: Environment>(&mut self) -> Result<T::Balance> {\n        self.chain_spec\n            .minimum_balance::<T>()\n            .map_err(|_| scale::Error::from(\"could not decode minimum balance\"))\n            .map_err(Into::into)\n    }\n\n    fn tombstone_deposit<T: Environment>(&mut self) -> Result<T::Balance> {\n        self.chain_spec\n            .tombstone_deposit::<T>()\n            .map_err(|_| scale::Error::from(\"could not decode tombstone deposit\"))\n            .map_err(Into::into)\n    }\n\n    fn emit_event<T, Event>(&mut self, new_event: Event)\n    where\n        T: Environment,\n        Event: Topics + scale::Encode,\n    {\n        self.emitted_events.record::<T, Event>(new_event)\n    }\n\n    fn set_rent_allowance<T>(&mut self, new_rent_allowance: T::Balance)\n    where\n        T: Environment,\n    {\n        self.callee_account_mut()\n            .set_rent_allowance::<T>(new_rent_allowance)\n            .expect(\"could not encode rent allowance\")\n    }\n\n    fn invoke_contract<T, Args>(\n        &mut self,\n        _call_params: &CallParams<T, Args, ()>,\n    ) -> Result<()>\n    where\n        T: Environment,\n        Args: scale::Encode,\n    {\n        unimplemented!(\"off-chain environment does not support contract invocation\")\n    }\n\n    fn eval_contract<T, Args, R>(\n        &mut self,\n        _call_params: &CallParams<T, Args, ReturnType<R>>,\n    ) -> Result<R>\n    where\n        T: Environment,\n        Args: scale::Encode,\n        R: scale::Decode,\n    {\n        unimplemented!(\"off-chain environment does not support contract evaluation\")\n    }\n\n    fn instantiate_contract<T, Args, Salt, C>(\n        &mut self,\n        _params: &CreateParams<T, Args, Salt, C>,\n    ) -> Result<T::AccountId>\n    where\n        T: Environment,\n        Args: scale::Encode,\n    {\n        unimplemented!(\"off-chain environment does not support contract instantiation\")\n    }\n\n    fn terminate_contract<T>(&mut self, beneficiary: T::AccountId) -> !\n    where\n        T: Environment,\n    {\n        self.terminate_contract_impl::<T>(beneficiary)\n    }\n\n    fn restore_contract<T>(\n        &mut self,\n        _account_id: T::AccountId,\n        _code_hash: T::Hash,\n        _rent_allowance: T::Balance,\n        _filtered_keys: &[Key],\n    ) where\n        T: Environment,\n    {\n        unimplemented!(\"off-chain environment does not support contract restoration\")\n    }\n\n    fn transfer<T>(&mut self, destination: T::AccountId, value: T::Balance) -> Result<()>\n    where\n        T: Environment,\n    {\n        self.transfer_impl::<T>(&destination, value)\n    }\n\n    fn random<T>(&mut self, subject: &[u8]) -> Result<T::Hash>\n    where\n        T: Environment,\n    {\n        self.current_block()\n            .expect(UNITIALIZED_EXEC_CONTEXT)\n            .random::<T>(subject)\n            .map_err(Into::into)\n    }\n}\n"],["875","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::OffChainError;\nuse crate::Result;\nuse derive_more::From;\nuse std::collections::{\n    hash_map::Entry,\n    HashMap,\n};\n\n/// Chain extension registry.\n///\n/// Allows to register chain extension methods and call them.\npub struct ChainExtensionHandler {\n    /// The currently registered runtime call handler.\n    registered: HashMap<ExtensionId, Box<dyn ChainExtension>>,\n    /// The output buffer used and reused for chain extension method call results.\n    output: Vec<u8>,\n}\n\n/// The unique ID of the registered chain extension method.\n#[derive(\n    Debug, From, scale::Encode, scale::Decode, PartialEq, Eq, PartialOrd, Ord, Hash,\n)]\npub struct ExtensionId(u32);\n\n/// Types implementing this trait can be used as chain extensions.\n///\n/// This trait is only useful for testing contract via the off-chain environment.\npub trait ChainExtension {\n    /// The static function ID of the chain extension.\n    ///\n    /// # Note\n    ///\n    /// This is expected to return a constant value.\n    fn func_id(&self) -> u32;\n\n    /// Calls the chain extension with the given input.\n    ///\n    /// Returns an error code and may fill the `output` buffer with a SCALE encoded result.\n    fn call(&mut self, input: &[u8], output: &mut Vec<u8>) -> u32;\n}\n\nimpl ChainExtensionHandler {\n    /// Creates a new chain extension handler.\n    ///\n    /// Initialized with an empty set of chain extensions.\n    pub fn new() -> Self {\n        Self {\n            registered: HashMap::new(),\n            output: Vec::new(),\n        }\n    }\n\n    /// Resets the chain extension handler to uninitialized state.\n    pub fn reset(&mut self) {\n        self.registered.clear();\n        self.output.clear();\n    }\n\n    /// Register a new chain extension.\n    pub fn register(&mut self, extension: Box<dyn ChainExtension>) {\n        let func_id = extension.func_id();\n        self.registered\n            .insert(ExtensionId::from(func_id), extension);\n    }\n\n    /// Evaluates the chain extension with the given parameters.\n    ///\n    /// Upon success returns the values returned by the evaluated chain extension.\n    pub fn eval(&mut self, func_id: u32, input: &[u8]) -> Result<(u32, &[u8])> {\n        self.output.clear();\n        let extension_id = ExtensionId::from(func_id);\n        match self.registered.entry(extension_id) {\n            Entry::Occupied(occupied) => {\n                let status_code = occupied.into_mut().call(input, &mut self.output);\n                Ok((status_code, &mut self.output))\n            }\n            Entry::Vacant(_vacant) => {\n                Err(OffChainError::UnregisteredChainExtension.into())\n            }\n        }\n    }\n}\n"],["876","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::backend::{\n    EnvBackend,\n    TypedEnvBackend,\n};\nuse cfg_if::cfg_if;\n\npub trait OnInstance: EnvBackend + TypedEnvBackend {\n    fn on_instance<F, R>(f: F) -> R\n    where\n        F: FnOnce(&mut Self) -> R;\n}\n\ncfg_if! {\n    if #[cfg(all(not(feature = \"std\"), target_arch = \"wasm32\"))] {\n        mod on_chain;\n        pub use self::on_chain::EnvInstance;\n    } else if #[cfg(feature = \"std\")] {\n        pub mod off_chain;\n        pub use self::off_chain::EnvInstance;\n        pub use self::off_chain::{\n            AccountError,\n            TypedEncodedError,\n        };\n    } else {\n        compile_error! {\n            \"ink! only support compilation as `std` or `no_std` + `wasm32-unknown`\"\n        }\n    }\n}\n"],["877","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Provides type definitions and traits for the built-in cryptographic hashes.\n\n/// The output type of a built-in cryptographic hash function.\npub trait HashOutput: private::Sealed {\n    /// The output type of the crypto hash.\n    ///\n    /// This should be a byte array with some constant size such as `[u8; 32]`.\n    type Type: Default;\n}\n\n/// Types that are usable as built-in cryptographic hashes.\npub trait CryptoHash: HashOutput + private::Sealed {\n    /// Hashes the given raw byte input and copies the result into `output`.\n    fn hash(input: &[u8], output: &mut <Self as HashOutput>::Type);\n}\n\n/// The SHA2 crypto hash with 256-bit output.\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\npub enum Sha2x256 {}\n\n/// The KECCAK crypto hash with 256-bit output.\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\npub enum Keccak256 {}\n\n/// The BLAKE2 crypto hash with 256-bit output.\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\npub enum Blake2x256 {}\n\n/// The BLAKE2 crypto hash with 128-bit output.\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\npub enum Blake2x128 {}\n\nmod private {\n    /// Seals the implementation of `CryptoHash` and `HashOutput`.\n    pub trait Sealed {}\n}\n\nimpl private::Sealed for Sha2x256 {}\nimpl private::Sealed for Keccak256 {}\nimpl private::Sealed for Blake2x256 {}\nimpl private::Sealed for Blake2x128 {}\n\nimpl HashOutput for Sha2x256 {\n    type Type = [u8; 32];\n}\n\nimpl HashOutput for Keccak256 {\n    type Type = [u8; 32];\n}\n\nimpl HashOutput for Blake2x256 {\n    type Type = [u8; 32];\n}\n\nimpl HashOutput for Blake2x128 {\n    type Type = [u8; 16];\n}\n"],["878","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Definitions and utilities for calling chain extension methods.\n//!\n//! Users should not use these types and definitions directly but rather use the provided\n//! `#[ink::chain_extension]` procedural macro defined in the `ink_lang` crate.\n\nuse crate::{\n    backend::EnvBackend,\n    engine::{\n        EnvInstance,\n        OnInstance,\n    },\n};\nuse core::marker::PhantomData;\n\n/// Implemented by error codes in order to construct them from status codes.\n///\n/// A status code is returned by calling an ink! chain extension method.\n/// It is the `u32` return value.\n///\n/// The purpose of an `ErrorCode` type that implements this trait is to provide\n/// more context information about the status of an ink! chain extension method call.\npub trait FromStatusCode: Sized {\n    /// Returns `Ok` if the status code for the called chain extension method is valid.\n    ///\n    /// Returning `Ok` will query the output buffer of the call if the chain extension\n    /// method definition has a return value.\n    ///\n    /// # Note\n    ///\n    /// The convention is to use `0` as the only `raw` value that yields `Ok` whereas\n    /// every other value represents one error code. By convention this mapping should\n    /// never panic and therefore every `raw` value must map to either `Ok` or to a proper\n    /// `ErrorCode` variant.\n    fn from_status_code(status_code: u32) -> Result<(), Self>;\n}\n\n/// A concrete instance of a chain extension method.\n///\n/// This is a utility type used to drive the execution of a chain extension method call.\n/// It has several different specializations of its `call` method for different ways to\n/// manage error handling when calling a predefined chain extension method.\n///\n/// - `I` represents the input type of the chain extension method.\n///   All tuple types that may act as input parameters for the chain extension method are valid.\n///   Examples include `()`, `i32`, `(u8, [u8; 5], i32)`, etc.\n/// - `O` represents the return (or output) type of the chain extension method.\n///   Only `Result<T, E>` or `NoResult<O>` generic types are allowed for `O`.\n///   The `Result<T, E>` type says that the chain extension method returns a `Result` type\n///   whereas the `NoResult<O>` type says that the chain extension method returns a non-`Result` value\n///   of type `O`.\n/// - `ErrorCode` represents how the chain extension method handles the chain extension's error code.\n///   Only `HandleErrorCode<E>` and `IgnoreErrorCode` types are allowed that each say to either properly\n///   handle or ignore the chain extension's error code respectively.\n///\n/// The type states for type parameter `O` and `ErrorCode` represent 4 different states:\n///\n/// 1. The chain extension method makes use of the chain extension's error code: `HandleErrorCode(E)`\n///     - **A:** The chain extension method returns a `Result<T, E>` type.\n///     - **B:** The chain extension method returns a type `T` that is not a `Result` type: `NoResult<T>`\n/// 2. The chain extension ignores the chain extension's error code: `IgnoreErrorCode`\n///     - **A:** The chain extension method returns a `Result<T, E>` type.\n///     - **B:** The chain extension method returns a type `T` that is not a `Result` type: `NoResult<T>`\n#[derive(Debug)]\npub struct ChainExtensionMethod<I, O, ErrorCode> {\n    func_id: u32,\n    #[allow(clippy::type_complexity)]\n    state: PhantomData<fn() -> (I, O, ErrorCode)>,\n}\n\nimpl ChainExtensionMethod<(), (), ()> {\n    /// Creates a new chain extension method instance.\n    #[inline(always)]\n    pub fn build(func_id: u32) -> Self {\n        Self {\n            func_id,\n            state: Default::default(),\n        }\n    }\n}\n\nimpl<O, ErrorCode> ChainExtensionMethod<(), O, ErrorCode> {\n    /// Sets the input types of the chain extension method call to `I`.\n    ///\n    /// # Note\n    ///\n    /// `I` represents the input type of the chain extension method.\n    /// All tuple types that may act as input parameters for the chain extension method are valid.\n    /// Examples include `()`, `i32`, `(u8, [u8; 5], i32)`, etc.\n    #[inline(always)]\n    pub fn input<I>(self) -> ChainExtensionMethod<I, O, ErrorCode>\n    where\n        I: scale::Encode,\n    {\n        ChainExtensionMethod {\n            func_id: self.func_id,\n            state: Default::default(),\n        }\n    }\n}\n\nimpl<I, ErrorCode> ChainExtensionMethod<I, (), ErrorCode> {\n    /// Sets the output type of the chain extension method call to `Result<T, E>`.\n    ///\n    /// # Note\n    ///\n    /// This indicates that the chain extension method return value might represent a failure.\n    #[inline(always)]\n    pub fn output_result<T, E>(self) -> ChainExtensionMethod<I, Result<T, E>, ErrorCode>\n    where\n        Result<T, E>: scale::Decode,\n        E: From<scale::Error>,\n    {\n        ChainExtensionMethod {\n            func_id: self.func_id,\n            state: Default::default(),\n        }\n    }\n\n    /// Sets the output type of the chain extension method call to `O`.\n    ///\n    /// # Note\n    ///\n    /// The set returned type `O` must not be of type `Result<T, E>`.\n    /// When using the `#[ink::chain_extension]` procedural macro to define\n    /// this chain extension method the above constraint is enforced at\n    /// compile time.\n    #[inline(always)]\n    pub fn output<O>(self) -> ChainExtensionMethod<I, state::NoResult<O>, ErrorCode>\n    where\n        O: scale::Decode,\n    {\n        ChainExtensionMethod {\n            func_id: self.func_id,\n            state: Default::default(),\n        }\n    }\n}\n\nimpl<I, O> ChainExtensionMethod<I, O, ()> {\n    /// Makes the chain extension method call assume that the returned status code is always success.\n    ///\n    /// # Note\n    ///\n    /// This will avoid handling of failure status codes returned by the chain extension method call.\n    /// Use this only if you are sure that the chain extension method call will never return an error\n    /// code that represents failure.\n    ///\n    /// The output of the chain extension method call is always decoded and returned in this case.\n    #[inline(always)]\n    pub fn ignore_error_code(self) -> ChainExtensionMethod<I, O, state::IgnoreErrorCode> {\n        ChainExtensionMethod {\n            func_id: self.func_id,\n            state: Default::default(),\n        }\n    }\n\n    /// Makes the chain exntesion method call handle the returned status code.\n    ///\n    /// # Note\n    ///\n    /// This will handle the returned status code and only loads and decodes the value\n    /// returned in the output of the chain extension method call in case of success.\n    #[inline(always)]\n    pub fn handle_error_code<ErrorCode>(\n        self,\n    ) -> ChainExtensionMethod<I, O, state::HandleErrorCode<ErrorCode>>\n    where\n        ErrorCode: FromStatusCode,\n    {\n        ChainExtensionMethod {\n            func_id: self.func_id,\n            state: Default::default(),\n        }\n    }\n}\n\n/// Type states of the chain extension method instance.\npub mod state {\n    use core::marker::PhantomData;\n\n    /// Type state meaning that the chain extension method ignores the chain extension's error code.\n    #[derive(Debug)]\n    pub enum IgnoreErrorCode {}\n\n    /// Type state meaning that the chain extension method uses the chain extension's error code.\n    #[derive(Debug)]\n    pub struct HandleErrorCode<T> {\n        error_code: PhantomData<fn() -> T>,\n    }\n\n    /// Type state meaning that the chain extension method deliberately does not return a `Result` type.\n    ///\n    /// Additionally this is enforced by the `#[ink::chain_extension]` proc. macro when used.\n    #[derive(Debug)]\n    pub struct NoResult<T> {\n        no_result: PhantomData<fn() -> T>,\n    }\n}\n\nimpl<I, T, E, ErrorCode>\n    ChainExtensionMethod<I, Result<T, E>, state::HandleErrorCode<ErrorCode>>\nwhere\n    I: scale::Encode,\n    T: scale::Decode,\n    E: scale::Decode + From<ErrorCode> + From<scale::Error>,\n    ErrorCode: FromStatusCode,\n{\n    /// Calls the chain extension method for case 1A described [here].\n    ///\n    /// [here]: [`ChainExtensionMethodInstance`]\n    ///\n    /// # Errors\n    ///\n    /// - If the called chain extension method returns a non-successful error code.\n    /// - If the `Result` return value of the called chain extension represents an error.\n    /// - If the `Result` return value cannot be SCALE decoded properly.\n    /// - If custom constraints specified by the called chain extension method are violated.\n    ///     - These constraints are determined and defined by the author of the chain extension method.\n    ///\n    /// # Example\n    ///\n    /// Declares a chain extension method with the unique ID of 5 that requires a `bool` and an `i32`\n    /// as input parameters and returns a `Result<i32, MyError>` upon completion.\n    /// It will handle the shared error code from the chain extension.\n    /// The call is finally invoked with arguments `true` and `42` for the `bool` and `i32` input\n    /// parameter respectively.\n    ///\n    /// ```should_panic\n    /// # // Panics because the off-chain environment has not\n    /// # // registered a chain extension method for the ID.\n    /// # use ink_env::chain_extension::{ChainExtensionMethod, FromStatusCode};\n    /// let result = ChainExtensionMethod::build(5)\n    ///     .input::<(bool, i32)>()\n    ///     .output_result::<i32, MyError>()\n    ///     .handle_error_code::<MyErrorCode>()\n    ///     .call(&(true, 42));\n    /// # #[derive(scale::Encode, scale::Decode)]\n    /// # pub struct MyError {}\n    /// # impl From<scale::Error> for MyError {\n    /// #     fn from(_error: scale::Error) -> Self { Self {} }\n    /// # }\n    /// # impl From<MyErrorCode> for MyError {\n    /// #     fn from(_error: MyErrorCode) -> Self { Self {} }\n    /// # }\n    /// # pub struct MyErrorCode {}\n    /// # impl FromStatusCode for MyErrorCode {\n    /// #     fn from_status_code(status_code: u32) -> Result<(), Self> { Ok(()) }\n    /// # }\n    /// ```\n    #[inline(always)]\n    pub fn call(self, input: &I) -> Result<T, E> {\n        <EnvInstance as OnInstance>::on_instance(|instance| {\n            EnvBackend::call_chain_extension::<I, T, E, ErrorCode, _, _>(\n                instance,\n                self.func_id,\n                input,\n                ErrorCode::from_status_code,\n                |mut output| scale::Decode::decode(&mut output).map_err(Into::into),\n            )\n        })\n    }\n}\n\nimpl<I, T, E> ChainExtensionMethod<I, Result<T, E>, state::IgnoreErrorCode>\nwhere\n    I: scale::Encode,\n    T: scale::Decode,\n    E: scale::Decode + From<scale::Error>,\n{\n    /// Calls the chain extension method for case 2A described [here].\n    ///\n    /// [here]: [`ChainExtensionMethodInstance`]\n    ///\n    /// # Errors\n    ///\n    /// - If the `Result` return value of the called chain extension represents an error.\n    /// - If the `Result` return value cannot be SCALE decoded properly.\n    /// - If custom constraints specified by the called chain extension method are violated.\n    ///     - These constraints are determined and defined by the author of the chain extension method.\n    ///\n    /// # Example\n    ///\n    /// Declares a chain extension method with the unique ID of 5 that requires a `bool` and an `i32`\n    /// as input parameters and returns a `Result<i32, MyError>` upon completion.\n    /// It will ignore the shared error code from the chain extension and assumes that the call succeeds.\n    /// The call is finally invoked with arguments `true` and `42` for the `bool` and `i32` input\n    /// parameter respectively.\n    ///\n    /// ```should_panic\n    /// # // Panics because the off-chain environment has not\n    /// # // registered a chain extension method for the ID.\n    /// # use ink_env::chain_extension::{ChainExtensionMethod};\n    /// let result = ChainExtensionMethod::build(5)\n    ///     .input::<(bool, i32)>()\n    ///     .output_result::<i32, MyError>()\n    ///     .ignore_error_code()\n    ///     .call(&(true, 42));\n    /// # #[derive(scale::Encode, scale::Decode)]\n    /// # pub struct MyError {}\n    /// # impl From<scale::Error> for MyError {\n    /// #     fn from(_error: scale::Error) -> Self { Self {} }\n    /// # }\n    /// ```\n    #[inline(always)]\n    pub fn call(self, input: &I) -> Result<T, E> {\n        <EnvInstance as OnInstance>::on_instance(|instance| {\n            EnvBackend::call_chain_extension::<I, T, E, E, _, _>(\n                instance,\n                self.func_id,\n                input,\n                |_status_code| Ok(()),\n                |mut output| scale::Decode::decode(&mut output).map_err(Into::into),\n            )\n        })\n    }\n}\n\nimpl<I, O, ErrorCode>\n    ChainExtensionMethod<I, state::NoResult<O>, state::HandleErrorCode<ErrorCode>>\nwhere\n    I: scale::Encode,\n    O: scale::Decode,\n    ErrorCode: FromStatusCode,\n{\n    /// Calls the chain extension method for case 1B described [here].\n    ///\n    /// [here]: [`ChainExtensionMethodInstance`]\n    ///\n    /// # Errors\n    ///\n    /// - If the called chain extension method returns a non-successful error code.\n    /// - If custom constraints specified by the called chain extension method are violated.\n    ///     - These constraints are determined and defined by the author of the chain extension method.\n    ///\n    /// # Panics\n    ///\n    /// - If the return value cannot be SCALE decoded properly.\n    ///\n    /// # Example\n    ///\n    /// Declares a chain extension method with the unique ID of 5 that requires a `bool` and an `i32`\n    /// as input parameters and returns a `Result<i32, MyErrorCode>` upon completion.\n    /// It will handle the shared error code from the chain extension.\n    /// The call is finally invoked with arguments `true` and `42` for the `bool` and `i32` input\n    /// parameter respectively.\n    ///\n    /// ```should_panic\n    /// # // Panics because the off-chain environment has not\n    /// # // registered a chain extension method for the ID.\n    /// # use ink_env::chain_extension::{ChainExtensionMethod, FromStatusCode};\n    /// let result = ChainExtensionMethod::build(5)\n    ///     .input::<(bool, i32)>()\n    ///     .output::<i32>()\n    ///     .handle_error_code::<MyErrorCode>()\n    ///     .call(&(true, 42));\n    /// # pub struct MyErrorCode {}\n    /// # impl FromStatusCode for MyErrorCode {\n    /// #     fn from_status_code(status_code: u32) -> Result<(), Self> { Ok(()) }\n    /// # }\n    /// ```\n    #[inline(always)]\n    pub fn call(self, input: &I) -> Result<O, ErrorCode> {\n        <EnvInstance as OnInstance>::on_instance(|instance| {\n            EnvBackend::call_chain_extension::<I, O, ErrorCode, ErrorCode, _, _>(\n                instance,\n                self.func_id,\n                input,\n                ErrorCode::from_status_code,\n                |mut output| {\n                    let decoded = <O as scale::Decode>::decode(&mut output)\n                        .expect(\"encountered error while decoding chain extension method call return value\");\n                    Ok(decoded)\n                },\n            )\n        })\n    }\n}\n\nimpl<I, O> ChainExtensionMethod<I, state::NoResult<O>, state::IgnoreErrorCode>\nwhere\n    I: scale::Encode,\n    O: scale::Decode,\n{\n    /// Calls the chain extension method for case 2B described [here].\n    ///\n    /// [here]: [`ChainExtensionMethodInstance`]\n    ///\n    /// # Panics\n    ///\n    /// - If the return value cannot be SCALE decoded properly.\n    ///\n    /// # Example\n    ///\n    /// Declares a chain extension method with the unique ID of 5 that requires a `bool` and an `i32`\n    /// as input parameters and returns a `Result<i32, MyErrorCode>` upon completion.\n    /// It will ignore the shared error code from the chain extension and assumes that the call succeeds.\n    /// The call is finally invoked with arguments `true` and `42` for the `bool` and `i32` input\n    /// parameter respectively.\n    ///\n    /// ```should_panic\n    /// # // Panics because the off-chain environment has not\n    /// # // registered a chain extension method for the ID.\n    /// # use ink_env::chain_extension::ChainExtensionMethod;\n    /// let result = ChainExtensionMethod::build(5)\n    ///     .input::<(bool, i32)>()\n    ///     .output::<i32>()\n    ///     .ignore_error_code()\n    ///     .call(&(true, 42));\n    /// ```\n    #[inline(always)]\n    pub fn call(self, input: &I) -> O {\n        <EnvInstance as OnInstance>::on_instance(|instance| {\n            EnvBackend::call_chain_extension::<I, O, (), (), _, _>(\n                instance,\n                self.func_id,\n                input,\n                |_status_code| Ok(()),\n                |mut output| {\n                    let decoded = <O as scale::Decode>::decode(&mut output)\n                        .expect(\"encountered error while decoding chain extension method call return value\");\n                    Ok(decoded)\n                },\n            ).expect(\"assume the chain extension method never fails\")\n        })\n    }\n}\n"],["879","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::{\n    call::{\n        utils::ReturnType,\n        CallParams,\n        CreateParams,\n    },\n    hash::{\n        CryptoHash,\n        HashOutput,\n    },\n    topics::Topics,\n    Environment,\n    Result,\n};\nuse ink_primitives::Key;\n\n/// The flags to indicate further information about the end of a contract execution.\npub struct ReturnFlags {\n    value: u32,\n}\n\nimpl Default for ReturnFlags {\n    fn default() -> Self {\n        Self { value: 0 }\n    }\n}\n\nimpl ReturnFlags {\n    /// Sets the bit to indicate that the execution is going to be reverted.\n    pub fn set_reverted(mut self, has_reverted: bool) -> Self {\n        match has_reverted {\n            true => self.value |= has_reverted as u32,\n            false => self.value &= !has_reverted as u32,\n        }\n        self\n    }\n\n    /// Returns the underlying `u32` representation.\n    pub(crate) fn into_u32(self) -> u32 {\n        self.value\n    }\n}\n\n/// Environmental contract functionality that does not require `Environment`.\npub trait EnvBackend {\n    /// Writes the value to the contract storage under the given key.\n    fn set_contract_storage<V>(&mut self, key: &Key, value: &V)\n    where\n        V: scale::Encode;\n\n    /// Returns the value stored under the given key in the contract's storage if any.\n    ///\n    /// # Errors\n    ///\n    /// - If the decoding of the typed value failed\n    fn get_contract_storage<R>(&mut self, key: &Key) -> Result<Option<R>>\n    where\n        R: scale::Decode;\n\n    /// Clears the contract's storage key entry.\n    fn clear_contract_storage(&mut self, key: &Key);\n\n    /// Returns the execution input to the executed contract and decodes it as `T`.\n    ///\n    /// # Note\n    ///\n    /// - The input is the 4-bytes selector followed by the arguments\n    ///   of the called function in their SCALE encoded representation.\n    /// - No prior interaction with the environment must take place before\n    ///   calling this procedure.\n    ///\n    /// # Usage\n    ///\n    /// Normally contracts define their own `enum` dispatch types respective\n    /// to their exported contructors and messages that implement `scale::Decode`\n    /// according to the contructors or messages selectors and their arguments.\n    /// These `enum` dispatch types are then given to this procedure as the `T`.\n    ///\n    /// When using ink! users do not have to construct those enum dispatch types\n    /// themselves as they are normally generated by the ink! code generation\n    /// automatically.\n    ///\n    /// # Errors\n    ///\n    /// If the given `T` cannot be properly decoded from the expected input.\n    fn decode_input<T>(&mut self) -> Result<T>\n    where\n        T: scale::Decode;\n\n    /// Returns the value back to the caller of the executed contract.\n    ///\n    /// # Note\n    ///\n    /// Calling this method will end contract execution immediately.\n    /// It will return the given return value back to its caller.\n    ///\n    /// The `flags` parameter can be used to revert the state changes of the\n    /// entire execution if necessary.\n    fn return_value<R>(&mut self, flags: ReturnFlags, return_value: &R) -> !\n    where\n        R: scale::Encode;\n\n    /// Prints the given contents to the console log.\n    fn println(&mut self, content: &str);\n\n    /// Conducts the crypto hash of the given input and stores the result in `output`.\n    fn hash_bytes<H>(&mut self, input: &[u8], output: &mut <H as HashOutput>::Type)\n    where\n        H: CryptoHash;\n\n    /// Conducts the crypto hash of the given encoded input and stores the result in `output`.\n    fn hash_encoded<H, T>(&mut self, input: &T, output: &mut <H as HashOutput>::Type)\n    where\n        H: CryptoHash,\n        T: scale::Encode;\n\n    /// Low-level interface to call a chain extension method.\n    ///\n    /// Returns the output of the chain extension of the specified type.\n    ///\n    /// # Errors\n    ///\n    /// - If the chain extension with the given ID does not exist.\n    /// - If the inputs had an unexpected encoding.\n    /// - If the output could not be properly decoded.\n    /// - If some extension specific condition has not been met.\n    ///\n    /// # Dev. Note\n    ///\n    /// A valid implementation applies the `status_to_result` closure on\n    /// the status code returned by the actual call to the chain extension\n    /// method.\n    /// Only if the closure finds that the given status code indicates a\n    /// successful call to the chain extension method is the resulting\n    /// output buffer passed to the `decode_to_result` closure, in order to\n    /// drive the decoding and error management process from the outside.\n    fn call_chain_extension<I, T, E, ErrorCode, F, D>(\n        &mut self,\n        func_id: u32,\n        input: &I,\n        status_to_result: F,\n        decode_to_result: D,\n    ) -> ::core::result::Result<T, E>\n    where\n        I: scale::Encode,\n        T: scale::Decode,\n        E: From<ErrorCode>,\n        F: FnOnce(u32) -> ::core::result::Result<(), ErrorCode>,\n        D: FnOnce(&[u8]) -> ::core::result::Result<T, E>;\n}\n\n/// Environmental contract functionality.\npub trait TypedEnvBackend: EnvBackend {\n    /// Returns the address of the caller of the executed contract.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`caller`][`crate::caller`]\n    fn caller<T: Environment>(&mut self) -> Result<T::AccountId>;\n\n    /// Returns the transferred balance for the contract execution.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`transferred_balance`][`crate::transferred_balance`]\n    fn transferred_balance<T: Environment>(&mut self) -> Result<T::Balance>;\n\n    /// Returns the price for the specified amount of gas.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`weight_to_fee`][`crate::weight_to_fee`]\n    fn weight_to_fee<T: Environment>(&mut self, gas: u64) -> Result<T::Balance>;\n\n    /// Returns the amount of gas left for the contract execution.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`gas_left`][`crate::gas_left`]\n    fn gas_left<T: Environment>(&mut self) -> Result<T::Balance>;\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`block_timestamp`][`crate::block_timestamp`]\n    fn block_timestamp<T: Environment>(&mut self) -> Result<T::Timestamp>;\n\n    /// Returns the address of the executed contract.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`account_id`][`crate::account_id`]\n    fn account_id<T: Environment>(&mut self) -> Result<T::AccountId>;\n\n    /// Returns the balance of the executed contract.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`balance`][`crate::balance`]\n    fn balance<T: Environment>(&mut self) -> Result<T::Balance>;\n\n    /// Returns the current rent allowance for the executed contract.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`rent_allowance`][`crate::rent_allowance`]\n    fn rent_allowance<T: Environment>(&mut self) -> Result<T::Balance>;\n\n    /// Returns the current block number.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`block_number`][`crate::block_number`]\n    fn block_number<T: Environment>(&mut self) -> Result<T::BlockNumber>;\n\n    /// Returns the minimum balance that is required for creating an account.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`minimum_balance`][`crate::minimum_balance`]\n    fn minimum_balance<T: Environment>(&mut self) -> Result<T::Balance>;\n\n    /// Returns the tombstone deposit of the contract chain.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`tombstone_deposit`][`crate::tombstone_deposit`]\n    fn tombstone_deposit<T: Environment>(&mut self) -> Result<T::Balance>;\n\n    /// Emits an event with the given event data.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`emit_event`][`crate::emit_event`]\n    fn emit_event<T, Event>(&mut self, event: Event)\n    where\n        T: Environment,\n        Event: Topics + scale::Encode;\n\n    /// Sets the rent allowance of the executed contract to the new value.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`set_rent_allowance`][`crate::set_rent_allowance`]\n    fn set_rent_allowance<T>(&mut self, new_value: T::Balance)\n    where\n        T: Environment;\n\n    /// Invokes a contract message.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`invoke_contract`][`crate::invoke_contract`]\n    fn invoke_contract<T, Args>(\n        &mut self,\n        call_data: &CallParams<T, Args, ()>,\n    ) -> Result<()>\n    where\n        T: Environment,\n        Args: scale::Encode;\n\n    /// Evaluates a contract message and returns its result.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`eval_contract`][`crate::eval_contract`]\n    fn eval_contract<T, Args, R>(\n        &mut self,\n        call_data: &CallParams<T, Args, ReturnType<R>>,\n    ) -> Result<R>\n    where\n        T: Environment,\n        Args: scale::Encode,\n        R: scale::Decode;\n\n    /// Instantiates another contract.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`instantiate_contract`][`crate::instantiate_contract`]\n    fn instantiate_contract<T, Args, Salt, C>(\n        &mut self,\n        params: &CreateParams<T, Args, Salt, C>,\n    ) -> Result<T::AccountId>\n    where\n        T: Environment,\n        Args: scale::Encode,\n        Salt: AsRef<[u8]>;\n\n    /// Restores a smart contract tombstone.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`restore_contract`][`crate::restore_contract`]\n    fn restore_contract<T>(\n        &mut self,\n        account_id: T::AccountId,\n        code_hash: T::Hash,\n        rent_allowance: T::Balance,\n        filtered_keys: &[Key],\n    ) where\n        T: Environment;\n\n    /// Terminates a smart contract.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`terminate_contract`][`crate::terminate_contract`]\n    fn terminate_contract<T>(&mut self, beneficiary: T::AccountId) -> !\n    where\n        T: Environment;\n\n    /// Transfers value from the contract to the destination account ID.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`transfer`][`crate::transfer`]\n    fn transfer<T>(&mut self, destination: T::AccountId, value: T::Balance) -> Result<()>\n    where\n        T: Environment;\n\n    /// Returns a random hash seed.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`random`][`crate::random`]\n    fn random<T>(&mut self, subject: &[u8]) -> Result<T::Hash>\n    where\n        T: Environment;\n}\n"],["880","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Utilities, types and abstractions common to call and instantiation routines.\n\nuse core::marker::PhantomData;\n\n/// Represents a return type.\n///\n/// Used as a marker type to differentiate at compile-time between invoke and evaluate.\n#[derive(Debug)]\npub struct ReturnType<T>(PhantomData<fn() -> T>);\n\nimpl<T> Clone for ReturnType<T> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Self(Default::default())\n    }\n}\n\nimpl<T> Copy for ReturnType<T> {}\n\nimpl<T> Default for ReturnType<T> {\n    #[inline]\n    fn default() -> Self {\n        Self(Default::default())\n    }\n}\n\n/// A parameter that has been set to some value.\n#[derive(Debug, Copy, Clone)]\npub struct Set<T>(pub T);\n\nimpl<T> Set<T> {\n    /// Returns the set value.\n    #[inline]\n    pub fn value(self) -> T {\n        self.0\n    }\n}\n\n/// A parameter that has not been set, yet.\n#[derive(Debug)]\npub struct Unset<T>(PhantomData<fn() -> T>);\n\nimpl<T> Clone for Unset<T> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Self(Default::default())\n    }\n}\n\nimpl<T> Copy for Unset<T> {}\n\nimpl<T> Default for Unset<T> {\n    #[inline]\n    fn default() -> Self {\n        Self(Default::default())\n    }\n}\n\n/// Implemented by [`Set`] and [`Unset`] in order to unwrap their value.\n///\n/// This is useful in case the use-site does not know if it is working with\n/// a set or an unset value generically unwrap it using a closure for fallback.\npub trait Unwrap {\n    /// The output type of the `unwrap_or_else` operation.\n    type Output;\n\n    /// Returns the set value or evaluates the given closure.\n    fn unwrap_or_else<F>(self, f: F) -> Self::Output\n    where\n        F: FnOnce() -> Self::Output;\n}\n\nimpl<T> Unwrap for Unset<T> {\n    type Output = T;\n\n    #[inline]\n    fn unwrap_or_else<F>(self, f: F) -> Self::Output\n    where\n        F: FnOnce() -> Self::Output,\n    {\n        f()\n    }\n}\n\nimpl<T> Unwrap for Set<T> {\n    type Output = T;\n\n    #[inline]\n    fn unwrap_or_else<F>(self, _: F) -> Self::Output\n    where\n        F: FnOnce() -> Self::Output,\n    {\n        self.value()\n    }\n}\n"],["881","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse derive_more::From;\n\n/// The function selector.\n#[derive(Debug, Copy, Clone, PartialEq, Eq, From, scale::Decode, scale::Encode)]\npub struct Selector {\n    /// The 4 underlying bytes.\n    bytes: [u8; 4],\n}\n\nimpl Selector {\n    /// Creates a selector directly from 4 bytes.\n    pub const fn new(bytes: [u8; 4]) -> Self {\n        Self { bytes }\n    }\n\n    /// Returns the underlying bytes of the selector.\n    pub const fn to_bytes(self) -> [u8; 4] {\n        self.bytes\n    }\n}\n"],["882","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::{\n    call::{\n        utils::{\n            EmptyArgumentList,\n            ReturnType,\n            Set,\n            Unset,\n            Unwrap,\n        },\n        ExecutionInput,\n    },\n    Environment,\n    Error,\n};\nuse core::marker::PhantomData;\n\n/// The final parameters to the cross-contract call.\n#[derive(Debug)]\npub struct CallParams<E, Args, R>\nwhere\n    E: Environment,\n{\n    /// The account ID of the to-be-called smart contract.\n    callee: E::AccountId,\n    /// The maximum gas costs allowed for the call.\n    gas_limit: u64,\n    /// The transferred value for the call.\n    transferred_value: E::Balance,\n    /// The expected return type.\n    return_type: ReturnType<R>,\n    /// The inputs to the execution which is a selector and encoded arguments.\n    exec_input: ExecutionInput<Args>,\n}\n\n#[cfg(\n    // We do not currently support cross-contract calling in the off-chain\n    // environment so we do not have to provide these getters in case of\n    // off-chain environment compilation.\n    all(not(feature = \"std\"), target_arch = \"wasm32\")\n)]\nimpl<E, Args, R> CallParams<E, Args, R>\nwhere\n    E: Environment,\n{\n    /// Returns the account ID of the called contract instance.\n    #[inline]\n    pub(crate) fn callee(&self) -> &E::AccountId {\n        &self.callee\n    }\n\n    /// Returns the chosen gas limit for the called contract execution.\n    #[inline]\n    pub(crate) fn gas_limit(&self) -> u64 {\n        self.gas_limit\n    }\n\n    /// Returns the transferred value for the called contract.\n    #[inline]\n    pub(crate) fn transferred_value(&self) -> &E::Balance {\n        &self.transferred_value\n    }\n\n    /// Returns the execution input.\n    #[inline]\n    pub(crate) fn exec_input(&self) -> &ExecutionInput<Args> {\n        &self.exec_input\n    }\n}\n\nimpl<E, Args> CallParams<E, Args, ()>\nwhere\n    E: Environment,\n    Args: scale::Encode,\n{\n    /// Invokes the contract with the given built-up call parameters.\n    ///\n    /// # Note\n    ///\n    /// Prefer [`invoke`](`Self::invoke`) over [`eval`](`Self::eval`) if the\n    /// called contract message does not return anything because it is more efficient.\n    pub fn invoke(&self) -> Result<(), crate::Error> {\n        crate::invoke_contract(self)\n    }\n}\n\nimpl<E, Args, R> CallParams<E, Args, ReturnType<R>>\nwhere\n    E: Environment,\n    Args: scale::Encode,\n    R: scale::Decode,\n{\n    /// Evaluates the contract with the given built-up call parameters.\n    ///\n    /// Returns the result of the contract execution.\n    ///\n    /// # Note\n    ///\n    /// Prefer [`invoke`](`Self::invoke`) over [`eval`](`Self::eval`) if the\n    /// called contract message does not return anything because it is more efficient.\n    pub fn eval(&self) -> Result<R, crate::Error> {\n        crate::eval_contract(self)\n    }\n}\n\n/// Returns a new [`CallBuilder`] to build up the parameters to a cross-contract call.\n///\n/// # Example\n///\n/// **Note:** The shown examples panic because there is currently no cross-calling\n///           support in the off-chain testing environment. However, this code\n///           should work fine in on-chain environments.\n///\n/// ## Example 1: No Return Value\n///\n/// The below example shows calling of a message of another contract that does\n/// not return any value back to its caller. The called function ...\n///\n/// - has a selector equal to `0xDEADBEEF`\n/// - is provided with 5000 units of gas for its execution\n/// - is provided with 10 units of transferred value for the contract instance\n/// - receives the following arguments in order\n///    1. an `i32` with value `42`\n///    2. a `bool` with value `true`\n///    3. an array of 32 `u8` with value `0x10`\n///\n/// ```should_panic\n/// # use ::ink_env::{\n/// #     Environment,\n/// #     DefaultEnvironment,\n/// #     call::{build_call, Selector, ExecutionInput}\n/// # };\n/// # type AccountId = <DefaultEnvironment as Environment>::AccountId;\n/// build_call::<DefaultEnvironment>()\n///     .callee(AccountId::from([0x42; 32]))\n///     .gas_limit(5000)\n///     .transferred_value(10)\n///     .exec_input(\n///         ExecutionInput::new(Selector::new([0xDE, 0xAD, 0xBE, 0xEF]))\n///             .push_arg(42)\n///             .push_arg(true)\n///             .push_arg(&[0x10u8; 32])\n///     )\n///     .returns::<()>()\n///     .fire()\n///     .unwrap();\n/// ```\n///\n/// ## Example 2: With Return Value\n///\n/// The below example shows calling of a message of another contract that does\n/// return a `i32` value back to its caller. The called function ...\n///\n/// - has a selector equal to `0xDEADBEEF`\n/// - is provided with 5000 units of gas for its execution\n/// - is provided with 10 units of transferred value for the contract instance\n/// - receives the following arguments in order\n///    1. an `i32` with value `42`\n///    2. a `bool` with value `true`\n///    3. an array of 32 `u8` with value `0x10`\n///\n/// ```should_panic\n/// # use ::ink_env::{\n/// #     Environment,\n/// #     DefaultEnvironment,\n/// #     call::{build_call, Selector, ExecutionInput, utils::ReturnType},\n/// # };\n/// # type AccountId = <DefaultEnvironment as Environment>::AccountId;\n/// let my_return_value: i32 = build_call::<DefaultEnvironment>()\n///     .callee(AccountId::from([0x42; 32]))\n///     .gas_limit(5000)\n///     .transferred_value(10)\n///     .exec_input(\n///         ExecutionInput::new(Selector::new([0xDE, 0xAD, 0xBE, 0xEF]))\n///             .push_arg(42)\n///             .push_arg(true)\n///             .push_arg(&[0x10; 32])\n///     )\n///     .returns::<ReturnType<i32>>()\n///     .fire()\n///     .unwrap();\n/// ```\n#[allow(clippy::type_complexity)]\npub fn build_call<E>() -> CallBuilder<\n    E,\n    Unset<E::AccountId>,\n    Unset<u64>,\n    Unset<E::Balance>,\n    Unset<ExecutionInput<EmptyArgumentList>>,\n    Unset<ReturnType<()>>,\n>\nwhere\n    E: Environment,\n{\n    CallBuilder {\n        env: Default::default(),\n        callee: Default::default(),\n        gas_limit: Default::default(),\n        transferred_value: Default::default(),\n        exec_input: Default::default(),\n        return_type: Default::default(),\n    }\n}\n\n/// Builds up a cross contract call.\npub struct CallBuilder<E, Callee, GasLimit, TransferredValue, Args, RetType>\nwhere\n    E: Environment,\n{\n    env: PhantomData<fn() -> E>,\n    /// The current parameters that have been built up so far.\n    callee: Callee,\n    gas_limit: GasLimit,\n    transferred_value: TransferredValue,\n    exec_input: Args,\n    return_type: RetType,\n}\n\nimpl<E, GasLimit, TransferredValue, Args, RetType>\n    CallBuilder<E, Unset<E::AccountId>, GasLimit, TransferredValue, Args, RetType>\nwhere\n    E: Environment,\n{\n    /// Sets the called smart contract instance account ID to the given value.\n    #[inline]\n    pub fn callee(\n        self,\n        callee: E::AccountId,\n    ) -> CallBuilder<E, Set<E::AccountId>, GasLimit, TransferredValue, Args, RetType>\n    {\n        CallBuilder {\n            env: Default::default(),\n            callee: Set(callee),\n            gas_limit: self.gas_limit,\n            transferred_value: self.transferred_value,\n            exec_input: self.exec_input,\n            return_type: self.return_type,\n        }\n    }\n}\n\nimpl<E, Callee, TransferredValue, Args, RetType>\n    CallBuilder<E, Callee, Unset<u64>, TransferredValue, Args, RetType>\nwhere\n    E: Environment,\n{\n    /// Sets the maximum allowed gas costs for the call.\n    #[inline]\n    pub fn gas_limit(\n        self,\n        gas_limit: u64,\n    ) -> CallBuilder<E, Callee, Set<u64>, TransferredValue, Args, RetType> {\n        CallBuilder {\n            env: Default::default(),\n            callee: self.callee,\n            gas_limit: Set(gas_limit),\n            transferred_value: self.transferred_value,\n            exec_input: self.exec_input,\n            return_type: self.return_type,\n        }\n    }\n}\n\nimpl<E, Callee, GasLimit, Args, RetType>\n    CallBuilder<E, Callee, GasLimit, Unset<E::Balance>, Args, RetType>\nwhere\n    E: Environment,\n{\n    /// Sets the value transferred upon the execution of the call.\n    #[inline]\n    pub fn transferred_value(\n        self,\n        transferred_value: E::Balance,\n    ) -> CallBuilder<E, Callee, GasLimit, Set<E::Balance>, Args, RetType> {\n        CallBuilder {\n            env: Default::default(),\n            callee: self.callee,\n            gas_limit: self.gas_limit,\n            transferred_value: Set(transferred_value),\n            exec_input: self.exec_input,\n            return_type: self.return_type,\n        }\n    }\n}\n\nmod seal {\n    /// Used to prevent users from implementing `IndicateReturnType` for their own types.\n    pub trait Sealed {}\n    impl Sealed for () {}\n    impl<T> Sealed for super::ReturnType<T> {}\n}\n/// Types that can be used in [`CallBuilder::returns`] to signal return type.\npub trait IndicateReturnType: Default + self::seal::Sealed {}\nimpl IndicateReturnType for () {}\nimpl<T> IndicateReturnType for ReturnType<T> {}\n\nimpl<E, Callee, GasLimit, TransferredValue, Args>\n    CallBuilder<E, Callee, GasLimit, TransferredValue, Args, Unset<ReturnType<()>>>\nwhere\n    E: Environment,\n{\n    /// Sets the type of the returned value upon the execution of the call.\n    ///\n    /// # Note\n    ///\n    /// Either use `.returns::<()>` to signal that the call does not return a value\n    /// or use `.returns::<ReturnType<T>>` to signal that the call returns a value of\n    /// type `T`.\n    #[inline]\n    pub fn returns<R>(\n        self,\n    ) -> CallBuilder<E, Callee, GasLimit, TransferredValue, Args, Set<R>>\n    where\n        R: IndicateReturnType,\n    {\n        CallBuilder {\n            env: Default::default(),\n            callee: self.callee,\n            gas_limit: self.gas_limit,\n            transferred_value: self.transferred_value,\n            exec_input: self.exec_input,\n            return_type: Set(Default::default()),\n        }\n    }\n}\n\nimpl<E, Callee, GasLimit, TransferredValue, RetType>\n    CallBuilder<\n        E,\n        Callee,\n        GasLimit,\n        TransferredValue,\n        Unset<ExecutionInput<EmptyArgumentList>>,\n        RetType,\n    >\nwhere\n    E: Environment,\n{\n    /// Sets the execution input to the given value.\n    pub fn exec_input<Args>(\n        self,\n        exec_input: ExecutionInput<Args>,\n    ) -> CallBuilder<\n        E,\n        Callee,\n        GasLimit,\n        TransferredValue,\n        Set<ExecutionInput<Args>>,\n        RetType,\n    > {\n        CallBuilder {\n            env: Default::default(),\n            callee: self.callee,\n            gas_limit: self.gas_limit,\n            transferred_value: self.transferred_value,\n            exec_input: Set(exec_input),\n            return_type: self.return_type,\n        }\n    }\n}\n\nimpl<E, GasLimit, TransferredValue, Args, RetType>\n    CallBuilder<\n        E,\n        Set<E::AccountId>,\n        GasLimit,\n        TransferredValue,\n        Set<ExecutionInput<Args>>,\n        Set<RetType>,\n    >\nwhere\n    E: Environment,\n    GasLimit: Unwrap<Output = u64>,\n    TransferredValue: Unwrap<Output = E::Balance>,\n{\n    /// Finalizes the call builder to call a function.\n    pub fn params(self) -> CallParams<E, Args, RetType> {\n        CallParams {\n            callee: self.callee.value(),\n            gas_limit: self.gas_limit.unwrap_or_else(|| 0),\n            transferred_value: self\n                .transferred_value\n                .unwrap_or_else(|| E::Balance::from(0u32)),\n            return_type: Default::default(),\n            exec_input: self.exec_input.value(),\n        }\n    }\n}\n\nimpl<E, GasLimit, TransferredValue, Args>\n    CallBuilder<\n        E,\n        Set<E::AccountId>,\n        GasLimit,\n        TransferredValue,\n        Set<ExecutionInput<Args>>,\n        Set<()>,\n    >\nwhere\n    E: Environment,\n    GasLimit: Unwrap<Output = u64>,\n    Args: scale::Encode,\n    TransferredValue: Unwrap<Output = E::Balance>,\n{\n    /// Invokes the cross-chain function call.\n    pub fn fire(self) -> Result<(), Error> {\n        self.params().invoke()\n    }\n}\n\nimpl<E, GasLimit, TransferredValue, Args, R>\n    CallBuilder<\n        E,\n        Set<E::AccountId>,\n        GasLimit,\n        TransferredValue,\n        Set<ExecutionInput<Args>>,\n        Set<ReturnType<R>>,\n    >\nwhere\n    E: Environment,\n    GasLimit: Unwrap<Output = u64>,\n    Args: scale::Encode,\n    R: scale::Decode,\n    TransferredValue: Unwrap<Output = E::Balance>,\n{\n    /// Invokes the cross-chain function call and returns the result.\n    pub fn fire(self) -> Result<R, Error> {\n        self.params().eval()\n    }\n}\n"],["883","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::call::Selector;\n\n/// The input data for a smart contract execution.\n#[derive(Debug)]\npub struct ExecutionInput<Args> {\n    /// The selector for the smart contract execution.\n    selector: Selector,\n    /// The arguments of the smart contract execution.\n    args: Args,\n}\n\nimpl ExecutionInput<EmptyArgumentList> {\n    /// Creates a new execution input with the given selector.\n    #[inline]\n    pub fn new(selector: Selector) -> Self {\n        Self {\n            selector,\n            args: ArgumentList::empty(),\n        }\n    }\n\n    /// Pushes an argument to the execution input.\n    #[inline]\n    pub fn push_arg<T>(\n        self,\n        arg: T,\n    ) -> ExecutionInput<ArgumentList<Argument<T>, EmptyArgumentList>>\n    where\n        T: scale::Encode,\n    {\n        ExecutionInput {\n            selector: self.selector,\n            args: self.args.push_arg(arg),\n        }\n    }\n}\n\nimpl<'a, Head, Rest> ExecutionInput<ArgumentList<Argument<Head>, Rest>> {\n    /// Pushes an argument to the execution input.\n    #[inline]\n    pub fn push_arg<T>(self, arg: T) -> ExecutionInput<ArgsList<T, ArgsList<Head, Rest>>>\n    where\n        T: scale::Encode,\n    {\n        ExecutionInput {\n            selector: self.selector,\n            args: self.args.push_arg(arg),\n        }\n    }\n}\n\n/// An argument list.\n///\n/// This type is constructed mainly at compile type via type constructions\n/// to avoid having to allocate heap memory while constructing the encoded\n/// arguments. The potentially heap allocating encoding is done right at the end\n/// where we can leverage the static environmental buffer instead of allocating\n/// heap memory.\n#[derive(Debug)]\npub struct ArgumentList<Head, Rest> {\n    /// The first argument of the argument list.\n    head: Head,\n    /// All the rest arguments.\n    rest: Rest,\n}\n\n/// Minor simplification of an argument list with a head and rest.\npub type ArgsList<Head, Rest> = ArgumentList<Argument<Head>, Rest>;\n\n/// A single argument and its reference to a known value.\n#[derive(Debug)]\npub struct Argument<T> {\n    /// The reference to the known value.\n    ///\n    /// Used for the encoding at the end of the construction.\n    arg: T,\n}\n\nimpl<T> Argument<T> {\n    /// Creates a new argument.\n    #[inline]\n    fn new(arg: T) -> Self {\n        Self { arg }\n    }\n}\n\n/// The end of an argument list.\n#[derive(Debug)]\npub struct ArgumentListEnd;\n\n/// An empty argument list.\npub type EmptyArgumentList = ArgumentList<ArgumentListEnd, ArgumentListEnd>;\n\nimpl EmptyArgumentList {\n    /// Creates a new empty argument list.\n    #[inline]\n    pub fn empty() -> EmptyArgumentList {\n        ArgumentList {\n            head: ArgumentListEnd,\n            rest: ArgumentListEnd,\n        }\n    }\n\n    /// Pushes the first argument to the empty argument list.\n    #[inline]\n    pub fn push_arg<T>(self, arg: T) -> ArgumentList<Argument<T>, Self>\n    where\n        T: scale::Encode,\n    {\n        ArgumentList {\n            head: Argument::new(arg),\n            rest: self,\n        }\n    }\n}\n\nimpl<Head, Rest> ArgumentList<Argument<Head>, Rest> {\n    /// Pushes another argument to the argument list.\n    #[inline]\n    pub fn push_arg<T>(self, arg: T) -> ArgumentList<Argument<T>, Self>\n    where\n        T: scale::Encode,\n    {\n        ArgumentList {\n            head: Argument::new(arg),\n            rest: self,\n        }\n    }\n}\n\nimpl<T> scale::Encode for Argument<T>\nwhere\n    T: scale::Encode,\n{\n    #[inline]\n    fn size_hint(&self) -> usize {\n        <T as scale::Encode>::size_hint(&self.arg)\n    }\n\n    #[inline]\n    fn encode_to<O: scale::Output + ?Sized>(&self, output: &mut O) {\n        <T as scale::Encode>::encode_to(&self.arg, output)\n    }\n}\n\nimpl scale::Encode for EmptyArgumentList {\n    #[inline]\n    fn size_hint(&self) -> usize {\n        0\n    }\n\n    #[inline]\n    fn encode_to<O: scale::Output + ?Sized>(&self, _output: &mut O) {}\n}\n\nimpl<'a, Head, Rest> scale::Encode for ArgumentList<Argument<Head>, Rest>\nwhere\n    Head: scale::Encode,\n    Rest: scale::Encode,\n{\n    #[inline]\n    fn size_hint(&self) -> usize {\n        scale::Encode::size_hint(&self.head) + scale::Encode::size_hint(&self.rest)\n    }\n\n    #[inline]\n    fn encode_to<O: scale::Output + ?Sized>(&self, output: &mut O) {\n        // We reverse the order of encoding because we build up the list of\n        // arguments in reverse order, too. This way we encode the arguments\n        // in the same order in which they have been pushed to the argument list\n        // while the argument list itself organizes them in reverse order.\n        scale::Encode::encode_to(&self.rest, output);\n        scale::Encode::encode_to(&self.head, output);\n    }\n}\n\nimpl<Args> scale::Encode for ExecutionInput<Args>\nwhere\n    Args: scale::Encode,\n{\n    #[inline]\n    fn size_hint(&self) -> usize {\n        scale::Encode::size_hint(&self.selector) + scale::Encode::size_hint(&self.args)\n    }\n\n    #[inline]\n    fn encode_to<O: scale::Output + ?Sized>(&self, output: &mut O) {\n        scale::Encode::encode_to(&self.selector, output);\n        scale::Encode::encode_to(&self.args, output);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn empty_exec_input_works() {\n        let selector = Selector::new([0x01, 0x02, 0x03, 0x04]);\n        let exec_input = ExecutionInput::new(selector);\n        let encoded = scale::Encode::encode(&exec_input);\n        assert!(!encoded.is_empty());\n        let decoded = <Selector as scale::Decode>::decode(&mut &encoded[..]).unwrap();\n        assert_eq!(decoded, selector);\n    }\n\n    #[test]\n    fn empty_args_works() {\n        let empty_list = ArgumentList::empty();\n        let encoded = scale::Encode::encode(&empty_list);\n        assert_eq!(encoded, <Vec<u8>>::new());\n    }\n\n    #[test]\n    fn single_argument_works() {\n        let empty_list = ArgumentList::empty().push_arg(&1i32);\n        let encoded = scale::Encode::encode(&empty_list);\n        assert!(!encoded.is_empty());\n        let decoded = <i32 as scale::Decode>::decode(&mut &encoded[..]).unwrap();\n        assert_eq!(decoded, 1i32);\n    }\n\n    #[test]\n    fn multiple_arguments_works() {\n        let empty_list = ArgumentList::empty()\n            .push_arg(&42i32)\n            .push_arg(&true)\n            .push_arg(&[0x66u8; 4]);\n        let encoded = scale::Encode::encode(&empty_list);\n        assert!(!encoded.is_empty());\n        let decoded =\n            <(i32, bool, [u8; 4]) as scale::Decode>::decode(&mut &encoded[..]).unwrap();\n        assert_eq!(decoded, (42i32, true, [0x66; 4]));\n    }\n}\n"],["884","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Utilities to call or instantiate contracts on the chain.\n\nmod call_builder;\nmod common;\nmod create_builder;\nmod execution_input;\nmod selector;\n\n/// Utility types for the cross-contract calling API.\npub mod utils {\n    pub use super::{\n        call_builder::IndicateReturnType,\n        common::{\n            ReturnType,\n            Set,\n            Unset,\n            Unwrap,\n        },\n        execution_input::{\n            ArgsList,\n            Argument,\n            ArgumentList,\n            ArgumentListEnd,\n            EmptyArgumentList,\n        },\n    };\n}\n\npub use self::{\n    call_builder::{\n        build_call,\n        CallBuilder,\n        CallParams,\n    },\n    create_builder::{\n        build_create,\n        state,\n        CreateBuilder,\n        CreateParams,\n        FromAccountId,\n    },\n    execution_input::ExecutionInput,\n    selector::Selector,\n};\n"],["885","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::{\n    call::{\n        utils::{\n            EmptyArgumentList,\n            ReturnType,\n            Set,\n            Unset,\n            Unwrap,\n        },\n        ExecutionInput,\n    },\n    Environment,\n    Error,\n};\nuse core::marker::PhantomData;\n\npub mod state {\n    //! Type states that tell what state of a instantiation argument has not\n    //! yet been set properly for a valid construction.\n\n    /// Type state for the salt used for contract instantiation.\n    pub enum Salt {}\n}\n\n/// Contracts that can be constructed from an `AccountId`.\n///\n/// # Note\n///\n/// This is needed because of conflicting implementations of `From<T> for T`\n/// in the generated code of `ink_lang`.\npub trait FromAccountId<T>\nwhere\n    T: Environment,\n{\n    /// Creates the contract instance from the account ID of the already instantiated contract.\n    fn from_account_id(account_id: <T as Environment>::AccountId) -> Self;\n}\n\n/// Builds up contract instantiations.\n#[derive(Debug)]\npub struct CreateParams<E, Args, Salt, R>\nwhere\n    E: Environment,\n{\n    /// The code hash of the created contract.\n    code_hash: E::Hash,\n    /// The maximum gas costs allowed for the instantiation.\n    gas_limit: u64,\n    /// The endowment for the instantiated contract.\n    endowment: E::Balance,\n    /// The input data for the instantiation.\n    exec_input: ExecutionInput<Args>,\n    /// The salt for determining the hash for the contract account ID.\n    salt_bytes: Salt,\n    /// The type of the instantiated contract.\n    return_type: ReturnType<R>,\n}\n\ncfg_if::cfg_if! {\n    // We do not currently support cross-contract instantiation in the off-chain\n    // environment so we do not have to provide these getters in case of\n    // off-chain environment compilation.\n    if #[cfg(all(not(feature = \"std\"), target_arch = \"wasm32\"))] {\n        impl<E, Args, Salt, R> CreateParams<E, Args, Salt, R>\n        where\n            E: Environment,\n        {\n            /// The code hash of the contract.\n            #[inline]\n            pub(crate) fn code_hash(&self) -> &E::Hash {\n                &self.code_hash\n            }\n\n            /// The gas limit for the contract instantiation.\n            #[inline]\n            pub(crate) fn gas_limit(&self) -> u64 {\n                self.gas_limit\n            }\n\n            /// The endowment for the instantiated contract.\n            #[inline]\n            pub(crate) fn endowment(&self) -> &E::Balance {\n                &self.endowment\n            }\n\n            /// The raw encoded input data.\n            #[inline]\n            pub(crate) fn exec_input(&self) -> &ExecutionInput<Args> {\n                &self.exec_input\n            }\n        }\n\n        impl<E, Args, Salt, R> CreateParams<E, Args, Salt, R>\n        where\n            E: Environment,\n            Salt: AsRef<[u8]>,\n        {\n            /// The salt for determining the hash for the contract account ID.\n            #[inline]\n            pub(crate) fn salt_bytes(&self) -> &Salt {\n                &self.salt_bytes\n            }\n        }\n    }\n}\n\nimpl<E, Args, Salt, R> CreateParams<E, Args, Salt, R>\nwhere\n    E: Environment,\n    Args: scale::Encode,\n    Salt: AsRef<[u8]>,\n    R: FromAccountId<E>,\n{\n    /// Instantiates the contract and returns its account ID back to the caller.\n    #[inline]\n    pub fn instantiate(&self) -> Result<R, crate::Error> {\n        crate::instantiate_contract(self).map(FromAccountId::from_account_id)\n    }\n}\n\n/// Builds up contract instantiations.\npub struct CreateBuilder<E, CodeHash, GasLimit, Endowment, Args, Salt, R>\nwhere\n    E: Environment,\n{\n    env: PhantomData<fn() -> E>,\n    code_hash: CodeHash,\n    gas_limit: GasLimit,\n    endowment: Endowment,\n    exec_input: Args,\n    salt: Salt,\n    return_type: ReturnType<R>,\n}\n\n/// Returns a new [`CreateBuilder`] to build up the parameters to a cross-contract instantiation.\n///\n/// # Example\n///\n/// The below example shows instantiation of contract of type `MyContract`.\n///\n/// The used constructor ...\n///\n/// - has a selector equal to `0xDEADBEEF`\n/// - is provided with 4000 units of gas for its execution\n/// - is provided with 25 units of transferred value for the new contract instance\n/// - receives the following arguments in order\n///    1. an `i32` with value `42`\n///    2. a `bool` with value `true`\n///    3. an array of 32 `u8` with value `0x10`\n///\n/// ```should_panic\n/// # use ::ink_env::{\n/// #     Environment,\n/// #     DefaultEnvironment,\n/// #     call::{build_create, Selector, ExecutionInput, FromAccountId}\n/// # };\n/// # type Hash = <DefaultEnvironment as Environment>::Hash;\n/// # type AccountId = <DefaultEnvironment as Environment>::AccountId;\n/// # type Salt = &'static [u8];\n/// # struct MyContract;\n/// # impl FromAccountId<DefaultEnvironment> for MyContract {\n/// #     fn from_account_id(account_id: AccountId) -> Self { Self }\n/// # }\n/// let my_contract: MyContract = build_create::<DefaultEnvironment, MyContract>()\n///     .code_hash(Hash::from([0x42; 32]))\n///     .gas_limit(4000)\n///     .endowment(25)\n///     .exec_input(\n///         ExecutionInput::new(Selector::new([0xDE, 0xAD, 0xBE, 0xEF]))\n///             .push_arg(42)\n///             .push_arg(true)\n///             .push_arg(&[0x10u8; 32])\n///     )\n///     .salt_bytes(&[0xDE, 0xAD, 0xBE, 0xEF])\n///     .params()\n///     .instantiate()\n///     .unwrap();\n/// ```\n///\n/// **Note:** The shown example panics because there is currently no cross-calling\n///           support in the off-chain testing environment. However, this code\n///           should work fine in on-chain environments.\n#[allow(clippy::type_complexity)]\npub fn build_create<E, R>() -> CreateBuilder<\n    E,\n    Unset<E::Hash>,\n    Unset<u64>,\n    Unset<E::Balance>,\n    Unset<ExecutionInput<EmptyArgumentList>>,\n    Unset<state::Salt>,\n    R,\n>\nwhere\n    E: Environment,\n    R: FromAccountId<E>,\n{\n    CreateBuilder {\n        env: Default::default(),\n        code_hash: Default::default(),\n        gas_limit: Default::default(),\n        endowment: Default::default(),\n        exec_input: Default::default(),\n        salt: Default::default(),\n        return_type: Default::default(),\n    }\n}\n\nimpl<E, GasLimit, Endowment, Args, Salt, R>\n    CreateBuilder<E, Unset<E::Hash>, GasLimit, Endowment, Args, Salt, R>\nwhere\n    E: Environment,\n{\n    /// Sets the used code hash for the contract instantiation.\n    #[inline]\n    pub fn code_hash(\n        self,\n        code_hash: E::Hash,\n    ) -> CreateBuilder<E, Set<E::Hash>, GasLimit, Endowment, Args, Salt, R> {\n        CreateBuilder {\n            env: Default::default(),\n            code_hash: Set(code_hash),\n            gas_limit: self.gas_limit,\n            endowment: self.endowment,\n            exec_input: self.exec_input,\n            salt: self.salt,\n            return_type: self.return_type,\n        }\n    }\n}\n\nimpl<E, CodeHash, Endowment, Args, Salt, R>\n    CreateBuilder<E, CodeHash, Unset<u64>, Endowment, Args, Salt, R>\nwhere\n    E: Environment,\n{\n    /// Sets the maximum allowed gas costs for the contract instantiation.\n    #[inline]\n    pub fn gas_limit(\n        self,\n        gas_limit: u64,\n    ) -> CreateBuilder<E, CodeHash, Set<u64>, Endowment, Args, Salt, R> {\n        CreateBuilder {\n            env: Default::default(),\n            code_hash: self.code_hash,\n            gas_limit: Set(gas_limit),\n            endowment: self.endowment,\n            exec_input: self.exec_input,\n            salt: self.salt,\n            return_type: self.return_type,\n        }\n    }\n}\n\nimpl<E, CodeHash, GasLimit, Args, Salt, R>\n    CreateBuilder<E, CodeHash, GasLimit, Unset<E::Balance>, Args, Salt, R>\nwhere\n    E: Environment,\n{\n    /// Sets the value transferred upon the execution of the call.\n    #[inline]\n    pub fn endowment(\n        self,\n        endowment: E::Balance,\n    ) -> CreateBuilder<E, CodeHash, GasLimit, Set<E::Balance>, Args, Salt, R> {\n        CreateBuilder {\n            env: Default::default(),\n            code_hash: self.code_hash,\n            gas_limit: self.gas_limit,\n            endowment: Set(endowment),\n            exec_input: self.exec_input,\n            salt: self.salt,\n            return_type: self.return_type,\n        }\n    }\n}\n\nimpl<E, CodeHash, GasLimit, Endowment, Salt, R>\n    CreateBuilder<\n        E,\n        CodeHash,\n        GasLimit,\n        Endowment,\n        Unset<ExecutionInput<EmptyArgumentList>>,\n        Salt,\n        R,\n    >\nwhere\n    E: Environment,\n{\n    /// Sets the value transferred upon the execution of the call.\n    #[inline]\n    pub fn exec_input<Args>(\n        self,\n        exec_input: ExecutionInput<Args>,\n    ) -> CreateBuilder<E, CodeHash, GasLimit, Endowment, Set<ExecutionInput<Args>>, Salt, R>\n    {\n        CreateBuilder {\n            env: Default::default(),\n            code_hash: self.code_hash,\n            gas_limit: self.gas_limit,\n            endowment: self.endowment,\n            exec_input: Set(exec_input),\n            salt: self.salt,\n            return_type: self.return_type,\n        }\n    }\n}\n\nimpl<E, CodeHash, GasLimit, Endowment, Args, R>\n    CreateBuilder<E, CodeHash, GasLimit, Endowment, Args, Unset<state::Salt>, R>\nwhere\n    E: Environment,\n{\n    /// Sets the value transferred upon the execution of the call.\n    #[inline]\n    pub fn salt_bytes<Salt>(\n        self,\n        salt: Salt,\n    ) -> CreateBuilder<E, CodeHash, GasLimit, Endowment, Args, Set<Salt>, R>\n    where\n        Salt: AsRef<[u8]>,\n    {\n        CreateBuilder {\n            env: Default::default(),\n            code_hash: self.code_hash,\n            gas_limit: self.gas_limit,\n            endowment: self.endowment,\n            exec_input: self.exec_input,\n            salt: Set(salt),\n            return_type: self.return_type,\n        }\n    }\n}\n\nimpl<E, GasLimit, Args, Salt, R>\n    CreateBuilder<\n        E,\n        Set<E::Hash>,\n        GasLimit,\n        Set<E::Balance>,\n        Set<ExecutionInput<Args>>,\n        Set<Salt>,\n        R,\n    >\nwhere\n    E: Environment,\n    GasLimit: Unwrap<Output = u64>,\n{\n    /// Sets the value transferred upon the execution of the call.\n    #[inline]\n    pub fn params(self) -> CreateParams<E, Args, Salt, R> {\n        CreateParams {\n            code_hash: self.code_hash.value(),\n            gas_limit: self.gas_limit.unwrap_or_else(|| 0),\n            endowment: self.endowment.value(),\n            exec_input: self.exec_input.value(),\n            salt_bytes: self.salt.value(),\n            return_type: self.return_type,\n        }\n    }\n}\n\nimpl<E, GasLimit, Args, Salt, R>\n    CreateBuilder<\n        E,\n        Set<E::Hash>,\n        GasLimit,\n        Set<E::Balance>,\n        Set<ExecutionInput<Args>>,\n        Set<Salt>,\n        R,\n    >\nwhere\n    E: Environment,\n    GasLimit: Unwrap<Output = u64>,\n    Args: scale::Encode,\n    Salt: AsRef<[u8]>,\n    R: FromAccountId<E>,\n{\n    /// Instantiates the contract using the given instantiation parameters.\n    #[inline]\n    pub fn instantiate(self) -> Result<R, Error> {\n        self.params().instantiate()\n    }\n}\n"],["886","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse derive_more::From;\n\n#[cfg(any(feature = \"std\", test, doc))]\nuse crate::engine::off_chain::OffChainError;\n\n/// Errors that can be encountered upon environmental interaction.\n#[derive(Debug, From, PartialEq, Eq)]\npub enum Error {\n    /// Error upon decoding an encoded value.\n    Decode(scale::Error),\n    /// An error that can only occure in the off-chain environment.\n    #[cfg(any(feature = \"std\", test, doc))]\n    OffChain(OffChainError),\n    /// The call to another contract has trapped.\n    CalleeTrapped,\n    /// The call to another contract has been reverted.\n    CalleeReverted,\n    /// The queried contract storage entry is missing.\n    KeyNotFound,\n    /// Transfer failed because it would have brought the sender's total balance\n    /// below the subsistence threshold.\n    BelowSubsistenceThreshold,\n    /// Transfer failed for other not further specified reason. Most probably\n    /// reserved or locked balance of the sender that was preventing the transfer.\n    TransferFailed,\n    /// The newly created contract is below the subsistence threshold after executing\n    /// its constructor so no usable contract instance will be created.\n    NewContractNotFunded,\n    /// No code could be found at the supplied code hash.\n    CodeNotFound,\n    /// The account that was called is either no contract (e.g. user account) or is a tombstone.\n    NotCallable,\n    /// An unknown error has occured.\n    UnknownError,\n}\n\n/// A result of environmental operations.\npub type Result<T> = core::result::Result<T, Error>;\n"],["887","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Primitive traits for runtime arithmetic, copied from substrate\n\nuse core::{\n    convert::{\n        TryFrom,\n        TryInto,\n    },\n    ops::{\n        Add,\n        AddAssign,\n        Div,\n        DivAssign,\n        Mul,\n        MulAssign,\n        Sub,\n        SubAssign,\n    },\n};\nuse num_traits::{\n    checked_pow,\n    Bounded,\n    CheckedMul,\n    One,\n    Unsigned,\n    Zero,\n};\n\n/// Types that allow for simple arithmetic operations.\n///\n/// Subset of all trait bounds copied over from what Substrate defines\n/// for its `BaseArithmetic` types. We can extend this in the future\n/// if needed.\npub trait BaseArithmetic:\n    Sized\n    + From<u8>\n    + Bounded\n    + Ord\n    + PartialOrd<Self>\n    + Zero\n    + One\n    + Bounded\n    + Add<Self, Output = Self>\n    + AddAssign<Self>\n    + Sub<Self, Output = Self>\n    + SubAssign<Self>\n    + Mul<Self, Output = Self>\n    + MulAssign<Self>\n    + Div<Self, Output = Self>\n    + DivAssign<Self>\n    + CheckedMul\n    + Saturating\n    + TryFrom<u16>\n    + TryFrom<u32>\n    + TryFrom<u64>\n    + TryFrom<u128>\n    + TryFrom<usize>\n    + TryInto<u16>\n    + TryInto<u32>\n    + TryInto<u64>\n    + TryInto<u128>\n    + TryInto<usize>\n// Further trait bounds from the original BaseArithmetic trait\n// that we could use to extend ink!'s BaseArithmetic trait.\n//\n// UniqueSaturatedInto<u8> +\n// UniqueSaturatedInto<u16> +\n// UniqueSaturatedInto<u32> +\n// UniqueSaturatedInto<u64> +\n// UniqueSaturatedInto<u128> +\n// UniqueSaturatedFrom<u64> +\n// UniqueSaturatedFrom<u128> +\n// Shl<u32, Output = Self> +\n// Shr<u32, Output = Self> +\n// CheckedAdd +\n// CheckedSub +\n// CheckedDiv +\n// CheckedShl +\n// CheckedShr +\n// IntegerSquareRoot +\n{\n}\n\nimpl<T> BaseArithmetic for T where\n    T: Sized\n        + From<u8>\n        + Bounded\n        + Ord\n        + PartialOrd<Self>\n        + Zero\n        + One\n        + Add<Self, Output = Self>\n        + AddAssign<Self>\n        + Sub<Self, Output = Self>\n        + SubAssign<Self>\n        + Mul<Self, Output = Self>\n        + MulAssign<Self>\n        + Div<Self, Output = Self>\n        + DivAssign<Self>\n        + CheckedMul\n        + Saturating\n        + TryFrom<u16>\n        + TryFrom<u32>\n        + TryFrom<u64>\n        + TryFrom<u128>\n        + TryFrom<usize>\n        + TryInto<u16>\n        + TryInto<u32>\n        + TryInto<u64>\n        + TryInto<u128>\n        + TryInto<usize>\n{\n}\n\n/// A meta trait for arithmetic (copied from substrate).\n///\n/// Arithmetic types do all the usual stuff you'd expect numbers to do. They are guaranteed to\n/// be able to represent at least `u32` values without loss, hence the trait implies `From<u32>`\n/// and smaller integers. All other conversions are fallible.\npub trait AtLeast32Bit: BaseArithmetic + From<u16> + From<u32> {}\n\nimpl<T> AtLeast32Bit for T where T: BaseArithmetic + From<u16> + From<u32> {}\n\n/// A meta trait for arithmetic.  Same as [`AtLeast32Bit `], but also bounded to be unsigned.\npub trait AtLeast32BitUnsigned: AtLeast32Bit + Unsigned {}\n\nimpl<T> AtLeast32BitUnsigned for T where T: AtLeast32Bit + Unsigned {}\n\n/// Saturating arithmetic operations, returning maximum or minimum values instead of overflowing.\npub trait Saturating {\n    /// Saturating addition. Compute `self + rhs`, saturating at the numeric bounds instead of\n    /// overflowing.\n    fn saturating_add(self, rhs: Self) -> Self;\n\n    /// Saturating subtraction. Compute `self - rhs`, saturating at the numeric bounds instead of\n    /// overflowing.\n    fn saturating_sub(self, rhs: Self) -> Self;\n\n    /// Saturating multiply. Compute `self * rhs`, saturating at the numeric bounds instead of\n    /// overflowing.\n    fn saturating_mul(self, rhs: Self) -> Self;\n\n    /// Saturating exponentiation. Compute `self.pow(exp)`, saturating at the numeric bounds\n    /// instead of overflowing.\n    fn saturating_pow(self, exp: usize) -> Self;\n}\n\nimpl<T> Saturating for T\nwhere\n    T: Clone + Zero + One + PartialOrd + CheckedMul + Bounded + num_traits::Saturating,\n{\n    fn saturating_add(self, o: Self) -> Self {\n        <Self as num_traits::Saturating>::saturating_add(self, o)\n    }\n\n    fn saturating_sub(self, o: Self) -> Self {\n        <Self as num_traits::Saturating>::saturating_sub(self, o)\n    }\n\n    fn saturating_mul(self, o: Self) -> Self {\n        self.checked_mul(&o).unwrap_or_else(|| {\n            if (self < T::zero()) != (o < T::zero()) {\n                Bounded::min_value()\n            } else {\n                Bounded::max_value()\n            }\n        })\n    }\n\n    fn saturating_pow(self, exp: usize) -> Self {\n        let neg = self < T::zero() && exp % 2 != 0;\n        checked_pow(self, exp).unwrap_or_else(|| {\n            if neg {\n                Bounded::min_value()\n            } else {\n                Bounded::max_value()\n            }\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Saturating;\n\n    #[test]\n    fn saturating_add() {\n        assert_eq!(\n            u64::max_value(),\n            Saturating::saturating_add(u64::max_value(), 1)\n        )\n    }\n\n    #[test]\n    fn saturatiung_sub() {\n        assert_eq!(\n            u64::min_value(),\n            Saturating::saturating_sub(u64::min_value(), 1)\n        )\n    }\n\n    #[test]\n    fn saturating_mul() {\n        assert_eq!(\n            u64::max_value(),\n            Saturating::saturating_mul(u64::max_value(), 2)\n        );\n        assert_eq!(\n            i64::min_value(),\n            Saturating::saturating_mul(i64::min_value(), 2)\n        );\n        assert_eq!(\n            i64::min_value(),\n            Saturating::saturating_mul(2, i64::min_value())\n        );\n    }\n\n    #[test]\n    fn saturating_pow() {\n        assert_eq!(\n            u64::max_value(),\n            Saturating::saturating_pow(u64::max_value(), 2)\n        );\n        assert_eq!(\n            i64::max_value(),\n            Saturating::saturating_pow(i64::min_value(), 2)\n        );\n        assert_eq!(\n            i64::min_value(),\n            Saturating::saturating_pow(i64::min_value(), 3)\n        );\n    }\n}\n"],["888","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! The public raw interface towards the host Wasm engine.\n\nuse crate::{\n    backend::{\n        EnvBackend,\n        ReturnFlags,\n        TypedEnvBackend,\n    },\n    call::{\n        utils::ReturnType,\n        CallParams,\n        CreateParams,\n    },\n    engine::{\n        EnvInstance,\n        OnInstance,\n    },\n    hash::{\n        CryptoHash,\n        HashOutput,\n    },\n    topics::Topics,\n    Environment,\n    Result,\n};\nuse ink_primitives::Key;\n\n/// Returns the address of the caller of the executed contract.\n///\n/// # Errors\n///\n/// If the returned caller cannot be properly decoded.\npub fn caller<T>() -> Result<T::AccountId>\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        TypedEnvBackend::caller::<T>(instance)\n    })\n}\n\n/// Returns the transferred balance for the contract execution.\n///\n/// # Errors\n///\n/// If the returned value cannot be properly decoded.\npub fn transferred_balance<T>() -> Result<T::Balance>\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        TypedEnvBackend::transferred_balance::<T>(instance)\n    })\n}\n\n/// Returns the price for the specified amount of gas.\n///\n/// # Errors\n///\n/// If the returned value cannot be properly decoded.\npub fn weight_to_fee<T>(gas: u64) -> Result<T::Balance>\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        TypedEnvBackend::weight_to_fee::<T>(instance, gas)\n    })\n}\n\n/// Returns the amount of gas left for the contract execution.\n///\n/// # Errors\n///\n/// If the returned value cannot be properly decoded.\npub fn gas_left<T>() -> Result<T::Balance>\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        TypedEnvBackend::gas_left::<T>(instance)\n    })\n}\n\n/// Returns the current block timestamp.\n///\n/// # Errors\n///\n/// If the returned value cannot be properly decoded.\npub fn block_timestamp<T>() -> Result<T::Timestamp>\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        TypedEnvBackend::block_timestamp::<T>(instance)\n    })\n}\n\n/// Returns the account ID of the executed contract.\n///\n/// # Note\n///\n/// This method was formerly known as `address`.\n///\n/// # Errors\n///\n/// If the returned value cannot be properly decoded.\npub fn account_id<T>() -> Result<T::AccountId>\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        TypedEnvBackend::account_id::<T>(instance)\n    })\n}\n\n/// Returns the balance of the executed contract.\n///\n/// # Errors\n///\n/// If the returned value cannot be properly decoded.\npub fn balance<T>() -> Result<T::Balance>\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        TypedEnvBackend::balance::<T>(instance)\n    })\n}\n\n/// Returns the current rent allowance for the executed contract.\n///\n/// # Errors\n///\n/// If the returned value cannot be properly decoded.\npub fn rent_allowance<T>() -> Result<T::Balance>\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        TypedEnvBackend::rent_allowance::<T>(instance)\n    })\n}\n\n/// Returns the current block number.\n///\n/// # Errors\n///\n/// If the returned value cannot be properly decoded.\npub fn block_number<T>() -> Result<T::BlockNumber>\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        TypedEnvBackend::block_number::<T>(instance)\n    })\n}\n\n/// Returns the minimum balance that is required for creating an account.\n///\n/// # Errors\n///\n/// If the returned value cannot be properly decoded.\npub fn minimum_balance<T>() -> Result<T::Balance>\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        TypedEnvBackend::minimum_balance::<T>(instance)\n    })\n}\n\n/// Returns the tombstone deposit for the contracts chain.\n///\n/// # Errors\n///\n/// If the returned value cannot be properly decoded.\npub fn tombstone_deposit<T>() -> Result<T::Balance>\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        TypedEnvBackend::tombstone_deposit::<T>(instance)\n    })\n}\n\n/// Emits an event with the given event data.\npub fn emit_event<T, Event>(event: Event)\nwhere\n    T: Environment,\n    Event: Topics + scale::Encode,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        TypedEnvBackend::emit_event::<T, Event>(instance, event)\n    })\n}\n\n/// Sets the rent allowance of the executed contract to the new value.\npub fn set_rent_allowance<T>(new_value: T::Balance)\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        TypedEnvBackend::set_rent_allowance::<T>(instance, new_value)\n    })\n}\n\n/// Writes the value to the contract storage under the given key.\n///\n/// # Panics\n///\n/// - If the encode length of value exceeds the configured maximum value length of a storage entry.\npub fn set_contract_storage<V>(key: &Key, value: &V)\nwhere\n    V: scale::Encode,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        EnvBackend::set_contract_storage::<V>(instance, key, value)\n    })\n}\n\n/// Returns the value stored under the given key in the contract's storage if any.\n///\n/// # Errors\n///\n/// - If the decoding of the typed value failed (`KeyNotFound`)\npub fn get_contract_storage<R>(key: &Key) -> Result<Option<R>>\nwhere\n    R: scale::Decode,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        EnvBackend::get_contract_storage::<R>(instance, key)\n    })\n}\n\n/// Clears the contract's storage key entry.\npub fn clear_contract_storage(key: &Key) {\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        EnvBackend::clear_contract_storage(instance, key)\n    })\n}\n\n/// Invokes a contract message.\n///\n/// # Note\n///\n/// - Prefer using this over [`eval_contract`] if possible. [`invoke_contract`]\n///   will generally have a better performance since it won't try to fetch any results.\n/// - This is a low level way to invoke another smart contract.\n///   Prefer to use the ink! guided and type safe approach to using this.\n///\n/// # Errors\n///\n/// - If the called account does not exist.\n/// - If the called account is not a contract.\n/// - If the called contract is a tombstone.\n/// - If arguments passed to the called contract message are invalid.\n/// - If the called contract execution has trapped.\n/// - If the called contract ran out of gas upon execution.\npub fn invoke_contract<T, Args>(params: &CallParams<T, Args, ()>) -> Result<()>\nwhere\n    T: Environment,\n    Args: scale::Encode,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        TypedEnvBackend::invoke_contract::<T, Args>(instance, params)\n    })\n}\n\n/// Evaluates a contract message and returns its result.\n///\n/// # Note\n///\n/// This is a low level way to evaluate another smart contract.\n/// Prefer to use the ink! guided and type safe approach to using this.\n///\n/// # Errors\n///\n/// - If the called account does not exist.\n/// - If the called account is not a contract.\n/// - If the called contract is a tombstone.\n/// - If arguments passed to the called contract message are invalid.\n/// - If the called contract execution has trapped.\n/// - If the called contract ran out of gas upon execution.\n/// - If the returned value failed to decode properly.\npub fn eval_contract<T, Args, R>(params: &CallParams<T, Args, ReturnType<R>>) -> Result<R>\nwhere\n    T: Environment,\n    Args: scale::Encode,\n    R: scale::Decode,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        TypedEnvBackend::eval_contract::<T, Args, R>(instance, params)\n    })\n}\n\n/// Instantiates another contract.\n///\n/// # Note\n///\n/// This is a low level way to instantiate another smart contract.\n/// Prefer to use the ink! guided and type safe approach to using this.\n///\n/// # Errors\n///\n/// - If the code hash is invalid.\n/// - If the arguments passed to the instantiation process are invalid.\n/// - If the instantiation process traps.\n/// - If the instantiation process runs out of gas.\n/// - If given insufficient endowment.\n/// - If the returned account ID failed to decode properly.\npub fn instantiate_contract<T, Args, Salt, C>(\n    params: &CreateParams<T, Args, Salt, C>,\n) -> Result<T::AccountId>\nwhere\n    T: Environment,\n    Args: scale::Encode,\n    Salt: AsRef<[u8]>,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        TypedEnvBackend::instantiate_contract::<T, Args, Salt, C>(instance, params)\n    })\n}\n\n/// Restores a smart contract in tombstone state.\n///\n/// # Params\n///\n/// - `account_id`: Account ID of the to-be-restored contract.\n/// - `code_hash`: Code hash of the to-be-restored contract.\n/// - `rent_allowance`: Rent allowance of the restored contract\n///                     upon successful restoration.\n/// - `filtered_keys`: Storage keys to be excluded when calculating the tombstone hash,\n///                    which is used to decide whether the original contract and the\n///                    to-be-restored contract have matching storage.\n///\n/// # Usage\n///\n/// A smart contract that has too few funds to pay for its storage fees\n/// can eventually be evicted. An evicted smart contract `C` leaves behind\n/// a tombstone associated with a hash that has been computed partially\n/// by its storage contents.\n///\n/// To restore contract `C` back to a fully working contract the normal\n/// process is to write another contract `C2` with the only purpose to\n/// eventually have the absolutely same contract storage as `C` did when\n/// it was evicted.\n/// For that purpose `C2` can use other storage keys that have not been in\n/// use by contract `C`.\n/// Once `C2` contract storage matches the storage of `C` when it was evicted\n/// `C2` can invoke this method in order to initiate restoration of `C`.\n/// A tombstone hash is calculated for `C2` and if it matches the tombstone\n/// hash of `C` the restoration is going to be successful.\n/// The `filtered_keys` argument can be used to ignore the extraneous keys\n/// used by `C2` but not used by `C`.\n///\n/// The process of such a smart contract restoration can generally be very expensive.\n///\n/// # Note\n///\n/// - The `filtered_keys` can be used to ignore certain storage regions\n///   in the restorer contract to not influence the hash calculations.\n/// - Does *not* perform restoration right away but defers it to the end of\n///   the contract execution.\n/// - Restoration is cancelled if there is no tombstone in the destination\n///   address or if the hashes don't match. No changes are made in this case.\npub fn restore_contract<T>(\n    account_id: T::AccountId,\n    code_hash: T::Hash,\n    rent_allowance: T::Balance,\n    filtered_keys: &[Key],\n) where\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        TypedEnvBackend::restore_contract::<T>(\n            instance,\n            account_id,\n            code_hash,\n            rent_allowance,\n            filtered_keys,\n        )\n    })\n}\n\n/// Terminates the existence of the currently executed smart contract.\n///\n/// This removes the calling account and transfers all remaining balance\n/// to the given beneficiary.\n///\n/// # Note\n///\n/// This function never returns. Either the termination was successful and the\n/// execution of the destroyed contract is halted. Or it failed during the termination\n/// which is considered fatal and results in a trap + rollback.\npub fn terminate_contract<T>(beneficiary: T::AccountId) -> !\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        TypedEnvBackend::terminate_contract::<T>(instance, beneficiary)\n    })\n}\n\n/// Transfers value from the contract to the destination account ID.\n///\n/// # Note\n///\n/// This is more efficient and simpler than the alternative to make a no-op\n/// contract call or invoke a runtime function that performs the\n/// transaction.\n///\n/// # Errors\n///\n/// - If the contract doesn't have sufficient funds.\n/// - If the transfer would have brought the sender's total balance below the\n///   subsistence threshold.\npub fn transfer<T>(destination: T::AccountId, value: T::Balance) -> Result<()>\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        TypedEnvBackend::transfer::<T>(instance, destination, value)\n    })\n}\n\n/// Returns the execution input to the executed contract and decodes it as `T`.\n///\n/// # Note\n///\n/// - The input is the 4-bytes selector followed by the arguments\n///   of the called function in their SCALE encoded representation.\n/// - No prior interaction with the environment must take place before\n///   calling this procedure.\n///\n/// # Usage\n///\n/// Normally contracts define their own `enum` dispatch types respective\n/// to their exported contructors and messages that implement `scale::Decode`\n/// according to the contructors or messages selectors and their arguments.\n/// These `enum` dispatch types are then given to this procedure as the `T`.\n///\n/// When using ink! users do not have to construct those enum dispatch types\n/// themselves as they are normally generated by the ink! code generation\n/// automatically.\n///\n/// # Errors\n///\n/// If the given `T` cannot be properly decoded from the expected input.\npub fn decode_input<T>() -> Result<T>\nwhere\n    T: scale::Decode,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        EnvBackend::decode_input::<T>(instance)\n    })\n}\n\n/// Returns the value back to the caller of the executed contract.\n///\n/// # Note\n///\n/// This function  stops the execution of the contract immediately.\npub fn return_value<R>(return_flags: ReturnFlags, return_value: &R) -> !\nwhere\n    R: scale::Encode,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        EnvBackend::return_value::<R>(instance, return_flags, return_value)\n    })\n}\n\n/// Returns a random hash seed.\n///\n/// # Note\n///\n/// - The subject buffer can be used to further randomize the hash.\n/// - Within the same execution returns the same random hash for the same subject.\n///\n/// # Errors\n///\n/// If the returned value cannot be properly decoded.\npub fn random<T>(subject: &[u8]) -> Result<T::Hash>\nwhere\n    T: Environment,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        TypedEnvBackend::random::<T>(instance, subject)\n    })\n}\n\n/// Prints the given contents to the environmental log.\npub fn debug_println(content: &str) {\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        EnvBackend::println(instance, content)\n    })\n}\n\n/// Conducts the crypto hash of the given input and stores the result in `output`.\npub fn hash_bytes<H>(input: &[u8], output: &mut <H as HashOutput>::Type)\nwhere\n    H: CryptoHash,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        instance.hash_bytes::<H>(input, output)\n    })\n}\n\n/// Conducts the crypto hash of the given encoded input and stores the result in `output`.\n///\n/// # Example\n///\n/// ```\n/// # use ink_env::hash::{Sha2x256, HashOutput};\n/// const EXPECTED: [u8; 32] = [\n///   243, 242, 58, 110, 205, 68, 100, 244, 187, 55, 188, 248,  29, 136, 145, 115,\n///   186, 134, 14, 175, 178, 99, 183,  21,   4, 94,  92,  69, 199, 207, 241, 179,\n/// ];\n/// let encodable = (42, \"foo\", true); // Implements `scale::Encode`\n/// let mut output = <Sha2x256 as HashOutput>::Type::default(); // 256-bit buffer\n/// ink_env::hash_encoded::<Sha2x256, _>(&encodable, &mut output);\n/// assert_eq!(output, EXPECTED);\n/// ```\npub fn hash_encoded<H, T>(input: &T, output: &mut <H as HashOutput>::Type)\nwhere\n    H: CryptoHash,\n    T: scale::Encode,\n{\n    <EnvInstance as OnInstance>::on_instance(|instance| {\n        instance.hash_encoded::<H, T>(input, output)\n    })\n}\n"],["889","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nstatic TEST_INPUT: &[u8] = b\"DEAD_BEEF\";\n\n#[test]\nfn test_hash_keccak_256() {\n    let mut output = [0x00_u8; 32];\n    crate::hash_bytes::<crate::hash::Keccak256>(TEST_INPUT, &mut output);\n    assert_eq!(\n        output,\n        [\n            24, 230, 209, 59, 127, 30, 158, 244, 60, 177, 132, 150, 167, 244, 64, 69,\n            184, 123, 185, 44, 211, 199, 208, 179, 14, 64, 126, 140, 217, 69, 36, 216\n        ]\n    );\n}\n\n#[test]\nfn test_hash_sha2_256() {\n    let mut output = [0x00_u8; 32];\n    crate::hash_bytes::<crate::hash::Sha2x256>(TEST_INPUT, &mut output);\n    assert_eq!(\n        output,\n        [\n            136, 15, 25, 218, 88, 54, 49, 152, 115, 168, 147, 189, 207, 171, 243, 129,\n            161, 76, 15, 141, 197, 106, 111, 213, 19, 197, 133, 219, 181, 233, 195, 120\n        ]\n    );\n}\n\n#[test]\nfn test_hash_blake2_256() {\n    let mut output = [0x00_u8; 32];\n    crate::hash_bytes::<crate::hash::Blake2x256>(TEST_INPUT, &mut output);\n    assert_eq!(\n        output,\n        [\n            244, 247, 235, 182, 194, 161, 28, 69, 34, 106, 237, 7, 57, 87, 190, 12, 92,\n            171, 91, 176, 135, 52, 247, 94, 8, 112, 94, 183, 140, 101, 208, 120\n        ]\n    );\n}\n\n#[test]\nfn test_hash_blake2_128() {\n    let mut output = [0x00_u8; 16];\n    crate::hash_bytes::<crate::hash::Blake2x128>(TEST_INPUT, &mut output);\n    assert_eq!(\n        output,\n        [180, 158, 48, 21, 171, 163, 217, 175, 145, 160, 25, 159, 213, 142, 103, 242]\n    );\n}\n"],["890","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Docs\n\nuse crate::Environment;\n\n/// The concrete implementation that is guided by the topics builder.\n///\n/// To be implemented by the on-chain and off-chain environments respectively.\n#[doc(hidden)]\npub trait TopicsBuilderBackend<E>\nwhere\n    E: Environment,\n{\n    /// The type of the serialized event topics.\n    type Output;\n\n    /// Initialized the backend with the expected number of event topics.\n    fn expect(&mut self, expected_topics: usize);\n\n    /// Pushes another topic for serialization to the backend.\n    fn push_topic<T>(&mut self, topic_value: &T)\n    where\n        T: scale::Encode;\n\n    /// Extracts the serialized topics.\n    fn output(self) -> Self::Output;\n}\n\n/// Builder for event topic serialization.\n///\n/// Abstraction to build up event topic serialization with zero-overhead,\n/// no heap-memory allocations and no dynamic dispatch.\n#[doc(hidden)]\npub struct TopicsBuilder<S, E, B> {\n    backend: B,\n    state: core::marker::PhantomData<fn() -> (S, E)>,\n}\n\nimpl<E, B> From<B> for TopicsBuilder<state::Uninit, E, B>\nwhere\n    E: Environment,\n    B: TopicsBuilderBackend<E>,\n{\n    fn from(backend: B) -> Self {\n        Self {\n            backend,\n            state: Default::default(),\n        }\n    }\n}\n\n#[doc(hidden)]\npub mod state {\n    /// The topic builder is uninitialized and needs to be provided with the\n    /// expected number of topics that need to be constructed.\n    pub enum Uninit {}\n    /// There are some remaining topics that need to be provided with some values.\n    pub enum HasRemainingTopics {}\n    /// There are no more remaining topics and the topic builder shall be finalized.\n    pub enum NoRemainingTopics {}\n}\n\nimpl<E, B> TopicsBuilder<state::Uninit, E, B>\nwhere\n    E: Environment,\n    B: TopicsBuilderBackend<E>,\n{\n    /// Initializes the topics builder and informs it about how many topics it must expect to serialize.\n    ///\n    /// The number of expected topics is given implicitly by the `E` type parameter.\n    pub fn build<Event: Topics>(\n        mut self,\n    ) -> TopicsBuilder<<Event as Topics>::RemainingTopics, E, B> {\n        self.backend\n            .expect(<<Event as Topics>::RemainingTopics as EventTopicsAmount>::AMOUNT);\n        TopicsBuilder {\n            backend: self.backend,\n            state: Default::default(),\n        }\n    }\n}\n\nimpl<E, S, B> TopicsBuilder<S, E, B>\nwhere\n    E: Environment,\n    S: SomeRemainingTopics,\n    B: TopicsBuilderBackend<E>,\n{\n    /// Pushes another event topic to be serialized through the topics builder.\n    ///\n    /// Returns a topics builder that expects one less event topic for serialization\n    /// than before the call.\n    pub fn push_topic<T>(\n        mut self,\n        value: &T,\n    ) -> TopicsBuilder<<S as SomeRemainingTopics>::Next, E, B>\n    where\n        T: scale::Encode,\n    {\n        self.backend.push_topic(value);\n        TopicsBuilder {\n            backend: self.backend,\n            state: Default::default(),\n        }\n    }\n}\n\nimpl<E, B> TopicsBuilder<state::NoRemainingTopics, E, B>\nwhere\n    E: Environment,\n    B: TopicsBuilderBackend<E>,\n{\n    /// Finalizes the topics builder.\n    ///\n    /// No more event topics can be serialized afterwards but the environment will be\n    /// able to extract the information collected by the topics builder in order to\n    /// emit the serialized event.\n    pub fn finish(self) -> <B as TopicsBuilderBackend<E>>::Output\n    where\n        B: TopicsBuilderBackend<E>,\n    {\n        self.backend.output()\n    }\n}\n\n/// Indicates that there are some remaining topics left for expected serialization.\n#[doc(hidden)]\npub trait SomeRemainingTopics {\n    /// The type state indicating the amount of the remaining topics afterwards.\n    ///\n    /// Basically trivial sequence of: `N => N - 1` unless `N <= 1`\n    type Next;\n}\n\n/// Indicates the actual amount of expected event topics.\n#[doc(hidden)]\npub trait EventTopicsAmount {\n    /// The actual amount of remaining topics.\n    const AMOUNT: usize;\n}\n\nmacro_rules! impl_some_remaining_for {\n    ( $( $n:literal ),* $(,)? ) => {\n        $(\n            impl SomeRemainingTopics for [state::HasRemainingTopics; $n] {\n                type Next = [state::HasRemainingTopics; $n - 1];\n            }\n\n            impl EventTopicsAmount for [state::HasRemainingTopics; $n] {\n                const AMOUNT: usize = $n;\n            }\n        )*\n    };\n}\n#[rustfmt::skip]\nimpl_some_remaining_for!(\n             2,  3,  4,  5,  6,  7,  8,  9,\n    10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n    20, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n    30, 31, 32,\n);\n\nimpl SomeRemainingTopics for [state::HasRemainingTopics; 1] {\n    type Next = state::NoRemainingTopics;\n}\n\nimpl EventTopicsAmount for [state::HasRemainingTopics; 1] {\n    const AMOUNT: usize = 1;\n}\n\nimpl EventTopicsAmount for state::NoRemainingTopics {\n    const AMOUNT: usize = 0;\n}\n\n/// Implemented by event types to guide the event topic serialization using the topics builder.\n///\n/// Normally this trait should be implemented automatically via the ink! codegen.\npub trait Topics {\n    /// Type state indicating how many event topics are to be expected by the topics builder.\n    type RemainingTopics: EventTopicsAmount;\n\n    /// Guides event topic serialization using the given topics builder.\n    fn topics<E, B>(\n        &self,\n        builder: TopicsBuilder<state::Uninit, E, B>,\n    ) -> <B as TopicsBuilderBackend<E>>::Output\n    where\n        E: Environment,\n        B: TopicsBuilderBackend<E>;\n}\n\n/// For each topic a hash is generated. This hash must be unique\n/// for a field and its value. The `prefix` is concatenated\n/// with the `value` and this result is then hashed.\n/// The `prefix` is typically set to the path a field has in\n/// an event struct + the identifier of the event struct.\n///\n/// For example, in the case of our Erc20 example contract the\n/// prefix `Erc20::Transfer::from` is concatenated with the\n/// field value of `from` and then hashed.\n/// In this example `Erc20` would be the contract identified,\n/// `Transfer` the event identifier, and `from` the field identifier.\n#[doc(hidden)]\npub struct PrefixedValue<'a, 'b, T> {\n    pub prefix: &'a [u8],\n    pub value: &'b T,\n}\n\nimpl<X> scale::Encode for PrefixedValue<'_, '_, X>\nwhere\n    X: scale::Encode,\n{\n    #[inline]\n    fn size_hint(&self) -> usize {\n        self.prefix.size_hint() + self.value.size_hint()\n    }\n\n    #[inline]\n    fn encode_to<T: scale::Output + ?Sized>(&self, dest: &mut T) {\n        self.prefix.encode_to(dest);\n        self.value.encode_to(dest);\n    }\n}\n"],["891","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse ink_env::{\n    call::{\n        utils::{\n            ReturnType,\n            Set,\n        },\n        CallBuilder,\n        ExecutionInput,\n        Selector,\n    },\n    Environment,\n};\nuse ink_storage::traits::SpreadLayout;\n\n/// Trait used to indicate that an ink! trait definition has been checked\n/// by the `#[ink::trait_definition]` proc. macro.\n#[doc(hidden)]\npub unsafe trait CheckedInkTrait<T> {}\n\n/// Trait used by `#[ink::trait_definition]` to ensure that the associated\n/// return type for each trait message is correct.\n#[doc(hidden)]\npub trait ImpliesReturn<T> {}\n\nimpl<T> ImpliesReturn<T> for T {}\nimpl<T, E, Callee, GasCost, TransferredValue, Args> ImpliesReturn<T>\n    for CallBuilder<\n        E,\n        Callee,\n        GasCost,\n        TransferredValue,\n        Set<ExecutionInput<Args>>,\n        Set<ReturnType<T>>,\n    >\nwhere\n    E: Environment,\n{\n}\n\nimpl<E, Callee, GasCost, TransferredValue, Args> ImpliesReturn<()>\n    for CallBuilder<\n        E,\n        Callee,\n        GasCost,\n        TransferredValue,\n        Set<ExecutionInput<Args>>,\n        Set<()>,\n    >\nwhere\n    E: Environment,\n{\n}\n\n/// Dispatchable functions that have inputs.\n#[doc(hidden)]\npub trait FnInput {\n    /// The tuple-type of all inputs.\n    type Input: scale::Decode + 'static;\n}\n\n/// Dispatchable functions that have an output.\n#[doc(hidden)]\npub trait FnOutput {\n    /// The output type.\n    type Output: scale::Encode + 'static;\n}\n\n/// The selector of dispatchable functions.\n#[doc(hidden)]\npub trait FnSelector {\n    /// The selector.\n    const SELECTOR: Selector;\n}\n\n/// The storage state that the dispatchable function acts on.\n#[doc(hidden)]\npub trait FnState {\n    /// The storage state.\n    type State: SpreadLayout + Sized;\n}\n\n/// A dispatchable contract constructor message.\n#[doc(hidden)]\npub trait Constructor: FnInput + FnSelector + FnState {\n    const CALLABLE: fn(<Self as FnInput>::Input) -> <Self as FnState>::State;\n}\n\n/// A `&self` dispatchable contract message.\n#[doc(hidden)]\npub trait MessageRef: FnInput + FnOutput + FnSelector + FnState {\n    const CALLABLE: fn(\n        &<Self as FnState>::State,\n        <Self as FnInput>::Input,\n    ) -> <Self as FnOutput>::Output;\n}\n\n/// A `&mut self` dispatchable contract message.\n#[doc(hidden)]\npub trait MessageMut: FnInput + FnOutput + FnSelector + FnState {\n    const CALLABLE: fn(\n        &mut <Self as FnState>::State,\n        <Self as FnInput>::Input,\n    ) -> <Self as FnOutput>::Output;\n}\n\n/// Indicates that some compile time expression is expected to be `true`.\n#[doc(hidden)]\npub trait True {}\n"],["892","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/// Implemented by contracts in order to override `env().emit_event(..)`\n/// syntax for emitting of ink! contract events.\n///\n/// # Dev Note\n///\n/// Normally we'd try to define traits like these in the compagnion\n/// `ink_lang` crate, however, due to Rust's orphan rules we must\n/// define this trait here.\npub trait EmitEvent<C>\nwhere\n    C: BaseEvent,\n{\n    /// Emits an event that can be trivially converted into the base event.\n    fn emit_event<E>(self, event: E)\n    where\n        E: Into<<C as BaseEvent>::Type>;\n}\n\n/// Defines a base event type for the contract.\n///\n/// This is usually the event enum that comprises all defined event types.\npub trait BaseEvent {\n    /// The generated base event enum.\n    type Type;\n}\n"],["893","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::DispatchError;\n\n/// The contract dispatch mode.\n///\n/// Tells the [`DispatchUsingMode`](`crate::DispatchUsingMode`) implementation for\n/// an ink! smart contract how to dispatch for a call.\n#[derive(Copy, Clone, PartialEq, Eq)]\n#[doc(hidden)]\npub enum DispatchMode {\n    /// Mode for instantiating a contract.\n    Instantiate,\n    /// Mode for calling a contract.\n    Call,\n}\n\n/// Trait implemented by contracts themselves in order to provide a clean\n/// interface for the C-ABI specified `call` and `create` functions to forward\n/// calls to.\n#[doc(hidden)]\npub trait DispatchUsingMode {\n    fn dispatch_using_mode(mode: DispatchMode) -> Result<(), DispatchError>;\n}\n"],["894","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/// Trait implemented by chain extensions.\n///\n/// Allows to use the `self.env().extension().my_chain_extension(..)` syntax.\n///\n/// # Note\n///\n/// This trait is automatically implemented when using `#[ink::chain_extension]` proc. macro.\npub trait ChainExtensionInstance {\n    /// The type of the chain extension instance.\n    type Instance;\n\n    /// Creates a new instance of the chain extension to use methods with method chaining syntax.\n    fn instantiate() -> Self::Instance;\n}\n\n/// Implemented by chain extension types.\n///\n/// Every chain extension defines a set of chain extension methods\n/// that share a common error code type.\npub trait ChainExtension {\n    /// The error code that determines whether a chain extension method call was successful.\n    type ErrorCode: ink_env::chain_extension::FromStatusCode;\n}\n\n/// Only implemented for `Result<T, E>`.\n///\n/// Used to check at compile time if the return type of a chain extension method\n/// is a `Result` type using the type system instead of the syntactic structure.\n#[doc(hidden)]\npub trait IsResultType: private::Sealed {\n    /// The `T` type of the `Result<T, E>`.\n    type Ok;\n    /// The `E` type of the `Result<T, E>`.\n    type Err;\n}\n\nimpl<T, E> private::Sealed for Result<T, E> {}\nimpl<T, E> IsResultType for Result<T, E> {\n    type Ok = T;\n    type Err = E;\n}\n\nmod private {\n    /// Seals the `IsResultType` trait so that it cannot be implemented outside of this module.\n    pub trait Sealed {}\n}\n"],["895","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::{\n    Constructor,\n    DispatchError,\n    FnOutput,\n    FnState,\n    MessageMut,\n    MessageRef,\n};\nuse core::{\n    any::TypeId,\n    mem::ManuallyDrop,\n};\nuse ink_env::{\n    Environment,\n    ReturnFlags,\n};\nuse ink_primitives::Key;\nuse ink_storage::{\n    alloc,\n    alloc::ContractPhase,\n    traits::{\n        pull_spread_root,\n        push_spread_root,\n    },\n};\n\n/// Results of message handling operations.\n#[doc(hidden)]\npub type Result<T> = core::result::Result<T, DispatchError>;\n\n/// Connector trait: Connects enum dispatcher for messages with the contract.\n#[doc(hidden)]\npub trait MessageDispatcher {\n    /// The contract's message dispatcher type.\n    type Type;\n}\n\n/// Connector trait: Connects enum dispatcher for constructors with the contract.\n#[doc(hidden)]\npub trait ConstructorDispatcher {\n    /// The contract's constructors dispatcher type.\n    type Type;\n}\n\n/// Connector trait used to start the execution of a smart contract.\n///\n/// The generated message and constructor dispatch enums implement this trait\n/// in order to forward their already decoded state to the selected messages\n/// or constructors.\n#[doc(hidden)]\npub trait Execute {\n    /// Starts the smart contract execution.\n    fn execute(self) -> Result<()>;\n}\n\n/// Yields `true` if the message accepts payments.\n#[derive(Copy, Clone)]\n#[doc(hidden)]\npub struct AcceptsPayments(pub bool);\n\nimpl From<AcceptsPayments> for bool {\n    #[inline]\n    fn from(accepts_payments: AcceptsPayments) -> Self {\n        accepts_payments.0\n    }\n}\n\n/// Yields `true` if the dynamic storage allocator is enabled for the given call.\n#[derive(Copy, Clone)]\n#[doc(hidden)]\npub struct EnablesDynamicStorageAllocator(pub bool);\n\nimpl From<EnablesDynamicStorageAllocator> for bool {\n    #[inline]\n    fn from(enables_dynamic_storage_allocator: EnablesDynamicStorageAllocator) -> Self {\n        enables_dynamic_storage_allocator.0\n    }\n}\n\n/// Executes the given `&self` message closure.\n///\n/// # Note\n///\n/// The closure is supposed to already contain all the arguments that the real\n/// message requires and forwards them.\n#[inline]\n#[doc(hidden)]\npub fn execute_message<E, M, F>(\n    accepts_payments: AcceptsPayments,\n    enables_dynamic_storage_allocator: EnablesDynamicStorageAllocator,\n    f: F,\n) -> Result<()>\nwhere\n    E: Environment,\n    M: MessageRef,\n    F: FnOnce(&<M as FnState>::State) -> <M as FnOutput>::Output,\n{\n    let accepts_payments: bool = accepts_payments.into();\n    let enables_dynamic_storage_allocator: bool =\n        enables_dynamic_storage_allocator.into();\n    if !accepts_payments {\n        deny_payment::<E>()?;\n    }\n    if enables_dynamic_storage_allocator {\n        alloc::initialize(ContractPhase::Call);\n    }\n    let root_key = Key::from([0x00; 32]);\n    let state = ManuallyDrop::new(pull_spread_root::<<M as FnState>::State>(&root_key));\n    let result = f(&state);\n    if enables_dynamic_storage_allocator {\n        alloc::finalize();\n    }\n    if TypeId::of::<<M as FnOutput>::Output>() != TypeId::of::<()>() {\n        ink_env::return_value::<<M as FnOutput>::Output>(ReturnFlags::default(), &result)\n    }\n    Ok(())\n}\n\n/// Returns `Ok` if the caller did not transfer additional value to the callee.\n///\n/// # Errors\n///\n/// If the caller did send some amount of transferred value to the callee.\n#[inline]\n#[doc(hidden)]\npub fn deny_payment<E>() -> Result<()>\nwhere\n    E: Environment,\n{\n    let transferred = ink_env::transferred_balance::<E>()\n        .expect(\"encountered error while querying transferred balance\");\n    if transferred != <E as Environment>::Balance::from(0u32) {\n        return Err(DispatchError::PaidUnpayableMessage)\n    }\n    Ok(())\n}\n\n/// Executes the given `&mut self` message closure.\n///\n/// # Note\n///\n/// The closure is supposed to already contain all the arguments that the real\n/// message requires and forwards them.\n#[inline]\n#[doc(hidden)]\npub fn execute_message_mut<E, M, F>(\n    accepts_payments: AcceptsPayments,\n    enables_dynamic_storage_allocator: EnablesDynamicStorageAllocator,\n    f: F,\n) -> Result<()>\nwhere\n    E: Environment,\n    M: MessageMut,\n    F: FnOnce(&mut <M as FnState>::State) -> <M as FnOutput>::Output,\n{\n    let accepts_payments: bool = accepts_payments.into();\n    let enables_dynamic_storage_allocator: bool =\n        enables_dynamic_storage_allocator.into();\n    if !accepts_payments {\n        deny_payment::<E>()?;\n    }\n    if enables_dynamic_storage_allocator {\n        alloc::initialize(ContractPhase::Call);\n    }\n    let root_key = Key::from([0x00; 32]);\n    let mut state =\n        ManuallyDrop::new(pull_spread_root::<<M as FnState>::State>(&root_key));\n    let result = f(&mut state);\n    push_spread_root::<<M as FnState>::State>(&state, &root_key);\n    if enables_dynamic_storage_allocator {\n        alloc::finalize();\n    }\n    if TypeId::of::<<M as FnOutput>::Output>() != TypeId::of::<()>() {\n        ink_env::return_value::<<M as FnOutput>::Output>(ReturnFlags::default(), &result)\n    }\n    Ok(())\n}\n\n/// Executes the given constructor closure.\n///\n/// # Note\n///\n/// The closure is supposed to already contain all the arguments that the real\n/// constructor message requires and forwards them.\n#[inline]\n#[doc(hidden)]\npub fn execute_constructor<C, F>(\n    enables_dynamic_storage_allocator: EnablesDynamicStorageAllocator,\n    f: F,\n) -> Result<()>\nwhere\n    C: Constructor,\n    F: FnOnce() -> <C as FnState>::State,\n{\n    let enables_dynamic_storage_allocator: bool =\n        enables_dynamic_storage_allocator.into();\n    if enables_dynamic_storage_allocator {\n        alloc::initialize(ContractPhase::Deploy);\n    }\n    let state = ManuallyDrop::new(f());\n    let root_key = Key::from([0x00; 32]);\n    push_spread_root::<<C as FnState>::State>(&state, &root_key);\n    if enables_dynamic_storage_allocator {\n        alloc::finalize();\n    }\n    Ok(())\n}\n"],["896","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse core::marker::PhantomData;\nuse ink_env::{\n    call::{\n        utils::ReturnType,\n        CallParams,\n        CreateParams,\n    },\n    hash::{\n        CryptoHash,\n        HashOutput,\n    },\n    Environment,\n    Result,\n};\nuse ink_primitives::Key;\n\nuse crate::ChainExtensionInstance;\n\n/// The environment of the compiled ink! smart contract.\npub trait ContractEnv {\n    /// The environment type.\n    type Env: ::ink_env::Environment;\n}\n\n/// Simplifies interaction with the host environment via `self`.\n///\n/// # Note\n///\n/// This is generally implemented for storage structs that include\n/// their environment in order to allow the different dispatch functions\n/// to use it for returning the contract's output.\npub trait Env {\n    /// The access wrapper.\n    type EnvAccess;\n\n    /// Accesses the environment with predefined environmental types.\n    fn env(self) -> Self::EnvAccess;\n}\n\n/// Simplifies interaction with the host environment via `Self`.\n///\n/// # Note\n///\n/// This is generally implemented for storage structs that include\n/// their environment in order to allow the different dispatch functions\n/// to use it for returning the contract's output.\npub trait StaticEnv {\n    /// The access wrapper.\n    type EnvAccess;\n\n    /// Accesses the environment with predefined environmental types.\n    fn env() -> Self::EnvAccess;\n}\n\n/// A typed accessor to the environment.\n///\n/// This allows ink! messages to make use of the environment efficiently\n/// and user friendly while also maintaining access invariants.\n#[derive(Copy, Clone)]\npub struct EnvAccess<'a, T> {\n    /// Tricks the Rust compiler into thinking that we use `T`.\n    marker: PhantomData<fn() -> &'a T>,\n}\n\nimpl<'a, T> Default for EnvAccess<'a, T> {\n    #[inline]\n    fn default() -> Self {\n        Self {\n            marker: Default::default(),\n        }\n    }\n}\n\nimpl<'a, E> core::fmt::Debug for EnvAccess<'a, E> {\n    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n        f.debug_struct(\"EnvAccess\").finish()\n    }\n}\n\nimpl<'a, T> EnvAccess<'a, T>\nwhere\n    T: Environment,\n    <T as Environment>::ChainExtension: ChainExtensionInstance,\n{\n    /// Allows to call one of the available defined chain extension methods.\n    pub fn extension(\n        self,\n    ) -> <<T as Environment>::ChainExtension as ChainExtensionInstance>::Instance {\n        <<T as Environment>::ChainExtension as ChainExtensionInstance>::instantiate()\n    }\n}\n\nimpl<'a, T> EnvAccess<'a, T>\nwhere\n    T: Environment,\n{\n    /// Returns the address of the caller of the executed contract.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`ink_env::caller`]\n    pub fn caller(self) -> T::AccountId {\n        ink_env::caller::<T>().expect(\"couldn't decode caller\")\n    }\n\n    /// Returns the transferred balance for the contract execution.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`ink_env::transferred_balance`]\n    pub fn transferred_balance(self) -> T::Balance {\n        ink_env::transferred_balance::<T>().expect(\"couldn't decode transferred balance\")\n    }\n\n    /// Returns the price for the specified amount of gas.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`ink_env::weight_to_fee`]\n    pub fn weight_to_fee(self, gas: u64) -> T::Balance {\n        ink_env::weight_to_fee::<T>(gas).expect(\"couldn't decode weight fee\")\n    }\n\n    /// Returns the amount of gas left for the contract execution.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`ink_env::gas_left`]\n    pub fn gas_left(self) -> T::Balance {\n        ink_env::gas_left::<T>().expect(\"couldn't decode gas left\")\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`ink_env::block_timestamp`]\n    pub fn block_timestamp(self) -> T::Timestamp {\n        ink_env::block_timestamp::<T>().expect(\"couldn't decode block time stamp\")\n    }\n\n    /// Returns the account ID of the executed contract.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`ink_env::account_id`]\n    pub fn account_id(self) -> T::AccountId {\n        ink_env::account_id::<T>().expect(\"couldn't decode contract account ID\")\n    }\n\n    /// Returns the balance of the executed contract.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`ink_env::balance`]\n    pub fn balance(self) -> T::Balance {\n        ink_env::balance::<T>().expect(\"couldn't decode contract balance\")\n    }\n\n    /// Returns the current rent allowance for the executed contract.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`ink_env::rent_allowance`]\n    pub fn rent_allowance(self) -> T::Balance {\n        ink_env::rent_allowance::<T>().expect(\"couldn't decode contract rent allowance\")\n    }\n\n    /// Returns the current block number.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`ink_env::block_number`]\n    pub fn block_number(self) -> T::BlockNumber {\n        ink_env::block_number::<T>().expect(\"couldn't decode block number\")\n    }\n\n    /// Returns the minimum balance that is required for creating an account.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`ink_env::minimum_balance`]\n    pub fn minimum_balance(self) -> T::Balance {\n        ink_env::minimum_balance::<T>().expect(\"couldn't decode minimum account balance\")\n    }\n\n    /// Returns the tombstone deposit for the contracts chain.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`ink_env::tombstone_deposit`]\n    pub fn tombstone_deposit(self) -> T::Balance {\n        ink_env::tombstone_deposit::<T>().expect(\"couldn't decode tombstone deposits\")\n    }\n\n    /// Sets the rent allowance of the executed contract to the new value.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`ink_env::set_rent_allowance`]\n    pub fn set_rent_allowance(self, new_value: T::Balance) {\n        ink_env::set_rent_allowance::<T>(new_value)\n    }\n\n    /// Invokes a contract message.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`ink_env::invoke_contract`]\n    pub fn invoke_contract<Args>(self, params: &CallParams<T, Args, ()>) -> Result<()>\n    where\n        Args: scale::Encode,\n    {\n        ink_env::invoke_contract::<T, Args>(params)\n    }\n\n    /// Evaluates a contract message and returns its result.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`ink_env::eval_contract`]\n    pub fn eval_contract<Args, R>(\n        self,\n        params: &CallParams<T, Args, ReturnType<R>>,\n    ) -> Result<R>\n    where\n        Args: scale::Encode,\n        R: scale::Decode,\n    {\n        ink_env::eval_contract::<T, Args, R>(params)\n    }\n\n    /// Instantiates another contract.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`ink_env::instantiate_contract`]\n    pub fn instantiate_contract<Args, Salt, C>(\n        self,\n        params: &CreateParams<T, Args, Salt, C>,\n    ) -> Result<T::AccountId>\n    where\n        Args: scale::Encode,\n        Salt: AsRef<[u8]>,\n    {\n        ink_env::instantiate_contract::<T, Args, Salt, C>(params)\n    }\n\n    /// Restores a smart contract in tombstone state.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`ink_env::restore_contract`]\n    pub fn restore_contract(\n        self,\n        account_id: T::AccountId,\n        code_hash: T::Hash,\n        rent_allowance: T::Balance,\n        filtered_keys: &[Key],\n    ) {\n        ink_env::restore_contract::<T>(\n            account_id,\n            code_hash,\n            rent_allowance,\n            filtered_keys,\n        )\n    }\n\n    /// Terminates the existence of a smart contract.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`ink_env::terminate_contract`]\n    pub fn terminate_contract(self, beneficiary: T::AccountId) -> ! {\n        ink_env::terminate_contract::<T>(beneficiary)\n    }\n\n    /// Transfers value from the contract to the destination account ID.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`ink_env::transfer`]\n    pub fn transfer(self, destination: T::AccountId, value: T::Balance) -> Result<()> {\n        ink_env::transfer::<T>(destination, value)\n    }\n\n    /// Returns a random hash seed.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`ink_env::random`]\n    pub fn random(self, subject: &[u8]) -> T::Hash {\n        ink_env::random::<T>(subject).expect(\"couldn't decode randomized hash\")\n    }\n\n    /// Computes the hash of the given bytes using the cryptographic hash `H`.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`ink_env::hash_bytes`]\n    pub fn hash_bytes<H>(self, input: &[u8]) -> <H as HashOutput>::Type\n    where\n        H: CryptoHash,\n    {\n        let mut output = <H as HashOutput>::Type::default();\n        ink_env::hash_bytes::<H>(input, &mut output);\n        output\n    }\n\n    /// Computes the hash of the given SCALE encoded value using the cryptographic hash `H`.\n    ///\n    /// # Note\n    ///\n    /// For more details visit: [`ink_env::hash_encoded`]\n    pub fn hash_encoded<H, V>(self, value: &V) -> <H as HashOutput>::Type\n    where\n        H: CryptoHash,\n        V: scale::Encode,\n    {\n        let mut output = <H as HashOutput>::Type::default();\n        ink_env::hash_encoded::<H, V>(value, &mut output);\n        output\n    }\n}\n"],["897","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/// A dispatch result.\n#[doc(hidden)]\npub type DispatchResult = core::result::Result<(), DispatchError>;\n\n/// A dispatch error.\n#[derive(Debug, Copy, Clone)]\n#[doc(hidden)]\npub enum DispatchError {\n    UnknownSelector,\n    UnknownInstantiateSelector,\n    UnknownCallSelector,\n\n    InvalidParameters,\n    InvalidInstantiateParameters,\n    InvalidCallParameters,\n\n    CouldNotReadInput,\n    PaidUnpayableMessage,\n}\n\nimpl DispatchError {\n    /// Converts `self` into an associated `u32` that SRML contracts can handle.\n    #[inline]\n    pub fn to_u32(self) -> u32 {\n        DispatchRetCode::from(self).to_u32()\n    }\n}\n\n/// A return code indicating success or error in a compact form.\n#[derive(Copy, Clone)]\n#[doc(hidden)]\npub struct DispatchRetCode(u32);\n\nimpl DispatchRetCode {\n    /// Creates a return code indicating success.\n    #[inline]\n    pub fn success() -> Self {\n        Self(0)\n    }\n\n    /// Returns the `u32` representation of `self`.\n    ///\n    /// # Note\n    ///\n    /// This is useful to communicate back to SRML contracts.\n    #[inline]\n    pub fn to_u32(self) -> u32 {\n        self.0\n    }\n}\n\nimpl From<DispatchError> for DispatchRetCode {\n    #[inline]\n    fn from(err: DispatchError) -> Self {\n        match err {\n            DispatchError::UnknownSelector => Self(0x01),\n            DispatchError::UnknownInstantiateSelector => Self(0x02),\n            DispatchError::UnknownCallSelector => Self(0x03),\n            DispatchError::InvalidParameters => Self(0x04),\n            DispatchError::InvalidInstantiateParameters => Self(0x05),\n            DispatchError::InvalidCallParameters => Self(0x06),\n            DispatchError::CouldNotReadInput => Self(0x07),\n            DispatchError::PaidUnpayableMessage => Self(0x08),\n        }\n    }\n}\n\nimpl From<DispatchResult> for DispatchRetCode {\n    #[inline]\n    fn from(res: DispatchResult) -> Self {\n        match res {\n            Ok(_) => Self::success(),\n            Err(err) => Self::from(err),\n        }\n    }\n}\n"],["898","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse ink_env::Environment;\n\n/// The type that can never be returned because it is not possible to craft an instance of it.\n#[doc(hidden)]\npub enum NeverReturns {}\n\n/// Implemented by contracts that are compiled as dependencies.\n///\n/// This allows to forward `&self` calls to a call forwarder\n/// that encodes and dispatches the calls to the chain.\n#[doc(hidden)]\npub trait ForwardCall {\n    /// The call forwarder that handles `&self` messages.\n    type Forwarder;\n\n    /// Instantiates a call forwarder to forward `&self` messages.\n    fn call(self) -> Self::Forwarder;\n}\n\n/// Implemented by contracts that are compiled as dependencies.\n///\n/// This allows to forward `&mut self` calls to a call forwarder\n/// that encodes and dispatches the calls to the chain.\n#[doc(hidden)]\npub trait ForwardCallMut {\n    /// The call forwarder that handles `&mut self` messages.\n    type Forwarder;\n\n    /// Instantiates a call forwarder to forward `&mut self` messages.\n    fn call_mut(self) -> Self::Forwarder;\n}\n\n/// Implemented by contracts that are compiled as dependencies.\n///\n/// Allows them to return their underlying account identifier.\npub trait ToAccountId<T>\nwhere\n    T: Environment,\n{\n    /// Returns the underlying account identifier of the instantiated contract.\n    fn to_account_id(&self) -> <T as Environment>::AccountId;\n}\n"],["899","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse proc_macro2::TokenStream as TokenStream2;\n\n/// Types implementing this trait are code generators for the ink! language.\npub trait GenerateCode {\n    /// Generates ink! contract code.\n    fn generate_code(&self) -> TokenStream2;\n}\n\n/// Types implementing this trait can forward code generation to other generators.\npub trait GenerateCodeUsing: AsRef<ir::Contract> {\n    /// Generates code using the given codegen module.\n    fn generate_code_using<'a, G>(&'a self) -> TokenStream2\n    where\n        G: GenerateCode + From<&'a ir::Contract>;\n}\n\nimpl<T> GenerateCodeUsing for T\nwhere\n    T: AsRef<ir::Contract>,\n{\n    fn generate_code_using<'a, G>(&'a self) -> TokenStream2\n    where\n        G: GenerateCode + From<&'a ir::Contract>,\n    {\n        <G as GenerateCode>::generate_code(&G::from(\n            <Self as AsRef<ir::Contract>>::as_ref(self),\n        ))\n    }\n}\n"],["900","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::{\n    generator,\n    GenerateCode,\n    GenerateCodeUsing,\n};\nuse derive_more::From;\nuse proc_macro2::TokenStream as TokenStream2;\nuse quote::{\n    quote,\n    quote_spanned,\n};\nuse syn::spanned::Spanned as _;\n\n/// Generator to create the ink! storage struct and important trait impls.\n#[derive(From)]\npub struct Storage<'a> {\n    contract: &'a ir::Contract,\n}\n\nimpl<'a> AsRef<ir::Contract> for Storage<'_> {\n    fn as_ref(&self) -> &ir::Contract {\n        self.contract\n    }\n}\n\nimpl GenerateCode for Storage<'_> {\n    fn generate_code(&self) -> TokenStream2 {\n        let storage_span = self.contract.module().storage().span();\n        let access_env_impls = self.generate_access_env_trait_impls();\n        let storage_struct = self.generate_storage_struct();\n        let use_emit_event = if self.contract.module().events().next().is_some() {\n            // Required to allow for `self.env().emit_event(..)` in messages and constructors.\n            Some(quote! { use ::ink_lang::EmitEvent as _; })\n        } else {\n            None\n        };\n        let cfg = self.generate_code_using::<generator::CrossCallingConflictCfg>();\n        quote_spanned!(storage_span =>\n            #access_env_impls\n            #storage_struct\n\n            #cfg\n            const _: () = {\n                // Used to make `self.env()` available in message code.\n                #[allow(unused_imports)]\n                use ::ink_lang::{\n                    Env as _,\n                    StaticEnv as _,\n                };\n                #use_emit_event\n            };\n        )\n    }\n}\n\nimpl Storage<'_> {\n    fn generate_access_env_trait_impls(&self) -> TokenStream2 {\n        let storage_ident = &self.contract.module().storage().ident();\n        let cfg = self.generate_code_using::<generator::CrossCallingConflictCfg>();\n        quote! {\n            #cfg\n            const _: () = {\n                impl<'a> ::ink_lang::Env for &'a #storage_ident {\n                    type EnvAccess = ::ink_lang::EnvAccess<'a, <#storage_ident as ::ink_lang::ContractEnv>::Env>;\n\n                    fn env(self) -> Self::EnvAccess {\n                        Default::default()\n                    }\n                }\n\n                impl<'a> ::ink_lang::StaticEnv for #storage_ident {\n                    type EnvAccess = ::ink_lang::EnvAccess<'static, <#storage_ident as ::ink_lang::ContractEnv>::Env>;\n\n                    fn env() -> Self::EnvAccess {\n                        Default::default()\n                    }\n                }\n            };\n        }\n    }\n\n    /// Generates the storage struct definition.\n    fn generate_storage_struct(&self) -> TokenStream2 {\n        let storage = self.contract.module().storage();\n        let span = storage.span();\n        let ident = &storage.ident();\n        let attrs = &storage.attrs();\n        let fields = storage.fields();\n        let cfg = self.generate_code_using::<generator::CrossCallingConflictCfg>();\n        quote_spanned!( span =>\n            #cfg\n            #(#attrs)*\n            #[cfg_attr(\n                feature = \"std\",\n                derive(::ink_storage::traits::StorageLayout)\n            )]\n            #[derive(::ink_storage::traits::SpreadLayout)]\n            #[cfg_attr(test, derive(Debug))]\n            pub struct #ident {\n                #( #fields ),*\n            }\n        )\n    }\n}\n"],["901","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::GenerateCode;\nuse derive_more::From;\nuse heck::CamelCase as _;\nuse impl_serde::serialize as serde_hex;\nuse ir::Callable;\nuse itertools::Itertools as _;\nuse proc_macro2::{\n    Ident,\n    TokenStream as TokenStream2,\n};\nuse quote::{\n    format_ident,\n    quote,\n    quote_spanned,\n};\nuse syn::spanned::Spanned as _;\n\n/// Errors which may occur when forwarding a call is not allowed.\n///\n/// We insert markers for these errors in the generated contract code.\n/// This is necessary since we can't check these errors at compile time\n/// of the contract.\n/// `cargo-contract` checks the contract code for these error markers\n/// when building a contract and fails if it finds markers.\n#[derive(scale::Encode, scale::Decode)]\npub enum EnforcedErrors {\n    /// The below error represents calling a `&mut self` message in a context that\n    /// only allows for `&self` messages. This may happen under certain circumstances\n    /// when ink! trait implementations are involved with long-hand calling notation.\n    #[codec(index = 1)]\n    CannotCallTraitMessage {\n        /// The trait that defines the called message.\n        trait_ident: String,\n        /// The name of the called message.\n        message_ident: String,\n        /// The selector of the called message.\n        message_selector: [u8; 4],\n        /// Is `true` if the `self` receiver of the ink! message is `&mut self`.\n        message_mut: bool,\n    },\n    /// The below error represents calling a constructor in a context that does\n    /// not allow calling it. This may happen when the constructor defined in a\n    /// trait is cross-called in another contract.\n    /// This is not allowed since the contract to which a call is forwarded must\n    /// already exist at the point when the call to it is made.\n    #[codec(index = 2)]\n    CannotCallTraitConstructor {\n        /// The trait that defines the called constructor.\n        trait_ident: String,\n        /// The name of the called constructor.\n        constructor_ident: String,\n        /// The selector of the called constructor.\n        constructor_selector: [u8; 4],\n    },\n}\n\n/// Generates `#[cfg(..)]` code to guard against compilation under `ink-as-dependency`.\n#[derive(From)]\npub struct CrossCallingConflictCfg<'a> {\n    contract: &'a ir::Contract,\n}\n\nimpl GenerateCode for CrossCallingConflictCfg<'_> {\n    fn generate_code(&self) -> TokenStream2 {\n        if self.contract.config().is_compile_as_dependency_enabled() {\n            return quote! { #[cfg(feature = \"__ink_DO_NOT_COMPILE\")] }\n        }\n        quote! { #[cfg(not(feature = \"ink-as-dependency\"))] }\n    }\n}\n\n/// Generates code for using this ink! contract as a dependency.\n#[derive(From)]\npub struct CrossCalling<'a> {\n    contract: &'a ir::Contract,\n}\n\nimpl GenerateCode for CrossCalling<'_> {\n    fn generate_code(&self) -> TokenStream2 {\n        let storage = self.generate_storage();\n        let standard_impls = self.generate_standard_impls();\n        let call_forwarder = self.generate_call_forwarders();\n        let impl_blocks = self.generate_impl_blocks();\n        quote! {\n            #storage\n            #standard_impls\n            #call_forwarder\n            #impl_blocks\n        }\n    }\n}\n\nimpl CrossCalling<'_> {\n    /// Generates code for conditionally compiling code only if the contract\n    /// is compiled as dependency.\n    fn generate_cfg(&self) -> Option<TokenStream2> {\n        if self.contract.config().is_compile_as_dependency_enabled() {\n            return None\n        }\n        Some(quote! {\n            #[cfg(feature = \"ink-as-dependency\")]\n        })\n    }\n\n    /// Generates code for the ink! storage struct for cross-calling purposes.\n    ///\n    /// # Note\n    ///\n    /// This always consists of a single `AccountId` and can be viewed as a\n    /// reference to a live smart contract instance of the same type. It will\n    /// forward all calls via ink!'s provided cross-calling infrastructure\n    /// automatically over the chain.\n    fn generate_storage(&self) -> TokenStream2 {\n        let cfg = self.generate_cfg();\n        let storage = self.contract.module().storage();\n        let span = storage.span();\n        let ident = storage.ident();\n        let attrs = storage.attrs();\n        quote_spanned!(span =>\n            #cfg\n            #( #attrs )*\n            #[derive(\n                Clone,\n                Debug,\n                ::scale::Encode,\n                ::scale::Decode,\n                ::ink_storage::traits::SpreadLayout,\n                ::ink_storage::traits::PackedLayout,\n            )]\n            #[cfg_attr(\n                feature = \"std\",\n                derive(\n                    ::scale_info::TypeInfo,\n                    ::ink_storage::traits::StorageLayout,\n                )\n            )]\n            pub struct #ident {\n                account_id: AccountId,\n            }\n        )\n    }\n\n    /// Generates code for the trait implementations required to make the\n    /// generated ink! storage struct for cross-calling work out of the box\n    /// for the cross-calling infrastructure.\n    fn generate_standard_impls(&self) -> TokenStream2 {\n        let cfg = self.generate_cfg();\n        let ident = self.contract.module().storage().ident();\n        quote! {\n            #cfg\n            const _: () = {\n                impl ::ink_env::call::FromAccountId<Environment> for #ident {\n                    #[inline]\n                    fn from_account_id(account_id: AccountId) -> Self {\n                        Self { account_id }\n                    }\n                }\n\n                impl ::ink_lang::ToAccountId<Environment> for #ident {\n                    #[inline]\n                    fn to_account_id(&self) -> AccountId {\n                        self.account_id\n                    }\n                }\n            };\n        }\n    }\n\n    /// Builds up the `ink_env::call::utils::ArgumentList` type structure for the given types.\n    fn generate_arg_list<'a, Args>(args: Args) -> TokenStream2\n    where\n        Args: IntoIterator<Item = &'a syn::Type>,\n        <Args as IntoIterator>::IntoIter: DoubleEndedIterator,\n    {\n        args.into_iter().fold(\n            quote! { ::ink_env::call::utils::EmptyArgumentList },\n            |rest, arg| quote! {\n                ::ink_env::call::utils::ArgumentList<::ink_env::call::utils::Argument<#arg>, #rest>\n            }\n        )\n    }\n\n    /// Returns the identifier for the generated call forwarder utility.\n    fn call_forwarder_ident() -> Ident {\n        format_ident!(\"__ink_CallForwarder\")\n    }\n\n    fn generate_call_forwarder_trait_ghost_message(\n        message: ir::CallableWithSelector<ir::Message>,\n    ) -> TokenStream2 {\n        let span = message.span();\n        let ident = message.ident();\n        let output_ident = format_ident!(\"{}Out\", ident.to_string().to_camel_case());\n        let composed_selector = message.composed_selector().as_bytes().to_owned();\n        let trait_ident = message\n            .item_impl()\n            .trait_ident()\n            .expect(\"trait identifier must exist\")\n            .to_string();\n        let linker_error = EnforcedErrors::CannotCallTraitMessage {\n            trait_ident,\n            message_ident: ident.to_string(),\n            message_selector: composed_selector,\n            message_mut: message.receiver().is_ref_mut(),\n        };\n        let linker_error_ident = format_ident!(\n            \"__ink_enforce_error_{}\",\n            serde_hex::to_hex(&scale::Encode::encode(&linker_error), false)\n        );\n        let attrs = message.attrs();\n        let input_bindings = message\n            .inputs()\n            .enumerate()\n            .map(|(n, _)| format_ident!(\"__ink_binding_{}\", n))\n            .collect::<Vec<_>>();\n        let input_types = message\n            .inputs()\n            .map(|pat_type| &*pat_type.ty)\n            .collect::<Vec<_>>();\n        let output_ty = message\n            .output()\n            .cloned()\n            .unwrap_or_else(|| syn::parse_quote! { () });\n        let pub_tok = match message.item_impl().trait_path() {\n            Some(_) => None,\n            None => Some(quote! { pub }),\n        };\n        let mut_tok = match message.receiver() {\n            ir::Receiver::Ref => None,\n            ir::Receiver::RefMut => Some(quote! { mut }),\n        };\n        quote_spanned!(span=>\n            type #output_ident = #output_ty;\n\n            #( #attrs )*\n            #[cold]\n            #[doc(hidden)]\n            #pub_tok fn #ident(\n                & #mut_tok self,\n                #( #input_bindings : #input_types ),*\n            ) -> Self::#output_ident {\n                extern {\n                    fn #linker_error_ident() -> !;\n                }\n                unsafe { #linker_error_ident() }\n            }\n        )\n    }\n\n    fn generate_call_forwarder_trait_proper_message(\n        message: ir::CallableWithSelector<ir::Message>,\n    ) -> TokenStream2 {\n        let span = message.span();\n        let ident = message.ident();\n        let output_ident = format_ident!(\"{}Out\", ident.to_string().to_camel_case());\n        let composed_selector = message.composed_selector().as_bytes().to_owned();\n        let attrs = message.attrs();\n        let input_bindings = message\n            .inputs()\n            .enumerate()\n            .map(|(n, _)| format_ident!(\"__ink_binding_{}\", n))\n            .collect::<Vec<_>>();\n        let input_types = message\n            .inputs()\n            .map(|pat_type| &*pat_type.ty)\n            .collect::<Vec<_>>();\n        let arg_list = Self::generate_arg_list(input_types.iter().cloned());\n        let output = message.output();\n        let output_sig = output.map_or_else(\n            || quote! { () },\n            |output| quote! { ::ink_env::call::utils::ReturnType<#output> },\n        );\n        let pub_tok = match message.item_impl().trait_path() {\n            Some(_) => None,\n            None => Some(quote! { pub }),\n        };\n        let receiver = match message.receiver() {\n            ir::Receiver::Ref => Some(quote! { &self }),\n            ir::Receiver::RefMut => Some(quote! { &mut self }),\n        };\n        quote_spanned!(span=>\n            #[allow(clippy::type_complexity)]\n            type #output_ident = ::ink_env::call::CallBuilder<\n                Environment,\n                ::ink_env::call::utils::Set<AccountId>,\n                ::ink_env::call::utils::Unset<u64>,\n                ::ink_env::call::utils::Unset<Balance>,\n                ::ink_env::call::utils::Set<::ink_env::call::ExecutionInput<#arg_list>>,\n                ::ink_env::call::utils::Set<#output_sig>,\n            >;\n\n            #( #attrs )*\n            #[inline]\n            #pub_tok fn #ident(\n                #receiver #(, #input_bindings : #input_types )*\n            ) -> Self::#output_ident {\n                ::ink_env::call::build_call::<Environment>()\n                    .callee(::ink_lang::ToAccountId::to_account_id(self.contract))\n                    .exec_input(\n                        ::ink_env::call::ExecutionInput::new(\n                            ::ink_env::call::Selector::new([ #( #composed_selector ),* ])\n                        )\n                        #(\n                            .push_arg(#input_bindings)\n                        )*\n                    )\n                    .returns::<#output_sig>()\n            }\n        )\n    }\n\n    /// Generates code for a single call forwarder trait message.\n    ///\n    /// The `mutable` parameter indicates whether only read-only (`false`) or\n    /// write-only (`true`) messages shall be valid calls. For non valid messages\n    /// an invalid implementation is provided so that actually calling those\n    /// will result in a compiler or linker error.\n    fn generate_call_forwarder_trait_message(\n        mutable: bool,\n        message: ir::CallableWithSelector<ir::Message>,\n    ) -> TokenStream2 {\n        if mutable == message.receiver().is_ref_mut() {\n            Self::generate_call_forwarder_trait_proper_message(message)\n        } else {\n            Self::generate_call_forwarder_trait_ghost_message(message)\n        }\n    }\n\n    /// Generates code for a single call forwarder trait constructor.\n    ///\n    /// Note that constructors never need to be forwarded and that we only\n    /// provide their implementations to satisfy the implementation block.\n    /// We generally try to generate code in a way that actually calling\n    /// those constructors will result in a compiler or linker error.\n    fn generate_call_forwarder_trait_constructor(\n        constructor: ir::CallableWithSelector<ir::Constructor>,\n    ) -> TokenStream2 {\n        let span = constructor.span();\n        let attrs = constructor.attrs();\n        let ident = constructor.ident();\n        let output_ident = format_ident!(\"{}Out\", ident.to_string().to_camel_case());\n        let composed_selector = constructor.composed_selector().as_bytes().to_owned();\n        let trait_ident = constructor\n            .item_impl()\n            .trait_ident()\n            .expect(\"trait identifier must exist\")\n            .to_string();\n        let linker_error = EnforcedErrors::CannotCallTraitConstructor {\n            trait_ident,\n            constructor_ident: ident.to_string(),\n            constructor_selector: composed_selector,\n        };\n        let linker_error_ident = format_ident!(\n            \"__ink_enforce_error_{}\",\n            serde_hex::to_hex(&scale::Encode::encode(&linker_error), false)\n        );\n        let input_bindings = constructor\n            .inputs()\n            .enumerate()\n            .map(|(n, _)| format_ident!(\"__ink_binding_{}\", n))\n            .collect::<Vec<_>>();\n        let input_types = constructor\n            .inputs()\n            .map(|pat_type| &*pat_type.ty)\n            .collect::<Vec<_>>();\n        quote_spanned!(span =>\n            type #output_ident = ::ink_lang::NeverReturns;\n\n            #( #attrs )*\n            #[cold]\n            #[doc(hidden)]\n            fn #ident(\n                #( #input_bindings : #input_types ),*\n            ) -> Self::#output_ident {\n                extern {\n                    fn #linker_error_ident() -> !;\n                }\n                unsafe { #linker_error_ident() }\n            }\n        )\n    }\n\n    /// Generates code for a single call forwarder trait implementation block.\n    ///\n    /// The `mutable` parameter indicates whether only read-only (`false`) or\n    /// write-only (`true`) messages and constructors are to be considered.\n    fn generate_call_forwarder_trait_impl_block(\n        &self,\n        mutable: bool,\n        item_impl: &ir::ItemImpl,\n    ) -> TokenStream2 {\n        assert!(item_impl.trait_path().is_some());\n        let span = item_impl.span();\n        let attrs = item_impl.attrs();\n        let forwarder_ident = Self::call_forwarder_ident();\n        let storage_ident = self.contract.module().storage().ident();\n        let mut_tok = if mutable { Some(quote! { mut }) } else { None };\n        let constructors = item_impl.iter_constructors().map(|constructor| {\n            Self::generate_call_forwarder_trait_constructor(constructor)\n        });\n        let messages = item_impl\n            .iter_messages()\n            .map(|message| Self::generate_call_forwarder_trait_message(mutable, message));\n        let trait_path = item_impl\n            .trait_path()\n            .expect(\"encountered missing trait path for trait impl block\");\n        let trait_ident = item_impl\n            .trait_ident()\n            .expect(\"encountered missing trait identifier for trait impl block\");\n        let hash = ir::InkTrait::compute_verify_hash(\n            trait_ident,\n            item_impl.iter_constructors().map(|constructor| {\n                let ident = constructor.ident().clone();\n                let len_inputs = constructor.inputs().count();\n                (ident, len_inputs)\n            }),\n            item_impl.iter_messages().map(|message| {\n                let ident = message.ident().clone();\n                let len_inputs = message.inputs().count() + 1;\n                let is_mut = message.receiver().is_ref_mut();\n                (ident, len_inputs, is_mut)\n            }),\n        );\n        let checksum = u32::from_be_bytes([hash[0], hash[1], hash[2], hash[3]]) as usize;\n        quote_spanned!(span =>\n            unsafe impl<'a> ::ink_lang::CheckedInkTrait<[(); #checksum]> for #forwarder_ident<&'a #mut_tok #storage_ident> {}\n\n            #( #attrs )*\n            impl<'a> #trait_path for #forwarder_ident<&'a #mut_tok #storage_ident> {\n                type __ink_Checksum = [(); #checksum];\n\n                #( #constructors )*\n                #( #messages )*\n            }\n        )\n    }\n\n    fn generate_call_forwarder_inherent_message(\n        message: ir::CallableWithSelector<ir::Message>,\n    ) -> TokenStream2 {\n        let span = message.span();\n        let ident = message.ident();\n        let composed_selector = message.composed_selector().as_bytes().to_owned();\n        let attrs = message.attrs();\n        let input_bindings = message\n            .inputs()\n            .enumerate()\n            .map(|(n, _)| format_ident!(\"__ink_binding_{}\", n))\n            .collect::<Vec<_>>();\n        let input_types = message\n            .inputs()\n            .map(|pat_type| &*pat_type.ty)\n            .collect::<Vec<_>>();\n        let arg_list = Self::generate_arg_list(input_types.iter().cloned());\n        let output = message.output();\n        let output_sig = output.map_or_else(\n            || quote! { () },\n            |output| quote! { ::ink_env::call::utils::ReturnType<#output> },\n        );\n        let pub_tok = match message.item_impl().trait_path() {\n            Some(_) => None,\n            None => Some(quote! { pub }),\n        };\n        quote_spanned!(span=>\n            #( #attrs )*\n            #[inline]\n            #[allow(clippy::type_complexity)]\n            #pub_tok fn #ident(\n                self,\n                #( #input_bindings : #input_types ),*\n            ) -> ::ink_env::call::CallBuilder<\n                Environment,\n                ::ink_env::call::utils::Set<AccountId>,\n                ::ink_env::call::utils::Unset<u64>,\n                ::ink_env::call::utils::Unset<Balance>,\n                ::ink_env::call::utils::Set<::ink_env::call::ExecutionInput<#arg_list>>,\n                ::ink_env::call::utils::Set<#output_sig>,\n            > {\n                ::ink_env::call::build_call::<Environment>()\n                    .callee(::ink_lang::ToAccountId::to_account_id(self.contract))\n                    .exec_input(\n                        ::ink_env::call::ExecutionInput::new(\n                            ::ink_env::call::Selector::new([ #( #composed_selector ),* ])\n                        )\n                        #(\n                            .push_arg(#input_bindings)\n                        )*\n                    )\n                    .returns::<#output_sig>()\n            }\n        )\n    }\n\n    /// Generates code for a single call forwarder inherent implementation block.\n    ///\n    /// The `mutable` parameter indicates whether only read-only (`false`) or\n    /// write-only (`true`) messages and constructors are to be considered.\n    fn generate_call_forwarder_inherent_impl_block(\n        &self,\n        mutable: bool,\n        item_impl: &ir::ItemImpl,\n    ) -> TokenStream2 {\n        assert!(item_impl.trait_path().is_none());\n        let span = item_impl.span();\n        let attrs = item_impl.attrs();\n        let forwarder_ident = Self::call_forwarder_ident();\n        let storage_ident = self.contract.module().storage().ident();\n        let mut_tok = if mutable { Some(quote! { mut }) } else { None };\n        let messages = item_impl\n            .iter_messages()\n            .filter(|message| mutable == message.receiver().is_ref_mut())\n            .map(Self::generate_call_forwarder_inherent_message);\n        quote_spanned!(span =>\n            #( #attrs )*\n            impl<'a> #forwarder_ident<&'a #mut_tok #storage_ident> {\n                #( #messages )*\n            }\n        )\n    }\n\n    /// Generates code for the call forwarder implementation blocks.\n    ///\n    /// The `mutable` parameter indicates whether only read-only (`false`) or\n    /// write-only (`true`) messages and constructors are to be considered.\n    fn generate_call_forwarder_impl_blocks(&self, mutable: bool) -> TokenStream2 {\n        let impl_blocks = self.contract.module().impls().map(|item_impl| {\n            match item_impl.trait_path() {\n                Some(_) => {\n                    self.generate_call_forwarder_trait_impl_block(mutable, item_impl)\n                }\n                None => {\n                    self.generate_call_forwarder_inherent_impl_block(mutable, item_impl)\n                }\n            }\n        });\n        quote! { #( #impl_blocks )* }\n    }\n\n    /// Generates code for the call forwarder utility struct.\n    fn generate_call_forwarders(&self) -> TokenStream2 {\n        let forwarder_ident = Self::call_forwarder_ident();\n        let storage_ident = self.contract.module().storage().ident();\n        let impl_blocks_ref = self.generate_call_forwarder_impl_blocks(false);\n        let impl_blocks_refmut = self.generate_call_forwarder_impl_blocks(true);\n        let cfg = self.generate_cfg();\n        quote! {\n            #cfg\n            const _: () = {\n                impl<'a> ::ink_lang::ForwardCall for &'a #storage_ident {\n                    type Forwarder = #forwarder_ident<&'a #storage_ident>;\n\n                    #[inline]\n                    fn call(self) -> Self::Forwarder {\n                        #forwarder_ident { contract: self }\n                    }\n                }\n\n                impl<'a> ::ink_lang::ForwardCallMut for &'a mut #storage_ident {\n                    type Forwarder = #forwarder_ident<&'a mut #storage_ident>;\n\n                    #[inline]\n                    fn call_mut(self) -> Self::Forwarder {\n                        #forwarder_ident { contract: self }\n                    }\n                }\n\n                // Forwards contract messages to the chain.\n                #[doc(hidden)]\n                pub struct #forwarder_ident<T> {\n                    contract: T,\n                }\n\n                #impl_blocks_ref\n                #impl_blocks_refmut\n            };\n        }\n    }\n\n    /// Generates the code to allow short-hand cross-chain contract calls for messages.\n    fn generate_trait_impl_block_message(\n        &self,\n        message: ir::CallableWithSelector<ir::Message>,\n    ) -> TokenStream2 {\n        let storage_ident_str = self.contract.module().storage().ident().to_string();\n        let span = message.span();\n        let ident = message.ident();\n        let output_ident = format_ident!(\"{}Out\", ident.to_string().to_camel_case());\n        let ident_str = ident.to_string();\n        let trait_path = message\n            .item_impl()\n            .trait_path()\n            .expect(\"encountered missing trait path for trait impl block\")\n            .segments\n            .iter()\n            .map(|path_segment| &path_segment.ident)\n            .map(ToString::to_string)\n            .join(\"::\");\n        let error_str = format!(\n            \"encountered error while calling <{} as {}>::{}\",\n            storage_ident_str, trait_path, ident_str\n        );\n        let inputs_sig = message.inputs();\n        let inputs_params = message.inputs().map(|pat_type| &pat_type.pat);\n        let output_ty = message\n            .output()\n            .cloned()\n            .unwrap_or_else(|| syn::parse_quote! { () });\n        let receiver = message.receiver();\n        let forward_ident = match receiver {\n            ir::Receiver::Ref => format_ident!(\"call\"),\n            ir::Receiver::RefMut => format_ident!(\"call_mut\"),\n        };\n        let forward_trait = match receiver {\n            ir::Receiver::Ref => format_ident!(\"ForwardCall\"),\n            ir::Receiver::RefMut => format_ident!(\"ForwardCallMut\"),\n        };\n        let opt_mut = match receiver {\n            ir::Receiver::Ref => None,\n            ir::Receiver::RefMut => Some(quote! { mut }),\n        };\n        let opt_pub = match message.item_impl().trait_path() {\n            None => Some(quote! { pub }),\n            Some(_) => None,\n        };\n        quote_spanned!(span =>\n            type #output_ident = #output_ty;\n\n            #[inline]\n            #opt_pub fn #ident( #receiver #(, #inputs_sig )* ) -> Self::#output_ident {\n                <&#opt_mut Self as ::ink_lang::#forward_trait>::#forward_ident(self)\n                    .#ident( #( #inputs_params ),* )\n                    .fire()\n                    .expect(#error_str)\n            }\n        )\n    }\n\n    /// Generates the code to allow cross-chain contract calls for trait constructors.\n    fn generate_trait_impl_block_constructor(\n        constructor: ir::CallableWithSelector<ir::Constructor>,\n    ) -> TokenStream2 {\n        let span = constructor.span();\n        let attrs = constructor.attrs();\n        let ident = constructor.ident();\n        let output_ident = format_ident!(\"{}Out\", ident.to_string().to_camel_case());\n        let composed_selector = constructor.composed_selector().as_bytes().to_owned();\n        let input_bindings = constructor\n            .inputs()\n            .enumerate()\n            .map(|(n, _)| format_ident!(\"__ink_binding_{}\", n))\n            .collect::<Vec<_>>();\n        let input_types = constructor\n            .inputs()\n            .map(|pat_type| &*pat_type.ty)\n            .collect::<Vec<_>>();\n        let arg_list = Self::generate_arg_list(input_types.iter().cloned());\n        quote_spanned!(span =>\n            #[allow(clippy::type_complexity)]\n            type #output_ident = ::ink_env::call::CreateBuilder<\n                Environment,\n                ::ink_env::call::utils::Unset<Hash>,\n                ::ink_env::call::utils::Unset<u64>,\n                ::ink_env::call::utils::Unset<Balance>,\n                ::ink_env::call::utils::Set<::ink_env::call::ExecutionInput<#arg_list>>,\n                ::ink_env::call::utils::Unset<::ink_env::call::state::Salt>,\n                Self,\n            >;\n\n            #( #attrs )*\n            #[inline]\n            fn #ident(\n                #( #input_bindings : #input_types ),*\n            ) -> Self::#output_ident {\n                ::ink_env::call::build_create::<Environment, Salt, Self>()\n                    .exec_input(\n                        ::ink_env::call::ExecutionInput::new(\n                            ::ink_env::call::Selector::new([ #( #composed_selector ),* ])\n                        )\n                        #(\n                            .push_arg(#input_bindings)\n                        )*\n                    )\n            }\n        )\n    }\n\n    fn generate_trait_impl_block(&self, impl_block: &ir::ItemImpl) -> TokenStream2 {\n        assert!(impl_block.trait_path().is_some());\n        let cfg = self.generate_cfg();\n        let span = impl_block.span();\n        let attrs = impl_block.attrs();\n        let trait_path = impl_block\n            .trait_path()\n            .expect(\"encountered missing trait path\");\n        let trait_ident = impl_block\n            .trait_ident()\n            .expect(\"encountered missing trait identifier\");\n        let self_type = impl_block.self_type();\n        let messages = impl_block\n            .iter_messages()\n            .map(|message| self.generate_trait_impl_block_message(message));\n        let constructors = impl_block\n            .iter_constructors()\n            .map(Self::generate_trait_impl_block_constructor);\n        let hash = ir::InkTrait::compute_verify_hash(\n            trait_ident,\n            impl_block.iter_constructors().map(|constructor| {\n                let ident = constructor.ident().clone();\n                let len_inputs = constructor.inputs().count();\n                (ident, len_inputs)\n            }),\n            impl_block.iter_messages().map(|message| {\n                let ident = message.ident().clone();\n                let len_inputs = message.inputs().count() + 1;\n                let is_mut = message.receiver().is_ref_mut();\n                (ident, len_inputs, is_mut)\n            }),\n        );\n        let checksum = u32::from_be_bytes([hash[0], hash[1], hash[2], hash[3]]) as usize;\n        quote_spanned!(span =>\n            #cfg\n            unsafe impl ::ink_lang::CheckedInkTrait<[(); #checksum]> for #self_type {}\n\n            #cfg\n            #( #attrs )*\n            impl #trait_path for #self_type {\n                type __ink_Checksum = [(); #checksum];\n\n                #( #messages )*\n                #( #constructors )*\n            }\n        )\n    }\n\n    /// Generates the code to allow short-hand cross-chain contract calls for constructors.\n    ///\n    /// # Note\n    ///\n    /// For constructors this is the only way they are able to be called.\n    fn generate_inherent_impl_block_constructor(\n        constructor: ir::CallableWithSelector<ir::Constructor>,\n    ) -> TokenStream2 {\n        let span = constructor.span();\n        let attrs = constructor.attrs();\n        let ident = constructor.ident();\n        let composed_selector = constructor.composed_selector().as_bytes().to_owned();\n        let input_bindings = constructor\n            .inputs()\n            .enumerate()\n            .map(|(n, _)| format_ident!(\"__ink_binding_{}\", n))\n            .collect::<Vec<_>>();\n        let input_types = constructor\n            .inputs()\n            .map(|pat_type| &*pat_type.ty)\n            .collect::<Vec<_>>();\n        let arg_list = Self::generate_arg_list(input_types.iter().cloned());\n        quote_spanned!(span =>\n            #( #attrs )*\n            #[inline]\n            #[allow(clippy::type_complexity)]\n            pub fn #ident(\n                #( #input_bindings : #input_types ),*\n            ) -> ::ink_env::call::CreateBuilder<\n                Environment,\n                ::ink_env::call::utils::Unset<Hash>,\n                ::ink_env::call::utils::Unset<u64>,\n                ::ink_env::call::utils::Unset<Balance>,\n                ::ink_env::call::utils::Set<::ink_env::call::ExecutionInput<#arg_list>>,\n                ::ink_env::call::utils::Unset<::ink_env::call::state::Salt>,\n                Self,\n            > {\n                ::ink_env::call::build_create::<Environment, Self>()\n                    .exec_input(\n                        ::ink_env::call::ExecutionInput::new(\n                            ::ink_env::call::Selector::new([ #( #composed_selector ),* ])\n                        )\n                        #(\n                            .push_arg(#input_bindings)\n                        )*\n                    )\n            }\n        )\n    }\n\n    /// Generates the code to allow short-hand cross-chain contract calls for messages.\n    fn generate_inherent_impl_block_message(\n        &self,\n        message: ir::CallableWithSelector<ir::Message>,\n    ) -> TokenStream2 {\n        let storage_ident_str = self.contract.module().storage().ident().to_string();\n        let span = message.span();\n        let ident = message.ident();\n        let ident_str = ident.to_string();\n        let error_str = format!(\n            \"encountered error while calling {}::{}\",\n            storage_ident_str, ident_str\n        );\n        let inputs_sig = message.inputs();\n        let inputs_params = message.inputs().map(|pat_type| &pat_type.pat);\n        let output_sig = message.output().map(|output| quote! { -> #output });\n        let receiver = message.receiver();\n        let forward_ident = match receiver {\n            ir::Receiver::Ref => format_ident!(\"call\"),\n            ir::Receiver::RefMut => format_ident!(\"call_mut\"),\n        };\n        let forward_trait = match receiver {\n            ir::Receiver::Ref => format_ident!(\"ForwardCall\"),\n            ir::Receiver::RefMut => format_ident!(\"ForwardCallMut\"),\n        };\n        let opt_mut = match receiver {\n            ir::Receiver::Ref => None,\n            ir::Receiver::RefMut => Some(quote! { mut }),\n        };\n        let opt_pub = match message.item_impl().trait_path() {\n            None => Some(quote! { pub }),\n            Some(_) => None,\n        };\n        quote_spanned!(span =>\n            #[inline]\n            #opt_pub fn #ident( #receiver #(, #inputs_sig )* ) #output_sig {\n                <&#opt_mut Self as ::ink_lang::#forward_trait>::#forward_ident(self)\n                    .#ident( #( #inputs_params ),* )\n                    .fire()\n                    .expect(#error_str)\n            }\n        )\n    }\n\n    fn generate_inherent_impl_block(&self, impl_block: &ir::ItemImpl) -> TokenStream2 {\n        assert!(impl_block.trait_path().is_none());\n        let cfg = self.generate_cfg();\n        let span = impl_block.span();\n        let attrs = impl_block.attrs();\n        let self_type = impl_block.self_type();\n        let messages = impl_block\n            .iter_messages()\n            .map(|message| self.generate_inherent_impl_block_message(message));\n        let constructors = impl_block.iter_constructors().map(|constructor| {\n            Self::generate_inherent_impl_block_constructor(constructor)\n        });\n        quote_spanned!(span =>\n            #cfg\n            #( #attrs )*\n            impl #self_type {\n                #( #messages )*\n                #( #constructors )*\n            }\n        )\n    }\n\n    fn generate_impl_blocks(&self) -> TokenStream2 {\n        let impl_blocks = self.contract.module().impls().map(|impl_block| {\n            match impl_block.trait_path() {\n                Some(_) => self.generate_trait_impl_block(impl_block),\n                None => self.generate_inherent_impl_block(impl_block),\n            }\n        });\n        quote! {\n            #( #impl_blocks )*\n        }\n    }\n}\n"],["902","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::{\n    generator,\n    GenerateCode,\n    GenerateCodeUsing as _,\n};\nuse derive_more::From;\nuse ir::Callable as _;\nuse proc_macro2::{\n    Ident,\n    TokenStream as TokenStream2,\n};\nuse quote::{\n    format_ident,\n    quote,\n    quote_spanned,\n};\nuse syn::spanned::Spanned as _;\n\n/// Generates code for the message and constructor dispatcher.\n///\n/// This code efficiently selects the dispatched ink! constructor or message\n/// by inspecting the first four bytes (selector) of the given input bytes.\n///\n/// As this happens on every contract execution this code must be highly optimized.\n/// For that purpose a so-called dispatch enum is being generated that has a\n/// specialized `scale::Decode` implementation taking the first four bytes of\n/// the input stream in order to identify the enum variant that it is going to\n/// produce out of the rest of the input buffer.\n///\n/// The rest of the input buffer is then automatically decoded directly into the\n/// expected input types of the respective ink! constructor or message.\n#[derive(From)]\npub struct Dispatch<'a> {\n    contract: &'a ir::Contract,\n}\n\nimpl AsRef<ir::Contract> for Dispatch<'_> {\n    fn as_ref(&self) -> &ir::Contract {\n        self.contract\n    }\n}\n\nimpl GenerateCode for Dispatch<'_> {\n    fn generate_code(&self) -> TokenStream2 {\n        let no_cross_calling_cfg =\n            self.generate_code_using::<generator::CrossCallingConflictCfg>();\n        let entry_points = self.generate_entry_points();\n        let dispatch_using_mode = self.generate_dispatch_using_mode();\n        let dispatch_trait_impl_namespaces = self.generate_trait_impl_namespaces();\n        let dispatch_trait_impls = self.generate_dispatch_trait_impls();\n        let message_dispatch_enum = self.generate_message_dispatch_enum();\n        let constructor_dispatch_enum = self.generate_constructor_dispatch_enum();\n        quote! {\n            // We do not generate contract dispatch code while the contract\n            // is being tested or the contract is a dependency of another\n            // since both resulting compilations do not require dispatching.\n            #[cfg(not(test))]\n            #no_cross_calling_cfg\n            const _: () = {\n                #entry_points\n                #dispatch_using_mode\n                #dispatch_trait_impl_namespaces\n                #dispatch_trait_impls\n                #message_dispatch_enum\n                #constructor_dispatch_enum\n            };\n        }\n    }\n}\n\nimpl Dispatch<'_> {\n    /// Generates the static ink! contract entry points.\n    ///\n    /// # Note\n    ///\n    /// Those are expected to exist by the smart contracts host module.\n    /// They guide the dispatch, set-up and tear-down of a smart contract.\n    fn generate_entry_points(&self) -> TokenStream2 {\n        let storage_ident = self.contract.module().storage().ident();\n        let all_messages_deny_payment = self.all_messages_deny_payment();\n        quote! {\n            #[cfg(not(test))]\n            #[no_mangle]\n            fn deploy() -> u32 {\n                ::ink_lang::DispatchRetCode::from(\n                    <#storage_ident as ::ink_lang::DispatchUsingMode>::dispatch_using_mode(\n                        ::ink_lang::DispatchMode::Instantiate,\n                    ),\n                )\n                .to_u32()\n            }\n\n            #[cfg(not(test))]\n            #[no_mangle]\n            fn call() -> u32 {\n                if #all_messages_deny_payment {\n                    ::ink_lang::deny_payment::<<#storage_ident as ::ink_lang::ContractEnv>::Env>()\n                        .expect(\"caller transferred value even though all ink! message deny payments\")\n                }\n                ::ink_lang::DispatchRetCode::from(\n                    <#storage_ident as ::ink_lang::DispatchUsingMode>::dispatch_using_mode(\n                        ::ink_lang::DispatchMode::Call,\n                    ),\n                )\n                .to_u32()\n            }\n        }\n    }\n\n    /// Generates the `DispatchUsingMode` trait implementation to guide contract dispatch.\n    fn generate_dispatch_using_mode(&self) -> TokenStream2 {\n        let storage_ident = self.contract.module().storage().ident();\n        quote! {\n            impl ::ink_lang::DispatchUsingMode for #storage_ident {\n                #[allow(unused_parens)]\n                fn dispatch_using_mode(\n                    mode: ::ink_lang::DispatchMode\n                ) -> core::result::Result<(), ::ink_lang::DispatchError> {\n                    match mode {\n                        ::ink_lang::DispatchMode::Instantiate => {\n                            <<#storage_ident as ::ink_lang::ConstructorDispatcher>::Type as ::ink_lang::Execute>::execute(\n                                ::ink_env::decode_input::<<#storage_ident as ::ink_lang::ConstructorDispatcher>::Type>()\n                                    .map_err(|_| ::ink_lang::DispatchError::CouldNotReadInput)?\n                            )\n                        }\n                        ::ink_lang::DispatchMode::Call => {\n                            <<#storage_ident as ::ink_lang::MessageDispatcher>::Type as ::ink_lang::Execute>::execute(\n                                ::ink_env::decode_input::<<#storage_ident as ::ink_lang::MessageDispatcher>::Type>()\n                                    .map_err(|_| ::ink_lang::DispatchError::CouldNotReadInput)?\n                            )\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /// Returns the generated ink! namespace identifier for the given callable kind.\n    fn dispatch_trait_impl_namespace(kind: ir::CallableKind) -> Ident {\n        match kind {\n            ir::CallableKind::Constructor => format_ident!(\"__ink_Constr\"),\n            ir::CallableKind::Message => format_ident!(\"__ink_Msg\"),\n        }\n    }\n\n    /// Generates utility types to emulate namespaces to disambiguate dispatch trait\n    /// implementations for ink! messages and ink! constructors with overlapping\n    /// selectors.\n    fn generate_trait_impl_namespaces(&self) -> TokenStream2 {\n        let message_namespace =\n            Self::dispatch_trait_impl_namespace(ir::CallableKind::Message);\n        let constructor_namespace =\n            Self::dispatch_trait_impl_namespace(ir::CallableKind::Constructor);\n        quote! {\n            // Namespace for messages.\n            //\n            // # Note\n            //\n            // The `S` parameter is going to refer to array types `[(); N]`\n            // where `N` is the unique identifier of the associated message\n            // selector.\n            #[doc(hidden)]\n            pub struct #message_namespace<S> {\n                // We need to wrap inner because of Rust's orphan rules.\n                marker: core::marker::PhantomData<fn() -> S>,\n            }\n\n            // Namespace for constructors.\n            //\n            // # Note\n            //\n            // The `S` parameter is going to refer to array types `[(); N]`\n            // where `N` is the unique identifier of the associated constructor\n            // selector.\n            #[doc(hidden)]\n            pub struct #constructor_namespace<S> {\n                // We need to wrap inner because of Rust's orphan rules.\n                marker: core::marker::PhantomData<fn() -> S>,\n            }\n        }\n    }\n\n    /// Generates code for the dispatch trait impls for a generic ink! callable.\n    fn generate_trait_impls_for_callable<C>(\n        &self,\n        cws: ir::CallableWithSelector<'_, C>,\n    ) -> TokenStream2\n    where\n        C: ir::Callable + quote::ToTokens,\n    {\n        let callable = cws.callable();\n        let callable_span = callable.span();\n        let selector = cws.composed_selector();\n        let (selector_bytes, selector_id) = (selector.as_bytes(), selector.unique_id());\n        let input_types = callable\n            .inputs()\n            .map(|pat_type| &pat_type.ty)\n            .collect::<Vec<_>>();\n        let storage_ident = self.contract.module().storage().ident();\n        let namespace = Self::dispatch_trait_impl_namespace(cws.kind());\n        let input_types_tuple = if input_types.len() != 1 {\n            // Pack all types into a tuple if they are not exactly 1.\n            // This results in `()` for zero input types.\n            quote! { ( #( #input_types ),* ) }\n        } else {\n            // Return the single type without turning it into a tuple.\n            quote! { #( #input_types )* }\n        };\n        let fn_input_impl = quote_spanned!(callable.inputs_span() =>\n            impl ::ink_lang::FnInput for #namespace<[(); #selector_id]> {\n                type Input = #input_types_tuple;\n            }\n        );\n        let fn_selector_impl = quote_spanned!(callable_span =>\n            impl ::ink_lang::FnSelector for #namespace<[(); #selector_id]> {\n                const SELECTOR: ::ink_env::call::Selector = ::ink_env::call::Selector::new([\n                    #( #selector_bytes ),*\n                ]);\n            }\n        );\n        let fn_state_impl = quote_spanned!(callable_span =>\n            impl ::ink_lang::FnState for #namespace<[(); #selector_id]> {\n                type State = #storage_ident;\n            }\n        );\n        quote! {\n            #fn_input_impl\n            #fn_selector_impl\n            #fn_state_impl\n        }\n    }\n\n    /// Returns a tuple of:\n    ///\n    /// - Vector over the generated identifier bindings (`__ink_binding_N`) for all inputs.\n    /// - `TokenStream` representing the binding identifiers as tuple (for >=2 inputs),\n    ///   as single identifier (for exactly one input) or as wildcard (`_`) if there are\n    ///   no input bindings.\n    ///\n    /// # Examples\n    ///\n    /// **No inputs:**\n    /// ```\n    /// # use quote::quote;\n    /// # let x: (Vec<()>, _) =\n    /// ( vec![],\n    ///   quote! { _ } )\n    /// # ;\n    /// ```\n    ///\n    /// **Exactly one input:**\n    /// ```\n    /// # use quote::quote;\n    /// # let __ink_binding_0 = ();\n    /// ( vec![__ink_binding_0],\n    ///   quote! { __ink_binding_0 } )\n    /// # ;\n    /// ```\n    ///\n    /// **Multiple (>=2) inputs:**\n    /// ```\n    /// # use quote::quote;\n    /// # let __ink_binding_0 = ();\n    /// # let __ink_binding_1 = ();\n    /// ( vec![__ink_binding_0, __ink_binding_1, /* ... */],\n    ///   quote! { (__ink_binding_0, __ink_binding_1, ..) } )\n    /// # ;\n    /// ```\n    fn generate_input_bindings<C>(callable: &C) -> (Vec<Ident>, TokenStream2)\n    where\n        C: ir::Callable,\n    {\n        let input_bindings = callable\n            .inputs()\n            .enumerate()\n            .map(|(n, _pat_type)| format_ident!(\"__ink_binding_{}\", n))\n            .collect::<Vec<_>>();\n        let inputs_as_tuple_or_wildcard = match input_bindings.len() {\n            0 => quote! { _ },\n            1 => quote! { #( #input_bindings ),* },\n            _ => quote! { ( #( #input_bindings ),* ) },\n        };\n        (input_bindings, inputs_as_tuple_or_wildcard)\n    }\n\n    /// Generates all the dispatch trait implementations for the given ink! message.\n    fn generate_trait_impls_for_message(\n        &self,\n        cws: ir::CallableWithSelector<'_, ir::Message>,\n    ) -> TokenStream2 {\n        let message = cws.callable();\n        let message_span = message.span();\n        let selector = cws.composed_selector();\n        let selector_id = selector.unique_id();\n        let output_tokens = message\n            .output()\n            .map(quote::ToTokens::to_token_stream)\n            .unwrap_or_else(|| quote! { () });\n        let is_mut = message.receiver().is_ref_mut();\n        let storage_ident = self.contract.module().storage().ident();\n        let message_ident = message.ident();\n        let namespace = Self::dispatch_trait_impl_namespace(ir::CallableKind::Message);\n        let fn_output_impl = quote_spanned!(message.output().span() =>\n            impl ::ink_lang::FnOutput for #namespace<[(); #selector_id]> {\n                #[allow(unused_parens)]\n                type Output = #output_tokens;\n            }\n        );\n        let callable_impl = self.generate_trait_impls_for_callable(cws);\n        let (mut_token, message_trait_ident) = if is_mut {\n            (\n                Some(syn::token::Mut::default()),\n                format_ident!(\"MessageMut\"),\n            )\n        } else {\n            (None, format_ident!(\"MessageRef\"))\n        };\n        let (input_bindings, inputs_as_tuple_or_wildcard) =\n            Self::generate_input_bindings(message);\n        let as_trait = cws.item_impl().trait_path().map(|trait_path| {\n            quote_spanned!(message_span =>\n                as #trait_path\n            )\n        });\n        let message_impl = quote_spanned!(message_span =>\n            impl ::ink_lang::#message_trait_ident for #namespace<[(); #selector_id]> {\n                const CALLABLE: fn(\n                    &#mut_token <Self as ::ink_lang::FnState>::State,\n                    <Self as ::ink_lang::FnInput>::Input\n                ) -> <Self as ::ink_lang::FnOutput>::Output = |state, #inputs_as_tuple_or_wildcard| {\n                    <#storage_ident #as_trait>::#message_ident(state, #( #input_bindings ),* )\n                };\n            }\n        );\n        quote_spanned!(message_span =>\n            #callable_impl\n            #fn_output_impl\n            #message_impl\n        )\n    }\n\n    /// Generates all the dispatch trait implementations for the given ink! constructor.\n    fn generate_trait_impls_for_constructor(\n        &self,\n        cws: ir::CallableWithSelector<'_, ir::Constructor>,\n    ) -> TokenStream2 {\n        let constructor = cws.callable();\n        let constructor_span = constructor.span();\n        let selector = cws.composed_selector();\n        let selector_id = selector.unique_id();\n        let storage_ident = self.contract.module().storage().ident();\n        let constructor_ident = constructor.ident();\n        let namespace =\n            Self::dispatch_trait_impl_namespace(ir::CallableKind::Constructor);\n        let callable_impl = self.generate_trait_impls_for_callable(cws);\n        let (input_bindings, inputs_as_tuple_or_wildcard) =\n            Self::generate_input_bindings(constructor);\n        let as_trait = cws.item_impl().trait_path().map(|trait_path| {\n            quote_spanned!(constructor_span =>\n                as #trait_path\n            )\n        });\n        let constructor_impl = quote_spanned!(constructor_span =>\n            impl ::ink_lang::Constructor for #namespace<[(); #selector_id]> {\n                const CALLABLE: fn(\n                    <Self as ::ink_lang::FnInput>::Input\n                ) -> <Self as ::ink_lang::FnState>::State = |#inputs_as_tuple_or_wildcard| {\n                    <#storage_ident #as_trait>::#constructor_ident(#( #input_bindings ),* )\n                };\n            }\n        );\n        quote_spanned!(constructor_span =>\n            #callable_impl\n            #constructor_impl\n        )\n    }\n\n    /// Generate all dispatch trait implementations for ink! messages and ink! constructors.\n    fn generate_dispatch_trait_impls(&self) -> TokenStream2 {\n        let message_impls = self\n            .contract_messages()\n            .map(|message| self.generate_trait_impls_for_message(message));\n        let constructor_impls = self\n            .contract_constructors()\n            .map(|constructor| self.generate_trait_impls_for_constructor(constructor));\n        quote! {\n            #( #message_impls )*\n            #( #constructor_impls )*\n        }\n    }\n\n    /// Generates variant identifiers for the generated dispatch enum.\n    ///\n    /// Since we want to avoid generating random names we generate identifiers\n    /// in terms of the selectors of the associated ink! messages or constructors.\n    ///\n    /// ## Example\n    ///\n    /// Given prefix of `\"Message\"` and selector with bytes `0xDEADBEEF` we\n    /// generate the following identifier: `__ink_Message_0xdeadbeef`\n    ///\n    /// This way it is clear that this is an ink! generated identifier and even\n    /// encodes the unique selector bytes to make the identifier unique.\n    fn generate_dispatch_variant_ident<C>(\n        &self,\n        cws: ir::CallableWithSelector<'_, C>,\n    ) -> Ident\n    where\n        C: ir::Callable,\n    {\n        let selector_bytes = cws.composed_selector().as_bytes().to_owned();\n        let prefix = match cws.callable().kind() {\n            ir::CallableKind::Message => \"Message\",\n            ir::CallableKind::Constructor => \"Constructor\",\n        };\n        quote::format_ident!(\n            \"__ink_{}_0x{:02x}{:02x}{:02x}{:02x}\",\n            prefix,\n            selector_bytes[0],\n            selector_bytes[1],\n            selector_bytes[2],\n            selector_bytes[3]\n        )\n    }\n\n    /// Generates one match arm of the dispatch `scale::Decode` implementation.\n    ///\n    /// # Note\n    ///\n    /// There is one match arm per ink! constructor or message for the dispatch\n    /// `scale::Decode` implementation.\n    fn generate_dispatch_variant_decode<C>(\n        &self,\n        cws: ir::CallableWithSelector<'_, C>,\n    ) -> TokenStream2\n    where\n        C: ir::Callable,\n    {\n        let selector_bytes = cws.composed_selector().as_bytes().to_owned();\n        let variant_ident = self.generate_dispatch_variant_ident(cws);\n        let variant_types = cws.callable().inputs().map(|arg| &arg.ty);\n        quote! {\n            [ #( #selector_bytes ),* ] => {\n                Ok(Self::#variant_ident(\n                    #(\n                        <#variant_types as ::scale::Decode>::decode(input)?\n                    ),*\n                ))\n            }\n        }\n    }\n\n    /// Generates one match arm of the dispatch variant enum.\n    ///\n    /// # Note\n    ///\n    /// There is one match arm per ink! constructor or message for the dispatch\n    /// `scale::Decode` implementation.\n    fn generate_dispatch_variant_arm<C>(\n        &self,\n        cws: ir::CallableWithSelector<'_, C>,\n    ) -> TokenStream2\n    where\n        C: ir::Callable,\n    {\n        let input_types = cws.callable().inputs().map(|arg| &arg.ty);\n        let variant_ident = self.generate_dispatch_variant_ident(cws);\n        quote! {\n            #variant_ident(#(#input_types),*)\n        }\n    }\n\n    /// Returns `true` if all ink! messages of `self` deny payments.\n    ///\n    /// # Note\n    ///\n    /// This information is used to produce better code in this scenario.\n    fn all_messages_deny_payment(&self) -> bool {\n        self.contract\n            .module()\n            .impls()\n            .flat_map(ir::ItemImpl::iter_messages)\n            .all(|message| !message.is_payable())\n    }\n\n    /// Generates one match arm of the dispatch message for the `execute` implementation.\n    ///\n    /// # Note\n    ///\n    /// This is basically the code per ink! message that is going to be executed after\n    /// the dispatch has already taken place.\n    fn generate_dispatch_execute_message_arm(\n        &self,\n        cws: ir::CallableWithSelector<'_, ir::Message>,\n    ) -> TokenStream2 {\n        let storage_ident = self.contract.module().storage().ident();\n        let ident = self.generate_dispatch_variant_ident(cws);\n        let message = cws.callable();\n        let arg_pats = message.inputs().map(|arg| &arg.pat).collect::<Vec<_>>();\n        let arg_inputs = if arg_pats.len() == 1 {\n            quote! { #(#arg_pats),* }\n        } else {\n            quote! { ( #(#arg_pats),* ) }\n        };\n        let (mut_mod, msg_trait, exec_fn) = match message.receiver() {\n            ir::Receiver::RefMut => {\n                (\n                    Some(quote! { mut }),\n                    quote! { MessageMut },\n                    quote! { execute_message_mut },\n                )\n            }\n            ir::Receiver::Ref => {\n                (None, quote! { MessageRef }, quote! { execute_message })\n            }\n        };\n        let selector_id = cws.composed_selector().unique_id();\n        let namespace = Self::dispatch_trait_impl_namespace(ir::CallableKind::Message);\n        // If all ink! messages deny payment we can move the payment check to before\n        // the message dispatch which is more efficient.\n        let accepts_payments = cws.is_payable() || self.all_messages_deny_payment();\n        let is_dynamic_storage_allocation_enabled = self\n            .contract\n            .config()\n            .is_dynamic_storage_allocator_enabled();\n        quote! {\n            Self::#ident(#(#arg_pats),*) => {\n                ::ink_lang::#exec_fn::<<#storage_ident as ::ink_lang::ContractEnv>::Env, #namespace<[(); #selector_id]>, _>(\n                    ::ink_lang::AcceptsPayments(#accepts_payments),\n                    ::ink_lang::EnablesDynamicStorageAllocator(#is_dynamic_storage_allocation_enabled),\n                    move |state: &#mut_mod #storage_ident| {\n                        <#namespace<[(); #selector_id]> as ::ink_lang::#msg_trait>::CALLABLE(\n                            state, #arg_inputs\n                        )\n                    }\n                )\n            }\n        }\n    }\n\n    /// Returns an iterator over all ink! messages of the ink! contract.\n    fn contract_messages(\n        &self,\n    ) -> impl Iterator<Item = ir::CallableWithSelector<ir::Message>> {\n        self.contract\n            .module()\n            .impls()\n            .map(|impl_item| impl_item.iter_messages())\n            .flatten()\n    }\n\n    /// Generates the entire dispatch variant enum for all ink! messages.\n    fn generate_message_dispatch_enum(&self) -> TokenStream2 {\n        let storage_ident = self.contract.module().storage().ident();\n        let message_variants = self\n            .contract_messages()\n            .map(|message| self.generate_dispatch_variant_arm(message));\n        let decode_message = self\n            .contract_messages()\n            .map(|message| self.generate_dispatch_variant_decode(message));\n        let execute_variants = self\n            .contract_messages()\n            .map(|message| self.generate_dispatch_execute_message_arm(message));\n        quote! {\n            const _: () = {\n                #[doc(hidden)]\n                pub enum __ink_MessageDispatchEnum {\n                    #( #message_variants ),*\n                }\n\n                impl ::ink_lang::MessageDispatcher for #storage_ident {\n                    type Type = __ink_MessageDispatchEnum;\n                }\n\n                impl ::scale::Decode for __ink_MessageDispatchEnum {\n                    fn decode<I: ::scale::Input>(input: &mut I) -> ::core::result::Result<Self, ::scale::Error> {\n                        match <[u8; 4] as ::scale::Decode>::decode(input)? {\n                            #( #decode_message )*\n                            _invalid => Err(::scale::Error::from(\"encountered unknown ink! message selector\"))\n                        }\n                    }\n                }\n\n                impl ::ink_lang::Execute for __ink_MessageDispatchEnum {\n                    fn execute(self) -> ::core::result::Result<(), ::ink_lang::DispatchError> {\n                        match self {\n                            #( #execute_variants )*\n                        }\n                    }\n                }\n            };\n        }\n    }\n\n    /// Generates one match arm of the dispatch constructor for the `execute` implementation.\n    ///\n    /// # Note\n    ///\n    /// This is basically the code per ink! constructor that is going to be executed after\n    /// the dispatch has already taken place.\n    fn generate_dispatch_execute_constructor_arm(\n        &self,\n        cws: ir::CallableWithSelector<'_, ir::Constructor>,\n    ) -> TokenStream2 {\n        let ident = self.generate_dispatch_variant_ident(cws);\n        let constructor = cws.callable();\n        let arg_pats = constructor.inputs().map(|arg| &arg.pat).collect::<Vec<_>>();\n        let arg_inputs = if arg_pats.len() == 1 {\n            quote! { #(#arg_pats),* }\n        } else {\n            quote! { ( #(#arg_pats),* ) }\n        };\n        let selector_id = cws.composed_selector().unique_id();\n        let namespace =\n            Self::dispatch_trait_impl_namespace(ir::CallableKind::Constructor);\n        let is_dynamic_storage_allocation_enabled = self\n            .contract\n            .config()\n            .is_dynamic_storage_allocator_enabled();\n        quote! {\n            Self::#ident(#(#arg_pats),*) => {\n                ::ink_lang::execute_constructor::<#namespace<[(); #selector_id]>, _>(\n                    ::ink_lang::EnablesDynamicStorageAllocator(#is_dynamic_storage_allocation_enabled),\n                    move || {\n                        <#namespace<[(); #selector_id]> as ::ink_lang::Constructor>::CALLABLE(\n                            #arg_inputs\n                        )\n                    }\n                )\n            }\n        }\n    }\n\n    /// Returns an iterator over all ink! constructors of the ink! contract.\n    fn contract_constructors(\n        &self,\n    ) -> impl Iterator<Item = ir::CallableWithSelector<ir::Constructor>> {\n        self.contract\n            .module()\n            .impls()\n            .map(|impl_item| impl_item.iter_constructors())\n            .flatten()\n    }\n\n    /// Generates the entire dispatch variant enum for all ink! messages.\n    fn generate_constructor_dispatch_enum(&self) -> TokenStream2 {\n        let storage_ident = self.contract.module().storage().ident();\n        let message_variants = self\n            .contract_constructors()\n            .map(|message| self.generate_dispatch_variant_arm(message));\n        let decode_message = self\n            .contract_constructors()\n            .map(|message| self.generate_dispatch_variant_decode(message));\n        let execute_variants = self\n            .contract_constructors()\n            .map(|cws| self.generate_dispatch_execute_constructor_arm(cws));\n        quote! {\n            const _: () = {\n                #[doc(hidden)]\n                pub enum __ink_ConstructorDispatchEnum {\n                    #( #message_variants ),*\n                }\n\n                impl ::ink_lang::ConstructorDispatcher for #storage_ident {\n                    type Type = __ink_ConstructorDispatchEnum;\n                }\n\n                impl ::scale::Decode for __ink_ConstructorDispatchEnum {\n                    fn decode<I: ::scale::Input>(input: &mut I) -> ::core::result::Result<Self, ::scale::Error> {\n                        match <[u8; 4] as ::scale::Decode>::decode(input)? {\n                            #( #decode_message )*\n                            _invalid => Err(::scale::Error::from(\"encountered unknown ink! constructor selector\"))\n                        }\n                    }\n                }\n\n                impl ::ink_lang::Execute for __ink_ConstructorDispatchEnum {\n                    fn execute(self) -> ::core::result::Result<(), ::ink_lang::DispatchError> {\n                        match self {\n                            #( #execute_variants )*\n                        }\n                    }\n                }\n            };\n        }\n    }\n}\n"],["903","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::{\n    generator,\n    GenerateCode,\n    GenerateCodeUsing,\n};\nuse derive_more::From;\nuse proc_macro2::TokenStream as TokenStream2;\nuse quote::quote;\n\n/// Generates code for the entirety of the ink! contract.\n#[derive(From)]\npub struct Contract<'a> {\n    /// The contract to generate code for.\n    contract: &'a ir::Contract,\n}\n\nimpl AsRef<ir::Contract> for Contract<'_> {\n    fn as_ref(&self) -> &ir::Contract {\n        self.contract\n    }\n}\n\nimpl GenerateCode for Contract<'_> {\n    /// Generates ink! contract code.\n    fn generate_code(&self) -> TokenStream2 {\n        let module = self.contract.module();\n        let ident = module.ident();\n        let attrs = module.attrs();\n        let vis = module.vis();\n        let env = self.generate_code_using::<generator::Env>();\n        let storage = self.generate_code_using::<generator::Storage>();\n        let events = self.generate_code_using::<generator::Events>();\n        let dispatch = self.generate_code_using::<generator::Dispatch>();\n        let item_impls = self.generate_code_using::<generator::ItemImpls>();\n        let cross_calling = self.generate_code_using::<generator::CrossCalling>();\n        let metadata = self.generate_code_using::<generator::Metadata>();\n        let non_ink_items = self\n            .contract\n            .module()\n            .items()\n            .iter()\n            .filter_map(ir::Item::map_rust_item);\n        quote! {\n            #( #attrs )*\n            #vis mod #ident {\n                #env\n                #storage\n                #events\n                #dispatch\n                #item_impls\n                #cross_calling\n                #metadata\n                #( #non_ink_items )*\n            }\n        }\n    }\n}\n"],["904","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::{\n    generator,\n    GenerateCode,\n    GenerateCodeUsing as _,\n};\nuse derive_more::From;\nuse heck::CamelCase as _;\nuse ir::Callable as _;\nuse proc_macro2::TokenStream as TokenStream2;\nuse quote::{\n    format_ident,\n    quote,\n    quote_spanned,\n    ToTokens,\n};\nuse syn::spanned::Spanned as _;\n\n/// Generates code for all ink! implementation blocks.\n#[derive(From)]\npub struct ItemImpls<'a> {\n    contract: &'a ir::Contract,\n}\n\nimpl AsRef<ir::Contract> for ItemImpls<'_> {\n    fn as_ref(&self) -> &ir::Contract {\n        &self.contract\n    }\n}\n\nimpl GenerateCode for ItemImpls<'_> {\n    fn generate_code(&self) -> TokenStream2 {\n        let item_impls = self\n            .contract\n            .module()\n            .impls()\n            .map(|item_impl| self.generate_item_impl(item_impl));\n        let no_cross_calling_cfg =\n            self.generate_code_using::<generator::CrossCallingConflictCfg>();\n        quote! {\n            #no_cross_calling_cfg\n            const _: () = {\n                use ::ink_lang::{Env, EmitEvent, StaticEnv};\n\n                #( #item_impls )*\n            };\n        }\n    }\n}\n\nimpl ItemImpls<'_> {\n    /// Generates the code for the given ink! constructor within a trait implementation block.\n    fn generate_trait_constructor(constructor: &ir::Constructor) -> TokenStream2 {\n        let span = constructor.span();\n        let attrs = constructor.attrs();\n        let vis = match constructor.visibility() {\n            ir::Visibility::Inherited => None,\n            ir::Visibility::Public(vis_public) => Some(vis_public),\n        };\n        let ident = constructor.ident();\n        let output_ident = format_ident!(\"{}Out\", ident.to_string().to_camel_case());\n        let inputs = constructor.inputs();\n        let statements = constructor.statements();\n        quote_spanned!(span =>\n            type #output_ident = Self;\n\n            #( #attrs )*\n            #vis fn #ident( #( #inputs ),* ) -> Self::#output_ident {\n                #( #statements )*\n            }\n        )\n    }\n\n    /// Generates the code for the given ink! message within a trait implementation block.\n    fn generate_trait_message(message: &ir::Message) -> TokenStream2 {\n        let span = message.span();\n        let attrs = message.attrs();\n        let vis = match message.visibility() {\n            ir::Visibility::Inherited => None,\n            ir::Visibility::Public(vis_public) => Some(vis_public),\n        };\n        let receiver = match message.receiver() {\n            ir::Receiver::RefMut => quote! { &mut self },\n            ir::Receiver::Ref => quote! { &self },\n        };\n        let ident = message.ident();\n        let output_ident = format_ident!(\"{}Out\", ident.to_string().to_camel_case());\n        let inputs = message.inputs();\n        let output = message\n            .output()\n            .cloned()\n            .unwrap_or_else(|| syn::parse_quote! { () });\n        let statements = message.statements();\n        quote_spanned!(span =>\n            type #output_ident = #output;\n\n            #( #attrs )*\n            #vis fn #ident(#receiver #(, #inputs )* ) -> Self::#output_ident {\n                #( #statements )*\n            }\n        )\n    }\n\n    fn generate_trait_item_impl(item_impl: &ir::ItemImpl) -> TokenStream2 {\n        assert!(item_impl.trait_path().is_some());\n        let span = item_impl.span();\n        let attrs = item_impl.attrs();\n        let messages = item_impl\n            .iter_messages()\n            .map(|cws| Self::generate_trait_message(cws.callable()));\n        let constructors = item_impl\n            .iter_constructors()\n            .map(|cws| Self::generate_trait_constructor(cws.callable()));\n        let other_items = item_impl\n            .items()\n            .iter()\n            .filter_map(ir::ImplItem::filter_map_other_item)\n            .map(ToTokens::to_token_stream);\n        let trait_path = item_impl\n            .trait_path()\n            .expect(\"encountered missing trait path for trait impl block\");\n        let trait_ident = item_impl\n            .trait_ident()\n            .expect(\"encountered missing trait identifier for trait impl block\");\n        let self_type = item_impl.self_type();\n        let hash = ir::InkTrait::compute_verify_hash(\n            trait_ident,\n            item_impl.iter_constructors().map(|constructor| {\n                let ident = constructor.ident().clone();\n                let len_inputs = constructor.inputs().count();\n                (ident, len_inputs)\n            }),\n            item_impl.iter_messages().map(|message| {\n                let ident = message.ident().clone();\n                let len_inputs = message.inputs().count() + 1;\n                let is_mut = message.receiver().is_ref_mut();\n                (ident, len_inputs, is_mut)\n            }),\n        );\n        let checksum = u32::from_be_bytes([hash[0], hash[1], hash[2], hash[3]]) as usize;\n        quote_spanned!(span =>\n            unsafe impl ::ink_lang::CheckedInkTrait<[(); #checksum]> for #self_type {}\n\n            #( #attrs )*\n            impl #trait_path for #self_type {\n                type __ink_Checksum = [(); #checksum];\n\n                #( #constructors )*\n                #( #messages )*\n                #( #other_items )*\n            }\n        )\n    }\n\n    /// Generates the code for the given ink! constructor within an inherent implementation block.\n    fn generate_inherent_constructor(constructor: &ir::Constructor) -> TokenStream2 {\n        let span = constructor.span();\n        let attrs = constructor.attrs();\n        let vis = match constructor.visibility() {\n            ir::Visibility::Inherited => None,\n            ir::Visibility::Public(vis_public) => Some(vis_public),\n        };\n        let ident = constructor.ident();\n        let inputs = constructor.inputs();\n        let statements = constructor.statements();\n        quote_spanned!(span =>\n            #( #attrs )*\n            #vis fn #ident( #( #inputs ),* ) -> Self {\n                #( #statements )*\n            }\n        )\n    }\n\n    /// Generates the code for the given ink! message within an inherent implementation block.\n    fn generate_inherent_message(message: &ir::Message) -> TokenStream2 {\n        let span = message.span();\n        let attrs = message.attrs();\n        let vis = match message.visibility() {\n            ir::Visibility::Inherited => None,\n            ir::Visibility::Public(vis_public) => Some(vis_public),\n        };\n        let receiver = match message.receiver() {\n            ir::Receiver::RefMut => quote! { &mut self },\n            ir::Receiver::Ref => quote! { &self },\n        };\n        let ident = message.ident();\n        let inputs = message.inputs();\n        let output_arrow = message.output().map(|_| quote! { -> });\n        let output = message.output();\n        let statements = message.statements();\n        quote_spanned!(span =>\n            #( #attrs )*\n            #vis fn #ident(#receiver, #( #inputs ),* ) #output_arrow #output {\n                #( #statements )*\n            }\n        )\n    }\n\n    fn generate_inherent_item_impl(item_impl: &ir::ItemImpl) -> TokenStream2 {\n        assert!(item_impl.trait_path().is_none());\n        let span = item_impl.span();\n        let attrs = item_impl.attrs();\n        let messages = item_impl\n            .iter_messages()\n            .map(|cws| Self::generate_inherent_message(cws.callable()));\n        let constructors = item_impl\n            .iter_constructors()\n            .map(|cws| Self::generate_inherent_constructor(cws.callable()));\n        let other_items = item_impl\n            .items()\n            .iter()\n            .filter_map(ir::ImplItem::filter_map_other_item)\n            .map(ToTokens::to_token_stream);\n        let self_type = item_impl.self_type();\n        quote_spanned!(span =>\n            #( #attrs )*\n            impl #self_type {\n                #( #constructors )*\n                #( #messages )*\n                #( #other_items )*\n            }\n        )\n    }\n\n    /// Generates code to guard against ink! implementations that have not been implemented\n    /// for the ink! storage struct.\n    fn generate_item_impl_self_ty_guard(&self, item_impl: &ir::ItemImpl) -> TokenStream2 {\n        let self_ty = item_impl.self_type();\n        let span = self_ty.span();\n        let storage_ident = self.contract.module().storage().ident();\n        quote_spanned!(span =>\n            ::ink_lang::static_assertions::assert_type_eq_all!(\n                #self_ty,\n                #storage_ident,\n            );\n        )\n    }\n\n    /// Generates code for the given ink! implementation block.\n    fn generate_item_impl(&self, item_impl: &ir::ItemImpl) -> TokenStream2 {\n        let self_ty_guard = self.generate_item_impl_self_ty_guard(item_impl);\n        let impl_block = match item_impl.trait_path() {\n            Some(_) => Self::generate_trait_item_impl(item_impl),\n            None => Self::generate_inherent_item_impl(item_impl),\n        };\n        quote! {\n            #self_ty_guard\n            #impl_block\n        }\n    }\n}\n"],["905","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::GenerateCode;\nuse derive_more::From;\nuse ir::Callable as _;\nuse proc_macro2::TokenStream as TokenStream2;\nuse quote::{\n    quote,\n    quote_spanned,\n};\nuse syn::spanned::Spanned as _;\n\n/// Generates code to generate the metadata of the contract.\n#[derive(From)]\npub struct Metadata<'a> {\n    /// The contract to generate code for.\n    contract: &'a ir::Contract,\n}\n\nimpl GenerateCode for Metadata<'_> {\n    fn generate_code(&self) -> TokenStream2 {\n        let contract = self.generate_contract();\n        let layout = self.generate_layout();\n\n        quote! {\n            #[cfg(feature = \"std\")]\n            #[cfg(not(feature = \"ink-as-dependency\"))]\n            const _: () = {\n                #[no_mangle]\n                pub fn __ink_generate_metadata() -> ::ink_metadata::InkProject  {\n                    let contract: ::ink_metadata::ContractSpec = {\n                        #contract\n                    };\n                    let layout: ::ink_metadata::layout::Layout = {\n                        #layout\n                    };\n                    ::ink_metadata::InkProject::new(layout, contract)\n                }\n            };\n        }\n    }\n}\n\nimpl Metadata<'_> {\n    fn generate_layout(&self) -> TokenStream2 {\n        let contract_ident = self.contract.module().storage().ident();\n        quote! {\n            <#contract_ident as ::ink_storage::traits::StorageLayout>::layout(\n                &mut ::ink_primitives::KeyPtr::from(::ink_primitives::Key::from([0x00; 32]))\n            )\n        }\n    }\n\n    fn generate_contract(&self) -> TokenStream2 {\n        let constructors = self.generate_constructors();\n        let messages = self.generate_messages();\n        let events = self.generate_events();\n        let docs = self.generate_docs();\n\n        quote! {\n            ::ink_metadata::ContractSpec::new()\n                .constructors(vec![\n                    #(#constructors ,)*\n                ])\n                .messages(vec![\n                    #(#messages ,)*\n                ])\n                .events(vec![\n                    #(#events ,)*\n                ])\n                .docs(vec![\n                    #(#docs ,)*\n                ])\n                .done()\n        }\n    }\n\n    /// Extracts the doc strings from the given slice of attributes.\n    fn extract_doc_comments(\n        attributes: &[syn::Attribute],\n    ) -> impl Iterator<Item = String> + '_ {\n        attributes\n            .iter()\n            .filter_map(|attribute| {\n                match attribute.parse_meta() {\n                    Ok(syn::Meta::NameValue(name_value)) => Some(name_value),\n                    Ok(_) | Err(_) => None,\n                }\n            })\n            .filter(|name_value| name_value.path.is_ident(\"doc\"))\n            .filter_map(|name_value| {\n                match name_value.lit {\n                    syn::Lit::Str(lit_str) => Some(lit_str.value()),\n                    _ => None,\n                }\n            })\n    }\n\n    /// Generates ink! metadata for all contract constructors.\n    fn generate_constructors(&self) -> impl Iterator<Item = TokenStream2> + '_ {\n        self.contract\n            .module()\n            .impls()\n            .flat_map(|impl_block| {\n                let trait_ident = impl_block\n                    .trait_path()\n                    .map(|path| path.segments.last().map(|seg| &seg.ident))\n                    .flatten();\n                impl_block\n                    .iter_constructors()\n                    .map(move |constructor| (trait_ident, constructor))\n            })\n            .map(|(trait_ident, constructor)| {\n                let span = constructor.span();\n                let attrs = constructor.attrs();\n                let docs = Self::extract_doc_comments(&attrs);\n                let selector = constructor.composed_selector();\n                let selector_bytes = selector.as_bytes();\n                let constructor = constructor.callable();\n                let ident = constructor.ident();\n                let ident_lit = ident.to_string();\n                let args = constructor\n                    .inputs()\n                    .map(|arg| Self::generate_message_param(arg));\n                let constr = match trait_ident {\n                    Some(trait_ident) => {\n                        let trait_ident_lit = trait_ident.to_string();\n                        quote_spanned!(span => from_trait_and_name(#trait_ident_lit, #ident_lit))\n                    }\n                    None => {\n                        quote_spanned!(span => from_name(#ident_lit))\n                    }\n                };\n                quote_spanned!(span =>\n                    ::ink_metadata::ConstructorSpec::#constr\n                        .selector([#(#selector_bytes),*])\n                        .args(vec![\n                            #(#args ,)*\n                        ])\n                        .docs(vec![\n                            #(#docs ,)*\n                        ])\n                        .done()\n                )\n            })\n    }\n\n    /// Generates the ink! metadata for the given parameter and parameter type.\n    fn generate_message_param(pat_type: &syn::PatType) -> TokenStream2 {\n        let ident = match &*pat_type.pat {\n            syn::Pat::Ident(ident) => &ident.ident,\n            _ => unreachable!(\"encountered unexpected non identifier in ink! parameter\"),\n        };\n        let ident_lit = ident.to_string();\n        let type_spec = Self::generate_type_spec(&pat_type.ty);\n        quote! {\n            ::ink_metadata::MessageParamSpec::new(#ident_lit)\n                .of_type(#type_spec)\n                .done()\n        }\n    }\n\n    /// Generates the ink! metadata for the given type.\n    fn generate_type_spec(ty: &syn::Type) -> TokenStream2 {\n        fn without_display_name(ty: &syn::Type) -> TokenStream2 {\n            quote! { ::ink_metadata::TypeSpec::new::<#ty>() }\n        }\n        if let syn::Type::Path(type_path) = ty {\n            if type_path.qself.is_some() {\n                return without_display_name(ty)\n            }\n            let path = &type_path.path;\n            if path.segments.is_empty() {\n                return without_display_name(ty)\n            }\n            let segs = path\n                .segments\n                .iter()\n                .map(|seg| seg.ident.to_string())\n                .collect::<Vec<_>>();\n            quote! {\n                ::ink_metadata::TypeSpec::with_name_segs::<#ty, _>(\n                    vec![#(#segs),*].into_iter().map(AsRef::as_ref)\n                )\n            }\n        } else {\n            without_display_name(ty)\n        }\n    }\n\n    fn generate_messages(&self) -> impl Iterator<Item = TokenStream2> + '_ {\n        self.contract\n            .module()\n            .impls()\n            .flat_map(|impl_block| {\n                let trait_ident = impl_block\n                    .trait_path()\n                    .map(|path| path.segments.last().map(|seg| &seg.ident))\n                    .flatten();\n                impl_block\n                    .iter_messages()\n                    .map(move |message| (trait_ident, message))\n            })\n            .map(|(trait_ident, message)| {\n                let span = message.span();\n                let attrs = message.attrs();\n                let docs = Self::extract_doc_comments(&attrs);\n                let selector = message.composed_selector();\n                let selector_bytes = selector.as_bytes();\n                let is_payable = message.is_payable();\n                let message = message.callable();\n                let mutates = message.receiver().is_ref_mut();\n                let ident = message.ident();\n                let ident_lit = ident.to_string();\n                let args = message\n                    .inputs()\n                    .map(|arg| Self::generate_message_param(arg));\n                let ret_ty = Self::generate_return_type(message.output());\n                let constr = match trait_ident {\n                    Some(trait_ident) => {\n                        let trait_ident_lit = trait_ident.to_string();\n                        quote_spanned!(span => from_trait_and_name(#trait_ident_lit, #ident_lit))\n                    }\n                    None => {\n                        quote_spanned!(span => from_name(#ident_lit))\n                    }\n                };\n                quote_spanned!(span =>\n                    ::ink_metadata::MessageSpec::#constr\n                        .selector([#(#selector_bytes),*])\n                        .args(vec![\n                            #(#args ,)*\n                        ])\n                        .returns(#ret_ty)\n                        .mutates(#mutates)\n                        .payable(#is_payable)\n                        .docs(vec![\n                            #(#docs ,)*\n                        ])\n                        .done()\n                )\n            })\n    }\n\n    /// Generates ink! metadata for the given return type.\n    fn generate_return_type(ret_ty: Option<&syn::Type>) -> TokenStream2 {\n        match ret_ty {\n            None => {\n                quote! {\n                    ::ink_metadata::ReturnTypeSpec::new(None)\n                }\n            }\n            Some(ty) => {\n                let type_spec = Self::generate_type_spec(ty);\n                quote! {\n                    ::ink_metadata::ReturnTypeSpec::new(#type_spec)\n                }\n            }\n        }\n    }\n\n    /// Generates ink! metadata for all user provided ink! event definitions.\n    fn generate_events(&self) -> impl Iterator<Item = TokenStream2> + '_ {\n        self.contract.module().events().map(|event| {\n            let span = event.span();\n            let ident = event.ident();\n            let ident_lit = ident.to_string();\n            let docs = Self::extract_doc_comments(event.attrs());\n            let args = Self::generate_event_args(event);\n            quote_spanned!(span =>\n                ::ink_metadata::EventSpec::new(#ident_lit)\n                    .args(vec![\n                        #( #args, )*\n                    ])\n                    .docs(vec![\n                        #( #docs, )*\n                    ])\n                    .done()\n            )\n        })\n    }\n\n    /// Generate ink! metadata for a single argument of an ink! event definition.\n    fn generate_event_args(event: &ir::Event) -> impl Iterator<Item = TokenStream2> + '_ {\n        event.fields().map(|event_field| {\n            let span = event_field.span();\n            let ident = event_field.ident();\n            let ident_lit = ident.map(ToString::to_string);\n            let is_topic = event_field.is_topic;\n            let attrs = event_field.attrs();\n            let docs = Self::extract_doc_comments(&attrs);\n            let ty = Self::generate_type_spec(event_field.ty());\n            quote_spanned!(span =>\n                ::ink_metadata::EventParamSpec::new(#ident_lit)\n                    .of_type(#ty)\n                    .indexed(#is_topic)\n                    .docs(vec![\n                        #( #docs, )*\n                    ])\n                    .done()\n            )\n        })\n    }\n\n    /// Generates the documentation for the contract module.\n    fn generate_docs(&self) -> impl Iterator<Item = String> + '_ {\n        Self::extract_doc_comments(self.contract.module().attrs())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn extract_doc_comments_works() {\n        assert_eq!(\n            Metadata::extract_doc_comments(&[syn::parse_quote!( #[doc = r\"content\"] )])\n                .collect::<Vec<_>>(),\n            vec![\"content\".to_string()],\n        );\n        assert_eq!(\n            Metadata::extract_doc_comments(&[syn::parse_quote!(\n                /// content\n            )])\n            .collect::<Vec<_>>(),\n            vec![\" content\".to_string()],\n        );\n        assert_eq!(\n            Metadata::extract_doc_comments(&[syn::parse_quote!(\n                /**\n                 * Multi-line comments ...\n                 * May span many lines\n                 */\n            )])\n            .collect::<Vec<_>>(),\n            vec![r\"\n                 * Multi-line comments ...\n                 * May span many lines\n                 \"\n            .to_string()],\n        );\n        assert_eq!(\n            Metadata::extract_doc_comments(&[\n                syn::parse_quote!(\n                    /// multiple\n                ),\n                syn::parse_quote!(\n                    /// single\n                ),\n                syn::parse_quote!(\n                    /// line\n                ),\n                syn::parse_quote!(\n                    /// commments\n                ),\n            ])\n            .collect::<Vec<_>>(),\n            vec![\n                \" multiple\".to_string(),\n                \" single\".to_string(),\n                \" line\".to_string(),\n                \" commments\".to_string(),\n            ],\n        );\n        assert_eq!(\n            Metadata::extract_doc_comments(&[\n                syn::parse_quote!( #[doc = r\"a\"] ),\n                syn::parse_quote!( #[non_doc] ),\n                syn::parse_quote!( #[doc = r\"b\"] ),\n                syn::parse_quote!( #[derive(NonDoc)] ),\n                syn::parse_quote!( #[doc = r\"c\"] ),\n                syn::parse_quote!( #[docker = false] ),\n                syn::parse_quote!( #[doc = r\"d\"] ),\n                syn::parse_quote!( #[doc(Nope)] ),\n                syn::parse_quote!( #[doc = r\"e\"] ),\n            ])\n            .collect::<Vec<_>>(),\n            vec![\n                \"a\".to_string(),\n                \"b\".to_string(),\n                \"c\".to_string(),\n                \"d\".to_string(),\n                \"e\".to_string(),\n            ],\n        )\n    }\n}\n"],["906","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::GenerateCode;\nuse derive_more::From;\nuse proc_macro2::TokenStream as TokenStream2;\nuse quote::quote;\n\n/// Generates code for the ink! environment of the contract.\n#[derive(From)]\npub struct Env<'a> {\n    contract: &'a ir::Contract,\n}\n\nimpl GenerateCode for Env<'_> {\n    fn generate_code(&self) -> TokenStream2 {\n        let env = self.contract.config().env();\n        let storage_ident = self.contract.module().storage().ident();\n        quote! {\n            impl ::ink_lang::ContractEnv for #storage_ident {\n                type Env = #env;\n            }\n\n            type Environment = <#storage_ident as ::ink_lang::ContractEnv>::Env;\n\n            type AccountId = <<#storage_ident as ::ink_lang::ContractEnv>::Env as ::ink_env::Environment>::AccountId;\n            type Balance = <<#storage_ident as ::ink_lang::ContractEnv>::Env as ::ink_env::Environment>::Balance;\n            type Hash = <<#storage_ident as ::ink_lang::ContractEnv>::Env as ::ink_env::Environment>::Hash;\n            type Timestamp = <<#storage_ident as ::ink_lang::ContractEnv>::Env as ::ink_env::Environment>::Timestamp;\n            type BlockNumber = <<#storage_ident as ::ink_lang::ContractEnv>::Env as ::ink_env::Environment>::BlockNumber;\n        }\n    }\n}\n"],["907","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nmod chain_extension;\nmod contract;\nmod cross_calling;\nmod dispatch;\nmod env;\nmod events;\nmod ink_test;\nmod item_impls;\nmod metadata;\nmod storage;\nmod trait_def;\n\npub use self::{\n    chain_extension::ChainExtension,\n    contract::Contract,\n    cross_calling::{\n        CrossCalling,\n        CrossCallingConflictCfg,\n    },\n    dispatch::Dispatch,\n    env::Env,\n    events::Events,\n    ink_test::InkTest,\n    item_impls::ItemImpls,\n    metadata::Metadata,\n    storage::Storage,\n    trait_def::TraitDefinition,\n};\n"],["908","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::{\n    generator,\n    GenerateCode,\n    GenerateCodeUsing as _,\n};\nuse derive_more::From;\nuse proc_macro2::{\n    Span,\n    TokenStream as TokenStream2,\n};\nuse quote::{\n    quote,\n    quote_spanned,\n};\nuse syn::spanned::Spanned as _;\n\n/// Generates code for the ink! event structs of the contract.\n#[derive(From)]\npub struct Events<'a> {\n    contract: &'a ir::Contract,\n}\n\nimpl AsRef<ir::Contract> for Events<'_> {\n    fn as_ref(&self) -> &ir::Contract {\n        self.contract\n    }\n}\n\nimpl GenerateCode for Events<'_> {\n    fn generate_code(&self) -> TokenStream2 {\n        if self.contract.module().events().next().is_none() {\n            // Generate no code in case there are no event definitions.\n            return TokenStream2::new()\n        }\n        let emit_event_trait_impl = self.generate_emit_event_trait_impl();\n        let event_base = self.generate_event_base();\n        let topic_guards = self.generate_topic_guards();\n        let topics_impls = self.generate_topics_impls();\n        let event_structs = self.generate_event_structs();\n        quote! {\n            #emit_event_trait_impl\n            #event_base\n            #( #topic_guards )*\n            #( #event_structs )*\n            #( #topics_impls )*\n        }\n    }\n}\n\nimpl<'a> Events<'a> {\n    /// Used to allow emitting user defined events directly instead of converting\n    /// them first into the automatically generated base trait of the contract.\n    fn generate_emit_event_trait_impl(&self) -> TokenStream2 {\n        let storage_ident = &self.contract.module().storage().ident();\n        let no_cross_calling_cfg =\n            self.generate_code_using::<generator::CrossCallingConflictCfg>();\n        quote! {\n            const _: () = {\n                #no_cross_calling_cfg\n                impl<'a> ::ink_lang::EmitEvent<#storage_ident> for ::ink_lang::EnvAccess<'a, Environment> {\n                    fn emit_event<E>(self, event: E)\n                    where\n                        E: Into<<#storage_ident as ::ink_lang::BaseEvent>::Type>,\n                    {\n                        ::ink_env::emit_event::<\n                            Environment,\n                            <#storage_ident as ::ink_lang::BaseEvent>::Type\n                        >(event.into());\n                    }\n                }\n            };\n        }\n    }\n\n    /// Generates the base event enum that comprises all user defined events.\n    /// All emitted events are converted into a variant of this enum before being\n    /// serialized and emitted to apply their unique event discriminant (ID).\n    fn generate_event_base(&self) -> TokenStream2 {\n        let storage_ident = &self.contract.module().storage().ident();\n        let no_cross_calling_cfg =\n            self.generate_code_using::<generator::CrossCallingConflictCfg>();\n        let event_idents = self\n            .contract\n            .module()\n            .events()\n            .map(|event| event.ident())\n            .collect::<Vec<_>>();\n        let base_event_ident =\n            proc_macro2::Ident::new(\"__ink_EventBase\", Span::call_site());\n        quote! {\n            #no_cross_calling_cfg\n            #[derive(::scale::Encode, ::scale::Decode)]\n            pub enum #base_event_ident {\n                #( #event_idents(#event_idents), )*\n            }\n\n            #no_cross_calling_cfg\n            const _: () = {\n                impl ::ink_lang::BaseEvent for #storage_ident {\n                    type Type = #base_event_ident;\n                }\n            };\n\n            #(\n                #no_cross_calling_cfg\n                const _: () = {\n                    impl From<#event_idents> for #base_event_ident {\n                        fn from(event: #event_idents) -> Self {\n                            Self::#event_idents(event)\n                        }\n                    }\n                };\n            )*\n\n            const _: () = {\n                pub enum __ink_UndefinedAmountOfTopics {}\n                impl ::ink_env::topics::EventTopicsAmount for __ink_UndefinedAmountOfTopics {\n                    const AMOUNT: usize = 0;\n                }\n\n                #no_cross_calling_cfg\n                impl ::ink_env::Topics for #base_event_ident {\n                    type RemainingTopics = __ink_UndefinedAmountOfTopics;\n\n                    fn topics<E, B>(\n                        &self,\n                        builder: ::ink_env::topics::TopicsBuilder<::ink_env::topics::state::Uninit, E, B>,\n                    ) -> <B as ::ink_env::topics::TopicsBuilderBackend<E>>::Output\n                    where\n                        E: ::ink_env::Environment,\n                        B: ::ink_env::topics::TopicsBuilderBackend<E>,\n                    {\n                        match self {\n                            #(\n                                Self::#event_idents(event) => {\n                                    <#event_idents as ::ink_env::Topics>::topics::<E, B>(event, builder)\n                                }\n                            )*\n                        }\n                    }\n                }\n            };\n        }\n    }\n\n    /// Generate checks to guard against too many topics in event definitions.\n    fn generate_topics_guard(&self, event: &ir::Event) -> TokenStream2 {\n        let storage_ident = self.contract.module().storage().ident();\n        let event_ident = event.ident();\n        let len_topics = event.fields().filter(|event| event.is_topic).count();\n        let span = event.span();\n        quote_spanned!(span=>\n            const _: () = {\n                #[allow(non_camel_case_types)]\n                pub enum __ink_CheckSatisfied {}\n                pub enum EventTopicsWithinBounds {}\n                impl ::ink_lang::True for __ink_CheckSatisfied {}\n                #[doc(hidden)]\n                pub trait CompliesWithTopicLimit {}\n                impl CompliesWithTopicLimit for __ink_CheckSatisfied {}\n\n                #[allow(non_camel_case_types)]\n                pub trait __ink_RenameBool {\n                    type Type;\n                }\n                impl __ink_RenameBool for [(); true as usize] {\n                    type Type = __ink_CheckSatisfied;\n                }\n                impl __ink_RenameBool for [(); false as usize] {\n                    type Type = #event_ident;\n                }\n\n                #[allow(non_upper_case_globals)]\n                const __ink_MAX_EVENT_TOPICS: usize = <\n                    <#storage_ident as ::ink_lang::ContractEnv>::Env as ::ink_env::Environment\n                >::MAX_EVENT_TOPICS;\n\n                fn __ink_ensure_max_event_topics<T>(_: T)\n                where\n                    T: __ink_RenameBool,\n                    <T as __ink_RenameBool>::Type: CompliesWithTopicLimit,\n                {}\n                let _ = __ink_ensure_max_event_topics::<[(); (#len_topics <= __ink_MAX_EVENT_TOPICS) as usize]>;\n            };\n        )\n    }\n\n    /// Generates the guard code that protects against having too many topics defined on an ink! event.\n    fn generate_topic_guards(&'a self) -> impl Iterator<Item = TokenStream2> + 'a {\n        let no_cross_calling_cfg =\n            self.generate_code_using::<generator::CrossCallingConflictCfg>();\n        self.contract.module().events().map(move |event| {\n            let span = event.span();\n            let topics_guard = self.generate_topics_guard(event);\n            quote_spanned!(span =>\n                #no_cross_calling_cfg\n                #topics_guard\n            )\n        })\n    }\n\n    /// Generates the `Topics` trait implementations for the user defined events.\n    fn generate_topics_impls(&'a self) -> impl Iterator<Item = TokenStream2> + 'a {\n        let no_cross_calling_cfg =\n            self.generate_code_using::<generator::CrossCallingConflictCfg>();\n        let contract_ident = self.contract.module().storage().ident();\n        self.contract.module().events().map(move |event| {\n            let span = event.span();\n            let event_ident = event.ident();\n            let event_signature = syn::LitByteStr::new(\n                format!(\"{}::{}\", contract_ident, event_ident\n            ).as_bytes(), span);\n            let len_event_signature = event_signature.value().len();\n            let len_topics = event.fields().filter(|field| field.is_topic).count();\n            let topic_impls = event\n                .fields()\n                .enumerate()\n                .filter(|(_, field)| field.is_topic)\n                .map(|(n, topic_field)| {\n                    let span = topic_field.span();\n                    let field_ident = topic_field\n                        .ident()\n                        .map(quote::ToTokens::into_token_stream)\n                        .unwrap_or_else(|| quote_spanned!(span => #n));\n                    let field_type = topic_field.ty();\n                    let signature = syn::LitByteStr::new(\n                        format!(\"{}::{}::{}\", contract_ident, event_ident,\n                            field_ident\n                        ).as_bytes(), span);\n                    quote_spanned!(span =>\n                        .push_topic::<::ink_env::topics::PrefixedValue<#field_type>>(\n                            &::ink_env::topics::PrefixedValue { value: &self.#field_ident, prefix: #signature }\n                        )\n                    )\n                });\n            // Only include topic for event signature in case of non-anonymous event.\n            let event_signature_topic = match event.anonymous {\n                true => None,\n                false => Some(quote_spanned!(span=>\n                    .push_topic::<::ink_env::topics::PrefixedValue<[u8; #len_event_signature]>>(\n                        &::ink_env::topics::PrefixedValue { value: #event_signature, prefix: b\"\" }\n                    )\n                ))\n            };\n            // Anonymous events require 1 fewer topics since they do not include their signature.\n            let anonymous_topics_offset = if event.anonymous { 0 } else { 1 };\n            let remaining_topics_ty = match len_topics + anonymous_topics_offset {\n                0 => quote_spanned!(span=> ::ink_env::topics::state::NoRemainingTopics),\n                n => quote_spanned!(span=> [::ink_env::topics::state::HasRemainingTopics; #n]),\n            };\n            quote_spanned!(span =>\n                #no_cross_calling_cfg\n                const _: () = {\n                    impl ::ink_env::Topics for #event_ident {\n                        type RemainingTopics = #remaining_topics_ty;\n\n                        fn topics<E, B>(\n                            &self,\n                            builder: ::ink_env::topics::TopicsBuilder<::ink_env::topics::state::Uninit, E, B>,\n                        ) -> <B as ::ink_env::topics::TopicsBuilderBackend<E>>::Output\n                        where\n                            E: ::ink_env::Environment,\n                            B: ::ink_env::topics::TopicsBuilderBackend<E>,\n                        {\n                            builder\n                                .build::<Self>()\n                                #event_signature_topic\n                                #(\n                                    #topic_impls\n                                )*\n                                .finish()\n                        }\n                    }\n                };\n            )\n        })\n    }\n\n    /// Generates all the user defined event struct definitions.\n    fn generate_event_structs(&'a self) -> impl Iterator<Item = TokenStream2> + 'a {\n        let no_cross_calling_cfg =\n            self.generate_code_using::<generator::CrossCallingConflictCfg>();\n        self.contract.module().events().map(move |event| {\n            let span = event.span();\n            let ident = event.ident();\n            let attrs = event.attrs();\n            let fields = event.fields().map(|event_field| {\n                let span = event_field.span();\n                let attrs = event_field.attrs();\n                let vis = event_field.vis();\n                let ident = event_field.ident();\n                let ty = event_field.ty();\n                quote_spanned!(span=>\n                    #( #attrs )*\n                    #vis #ident : #ty\n                )\n            });\n            quote_spanned!(span =>\n                #no_cross_calling_cfg\n                #( #attrs )*\n                #[derive(scale::Encode, scale::Decode)]\n                pub struct #ident {\n                    #( #fields ),*\n                }\n            )\n        })\n    }\n}\n"],["909","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::GenerateCode;\nuse derive_more::From;\nuse heck::CamelCase as _;\nuse proc_macro2::TokenStream as TokenStream2;\nuse quote::{\n    format_ident,\n    quote,\n    quote_spanned,\n};\n\n/// Generator to create the ink! storage struct and important trait impls.\n#[derive(From)]\npub struct TraitDefinition<'a> {\n    trait_def: &'a ir::InkTrait,\n}\n\nimpl<'a> TraitDefinition<'a> {\n    fn generate_for_constructor(\n        constructor: ir::InkTraitConstructor<'a>,\n    ) -> TokenStream2 {\n        let span = constructor.span();\n        let attrs = constructor.attrs();\n        let sig = constructor.sig();\n        let ident = &sig.ident;\n        let output_ident = format_ident!(\"{}Out\", ident.to_string().to_camel_case());\n        let inputs = &sig.inputs;\n        quote_spanned!(span =>\n            /// Output type of the respective trait constructor.\n            type #output_ident;\n\n            #(#attrs)*\n            fn #ident(#inputs) -> Self::#output_ident;\n        )\n    }\n\n    fn generate_for_message(message: ir::InkTraitMessage<'a>) -> TokenStream2 {\n        let span = message.span();\n        let attrs = message.attrs();\n        let sig = message.sig();\n        let ident = &sig.ident;\n        let inputs = &sig.inputs;\n        let output = match &sig.output {\n            syn::ReturnType::Default => quote! { () },\n            syn::ReturnType::Type(_, ty) => quote! { #ty },\n        };\n        let output_ident = format_ident!(\"{}Out\", ident.to_string().to_camel_case());\n        quote_spanned!(span =>\n            /// Output type of the respective trait message.\n            type #output_ident: ::ink_lang::ImpliesReturn<#output>;\n\n            #(#attrs)*\n            fn #ident(#inputs) -> Self::#output_ident;\n        )\n    }\n}\n\nimpl GenerateCode for TraitDefinition<'_> {\n    fn generate_code(&self) -> TokenStream2 {\n        let span = self.trait_def.span();\n        let attrs = self.trait_def.attrs();\n        let hash = self.trait_def.verify_hash();\n        let ident = self.trait_def.ident();\n        let helper_ident = format_ident!(\n            \"__ink_Checked{}_0x{:X}{:X}{:X}{:X}\",\n            ident,\n            hash[0],\n            hash[1],\n            hash[2],\n            hash[3]\n        );\n        let verify_hash_id =\n            u32::from_be_bytes([hash[0], hash[1], hash[2], hash[3]]) as usize;\n        let constructors = self\n            .trait_def\n            .iter_items()\n            .flat_map(ir::InkTraitItem::filter_map_constructor)\n            .map(Self::generate_for_constructor);\n        let messages = self\n            .trait_def\n            .iter_items()\n            .flat_map(ir::InkTraitItem::filter_map_message)\n            .map(Self::generate_for_message);\n        quote_spanned!(span =>\n            #(#attrs)*\n            pub trait #ident: ::ink_lang::CheckedInkTrait<[(); #verify_hash_id]> {\n                #[doc(hidden)]\n                #[allow(non_camel_case_types)]\n                type __ink_Checksum: #helper_ident;\n\n                #(#constructors)*\n                #(#messages)*\n            }\n\n            #[doc(hidden)]\n            #[allow(non_camel_case_types)]\n            pub unsafe trait #helper_ident {}\n\n            const _: () = {\n                unsafe impl #helper_ident for [(); #verify_hash_id] {}\n            };\n        )\n    }\n}\n"],["910","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::GenerateCode;\nuse derive_more::From;\nuse ir::ChainExtensionMethod;\nuse proc_macro2::TokenStream as TokenStream2;\nuse quote::{\n    format_ident,\n    quote_spanned,\n};\nuse syn::spanned::Spanned;\n\n/// Generator to create an ink! chain extension.\n#[derive(From)]\npub struct ChainExtension<'a> {\n    extension: &'a ir::ChainExtension,\n}\n\nimpl ChainExtension<'_> {\n    fn generate_for_instance_method(\n        method: &ChainExtensionMethod,\n        error_code: &syn::Type,\n    ) -> TokenStream2 {\n        let span = method.span();\n        let attrs = method.attrs();\n        let ident = method.ident();\n        let func_id = method.id().into_u32();\n        let sig = method.sig();\n        let inputs = &sig.inputs;\n        let input_bindings = method.inputs().map(|pat_type| &pat_type.pat);\n        let input_types = method.inputs().map(|pat_type| &pat_type.ty);\n\n        // Mostly tuple-based type representation of the inputs:\n        // Special case for when there is exactly one input type.\n        // - 0 inputs          -> ()\n        // - 1 input T         -> T\n        // - n inputs A, B. .. -> (A, B, ..)\n        let compound_input_type = match inputs.len() {\n            0 => quote_spanned!(span=> ()),\n            1 => quote_spanned!(span=> #( #input_types )* ),\n            _n => quote_spanned!(span=> ( #( #input_types ),* ) ),\n        };\n\n        // Mostly tuple-based value representation of the inputs:\n        // Special case for when there is exactly one input value.\n        // - 0 inputs          -> ()\n        // - 1 input a         -> a\n        // - n inputs a, b. .. -> (a, b, ..)\n        let compound_input_bindings = match inputs.len() {\n            0 => quote_spanned!(span=> ()),\n            1 => quote_spanned!(span=> #( #input_bindings )* ),\n            _n => quote_spanned!(span=> ( #( #input_bindings ),* ) ),\n        };\n\n        let output = &sig.output;\n        let output_type = match output {\n            syn::ReturnType::Default => quote_spanned!(output.span()=> ()),\n            syn::ReturnType::Type(_arrow, ty) => {\n                quote_spanned!(output.span()=> #ty)\n            }\n        };\n\n        let handle_status = method.handle_status();\n        let returns_result = method.returns_result();\n\n        let error_code_handling = if handle_status {\n            quote_spanned!(span=>\n                .handle_error_code::<#error_code>()\n            )\n        } else {\n            quote_spanned!(span=>\n                .ignore_error_code()\n            )\n        };\n\n        let result_handling = if returns_result {\n            quote_spanned!(span=>\n                .output_result::<\n                    <#output_type as ::ink_lang::IsResultType>::Ok,\n                    <#output_type as ::ink_lang::IsResultType>::Err,\n                >()\n            )\n        } else {\n            quote_spanned!(span=>\n                .output::<#output_type>()\n            )\n        };\n\n        let returned_type = match (returns_result, handle_status) {\n            (false, true) => {\n                quote_spanned!(span=>\n                    ::core::result::Result<#output_type, #error_code>\n                )\n            }\n            _ => {\n                quote_spanned!(span=>\n                    #output_type\n                )\n            }\n        };\n\n        let where_output_is_result = Some(quote_spanned!(span=>\n            #output_type: ::ink_lang::IsResultType,\n        ))\n        .filter(|_| returns_result);\n\n        let where_output_impls_from_error_code = Some(quote_spanned!(span=>\n            <#output_type as ::ink_lang::IsResultType>::Err: ::core::convert::From<#error_code>,\n        )).filter(|_| returns_result && handle_status);\n\n        quote_spanned!(span=>\n            #( #attrs )*\n            #[inline]\n            pub fn #ident(self, #inputs) -> #returned_type\n            where\n                #where_output_is_result\n                #where_output_impls_from_error_code\n            {\n                ::ink_env::chain_extension::ChainExtensionMethod::build(#func_id)\n                    .input::<#compound_input_type>()\n                    #result_handling\n                    #error_code_handling\n                    .call(&#compound_input_bindings)\n            }\n        )\n    }\n}\n\nimpl GenerateCode for ChainExtension<'_> {\n    fn generate_code(&self) -> TokenStream2 {\n        let span = self.extension.span();\n        let attrs = self.extension.attrs();\n        let ident = self.extension.ident();\n        let error_code = self.extension.error_code();\n        let instance_methods = self\n            .extension\n            .iter_methods()\n            .map(|method| Self::generate_for_instance_method(method, error_code));\n        let instance_ident = format_ident!(\"__ink_{}Instance\", ident);\n        quote_spanned!(span =>\n            #(#attrs)*\n            pub enum #ident {}\n\n            const _: () = {\n                #[allow(non_camel_case_types)]\n                struct __ink_Private;\n                #[allow(non_camel_case_types)]\n                pub struct #instance_ident {\n                    __ink_private: __ink_Private\n                }\n\n                impl #instance_ident {\n                    #( #instance_methods )*\n                }\n\n                impl ::ink_lang::ChainExtensionInstance for #ident {\n                    type Instance = #instance_ident;\n\n                    fn instantiate() -> Self::Instance {\n                        Self::Instance { __ink_private: __ink_Private }\n                    }\n                }\n            };\n        )\n    }\n}\n"],["911","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::GenerateCode;\nuse derive_more::From;\nuse proc_macro2::TokenStream as TokenStream2;\nuse quote::quote;\n\n/// Generates code for the `[ink::test]` macro.\n#[derive(From)]\npub struct InkTest<'a> {\n    /// The test function to generate code for.\n    test: &'a ir::InkTest,\n}\n\nimpl GenerateCode for InkTest<'_> {\n    /// Generates the code for `#[ink:test]`.\n    fn generate_code(&self) -> TokenStream2 {\n        let item_fn = &self.test.item_fn;\n        let attrs = &item_fn.attrs;\n        let sig = &item_fn.sig;\n        let fn_name = &sig.ident;\n        let fn_return_type = &sig.output;\n        let fn_block = &item_fn.block;\n        let vis = &item_fn.vis;\n        let fn_args = &sig.inputs;\n        let expect_msg = format!(\n            \"{}: the off-chain testing environment returned an error\",\n            stringify!(#fn_name)\n        );\n        match fn_return_type {\n            syn::ReturnType::Default => {\n                quote! {\n                    #( #attrs )*\n                    #[test]\n                    #vis fn #fn_name( #fn_args ) {\n                        ::ink_env::test::run_test::<::ink_env::DefaultEnvironment, _>(|_| {\n                            {\n                                let _: () = {\n                                    #fn_block\n                                };\n                                Ok(())\n                            }\n                        })\n                        .expect(#expect_msg);\n                    }\n                }\n            }\n            syn::ReturnType::Type(rarrow, ret_type) => {\n                quote! {\n                    #( #attrs )*\n                    #[test]\n                    #vis fn #fn_name( #fn_args ) #rarrow #ret_type {\n                        ::ink_env::test::run_test::<::ink_env::DefaultEnvironment, _>(|_| {\n                            #fn_block\n                        })\n                    }\n                }\n            }\n        }\n    }\n}\n\nimpl GenerateCode for ir::InkTest {\n    fn generate_code(&self) -> TokenStream2 {\n        InkTest::from(self).generate_code()\n    }\n}\n"],["912","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Provide macros to simplify error reporting in procedural macros.\n\npub trait ExtError {\n    /// Returns `self` combined with the other error.\n    fn into_combine(self, another: syn::Error) -> Self;\n}\n\nimpl ExtError for syn::Error {\n    fn into_combine(mut self, another: syn::Error) -> Self {\n        self.combine(another);\n        self\n    }\n}\n\n/// Creates a [`syn::Error`] with the format message and infers the\n/// [`Span`](`proc_macro2::Span`) using [`ToTokens`](`quote::ToTokens`).\n///\n/// # Parameters\n///\n/// - The first argument must implement [`quote::ToTokens`] in order to\n///   infer a [`Span`](`proc_macro2::Span`).\n/// - The second argument is a format string.\n/// - The rest are format string arguments.\n///\n/// # Note\n///\n/// On stable Rust this might yield higher quality error span information to the user\n/// than [`format_err`].\n/// - Source:\n/// [`syn::Error::new_spanned`](https://docs.rs/syn/1.0.33/syn/struct.Error.html#method.new_spanned)\n/// - Tracking issue: [`#54725`](https://github.com/rust-lang/rust/issues/54725)\n#[macro_export]\nmacro_rules! format_err_spanned {\n    ($tokens:expr, $($msg:tt)*) => {\n        ::syn::Error::new_spanned(\n            &$tokens,\n            format_args!($($msg)*)\n        )\n    }\n}\n\n/// Creates a [`syn::Error`] with the format message and infers the\n/// [`Span`](`proc_macro2::Span`) using [`Spanned`](`syn::spanned::Spanned`).\n///\n/// # Parameters\n///\n/// - The first argument must be a type that implements [`syn::spanned::Spanned`].\n/// - The second argument is a format string.\n/// - The rest are format string arguments.\n///\n/// # Note\n///\n/// On stable Rust this might yield worse error span information to the user\n/// than [`format_err_spanned`].\n/// - Source:\n/// [`syn::Error::new_spanned`](https://docs.rs/syn/1.0.33/syn/struct.Error.html#method.new_spanned)\n/// - Tracking issue: [`#54725`](https://github.com/rust-lang/rust/issues/54725)\n#[macro_export]\nmacro_rules! format_err {\n    ($spanned:expr, $($msg:tt)*) => {\n        ::syn::Error::new(\n            <_ as ::syn::spanned::Spanned>::span(&$spanned),\n            format_args!($($msg)*)\n        )\n    }\n}\n"],["913","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::format_err;\nuse proc_macro2::Span;\nuse syn::spanned::Spanned as _;\n\n/// Ensures that the given visibility is `pub` and anotherwise returns an appropriate error.\n///\n/// # Note\n///\n/// The `name` parameter is given to improve the resulting error message. It denotes the\n/// entity which cannot have non-public visibility.\npub fn ensure_pub_visibility(\n    name: &str,\n    parent_span: Span,\n    vis: &syn::Visibility,\n) -> Result<(), syn::Error> {\n    let bad_visibility = match vis {\n        syn::Visibility::Inherited => Some(parent_span),\n        syn::Visibility::Restricted(vis_restricted) => Some(vis_restricted.span()),\n        syn::Visibility::Crate(vis_crate) => Some(vis_crate.span()),\n        syn::Visibility::Public(_) => None,\n    };\n    if let Some(bad_visibility) = bad_visibility {\n        return Err(format_err!(\n            bad_visibility,\n            \"non `pub` ink! {} are not supported\",\n            name\n        ))\n    }\n    Ok(())\n}\n"],["914","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/// Computes the BLAKE2b 256-bit hash for the given input and stores it in output.\npub fn blake2b_256(input: &[u8], output: &mut [u8]) {\n    use ::blake2::digest::{\n        Update as _,\n        VariableOutput as _,\n    };\n    let mut blake2 = blake2::VarBlake2b::new_keyed(&[], 32);\n    blake2.update(input);\n    blake2.finalize_variable(|result| output.copy_from_slice(result));\n}\n"],["915","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::{\n    error::ExtError as _,\n    ir,\n    ir::{\n        ExtensionId,\n        Selector,\n    },\n};\nuse core::{\n    convert::TryFrom,\n    result::Result,\n};\nuse proc_macro2::{\n    Ident,\n    Span,\n};\nuse regex::Regex;\nuse std::collections::HashMap;\nuse syn::spanned::Spanned;\n\n/// Either an ink! specific attribute, or another uninterpreted attribute.\n#[derive(Debug, PartialEq, Eq)]\npub enum Attribute {\n    /// An ink! specific attribute, e.g. `#[ink(storage)]`.\n    Ink(InkAttribute),\n    /// Any other attribute.\n    ///\n    /// This can be a known `#[derive(Debug)]` or a specific attribute of another\n    /// crate.\n    Other(syn::Attribute),\n}\n\n/// Types implementing this trait can return a slice over their `syn` attributes.\npub trait Attrs {\n    /// Returns the slice of attributes of an AST entity.\n    fn attrs(&self) -> &[syn::Attribute];\n}\n\nimpl Attrs for syn::ImplItem {\n    fn attrs(&self) -> &[syn::Attribute] {\n        match self {\n            syn::ImplItem::Const(item) => &item.attrs,\n            syn::ImplItem::Method(item) => &item.attrs,\n            syn::ImplItem::Type(item) => &item.attrs,\n            syn::ImplItem::Macro(item) => &item.attrs,\n            _ => &[],\n        }\n    }\n}\n\nimpl Attrs for syn::Item {\n    fn attrs(&self) -> &[syn::Attribute] {\n        use syn::Item;\n        match self {\n            Item::Const(syn::ItemConst { attrs, .. })\n            | Item::Enum(syn::ItemEnum { attrs, .. })\n            | Item::ExternCrate(syn::ItemExternCrate { attrs, .. })\n            | Item::Fn(syn::ItemFn { attrs, .. })\n            | Item::ForeignMod(syn::ItemForeignMod { attrs, .. })\n            | Item::Impl(syn::ItemImpl { attrs, .. })\n            | Item::Macro(syn::ItemMacro { attrs, .. })\n            | Item::Macro2(syn::ItemMacro2 { attrs, .. })\n            | Item::Mod(syn::ItemMod { attrs, .. })\n            | Item::Static(syn::ItemStatic { attrs, .. })\n            | Item::Struct(syn::ItemStruct { attrs, .. })\n            | Item::Trait(syn::ItemTrait { attrs, .. })\n            | Item::TraitAlias(syn::ItemTraitAlias { attrs, .. })\n            | Item::Type(syn::ItemType { attrs, .. })\n            | Item::Union(syn::ItemUnion { attrs, .. })\n            | Item::Use(syn::ItemUse { attrs, .. }) => attrs,\n            _ => &[],\n        }\n    }\n}\n\n/// An ink! specific attribute.\n///\n/// # Examples\n///\n/// An attribute with a simple flag:\n/// ```no_compile\n/// #[ink(storage)]\n/// ```\n///\n/// An attribute with a parameterized flag:\n/// ```no_compile\n/// #[ink(selector = \"0xDEADBEEF\")]\n/// ```\n///\n/// An attribute with multiple flags:\n/// ```no_compile\n/// #[ink(message, payable, selector = \"0xDEADBEEF\")]\n/// ```\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub struct InkAttribute {\n    /// The internal non-empty sequence of arguments of the ink! attribute.\n    args: Vec<AttributeFrag>,\n}\n\nimpl Spanned for InkAttribute {\n    fn span(&self) -> Span {\n        self.args\n            .iter()\n            .map(|arg| arg.span())\n            .fold(self.first().span(), |fst, snd| {\n                fst.join(snd).unwrap_or_else(|| self.first().span())\n            })\n    }\n}\n\nimpl InkAttribute {\n    /// Ensure that the first ink! attribute argument is of expected kind.\n    ///\n    /// # Errors\n    ///\n    /// If the first ink! attribute argument is not of expected kind.\n    pub fn ensure_first(&self, expected: &AttributeArgKind) -> Result<(), syn::Error> {\n        if &self.first().arg.kind() != expected {\n            return Err(format_err!(\n                self.span(),\n                \"unexpected first ink! attribute argument\",\n            ))\n        }\n        Ok(())\n    }\n\n    /// Ensures that the given iterator of ink! attribute arguments do not have\n    /// duplicates.\n    ///\n    /// # Errors\n    ///\n    /// If the given iterator yields duplicate ink! attribute arguments.\n    fn ensure_no_duplicate_args<'a, A>(args: A) -> Result<(), syn::Error>\n    where\n        A: IntoIterator<Item = &'a ir::AttributeFrag>,\n    {\n        use crate::error::ExtError as _;\n        use std::collections::HashSet;\n        let mut seen: HashSet<&AttributeFrag> = HashSet::new();\n        let mut seen2: HashMap<AttributeArgKind, Span> = HashMap::new();\n        for arg in args.into_iter() {\n            if let Some(seen) = seen.get(arg) {\n                return Err(format_err!(\n                    arg.span(),\n                    \"encountered duplicate ink! attribute arguments\"\n                )\n                .into_combine(format_err!(\n                    seen.span(),\n                    \"first equal ink! attribute argument here\"\n                )))\n            }\n            if let Some(seen) = seen2.get(&arg.kind().kind()) {\n                return Err(format_err!(\n                    arg.span(),\n                    \"encountered ink! attribute arguments with equal kinds\"\n                )\n                .into_combine(format_err!(\n                    *seen,\n                    \"first equal ink! attribute argument with equal kind here\"\n                )))\n            }\n            seen.insert(arg);\n            seen2.insert(arg.kind().kind(), arg.span());\n        }\n        Ok(())\n    }\n\n    /// Converts a sequence of `#[ink(..)]` attributes into a single flattened\n    /// `#[ink(..)]` attribute that contains all of the input arguments.\n    ///\n    /// # Example\n    ///\n    /// Given the input ink! attribute sequence `[ #[ink(message)], #[ink(payable)] ]`\n    /// this procedure returns the single attribute `#[ink(message, payable)]`.\n    ///\n    /// # Errors\n    ///\n    /// - If the sequence of input ink! attributes contains duplicates.\n    /// - If the input sequence is empty.\n    pub fn from_expanded<A>(attrs: A) -> Result<Self, syn::Error>\n    where\n        A: IntoIterator<Item = Self>,\n    {\n        let args = attrs\n            .into_iter()\n            .map(|attr| attr.args)\n            .flatten()\n            .collect::<Vec<_>>();\n        if args.is_empty() {\n            return Err(format_err!(\n                Span::call_site(),\n                \"encountered unexpected empty expanded ink! attribute arguments\",\n            ))\n        }\n        Self::ensure_no_duplicate_args(&args)?;\n        Ok(Self { args })\n    }\n\n    /// Returns the first ink! attribute argument.\n    pub fn first(&self) -> &AttributeFrag {\n        self.args\n            .first()\n            .expect(\"encountered invalid empty ink! attribute list\")\n    }\n\n    /// Returns an iterator over the non-empty flags of the ink! attribute.\n    ///\n    /// # Note\n    ///\n    /// This yields at least one ink! attribute flag.\n    pub fn args(&self) -> ::core::slice::Iter<AttributeFrag> {\n        self.args.iter()\n    }\n\n    /// Returns the namespace of the ink! attribute if any.\n    pub fn namespace(&self) -> Option<ir::Namespace> {\n        self.args().find_map(|arg| {\n            if let ir::AttributeArg::Namespace(namespace) = arg.kind() {\n                return Some(namespace.clone())\n            }\n            None\n        })\n    }\n\n    /// Returns the selector of the ink! attribute if any.\n    pub fn selector(&self) -> Option<ir::Selector> {\n        self.args().find_map(|arg| {\n            if let ir::AttributeArg::Selector(selector) = arg.kind() {\n                return Some(*selector)\n            }\n            None\n        })\n    }\n\n    /// Returns `true` if the ink! attribute contains the `payable` argument.\n    pub fn is_payable(&self) -> bool {\n        self.args()\n            .any(|arg| matches!(arg.kind(), AttributeArg::Payable))\n    }\n\n    /// Returns `true` if the ink! attribute contains the `anonymous` argument.\n    pub fn is_anonymous(&self) -> bool {\n        self.args()\n            .any(|arg| matches!(arg.kind(), AttributeArg::Anonymous))\n    }\n\n    /// Returns `false` if the ink! attribute contains the `handle_status = false` argument.\n    ///\n    /// Otherwise returns `true`.\n    pub fn is_handle_status(&self) -> bool {\n        !self\n            .args()\n            .any(|arg| matches!(arg.kind(), AttributeArg::HandleStatus(false)))\n    }\n\n    /// Returns `false` if the ink! attribute contains the `returns_result = false` argument.\n    ///\n    /// Otherwise returns `true`.\n    pub fn is_returns_result(&self) -> bool {\n        !self\n            .args()\n            .any(|arg| matches!(arg.kind(), AttributeArg::ReturnsResult(false)))\n    }\n}\n\n/// An ink! specific attribute argument.\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub struct AttributeFrag {\n    pub ast: syn::Meta,\n    pub arg: AttributeArg,\n}\n\nimpl AttributeFrag {\n    /// Returns a shared reference to the attribute argument kind.\n    pub fn kind(&self) -> &AttributeArg {\n        &self.arg\n    }\n}\n\nimpl Spanned for AttributeFrag {\n    fn span(&self) -> Span {\n        self.ast.span()\n    }\n}\n\n/// The kind of an ink! attribute argument.\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub enum AttributeArgKind {\n    /// `#[ink(storage)]`\n    Storage,\n    /// `#[ink(event)]`\n    Event,\n    /// `#[ink(anonymous)]`\n    Anonymous,\n    /// `#[ink(topic)]`\n    Topic,\n    /// `#[ink(message)]`\n    Message,\n    /// `#[ink(constructor)]`\n    Constructor,\n    /// `#[ink(payable)]`\n    Payable,\n    /// `#[ink(selector = \"0xDEADBEEF\")]`\n    Selector,\n    /// `#[ink(extension = N: u32)]`\n    Extension,\n    /// `#[ink(namespace = \"my_namespace\")]`\n    Namespace,\n    /// `#[ink(impl)]`\n    Implementation,\n    /// `#[ink(handle_status = flag: bool)]`\n    HandleStatus,\n    /// `#[ink(returns_result = flag: bool)]`\n    ReturnsResult,\n}\n\n/// An ink! specific attribute flag.\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub enum AttributeArg {\n    /// `#[ink(storage)]`\n    ///\n    /// Applied on `struct` types in order to flag them for being the\n    /// contract's storage definition.\n    Storage,\n    /// `#[ink(event)]`\n    ///\n    /// Applied on `struct` types in order to flag them for being an ink! event.\n    Event,\n    /// `#[ink(anonymous)]`\n    ///\n    /// Applied on `struct` event types in order to flag them as anonymous.\n    /// Anonymous events have similar semantics as in Solidity in that their\n    /// event signature won't be included in their event topics serialization\n    /// to reduce event emitting overhead. This is especially useful for user\n    /// defined events.\n    Anonymous,\n    /// `#[ink(topic)]`\n    ///\n    /// Applied on fields of ink! event types to indicate that they are topics.\n    Topic,\n    /// `#[ink(message)]`\n    ///\n    /// Applied on `&self` or `&mut self` methods to flag them for being an ink!\n    /// exported message.\n    Message,\n    /// `#[ink(constructor)]`\n    ///\n    /// Applied on inherent methods returning `Self` to flag them for being ink!\n    /// exported contract constructors.\n    Constructor,\n    /// `#[ink(payable)]`\n    ///\n    /// Applied on ink! constructors or messages in order to specify that they\n    /// can receive funds from callers.\n    Payable,\n    /// `#[ink(selector = \"0xDEADBEEF\")]`\n    ///\n    /// Applied on ink! constructors or messages to manually control their\n    /// selectors.\n    Selector(Selector),\n    /// `#[ink(namespace = \"my_namespace\")]`\n    ///\n    /// Applied on ink! trait implementation blocks to disambiguate other trait\n    /// implementation blocks with equal names.\n    Namespace(Namespace),\n    /// `#[ink(impl)]`\n    ///\n    /// This attribute supports a niche case that is rarely needed.\n    ///\n    /// Can be applied on ink! implementation blocks in order to make ink! aware\n    /// of them. This is useful if such an implementation block doesn't contain\n    /// any other ink! attributes, so it would be flagged by ink! as a Rust item.\n    /// Adding `#[ink(impl)]` on such implementation blocks makes them treated\n    /// as ink! implementation blocks thus allowing to access the environment\n    /// etc. Note that ink! messages and constructors still need to be explicitly\n    /// flagged as such.\n    Implementation,\n    /// `#[ink(extension = N: u32)]`\n    ///\n    /// Applies on ink! chain extension method to set their `func_id` parameter.\n    /// Every chain extension method must have exactly one ink! `extension` attribute.\n    ///\n    /// Used by the `#[ink::chain_extension]` proc. macro.\n    Extension(ExtensionId),\n    /// `#[ink(handle_status = flag: bool)]`\n    ///\n    /// Used by the `#[ink::chain_extension]` proc. macro.\n    ///\n    /// Default value: `true`\n    HandleStatus(bool),\n    /// `#[ink(returns_result = flag: bool)]`\n    ///\n    /// Used by the `#[ink::chain_extension]` proc. macro.\n    ///\n    /// Default value: `true`\n    ReturnsResult(bool),\n}\n\nimpl core::fmt::Display for AttributeArgKind {\n    fn fmt(&self, f: &mut core::fmt::Formatter) -> Result<(), core::fmt::Error> {\n        match self {\n            Self::Storage => write!(f, \"storage\"),\n            Self::Event => write!(f, \"event\"),\n            Self::Anonymous => write!(f, \"anonymous\"),\n            Self::Topic => write!(f, \"topic\"),\n            Self::Message => write!(f, \"message\"),\n            Self::Constructor => write!(f, \"constructor\"),\n            Self::Payable => write!(f, \"payable\"),\n            Self::Selector => {\n                write!(f, \"selector = S:[u8; 4]\")\n            }\n            Self::Extension => {\n                write!(f, \"extension = N:u32)\")\n            }\n            Self::Namespace => {\n                write!(f, \"namespace = N:string\")\n            }\n            Self::Implementation => write!(f, \"impl\"),\n            Self::HandleStatus => write!(f, \"handle_status\"),\n            Self::ReturnsResult => write!(f, \"returns_result\"),\n        }\n    }\n}\n\nimpl AttributeArg {\n    /// Returns the kind of the ink! attribute argument.\n    pub fn kind(&self) -> AttributeArgKind {\n        match self {\n            Self::Storage => AttributeArgKind::Storage,\n            Self::Event => AttributeArgKind::Event,\n            Self::Anonymous => AttributeArgKind::Anonymous,\n            Self::Topic => AttributeArgKind::Topic,\n            Self::Message => AttributeArgKind::Message,\n            Self::Constructor => AttributeArgKind::Constructor,\n            Self::Payable => AttributeArgKind::Payable,\n            Self::Selector(_) => AttributeArgKind::Selector,\n            Self::Extension(_) => AttributeArgKind::Extension,\n            Self::Namespace(_) => AttributeArgKind::Namespace,\n            Self::Implementation => AttributeArgKind::Implementation,\n            Self::HandleStatus(_) => AttributeArgKind::HandleStatus,\n            Self::ReturnsResult(_) => AttributeArgKind::ReturnsResult,\n        }\n    }\n}\n\nimpl core::fmt::Display for AttributeArg {\n    fn fmt(&self, f: &mut core::fmt::Formatter) -> Result<(), core::fmt::Error> {\n        match self {\n            Self::Storage => write!(f, \"storage\"),\n            Self::Event => write!(f, \"event\"),\n            Self::Anonymous => write!(f, \"anonymous\"),\n            Self::Topic => write!(f, \"topic\"),\n            Self::Message => write!(f, \"message\"),\n            Self::Constructor => write!(f, \"constructor\"),\n            Self::Payable => write!(f, \"payable\"),\n            Self::Selector(selector) => {\n                write!(f, \"selector = {:?}\", selector.as_bytes())\n            }\n            Self::Extension(extension) => {\n                write!(f, \"extension = {:?}\", extension.into_u32())\n            }\n            Self::Namespace(namespace) => {\n                write!(f, \"namespace = {:?}\", namespace.as_bytes())\n            }\n            Self::Implementation => write!(f, \"impl\"),\n            Self::HandleStatus(value) => write!(f, \"handle_status = {:?}\", value),\n            Self::ReturnsResult(value) => write!(f, \"returns_result = {:?}\", value),\n        }\n    }\n}\n\n/// An ink! namespace applicable to a trait implementation block.\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub struct Namespace {\n    /// The underlying bytes.\n    bytes: Vec<u8>,\n}\n\nimpl From<Vec<u8>> for Namespace {\n    fn from(bytes: Vec<u8>) -> Self {\n        Self { bytes }\n    }\n}\n\nimpl Namespace {\n    /// Returns the namespace as bytes.\n    pub fn as_bytes(&self) -> &[u8] {\n        &self.bytes\n    }\n}\n\n/// Returns `true` if the given iterator yields at least one attribute of the form\n/// `#[ink(..)]` or `#[ink]`.\n///\n/// # Note\n///\n/// This does not check at this point whether the ink! attribute is valid since\n/// this check is optimized for efficiency.\npub fn contains_ink_attributes<'a, I>(attrs: I) -> bool\nwhere\n    I: IntoIterator<Item = &'a syn::Attribute>,\n{\n    attrs.into_iter().any(|attr| attr.path.is_ident(\"ink\"))\n}\n\n/// Returns the first valid ink! attribute, if any.\n///\n/// Returns `None` if there are no ink! attributes.\n///\n/// # Errors\n///\n/// Returns an error if the first ink! attribute is invalid.\npub fn first_ink_attribute<'a, I>(\n    attrs: I,\n) -> Result<Option<ir::InkAttribute>, syn::Error>\nwhere\n    I: IntoIterator<Item = &'a syn::Attribute>,\n{\n    let first = attrs.into_iter().find(|attr| attr.path.is_ident(\"ink\"));\n    match first {\n        None => Ok(None),\n        Some(ink_attr) => InkAttribute::try_from(ink_attr.clone()).map(Some),\n    }\n}\n\n/// Partitions the given attributes into ink! specific and non-ink! specific attributes.\n///\n/// # Error\n///\n/// Returns an error if some ink! specific attributes could not be successfully parsed.\npub fn partition_attributes<I>(\n    attrs: I,\n) -> Result<(Vec<InkAttribute>, Vec<syn::Attribute>), syn::Error>\nwhere\n    I: IntoIterator<Item = syn::Attribute>,\n{\n    use either::Either;\n    use itertools::Itertools as _;\n    let (ink_attrs, others) = attrs\n        .into_iter()\n        .map(<Attribute as TryFrom<_>>::try_from)\n        .collect::<Result<Vec<Attribute>, syn::Error>>()?\n        .into_iter()\n        .partition_map(|attr| {\n            match attr {\n                Attribute::Ink(ink_attr) => Either::Left(ink_attr),\n                Attribute::Other(other_attr) => Either::Right(other_attr),\n            }\n        });\n    Attribute::ensure_no_duplicate_attrs(&ink_attrs)?;\n    Ok((ink_attrs, others))\n}\n\n/// Sanitizes the given attributes.\n///\n/// This partitions the attributes into ink! and non-ink! attributes.\n/// All ink! attributes are normalized, they are checked to have a valid first\n/// ink! attribute argument and no conflicts given the conflict predicate.\n///\n/// Returns the partitioned ink! and non-ink! attributes.\n///\n/// # Parameters\n///\n/// The `is_conflicting_attr` closure returns `Ok` if the attribute does not conflict,\n/// returns `Err(None)` if the attribute conflicts but without providing further reasoning\n/// and `Err(Some(reason))` if the attribute conflicts given additional context information.\n///\n/// # Errors\n///\n/// - If there are invalid ink! attributes.\n/// - If there are duplicate ink! attributes.\n/// - If the first ink! attribute is not matching the expected.\n/// - If there are conflicting ink! attributes.\npub fn sanitize_attributes<I, C>(\n    parent_span: Span,\n    attrs: I,\n    is_valid_first: &ir::AttributeArgKind,\n    mut is_conflicting_attr: C,\n) -> Result<(InkAttribute, Vec<syn::Attribute>), syn::Error>\nwhere\n    I: IntoIterator<Item = syn::Attribute>,\n    C: FnMut(&ir::AttributeFrag) -> Result<(), Option<syn::Error>>,\n{\n    let (ink_attrs, other_attrs) = ir::partition_attributes(attrs)?;\n    let normalized = ir::InkAttribute::from_expanded(ink_attrs).map_err(|err| {\n        err.into_combine(format_err!(parent_span, \"at this invocation\",))\n    })?;\n    normalized.ensure_first(is_valid_first).map_err(|err| {\n        err.into_combine(format_err!(\n            parent_span,\n            \"expected {} as first ink! attribute argument\",\n            is_valid_first,\n        ))\n    })?;\n    normalized.ensure_no_conflicts(|arg| is_conflicting_attr(arg))?;\n    Ok((normalized, other_attrs))\n}\n\nimpl Attribute {\n    /// Returns `Ok` if the given iterator yields no duplicate ink! attributes.\n    ///\n    /// # Errors\n    ///\n    /// If the given iterator yields duplicate ink! attributes.\n    /// Note: Duplicate non-ink! attributes are fine.\n    fn ensure_no_duplicate_attrs<'a, I>(attrs: I) -> Result<(), syn::Error>\n    where\n        I: IntoIterator<Item = &'a InkAttribute>,\n    {\n        use std::collections::HashSet;\n        let mut seen: HashSet<&InkAttribute> = HashSet::new();\n        for attr in attrs.into_iter() {\n            if let Some(seen) = seen.get(attr) {\n                use crate::error::ExtError as _;\n                return Err(format_err!(\n                    attr.span(),\n                    \"encountered duplicate ink! attribute\"\n                )\n                .into_combine(format_err!(seen.span(), \"first ink! attribute here\")))\n            }\n            seen.insert(attr);\n        }\n        Ok(())\n    }\n}\n\nimpl TryFrom<syn::Attribute> for Attribute {\n    type Error = syn::Error;\n\n    fn try_from(attr: syn::Attribute) -> Result<Self, Self::Error> {\n        if attr.path.is_ident(\"ink\") {\n            return <InkAttribute as TryFrom<_>>::try_from(attr).map(Into::into)\n        }\n        Ok(Attribute::Other(attr))\n    }\n}\n\nimpl From<InkAttribute> for Attribute {\n    fn from(ink_attribute: InkAttribute) -> Self {\n        Attribute::Ink(ink_attribute)\n    }\n}\n\nimpl TryFrom<syn::Attribute> for InkAttribute {\n    type Error = syn::Error;\n\n    fn try_from(attr: syn::Attribute) -> Result<Self, Self::Error> {\n        if !attr.path.is_ident(\"ink\") {\n            return Err(format_err_spanned!(attr, \"unexpected non-ink! attribute\"))\n        }\n        match attr.parse_meta().map_err(|_| {\n            format_err_spanned!(attr, \"unexpected ink! attribute structure\")\n        })? {\n            syn::Meta::List(meta_list) => {\n                let args = meta_list\n                    .nested\n                    .into_iter()\n                    .map(<AttributeFrag as TryFrom<_>>::try_from)\n                    .collect::<Result<Vec<_>, syn::Error>>()?;\n                Self::ensure_no_duplicate_args(&args)?;\n                if args.is_empty() {\n                    return Err(format_err_spanned!(\n                        attr,\n                        \"encountered unsupported empty ink! attribute\"\n                    ))\n                }\n                Ok(InkAttribute { args })\n            }\n            _ => Err(format_err_spanned!(attr, \"unknown ink! attribute\")),\n        }\n    }\n}\n\nimpl InkAttribute {\n    /// Ensures that there are no conflicting ink! attribute arguments in `self`.\n    ///\n    /// The given `is_conflicting` describes for every ink! attribute argument\n    /// found in `self` if it is in conflict.\n    ///\n    /// # Parameters\n    ///\n    /// The `is_conflicting_attr` closure returns `Ok` if the attribute does not conflict,\n    /// returns `Err(None)` if the attribute conflicts but without providing further reasoning\n    /// and `Err(Some(reason))` if the attribute conflicts given additional context information.\n    pub fn ensure_no_conflicts<'a, P>(\n        &'a self,\n        mut is_conflicting: P,\n    ) -> Result<(), syn::Error>\n    where\n        P: FnMut(&'a ir::AttributeFrag) -> Result<(), Option<syn::Error>>,\n    {\n        let mut err: Option<syn::Error> = None;\n        for arg in self.args() {\n            if let Err(reason) = is_conflicting(arg) {\n                let conflict_err = format_err!(\n                    arg.span(),\n                    \"encountered conflicting ink! attribute argument\",\n                );\n                match &mut err {\n                    Some(err) => {\n                        err.combine(conflict_err);\n                    }\n                    None => {\n                        err = Some(conflict_err);\n                    }\n                }\n                if let Some(reason) = reason {\n                    err.as_mut()\n                        .expect(\"must be `Some` at this point\")\n                        .combine(reason);\n                }\n            }\n        }\n        if let Some(err) = err {\n            return Err(err)\n        }\n        Ok(())\n    }\n}\n\n/// Returns an error to notify about non-hex digits at a position.\nfn err_non_hex(meta: &syn::Meta, pos: usize) -> syn::Error {\n    format_err_spanned!(meta, \"encountered non-hex digit at position {}\", pos)\n}\n\n/// Returns an error to notify about an invalid ink! selector.\nfn invalid_selector_err_regex(meta: &syn::Meta) -> syn::Error {\n    format_err_spanned!(\n        meta,\n        \"invalid selector - a selector must consist of four bytes in hex (e.g. `selector = \\\"0xCAFEBABE\\\"`)\"\n    )\n}\n\nimpl TryFrom<syn::NestedMeta> for AttributeFrag {\n    type Error = syn::Error;\n\n    fn try_from(nested_meta: syn::NestedMeta) -> Result<Self, Self::Error> {\n        match nested_meta {\n            syn::NestedMeta::Meta(meta) => {\n                match &meta {\n                    syn::Meta::NameValue(name_value) => {\n                        if name_value.path.is_ident(\"selector\") {\n                            if let syn::Lit::Str(lit_str) = &name_value.lit {\n                                let regex = Regex::new(r\"0x([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2})\")\n                                    .map_err(|_| {\n                                    invalid_selector_err_regex(&meta)\n                                })?;\n                                let str = lit_str.value();\n                                let cap =\n                                    regex.captures(&str).ok_or_else(|| {\n                                        invalid_selector_err_regex(&meta)\n                                    })?;\n                                if !regex.is_match(&str) {\n                                    return Err(invalid_selector_err_regex(\n                                        &meta,\n                                    ))\n                                }\n                                let len_digits = (str.as_bytes().len() - 2) / 2;\n                                if len_digits != 4 {\n                                    return Err(format_err!(\n                                            name_value,\n                                            \"expected 4-digit hexcode for `selector` argument, found {} digits\",\n                                            len_digits,\n                                        ))\n                                }\n                                let selector_bytes = [\n                                    u8::from_str_radix(&cap[1], 16)\n                                        .map_err(|_| err_non_hex(&meta, 0))?,\n                                    u8::from_str_radix(&cap[2], 16)\n                                        .map_err(|_| err_non_hex(&meta, 1))?,\n                                    u8::from_str_radix(&cap[3], 16)\n                                        .map_err(|_| err_non_hex(&meta, 2))?,\n                                    u8::from_str_radix(&cap[4], 16)\n                                        .map_err(|_| err_non_hex(&meta, 3))?,\n                                ];\n                                return Ok(AttributeFrag {\n                                    ast: meta,\n                                    arg: AttributeArg::Selector(Selector::from_bytes(\n                                        selector_bytes,\n                                    )),\n                                })\n                            }\n                            return Err(format_err!(name_value, \"expecteded 4-digit hexcode for `selector` argument, e.g. #[ink(selector = 0xC0FEBABE]\"))\n                        }\n                        if name_value.path.is_ident(\"namespace\") {\n                            if let syn::Lit::Str(lit_str) = &name_value.lit {\n                                let bytes = lit_str.value().into_bytes();\n                                return Ok(AttributeFrag {\n                                    ast: meta,\n                                    arg: AttributeArg::Namespace(\n                                        Namespace::from(bytes),\n                                    ),\n                                })\n                            }\n                            return Err(format_err!(name_value, \"expecteded string type for `namespace` argument, e.g. #[ink(namespace = \\\"hello\\\")]\"))\n                        }\n                        if name_value.path.is_ident(\"extension\") {\n                            if let syn::Lit::Int(lit_int) = &name_value.lit {\n                                let id = lit_int.base10_parse::<u32>().map_err(|parse_err| {\n                                    format_err!(\n                                        name_value,\n                                        \"could not parse `N` in `#[ink(extension = N)]` into a `u32` integer\",\n                                    ).into_combine(parse_err)\n                                })?;\n                                return Ok(AttributeFrag {\n                                    ast: meta,\n                                    arg: AttributeArg::Extension(\n                                        ExtensionId::from_u32(id),\n                                    ),\n                                })\n                            }\n                            return Err(format_err!(name_value, \"expecteded `u32` integer type for `N` in #[ink(extension = N)]\"))\n                        }\n                        if name_value.path.is_ident(\"handle_status\") {\n                            if let syn::Lit::Bool(lit_bool) = &name_value.lit {\n                                let value = lit_bool.value;\n                                return Ok(AttributeFrag {\n                                    ast: meta,\n                                    arg: AttributeArg::HandleStatus(value),\n                                })\n                            }\n                            return Err(format_err!(name_value, \"expecteded `bool` value type for `flag` in #[ink(handle_status = flag)]\"))\n                        }\n                        if name_value.path.is_ident(\"returns_result\") {\n                            if let syn::Lit::Bool(lit_bool) = &name_value.lit {\n                                let value = lit_bool.value;\n                                return Ok(AttributeFrag {\n                                    ast: meta,\n                                    arg: AttributeArg::ReturnsResult(value),\n                                })\n                            }\n                            return Err(format_err!(name_value, \"expecteded `bool` value type for `flag` in #[ink(returns_result = flag)]\"))\n                        }\n                        Err(format_err_spanned!(\n                            meta,\n                            \"unknown ink! attribute argument (name = value)\",\n                        ))\n                    }\n                    syn::Meta::Path(path) => {\n                        path\n                            .get_ident()\n                            .map(Ident::to_string)\n                            .ok_or_else(|| format_err_spanned!(meta, \"unknown ink! attribute (path)\"))\n                            .and_then(|ident| match ident.as_str() {\n                                \"storage\" => Ok(AttributeArg::Storage),\n                                \"message\" => Ok(AttributeArg::Message),\n                                \"constructor\" => Ok(AttributeArg::Constructor),\n                                \"event\" => Ok(AttributeArg::Event),\n                                \"anonymous\" => Ok(AttributeArg::Anonymous),\n                                \"topic\" => Ok(AttributeArg::Topic),\n                                \"payable\" => Ok(AttributeArg::Payable),\n                                \"impl\" => Ok(AttributeArg::Implementation),\n                                \"namespace\" => Err(format_err!(\n                                    meta,\n                                    \"encountered #[ink(namespace)] that is missing its string parameter. \\\n                                    Did you mean #[ink(namespace = name: str)] ?\"\n                                )),\n                                \"extension\" => Err(format_err!(\n                                    meta,\n                                    \"encountered #[ink(extension)] that is missing its N parameter. \\\n                                    Did you mean #[ink(extension = N: u32)] ?\"\n                                )),\n                                \"handle_status\" => Err(format_err!(\n                                    meta,\n                                    \"encountered #[ink(handle_status)] that is missing its `flag: bool` parameter. \\\n                                    Did you mean #[ink(handle_status = flag: bool)] ?\"\n                                )),\n                                \"returns_result\" => Err(format_err!(\n                                    meta,\n                                    \"encountered #[ink(returns_result)] that is missing its `flag: bool` parameter. \\\n                                    Did you mean #[ink(returns_result = flag: bool)] ?\"\n                                )),\n                                _ => Err(format_err_spanned!(\n                                    meta, \"unknown ink! attribute (path)\"\n                                ))\n                            })\n                            .map(|kind| AttributeFrag { ast: meta, arg: kind, })\n                    }\n                    syn::Meta::List(_) => {\n                        Err(format_err_spanned!(\n                            meta,\n                            \"unknown ink! attribute argument (list)\"\n                        ))\n                    }\n                }\n            }\n            syn::NestedMeta::Lit(_) => {\n                Err(format_err_spanned!(\n                    nested_meta,\n                    \"unknown ink! attribute argument (literal)\"\n                ))\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn contains_ink_attributes_works() {\n        assert!(!contains_ink_attributes(&[]));\n        assert!(contains_ink_attributes(&[syn::parse_quote! { #[ink] }]));\n        assert!(contains_ink_attributes(&[syn::parse_quote! { #[ink(..)] }]));\n        assert!(contains_ink_attributes(&[\n            syn::parse_quote! { #[inline] },\n            syn::parse_quote! { #[likely] },\n            syn::parse_quote! { #[ink(storage)] },\n        ]));\n        assert!(!contains_ink_attributes(&[\n            syn::parse_quote! { #[inline] },\n            syn::parse_quote! { #[likely] },\n        ]));\n    }\n\n    /// Asserts that the given input yields the expected first argument or the\n    /// expected error string.\n    ///\n    /// # Note\n    ///\n    /// Can be used to assert against the success and failure path.\n    fn assert_first_ink_attribute(\n        input: &[syn::Attribute],\n        expected: Result<Option<Vec<ir::AttributeArg>>, &'static str>,\n    ) {\n        assert_eq!(\n            first_ink_attribute(input)\n                .map(|maybe_attr: Option<ir::InkAttribute>| {\n                    maybe_attr.map(|attr: ir::InkAttribute| {\n                        attr.args.into_iter().map(|arg| arg.arg).collect::<Vec<_>>()\n                    })\n                })\n                .map_err(|err| err.to_string()),\n            expected.map_err(ToString::to_string),\n        )\n    }\n\n    #[test]\n    fn first_ink_attribute_works() {\n        assert_first_ink_attribute(&[], Ok(None));\n        assert_first_ink_attribute(\n            &[syn::parse_quote! { #[ink(storage)] }],\n            Ok(Some(vec![AttributeArg::Storage])),\n        );\n        assert_first_ink_attribute(\n            &[syn::parse_quote! { #[ink(invalid)] }],\n            Err(\"unknown ink! attribute (path)\"),\n        );\n    }\n\n    mod test {\n        use crate::ir;\n\n        /// Mock for `ir::Attribute` to improve testability.\n        #[derive(Debug, PartialEq, Eq)]\n        pub enum Attribute {\n            Ink(Vec<ir::AttributeArg>),\n            Other(syn::Attribute),\n        }\n\n        impl From<ir::Attribute> for Attribute {\n            fn from(attr: ir::Attribute) -> Self {\n                match attr {\n                    ir::Attribute::Ink(ink_attr) => {\n                        Self::Ink(\n                            ink_attr\n                                .args\n                                .into_iter()\n                                .map(|arg| arg.arg)\n                                .collect::<Vec<_>>(),\n                        )\n                    }\n                    ir::Attribute::Other(other_attr) => Self::Other(other_attr),\n                }\n            }\n        }\n\n        impl From<ir::InkAttribute> for Attribute {\n            fn from(ink_attr: ir::InkAttribute) -> Self {\n                Attribute::from(ir::Attribute::Ink(ink_attr))\n            }\n        }\n\n        /// Mock for `ir::InkAttribute` to improve testability.\n        #[derive(Debug, PartialEq, Eq)]\n        pub struct InkAttribute {\n            args: Vec<ir::AttributeArg>,\n        }\n\n        impl From<ir::InkAttribute> for InkAttribute {\n            fn from(ink_attr: ir::InkAttribute) -> Self {\n                Self {\n                    args: ink_attr\n                        .args\n                        .into_iter()\n                        .map(|arg| arg.arg)\n                        .collect::<Vec<_>>(),\n                }\n            }\n        }\n\n        impl<I> From<I> for InkAttribute\n        where\n            I: IntoIterator<Item = ir::AttributeArg>,\n        {\n            fn from(args: I) -> Self {\n                Self {\n                    args: args.into_iter().collect::<Vec<_>>(),\n                }\n            }\n        }\n    }\n\n    /// Asserts that the given [`syn::Attribute`] is converted into the expected\n    /// [`ir::Attribute]` or yields the expected error message.\n    fn assert_attribute_try_from(\n        input: syn::Attribute,\n        expected: Result<test::Attribute, &'static str>,\n    ) {\n        assert_eq!(\n            <ir::Attribute as TryFrom<_>>::try_from(input)\n                .map(test::Attribute::from)\n                .map_err(|err| err.to_string()),\n            expected.map_err(ToString::to_string),\n        )\n    }\n\n    #[test]\n    fn storage_works() {\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(storage)]\n            },\n            Ok(test::Attribute::Ink(vec![AttributeArg::Storage])),\n        );\n    }\n\n    /// This tests that `#[ink(impl)]` works which can be non-trivial since\n    /// `impl` is also a Rust keyword.\n    #[test]\n    fn impl_works() {\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(impl)]\n            },\n            Ok(test::Attribute::Ink(vec![AttributeArg::Implementation])),\n        );\n    }\n\n    #[test]\n    fn selector_works() {\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(selector = \"0xDEADBEEF\")]\n            },\n            Ok(test::Attribute::Ink(vec![AttributeArg::Selector(\n                Selector::from_bytes([0xDE, 0xAD, 0xBE, 0xEF]),\n            )])),\n        );\n    }\n\n    #[test]\n    fn selector_non_hexcode() {\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(selector = \"0xhelloworld\")]\n            },\n            Err(\"invalid selector - a selector must consist of four bytes in hex (e.g. `selector = \\\"0xCAFEBABE\\\"`)\"),\n        );\n    }\n\n    #[test]\n    fn selector_too_long() {\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(selector = \"0xDEADBEEFC0FEBABE\")]\n            },\n            Err(\"expected 4-digit hexcode for `selector` argument, found 8 digits\"),\n        );\n    }\n\n    #[test]\n    fn selector_invalid_type() {\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(selector = 42)]\n            },\n            Err(\"expecteded 4-digit hexcode for `selector` argument, e.g. #[ink(selector = 0xC0FEBABE]\"),\n        );\n    }\n\n    #[test]\n    fn namespace_works() {\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(namespace = \"my_namespace\")]\n            },\n            Ok(test::Attribute::Ink(vec![AttributeArg::Namespace(\n                Namespace::from(\"my_namespace\".to_string().into_bytes()),\n            )])),\n        );\n    }\n\n    #[test]\n    fn namespace_invalid_type() {\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(namespace = 42)]\n            },\n            Err(\"expecteded string type for `namespace` argument, e.g. #[ink(namespace = \\\"hello\\\")]\"),\n        );\n    }\n\n    #[test]\n    fn namespace_missing_parameter() {\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(namespace)]\n            },\n            Err(\n                \"encountered #[ink(namespace)] that is missing its string parameter. \\\n                Did you mean #[ink(namespace = name: str)] ?\",\n            ),\n        );\n    }\n\n    #[test]\n    fn extension_works() {\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(extension = 42)]\n            },\n            Ok(test::Attribute::Ink(vec![AttributeArg::Extension(\n                ExtensionId::from_u32(42),\n            )])),\n        );\n    }\n\n    #[test]\n    fn extension_invalid_value_type() {\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(extension = \"string\")]\n            },\n            Err(\"expecteded `u32` integer type for `N` in #[ink(extension = N)]\"),\n        );\n    }\n\n    #[test]\n    fn extension_negative_integer() {\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(extension = -1)]\n            },\n            Err(\"could not parse `N` in `#[ink(extension = N)]` into a `u32` integer\"),\n        );\n    }\n\n    #[test]\n    fn extension_too_big_integer() {\n        let max_u32_plus_1 = (u32::MAX as u64) + 1;\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(extension = #max_u32_plus_1)]\n            },\n            Err(\"could not parse `N` in `#[ink(extension = N)]` into a `u32` integer\"),\n        );\n    }\n\n    #[test]\n    fn extension_missing_parameter() {\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(extension)]\n            },\n            Err(\n                \"encountered #[ink(extension)] that is missing its N parameter. \\\n                Did you mean #[ink(extension = N: u32)] ?\",\n            ),\n        );\n    }\n\n    #[test]\n    fn handle_status_works() {\n        fn expected_ok(value: bool) -> Result<test::Attribute, &'static str> {\n            Ok(test::Attribute::Ink(vec![AttributeArg::HandleStatus(\n                value,\n            )]))\n        }\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(handle_status = true)]\n            },\n            expected_ok(true),\n        );\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(handle_status = false)]\n            },\n            expected_ok(false),\n        );\n    }\n\n    #[test]\n    fn handle_status_missing_parameter() {\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(handle_status)]\n            },\n            Err(\n                \"encountered #[ink(handle_status)] that is missing its `flag: bool` parameter. \\\n                Did you mean #[ink(handle_status = flag: bool)] ?\",\n            ),\n        );\n    }\n\n    #[test]\n    fn handle_status_invalid_parameter_type() {\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(handle_status = \"string\")]\n            },\n            Err(\n                \"expecteded `bool` value type for `flag` in #[ink(handle_status = flag)]\",\n            ),\n        );\n    }\n\n    #[test]\n    fn returns_result_works() {\n        fn expected_ok(value: bool) -> Result<test::Attribute, &'static str> {\n            Ok(test::Attribute::Ink(vec![AttributeArg::ReturnsResult(\n                value,\n            )]))\n        }\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(returns_result = true)]\n            },\n            expected_ok(true),\n        );\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(returns_result = false)]\n            },\n            expected_ok(false),\n        );\n    }\n\n    #[test]\n    fn returns_result_missing_parameter() {\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(returns_result)]\n            },\n            Err(\n                \"encountered #[ink(returns_result)] that is missing its `flag: bool` parameter. \\\n                Did you mean #[ink(returns_result = flag: bool)] ?\",\n            ),\n        );\n    }\n\n    #[test]\n    fn returns_result_invalid_parameter_type() {\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(returns_result = \"string\")]\n            },\n            Err(\"expecteded `bool` value type for `flag` in #[ink(returns_result = flag)]\"),\n        );\n    }\n\n    #[test]\n    fn compound_mixed_works() {\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(message, namespace = \"my_namespace\")]\n            },\n            Ok(test::Attribute::Ink(vec![\n                AttributeArg::Message,\n                AttributeArg::Namespace(Namespace::from(\n                    \"my_namespace\".to_string().into_bytes(),\n                )),\n            ])),\n        )\n    }\n\n    #[test]\n    fn compound_simple_works() {\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(\n                    storage,\n                    message,\n                    constructor,\n                    event,\n                    topic,\n                    payable,\n                    impl,\n                )]\n            },\n            Ok(test::Attribute::Ink(vec![\n                AttributeArg::Storage,\n                AttributeArg::Message,\n                AttributeArg::Constructor,\n                AttributeArg::Event,\n                AttributeArg::Topic,\n                AttributeArg::Payable,\n                AttributeArg::Implementation,\n            ])),\n        );\n    }\n\n    #[test]\n    fn non_ink_attribute_works() {\n        let attr: syn::Attribute = syn::parse_quote! {\n            #[non_ink(message)]\n        };\n        assert_attribute_try_from(attr.clone(), Ok(test::Attribute::Other(attr)));\n    }\n\n    #[test]\n    fn empty_ink_attribute_fails() {\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink]\n            },\n            Err(\"unknown ink! attribute\"),\n        );\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink()]\n            },\n            Err(\"encountered unsupported empty ink! attribute\"),\n        );\n    }\n\n    #[test]\n    fn duplicate_flags_fails() {\n        assert_attribute_try_from(\n            syn::parse_quote! {\n                #[ink(message, message)]\n            },\n            Err(\"encountered duplicate ink! attribute arguments\"),\n        );\n    }\n\n    /// Asserts that the given sequence of [`syn::Attribute`] is correctly\n    /// partitioned into the expected tuple of ink! and non-ink! attributes\n    /// or that the expected error is returned.\n    fn assert_parition_attributes(\n        input: Vec<syn::Attribute>,\n        expected: Result<(Vec<test::InkAttribute>, Vec<syn::Attribute>), &'static str>,\n    ) {\n        assert_eq!(\n            partition_attributes(input)\n                .map(|(ink_attr, other_attr)| {\n                    (\n                        ink_attr\n                            .into_iter()\n                            .map(test::InkAttribute::from)\n                            .collect::<Vec<_>>(),\n                        other_attr,\n                    )\n                })\n                .map_err(|err| err.to_string()),\n            expected.map_err(ToString::to_string)\n        );\n    }\n\n    #[test]\n    fn parition_attributes_works() {\n        assert_parition_attributes(\n            vec![\n                syn::parse_quote! { #[ink(message)] },\n                syn::parse_quote! { #[non_ink_attribute] },\n            ],\n            Ok((\n                vec![test::InkAttribute::from(vec![AttributeArg::Message])],\n                vec![syn::parse_quote! { #[non_ink_attribute] }],\n            )),\n        )\n    }\n\n    #[test]\n    fn parition_duplicates_fails() {\n        assert_parition_attributes(\n            vec![\n                syn::parse_quote! { #[ink(message)] },\n                syn::parse_quote! { #[ink(message)] },\n            ],\n            Err(\"encountered duplicate ink! attribute\"),\n        )\n    }\n}\n"],["916","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::{\n    ast,\n    ir,\n};\nuse core::convert::TryFrom;\nuse proc_macro2::TokenStream as TokenStream2;\n\n/// An ink! contract definition consisting of the ink! configuration and module.\n///\n/// This is the root of any ink! smart contract definition. It contains every\n/// information accessible to the ink! smart contract macros. It is also used\n/// as the root source for the ink! code generation.\n///\n/// # Example\n///\n/// ```no_compile\n/// #[ink::contract(/* optional ink! configurations */)]\n/// mod my_contract {\n///     /* ink! and Rust definitions */\n/// }\n/// ```\npub struct Contract {\n    /// The parsed Rust inline module.\n    ///\n    /// Contains all Rust module items after parsing. Note that while parsing\n    /// the ink! module all ink! specific items are moved out of this AST based\n    /// representation.\n    item: ir::ItemMod,\n    /// The specified ink! configuration.\n    config: ir::Config,\n}\n\nimpl Contract {\n    /// Creates a new ink! contract from the given ink! configuration and module\n    /// token streams.\n    ///\n    /// The ink! macro should use this constructor in order to setup ink!.\n    ///\n    /// # Note\n    ///\n    /// - The `ink_config` token stream must properly decode into [`ir::Config`].\n    /// - The `ink_module` token stream must properly decode into [`ir::ItemMod`].\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the provided token stream cannot be decoded properly\n    /// into a valid ink! configuration or ink! module respectively.\n    pub fn new(\n        ink_config: TokenStream2,\n        ink_module: TokenStream2,\n    ) -> Result<Self, syn::Error> {\n        let config = syn::parse2::<ast::AttributeArgs>(ink_config)?;\n        let module = syn::parse2::<syn::ItemMod>(ink_module)?;\n        let ink_config = ir::Config::try_from(config)?;\n        let ink_module = ir::ItemMod::try_from(module)?;\n        Ok(Self {\n            item: ink_module,\n            config: ink_config,\n        })\n    }\n\n    /// Returns the ink! inline module definition.\n    ///\n    /// # Note\n    ///\n    /// The ink! inline module definition is the module that comprises the\n    /// whole ink! smart contract, e.g.:\n    ///\n    /// ```no_compile\n    /// #[ink::contract]\n    /// mod my_contract {\n    ///     // ... definitions\n    /// }\n    /// ```\n    pub fn module(&self) -> &ir::ItemMod {\n        &self.item\n    }\n\n    /// Returns the configuration of the ink! smart contract.\n    ///\n    /// # Note\n    ///\n    /// The configuration is given via the `#[ink::contract(config))]` attribute\n    /// macro annotation itself within the `(config)` part. The available fields\n    /// are the following:\n    ///\n    /// - `types`: To specify `Environment` different from the default environment\n    ///            types.\n    /// - `storage-alloc`: If `true` enables the dynamic storage allocator\n    ///                    facilities and code generation of the ink! smart\n    ///                    contract. Does incure some overhead. The default is\n    ///                    `true`.\n    /// - `as-dependency`: If `true` compiles this ink! smart contract always as\n    ///                    if it was a dependency of another smart contract.\n    ///                    This configuration is mainly needed for testing and\n    ///                    the default is `false`.\n    ///\n    /// Note that we might add more configuration fields in the future if\n    /// necessary.\n    pub fn config(&self) -> &ir::Config {\n        &self.config\n    }\n}\n"],["917","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::{\n    ir,\n    ir::idents_lint,\n};\nuse core::convert::TryFrom;\nuse proc_macro2::{\n    Ident,\n    Span,\n    TokenStream as TokenStream2,\n};\nuse syn::{\n    spanned::Spanned as _,\n    Result,\n};\n\n/// A checked ink! trait definition.\n#[derive(Debug, PartialEq, Eq)]\npub struct InkTrait {\n    item: syn::ItemTrait,\n}\n\nimpl TryFrom<syn::ItemTrait> for InkTrait {\n    type Error = syn::Error;\n\n    fn try_from(item_trait: syn::ItemTrait) -> core::result::Result<Self, Self::Error> {\n        idents_lint::ensure_no_ink_identifiers(&item_trait)?;\n        Self::analyse_properties(&item_trait)?;\n        Self::analyse_items(&item_trait)?;\n        Ok(Self { item: item_trait })\n    }\n}\n\nimpl InkTrait {\n    /// Returns the hash to verify that the trait definition has been checked.\n    pub fn compute_verify_hash<C, M>(\n        trait_name: &Ident,\n        constructors: C,\n        messages: M,\n    ) -> [u8; 32]\n    where\n        // Name and number of inputs.\n        C: Iterator<Item = (Ident, usize)>,\n        // Name, number of inputs and true if message may mutate storage.\n        M: Iterator<Item = (Ident, usize, bool)>,\n    {\n        let mut constructors = constructors\n            .map(|(name, len_inputs)| {\n                [name.to_string(), len_inputs.to_string()].join(\":\")\n            })\n            .collect::<Vec<_>>();\n        let mut messages = messages\n            .map(|(name, len_inputs, mutability)| {\n                let mutability = match mutability {\n                    true => \"w\",\n                    false => \"r\",\n                };\n                [\n                    name.to_string(),\n                    len_inputs.to_string(),\n                    mutability.to_string(),\n                ]\n                .join(\":\")\n            })\n            .collect::<Vec<_>>();\n        constructors.sort_unstable();\n        messages.sort_unstable();\n        let joined_constructors = constructors.join(\",\");\n        let joined_messages = messages.join(\",\");\n        let mut buffer = vec![\"__ink_trait\".to_string(), trait_name.to_string()];\n        if !joined_constructors.is_empty() {\n            buffer.push(joined_constructors);\n        }\n        if !joined_messages.is_empty() {\n            buffer.push(joined_messages);\n        }\n        let buffer = buffer.join(\"::\").into_bytes();\n        use blake2::digest::generic_array::sequence::Split as _;\n        let (head_32, _rest) =\n            <blake2::Blake2b as blake2::Digest>::digest(&buffer).split();\n        head_32.into()\n    }\n\n    /// Returns the hash to verify that the trait definition has been checked.\n    pub fn verify_hash(&self) -> [u8; 32] {\n        let trait_name = self.ident();\n        Self::compute_verify_hash(\n            trait_name,\n            self.iter_items()\n                .flat_map(InkTraitItem::filter_map_constructor)\n                .map(|constructor| {\n                    let name = constructor.sig().ident.clone();\n                    let len_inputs = constructor.sig().inputs.len();\n                    (name, len_inputs)\n                }),\n            self.iter_items()\n                .flat_map(InkTraitItem::filter_map_message)\n                .map(|message| {\n                    let name = message.sig().ident.clone();\n                    let len_inputs = message.sig().inputs.len();\n                    let mutability = message.mutates();\n                    (name, len_inputs, mutability)\n                }),\n        )\n    }\n}\n\n/// Iterator over all the ink! trait items of an ink! trait definition.\npub struct IterInkTraitItems<'a> {\n    iter: core::slice::Iter<'a, syn::TraitItem>,\n}\n\nimpl<'a> IterInkTraitItems<'a> {\n    /// Creates a new iterator yielding ink! trait items.\n    fn new(item_trait: &'a InkTrait) -> Self {\n        Self {\n            iter: item_trait.item.items.iter(),\n        }\n    }\n}\n\nimpl<'a> Iterator for IterInkTraitItems<'a> {\n    type Item = InkTraitItem<'a>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        'outer: loop {\n            match self.iter.next() {\n                None => return None,\n                Some(syn::TraitItem::Method(method)) => {\n                    let first_attr = ir::first_ink_attribute(&method.attrs)\n                        .ok()\n                        .flatten()\n                        .expect(\"unexpected missing ink! attribute for trait method\")\n                        .first()\n                        .kind()\n                        .clone();\n                    match first_attr {\n                        ir::AttributeArg::Constructor => {\n                            return Some(InkTraitItem::Constructor(InkTraitConstructor {\n                                item: method,\n                            }))\n                        }\n                        ir::AttributeArg::Message => {\n                            return Some(InkTraitItem::Message(InkTraitMessage {\n                                item: method,\n                            }))\n                        }\n                        _ => continue 'outer,\n                    }\n                }\n                Some(_) => continue 'outer,\n            }\n        }\n    }\n}\n\n/// An ink! item within an ink! trait definition.\n#[derive(Debug, Clone)]\npub enum InkTraitItem<'a> {\n    Constructor(InkTraitConstructor<'a>),\n    Message(InkTraitMessage<'a>),\n}\n\nimpl<'a> InkTraitItem<'a> {\n    /// Returns `Some` if the ink! trait item is a constructor.\n    pub fn filter_map_constructor(self) -> Option<InkTraitConstructor<'a>> {\n        match self {\n            Self::Constructor(ink_trait_constructor) => Some(ink_trait_constructor),\n            _ => None,\n        }\n    }\n\n    /// Returns `Some` if the ink! trait item is a message.\n    pub fn filter_map_message(self) -> Option<InkTraitMessage<'a>> {\n        match self {\n            Self::Message(ink_trait_message) => Some(ink_trait_message),\n            _ => None,\n        }\n    }\n}\n\n/// Returns all non-ink! attributes.\n///\n/// # Panics\n///\n/// If there are malformed ink! attributes in the input.\nfn extract_rust_attributes(attributes: &[syn::Attribute]) -> Vec<syn::Attribute> {\n    let (_ink_attrs, rust_attrs) = ir::partition_attributes(attributes.to_vec())\n        .expect(\"encountered unexpected invalid ink! attributes\");\n    rust_attrs\n}\n\n/// A checked ink! constructor of an ink! trait definition.\n#[derive(Debug, Clone)]\npub struct InkTraitConstructor<'a> {\n    item: &'a syn::TraitItemMethod,\n}\n\nimpl<'a> InkTraitConstructor<'a> {\n    /// Returns all non-ink! attributes.\n    pub fn attrs(&self) -> Vec<syn::Attribute> {\n        extract_rust_attributes(&self.item.attrs)\n    }\n\n    /// Returns the original signature of the ink! constructor.\n    pub fn sig(&self) -> &syn::Signature {\n        &self.item.sig\n    }\n\n    /// Returns the span of the ink! constructor.\n    pub fn span(&self) -> Span {\n        self.item.span()\n    }\n}\n\n/// A checked ink! message of an ink! trait definition.\n#[derive(Debug, Clone)]\npub struct InkTraitMessage<'a> {\n    item: &'a syn::TraitItemMethod,\n}\n\nimpl<'a> InkTraitMessage<'a> {\n    /// Returns all non-ink! attributes.\n    pub fn attrs(&self) -> Vec<syn::Attribute> {\n        extract_rust_attributes(&self.item.attrs)\n    }\n\n    /// Returns the original signature of the ink! message.\n    pub fn sig(&self) -> &syn::Signature {\n        &self.item.sig\n    }\n\n    /// Returns the span of the ink! message.\n    pub fn span(&self) -> Span {\n        self.item.span()\n    }\n\n    /// Returns `true` if the ink! message may mutate the contract storage.\n    pub fn mutates(&self) -> bool {\n        self.sig()\n            .receiver()\n            .map(|fn_arg| {\n                match fn_arg {\n                    syn::FnArg::Receiver(receiver) if receiver.mutability.is_some() => {\n                        true\n                    }\n                    syn::FnArg::Typed(pat_type) => {\n                        match &*pat_type.ty {\n                            syn::Type::Reference(reference)\n                                if reference.mutability.is_some() =>\n                            {\n                                true\n                            }\n                            _ => false,\n                        }\n                    }\n                    _ => false,\n                }\n            })\n            .expect(\"encountered missing receiver for ink! message\")\n    }\n}\n\nimpl InkTrait {\n    /// Returns `Ok` if the trait matches all requirements for an ink! trait definition.\n    pub fn new(attr: TokenStream2, input: TokenStream2) -> Result<Self> {\n        if !attr.is_empty() {\n            return Err(format_err_spanned!(\n                attr,\n                \"unexpected attribute input for ink! trait definition\"\n            ))\n        }\n        let item_trait = syn::parse2::<syn::ItemTrait>(input)?;\n        InkTrait::try_from(item_trait)\n    }\n\n    /// Returns span of the ink! trait definition.\n    pub fn span(&self) -> Span {\n        self.item.span()\n    }\n\n    /// Returns the attributes of the ink! trait definition.\n    pub fn attrs(&self) -> &[syn::Attribute] {\n        &self.item.attrs\n    }\n\n    /// Returns the identifier of the ink! trait definition.\n    pub fn ident(&self) -> &Ident {\n        &self.item.ident\n    }\n\n    /// Returns an iterator yielding the ink! specific items of the ink! trait definition.\n    pub fn iter_items(&self) -> IterInkTraitItems {\n        IterInkTraitItems::new(self)\n    }\n\n    /// Analyses the properties of the ink! trait definition.\n    ///\n    /// # Errors\n    ///\n    /// - If the trait has been defined as `unsafe`.\n    /// - If the trait is an automatically implemented trait (`auto trait`).\n    /// - If the trait is generic over some set of types.\n    /// - If the trait's visibility is not public (`pub`).\n    fn analyse_properties(item_trait: &syn::ItemTrait) -> Result<()> {\n        if let Some(unsafety) = &item_trait.unsafety {\n            return Err(format_err_spanned!(\n                unsafety,\n                \"ink! trait definitions cannot be unsafe\"\n            ))\n        }\n        if let Some(auto) = &item_trait.auto_token {\n            return Err(format_err_spanned!(\n                auto,\n                \"ink! trait definitions cannot be automatically implemented traits\"\n            ))\n        }\n        if !item_trait.generics.params.is_empty() {\n            return Err(format_err_spanned!(\n                item_trait.generics.params,\n                \"ink! trait definitions must not be generic\"\n            ))\n        }\n        if !matches!(item_trait.vis, syn::Visibility::Public(_)) {\n            return Err(format_err_spanned!(\n                item_trait.vis,\n                \"ink! trait definitions must have public visibility\"\n            ))\n        }\n        if !item_trait.supertraits.is_empty() {\n            return Err(format_err_spanned!(\n                item_trait.supertraits,\n                \"ink! trait definitions with supertraits are not supported, yet\"\n            ))\n        }\n        Ok(())\n    }\n\n    /// Returns `Ok` if all trait items respects the requirements for an ink! trait definition.\n    ///\n    /// # Errors\n    ///\n    /// - If the trait contains an unsupported trait item such as\n    ///     - associated constants (`const`)\n    ///     - associated types (`type`)\n    ///     - macros definitions or usages\n    ///     - unknown token sequences (verbatims)\n    ///     - methods with default implementations\n    /// - If the trait contains methods which do not respect the ink! trait definition requirements:\n    ///     - All trait methods need to be declared as either `#[ink(message)]` or `#[ink(constructor)]`\n    ///       and need to respect their respective rules.\n    ///\n    /// # Note\n    ///\n    /// Associated types and constants might be allowed in the future.\n    fn analyse_items(item_trait: &syn::ItemTrait) -> Result<()> {\n        for trait_item in &item_trait.items {\n            match trait_item {\n                syn::TraitItem::Const(const_trait_item) => {\n                    return Err(format_err_spanned!(\n                        const_trait_item,\n                        \"associated constants in ink! trait definitions are not supported, yet\"\n                    ))\n                }\n                syn::TraitItem::Macro(macro_trait_item) => {\n                    return Err(format_err_spanned!(\n                        macro_trait_item,\n                        \"macros in ink! trait definitions are not supported\"\n                    ))\n                }\n                syn::TraitItem::Type(type_trait_item) => {\n                    return Err(format_err_spanned!(\n                    type_trait_item,\n                    \"associated types in ink! trait definitions are not supported, yet\"\n                ))\n                }\n                syn::TraitItem::Verbatim(verbatim) => {\n                    return Err(format_err_spanned!(\n                        verbatim,\n                        \"encountered unsupported item in ink! trait definition\"\n                    ))\n                }\n                syn::TraitItem::Method(method_trait_item) => {\n                    Self::analyse_methods(method_trait_item)?;\n                }\n                unknown => {\n                    return Err(format_err_spanned!(\n                        unknown,\n                        \"encountered unknown or unsupported item in ink! trait definition\"\n                    ))\n                }\n            }\n        }\n        Ok(())\n    }\n\n    /// Analyses an ink! method that can be either an ink! message or constructor.\n    ///\n    /// # Errors\n    ///\n    /// - If the method declared as `unsafe`, `const` or `async`.\n    /// - If the method has some explicit API.\n    /// - If the method is variadic or has generic parameters.\n    /// - If the method does not respect the properties of either an\n    ///   ink! message or ink! constructor.\n    fn analyse_methods(method: &syn::TraitItemMethod) -> Result<()> {\n        if let Some(default_impl) = &method.default {\n            return Err(format_err_spanned!(\n                default_impl,\n                \"ink! trait methods with default implementations are not supported\"\n            ))\n        }\n        if let Some(constness) = &method.sig.constness {\n            return Err(format_err_spanned!(\n                constness,\n                \"const ink! trait methods are not supported\"\n            ))\n        }\n        if let Some(asyncness) = &method.sig.asyncness {\n            return Err(format_err_spanned!(\n                asyncness,\n                \"async ink! trait methods are not supported\"\n            ))\n        }\n        if let Some(unsafety) = &method.sig.unsafety {\n            return Err(format_err_spanned!(\n                unsafety,\n                \"unsafe ink! trait methods are not supported\"\n            ))\n        }\n        if let Some(abi) = &method.sig.abi {\n            return Err(format_err_spanned!(\n                abi,\n                \"ink! trait methods with non default ABI are not supported\"\n            ))\n        }\n        if let Some(variadic) = &method.sig.variadic {\n            return Err(format_err_spanned!(\n                variadic,\n                \"variadic ink! trait methods are not supported\"\n            ))\n        }\n        if !method.sig.generics.params.is_empty() {\n            return Err(format_err_spanned!(\n                method.sig.generics.params,\n                \"generic ink! trait methods are not supported\"\n            ))\n        }\n        match ir::first_ink_attribute(&method.attrs) {\n            Ok(Some(ink_attr)) => {\n                match ink_attr.first().kind() {\n                    ir::AttributeArg::Message => {\n                        Self::analyse_message(method)?;\n                    }\n                    ir::AttributeArg::Constructor => {\n                        Self::analyse_constructor(method)?;\n                    }\n                    _unsupported => {\n                        return Err(format_err_spanned!(\n                            method,\n                            \"encountered unsupported ink! attribute for ink! trait method\",\n                        ))\n                    }\n                }\n            }\n            Ok(None) => {\n                return Err(format_err_spanned!(\n                    method,\n                    \"missing #[ink(message)] or #[ink(constructor)] flags on ink! trait method\"\n                ))\n            }\n            Err(err) => return Err(err),\n        }\n        Ok(())\n    }\n\n    /// Analyses the properties of an ink! constructor.\n    ///\n    /// # Errors\n    ///\n    /// - If the constructor has a `self` receiver as first argument.\n    /// - If the constructor has no `Self` return type.\n    fn analyse_constructor(constructor: &syn::TraitItemMethod) -> Result<()> {\n        ir::sanitize_attributes(\n            constructor.span(),\n            constructor.attrs.clone(),\n            &ir::AttributeArgKind::Constructor,\n            |arg| {\n                match arg.kind() {\n                    ir::AttributeArg::Constructor => Ok(()),\n                    _ => Err(None),\n                }\n            },\n        )?;\n        if let Some(receiver) = constructor.sig.receiver() {\n            return Err(format_err_spanned!(\n                receiver,\n                \"ink! constructors must not have a `self` receiver\",\n            ))\n        }\n        match &constructor.sig.output {\n            syn::ReturnType::Default => {\n                return Err(format_err_spanned!(\n                    constructor.sig,\n                    \"ink! constructors must return Self\"\n                ))\n            }\n            syn::ReturnType::Type(_, ty) => {\n                match &**ty {\n                    syn::Type::Path(type_path) => {\n                        if !type_path.path.is_ident(\"Self\") {\n                            return Err(format_err_spanned!(\n                                type_path.path,\n                                \"ink! constructors must return Self\"\n                            ))\n                        }\n                    }\n                    unknown => {\n                        return Err(format_err_spanned!(\n                            unknown,\n                            \"ink! constructors must return Self\"\n                        ))\n                    }\n                }\n            }\n        }\n        Ok(())\n    }\n\n    /// Analyses the properties of an ink! message.\n    ///\n    /// # Errors\n    ///\n    /// - If the message has no `&self` or `&mut self` receiver.\n    fn analyse_message(message: &syn::TraitItemMethod) -> Result<()> {\n        ir::sanitize_attributes(\n            message.span(),\n            message.attrs.clone(),\n            &ir::AttributeArgKind::Message,\n            |arg| {\n                match arg.kind() {\n                    ir::AttributeArg::Message => Ok(()),\n                    _ => Err(None),\n                }\n            },\n        )?;\n        match message.sig.receiver() {\n            None | Some(syn::FnArg::Typed(_)) => {\n                return Err(format_err_spanned!(\n                message.sig,\n                \"missing or malformed `&self` or `&mut self` receiver for ink! message\",\n            ))\n            }\n            Some(syn::FnArg::Receiver(receiver)) => {\n                if receiver.reference.is_none() {\n                    return Err(format_err_spanned!(\n                        receiver,\n                        \"self receiver of ink! message must be `&self` or `&mut self`\"\n                    ))\n                }\n            }\n        }\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    /// Checks if the token stream in `$trait_def` results in the expected error message.\n    macro_rules! assert_ink_trait_eq_err {\n        ( error: $err_str:literal, $($trait_def:tt)* ) => {\n            assert_eq!(\n                <InkTrait as TryFrom<syn::ItemTrait>>::try_from(syn::parse_quote! {\n                    $( $trait_def )*\n                })\n                .map_err(|err| err.to_string()),\n                Err(\n                    $err_str.to_string()\n                )\n            )\n        };\n    }\n\n    #[test]\n    fn unsafe_trait_def_is_denied() {\n        assert_ink_trait_eq_err!(\n            error: \"ink! trait definitions cannot be unsafe\",\n            pub unsafe trait MyTrait {}\n        );\n    }\n\n    #[test]\n    fn auto_trait_def_is_denied() {\n        assert_ink_trait_eq_err!(\n            error: \"ink! trait definitions cannot be automatically implemented traits\",\n            pub auto trait MyTrait {}\n        );\n    }\n\n    #[test]\n    fn non_pub_trait_def_is_denied() {\n        assert_ink_trait_eq_err!(\n            error: \"ink! trait definitions must have public visibility\",\n            trait MyTrait {}\n        );\n        assert_ink_trait_eq_err!(\n            error: \"ink! trait definitions must have public visibility\",\n            pub(crate) trait MyTrait {}\n        );\n    }\n\n    #[test]\n    fn generic_trait_def_is_denied() {\n        assert_ink_trait_eq_err!(\n            error: \"ink! trait definitions must not be generic\",\n            pub trait MyTrait<T> {}\n        );\n    }\n\n    #[test]\n    fn trait_def_with_supertraits_is_denied() {\n        assert_ink_trait_eq_err!(\n            error: \"ink! trait definitions with supertraits are not supported, yet\",\n            pub trait MyTrait: SuperTrait {}\n        );\n    }\n\n    #[test]\n    fn trait_def_containing_const_item_is_denied() {\n        assert_ink_trait_eq_err!(\n            error: \"associated constants in ink! trait definitions are not supported, yet\",\n            pub trait MyTrait {\n                const T: i32;\n            }\n        );\n    }\n\n    #[test]\n    fn trait_def_containing_associated_type_is_denied() {\n        assert_ink_trait_eq_err!(\n            error: \"associated types in ink! trait definitions are not supported, yet\",\n            pub trait MyTrait {\n                type Type;\n            }\n        );\n    }\n\n    #[test]\n    fn trait_def_containing_macro_is_denied() {\n        assert_ink_trait_eq_err!(\n            error: \"macros in ink! trait definitions are not supported\",\n            pub trait MyTrait {\n                my_macro_call!();\n            }\n        );\n    }\n\n    #[test]\n    fn trait_def_containing_non_flagged_method_is_denied() {\n        assert_ink_trait_eq_err!(\n            error: \"missing #[ink(message)] or #[ink(constructor)] flags on ink! trait method\",\n            pub trait MyTrait {\n                fn non_flagged_1(&self);\n            }\n        );\n        assert_ink_trait_eq_err!(\n            error: \"missing #[ink(message)] or #[ink(constructor)] flags on ink! trait method\",\n            pub trait MyTrait {\n                fn non_flagged_2(&mut self);\n            }\n        );\n        assert_ink_trait_eq_err!(\n            error: \"missing #[ink(message)] or #[ink(constructor)] flags on ink! trait method\",\n            pub trait MyTrait {\n                fn non_flagged_3() -> Self;\n            }\n        );\n    }\n\n    #[test]\n    fn trait_def_containing_default_implemented_methods_is_denied() {\n        assert_ink_trait_eq_err!(\n            error: \"ink! trait methods with default implementations are not supported\",\n            pub trait MyTrait {\n                #[ink(constructor)]\n                fn default_implemented() -> Self {}\n            }\n        );\n        assert_ink_trait_eq_err!(\n            error: \"ink! trait methods with default implementations are not supported\",\n            pub trait MyTrait {\n                #[ink(message)]\n                fn default_implemented(&self) {}\n            }\n        );\n    }\n\n    #[test]\n    fn trait_def_containing_const_methods_is_denied() {\n        assert_ink_trait_eq_err!(\n            error: \"const ink! trait methods are not supported\",\n            pub trait MyTrait {\n                #[ink(constructor)]\n                const fn const_constructor() -> Self;\n            }\n        );\n        assert_ink_trait_eq_err!(\n            error: \"const ink! trait methods are not supported\",\n            pub trait MyTrait {\n                #[ink(message)]\n                const fn const_message(&self);\n            }\n        );\n    }\n\n    #[test]\n    fn trait_def_containing_async_methods_is_denied() {\n        assert_ink_trait_eq_err!(\n            error: \"async ink! trait methods are not supported\",\n            pub trait MyTrait {\n                #[ink(constructor)]\n                async fn const_constructor() -> Self;\n            }\n        );\n        assert_ink_trait_eq_err!(\n            error: \"async ink! trait methods are not supported\",\n            pub trait MyTrait {\n                #[ink(message)]\n                async fn const_message(&self);\n            }\n        );\n    }\n\n    #[test]\n    fn trait_def_containing_unsafe_methods_is_denied() {\n        assert_ink_trait_eq_err!(\n            error: \"unsafe ink! trait methods are not supported\",\n            pub trait MyTrait {\n                #[ink(constructor)]\n                unsafe fn const_constructor() -> Self;\n            }\n        );\n        assert_ink_trait_eq_err!(\n            error: \"unsafe ink! trait methods are not supported\",\n            pub trait MyTrait {\n                #[ink(message)]\n                unsafe fn const_message(&self);\n            }\n        );\n    }\n\n    #[test]\n    fn trait_def_containing_methods_using_explicit_abi_is_denied() {\n        assert_ink_trait_eq_err!(\n            error: \"ink! trait methods with non default ABI are not supported\",\n            pub trait MyTrait {\n                #[ink(constructor)]\n                extern fn const_constructor() -> Self;\n            }\n        );\n        assert_ink_trait_eq_err!(\n            error: \"ink! trait methods with non default ABI are not supported\",\n            pub trait MyTrait {\n                #[ink(message)]\n                extern fn const_message(&self);\n            }\n        );\n    }\n\n    #[test]\n    fn trait_def_containing_variadic_methods_is_denied() {\n        assert_ink_trait_eq_err!(\n            error: \"variadic ink! trait methods are not supported\",\n            pub trait MyTrait {\n                #[ink(constructor)]\n                fn const_constructor(...) -> Self;\n            }\n        );\n        assert_ink_trait_eq_err!(\n            error: \"variadic ink! trait methods are not supported\",\n            pub trait MyTrait {\n                #[ink(message)]\n                fn const_message(&self, ...);\n            }\n        );\n    }\n\n    #[test]\n    fn trait_def_containing_generic_methods_is_denied() {\n        assert_ink_trait_eq_err!(\n            error: \"generic ink! trait methods are not supported\",\n            pub trait MyTrait {\n                #[ink(constructor)]\n                fn const_constructor<T>() -> Self;\n            }\n        );\n        assert_ink_trait_eq_err!(\n            error: \"generic ink! trait methods are not supported\",\n            pub trait MyTrait {\n                #[ink(message)]\n                fn const_message<T>(&self);\n            }\n        );\n    }\n\n    #[test]\n    fn trait_def_containing_method_with_unsupported_ink_attribute_is_denied() {\n        assert_ink_trait_eq_err!(\n            error: \"encountered unsupported ink! attribute for ink! trait method\",\n            pub trait MyTrait {\n                #[ink(payable)]\n                fn unsupported_ink_attribute(&self);\n            }\n        );\n        assert_ink_trait_eq_err!(\n            error: \"unknown ink! attribute (path)\",\n            pub trait MyTrait {\n                #[ink(unknown)]\n                fn unknown_ink_attribute(&self);\n            }\n        );\n    }\n\n    #[test]\n    fn trait_def_containing_invalid_constructor_is_denied() {\n        assert_ink_trait_eq_err!(\n            error: \"ink! constructors must not have a `self` receiver\",\n            pub trait MyTrait {\n                #[ink(constructor)]\n                fn has_self_receiver(&self) -> Self;\n            }\n        );\n        assert_ink_trait_eq_err!(\n            error: \"ink! constructors must not have a `self` receiver\",\n            pub trait MyTrait {\n                #[ink(constructor)]\n                fn has_self_receiver(&mut self) -> Self;\n            }\n        );\n        assert_ink_trait_eq_err!(\n            error: \"ink! constructors must not have a `self` receiver\",\n            pub trait MyTrait {\n                #[ink(constructor)]\n                fn has_self_receiver(self) -> Self;\n            }\n        );\n        assert_ink_trait_eq_err!(\n            error: \"ink! constructors must not have a `self` receiver\",\n            pub trait MyTrait {\n                #[ink(constructor)]\n                fn has_self_receiver(self: &Self) -> Self;\n            }\n        );\n        assert_ink_trait_eq_err!(\n            error: \"ink! constructors must not have a `self` receiver\",\n            pub trait MyTrait {\n                #[ink(constructor)]\n                fn has_self_receiver(self: Self) -> Self;\n            }\n        );\n        assert_ink_trait_eq_err!(\n            error: \"ink! constructors must return Self\",\n            pub trait MyTrait {\n                #[ink(constructor)]\n                fn does_not_return_self();\n            }\n        );\n        assert_ink_trait_eq_err!(\n            error: \"ink! constructors must return Self\",\n            pub trait MyTrait {\n                #[ink(constructor)]\n                fn does_not_return_self() -> i32;\n            }\n        );\n    }\n\n    #[test]\n    fn trait_def_containing_invalid_message_is_denied() {\n        assert_ink_trait_eq_err!(\n            error: \"missing or malformed `&self` or `&mut self` receiver for ink! message\",\n            pub trait MyTrait {\n                #[ink(message)]\n                fn does_not_return_self();\n            }\n        );\n        assert_ink_trait_eq_err!(\n            error: \"missing or malformed `&self` or `&mut self` receiver for ink! message\",\n            pub trait MyTrait {\n                #[ink(message)]\n                fn does_not_return_self(self: &Self);\n            }\n        );\n        assert_ink_trait_eq_err!(\n            error: \"self receiver of ink! message must be `&self` or `&mut self`\",\n            pub trait MyTrait {\n                #[ink(message)]\n                fn does_not_return_self(self);\n            }\n        );\n    }\n\n    #[test]\n    fn trait_def_containing_constructor_with_invalid_ink_attributes_is_denied() {\n        assert_ink_trait_eq_err!(\n            error: \"encountered duplicate ink! attribute\",\n            pub trait MyTrait {\n                #[ink(constructor)]\n                #[ink(constructor)]\n                fn does_not_return_self() -> Self;\n            }\n        );\n        assert_ink_trait_eq_err!(\n            error: \"encountered conflicting ink! attribute argument\",\n            pub trait MyTrait {\n                #[ink(constructor)]\n                #[ink(message)]\n                fn does_not_return_self() -> Self;\n            }\n        );\n        assert_ink_trait_eq_err!(\n            error: \"encountered conflicting ink! attribute argument\",\n            pub trait MyTrait {\n                #[ink(constructor)]\n                #[ink(payable)]\n                fn does_not_return_self() -> Self;\n            }\n        );\n    }\n\n    #[test]\n    fn trait_def_containing_message_with_invalid_ink_attributes_is_denied() {\n        assert_ink_trait_eq_err!(\n            error: \"encountered duplicate ink! attribute\",\n            pub trait MyTrait {\n                #[ink(message)]\n                #[ink(message)]\n                fn does_not_return_self(&self);\n            }\n        );\n        assert_ink_trait_eq_err!(\n            error: \"encountered conflicting ink! attribute argument\",\n            pub trait MyTrait {\n                #[ink(message)]\n                #[ink(constructor)]\n                fn does_not_return_self(&self);\n            }\n        );\n        assert_ink_trait_eq_err!(\n            error: \"encountered conflicting ink! attribute argument\",\n            pub trait MyTrait {\n                #[ink(message)]\n                #[ink(payable)]\n                fn does_not_return_self(&self);\n            }\n        );\n    }\n\n    #[test]\n    fn trait_def_is_ok() {\n        assert!(\n            <InkTrait as TryFrom<syn::ItemTrait>>::try_from(syn::parse_quote! {\n                pub trait MyTrait {\n                    #[ink(constructor)]\n                    fn my_constructor() -> Self;\n                    #[ink(message)]\n                    fn my_message(&self);\n                    #[ink(message)]\n                    fn my_message_mut(&mut self);\n                }\n            })\n            .is_ok()\n        )\n    }\n\n    #[test]\n    fn iter_constructors_works() {\n        let ink_trait =\n            <InkTrait as TryFrom<syn::ItemTrait>>::try_from(syn::parse_quote! {\n                pub trait MyTrait {\n                    #[ink(constructor)]\n                    fn constructor_1() -> Self;\n                    #[ink(constructor)]\n                    fn constructor_2() -> Self;\n                    #[ink(message)]\n                    fn message_1(&self);\n                    #[ink(message)]\n                    fn message_2(&mut self);\n                 }\n            })\n            .unwrap();\n        let actual = ink_trait\n            .iter_items()\n            .flat_map(|item| {\n                item.filter_map_constructor()\n                    .map(|constructor| constructor.sig().ident.to_string())\n            })\n            .collect::<Vec<_>>();\n        let expected = vec![\"constructor_1\".to_string(), \"constructor_2\".to_string()];\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn iter_messages_works() {\n        let ink_trait =\n            <InkTrait as TryFrom<syn::ItemTrait>>::try_from(syn::parse_quote! {\n                pub trait MyTrait {\n                    #[ink(constructor)]\n                    fn constructor_1() -> Self;\n                    #[ink(constructor)]\n                    fn constructor_2() -> Self;\n                    #[ink(message)]\n                    fn message_1(&self);\n                    #[ink(message)]\n                    fn message_2(&mut self);\n                }\n            })\n            .unwrap();\n        let actual = ink_trait\n            .iter_items()\n            .flat_map(|item| {\n                item.filter_map_message()\n                    .map(|message| message.sig().ident.to_string())\n            })\n            .collect::<Vec<_>>();\n        let expected = vec![\"message_1\".to_string(), \"message_2\".to_string()];\n        assert_eq!(actual, expected);\n    }\n\n    fn assert_verify_hash2_works_with(ink_trait: InkTrait, expected: &str) {\n        let expected = expected.to_string().into_bytes();\n        let actual = ink_trait.verify_hash();\n        let expected: [u8; 32] = {\n            use blake2::digest::generic_array::sequence::Split as _;\n            let (head_32, _rest) =\n                <blake2::Blake2b as blake2::Digest>::digest(&expected).split();\n            head_32.into()\n        };\n        assert_eq!(actual, expected);\n    }\n\n    macro_rules! ink_trait {\n        ( $($tt:tt)* ) => {{\n            <InkTrait as TryFrom<syn::ItemTrait>>::try_from(syn::parse_quote! {\n                $( $tt )*\n            })\n            .unwrap()\n        }};\n    }\n\n    #[test]\n    fn verify_hash_works() {\n        let ink_trait = ink_trait! {\n            pub trait MyTrait {\n                #[ink(constructor)]\n                fn constructor_1() -> Self;\n                #[ink(constructor)]\n                fn constructor_2(a: i32, b: i32) -> Self;\n                #[ink(message)]\n                fn message_1(&self);\n                #[ink(message)]\n                fn message_2(&mut self, a: i32, b: i32) -> i32;\n            }\n        };\n        assert_verify_hash2_works_with(\n            ink_trait,\n            \"__ink_trait::MyTrait::constructor_1:0,constructor_2:2::message_1:1:r,message_2:3:w\"\n        );\n    }\n\n    #[test]\n    fn verify_hash_works_without_constructors() {\n        let ink_trait = ink_trait! {\n            pub trait MyTrait {\n                #[ink(message)]\n                fn message_1(&self);\n                #[ink(message)]\n                fn message_2(&mut self, a: i32, b: i32) -> i32;\n            }\n        };\n        assert_verify_hash2_works_with(\n            ink_trait,\n            \"__ink_trait::MyTrait::message_1:1:r,message_2:3:w\",\n        );\n    }\n\n    #[test]\n    fn verify_hash_works_without_messages() {\n        let ink_trait = ink_trait! {\n            pub trait MyTrait {\n                #[ink(constructor)]\n                fn constructor_1() -> Self;\n                #[ink(constructor)]\n                fn constructor_2(a: i32, b: i32) -> Self;\n            }\n        };\n        assert_verify_hash2_works_with(\n            ink_trait,\n            \"__ink_trait::MyTrait::constructor_1:0,constructor_2:2\",\n        );\n    }\n}\n"],["918","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::{\n    error::ExtError,\n    ir,\n    ir::idents_lint,\n};\nuse core::{\n    convert::TryFrom,\n    slice::Iter as SliceIter,\n};\nuse proc_macro2::TokenStream as TokenStream2;\nuse std::collections::HashMap;\nuse syn::{\n    spanned::Spanned as _,\n    Result,\n};\n\n/// An ink! chain extension.\n#[derive(Debug, PartialEq, Eq)]\npub struct ChainExtension {\n    item: syn::ItemTrait,\n    error_code: syn::TraitItemType,\n    methods: Vec<ChainExtensionMethod>,\n}\n\nimpl ChainExtension {\n    /// Returns the Rust attributes of the ink! chain extension.\n    pub fn attrs(&self) -> Vec<syn::Attribute> {\n        let (_, attrs) = ir::partition_attributes(self.item.attrs.iter().cloned())\n            .expect(\"encountered unexpected invalid attributes for ink! chain extension\");\n        attrs\n    }\n\n    /// Returns the span of the ink! chain extension.\n    pub fn span(&self) -> proc_macro2::Span {\n        self.item.span()\n    }\n\n    /// Returns the identifier of the ink! chain extension.\n    pub fn ident(&self) -> &proc_macro2::Ident {\n        &self.item.ident\n    }\n\n    /// Returns a slice over all the chain extension methods.\n    pub fn iter_methods(&self) -> SliceIter<ChainExtensionMethod> {\n        self.methods.iter()\n    }\n\n    /// Returns the type of the error code of the chain extension.\n    pub fn error_code(&self) -> &syn::Type {\n        self.error_code\n            .default\n            .as_ref()\n            .map(|(_token, ty)| ty)\n            .expect(\"unexpected missing default type for error code\")\n    }\n}\n\n/// An ink! chain extension method.\n#[derive(Debug, PartialEq, Eq)]\npub struct ChainExtensionMethod {\n    /// The underlying validated AST of the chain extension method.\n    item: syn::TraitItemMethod,\n    /// The unique identifier of the chain extension method.\n    id: ExtensionId,\n    /// If `false` the `u32` status code of the chain extension method call is going to be\n    /// ignored and assumed to be always successful. The output buffer in this case is going\n    /// to be queried and decoded into the chain extension method's output type.\n    ///\n    /// If `true` the returned `u32` status code `code` is queried and\n    /// `<Self::ErrorCode as ink_lang::FromStatusCode>::from_status_code(code)` is called.\n    /// The call to `from_status_code` returns `Result<(), Self::ErrorCode>`. If `Ok(())`\n    /// the output buffer is queried and decoded as described above.\n    /// If `Err(Self::ErrorCode)` the `Self::ErrorCode` is converted into `E` of `Result<T, E>`\n    /// if the chain extension method returns a `Result` type.\n    /// In case the chain extension method does _NOT_ return a `Result` type the call returns\n    /// `Result<T, Self::ErrorCode>` where `T` is the chain extension method's return type.\n    ///\n    /// The default for this flag is `true`.\n    handle_status: bool,\n    /// If `false` the proc. macro no longer tries to enforce that the returned type encoded\n    /// into the output buffer of the chain extension method call is of type `Result<T, E>`.\n    /// Also `E` is no longer required to implement `From<Self::ErrorCode>` in case `handle_status`\n    /// flag does not exist.\n    ///\n    /// The default for this flag is `true`.\n    returns_result: bool,\n}\n\nimpl ChainExtensionMethod {\n    /// Returns the Rust attributes of the ink! chain extension method.\n    pub fn attrs(&self) -> Vec<syn::Attribute> {\n        let (_, attrs) = ir::partition_attributes(self.item.attrs.iter().cloned())\n            .expect(\n            \"encountered unexpected invalid attributes for ink! chain extension method\",\n        );\n        attrs\n    }\n\n    /// Returns the span of the ink! chain extension method.\n    pub fn span(&self) -> proc_macro2::Span {\n        self.item.span()\n    }\n\n    /// Returns the identifier of the ink! chain extension method.\n    pub fn ident(&self) -> &proc_macro2::Ident {\n        &self.item.sig.ident\n    }\n\n    /// Returns the method signature of the ink! chain extension method.\n    pub fn sig(&self) -> &syn::Signature {\n        &self.item.sig\n    }\n\n    /// Returns the unique ID of the chain extension method.\n    pub fn id(&self) -> ExtensionId {\n        self.id\n    }\n\n    /// Returns an iterator over the inputs of the chain extension method.\n    pub fn inputs(&self) -> ChainExtensionMethodInputs {\n        ChainExtensionMethodInputs {\n            iter: self.item.sig.inputs.iter(),\n        }\n    }\n\n    /// Returns `true` if the chain extension method was flagged with `#[ink(handle_status)]`.\n    pub fn handle_status(&self) -> bool {\n        self.handle_status\n    }\n\n    /// Returns `true` if the chain extension method was flagged with `#[ink(returns_result)]`.\n    pub fn returns_result(&self) -> bool {\n        self.returns_result\n    }\n}\n\npub struct ChainExtensionMethodInputs<'a> {\n    iter: syn::punctuated::Iter<'a, syn::FnArg>,\n}\n\nimpl<'a> Iterator for ChainExtensionMethodInputs<'a> {\n    type Item = &'a syn::PatType;\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let item = self.iter.next()?;\n        match item {\n            syn::FnArg::Receiver(receiver) => {\n                panic!(\"encountered unexpected receiver in chain extension method input: {:?}\", receiver)\n            }\n            syn::FnArg::Typed(pat_type) => Some(pat_type),\n        }\n    }\n}\n\n/// The unique ID of an ink! chain extension method.\n///\n/// # Note\n///\n/// The ink! attribute `#[ink(extension = N: u32)]` for chain extension methods.\n///\n/// Has a `func_id` extension ID to identify the associated chain extension method.\n#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub struct ExtensionId {\n    index: u32,\n}\n\nimpl ExtensionId {\n    /// Creates a new chain extension method ID from the given `u32`.\n    pub fn from_u32(index: u32) -> Self {\n        Self { index }\n    }\n\n    /// Returns the underlying raw `u32` index.\n    pub fn into_u32(self) -> u32 {\n        self.index\n    }\n}\n\nimpl TryFrom<syn::ItemTrait> for ChainExtension {\n    type Error = syn::Error;\n\n    fn try_from(item_trait: syn::ItemTrait) -> core::result::Result<Self, Self::Error> {\n        idents_lint::ensure_no_ink_identifiers(&item_trait)?;\n        Self::analyse_properties(&item_trait)?;\n        let (error_code, methods) = Self::analyse_items(&item_trait)?;\n        Ok(Self {\n            item: item_trait,\n            error_code,\n            methods,\n        })\n    }\n}\n\nimpl ChainExtension {\n    /// Returns `Ok` if the trait matches all requirements for an ink! chain extension.\n    pub fn new(attr: TokenStream2, input: TokenStream2) -> Result<Self> {\n        if !attr.is_empty() {\n            return Err(format_err_spanned!(\n                attr,\n                \"unexpected attribute input for ink! chain extension\"\n            ))\n        }\n        let item_trait = syn::parse2::<syn::ItemTrait>(input)?;\n        ChainExtension::try_from(item_trait)\n    }\n\n    /// Analyses the properties of the ink! chain extension.\n    ///\n    /// # Errors\n    ///\n    /// - If the input trait has been defined as `unsafe`.\n    /// - If the input trait is an automatically implemented trait (`auto trait`).\n    /// - If the input trait is generic over some set of types.\n    /// - If the input trait's visibility is not public (`pub`).\n    /// - If the input trait has supertraits.\n    fn analyse_properties(item_trait: &syn::ItemTrait) -> Result<()> {\n        if let Some(unsafety) = &item_trait.unsafety {\n            return Err(format_err_spanned!(\n                unsafety,\n                \"ink! chain extensions cannot be unsafe\"\n            ))\n        }\n        if let Some(auto) = &item_trait.auto_token {\n            return Err(format_err_spanned!(\n                auto,\n                \"ink! chain extensions cannot be automatically implemented traits\"\n            ))\n        }\n        if !item_trait.generics.params.is_empty() {\n            return Err(format_err_spanned!(\n                item_trait.generics.params,\n                \"ink! chain extensions must not be generic\"\n            ))\n        }\n        if !matches!(item_trait.vis, syn::Visibility::Public(_)) {\n            return Err(format_err_spanned!(\n                item_trait.vis,\n                \"ink! chain extensions must have public visibility\"\n            ))\n        }\n        if !item_trait.supertraits.is_empty() {\n            return Err(format_err_spanned!(\n                item_trait.supertraits,\n                \"ink! chain extensions with supertraits are not supported, yet\"\n            ))\n        }\n        Ok(())\n    }\n\n    /// Checks if the associated trait item type is a proper chain extension error code.\n    ///\n    /// # Errors\n    ///\n    /// - If the associated type is not called `ErrorCode`.\n    /// - If the associated type is generic, has where bounds or has a default type.\n    /// - If there are multiple associated `ErrorCode` types.\n    fn analyse_error_code(\n        item_type: &syn::TraitItemType,\n        previous: &mut Option<syn::TraitItemType>,\n    ) -> Result<()> {\n        if item_type.ident != \"ErrorCode\" {\n            return Err(format_err_spanned!(\n                item_type.ident,\n                \"chain extensions expect an associated type with name `ErrorCode` but found {}\",\n                item_type.ident,\n            ))\n        }\n        if !item_type.generics.params.is_empty() {\n            return Err(format_err_spanned!(\n                item_type.generics,\n                \"generic chain extension `ErrorCode` types are not supported\",\n            ))\n        }\n        if !item_type.bounds.is_empty() {\n            return Err(format_err_spanned!(\n                item_type.bounds,\n                \"bounded chain extension `ErrorCode` types are not supported\",\n            ))\n        }\n        if item_type.default.is_none() {\n            return Err(format_err_spanned!(\n                item_type,\n                \"expected a default type for the ink! chain extension ErrorCode\",\n            ))\n        }\n        match previous {\n            Some(previous_error_code) => {\n                return Err(format_err_spanned!(\n                    item_type,\n                    \"encountered duplicate `ErrorCode` associated types for the chain extension\",\n                )).map_err(|err| err.into_combine(format_err_spanned!(\n                    previous_error_code,\n                    \"first `ErrorCode` associated type here\",\n                )))\n            }\n            None => {\n                *previous = Some(item_type.clone());\n            }\n        }\n        Ok(())\n    }\n\n    /// Returns `Ok` if all trait items respect the requirements for an ink! chain extension.\n    ///\n    /// # Errors\n    ///\n    /// - If the trait contains an unsupported trait item such as\n    ///     - associated constants (`const`)\n    ///     - associated types (`type`)\n    ///     - macros definitions or usages\n    ///     - unknown token sequences (verbatims)\n    ///     - methods with default implementations\n    /// - If the trait contains methods which do not respect the ink! trait definition requirements:\n    ///     - All trait methods must not have a `self` receiver.\n    ///     - All trait methods must have an `#[ink(extension = N: u32)]` attribute that is the ID that\n    ///       corresponds with the function ID of the respective chain extension call.\n    ///\n    /// # Note\n    ///\n    /// The input Rust trait item is going to be replaced with a concrete chain extension type definition\n    /// as a result of this proc. macro invocation.\n    fn analyse_items(\n        item_trait: &syn::ItemTrait,\n    ) -> Result<(syn::TraitItemType, Vec<ChainExtensionMethod>)> {\n        let mut methods = Vec::new();\n        let mut seen_ids = HashMap::new();\n        let mut error_code = None;\n        for trait_item in &item_trait.items {\n            match trait_item {\n                syn::TraitItem::Const(const_trait_item) => {\n                    return Err(format_err_spanned!(\n                        const_trait_item,\n                        \"associated constants in ink! chain extensions are not supported, yet\"\n                    ))\n                }\n                syn::TraitItem::Macro(macro_trait_item) => {\n                    return Err(format_err_spanned!(\n                        macro_trait_item,\n                        \"macros in ink! chain extensions are not supported\"\n                    ))\n                }\n                syn::TraitItem::Type(type_trait_item) => {\n                    Self::analyse_error_code(type_trait_item, &mut error_code)?;\n                }\n                syn::TraitItem::Verbatim(verbatim) => {\n                    return Err(format_err_spanned!(\n                        verbatim,\n                        \"encountered unsupported item in ink! chain extensions\"\n                    ))\n                }\n                syn::TraitItem::Method(method_trait_item) => {\n                    let method = Self::analyse_methods(method_trait_item)?;\n                    let method_id = method.id();\n                    if let Some(previous) = seen_ids.get(&method_id) {\n                        return Err(format_err!(\n                            method.span(),\n                            \"encountered duplicate extension identifiers for the same chain extension\",\n                        ).into_combine(format_err!(\n                            *previous,\n                            \"previous duplicate extension identifier here\",\n                        )))\n                    }\n                    seen_ids.insert(method_id, method.span());\n                    methods.push(method);\n                }\n                unknown => {\n                    return Err(format_err_spanned!(\n                        unknown,\n                        \"encountered unknown or unsupported item in ink! chain extensions\"\n                    ))\n                }\n            }\n        }\n        let error_code = match error_code {\n            Some(error_code) => error_code,\n            None => {\n                return Err(format_err_spanned!(\n                    item_trait,\n                    \"missing ErrorCode associated type from ink! chain extension\",\n                ))\n            }\n        };\n        Ok((error_code, methods))\n    }\n\n    /// Analyses a chain extension method.\n    ///\n    /// # Errors\n    ///\n    /// - If the method is missing the `#[ink(extension = N: u32)]` attribute.\n    /// - If the method has a `self` receiver.\n    /// - If the method declared as `unsafe`, `const` or `async`.\n    /// - If the method has some explicit API.\n    /// - If the method is variadic or has generic parameters.\n    fn analyse_methods(method: &syn::TraitItemMethod) -> Result<ChainExtensionMethod> {\n        if let Some(default_impl) = &method.default {\n            return Err(format_err_spanned!(\n                default_impl,\n                \"ink! chain extension methods with default implementations are not supported\"\n            ))\n        }\n        if let Some(constness) = &method.sig.constness {\n            return Err(format_err_spanned!(\n                constness,\n                \"const ink! chain extension methods are not supported\"\n            ))\n        }\n        if let Some(asyncness) = &method.sig.asyncness {\n            return Err(format_err_spanned!(\n                asyncness,\n                \"async ink! chain extension methods are not supported\"\n            ))\n        }\n        if let Some(unsafety) = &method.sig.unsafety {\n            return Err(format_err_spanned!(\n                unsafety,\n                \"unsafe ink! chain extension methods are not supported\"\n            ))\n        }\n        if let Some(abi) = &method.sig.abi {\n            return Err(format_err_spanned!(\n                abi,\n                \"ink! chain extension methods with non default ABI are not supported\"\n            ))\n        }\n        if let Some(variadic) = &method.sig.variadic {\n            return Err(format_err_spanned!(\n                variadic,\n                \"variadic ink! chain extension methods are not supported\"\n            ))\n        }\n        if !method.sig.generics.params.is_empty() {\n            return Err(format_err_spanned!(\n                method.sig.generics.params,\n                \"generic ink! chain extension methods are not supported\"\n            ))\n        }\n        match ir::first_ink_attribute(&method.attrs)?\n                .map(|attr| attr.first().kind().clone()) {\n            Some(ir::AttributeArg::Extension(extension)) => {\n                Self::analyse_chain_extension_method(method, extension)\n            }\n            Some(_unsupported) => {\n                Err(format_err_spanned!(\n                    method,\n                    \"encountered unsupported ink! attribute for ink! chain extension method. expected #[ink(extension = N: u32)] attribute\"\n                ))\n            }\n            None => {\n                Err(format_err_spanned!(\n                    method,\n                    \"missing #[ink(extension = N: u32)] flag on ink! chain extension method\"\n                ))\n            }\n        }\n    }\n\n    /// Analyses the properties of an ink! chain extension method.\n    ///\n    /// # Errors\n    ///\n    /// - If the chain extension method has a `self` receiver as first argument.\n    fn analyse_chain_extension_method(\n        item_method: &syn::TraitItemMethod,\n        extension: ExtensionId,\n    ) -> Result<ChainExtensionMethod> {\n        let (ink_attrs, _) = ir::sanitize_attributes(\n            item_method.span(),\n            item_method.attrs.clone(),\n            &ir::AttributeArgKind::Extension,\n            |arg| {\n                match arg.kind() {\n                    ir::AttributeArg::Extension(_)\n                    | ir::AttributeArg::HandleStatus(_)\n                    | ir::AttributeArg::ReturnsResult(_) => Ok(()),\n                    _ => Err(None),\n                }\n            },\n        )?;\n        if let Some(receiver) = item_method.sig.receiver() {\n            return Err(format_err_spanned!(\n                receiver,\n                \"ink! chain extension method must not have a `self` receiver\",\n            ))\n        }\n        let result = ChainExtensionMethod {\n            id: extension,\n            item: item_method.clone(),\n            handle_status: ink_attrs.is_handle_status(),\n            returns_result: ink_attrs.is_returns_result(),\n        };\n        Ok(result)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    /// Checks if the token stream in `$chain_extension` results in the expected error message.\n    macro_rules! assert_ink_chain_extension_eq_err {\n        ( error: $err_str:literal, $($chain_extension:tt)* ) => {\n            assert_eq!(\n                <ChainExtension as TryFrom<syn::ItemTrait>>::try_from(syn::parse_quote! {\n                    $( $chain_extension )*\n                })\n                .map_err(|err| err.to_string()),\n                Err(\n                    $err_str.to_string()\n                )\n            )\n        };\n    }\n\n    #[test]\n    fn unsafe_chain_extension_is_denied() {\n        assert_ink_chain_extension_eq_err!(\n            error: \"ink! chain extensions cannot be unsafe\",\n            pub unsafe trait MyChainExtension {}\n        );\n    }\n\n    #[test]\n    fn auto_chain_extension_is_denied() {\n        assert_ink_chain_extension_eq_err!(\n            error: \"ink! chain extensions cannot be automatically implemented traits\",\n            pub auto trait MyChainExtension {}\n        );\n    }\n\n    #[test]\n    fn non_pub_chain_extension_is_denied() {\n        assert_ink_chain_extension_eq_err!(\n            error: \"ink! chain extensions must have public visibility\",\n            trait MyChainExtension {}\n        );\n        assert_ink_chain_extension_eq_err!(\n            error: \"ink! chain extensions must have public visibility\",\n            pub(crate) trait MyChainExtension {}\n        );\n    }\n\n    #[test]\n    fn generic_chain_extension_is_denied() {\n        assert_ink_chain_extension_eq_err!(\n            error: \"ink! chain extensions must not be generic\",\n            pub trait MyChainExtension<T> {}\n        );\n    }\n\n    #[test]\n    fn chain_extension_with_supertraits_is_denied() {\n        assert_ink_chain_extension_eq_err!(\n            error: \"ink! chain extensions with supertraits are not supported, yet\",\n            pub trait MyChainExtension: SuperChainExtension {}\n        );\n    }\n\n    #[test]\n    fn chain_extension_containing_const_item_is_denied() {\n        assert_ink_chain_extension_eq_err!(\n            error: \"associated constants in ink! chain extensions are not supported, yet\",\n            pub trait MyChainExtension {\n                const T: i32;\n            }\n        );\n    }\n\n    #[test]\n    fn chain_extension_containing_invalid_associated_type_is_denied() {\n        assert_ink_chain_extension_eq_err!(\n            error: \"chain extensions expect an associated type with name `ErrorCode` but found Type\",\n            pub trait MyChainExtension {\n                type Type;\n            }\n        );\n    }\n\n    #[test]\n    fn chain_extension_with_invalid_error_code() {\n        assert_ink_chain_extension_eq_err!(\n            error: \"chain extensions expect an associated type with name `ErrorCode` but found IncorrectName\",\n            pub trait MyChainExtension {\n                type IncorrectName = ();\n            }\n        );\n        assert_ink_chain_extension_eq_err!(\n            error: \"generic chain extension `ErrorCode` types are not supported\",\n            pub trait MyChainExtension {\n                type ErrorCode<T> = ();\n            }\n        );\n        assert_ink_chain_extension_eq_err!(\n            error: \"bounded chain extension `ErrorCode` types are not supported\",\n            pub trait MyChainExtension {\n                type ErrorCode: Copy = ();\n            }\n        );\n        assert_ink_chain_extension_eq_err!(\n            error: \"expected a default type for the ink! chain extension ErrorCode\",\n            pub trait MyChainExtension {\n                type ErrorCode;\n            }\n        );\n        assert_ink_chain_extension_eq_err!(\n            error: \"encountered duplicate `ErrorCode` associated types for the chain extension\",\n            pub trait MyChainExtension {\n                type ErrorCode = ();\n                type ErrorCode = ();\n            }\n        );\n    }\n\n    #[test]\n    fn chain_extension_containing_macro_is_denied() {\n        assert_ink_chain_extension_eq_err!(\n            error: \"macros in ink! chain extensions are not supported\",\n            pub trait MyChainExtension {\n                my_macro_call!();\n            }\n        );\n    }\n\n    #[test]\n    fn chain_extension_containing_non_flagged_method_is_denied() {\n        assert_ink_chain_extension_eq_err!(\n            error: \"missing #[ink(extension = N: u32)] flag on ink! chain extension method\",\n            pub trait MyChainExtension {\n                fn non_flagged_1(&self);\n            }\n        );\n        assert_ink_chain_extension_eq_err!(\n            error: \"missing #[ink(extension = N: u32)] flag on ink! chain extension method\",\n            pub trait MyChainExtension {\n                fn non_flagged_2(&mut self);\n            }\n        );\n        assert_ink_chain_extension_eq_err!(\n            error: \"missing #[ink(extension = N: u32)] flag on ink! chain extension method\",\n            pub trait MyChainExtension {\n                fn non_flagged_3() -> Self;\n            }\n        );\n    }\n\n    #[test]\n    fn chain_extension_containing_default_implemented_methods_is_denied() {\n        assert_ink_chain_extension_eq_err!(\n            error: \"ink! chain extension methods with default implementations are not supported\",\n            pub trait MyChainExtension {\n                #[ink(constructor)]\n                fn default_implemented() -> Self {}\n            }\n        );\n    }\n\n    #[test]\n    fn chain_extension_containing_const_methods_is_denied() {\n        assert_ink_chain_extension_eq_err!(\n            error: \"const ink! chain extension methods are not supported\",\n            pub trait MyChainExtension {\n                #[ink(extension = 1)]\n                const fn const_constructor() -> Self;\n            }\n        );\n    }\n\n    #[test]\n    fn chain_extension_containing_async_methods_is_denied() {\n        assert_ink_chain_extension_eq_err!(\n            error: \"async ink! chain extension methods are not supported\",\n            pub trait MyChainExtension {\n                #[ink(extension = 1)]\n                async fn const_constructor() -> Self;\n            }\n        );\n    }\n\n    #[test]\n    fn chain_extension_containing_unsafe_methods_is_denied() {\n        assert_ink_chain_extension_eq_err!(\n            error: \"unsafe ink! chain extension methods are not supported\",\n            pub trait MyChainExtension {\n                #[ink(extension = 1)]\n                unsafe fn const_constructor() -> Self;\n            }\n        );\n    }\n\n    #[test]\n    fn chain_extension_containing_methods_using_explicit_abi_is_denied() {\n        assert_ink_chain_extension_eq_err!(\n            error: \"ink! chain extension methods with non default ABI are not supported\",\n            pub trait MyChainExtension {\n                #[ink(extension = 1)]\n                extern fn const_constructor() -> Self;\n            }\n        );\n    }\n\n    #[test]\n    fn chain_extension_containing_variadic_methods_is_denied() {\n        assert_ink_chain_extension_eq_err!(\n            error: \"variadic ink! chain extension methods are not supported\",\n            pub trait MyChainExtension {\n                #[ink(extension = 1)]\n                fn const_constructor(...) -> Self;\n            }\n        );\n    }\n\n    #[test]\n    fn chain_extension_containing_generic_methods_is_denied() {\n        assert_ink_chain_extension_eq_err!(\n            error: \"generic ink! chain extension methods are not supported\",\n            pub trait MyChainExtension {\n                #[ink(extension = 1)]\n                fn const_constructor<T>() -> Self;\n            }\n        );\n    }\n\n    #[test]\n    fn chain_extension_containing_method_with_unsupported_ink_attribute_is_denied() {\n        assert_ink_chain_extension_eq_err!(\n            error: \"\\\n                encountered unsupported ink! attribute for ink! chain extension method. \\\n                expected #[ink(extension = N: u32)] attribute\",\n            pub trait MyChainExtension {\n                #[ink(message)]\n                fn unsupported_ink_attribute(&self);\n            }\n        );\n        assert_ink_chain_extension_eq_err!(\n            error: \"unknown ink! attribute (path)\",\n            pub trait MyChainExtension {\n                #[ink(unknown)]\n                fn unknown_ink_attribute(&self);\n            }\n        );\n    }\n\n    #[test]\n    fn chain_extension_containing_method_with_invalid_marker() {\n        assert_ink_chain_extension_eq_err!(\n            error: \"could not parse `N` in `#[ink(extension = N)]` into a `u32` integer\",\n            pub trait MyChainExtension {\n                #[ink(extension = -1)]\n                fn has_self_receiver();\n            }\n        );\n        let too_large = (u32::MAX as u64) + 1;\n        assert_ink_chain_extension_eq_err!(\n            error: \"could not parse `N` in `#[ink(extension = N)]` into a `u32` integer\",\n            pub trait MyChainExtension {\n                #[ink(extension = #too_large)]\n                fn has_self_receiver();\n            }\n        );\n        assert_ink_chain_extension_eq_err!(\n            error: \"expecteded `u32` integer type for `N` in #[ink(extension = N)]\",\n            pub trait MyChainExtension {\n                #[ink(extension = \"Hello, World!\")]\n                fn has_self_receiver();\n            }\n        );\n        assert_ink_chain_extension_eq_err!(\n            error: \"encountered #[ink(extension)] that is missing its N parameter. Did you mean #[ink(extension = N: u32)] ?\",\n            pub trait MyChainExtension {\n                #[ink(extension)]\n                fn has_self_receiver();\n            }\n        );\n\n        assert_ink_chain_extension_eq_err!(\n            error: \"encountered duplicate ink! attribute\",\n            pub trait MyChainExtension {\n                #[ink(extension = 42)]\n                #[ink(extension = 42)]\n                fn duplicate_attributes() -> Self;\n            }\n        );\n        assert_ink_chain_extension_eq_err!(\n            error: \"encountered ink! attribute arguments with equal kinds\",\n            pub trait MyChainExtension {\n                #[ink(extension = 1)]\n                #[ink(extension = 2)]\n                fn duplicate_attributes() -> Self;\n            }\n        );\n        assert_ink_chain_extension_eq_err!(\n            error: \"encountered conflicting ink! attribute argument\",\n            pub trait MyChainExtension {\n                #[ink(extension = 1)]\n                #[ink(message)]\n                fn conflicting_attributes() -> Self;\n            }\n        );\n    }\n\n    #[test]\n    fn chain_extension_containing_method_with_self_receiver_is_denied() {\n        assert_ink_chain_extension_eq_err!(\n            error: \"ink! chain extension method must not have a `self` receiver\",\n            pub trait MyChainExtension {\n                type ErrorCode = ();\n\n                #[ink(extension = 1)]\n                fn has_self_receiver(&self) -> Self;\n            }\n        );\n        assert_ink_chain_extension_eq_err!(\n            error: \"ink! chain extension method must not have a `self` receiver\",\n            pub trait MyChainExtension {\n                type ErrorCode = ();\n\n                #[ink(extension = 1)]\n                fn has_self_receiver(&mut self) -> Self;\n            }\n        );\n        assert_ink_chain_extension_eq_err!(\n            error: \"ink! chain extension method must not have a `self` receiver\",\n            pub trait MyChainExtension {\n                type ErrorCode = ();\n\n                #[ink(extension = 1)]\n                fn has_self_receiver(self) -> Self;\n            }\n        );\n        assert_ink_chain_extension_eq_err!(\n            error: \"ink! chain extension method must not have a `self` receiver\",\n            pub trait MyChainExtension {\n                type ErrorCode = ();\n\n                #[ink(extension = 1)]\n                fn has_self_receiver(self: &Self) -> Self;\n            }\n        );\n        assert_ink_chain_extension_eq_err!(\n            error: \"ink! chain extension method must not have a `self` receiver\",\n            pub trait MyChainExtension {\n                type ErrorCode = ();\n\n                #[ink(extension = 1)]\n                fn has_self_receiver(self: Self) -> Self;\n            }\n        );\n    }\n\n    #[test]\n    fn chain_extension_with_overlapping_extension_ids() {\n        assert_ink_chain_extension_eq_err!(\n            error: \"encountered duplicate extension identifiers for the same chain extension\",\n            pub trait MyChainExtension {\n                #[ink(extension = 1)]\n                fn same_id_1();\n                #[ink(extension = 1)]\n                fn same_id_2();\n            }\n        );\n    }\n\n    #[test]\n    fn chain_extension_is_ok() {\n        let chain_extension = <ChainExtension as TryFrom<syn::ItemTrait>>::try_from(syn::parse_quote! {\n                pub trait MyChainExtension {\n                    type ErrorCode = ();\n\n                    #[ink(extension = 1)]\n                    fn extension_1();\n                    #[ink(extension = 2)]\n                    fn extension_2(input: i32);\n                    #[ink(extension = 3)]\n                    fn extension_3() -> i32;\n                    #[ink(extension = 4)]\n                    fn extension_4(input: i32) -> i32;\n                    #[ink(extension = 5)]\n                    fn extension_5(in1: i8, in2: i16, in3: i32, in4: i64) -> (u8, u16, u32, u64);\n                }\n            }).unwrap();\n        assert_eq!(chain_extension.methods.len(), 5);\n        for (actual, expected) in chain_extension\n            .methods\n            .iter()\n            .map(|method| method.id())\n            .zip(1..=5u32)\n        {\n            assert_eq!(actual.index, expected);\n        }\n        for (actual, expected) in chain_extension\n            .methods\n            .iter()\n            .map(|method| method.ident().to_string())\n            .zip(\n                [\n                    \"extension_1\",\n                    \"extension_2\",\n                    \"extension_3\",\n                    \"extension_4\",\n                    \"extension_5\",\n                ]\n                .iter()\n                .map(ToString::to_string),\n            )\n        {\n            assert_eq!(actual, expected);\n        }\n    }\n\n    #[test]\n    fn chain_extension_with_params_is_ok() {\n        let chain_extension =\n            <ChainExtension as TryFrom<syn::ItemTrait>>::try_from(syn::parse_quote! {\n                pub trait MyChainExtension {\n                    type ErrorCode = ();\n\n                    #[ink(extension = 1, handle_status = false)]\n                    fn extension_a();\n                    #[ink(extension = 2, returns_result = false)]\n                    fn extension_b();\n                    #[ink(extension = 3, handle_status = false, returns_result = false)]\n                    fn extension_c();\n\n                    #[ink(extension = 4)]\n                    #[ink(handle_status = false)]\n                    fn extension_d();\n                    #[ink(extension = 5)]\n                    #[ink(returns_result = false)]\n                    fn extension_e();\n                    #[ink(extension = 6)]\n                    #[ink(handle_status = false)]\n                    #[ink(returns_result = false)]\n                    fn extension_f();\n                }\n            })\n            .unwrap();\n        let expected_methods = 6;\n        assert_eq!(chain_extension.methods.len(), expected_methods);\n        for (actual, expected) in chain_extension\n            .methods\n            .iter()\n            .map(|method| method.id())\n            .zip(1..=expected_methods as u32)\n        {\n            assert_eq!(actual.index, expected);\n        }\n        for (actual, expected) in chain_extension\n            .methods\n            .iter()\n            .map(|method| method.ident().to_string())\n            .zip(\n                [\n                    \"extension_a\",\n                    \"extension_b\",\n                    \"extension_c\",\n                    \"extension_d\",\n                    \"extension_e\",\n                    \"extension_f\",\n                ]\n                .iter()\n                .map(ToString::to_string),\n            )\n        {\n            assert_eq!(actual, expected);\n        }\n    }\n}\n"],["919","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::{\n    Constructor,\n    Message,\n};\nuse crate::{\n    error::ExtError as _,\n    ir,\n    ir::attrs::Attrs as _,\n};\nuse core::convert::TryFrom;\nuse syn::spanned::Spanned as _;\n\n/// An item within an ink! implementation block.\n///\n/// Can be either\n/// - an ink! [`ir::Constructor`](`crate::ir::Constructor`)\n/// - an ink! [`ir::Message`](`crate::ir::Message`)\n/// - or any other non-ink! item.\n///\n/// # Note\n///\n/// Based on [`syn::ImplItem`] with special variants for ink! impl items.\n#[derive(Debug, PartialEq, Eq)]\n#[allow(clippy::large_enum_variant)]\npub enum ImplItem {\n    /// A `#[ink(constructor)]` marked inherent function.\n    Constructor(Constructor),\n    /// A `#[ink(message)]` marked method.\n    Message(Message),\n    /// Any other implementation block item.\n    Other(syn::ImplItem),\n}\n\nimpl quote::ToTokens for ImplItem {\n    /// We mainly implement this trait for this ink! type to have a derived\n    /// [`Spanned`](`syn::spanned::Spanned`) implementation for it.\n    fn to_tokens(&self, tokens: &mut proc_macro2::TokenStream) {\n        match self {\n            Self::Constructor(constructor) => constructor.to_tokens(tokens),\n            Self::Message(message) => message.to_tokens(tokens),\n            Self::Other(other) => other.to_tokens(tokens),\n        }\n    }\n}\n\nimpl TryFrom<syn::ImplItem> for ImplItem {\n    type Error = syn::Error;\n\n    fn try_from(impl_item: syn::ImplItem) -> Result<Self, Self::Error> {\n        match impl_item {\n            syn::ImplItem::Method(method_item) => {\n                if !ir::contains_ink_attributes(&method_item.attrs) {\n                    return Ok(Self::Other(method_item.into()))\n                }\n                let attr = ir::first_ink_attribute(&method_item.attrs)?\n                    .expect(\"missing expected ink! attribute for struct\");\n                match attr.first().kind() {\n                    ir::AttributeArg::Message => {\n                        <Message as TryFrom<_>>::try_from(method_item)\n                            .map(Into::into)\n                            .map(Self::Message)\n                    }\n                    ir::AttributeArg::Constructor => {\n                        <Constructor as TryFrom<_>>::try_from(method_item)\n                            .map(Into::into)\n                            .map(Self::Constructor)\n                    }\n                    _ => Err(format_err_spanned!(\n                        method_item,\n                        \"encountered invalid ink! attribute at this point, expected either \\\n                        #[ink(message)] or #[ink(constructor) attributes\"\n                    )),\n                }\n            }\n            other_item => {\n                // This is an error if the impl item contains any unexpected\n                // ink! attributes. Otherwise it is a normal Rust item.\n                if ir::contains_ink_attributes(other_item.attrs()) {\n                    let (ink_attrs, _) =\n                        ir::partition_attributes(other_item.attrs().iter().cloned())?;\n                    assert!(!ink_attrs.is_empty());\n                    fn into_err(attr: &ir::InkAttribute) -> syn::Error {\n                        format_err!(attr.span(), \"encountered unexpected ink! attribute\",)\n                    }\n                    return Err(ink_attrs[1..]\n                        .iter()\n                        .map(into_err)\n                        .fold(into_err(&ink_attrs[0]), |fst, snd| fst.into_combine(snd)))\n                }\n                Ok(Self::Other(other_item))\n            }\n        }\n    }\n}\n\nimpl ImplItem {\n    /// Returns `true` if the impl block item is an ink! message.\n    pub fn is_message(&self) -> bool {\n        self.filter_map_message().is_some()\n    }\n\n    /// Returns `Some` if `self` is an ink! message.\n    ///\n    /// Otherwise, returns `None`.\n    pub fn filter_map_message(&self) -> Option<&Message> {\n        match self {\n            ImplItem::Message(message) => Some(message),\n            _ => None,\n        }\n    }\n\n    /// Returns `true` if the impl block item is an ink! message.\n    pub fn is_constructor(&self) -> bool {\n        self.filter_map_constructor().is_some()\n    }\n\n    /// Returns `Some` if `self` is an ink! constructor.\n    ///\n    /// Otherwise, returns `None`.\n    pub fn filter_map_constructor(&self) -> Option<&Constructor> {\n        match self {\n            ImplItem::Constructor(constructor) => Some(constructor),\n            _ => None,\n        }\n    }\n\n    /// Returns `true` if the impl block item is a non ink! specific item.\n    pub fn is_other_item(&self) -> bool {\n        self.filter_map_other_item().is_some()\n    }\n\n    /// Returns `Some` if `self` is a not an ink! specific item.\n    ///\n    /// Otherwise, returns `None`.\n    pub fn filter_map_other_item(&self) -> Option<&syn::ImplItem> {\n        match self {\n            ImplItem::Other(rust_item) => Some(rust_item),\n            _ => None,\n        }\n    }\n}\n"],["920","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::{\n    CallableWithSelector,\n    ImplItem,\n    ItemImpl,\n};\nuse crate::ir;\n\n/// Iterator yielding all ink! constructor within a source ink!\n/// [`ir::ItemImpl`](`crate::ir::ItemImpl`).\npub struct IterConstructors<'a> {\n    item_impl: &'a ir::ItemImpl,\n    impl_items: core::slice::Iter<'a, ImplItem>,\n}\n\nimpl<'a> IterConstructors<'a> {\n    /// Creates a new ink! messages iterator.\n    pub(super) fn new(item_impl: &'a ItemImpl) -> Self {\n        Self {\n            item_impl,\n            impl_items: item_impl.items.iter(),\n        }\n    }\n}\n\nimpl<'a> Iterator for IterConstructors<'a> {\n    type Item = CallableWithSelector<'a, ir::Constructor>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        'repeat: loop {\n            match self.impl_items.next() {\n                None => return None,\n                Some(impl_item) => {\n                    if let Some(constructor) = impl_item.filter_map_constructor() {\n                        return Some(CallableWithSelector::new(\n                            self.item_impl,\n                            constructor,\n                        ))\n                    }\n                    continue 'repeat\n                }\n            }\n        }\n    }\n}\n\n/// Iterator yielding all ink! messages within a source ink!\n/// [`ir::ItemImpl`](`crate::ir::ItemImpl`).\npub struct IterMessages<'a> {\n    item_impl: &'a ir::ItemImpl,\n    impl_items: core::slice::Iter<'a, ImplItem>,\n}\n\nimpl<'a> IterMessages<'a> {\n    /// Creates a new ink! messages iterator.\n    pub(super) fn new(item_impl: &'a ItemImpl) -> Self {\n        Self {\n            item_impl,\n            impl_items: item_impl.items.iter(),\n        }\n    }\n}\n\nimpl<'a> Iterator for IterMessages<'a> {\n    type Item = CallableWithSelector<'a, ir::Message>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        'repeat: loop {\n            match self.impl_items.next() {\n                None => return None,\n                Some(impl_item) => {\n                    if let Some(message) = impl_item.filter_map_message() {\n                        return Some(CallableWithSelector::new(self.item_impl, message))\n                    }\n                    continue 'repeat\n                }\n            }\n        }\n    }\n}\n"],["921","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::{\n    ensure_callable_invariants,\n    Callable,\n    CallableKind,\n    InputsIter,\n    Visibility,\n};\nuse crate::ir;\nuse core::convert::TryFrom;\nuse proc_macro2::{\n    Ident,\n    Span,\n};\nuse syn::spanned::Spanned as _;\n\n/// The receiver of an ink! message.\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\npub enum Receiver {\n    /// The `&self` message receiver.\n    Ref,\n    /// The `&mut self` message receiver.\n    RefMut,\n}\n\nimpl quote::ToTokens for Receiver {\n    fn to_tokens(&self, tokens: &mut proc_macro2::TokenStream) {\n        let receiver = match self {\n            Self::Ref => quote::quote! { &self },\n            Self::RefMut => quote::quote! { &mut self },\n        };\n        tokens.extend(receiver);\n    }\n}\n\nimpl Receiver {\n    /// Returns `true` if the receiver is `&self`.\n    pub fn is_ref(self) -> bool {\n        matches!(self, Self::Ref)\n    }\n\n    /// Returns `true` if the receiver is `&mut self`.\n    pub fn is_ref_mut(self) -> bool {\n        matches!(self, Self::RefMut)\n    }\n}\n\n/// An ink! message definition.\n///\n/// # Example\n///\n/// ## Inherent implementation message:\n///\n/// ```\n/// # use core::convert::TryFrom;\n/// # <ink_lang_ir::ItemImpl as TryFrom<syn::ItemImpl>>::try_from(syn::parse_quote! {\n/// impl MyStorage {\n///     #[ink(message)]\n///     pub fn my_message(&self, input: i32) -> bool {\n///         /* message implementation goes here */\n/// #       unimplemented!()\n///     }\n/// }\n/// # }).unwrap();\n/// ```\n///\n/// ## Trait implementation message:\n///\n/// ```\n/// # use core::convert::TryFrom;\n/// # let event = <ink_lang_ir::ItemImpl as TryFrom<syn::ItemImpl>>::try_from(syn::parse_quote! {\n/// impl MyTrait for MyStorage {\n///     #[ink(message)]\n///     fn my_message(&mut self, input: bool) -> i32 {\n///         /* message implementation goes here */\n/// #       unimplemented!()\n///     }\n/// }\n/// # }).unwrap();\n/// ```\n#[derive(Debug, PartialEq, Eq)]\npub struct Message {\n    /// The underlying Rust method item.\n    pub(super) item: syn::ImplItemMethod,\n    /// If the ink! message can receive funds.\n    is_payable: bool,\n    /// An optional user provided selector.\n    ///\n    /// # Note\n    ///\n    /// This overrides the computed selector, even when using a manual namespace\n    /// for the parent implementation block.\n    selector: Option<ir::Selector>,\n}\n\nimpl quote::ToTokens for Message {\n    /// We mainly implement this trait for this ink! type to have a derived\n    /// [`Spanned`](`syn::spanned::Spanned`) implementation for it.\n    fn to_tokens(&self, tokens: &mut proc_macro2::TokenStream) {\n        self.item.to_tokens(tokens)\n    }\n}\n\nimpl Message {\n    /// Ensures that the given method inputs start with `&self` or `&mut self`\n    /// receivers.\n    ///\n    /// If not an appropriate error is returned.\n    ///\n    /// # Errors\n    ///\n    /// - If the method inputs yields no elements.\n    /// - If the first method input is not `&self` or `&mut self`.\n    fn ensure_receiver_is_self_ref(\n        method_item: &syn::ImplItemMethod,\n    ) -> Result<(), syn::Error> {\n        let mut fn_args = method_item.sig.inputs.iter();\n        fn bail(span: Span) -> syn::Error {\n            format_err!(\n                span,\n                \"ink! messages must have `&self` or `&mut self` receiver\",\n            )\n        }\n        match fn_args.next() {\n            None => return Err(bail(method_item.span())),\n            Some(syn::FnArg::Typed(pat_typed)) => return Err(bail(pat_typed.span())),\n            Some(syn::FnArg::Receiver(receiver)) => {\n                if receiver.reference.is_none() {\n                    return Err(bail(receiver.span()))\n                }\n            }\n        }\n        Ok(())\n    }\n\n    /// Ensures that the ink! message does not return `Self`.\n    ///\n    /// # Errors\n    ///\n    /// If the given Rust method has a `Self` return type.\n    fn ensure_not_return_self(\n        method_item: &syn::ImplItemMethod,\n    ) -> Result<(), syn::Error> {\n        match &method_item.sig.output {\n            syn::ReturnType::Default => (),\n            syn::ReturnType::Type(_arrow, ret_type) => {\n                if let syn::Type::Path(type_path) = &**ret_type {\n                    if type_path.path.is_ident(\"Self\") {\n                        return Err(format_err!(\n                            ret_type,\n                            \"ink! messages must not return `Self`\"\n                        ))\n                    }\n                }\n            }\n        }\n        Ok(())\n    }\n\n    /// Sanitizes the attributes for the ink! message.\n    ///\n    /// Returns a tuple of ink! attributes and non-ink! attributes.\n    fn sanitize_attributes(\n        method_item: &syn::ImplItemMethod,\n    ) -> Result<(ir::InkAttribute, Vec<syn::Attribute>), syn::Error> {\n        ir::sanitize_attributes(\n            method_item.span(),\n            method_item.attrs.clone(),\n            &ir::AttributeArgKind::Message,\n            |arg| {\n                match arg.kind() {\n                    ir::AttributeArg::Message\n                    | ir::AttributeArg::Payable\n                    | ir::AttributeArg::Selector(_) => Ok(()),\n                    _ => Err(None),\n                }\n            },\n        )\n    }\n}\n\nimpl TryFrom<syn::ImplItemMethod> for Message {\n    type Error = syn::Error;\n\n    fn try_from(method_item: syn::ImplItemMethod) -> Result<Self, Self::Error> {\n        ensure_callable_invariants(&method_item, CallableKind::Message)?;\n        Self::ensure_receiver_is_self_ref(&method_item)?;\n        Self::ensure_not_return_self(&method_item)?;\n        let (ink_attrs, other_attrs) = Self::sanitize_attributes(&method_item)?;\n        let is_payable = ink_attrs.is_payable();\n        let selector = ink_attrs.selector();\n        Ok(Self {\n            is_payable,\n            selector,\n            item: syn::ImplItemMethod {\n                attrs: other_attrs,\n                ..method_item\n            },\n        })\n    }\n}\n\nimpl Callable for Message {\n    fn kind(&self) -> CallableKind {\n        CallableKind::Message\n    }\n\n    fn ident(&self) -> &Ident {\n        &self.item.sig.ident\n    }\n\n    fn user_provided_selector(&self) -> Option<&ir::Selector> {\n        self.selector.as_ref()\n    }\n\n    fn is_payable(&self) -> bool {\n        self.is_payable\n    }\n\n    fn visibility(&self) -> Visibility {\n        match &self.item.vis {\n            syn::Visibility::Public(vis_public) => Visibility::Public(vis_public.clone()),\n            syn::Visibility::Inherited => Visibility::Inherited,\n            _ => unreachable!(\"encountered invalid visibility for ink! message\"),\n        }\n    }\n\n    fn inputs(&self) -> InputsIter {\n        InputsIter::from(self)\n    }\n\n    fn inputs_span(&self) -> Span {\n        self.item.sig.inputs.span()\n    }\n\n    fn statements(&self) -> &[syn::Stmt] {\n        &self.item.block.stmts\n    }\n}\n\nimpl Message {\n    /// Returns a slice of all non-ink! attributes of the ink! message.\n    pub fn attrs(&self) -> &[syn::Attribute] {\n        &self.item.attrs\n    }\n\n    /// Returns the `self` receiver of the ink! message.\n    pub fn receiver(&self) -> Receiver {\n        match self.item.sig.inputs.iter().next() {\n            Some(syn::FnArg::Receiver(receiver)) => {\n                debug_assert!(receiver.reference.is_some());\n                if receiver.mutability.is_some() {\n                    Receiver::RefMut\n                } else {\n                    Receiver::Ref\n                }\n            }\n            _ => unreachable!(\"encountered invalid receiver argument for ink! message\"),\n        }\n    }\n\n    /// Returns the return type of the ink! message if any.\n    pub fn output(&self) -> Option<&syn::Type> {\n        match &self.item.sig.output {\n            syn::ReturnType::Default => None,\n            syn::ReturnType::Type(_, return_type) => Some(return_type),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn output_works() {\n        let test_inputs: Vec<(Option<syn::Type>, syn::ImplItemMethod)> = vec![\n            (\n                // No output:\n                None,\n                syn::parse_quote! {\n                    #[ink(message)]\n                    fn my_message(&self) {}\n                },\n            ),\n            (\n                // Single output:\n                Some(syn::parse_quote! { i32 }),\n                syn::parse_quote! {\n                    #[ink(message)]\n                    fn my_message(&self) -> i32 {}\n                },\n            ),\n            (\n                // Tuple output:\n                Some(syn::parse_quote! { (i32, u64, bool) }),\n                syn::parse_quote! {\n                    #[ink(message)]\n                    fn my_message(&self) -> (i32, u64, bool) {}\n                },\n            ),\n        ];\n        for (expected_output, item_method) in test_inputs {\n            let actual_output = <ir::Message as TryFrom<_>>::try_from(item_method)\n                .unwrap()\n                .output()\n                .cloned();\n            assert_eq!(actual_output, expected_output);\n        }\n    }\n\n    #[test]\n    fn inputs_works() {\n        macro_rules! expected_inputs {\n            ( $( $name:ident: $ty:ty ),* ) => {{\n                vec![\n                    $(\n                        syn::parse_quote! {\n                            $name: $ty\n                        }\n                    ),*\n                ]\n            }};\n        }\n        let test_inputs: Vec<(Vec<syn::FnArg>, syn::ImplItemMethod)> = vec![\n            (\n                // No inputs:\n                expected_inputs!(),\n                syn::parse_quote! {\n                    #[ink(message)]\n                    fn my_message(&self) {}\n                },\n            ),\n            (\n                // Single input:\n                expected_inputs!(a: i32),\n                syn::parse_quote! {\n                    #[ink(message)]\n                    fn my_message(&self, a: i32) {}\n                },\n            ),\n            (\n                // Some inputs:\n                expected_inputs!(a: i32, b: u64, c: [u8; 32]),\n                syn::parse_quote! {\n                    #[ink(message)]\n                    fn my_message(&self, a: i32, b: u64, c: [u8; 32]) {}\n                },\n            ),\n        ];\n        for (expected_inputs, item_method) in test_inputs {\n            let actual_inputs = <ir::Message as TryFrom<_>>::try_from(item_method)\n                .unwrap()\n                .inputs()\n                .cloned()\n                .map(|pat_type| syn::FnArg::Typed(pat_type))\n                .collect::<Vec<_>>();\n            assert_eq!(actual_inputs, expected_inputs);\n        }\n    }\n\n    #[test]\n    fn is_payable_works() {\n        let test_inputs: Vec<(bool, syn::ImplItemMethod)> = vec![\n            // Not payable.\n            (\n                false,\n                syn::parse_quote! {\n                    #[ink(message)]\n                    fn my_message(&self) {}\n                },\n            ),\n            // Normalized ink! attribute.\n            (\n                true,\n                syn::parse_quote! {\n                    #[ink(message, payable)]\n                    pub fn my_message(&self) {}\n                },\n            ),\n            // Different ink! attributes.\n            (\n                true,\n                syn::parse_quote! {\n                    #[ink(message)]\n                    #[ink(payable)]\n                    pub fn my_message(&self) {}\n                },\n            ),\n            // Another ink! attribute, separate and normalized attribute.\n            (\n                true,\n                syn::parse_quote! {\n                    #[ink(message)]\n                    #[ink(selector = \"0xDEADBEEF\", payable)]\n                    pub fn my_message(&self) {}\n                },\n            ),\n        ];\n        for (expect_payable, item_method) in test_inputs {\n            let is_payable = <ir::Message as TryFrom<_>>::try_from(item_method)\n                .unwrap()\n                .is_payable();\n            assert_eq!(is_payable, expect_payable);\n        }\n    }\n\n    #[test]\n    fn receiver_works() {\n        let test_inputs: Vec<(Receiver, syn::ImplItemMethod)> = vec![\n            (\n                Receiver::Ref,\n                syn::parse_quote! {\n                    #[ink(message)]\n                    fn my_message(&self) {}\n                },\n            ),\n            (\n                Receiver::RefMut,\n                syn::parse_quote! {\n                    #[ink(message, payable)]\n                    fn my_message(&mut self) {}\n                },\n            ),\n        ];\n        for (expected_receiver, item_method) in test_inputs {\n            let actual_receiver = <ir::Message as TryFrom<_>>::try_from(item_method)\n                .unwrap()\n                .receiver();\n            assert_eq!(actual_receiver, expected_receiver);\n        }\n    }\n\n    #[test]\n    fn visibility_works() {\n        let test_inputs: Vec<(bool, syn::ImplItemMethod)> = vec![\n            // &self\n            (\n                false,\n                syn::parse_quote! {\n                    #[ink(message)]\n                    fn my_message(&self) {}\n                },\n            ),\n            // &self + pub\n            (\n                true,\n                syn::parse_quote! {\n                    #[ink(message)]\n                    pub fn my_message(&self) {}\n                },\n            ),\n            // &mut self\n            (\n                false,\n                syn::parse_quote! {\n                    #[ink(message)]\n                    fn my_message(&mut self) {}\n                },\n            ),\n            // &mut self + pub\n            (\n                true,\n                syn::parse_quote! {\n                    #[ink(message)]\n                    pub fn my_message(&mut self) {}\n                },\n            ),\n        ];\n        for (is_pub, item_method) in test_inputs {\n            let visibility = <ir::Message as TryFrom<_>>::try_from(item_method)\n                .unwrap()\n                .visibility();\n            assert_eq!(visibility.is_pub(), is_pub);\n            assert_eq!(visibility.is_inherited(), !is_pub);\n        }\n    }\n\n    #[test]\n    fn try_from_works() {\n        let item_methods: Vec<syn::ImplItemMethod> = vec![\n            // &self\n            syn::parse_quote! {\n                #[ink(message)]\n                fn my_message(&self) {}\n            },\n            // &self + pub\n            syn::parse_quote! {\n                #[ink(message)]\n                pub fn my_message(&self) {}\n            },\n            // &mut self\n            syn::parse_quote! {\n                #[ink(message)]\n                fn my_message(&mut self) {}\n            },\n            // &mut self + pub\n            syn::parse_quote! {\n                #[ink(message)]\n                pub fn my_message(&mut self) {}\n            },\n            // &self + payable\n            syn::parse_quote! {\n                #[ink(message, payable)]\n                fn my_message(&self) {}\n            },\n            // &mut self + payable\n            syn::parse_quote! {\n                #[ink(message, payable)]\n                fn my_message(&mut self) {}\n            },\n            // &self + many inputs + output works\n            syn::parse_quote! {\n                #[ink(message)]\n                fn my_message(&self, input1: i32, input2: i64, input3: u32, input4: u64) -> bool {}\n            },\n            // &mut self + many inputs + output works\n            syn::parse_quote! {\n                #[ink(message)]\n                fn my_message(&mut self, input1: i32, input2: i64, input3: u32, input4: u64) -> bool {}\n            },\n        ];\n        for item_method in item_methods {\n            assert!(<ir::Message as TryFrom<_>>::try_from(item_method).is_ok());\n        }\n    }\n\n    fn assert_try_from_fails(item_method: syn::ImplItemMethod, expected_err: &str) {\n        assert_eq!(\n            <ir::Message as TryFrom<_>>::try_from(item_method)\n                .map_err(|err| err.to_string()),\n            Err(expected_err.to_string()),\n        );\n    }\n\n    #[test]\n    fn try_from_generics_fails() {\n        let item_methods: Vec<syn::ImplItemMethod> = vec![\n            syn::parse_quote! {\n                #[ink(message)]\n                fn my_message<T>(&self) {}\n            },\n            syn::parse_quote! {\n                #[ink(message)]\n                pub fn my_message<T>(&self) {}\n            },\n            syn::parse_quote! {\n                #[ink(message)]\n                fn my_message<T>(&mut self) {}\n            },\n            syn::parse_quote! {\n                #[ink(message)]\n                pub fn my_message<T>(&mut self) {}\n            },\n        ];\n        for item_method in item_methods {\n            assert_try_from_fails(item_method, \"ink! messages must not be generic\")\n        }\n    }\n\n    #[test]\n    fn try_from_receiver_fails() {\n        let item_methods: Vec<syn::ImplItemMethod> = vec![\n            syn::parse_quote! {\n                #[ink(message)]\n                fn my_message() {}\n            },\n            syn::parse_quote! {\n                #[ink(message)]\n                fn my_message(self) {}\n            },\n            syn::parse_quote! {\n                #[ink(message)]\n                pub fn my_message(mut self) {}\n            },\n            syn::parse_quote! {\n                #[ink(message)]\n                fn my_message(this: &Self) {}\n            },\n            syn::parse_quote! {\n                #[ink(message)]\n                pub fn my_message(this: &mut Self) {}\n            },\n        ];\n        for item_method in item_methods {\n            assert_try_from_fails(\n                item_method,\n                \"ink! messages must have `&self` or `&mut self` receiver\",\n            )\n        }\n    }\n\n    #[test]\n    fn try_from_const_fails() {\n        let item_methods: Vec<syn::ImplItemMethod> = vec![\n            // &self\n            syn::parse_quote! {\n                #[ink(message)]\n                const fn my_message(&self) {}\n            },\n            // &mut self\n            syn::parse_quote! {\n                #[ink(message)]\n                const fn my_message(&mut self) {}\n            },\n        ];\n        for item_method in item_methods {\n            assert_try_from_fails(item_method, \"ink! messages must not be const\")\n        }\n    }\n\n    #[test]\n    fn try_from_async_fails() {\n        let item_methods: Vec<syn::ImplItemMethod> = vec![\n            // &self\n            syn::parse_quote! {\n                #[ink(message)]\n                async fn my_message(&self) {}\n            },\n            // &mut self\n            syn::parse_quote! {\n                #[ink(message)]\n                async fn my_message(&mut self) {}\n            },\n        ];\n        for item_method in item_methods {\n            assert_try_from_fails(item_method, \"ink! messages must not be async\")\n        }\n    }\n\n    #[test]\n    fn try_from_unsafe_fails() {\n        let item_methods: Vec<syn::ImplItemMethod> = vec![\n            // &self\n            syn::parse_quote! {\n                #[ink(message)]\n                unsafe fn my_message(&self) {}\n            },\n            // &mut self\n            syn::parse_quote! {\n                #[ink(message)]\n                unsafe fn my_message(&mut self) {}\n            },\n        ];\n        for item_method in item_methods {\n            assert_try_from_fails(item_method, \"ink! messages must not be unsafe\")\n        }\n    }\n\n    #[test]\n    fn try_from_explicit_abi_fails() {\n        let item_methods: Vec<syn::ImplItemMethod> = vec![\n            // &self\n            syn::parse_quote! {\n                #[ink(message)]\n                extern \"C\" fn my_message(&self) {}\n            },\n            // &mut self\n            syn::parse_quote! {\n                #[ink(message)]\n                extern \"C\" fn my_message(&mut self) {}\n            },\n        ];\n        for item_method in item_methods {\n            assert_try_from_fails(item_method, \"ink! messages must have explicit ABI\")\n        }\n    }\n\n    #[test]\n    fn try_from_variadic_fails() {\n        let item_methods: Vec<syn::ImplItemMethod> = vec![\n            // &self\n            syn::parse_quote! {\n                #[ink(message)]\n                fn my_message(&self, ...) {}\n            },\n            // &mut self\n            syn::parse_quote! {\n                #[ink(message)]\n                fn my_message(&mut self, ...) {}\n            },\n        ];\n        for item_method in item_methods {\n            assert_try_from_fails(item_method, \"ink! messages must not be variadic\")\n        }\n    }\n\n    #[test]\n    fn try_from_visibility_fails() {\n        let item_methods: Vec<syn::ImplItemMethod> = vec![\n            // &self + crate visibility\n            syn::parse_quote! {\n                #[ink(message)]\n                crate fn my_message(&self) {}\n            },\n            // &mut self + crate visibility\n            syn::parse_quote! {\n                #[ink(message)]\n                crate fn my_message(&mut self) {}\n            },\n            // &self + pub restricted visibility\n            syn::parse_quote! {\n                #[ink(message)]\n                pub(in my::path) fn my_message(&self) {}\n            },\n            // &mut self + pub restricted visibility\n            syn::parse_quote! {\n                #[ink(message)]\n                pub(in my::path) fn my_message(&mut self) {}\n            },\n        ];\n        for item_method in item_methods {\n            assert_try_from_fails(\n                item_method,\n                \"ink! messages must have public or inherited visibility\",\n            )\n        }\n    }\n\n    #[test]\n    fn conflicting_attributes_fails() {\n        let item_methods: Vec<syn::ImplItemMethod> = vec![\n            // storage\n            syn::parse_quote! {\n                #[ink(message, storage)]\n                fn my_message(&self) {}\n            },\n            // namespace\n            syn::parse_quote! {\n                #[ink(message, namespace = \"my_namespace\")]\n                fn my_message(&self) {}\n            },\n            // event + multiple attributes\n            syn::parse_quote! {\n                #[ink(message)]\n                #[ink(event)]\n                fn my_message(&self) {}\n            },\n        ];\n        for item_method in item_methods {\n            assert_try_from_fails(\n                item_method,\n                \"encountered conflicting ink! attribute argument\",\n            )\n        }\n    }\n}\n"],["922","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::{\n    error::ExtError as _,\n    ir,\n    ir::attrs::Attrs as _,\n};\nuse core::convert::TryFrom;\nuse proc_macro2::{\n    Ident,\n    Span,\n};\n\nmod callable;\nmod constructor;\nmod impl_item;\nmod iter;\nmod message;\n\n#[cfg(test)]\nmod tests;\n\nuse self::callable::ensure_callable_invariants;\npub use self::{\n    callable::{\n        Callable,\n        CallableKind,\n        CallableWithSelector,\n        InputsIter,\n        Visibility,\n    },\n    constructor::Constructor,\n    impl_item::ImplItem,\n    iter::{\n        IterConstructors,\n        IterMessages,\n    },\n    message::{\n        Message,\n        Receiver,\n    },\n};\nuse quote::TokenStreamExt as _;\nuse syn::spanned::Spanned;\n\n/// An ink! implementation block.\n///\n/// # Note\n///\n/// - This can be either an inherent implementation block that implements some\n///   constructors, messages or internal functions for the storage struct; OR it\n///   can be a trait implementation for the storage struct.\n/// - We try to support all fields that are supported by the underlying `syn`\n///   implementation for [`syn::ItemImpl`] even though they are not really\n///   required to represent ink!. This is done for consistency with `syn`.\n#[derive(Debug, PartialEq, Eq)]\npub struct ItemImpl {\n    attrs: Vec<syn::Attribute>,\n    defaultness: Option<syn::token::Default>,\n    unsafety: Option<syn::token::Unsafe>,\n    impl_token: syn::token::Impl,\n    generics: syn::Generics,\n    trait_: Option<(Option<syn::token::Bang>, syn::Path, syn::token::For)>,\n    self_ty: Box<syn::Type>,\n    brace_token: syn::token::Brace,\n    items: Vec<ImplItem>,\n    /// A namespace to disambiguate trait implementation blocks with equal\n    /// names. Generally can be used to change computation of message and\n    /// constructor selectors of the implementation block.\n    namespace: Option<ir::Namespace>,\n}\n\nimpl quote::ToTokens for ItemImpl {\n    /// We mainly implement this trait for this ink! type to have a derived\n    /// [`Spanned`](`syn::spanned::Spanned`) implementation for it.\n    fn to_tokens(&self, tokens: &mut proc_macro2::TokenStream) {\n        tokens.append_all(\n            self.attrs\n                .iter()\n                .filter(|attr| matches!(attr.style, syn::AttrStyle::Outer)),\n        );\n        self.defaultness.to_tokens(tokens);\n        self.unsafety.to_tokens(tokens);\n        self.impl_token.to_tokens(tokens);\n        self.generics.to_tokens(tokens);\n        if let Some((polarity, path, for_token)) = &self.trait_ {\n            polarity.to_tokens(tokens);\n            path.to_tokens(tokens);\n            for_token.to_tokens(tokens);\n        }\n        self.self_ty.to_tokens(tokens);\n        self.generics.where_clause.to_tokens(tokens);\n        self.brace_token.surround(tokens, |tokens| {\n            tokens.append_all(\n                self.attrs\n                    .iter()\n                    .filter(|attr| matches!(attr.style, syn::AttrStyle::Inner(_))),\n            );\n            tokens.append_all(&self.items);\n        });\n    }\n}\n\nimpl ItemImpl {\n    /// Returns `true` if the Rust implementation block is an ink! implementation\n    /// block.\n    ///\n    /// # Note\n    ///\n    /// This is the case if:\n    ///\n    /// - The ink! implementation block has been annotatated as in:\n    ///\n    /// ```\n    /// # use core::convert::TryFrom;\n    /// # <ink_lang_ir::ItemImpl as TryFrom<syn::ItemImpl>>::try_from(syn::parse_quote! {\n    /// #[ink(impl)]\n    /// impl MyStorage {\n    ///     fn my_function(&self) {\n    ///         /* inherent method implementation */\n    ///         unimplemented!()\n    ///     }\n    /// }\n    /// # }).unwrap();\n    /// ```\n    ///\n    /// - Or if any of the ink! implementation block methods do have ink!\n    ///   specific annotations:\n    ///\n    /// ```\n    /// # use core::convert::TryFrom;\n    /// # <ink_lang_ir::ItemImpl as TryFrom<syn::ItemImpl>>::try_from(syn::parse_quote! {\n    /// impl MyStorage {\n    ///     #[ink(constructor)]\n    ///     pub fn my_constructor() -> Self {\n    ///         /* constructor implementation */\n    ///         unimplemented!()\n    ///     }\n    /// }\n    /// # }).unwrap();\n    /// ```\n    ///\n    /// The same rules apply to ink! trait implementation blocks.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error in case of encountered malformed ink! attributes.\n    pub(super) fn is_ink_impl_block(\n        item_impl: &syn::ItemImpl,\n    ) -> Result<bool, syn::Error> {\n        // Quick check in order to efficiently bail out in case where there are\n        // no ink! attributes:\n        if !ir::contains_ink_attributes(&item_impl.attrs)\n            && item_impl\n                .items\n                .iter()\n                .all(|item| !ir::contains_ink_attributes(item.attrs()))\n        {\n            return Ok(false)\n        }\n        // Check if the implementation block itself has been annotated with\n        // `#[ink(impl)]` and return `true` if this is the case.\n        let (ink_attrs, _) = ir::partition_attributes(item_impl.attrs.clone())?;\n        let impl_block_span = item_impl.span();\n        if !ink_attrs.is_empty() {\n            let normalized =\n                ir::InkAttribute::from_expanded(ink_attrs).map_err(|err| {\n                    err.into_combine(format_err!(impl_block_span, \"at this invocation\",))\n                })?;\n            if normalized\n                .ensure_first(&ir::AttributeArgKind::Implementation)\n                .is_ok()\n            {\n                return Ok(true)\n            }\n        }\n        // Check if any of the implementation block's methods either resembles\n        // an ink! constructor or an ink! message:\n        'repeat: for item in &item_impl.items {\n            match item {\n                syn::ImplItem::Method(method_item) => {\n                    if !ir::contains_ink_attributes(&method_item.attrs) {\n                        continue 'repeat\n                    }\n                    let attr = ir::first_ink_attribute(&method_item.attrs)?\n                        .expect(\"missing expected ink! attribute for struct\");\n                    match attr.first().kind() {\n                        ir::AttributeArg::Constructor | ir::AttributeArg::Message => {\n                            return Ok(true)\n                        }\n                        _ => continue 'repeat,\n                    }\n                }\n                _ => continue 'repeat,\n            }\n        }\n        Ok(false)\n    }\n}\n\nimpl TryFrom<syn::ItemImpl> for ItemImpl {\n    type Error = syn::Error;\n\n    fn try_from(item_impl: syn::ItemImpl) -> Result<Self, Self::Error> {\n        let impl_block_span = item_impl.span();\n        if !Self::is_ink_impl_block(&item_impl)? {\n            return Err(format_err_spanned!(\n                item_impl,\n                \"missing ink! annotations on the impl block or on any of its items\"\n            ))\n        }\n        if let Some(defaultness) = item_impl.defaultness {\n            return Err(format_err_spanned!(\n                defaultness,\n                \"default implementations are unsupported for ink! implementation blocks\",\n            ))\n        }\n        if let Some(unsafety) = item_impl.unsafety {\n            return Err(format_err_spanned!(\n                unsafety,\n                \"unsafe ink! implementation blocks are not supported\",\n            ))\n        }\n        if !item_impl.generics.params.is_empty() {\n            return Err(format_err_spanned!(\n                item_impl.generics.params,\n                \"generic ink! implementation blocks are not supported\",\n            ))\n        }\n        let impl_items = item_impl\n            .items\n            .into_iter()\n            .map(<ImplItem as TryFrom<_>>::try_from)\n            .collect::<Result<Vec<_>, syn::Error>>()?;\n        let is_trait_impl = item_impl.trait_.is_some();\n        for impl_item in &impl_items {\n            /// Ensures that visibility of ink! messages and constructors is\n            /// valid in dependency of the containing ink! impl block.\n            ///\n            /// # Note\n            ///\n            /// Trait implementation blocks expect inherited visibility\n            /// while inherent implementation block expect public visibility.\n            fn ensure_valid_visibility(\n                vis: ir::Visibility,\n                span: Span,\n                what: &str,\n                is_trait_impl: bool,\n            ) -> Result<(), syn::Error> {\n                let requires_pub = !is_trait_impl;\n                if requires_pub != vis.is_pub() {\n                    return Err(format_err!(\n                        span,\n                        \"ink! {} in {} impl blocks must have {} visibility\",\n                        what,\n                        if is_trait_impl { \"trait\" } else { \"inherent\" },\n                        if requires_pub { \"public\" } else { \"inherited\" },\n                    ))\n                }\n                Ok(())\n            }\n            match impl_item {\n                ir::ImplItem::Message(message) => {\n                    ensure_valid_visibility(\n                        message.visibility(),\n                        message.item.span(),\n                        \"message\",\n                        is_trait_impl,\n                    )?;\n                }\n                ir::ImplItem::Constructor(constructor) => {\n                    ensure_valid_visibility(\n                        constructor.visibility(),\n                        constructor.item.span(),\n                        \"constructor\",\n                        is_trait_impl,\n                    )?;\n                }\n                _ => (),\n            }\n        }\n        let (ink_attrs, other_attrs) = ir::partition_attributes(item_impl.attrs)?;\n        let mut namespace = None;\n        if !ink_attrs.is_empty() {\n            let normalized =\n                ir::InkAttribute::from_expanded(ink_attrs).map_err(|err| {\n                    err.into_combine(format_err!(impl_block_span, \"at this invocation\",))\n                })?;\n            normalized.ensure_no_conflicts(|arg| {\n                match arg.kind() {\n                    ir::AttributeArg::Implementation | ir::AttributeArg::Namespace(_) => {\n                        Ok(())\n                    }\n                    _ => Err(None),\n                }\n            })?;\n            namespace = normalized.namespace();\n        }\n        Ok(Self {\n            attrs: other_attrs,\n            defaultness: item_impl.defaultness,\n            unsafety: item_impl.unsafety,\n            impl_token: item_impl.impl_token,\n            generics: item_impl.generics,\n            trait_: item_impl.trait_,\n            self_ty: item_impl.self_ty,\n            brace_token: item_impl.brace_token,\n            items: impl_items,\n            namespace,\n        })\n    }\n}\n\nimpl ItemImpl {\n    /// Returns all non-ink! specific attributes of the implementation block.\n    pub fn attrs(&self) -> &[syn::Attribute] {\n        &self.attrs\n    }\n\n    /// Returns the `Self` type of the implementation block.\n    pub fn self_type(&self) -> &syn::Type {\n        self.self_ty.as_ref()\n    }\n\n    /// Returns the trait type path if this is a trait implementation block.\n    ///\n    /// Returns `None` if this is an inherent implementation block.\n    pub fn trait_path(&self) -> Option<&syn::Path> {\n        self.trait_.as_ref().map(|(_, path, _)| path)\n    }\n\n    /// Returns the trait identifier if this is a trait implementation block.\n    ///\n    /// Returns `None` if this is an inherent implementation block.\n    pub fn trait_ident(&self) -> Option<&Ident> {\n        self.trait_path()\n            .map(|trait_path| trait_path.segments.last())\n            .flatten()\n            .map(|segment| &segment.ident)\n    }\n\n    /// Returns the namespace of the implementation block if any has been provided.\n    pub fn namespace(&self) -> Option<&ir::Namespace> {\n        self.namespace.as_ref()\n    }\n\n    /// Returns an iterator yielding the ink! messages of the implementation block.\n    pub fn iter_messages(&self) -> IterMessages {\n        IterMessages::new(self)\n    }\n\n    /// Returns an iterator yielding the ink! messages of the implementation block.\n    pub fn iter_constructors(&self) -> IterConstructors {\n        IterConstructors::new(self)\n    }\n\n    /// Returns a slice over the shared references of the items of the impl.\n    pub fn items(&self) -> &[ir::ImplItem] {\n        &self.items\n    }\n}\n"],["923","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Utilities and helper routines that are useful for both ink! messages\n//! and ink! constructors.\n\nuse crate::ir;\nuse core::fmt;\nuse proc_macro2::{\n    Ident,\n    Span,\n};\nuse quote::ToTokens as _;\nuse syn::spanned::Spanned as _;\n\n/// The kind of externally callable smart contract entity.\n#[derive(Debug, Copy, Clone)]\npub enum CallableKind {\n    /// An ink! message externally callable.\n    Message,\n    /// An ink! constructor externally callable.\n    Constructor,\n}\n\nimpl fmt::Display for CallableKind {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::Message => write!(f, \"message\"),\n            Self::Constructor => write!(f, \"constructor\"),\n        }\n    }\n}\n\n/// Wrapper for a callable that adds its composed selector.\n#[derive(Debug)]\npub struct CallableWithSelector<'a, C> {\n    /// The composed selector computed by the associated implementation block\n    /// and the given callable.\n    composed_selector: ir::Selector,\n    /// The parent implementation block.\n    item_impl: &'a ir::ItemImpl,\n    /// The actual callable.\n    callable: &'a C,\n}\n\nimpl<C> Copy for CallableWithSelector<'_, C> {}\nimpl<C> Clone for CallableWithSelector<'_, C> {\n    fn clone(&self) -> Self {\n        Self {\n            composed_selector: self.composed_selector,\n            item_impl: self.item_impl,\n            callable: self.callable,\n        }\n    }\n}\n\nimpl<'a, C> CallableWithSelector<'a, C>\nwhere\n    C: Callable,\n{\n    /// Creates a new wrapper around the given callable and parent impl block.\n    pub(super) fn new(item_impl: &'a ir::ItemImpl, callable: &'a C) -> Self {\n        Self {\n            composed_selector: compose_selector(item_impl, callable),\n            item_impl,\n            callable,\n        }\n    }\n}\n\nimpl<'a, C> CallableWithSelector<'a, C> {\n    /// Returns the composed selector of the ink! callable the the impl block.\n    pub fn composed_selector(&self) -> ir::Selector {\n        self.composed_selector\n    }\n\n    /// Returns a shared reference to the underlying callable.\n    pub fn callable(&self) -> &'a C {\n        self.callable\n    }\n\n    /// Returns the parent implementation block of the ink! callable.\n    pub fn item_impl(&self) -> &'a ir::ItemImpl {\n        self.item_impl\n    }\n}\n\nimpl<'a, C> Callable for CallableWithSelector<'a, C>\nwhere\n    C: Callable,\n{\n    fn kind(&self) -> CallableKind {\n        <C as Callable>::kind(&self.callable)\n    }\n\n    fn ident(&self) -> &Ident {\n        <C as Callable>::ident(&self.callable)\n    }\n\n    fn user_provided_selector(&self) -> Option<&ir::Selector> {\n        <C as Callable>::user_provided_selector(&self.callable)\n    }\n\n    fn is_payable(&self) -> bool {\n        <C as Callable>::is_payable(&self.callable)\n    }\n\n    fn visibility(&self) -> Visibility {\n        <C as Callable>::visibility(&self.callable)\n    }\n\n    fn inputs(&self) -> InputsIter {\n        <C as Callable>::inputs(&self.callable)\n    }\n\n    fn inputs_span(&self) -> Span {\n        <C as Callable>::inputs_span(&self.callable)\n    }\n\n    fn statements(&self) -> &[syn::Stmt] {\n        <C as Callable>::statements(&self.callable)\n    }\n}\n\nimpl<'a, C> ::core::ops::Deref for CallableWithSelector<'a, C> {\n    type Target = C;\n\n    fn deref(&self) -> &Self::Target {\n        &self.callable\n    }\n}\n\n/// An ink! callable.\n///\n/// This is either an ink! message or an ink! constructor.\n/// Used to share common behavior between different callable types.\npub trait Callable {\n    /// Returns the kind of the ink! callable.\n    fn kind(&self) -> CallableKind;\n\n    /// Returns the identifier of the ink! callable.\n    fn ident(&self) -> &Ident;\n\n    /// Returns the selector of the ink! callable if any has been manually set.\n    fn user_provided_selector(&self) -> Option<&ir::Selector>;\n\n    /// Returns `true` if the ink! callable is flagged as payable.\n    ///\n    /// # Note\n    ///\n    /// Flagging as payable is done using the `#[ink(payable)]` attribute.\n    fn is_payable(&self) -> bool;\n\n    /// Returns the visibility of the ink! callable.\n    fn visibility(&self) -> Visibility;\n\n    /// Returns an iterator yielding all input parameters of the ink! callable.\n    fn inputs(&self) -> InputsIter;\n\n    /// Returns the span of the inputs of the ink! callable.\n    fn inputs_span(&self) -> Span;\n\n    /// Returns a slice over shared references to the statements of the callable.\n    fn statements(&self) -> &[syn::Stmt];\n}\n\n/// Returns the composed selector of the ink! callable.\n///\n/// Composition takes into account the given [`ir::ItemImpl`].\n///\n/// # Details\n///\n/// Given\n/// - the callable's identifier `i`\n/// - the optionally set callable's selector `s`\n/// - the impl blocks trait path in case it implements a trait, `P`\n/// - the impl blocks optional user provided namespace `S`\n///\n/// Then the selector is composed in the following way:\n///\n/// - If `s` is given we simply return `s`.\n/// - Otherwise if `T` is not `None` (trait impl block) we concatenate\n///   `S`, `T` and `i` with `::` as separator if `T` refers to a full-path.\n///   If `T` refers to a relative path or is just an identifier we only take\n///   its last segment `p` (e.g. the trait's identifier) into consideration\n///   and use it instead of `P` in the above concatenation.\n///   In the following we refer to the resulting concatenation as `C`.\n/// - Now we take the BLAKE-2 hash of `C` which results in 32 bytes of output\n///   and take the first 4 bytes that are returned in order as the composed\n///   selector.\n///\n/// # Examples\n///\n/// ## Overriding the composed selector\n///\n/// Given\n///\n/// ```no_compile\n/// impl MyStorage {\n///     #[ink(message, selector = \"0xDEADBEEF\")]\n///     fn my_message(&self) {}\n/// }\n/// ```\n///\n/// ... then the selector of `my_message` is simply `0xDEADBEEF` since it overrides\n/// the composed selector.\n///\n/// ## Inherent implementation block\n///\n/// Given\n///\n/// ```no_compile\n/// impl MyStorage {\n///     #[ink(message)]\n///     fn my_message(&self) {}\n/// }\n/// ```\n///\n/// ... then the selector of `my_message` is composed such as:\n/// ```no_compile\n/// BLAKE2(\"my_message\".to_string().as_bytes())[0..4]\n/// ```\n///\n/// ## Trait implementation block\n///\n/// Given\n///\n/// ```no_compile\n/// impl MyTrait for MyStorage {\n///     #[ink(message)]\n///     fn my_message(&self) {}\n/// }\n/// ```\n///\n/// ... then the selector of `my_message` is composed such as:\n/// ```no_compile\n/// BLAKE2(\"MyTrait::my_message\".to_string().as_bytes())[0..4]\n/// ```\n///\n/// ## Using full path for trait\n///\n/// Given\n///\n/// ```no_compile\n/// impl ::my_full::long_path::MyTrait for MyStorage {\n///     #[ink(message)]\n///     fn my_message(&self) {}\n/// }\n/// ```\n///\n/// ... then the selector of `my_message` is composed such as:\n/// ```no_compile\n/// BLAKE2(\"::my_full::long_path::MyTrait::my_message\".to_string().as_bytes())[0..4]\n/// ```\n///\n/// ## Using a namespace\n///\n/// Given\n///\n/// ```no_compile\n/// #[ink(namespace = \"my_namespace\")]\n/// impl MyTrait for MyStorage {\n///     #[ink(message)]\n///     fn my_message(&self) {}\n/// }\n/// ```\n///\n/// ... then the selector of `my_message` is composed such as:\n/// ```no_compile\n/// BLAKE2(\"my_namespace::MyTrait::my_message\".to_string().as_bytes())[0..4]\n/// ```\n///\n/// ## Note\n///\n/// All above examples work similarly for ink! constructors interchangeably.\n///\n/// ## Usage Recommendations\n///\n/// These recommendation mainly apply to trait implementation blocks:\n///\n/// - The recommendation by the ink! team is to use the full-path approach\n/// wherever possible; OR import the trait and use only its identifier with\n/// an additional namespace if required to disambiguate selectors.\n/// - Try not to intermix the above recommendations.\n/// - Avoid directly setting the selector of an ink! message or constuctor.\n///   Only do this if nothing else helps and you need a very specific selector,\n///   e.g. in case of backwards compatibility.\n/// - Do not use the namespace unless required to disambiguate.\npub fn compose_selector<C>(item_impl: &ir::ItemImpl, callable: &C) -> ir::Selector\nwhere\n    C: Callable,\n{\n    if let Some(selector) = callable.user_provided_selector() {\n        return *selector\n    }\n    let callable_ident = callable.ident().to_string().into_bytes();\n    let namespace_bytes = item_impl\n        .namespace()\n        .map(|namespace| namespace.as_bytes().to_vec())\n        .unwrap_or_default();\n    let separator = &b\"::\"[..];\n    let joined = match item_impl.trait_path() {\n        None => {\n            // Inherent implementation block:\n            if namespace_bytes.is_empty() {\n                callable_ident\n            } else {\n                [namespace_bytes, callable_ident].join(separator)\n            }\n        }\n        Some(path) => {\n            // Trait implementation block:\n            //\n            // We need to separate between full-path, e.g. `::my::full::Path`\n            // starting with `::` and relative paths for the composition.\n            let path_bytes = if path.leading_colon.is_some() {\n                let mut str_repr = path.to_token_stream().to_string();\n                str_repr.retain(|c| !c.is_whitespace());\n                str_repr.into_bytes()\n            } else {\n                path.segments\n                    .last()\n                    .expect(\"encountered empty trait path\")\n                    .ident\n                    .to_string()\n                    .into_bytes()\n            };\n            if namespace_bytes.is_empty() {\n                [path_bytes, callable_ident].join(separator)\n            } else {\n                [namespace_bytes, path_bytes, callable_ident].join(separator)\n            }\n        }\n    };\n    ir::Selector::new(&joined)\n}\n\n/// Ensures that common invariants of externally callable ink! entities are met.\n///\n/// # Errors\n///\n/// In case any of the common externally callable invariants are not met:\n/// - This is `true` if the externally callable is:\n///  - generic\n///  - const (compile-time evaluatable)\n///  - async (async WebAssembly smart contract calling is not allowed)\n///  - unsafe (caller provided assertions not yet stable)\n/// - Furthermore this is `true` if the externally callable is defined for a\n///   non default ABI (e.g. `extern \"C\"`) or doesn't have valid visibility.\npub(super) fn ensure_callable_invariants(\n    method_item: &syn::ImplItemMethod,\n    kind: CallableKind,\n) -> Result<(), syn::Error> {\n    let bad_visibility = match &method_item.vis {\n        syn::Visibility::Inherited => None,\n        syn::Visibility::Restricted(vis_restricted) => Some(vis_restricted.span()),\n        syn::Visibility::Crate(vis_crate) => Some(vis_crate.span()),\n        syn::Visibility::Public(_) => None,\n    };\n    if let Some(bad_visibility) = bad_visibility {\n        return Err(format_err!(\n            bad_visibility,\n            \"ink! {}s must have public or inherited visibility\",\n            kind\n        ))\n    }\n    if !method_item.sig.generics.params.is_empty() {\n        return Err(format_err_spanned!(\n            method_item.sig.generics.params,\n            \"ink! {}s must not be generic\",\n            kind,\n        ))\n    }\n    if method_item.sig.constness.is_some() {\n        return Err(format_err_spanned!(\n            method_item.sig.constness,\n            \"ink! {}s must not be const\",\n            kind,\n        ))\n    }\n    if method_item.sig.asyncness.is_some() {\n        return Err(format_err_spanned!(\n            method_item.sig.asyncness,\n            \"ink! {}s must not be async\",\n            kind,\n        ))\n    }\n    if method_item.sig.unsafety.is_some() {\n        return Err(format_err_spanned!(\n            method_item.sig.unsafety,\n            \"ink! {}s must not be unsafe\",\n            kind,\n        ))\n    }\n    if method_item.sig.abi.is_some() {\n        return Err(format_err_spanned!(\n            method_item.sig.abi,\n            \"ink! {}s must have explicit ABI\",\n            kind,\n        ))\n    }\n    if method_item.sig.variadic.is_some() {\n        return Err(format_err_spanned!(\n            method_item.sig.variadic,\n            \"ink! {}s must not be variadic\",\n            kind,\n        ))\n    }\n    Ok(())\n}\n\n/// The visibility of an ink! message or constructor.\n#[derive(Debug, Clone)]\npub enum Visibility {\n    Public(syn::VisPublic),\n    Inherited,\n}\n\nimpl Visibility {\n    /// Returns `true` if the visibility of the ink! message of constructor is public (`pub`).\n    ///\n    /// # Note\n    ///\n    /// Messages in normal implementation blocks must have public visibility.\n    pub fn is_pub(&self) -> bool {\n        matches!(self, Self::Public(_))\n    }\n\n    /// Returns `true` if the visibility of the ink! message of constructor is inherited.\n    ///\n    /// # Note\n    ///\n    /// Messages in trait implementation blocks must have inherited visibility.\n    pub fn is_inherited(&self) -> bool {\n        matches!(self, Self::Inherited)\n    }\n\n    /// Returns the associated span if any.\n    pub fn span(&self) -> Option<Span> {\n        match self {\n            Self::Public(vis_public) => Some(vis_public.span()),\n            Self::Inherited => None,\n        }\n    }\n}\n\n/// Iterator over the input parameters of an ink! message or constructor.\n///\n/// Does not yield the self receiver of ink! messages.\npub struct InputsIter<'a> {\n    iter: syn::punctuated::Iter<'a, syn::FnArg>,\n}\n\nimpl<'a> From<&'a ir::Message> for InputsIter<'a> {\n    fn from(message: &'a ir::Message) -> Self {\n        Self {\n            iter: message.item.sig.inputs.iter(),\n        }\n    }\n}\n\nimpl<'a> From<&'a ir::Constructor> for InputsIter<'a> {\n    fn from(constructor: &'a ir::Constructor) -> Self {\n        Self {\n            iter: constructor.item.sig.inputs.iter(),\n        }\n    }\n}\n\nimpl<'a> Iterator for InputsIter<'a> {\n    type Item = &'a syn::PatType;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        'repeat: loop {\n            match self.iter.next() {\n                None => return None,\n                Some(syn::FnArg::Typed(pat_typed)) => return Some(pat_typed),\n                Some(syn::FnArg::Receiver(_)) => continue 'repeat,\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::{\n        convert::TryFrom,\n        fmt::Debug,\n    };\n\n    pub enum ExpectedSelector {\n        Raw([u8; 4]),\n        Blake2(Vec<u8>),\n    }\n\n    impl From<[u8; 4]> for ExpectedSelector {\n        fn from(raw_selector: [u8; 4]) -> Self {\n            ExpectedSelector::Raw(raw_selector)\n        }\n    }\n\n    impl From<Vec<u8>> for ExpectedSelector {\n        fn from(blake2_input: Vec<u8>) -> Self {\n            ExpectedSelector::Blake2(blake2_input)\n        }\n    }\n\n    impl ExpectedSelector {\n        pub fn expected_selector(self) -> ir::Selector {\n            match self {\n                Self::Raw(raw_selector) => ir::Selector::from_bytes(raw_selector),\n                Self::Blake2(blake2_input) => ir::Selector::new(&blake2_input),\n            }\n        }\n    }\n\n    /// Asserts that the given ink! implementation block and the given ink!\n    /// message result in the same composed selector as the expected bytes.\n    fn assert_compose_selector<C, S>(\n        item_impl: syn::ItemImpl,\n        item_method: syn::ImplItemMethod,\n        expected_selector: S,\n    ) where\n        C: Callable + TryFrom<syn::ImplItemMethod>,\n        <C as TryFrom<syn::ImplItemMethod>>::Error: Debug,\n        S: Into<ExpectedSelector>,\n    {\n        assert_eq!(\n            compose_selector(\n                &<ir::ItemImpl as TryFrom<syn::ItemImpl>>::try_from(item_impl).unwrap(),\n                &<C as TryFrom<syn::ImplItemMethod>>::try_from(item_method).unwrap(),\n            ),\n            expected_selector.into().expected_selector(),\n        )\n    }\n\n    #[test]\n    fn compose_selector_works() {\n        assert_compose_selector::<ir::Message, _>(\n            syn::parse_quote! {\n                #[ink(impl)]\n                impl MyStorage {}\n            },\n            syn::parse_quote! {\n                #[ink(message)]\n                fn my_message(&self) {}\n            },\n            b\"my_message\".to_vec(),\n        );\n        assert_compose_selector::<ir::Message, _>(\n            syn::parse_quote! {\n                #[ink(impl)]\n                impl MyTrait for MyStorage {}\n            },\n            syn::parse_quote! {\n                #[ink(message)]\n                fn my_message(&self) {}\n            },\n            b\"MyTrait::my_message\".to_vec(),\n        );\n        assert_compose_selector::<ir::Message, _>(\n            syn::parse_quote! {\n                #[ink(impl)]\n                impl ::my::full::path::MyTrait for MyStorage {}\n            },\n            syn::parse_quote! {\n                #[ink(message)]\n                fn my_message(&self) {}\n            },\n            b\"::my::full::path::MyTrait::my_message\".to_vec(),\n        );\n        assert_compose_selector::<ir::Message, _>(\n            syn::parse_quote! {\n                #[ink(impl, namespace = \"my_namespace\")]\n                impl MyTrait for MyStorage {}\n            },\n            syn::parse_quote! {\n                #[ink(message)]\n                fn my_message(&self) {}\n            },\n            b\"my_namespace::MyTrait::my_message\".to_vec(),\n        );\n        assert_compose_selector::<ir::Message, _>(\n            syn::parse_quote! {\n                #[ink(impl)]\n                impl MyTrait for MyStorage {}\n            },\n            syn::parse_quote! {\n                #[ink(message, selector = \"0xDEADBEEF\")]\n                fn my_message(&self) {}\n            },\n            [0xDE, 0xAD, 0xBE, 0xEF],\n        );\n        assert_compose_selector::<ir::Message, _>(\n            syn::parse_quote! {\n                #[ink(impl)]\n                impl relative::path_to::MyTrait for MyStorage {}\n            },\n            syn::parse_quote! {\n                #[ink(message)]\n                fn my_message(&self) {}\n            },\n            b\"MyTrait::my_message\".to_vec(),\n        );\n    }\n}\n"],["924","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::ir;\nuse core::convert::TryFrom;\n\n#[test]\nfn is_ink_impl_block_eval_false_works() {\n    let item_impls: Vec<syn::ItemImpl> = vec![\n        syn::parse_quote! {\n            impl MyStorage {}\n        },\n        syn::parse_quote! {\n            impl MyTrait for MyStorage {}\n        },\n    ];\n    for item_impl in &item_impls {\n        assert_eq!(\n            ir::ItemImpl::is_ink_impl_block(item_impl).map_err(|err| err.to_string()),\n            Ok(false),\n        )\n    }\n}\n\n#[test]\nfn is_ink_impl_block_eval_true_works() {\n    let item_impls: Vec<syn::ItemImpl> = vec![\n        syn::parse_quote! {\n            #[ink(impl)]\n            impl MyStorage {}\n        },\n        syn::parse_quote! {\n            impl MyStorage {\n                #[ink(constructor)]\n                fn my_constructor() -> Self {}\n            }\n        },\n        syn::parse_quote! {\n            impl MyStorage {\n                #[ink(message)]\n                fn my_message(&self) {}\n            }\n        },\n        syn::parse_quote! {\n            #[ink(impl)]\n            impl MyTrait for MyStorage {}\n        },\n        syn::parse_quote! {\n            impl MyTrait for MyStorage {\n                #[ink(message)]\n                fn my_message(&self) {}\n            }\n        },\n        syn::parse_quote! {\n            #[ink(impl)]\n            impl MyStorage {\n                #[ink(constructor)]\n                fn my_constructor() -> Self {}\n                #[ink(message)]\n                fn my_message(&self) {}\n            }\n        },\n        syn::parse_quote! {\n            #[ink(impl)]\n            impl MyTrait for MyStorage {\n                #[ink(constructor)]\n                fn my_constructor() -> Self {}\n                #[ink(message)]\n                fn my_message(&self) {}\n            }\n        },\n        syn::parse_quote! {\n            // This is actually invalid but the function under test will\n            // still determine this to be a valid ink! implementation block.\n            #[ink(impl)]\n            impl MyStorage {\n                #[ink(..)]\n                fn invalid_ink_attribute(&self) {}\n            }\n        },\n    ];\n    for item_impl in &item_impls {\n        assert_eq!(\n            ir::ItemImpl::is_ink_impl_block(item_impl).map_err(|err| err.to_string()),\n            Ok(true),\n        )\n    }\n}\n\nfn assert_is_ink_impl_block_fails(impl_block: &syn::ItemImpl, expected: &str) {\n    assert_eq!(\n        ir::ItemImpl::is_ink_impl_block(impl_block).map_err(|err| err.to_string()),\n        Err(expected.to_string())\n    )\n}\n\n#[test]\nfn is_ink_impl_block_fails() {\n    assert_is_ink_impl_block_fails(\n        &syn::parse_quote! {\n            #[ink(invalid)]\n            impl MyStorage {}\n        },\n        \"unknown ink! attribute (path)\",\n    );\n    assert_is_ink_impl_block_fails(\n        &syn::parse_quote! {\n            #[ink(invalid)]\n            impl MyTrait for MyStorage {}\n        },\n        \"unknown ink! attribute (path)\",\n    );\n    assert_is_ink_impl_block_fails(\n        &syn::parse_quote! {\n            #[ink(impl)]\n            #[ink(impl)]\n            impl MyStorage {}\n        },\n        \"encountered duplicate ink! attribute\",\n    );\n    assert_is_ink_impl_block_fails(\n        &syn::parse_quote! {\n            #[ink(impl)]\n            #[ink(impl)]\n            impl MyTrait for MyStorage {}\n        },\n        \"encountered duplicate ink! attribute\",\n    );\n    assert_is_ink_impl_block_fails(\n        &syn::parse_quote! {\n            impl MyStorage {\n                #[ink(invalid)]\n                fn invalid_fn_attr(&self) {}\n            }\n        },\n        \"unknown ink! attribute (path)\",\n    );\n    assert_is_ink_impl_block_fails(\n        &syn::parse_quote! {\n            impl MyTrait for MyStorage {\n                #[ink(invalid)]\n                fn invalid_fn_attr(&self) {}\n            }\n        },\n        \"unknown ink! attribute (path)\",\n    );\n}\n\n/// Asserts that the `TryFrom` application on the given [`syn::ItemImpl`]\n/// fails with the expected error message.\nfn assert_try_from_item_impl_fails(item_impl: syn::ItemImpl, expected_err: &str) {\n    assert_eq!(\n        <ir::ItemImpl as TryFrom<syn::ItemImpl>>::try_from(item_impl)\n            .map_err(|err| err.to_string()),\n        Err(expected_err.to_string())\n    )\n}\n\n#[test]\nfn visibility_fails() {\n    assert_try_from_item_impl_fails(\n        syn::parse_quote! {\n            impl MyStorage {\n                #[ink(message)]\n                fn my_private_message(&self) {}\n            }\n        },\n        \"ink! message in inherent impl blocks must have public visibility\",\n    );\n    assert_try_from_item_impl_fails(\n        syn::parse_quote! {\n            impl MyStorage {\n                #[ink(constructor)]\n                fn my_private_constructor() -> Self {}\n            }\n        },\n        \"ink! constructor in inherent impl blocks must have public visibility\",\n    );\n    assert_try_from_item_impl_fails(\n        syn::parse_quote! {\n            impl MyTrait for MyStorage {\n                #[ink(message)]\n                pub fn my_public_message(&self) {}\n            }\n        },\n        \"ink! message in trait impl blocks must have inherited visibility\",\n    );\n    assert_try_from_item_impl_fails(\n        syn::parse_quote! {\n            impl MyTrait for MyStorage {\n                #[ink(constructor)]\n                pub fn my_public_constructor() -> Self {}\n            }\n        },\n        \"ink! constructor in trait impl blocks must have inherited visibility\",\n    );\n}\n\n#[test]\nfn try_from_works() {\n    let item_impls: Vec<syn::ItemImpl> = vec![\n        syn::parse_quote! {\n            #[ink(impl)]\n            impl MyStorage {}\n        },\n        syn::parse_quote! {\n            impl MyStorage {\n                #[ink(message)]\n                pub fn my_message(&self) {}\n            }\n        },\n        syn::parse_quote! {\n            #[ink(impl)]\n            impl MyTrait for MyStorage {}\n        },\n        syn::parse_quote! {\n            impl MyTrait for MyStorage {\n                #[ink(message)]\n                fn my_message(&self) {}\n            }\n        },\n    ];\n    for item_impl in item_impls {\n        assert!(<ir::ItemImpl as TryFrom<syn::ItemImpl>>::try_from(item_impl).is_ok())\n    }\n}\n\n#[test]\nfn namespace_works() {\n    let impl_block: ir::ItemImpl =\n        <ir::ItemImpl as TryFrom<syn::ItemImpl>>::try_from(syn::parse_quote! {\n            #[ink(namespace = \"my_namespace\")]\n            impl MyStorage {\n                #[ink(message)]\n                pub fn my_message(&self) {}\n            }\n        })\n        .unwrap();\n    assert_eq!(\n        impl_block.namespace,\n        Some(ir::Namespace::from(\n            \"my_namespace\".to_string().as_bytes().to_vec()\n        ))\n    )\n}\n"],["925","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::{\n    ensure_callable_invariants,\n    Callable,\n    CallableKind,\n    InputsIter,\n    Visibility,\n};\nuse crate::ir;\nuse core::convert::TryFrom;\nuse proc_macro2::{\n    Ident,\n    Span,\n};\nuse syn::spanned::Spanned as _;\n\n/// An ink! constructor definition.\n///\n/// # Example\n///\n/// ## Inherent implementation constructor:\n///\n/// ```\n/// # use core::convert::TryFrom;\n/// # let event = <ink_lang_ir::ItemImpl as TryFrom<syn::ItemImpl>>::try_from(syn::parse_quote! {\n/// impl MyStorage {\n///     #[ink(constructor)]\n///     pub fn new(init_value: i32) -> Self {\n///         /* contract initialization goes here */\n/// #       unimplemented!()\n///     }\n/// }\n/// # }).unwrap();\n/// ```\n///\n/// ## Trait implementation constructor:\n///\n/// ```\n/// # use core::convert::TryFrom;\n/// # <ink_lang_ir::ItemImpl as TryFrom<syn::ItemImpl>>::try_from(syn::parse_quote! {\n/// impl MyTrait for MyStorage {\n///     #[ink(constructor)]\n///     fn new(init_value: i32) -> Self {\n///         /* contract initialization goes here */\n/// #       unimplemented!()\n///     }\n/// }\n/// # }).unwrap();\n/// ```\n#[derive(Debug, PartialEq, Eq)]\npub struct Constructor {\n    /// The underlying Rust method item.\n    pub(super) item: syn::ImplItemMethod,\n    /// An optional user provided selector.\n    ///\n    /// # Note\n    ///\n    /// This overrides the computed selector, even when using a manual namespace\n    /// for the parent implementation block.\n    selector: Option<ir::Selector>,\n}\n\nimpl quote::ToTokens for Constructor {\n    /// We mainly implement this trait for this ink! type to have a derived\n    /// [`Spanned`](`syn::spanned::Spanned`) implementation for it.\n    fn to_tokens(&self, tokens: &mut proc_macro2::TokenStream) {\n        self.item.to_tokens(tokens)\n    }\n}\n\nimpl Constructor {\n    /// Returns `true` if the given type is `Self`.\n    fn type_is_self_val(ty: &syn::Type) -> bool {\n        matches!(ty, syn::Type::Path(syn::TypePath {\n            qself: None,\n            path\n        }) if path.is_ident(\"Self\"))\n    }\n\n    /// Ensures that the return type of the ink! constructor is `Self`.\n    ///\n    /// Returns an appropriate error otherwise.\n    ///\n    /// # Errors\n    ///\n    /// If the ink! constructor does not return `Self` or is missing a return\n    /// type entirely.\n    fn ensure_valid_return_type(\n        method_item: &syn::ImplItemMethod,\n    ) -> Result<(), syn::Error> {\n        match &method_item.sig.output {\n            syn::ReturnType::Default => {\n                return Err(format_err_spanned!(\n                    &method_item.sig,\n                    \"missing return for ink! constructor\",\n                ))\n            }\n            syn::ReturnType::Type(_, return_type) => {\n                if !Self::type_is_self_val(return_type.as_ref()) {\n                    return Err(format_err_spanned!(\n                        return_type,\n                        \"ink! constructors must return Self\",\n                    ))\n                }\n            }\n        }\n        Ok(())\n    }\n\n    /// Ensures that the ink! constructor has no `self` receiver.\n    ///\n    /// Returns an appropriate error otherwise.\n    ///\n    /// # Errors\n    ///\n    /// If the ink! constructor has a `&self`, `&mut self`, `self` or any other\n    /// kind of a `self` receiver as first argument.\n    fn ensure_no_self_receiver(\n        method_item: &syn::ImplItemMethod,\n    ) -> Result<(), syn::Error> {\n        match method_item.sig.inputs.iter().next() {\n            None | Some(syn::FnArg::Typed(_)) => (),\n            Some(syn::FnArg::Receiver(receiver)) => {\n                return Err(format_err_spanned!(\n                    receiver,\n                    \"ink! constructors must have no `self` receiver\",\n                ))\n            }\n        }\n        Ok(())\n    }\n\n    /// Sanitizes the attributes for the ink! constructor.\n    ///\n    /// Returns a tuple of ink! attributes and non-ink! attributes.\n    fn sanitize_attributes(\n        method_item: &syn::ImplItemMethod,\n    ) -> Result<(ir::InkAttribute, Vec<syn::Attribute>), syn::Error> {\n        ir::sanitize_attributes(\n            method_item.span(),\n            method_item.attrs.clone(),\n            &ir::AttributeArgKind::Constructor,\n            |arg| {\n                match arg.kind() {\n                    ir::AttributeArg::Constructor | ir::AttributeArg::Selector(_) => {\n                        Ok(())\n                    }\n                    ir::AttributeArg::Payable => {\n                        Err(Some(format_err!(\n                            arg.span(),\n                            \"constructors are implicitly payable\"\n                        )))\n                    }\n                    _ => Err(None),\n                }\n            },\n        )\n    }\n}\n\nimpl TryFrom<syn::ImplItemMethod> for Constructor {\n    type Error = syn::Error;\n\n    fn try_from(method_item: syn::ImplItemMethod) -> Result<Self, Self::Error> {\n        ensure_callable_invariants(&method_item, CallableKind::Constructor)?;\n        Self::ensure_valid_return_type(&method_item)?;\n        Self::ensure_no_self_receiver(&method_item)?;\n        let (ink_attrs, other_attrs) = Self::sanitize_attributes(&method_item)?;\n        let selector = ink_attrs.selector();\n        Ok(Constructor {\n            selector,\n            item: syn::ImplItemMethod {\n                attrs: other_attrs,\n                ..method_item\n            },\n        })\n    }\n}\n\nimpl Callable for Constructor {\n    fn kind(&self) -> CallableKind {\n        CallableKind::Constructor\n    }\n\n    fn ident(&self) -> &Ident {\n        &self.item.sig.ident\n    }\n\n    fn user_provided_selector(&self) -> Option<&ir::Selector> {\n        self.selector.as_ref()\n    }\n\n    fn is_payable(&self) -> bool {\n        true\n    }\n\n    fn visibility(&self) -> Visibility {\n        match &self.item.vis {\n            syn::Visibility::Public(vis_public) => Visibility::Public(vis_public.clone()),\n            syn::Visibility::Inherited => Visibility::Inherited,\n            _ => unreachable!(\"encountered invalid visibility for ink! constructor\"),\n        }\n    }\n\n    fn inputs(&self) -> InputsIter {\n        InputsIter::from(self)\n    }\n\n    fn inputs_span(&self) -> Span {\n        self.item.sig.inputs.span()\n    }\n\n    fn statements(&self) -> &[syn::Stmt] {\n        &self.item.block.stmts\n    }\n}\n\nimpl Constructor {\n    /// Returns a slice of all non-ink! attributes of the ink! constructor.\n    pub fn attrs(&self) -> &[syn::Attribute] {\n        &self.item.attrs\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn inputs_works() {\n        macro_rules! expected_inputs {\n            ( $( $name:ident: $ty:ty ),* ) => {{\n                vec![\n                    $(\n                        syn::parse_quote! {\n                            $name: $ty\n                        }\n                    ),*\n                ]\n            }};\n        }\n        let test_inputs: Vec<(Vec<syn::FnArg>, syn::ImplItemMethod)> = vec![\n            (\n                // No inputs:\n                expected_inputs!(),\n                syn::parse_quote! {\n                    #[ink(constructor)]\n                    fn my_constructor() -> Self {}\n                },\n            ),\n            (\n                // Single input:\n                expected_inputs!(a: i32),\n                syn::parse_quote! {\n                    #[ink(constructor)]\n                    fn my_constructor(a: i32) -> Self {}\n                },\n            ),\n            (\n                // Some inputs:\n                expected_inputs!(a: i32, b: u64, c: [u8; 32]),\n                syn::parse_quote! {\n                    #[ink(constructor)]\n                    fn my_constructor(a: i32, b: u64, c: [u8; 32]) -> Self {}\n                },\n            ),\n        ];\n        for (expected_inputs, item_method) in test_inputs {\n            let actual_inputs = <ir::Constructor as TryFrom<_>>::try_from(item_method)\n                .unwrap()\n                .inputs()\n                .cloned()\n                .map(|pat_type| syn::FnArg::Typed(pat_type))\n                .collect::<Vec<_>>();\n            assert_eq!(actual_inputs, expected_inputs);\n        }\n    }\n\n    #[test]\n    fn visibility_works() {\n        let test_inputs: Vec<(bool, syn::ImplItemMethod)> = vec![\n            // inherited\n            (\n                false,\n                syn::parse_quote! {\n                    #[ink(constructor)]\n                    fn my_constructor() -> Self {}\n                },\n            ),\n            // public\n            (\n                true,\n                syn::parse_quote! {\n                    #[ink(constructor)]\n                    pub fn my_constructor() -> Self {}\n                },\n            ),\n        ];\n        for (is_pub, item_method) in test_inputs {\n            let visibility = <ir::Constructor as TryFrom<_>>::try_from(item_method)\n                .unwrap()\n                .visibility();\n            assert_eq!(visibility.is_pub(), is_pub);\n            assert_eq!(visibility.is_inherited(), !is_pub);\n        }\n    }\n\n    #[test]\n    fn try_from_works() {\n        let item_methods: Vec<syn::ImplItemMethod> = vec![\n            // simple + inherited visibility\n            syn::parse_quote! {\n                #[ink(constructor)]\n                fn my_constructor() -> Self {}\n            },\n            // simple + public visibility\n            syn::parse_quote! {\n                #[ink(constructor)]\n                pub fn my_constructor() -> Self {}\n            },\n            // many inputs\n            syn::parse_quote! {\n                #[ink(constructor)]\n                fn my_constructor(input1: i32, input2: i64, input3: u32, input4: u64) -> Self {}\n            },\n        ];\n        for item_method in item_methods {\n            assert!(<ir::Constructor as TryFrom<_>>::try_from(item_method).is_ok());\n        }\n    }\n\n    fn assert_try_from_fails(item_method: syn::ImplItemMethod, expected_err: &str) {\n        assert_eq!(\n            <ir::Constructor as TryFrom<_>>::try_from(item_method)\n                .map_err(|err| err.to_string()),\n            Err(expected_err.to_string()),\n        );\n    }\n\n    #[test]\n    fn try_from_missing_return_fails() {\n        let item_methods: Vec<syn::ImplItemMethod> = vec![\n            syn::parse_quote! {\n                #[ink(constructor)]\n                fn my_constructor() {}\n            },\n            syn::parse_quote! {\n                #[ink(constructor)]\n                pub fn my_constructor() {}\n            },\n        ];\n        for item_method in item_methods {\n            assert_try_from_fails(item_method, \"missing return for ink! constructor\")\n        }\n    }\n\n    #[test]\n    fn try_from_invalid_return_fails() {\n        let item_methods: Vec<syn::ImplItemMethod> = vec![\n            syn::parse_quote! {\n                #[ink(constructor)]\n                fn my_constructor() -> &Self {}\n            },\n            syn::parse_quote! {\n                #[ink(constructor)]\n                pub fn my_constructor() -> &mut Self {}\n            },\n            syn::parse_quote! {\n                #[ink(constructor)]\n                pub fn my_constructor() -> i32 {}\n            },\n            syn::parse_quote! {\n                #[ink(constructor)]\n                pub fn my_constructor() -> Result<Self, ()> {}\n            },\n        ];\n        for item_method in item_methods {\n            assert_try_from_fails(item_method, \"ink! constructors must return Self\")\n        }\n    }\n\n    #[test]\n    fn try_from_invalid_self_receiver_fails() {\n        let item_methods: Vec<syn::ImplItemMethod> = vec![\n            syn::parse_quote! {\n                #[ink(constructor)]\n                fn my_constructor(&self) -> Self {}\n            },\n            syn::parse_quote! {\n                #[ink(constructor)]\n                pub fn my_constructor(&mut self) -> Self {}\n            },\n            syn::parse_quote! {\n                #[ink(constructor)]\n                pub fn my_constructor(self) -> Self {}\n            },\n            syn::parse_quote! {\n                #[ink(constructor)]\n                pub fn my_constructor(mut self) -> Self {}\n            },\n        ];\n        for item_method in item_methods {\n            assert_try_from_fails(\n                item_method,\n                \"ink! constructors must have no `self` receiver\",\n            )\n        }\n    }\n\n    #[test]\n    fn try_from_generics_fails() {\n        let item_methods: Vec<syn::ImplItemMethod> = vec![\n            syn::parse_quote! {\n                #[ink(constructor)]\n                fn my_constructor<T>() -> Self {}\n            },\n            syn::parse_quote! {\n                #[ink(constructor)]\n                pub fn my_constructor<T>() -> Self {}\n            },\n        ];\n        for item_method in item_methods {\n            assert_try_from_fails(item_method, \"ink! constructors must not be generic\")\n        }\n    }\n\n    #[test]\n    fn try_from_const_fails() {\n        let item_methods: Vec<syn::ImplItemMethod> = vec![\n            syn::parse_quote! {\n                #[ink(constructor)]\n                const fn my_constructor() -> Self {}\n            },\n            syn::parse_quote! {\n                #[ink(constructor)]\n                pub const fn my_constructor() -> Self {}\n            },\n        ];\n        for item_method in item_methods {\n            assert_try_from_fails(item_method, \"ink! constructors must not be const\")\n        }\n    }\n\n    #[test]\n    fn try_from_async_fails() {\n        let item_methods: Vec<syn::ImplItemMethod> = vec![\n            syn::parse_quote! {\n                #[ink(constructor)]\n                async fn my_constructor() -> Self {}\n            },\n            syn::parse_quote! {\n                #[ink(constructor)]\n                async fn my_constructor() -> Self {}\n            },\n        ];\n        for item_method in item_methods {\n            assert_try_from_fails(item_method, \"ink! constructors must not be async\")\n        }\n    }\n\n    #[test]\n    fn try_from_unsafe_fails() {\n        let item_methods: Vec<syn::ImplItemMethod> = vec![\n            syn::parse_quote! {\n                #[ink(constructor)]\n                unsafe fn my_constructor() -> Self {}\n            },\n            syn::parse_quote! {\n                #[ink(constructor)]\n                unsafe fn my_constructor() -> Self {}\n            },\n        ];\n        for item_method in item_methods {\n            assert_try_from_fails(item_method, \"ink! constructors must not be unsafe\")\n        }\n    }\n\n    #[test]\n    fn try_from_explicit_abi_fails() {\n        let item_methods: Vec<syn::ImplItemMethod> = vec![\n            syn::parse_quote! {\n                #[ink(constructor)]\n                extern \"C\" fn my_constructor() -> Self {}\n            },\n            syn::parse_quote! {\n                #[ink(constructor)]\n                extern \"C\" fn my_constructor() -> Self {}\n            },\n        ];\n        for item_method in item_methods {\n            assert_try_from_fails(item_method, \"ink! constructors must have explicit ABI\")\n        }\n    }\n\n    #[test]\n    fn try_from_variadic_fails() {\n        let item_methods: Vec<syn::ImplItemMethod> = vec![\n            syn::parse_quote! {\n                #[ink(constructor)]\n                fn my_constructor(...) -> Self {}\n            },\n            syn::parse_quote! {\n                #[ink(constructor)]\n                fn my_constructor(...) -> Self {}\n            },\n        ];\n        for item_method in item_methods {\n            assert_try_from_fails(item_method, \"ink! constructors must not be variadic\")\n        }\n    }\n\n    #[test]\n    fn try_from_visibility_fails() {\n        let item_methods: Vec<syn::ImplItemMethod> = vec![\n            syn::parse_quote! {\n                #[ink(constructor)]\n                crate fn my_constructor() -> Self {}\n            },\n            syn::parse_quote! {\n                #[ink(constructor)]\n                pub(in my::path) fn my_constructor() -> Self {}\n            },\n        ];\n        for item_method in item_methods {\n            assert_try_from_fails(\n                item_method,\n                \"ink! constructors must have public or inherited visibility\",\n            )\n        }\n    }\n\n    #[test]\n    fn conflicting_attributes_fails() {\n        let item_methods: Vec<syn::ImplItemMethod> = vec![\n            // storage\n            syn::parse_quote! {\n                #[ink(constructor, storage)]\n                fn my_constructor() -> Self {}\n            },\n            // namespace\n            syn::parse_quote! {\n                #[ink(constructor, namespace = \"my_namespace\")]\n                fn my_constructor() -> Self {}\n            },\n            // event + multiple attributes\n            syn::parse_quote! {\n                #[ink(constructor)]\n                #[ink(event)]\n                fn my_constructor() -> Self {}\n            },\n            // constructor + payable\n            syn::parse_quote! {\n                #[ink(constructor)]\n                #[ink(payable)]\n                fn my_constructor() -> Self {}\n            },\n        ];\n        for item_method in item_methods {\n            assert_try_from_fails(\n                item_method,\n                \"encountered conflicting ink! attribute argument\",\n            )\n        }\n    }\n}\n"],["926","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::blake2::blake2b_256;\n\n/// A function selector.\n///\n/// # Note\n///\n/// This is equal to the first four bytes of the SHA-3 hash of a function's name.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub struct Selector {\n    bytes: [u8; 4],\n}\n\nimpl Selector {\n    /// Creates a new selector from the given raw bytes.\n    pub fn from_bytes(bytes: [u8; 4]) -> Self {\n        Self { bytes }\n    }\n\n    /// Computes the BLAKE-2 256-bit based selector from the given input bytes.\n    pub fn new(input: &[u8]) -> Self {\n        let mut output = [0; 32];\n        blake2b_256(input, &mut output);\n        Self::from_bytes([output[0], output[1], output[2], output[3]])\n    }\n\n    /// Returns the underlying four bytes.\n    pub fn as_bytes(&self) -> &[u8; 4] {\n        &self.bytes\n    }\n\n    /// Returns a unique identifier as `usize`.\n    pub fn unique_id(self) -> usize {\n        u32::from_le_bytes(self.bytes) as usize\n    }\n}\n\nimpl From<[u8; 4]> for Selector {\n    fn from(bytes: [u8; 4]) -> Self {\n        Self::from_bytes(bytes)\n    }\n}\n"],["927","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::{\n    ir,\n    ir::idents_lint,\n};\nuse core::convert::TryFrom;\nuse proc_macro2::{\n    Ident,\n    Span,\n};\nuse quote::TokenStreamExt as _;\nuse std::collections::HashMap;\nuse syn::{\n    spanned::Spanned,\n    token,\n};\n\n/// The ink! module.\n///\n/// This is the root of all ink! smart contracts and is defined similarly to\n/// a normal Rust module annotated with\n/// `#[ink::contract( /* optional configuration */ )]` attribute.\n///\n/// It contains ink! specific items as well as normal Rust items.\n///\n/// # Example\n///\n/// ```\n/// // #[ink::contract] <-- this line belongs to the ink! configuration!\n/// # use core::convert::TryFrom;\n/// # use ink_lang_ir as ir;\n/// # <ir::ItemMod as TryFrom<syn::ItemMod>>::try_from(syn::parse_quote! {\n/// mod my_contract {\n///     #[ink(storage)]\n///     pub struct MyStorage {\n///         /* storage fields */\n///     }\n///\n///     #[ink(event)]\n///     pub struct MyEvent {\n///         /* event fields */\n///     }\n///\n///     impl MyStorage {\n///         #[ink(constructor)]\n///         pub fn my_constructor() -> Self {\n///             /* constructor initialization */\n///         }\n///\n///         #[ink(message)]\n///         pub fn my_message(&self) {\n///             /* message statements */\n///         }\n///     }\n/// }\n/// # }).unwrap();\n/// ```\n///\n/// # Note\n///\n/// This type has been named after [`syn::ItemMod`] and inherits all of the\n/// fields that are required for inline module definitions.\n///\n/// # Developer Note\n///\n/// Structurally the ink! `Module` mirrors an inline Rust module, for example:\n///\n/// ```\n/// mod rust_module {\n///     /* some Rust item definitions */\n/// }\n/// ```\n///\n/// If the capabilities of an inline Rust module change we have to adjust for that.\n#[derive(Debug, PartialEq, Eq)]\npub struct ItemMod {\n    attrs: Vec<syn::Attribute>,\n    vis: syn::Visibility,\n    mod_token: token::Mod,\n    ident: Ident,\n    brace: token::Brace,\n    items: Vec<ir::Item>,\n}\n\nimpl ItemMod {\n    /// Ensures that the ink! storage struct is not missing and that there are\n    /// not multiple ink! storage struct definitions for the given slice of items.\n    fn ensure_storage_struct_quantity(\n        module_span: Span,\n        items: &[ir::Item],\n    ) -> Result<(), syn::Error> {\n        let storage_iter = items\n            .iter()\n            .filter(|item| matches!(item, ir::Item::Ink(ir::InkItem::Storage(_))));\n        if storage_iter.clone().next().is_none() {\n            return Err(format_err!(module_span, \"missing ink! storage struct\",))\n        }\n        if storage_iter.clone().count() >= 2 {\n            let mut error = format_err!(\n                module_span,\n                \"encountered multiple ink! storage structs, expected exactly one\"\n            );\n            for storage in storage_iter {\n                error.combine(format_err!(storage, \"ink! storage struct here\"))\n            }\n            return Err(error)\n        }\n        Ok(())\n    }\n\n    /// Ensures that the given slice of items contains at least one ink! message.\n    fn ensure_contains_message(\n        module_span: Span,\n        items: &[ir::Item],\n    ) -> Result<(), syn::Error> {\n        let found_message = items\n            .iter()\n            .filter_map(|item| {\n                match item {\n                    ir::Item::Ink(ir::InkItem::ImplBlock(item_impl)) => {\n                        Some(item_impl.iter_messages())\n                    }\n                    _ => None,\n                }\n            })\n            .any(|mut messages| messages.next().is_some());\n        if !found_message {\n            return Err(format_err!(module_span, \"missing ink! message\"))\n        }\n        Ok(())\n    }\n\n    /// Ensures that the given slice of items contains at least one ink! constructor.\n    fn ensure_contains_constructor(\n        module_span: Span,\n        items: &[ir::Item],\n    ) -> Result<(), syn::Error> {\n        let found_constructor = items\n            .iter()\n            .filter_map(|item| {\n                match item {\n                    ir::Item::Ink(ir::InkItem::ImplBlock(item_impl)) => {\n                        Some(item_impl.iter_constructors())\n                    }\n                    _ => None,\n                }\n            })\n            .any(|mut constructors| constructors.next().is_some());\n        if !found_constructor {\n            return Err(format_err!(module_span, \"missing ink! constructor\"))\n        }\n        Ok(())\n    }\n\n    /// Ensures that no ink! message or constructor selectors are overlapping.\n    ///\n    /// # Note\n    ///\n    /// We differentiate between ink! message and ink! constructor selectors\n    /// since they are dispatched independently from each other and thus are\n    /// allowed to have overlapping selectors.\n    fn ensure_no_overlapping_selectors(items: &[ir::Item]) -> Result<(), syn::Error> {\n        let mut messages = <HashMap<ir::Selector, &ir::Message>>::new();\n        let mut constructors = <HashMap<ir::Selector, &ir::Constructor>>::new();\n        for item_impl in items\n            .iter()\n            .filter_map(ir::Item::map_ink_item)\n            .filter_map(ir::InkItem::filter_map_impl_block)\n        {\n            use std::collections::hash_map::Entry;\n            /// Kind is either `\"message\"` or `\"constructor\"`.\n            fn compose_error(\n                first_span: Span,\n                second_span: Span,\n                selector: ir::Selector,\n                kind: &str,\n            ) -> syn::Error {\n                use crate::error::ExtError as _;\n                format_err!(\n                    second_span,\n                    \"encountered ink! {}s with overlapping selectors (= {:02X?})\\n\\\n                     hint: use #[ink(selector = \\\"0x...\\\")] on the callable or \\\n                     #[ink(namespace = \\\"...\\\")] on the implementation block to \\\n                     disambiguate overlapping selectors.\",\n                    kind,\n                    selector.as_bytes(),\n                )\n                .into_combine(format_err!(\n                    first_span,\n                    \"first ink! {} with overlapping selector here\",\n                    kind,\n                ))\n            }\n            for message in item_impl.iter_messages() {\n                let selector = message.composed_selector();\n                match messages.entry(selector) {\n                    Entry::Occupied(overlap) => {\n                        return Err(compose_error(\n                            overlap.get().span(),\n                            message.callable().span(),\n                            selector,\n                            \"message\",\n                        ))\n                    }\n                    Entry::Vacant(vacant) => {\n                        vacant.insert(message.callable());\n                    }\n                }\n            }\n            for constructor in item_impl.iter_constructors() {\n                let selector = constructor.composed_selector();\n                match constructors.entry(selector) {\n                    Entry::Occupied(overlap) => {\n                        return Err(compose_error(\n                            overlap.get().span(),\n                            constructor.callable().span(),\n                            selector,\n                            \"constructor\",\n                        ))\n                    }\n                    Entry::Vacant(vacant) => {\n                        vacant.insert(constructor.callable());\n                    }\n                }\n            }\n        }\n        Ok(())\n    }\n}\n\nimpl TryFrom<syn::ItemMod> for ItemMod {\n    type Error = syn::Error;\n\n    fn try_from(module: syn::ItemMod) -> Result<Self, Self::Error> {\n        let module_span = module.span();\n        idents_lint::ensure_no_ink_identifiers(&module)?;\n        let (brace, items) = match module.content {\n            Some((brace, items)) => (brace, items),\n            None => {\n                return Err(format_err_spanned!(\n                    module,\n                    \"out-of-line ink! modules are not supported, use `#[ink::contract] mod name {{ ... }}`\",\n                ))\n            }\n        };\n        let (ink_attrs, other_attrs) = ir::partition_attributes(module.attrs)?;\n        if !ink_attrs.is_empty() {\n            let mut error = format_err!(\n                module_span,\n                \"encountered invalid ink! attributes on ink! module\"\n            );\n            for ink_attr in ink_attrs {\n                error.combine(format_err!(\n                    ink_attr.span(),\n                    \"invalid ink! attribute on module\"\n                ))\n            }\n            return Err(error)\n        }\n        let items = items\n            .into_iter()\n            .map(<ir::Item as TryFrom<syn::Item>>::try_from)\n            .collect::<Result<Vec<_>, syn::Error>>()?;\n        Self::ensure_storage_struct_quantity(module_span, &items)?;\n        Self::ensure_contains_message(module_span, &items)?;\n        Self::ensure_contains_constructor(module_span, &items)?;\n        Self::ensure_no_overlapping_selectors(&items)?;\n        Ok(Self {\n            attrs: other_attrs,\n            vis: module.vis,\n            mod_token: module.mod_token,\n            ident: module.ident,\n            brace,\n            items,\n        })\n    }\n}\n\nimpl quote::ToTokens for ItemMod {\n    /// We mainly implement this trait for ink! module to have a derived\n    /// [`Spanned`](`syn::spanned::Spanned`) implementation for it.\n    fn to_tokens(&self, tokens: &mut proc_macro2::TokenStream) {\n        tokens.append_all(\n            self.attrs\n                .iter()\n                .filter(|attr| matches!(attr.style, syn::AttrStyle::Outer)),\n        );\n        self.vis.to_tokens(tokens);\n        self.mod_token.to_tokens(tokens);\n        self.ident.to_tokens(tokens);\n        self.brace.surround(tokens, |tokens| {\n            tokens.append_all(\n                self.attrs\n                    .iter()\n                    .filter(|attr| matches!(attr.style, syn::AttrStyle::Inner(_))),\n            );\n            tokens.append_all(&self.items);\n        });\n    }\n}\n\nimpl ItemMod {\n    /// Returns the identifier of the ink! module.\n    pub fn ident(&self) -> &Ident {\n        &self.ident\n    }\n\n    /// Returns the storage struct definition for this ink! module.\n    ///\n    /// # Note\n    ///\n    /// The storage definition is the struct that has been annotated with\n    /// `#[ink(storage)]`. This struct is required to be defined in the root\n    /// of the ink! inline module.\n    ///\n    /// # Panics\n    ///\n    /// If zero or multiple `#[ink(storage)]` annotated structs were found in\n    /// the ink! module. This can be expected to never happen since upon\n    /// construction of an ink! module it is asserted that exactly one\n    /// `#[ink(storage)]` struct exists.\n    pub fn storage(&self) -> &ir::Storage {\n        let mut iter = IterInkItems::new(self)\n            .filter_map(|ink_item| ink_item.filter_map_storage_item());\n        let storage = iter\n            .next()\n            .expect(\"encountered ink! module without a storage struct\");\n        assert!(\n            iter.next().is_none(),\n            \"encountered multiple storage structs in ink! module\"\n        );\n        storage\n    }\n\n    /// Returns all (ink! and non-ink! specific) item definitions of the ink! inline module.\n    pub fn items(&self) -> &[ir::Item] {\n        self.items.as_slice()\n    }\n\n    /// Returns an iterator yielding all ink! implementation blocks.\n    ///\n    /// # Note\n    ///\n    /// An ink! implementation block can be either an inherent `impl` block\n    /// directly defined for the contract's storage struct if it includes at\n    /// least one `#[ink(message)]` or `#[ink(constructor)]` annotation, e.g.:\n    ///\n    /// ```\n    /// # use core::convert::TryFrom;\n    /// # use ink_lang_ir as ir;\n    /// # <ir::ItemMod as TryFrom<syn::ItemMod>>::try_from(syn::parse_quote! {\n    /// # mod my_module {\n    /// # #[ink(storage)]\n    /// # pub struct MyStorage {\n    /// #     /* storage fields */\n    /// # }\n    /// #\n    /// impl MyStorage {\n    /// #   #[ink(constructor)]\n    /// #   pub fn my_constructor() -> Self {\n    /// #       /* constructor implementation */\n    /// #   }\n    /// #\n    ///     #[ink(message)]\n    ///     pub fn my_message(&self) {\n    ///         /* message implementation */\n    ///     }\n    /// }\n    /// # }}).unwrap();\n    /// ```\n    ///\n    /// Also an implementation block can be defined as a trait implementation\n    /// for the ink! storage struct using the `#[ink(impl)]` annotation even\n    /// if none of its interior items have any ink! specific attributes on them,\n    /// e.g.:\n    ///\n    /// ```\n    /// # use core::convert::TryFrom;\n    /// # use ink_lang_ir as ir;\n    /// # <ir::ItemMod as TryFrom<syn::ItemMod>>::try_from(syn::parse_quote! {\n    /// # mod my_module {\n    /// # #[ink(storage)]\n    /// # pub struct MyStorage {\n    /// #     /* storage fields */\n    /// # }\n    /// #\n    /// #[ink(impl)]\n    /// impl MyStorage {\n    ///     fn my_method(&self) -> i32 {\n    ///         /* method implementation */\n    ///     }\n    /// }\n    /// #\n    /// # impl MyStorage {\n    /// #   #[ink(constructor)]\n    /// #   pub fn my_constructor() -> Self {\n    /// #       /* constructor implementation */\n    /// #   }\n    /// #\n    /// #   #[ink(message)]\n    /// #   pub fn my_message(&self) {\n    /// #       /* message implementation */\n    /// #   }\n    /// # }\n    /// # }}).unwrap();\n    /// ```\n    pub fn impls(&self) -> IterItemImpls {\n        IterItemImpls::new(self)\n    }\n\n    /// Returns an iterator yielding all event definitions in this ink! module.\n    pub fn events(&self) -> IterEvents {\n        IterEvents::new(self)\n    }\n\n    /// Returns all non-ink! attributes of the ink! module.\n    pub fn attrs(&self) -> &[syn::Attribute] {\n        &self.attrs\n    }\n\n    /// Returns the visibility of the ink! module.\n    pub fn vis(&self) -> &syn::Visibility {\n        &self.vis\n    }\n}\n\n/// Iterator yielding ink! item definitions of the ink! smart contract.\npub struct IterInkItems<'a> {\n    items_iter: core::slice::Iter<'a, ir::Item>,\n}\n\nimpl<'a> IterInkItems<'a> {\n    /// Creates a new ink! module items iterator.\n    fn new(ink_module: &'a ItemMod) -> Self {\n        Self {\n            items_iter: ink_module.items.iter(),\n        }\n    }\n}\n\nimpl<'a> Iterator for IterInkItems<'a> {\n    type Item = &'a ir::InkItem;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        'repeat: loop {\n            match self.items_iter.next() {\n                None => return None,\n                Some(item) => {\n                    if let Some(event) = item.map_ink_item() {\n                        return Some(event)\n                    }\n                    continue 'repeat\n                }\n            }\n        }\n    }\n}\n\n/// Iterator yielding all ink! event definitions within the ink!\n/// [`ItemMod`](`crate::ir::ItemMod`).\npub struct IterEvents<'a> {\n    items_iter: IterInkItems<'a>,\n}\n\nimpl<'a> IterEvents<'a> {\n    /// Creates a new ink! events iterator.\n    fn new(ink_module: &'a ItemMod) -> Self {\n        Self {\n            items_iter: IterInkItems::new(ink_module),\n        }\n    }\n}\n\nimpl<'a> Iterator for IterEvents<'a> {\n    type Item = &'a ir::Event;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        'repeat: loop {\n            match self.items_iter.next() {\n                None => return None,\n                Some(ink_item) => {\n                    if let Some(event) = ink_item.filter_map_event_item() {\n                        return Some(event)\n                    }\n                    continue 'repeat\n                }\n            }\n        }\n    }\n}\n\n/// Iterator yielding all ink! implementation block definitions within the ink!\n/// [`ItemMod`](`crate::ir::ItemMod`).\npub struct IterItemImpls<'a> {\n    items_iter: IterInkItems<'a>,\n}\n\nimpl<'a> IterItemImpls<'a> {\n    /// Creates a new ink! implementation blocks iterator.\n    fn new(ink_module: &'a ItemMod) -> Self {\n        Self {\n            items_iter: IterInkItems::new(ink_module),\n        }\n    }\n}\n\nimpl<'a> Iterator for IterItemImpls<'a> {\n    type Item = &'a ir::ItemImpl;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        'repeat: loop {\n            match self.items_iter.next() {\n                None => return None,\n                Some(ink_item) => {\n                    if let Some(event) = ink_item.filter_map_impl_block() {\n                        return Some(event)\n                    }\n                    continue 'repeat\n                }\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate as ir;\n\n    #[test]\n    fn item_mod_try_from_works() {\n        let item_mods: Vec<syn::ItemMod> = vec![\n            syn::parse_quote! {\n                mod minimal {\n                    #[ink(storage)]\n                    pub struct Minimal {}\n\n                    impl Minimal {\n                        #[ink(constructor)]\n                        pub fn new() -> Self {}\n                        #[ink(message)]\n                        pub fn minimal_message(&self) {}\n                    }\n                }\n            },\n            syn::parse_quote! {\n                mod flipper {\n                    #[ink(storage)]\n                    pub struct Flipper {\n                        value: bool,\n                    }\n\n                    impl Default for Flipper {\n                        #[ink(constructor)]\n                        fn default() -> Self {\n                            Self { value: false }\n                        }\n                    }\n\n                    impl Flipper {\n                        #[ink(message)]\n                        pub fn flip(&mut self) {\n                            self.value = !self.value\n                        }\n\n                        #[ink(message)]\n                        pub fn get(&self) -> bool {\n                            self.value\n                        }\n                    }\n                }\n            },\n        ];\n        for item_mod in item_mods {\n            assert!(<ir::ItemMod as TryFrom<syn::ItemMod>>::try_from(item_mod).is_ok())\n        }\n    }\n\n    fn assert_fail(item_mod: syn::ItemMod, expected_err: &str) {\n        assert_eq!(\n            <ir::ItemMod as TryFrom<syn::ItemMod>>::try_from(item_mod)\n                .map_err(|err| err.to_string()),\n            Err(expected_err.to_string()),\n        );\n    }\n\n    #[test]\n    fn missing_storage_struct_fails() {\n        assert_fail(\n            syn::parse_quote! {\n                mod my_module {\n                    impl MyStorage {\n                        #[ink(constructor)]\n                        pub fn my_constructor() -> Self {}\n                        #[ink(message)]\n                        pub fn my_message(&self) {}\n                    }\n                }\n            },\n            \"missing ink! storage struct\",\n        )\n    }\n\n    #[test]\n    fn multiple_storage_struct_fails() {\n        assert_fail(\n            syn::parse_quote! {\n                mod my_module {\n                    #[ink(storage)]\n                    pub struct MyFirstStorage {}\n                    #[ink(storage)]\n                    pub struct MySecondStorage {}\n                    impl MyFirstStorage {\n                        #[ink(constructor)]\n                        pub fn my_constructor() -> Self {}\n                        #[ink(message)]\n                        pub fn my_message(&self) {}\n                    }\n                }\n            },\n            \"encountered multiple ink! storage structs, expected exactly one\",\n        )\n    }\n\n    #[test]\n    fn missing_constructor_fails() {\n        assert_fail(\n            syn::parse_quote! {\n                mod my_module {\n                    #[ink(storage)]\n                    pub struct MyStorage {}\n\n                    impl MyStorage {\n                        #[ink(message)]\n                        pub fn my_message(&self) {}\n                    }\n                }\n            },\n            \"missing ink! constructor\",\n        )\n    }\n\n    #[test]\n    fn missing_message_fails() {\n        assert_fail(\n            syn::parse_quote! {\n                mod my_module {\n                    #[ink(storage)]\n                    pub struct MyStorage {}\n\n                    impl MyStorage {\n                        #[ink(constructor)]\n                        pub fn my_constructor() -> Self {}\n                    }\n                }\n            },\n            \"missing ink! message\",\n        )\n    }\n\n    #[test]\n    fn invalid_out_of_line_module_fails() {\n        assert_fail(\n            syn::parse_quote! {\n                mod my_module;\n            },\n            \"out-of-line ink! modules are not supported, use `#[ink::contract] mod name { ... }`\",\n        )\n    }\n\n    #[test]\n    fn conflicting_attributes_fails() {\n        assert_fail(\n            syn::parse_quote! {\n                #[ink(namespace = \"my_namespace\")]\n                mod my_module {\n                    #[ink(storage)]\n                    pub struct MyStorage {}\n                    impl MyStorage {\n                        #[ink(constructor)]\n                        pub fn my_constructor() -> Self {}\n                        #[ink(message)]\n                        pub fn my_message(&self) {}\n                    }\n                }\n            },\n            \"encountered invalid ink! attributes on ink! module\",\n        )\n    }\n\n    #[test]\n    fn overlapping_messages_fails() {\n        assert_fail(\n            syn::parse_quote! {\n                mod my_module {\n                    #[ink(storage)]\n                    pub struct MyStorage {}\n\n                    impl MyStorage {\n                        #[ink(constructor)]\n                        pub fn my_constructor() -> Self {}\n\n                        #[ink(message, selector = \"0xDEADBEEF\")]\n                        pub fn my_message_1(&self) {}\n                    }\n\n                    impl MyStorage {\n                        #[ink(message, selector = \"0xDEADBEEF\")]\n                        pub fn my_message_2(&self) {}\n                    }\n                }\n            },\n            \"encountered ink! messages with overlapping selectors (= [DE, AD, BE, EF])\\n\\\n                hint: use #[ink(selector = \\\"0x...\\\")] on the callable or \\\n                #[ink(namespace = \\\"...\\\")] on the implementation block to \\\n                disambiguate overlapping selectors.\",\n        );\n    }\n\n    #[test]\n    fn overlapping_constructors_fails() {\n        assert_fail(\n            syn::parse_quote! {\n                mod my_module {\n                    #[ink(storage)]\n                    pub struct MyStorage {}\n\n                    impl MyStorage {\n                        #[ink(constructor, selector = \"0xDEADBEEF\")]\n                        pub fn my_constructor_1() -> Self {}\n\n                        #[ink(message)]\n                        pub fn my_message_1(&self) {}\n                    }\n\n                    impl MyStorage {\n                        #[ink(constructor, selector = \"0xDEADBEEF\")]\n                        pub fn my_constructor_2() -> Self {}\n                    }\n                }\n            },\n            \"encountered ink! constructors with overlapping selectors (= [DE, AD, BE, EF])\\n\\\n                hint: use #[ink(selector = \\\"0x...\\\")] on the callable or \\\n                #[ink(namespace = \\\"...\\\")] on the implementation block to \\\n                disambiguate overlapping selectors.\",\n        );\n    }\n\n    #[test]\n    fn overlapping_trait_impls_fails() {\n        assert_fail(\n            syn::parse_quote! {\n                mod my_module {\n                    #[ink(storage)]\n                    pub struct MyStorage {}\n\n                    impl first::MyTrait for MyStorage {\n                        #[ink(constructor)]\n                        fn my_constructor() -> Self {}\n\n                        #[ink(message)]\n                        fn my_message(&self) {}\n                    }\n\n                    impl second::MyTrait for MyStorage {\n                        #[ink(message)]\n                        fn my_message(&self) {}\n                    }\n                }\n            },\n            \"encountered ink! messages with overlapping selectors (= [04, C4, 94, 46])\\n\\\n                hint: use #[ink(selector = \\\"0x...\\\")] on the callable or \\\n                #[ink(namespace = \\\"...\\\")] on the implementation block to \\\n                disambiguate overlapping selectors.\",\n        );\n    }\n\n    #[test]\n    fn namespaced_overlapping_trait_impls_works() {\n        assert!(\n            <ir::ItemMod as TryFrom<syn::ItemMod>>::try_from(syn::parse_quote! {\n                mod my_module {\n                    #[ink(storage)]\n                    pub struct MyStorage {}\n\n                    #[ink(namespace = \"first\")]\n                    impl first::MyTrait for MyStorage {\n                        #[ink(constructor)]\n                        fn my_constructor() -> Self {}\n\n                        #[ink(message)]\n                        fn my_message(&self) {}\n                    }\n\n                    impl second::MyTrait for MyStorage {\n                        #[ink(message)]\n                        fn my_message(&self) {}\n                    }\n                }\n            })\n            .is_ok()\n        );\n    }\n\n    #[test]\n    fn allow_overlap_between_messages_and_constructors() {\n        assert!(\n            <ir::ItemMod as TryFrom<syn::ItemMod>>::try_from(syn::parse_quote! {\n                mod my_module {\n                    #[ink(storage)]\n                    pub struct MyStorage {}\n\n                    impl MyStorage {\n                        #[ink(constructor, selector = \"0xDEADBEEF\")]\n                        pub fn my_constructor() -> Self {}\n\n                        #[ink(message, selector = \"0xDEADBEEF\")]\n                        pub fn my_message(&self) {}\n                    }\n                }\n            })\n            .is_ok()\n        );\n    }\n}\n"],["928","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::{\n    ast,\n    error::ExtError as _,\n};\nuse core::convert::TryFrom;\nuse syn::spanned::Spanned;\n\n/// The ink! configuration.\n#[derive(Debug, Default, PartialEq, Eq)]\npub struct Config {\n    /// If `true` enables the dynamic storage allocator\n    /// facilities and code generation of the ink! smart\n    /// contract. Does incur some overhead. The default is\n    /// `true`.\n    dynamic_storage_allocator: Option<bool>,\n    /// If `true` compiles this ink! smart contract always as\n    /// if it was a dependency of another smart contract.\n    /// This configuration is mainly needed for testing and\n    /// the default is `false`.\n    as_dependency: Option<bool>,\n    /// The environmental types definition.\n    ///\n    /// This must be a type that implements `ink_env::Environment` and can\n    /// be used to change the underlying environmental types of an ink! smart\n    /// contract.\n    env: Option<Environment>,\n}\n\n/// Return an error to notify about duplicate ink! config arguments.\nfn duplicate_config_err<F, S>(fst: F, snd: S, name: &str) -> syn::Error\nwhere\n    F: Spanned,\n    S: Spanned,\n{\n    format_err!(\n        snd.span(),\n        \"encountered duplicate ink! `{}` config argument\",\n        name,\n    )\n    .into_combine(format_err!(\n        fst.span(),\n        \"first `{}` config argument here\",\n        name\n    ))\n}\n\nimpl TryFrom<ast::AttributeArgs> for Config {\n    type Error = syn::Error;\n\n    fn try_from(args: ast::AttributeArgs) -> Result<Self, Self::Error> {\n        let mut dynamic_storage_allocator: Option<(bool, ast::MetaNameValue)> = None;\n        let mut as_dependency: Option<(bool, ast::MetaNameValue)> = None;\n        let mut env: Option<(Environment, ast::MetaNameValue)> = None;\n        for arg in args.into_iter() {\n            if arg.name.is_ident(\"dynamic_storage_allocator\") {\n                if let Some((_, ast)) = dynamic_storage_allocator {\n                    return Err(duplicate_config_err(\n                        ast,\n                        arg,\n                        \"dynamic_storage_allocator\",\n                    ))\n                }\n                if let ast::PathOrLit::Lit(syn::Lit::Bool(lit_bool)) = &arg.value {\n                    dynamic_storage_allocator = Some((lit_bool.value, arg))\n                } else {\n                    return Err(format_err_spanned!(\n                        arg,\n                        \"expected a bool literal for `dynamic_storage_allocator` ink! config argument\",\n                    ))\n                }\n            } else if arg.name.is_ident(\"compile_as_dependency\") {\n                if let Some((_, ast)) = as_dependency {\n                    return Err(duplicate_config_err(ast, arg, \"compile_as_dependency\"))\n                }\n                if let ast::PathOrLit::Lit(syn::Lit::Bool(lit_bool)) = &arg.value {\n                    as_dependency = Some((lit_bool.value, arg))\n                } else {\n                    return Err(format_err_spanned!(\n                        arg,\n                        \"expected a bool literal for `compile_as_dependency` ink! config argument\",\n                    ))\n                }\n            } else if arg.name.is_ident(\"env\") {\n                if let Some((_, ast)) = env {\n                    return Err(duplicate_config_err(ast, arg, \"env\"))\n                }\n                if let ast::PathOrLit::Path(path) = &arg.value {\n                    env = Some((Environment { path: path.clone() }, arg))\n                } else {\n                    return Err(format_err_spanned!(\n                        arg,\n                        \"expected a path for `env` ink! config argument\",\n                    ))\n                }\n            } else {\n                return Err(format_err_spanned!(\n                    arg,\n                    \"encountered unknown or unsupported ink! config argument\",\n                ))\n            }\n        }\n        Ok(Config {\n            dynamic_storage_allocator: dynamic_storage_allocator.map(|(value, _)| value),\n            as_dependency: as_dependency.map(|(value, _)| value),\n            env: env.map(|(value, _)| value),\n        })\n    }\n}\n\nimpl Config {\n    /// Returns the environmental types definition if specified.\n    /// Otherwise returns the default environmental types definition provided\n    /// by ink!.\n    pub fn env(&self) -> syn::Path {\n        self.env\n            .as_ref()\n            .map(|env| &env.path)\n            .cloned()\n            .unwrap_or(Environment::default().path)\n    }\n\n    /// Returns `true` if the dynamic storage allocator facilities are enabled\n    /// for the ink! smart contract, `false` otherwise.\n    ///\n    /// If nothing has been specified returns the default which is `false`.\n    pub fn is_dynamic_storage_allocator_enabled(&self) -> bool {\n        self.dynamic_storage_allocator.unwrap_or(false)\n    }\n\n    /// Return `true` if this ink! smart contract shall always be compiled as\n    /// if it was a dependency of another smart contract, returns `false`\n    /// otherwise.\n    ///\n    /// If nothing has been specified returns the default which is `false`.\n    pub fn is_compile_as_dependency_enabled(&self) -> bool {\n        self.as_dependency.unwrap_or(false)\n    }\n}\n\n/// The environmental types definition.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct Environment {\n    /// The underlying Rust type.\n    pub path: syn::Path,\n}\n\nimpl Default for Environment {\n    fn default() -> Self {\n        Self {\n            path: syn::parse_quote! { ::ink_env::DefaultEnvironment },\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    /// Asserts that the given input config attribute argument are converted\n    /// into the expected ink! configuration or yields the expected error message.\n    fn assert_try_from(\n        input: ast::AttributeArgs,\n        expected: Result<Config, &'static str>,\n    ) {\n        assert_eq!(\n            <Config as TryFrom<ast::AttributeArgs>>::try_from(input)\n                .map_err(|err| err.to_string()),\n            expected.map_err(ToString::to_string),\n        );\n    }\n\n    #[test]\n    fn empty_config_works() {\n        assert_try_from(syn::parse_quote! {}, Ok(Config::default()))\n    }\n\n    #[test]\n    fn storage_alloc_works() {\n        assert_try_from(\n            syn::parse_quote! {\n                dynamic_storage_allocator = true\n            },\n            Ok(Config {\n                dynamic_storage_allocator: Some(true),\n                as_dependency: None,\n                env: None,\n            }),\n        )\n    }\n\n    #[test]\n    fn storage_alloc_invalid_value_fails() {\n        assert_try_from(\n            syn::parse_quote! { dynamic_storage_allocator = \"invalid\" },\n            Err(\"expected a bool literal for `dynamic_storage_allocator` ink! config argument\"),\n        )\n    }\n\n    #[test]\n    fn as_dependency_works() {\n        assert_try_from(\n            syn::parse_quote! {\n                compile_as_dependency = false\n            },\n            Ok(Config {\n                dynamic_storage_allocator: None,\n                as_dependency: Some(false),\n                env: None,\n            }),\n        )\n    }\n\n    #[test]\n    fn as_dependency_invalid_value_fails() {\n        assert_try_from(\n            syn::parse_quote! { compile_as_dependency = \"invalid\" },\n            Err(\n                \"expected a bool literal for `compile_as_dependency` ink! config argument\"\n            )\n        )\n    }\n\n    #[test]\n    fn env_works() {\n        assert_try_from(\n            syn::parse_quote! {\n                env = ::my::env::Types\n            },\n            Ok(Config {\n                dynamic_storage_allocator: None,\n                as_dependency: None,\n                env: Some(Environment {\n                    path: syn::parse_quote! { ::my::env::Types },\n                }),\n            }),\n        )\n    }\n\n    #[test]\n    fn env_invalid_value_fails() {\n        assert_try_from(\n            syn::parse_quote! { env = \"invalid\" },\n            Err(\"expected a path for `env` ink! config argument\"),\n        );\n    }\n\n    #[test]\n    fn unknown_arg_fails() {\n        assert_try_from(\n            syn::parse_quote! { unknown = argument },\n            Err(\"encountered unknown or unsupported ink! config argument\"),\n        );\n    }\n\n    #[test]\n    fn duplicate_args_fails() {\n        assert_try_from(\n            syn::parse_quote! {\n                env = ::my::env::Types,\n                env = ::my::other::env::Types,\n            },\n            Err(\"encountered duplicate ink! `env` config argument\"),\n        );\n    }\n}\n"],["929","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nmod event;\nmod storage;\n\n#[cfg(test)]\nmod tests;\n\npub use self::{\n    event::Event,\n    storage::Storage,\n};\n\nuse crate::{\n    error::ExtError as _,\n    ir,\n    ir::attrs::Attrs as _,\n};\nuse core::convert::TryFrom;\nuse syn::spanned::Spanned as _;\n\n/// An item in the root of the ink! module ([`ir::ItemMod`](`crate::ir::ItemMod`)).\n///\n/// This is either an ink! specific item or a normal Rust item.\n#[derive(Debug, PartialEq, Eq)]\npub enum Item {\n    /// The item is an ink! specific item.\n    Ink(InkItem),\n    /// The item is a normal Rust item.\n    Rust(syn::Item),\n}\n\nimpl quote::ToTokens for Item {\n    /// We mainly implement this trait for this ink! type to have a derived\n    /// [`Spanned`](`syn::spanned::Spanned`) implementation for it.\n    fn to_tokens(&self, tokens: &mut proc_macro2::TokenStream) {\n        match self {\n            Self::Ink(ink_item) => ink_item.to_tokens(tokens),\n            Self::Rust(rust_item) => rust_item.to_tokens(tokens),\n        }\n    }\n}\n\nimpl TryFrom<syn::Item> for Item {\n    type Error = syn::Error;\n\n    fn try_from(item: syn::Item) -> Result<Self, Self::Error> {\n        match item {\n            syn::Item::Struct(item_struct) => {\n                if !ir::contains_ink_attributes(&item_struct.attrs) {\n                    return Ok(Self::Rust(item_struct.into()))\n                }\n                // At this point we know that there must be at least one ink!\n                // attribute. This can be either the ink! storage struct,\n                // an ink! event or an invalid ink! attribute.\n                let attr = ir::first_ink_attribute(&item_struct.attrs)?\n                    .expect(\"missing expected ink! attribute for struct\");\n                match attr.first().kind() {\n                    ir::AttributeArg::Storage => {\n                        <ir::Storage as TryFrom<_>>::try_from(item_struct)\n                            .map(Into::into)\n                            .map(Self::Ink)\n                    }\n                    ir::AttributeArg::Event => {\n                        <ir::Event as TryFrom<_>>::try_from(item_struct)\n                            .map(Into::into)\n                            .map(Self::Ink)\n                    }\n                    _invalid => {\n                        Err(format_err!(\n                            attr.span(),\n                            \"encountered unsupported ink! attribute argument on struct\",\n                        ))\n                    }\n                }\n            }\n            syn::Item::Impl(item_impl) => {\n                if !ir::ItemImpl::is_ink_impl_block(&item_impl)? {\n                    return Ok(Self::Rust(item_impl.into()))\n                }\n                // At this point we know that there must be at least one ink!\n                // attribute on either the impl block itself or one of its items.\n                <ir::ItemImpl as TryFrom<_>>::try_from(item_impl)\n                    .map(Into::into)\n                    .map(Self::Ink)\n            }\n            item => {\n                // This is an error if the item contains any unexpected\n                // ink! attributes. Otherwise it is a normal Rust item.\n                if ir::contains_ink_attributes(item.attrs()) {\n                    let (ink_attrs, _) =\n                        ir::partition_attributes(item.attrs().iter().cloned())?;\n                    assert!(!ink_attrs.is_empty());\n                    fn into_err(attr: &ir::InkAttribute) -> syn::Error {\n                        format_err!(attr.span(), \"encountered unexpected ink! attribute\",)\n                    }\n                    return Err(ink_attrs[1..]\n                        .iter()\n                        .map(into_err)\n                        .fold(into_err(&ink_attrs[0]), |fst, snd| fst.into_combine(snd)))\n                }\n                Ok(Self::Rust(item))\n            }\n        }\n    }\n}\n\nimpl Item {\n    /// Returns `true` if `self` is an ink! specific item.\n    pub fn is_ink_item(&self) -> bool {\n        self.map_ink_item().is_some()\n    }\n\n    /// Returns `true` if `self` is an normal Rust item.\n    pub fn is_rust_item(&self) -> bool {\n        self.map_rust_item().is_some()\n    }\n\n    /// Returns `Some` if `self` is an ink! specific item.\n    ///\n    /// Otherwise, returns `None`.\n    pub fn map_ink_item(&self) -> Option<&InkItem> {\n        match self {\n            Item::Ink(ink_item) => Some(ink_item),\n            _ => None,\n        }\n    }\n\n    /// Returns `Some` if `self` is an ink! specific item.\n    ///\n    /// Otherwise, returns `None`.\n    pub fn map_rust_item(&self) -> Option<&syn::Item> {\n        match self {\n            Item::Rust(rust_item) => Some(rust_item),\n            _ => None,\n        }\n    }\n}\n\n/// An ink! specific item.\n#[derive(Debug, PartialEq, Eq)]\npub enum InkItem {\n    /// The ink! storage struct definition.\n    Storage(ir::Storage),\n    /// An ink! event definition.\n    Event(ir::Event),\n    /// An ink! implementation block.\n    ImplBlock(ir::ItemImpl),\n}\n\nimpl quote::ToTokens for InkItem {\n    /// We mainly implement this trait for this ink! type to have a derived\n    /// [`Spanned`](`syn::spanned::Spanned`) implementation for it.\n    fn to_tokens(&self, tokens: &mut proc_macro2::TokenStream) {\n        match self {\n            Self::Storage(storage) => storage.to_tokens(tokens),\n            Self::Event(event) => event.to_tokens(tokens),\n            Self::ImplBlock(impl_block) => impl_block.to_tokens(tokens),\n        }\n    }\n}\n\nimpl InkItem {\n    /// Returns `true` if the given [`syn::Item`] is eventually an ink! item.\n    ///\n    /// # Errors\n    ///\n    /// If invalid or malformed ink! attributes are encountered for the given item.\n    pub fn is_ink_item(item: &syn::Item) -> Result<bool, syn::Error> {\n        match item {\n            syn::Item::Struct(item_struct) => {\n                if ir::Storage::is_ink_storage(item_struct)?\n                    || ir::Event::is_ink_event(item_struct)?\n                {\n                    return Ok(true)\n                }\n            }\n            syn::Item::Impl(item_impl) => {\n                return ir::ItemImpl::is_ink_impl_block(item_impl)\n            }\n            _ => (),\n        }\n        Ok(false)\n    }\n}\n\nimpl From<ir::Storage> for InkItem {\n    fn from(storage: ir::Storage) -> Self {\n        Self::Storage(storage)\n    }\n}\n\nimpl From<ir::Event> for InkItem {\n    fn from(event: ir::Event) -> Self {\n        Self::Event(event)\n    }\n}\n\nimpl From<ir::ItemImpl> for InkItem {\n    fn from(impl_block: ir::ItemImpl) -> Self {\n        Self::ImplBlock(impl_block)\n    }\n}\n\nimpl InkItem {\n    /// Returns `Some` if `self` is the ink! storage struct definition.\n    ///\n    /// Otherwise, returns `None`.\n    pub fn filter_map_storage_item(&self) -> Option<&ir::Storage> {\n        match self {\n            InkItem::Storage(storage) => Some(storage),\n            _ => None,\n        }\n    }\n\n    /// Returns `true` if the ink! specific item is the storage struct definition.\n    pub fn is_storage_item(&self) -> bool {\n        self.filter_map_storage_item().is_some()\n    }\n\n    /// Returns `Some` if `self` is an ink! event struct definition.\n    ///\n    /// Otherwise, returns `None`.\n    pub fn filter_map_event_item(&self) -> Option<&ir::Event> {\n        match self {\n            InkItem::Event(event) => Some(event),\n            _ => None,\n        }\n    }\n\n    /// Returns `true` if the ink! specific item is an event struct definition.\n    pub fn is_event_item(&self) -> bool {\n        self.filter_map_event_item().is_some()\n    }\n\n    /// Returns `Some` if `self` is an ink! implementation block.\n    ///\n    /// Otherwise, returns `None`.\n    pub fn filter_map_impl_block(&self) -> Option<&ir::ItemImpl> {\n        match self {\n            InkItem::ImplBlock(impl_block) => Some(impl_block),\n            _ => None,\n        }\n    }\n\n    /// Returns `true` if the ink! specific item is an implementation block.\n    pub fn is_impl_block(&self) -> bool {\n        self.filter_map_impl_block().is_some()\n    }\n}\n"],["930","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::*;\n\n#[test]\nfn simple_storage_works() {\n    let storage_struct: syn::Item = syn::parse_quote! {\n        #[ink(storage)]\n        pub struct MyStorage {\n            field_1: bool,\n            field_2: i32,\n        }\n    };\n    assert!(matches!(\n        <ir::Item as TryFrom<_>>::try_from(storage_struct.clone())\n            .map_err(|err| err.to_string()),\n        Ok(ir::Item::Ink(ir::InkItem::Storage(_)))\n    ))\n}\n\n#[test]\nfn simple_event_works() {\n    let event_struct: syn::Item = syn::parse_quote! {\n        #[ink(event)]\n        pub struct MyEvent {\n            #[ink(topic)]\n            param_1: bool,\n            param_2: i32,\n        }\n    };\n    assert!(matches!(\n        <ir::Item as TryFrom<_>>::try_from(event_struct.clone())\n            .map_err(|err| err.to_string()),\n        Ok(ir::Item::Ink(ir::InkItem::Event(_)))\n    ))\n}\n\n#[test]\nfn simple_rust_item_works() {\n    let rust_items: Vec<syn::Item> = vec![\n        syn::parse_quote! {\n            struct RustStruct {\n                field_1: bool,\n                field_2: i32,\n            }\n        },\n        syn::parse_quote! {\n            enum RustEnum {\n                Variant1,\n                Variant2(bool),\n                Variant3 {\n                    a: i32,\n                    b: i32,\n                }\n            }\n        },\n        syn::parse_quote! {\n            fn rust_function(param1: bool, param2: i32) {}\n        },\n        syn::parse_quote! {\n            mod rust_module {}\n        },\n    ];\n    for rust_item in rust_items {\n        assert_eq!(\n            <ir::Item as TryFrom<_>>::try_from(rust_item.clone())\n                .map_err(|err| err.to_string()),\n            Ok(ir::Item::Rust(rust_item))\n        )\n    }\n}\n"],["931","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::{\n    error::ExtError as _,\n    ir,\n    ir::utils,\n};\nuse core::convert::TryFrom;\nuse proc_macro2::{\n    Ident,\n    Span,\n};\nuse syn::spanned::Spanned as _;\n\n/// An ink! event struct definition.\n///\n/// # Example\n///\n/// ```\n/// # use core::convert::TryFrom;\n/// # let event = <ink_lang_ir::Event as TryFrom<syn::ItemStruct>>::try_from(syn::parse_quote! {\n/// #[ink(event)]\n/// pub struct Transaction {\n///     #[ink(topic)]\n///     from: AccountId,\n///     #[ink(topic)]\n///     to: AccountId,\n///     value: Balance,\n/// }\n/// # }).unwrap();\n/// ```\n#[derive(Debug, PartialEq, Eq)]\npub struct Event {\n    item: syn::ItemStruct,\n    pub anonymous: bool,\n}\n\nimpl quote::ToTokens for Event {\n    /// We mainly implement this trait for this ink! type to have a derived\n    /// [`Spanned`](`syn::spanned::Spanned`) implementation for it.\n    fn to_tokens(&self, tokens: &mut proc_macro2::TokenStream) {\n        self.item.to_tokens(tokens)\n    }\n}\n\nimpl Event {\n    /// Returns `true` if the first ink! annotation on the given struct is\n    /// `#[ink(event)]`.\n    ///\n    /// # Errors\n    ///\n    /// If the first found ink! attribute is malformed.\n    pub(super) fn is_ink_event(\n        item_struct: &syn::ItemStruct,\n    ) -> Result<bool, syn::Error> {\n        if !ir::contains_ink_attributes(&item_struct.attrs) {\n            return Ok(false)\n        }\n        // At this point we know that there must be at least one ink!\n        // attribute. This can be either the ink! storage struct,\n        // an ink! event or an invalid ink! attribute.\n        let attr = ir::first_ink_attribute(&item_struct.attrs)?\n            .expect(\"missing expected ink! attribute for struct\");\n        Ok(matches!(attr.first().kind(), ir::AttributeArg::Event))\n    }\n}\n\nimpl TryFrom<syn::ItemStruct> for Event {\n    type Error = syn::Error;\n\n    fn try_from(item_struct: syn::ItemStruct) -> Result<Self, Self::Error> {\n        let struct_span = item_struct.span();\n        let (ink_attrs, other_attrs) = ir::sanitize_attributes(\n            struct_span,\n            item_struct.attrs,\n            &ir::AttributeArgKind::Event,\n            |arg| {\n                match arg.kind() {\n                    ir::AttributeArg::Event | ir::AttributeArg::Anonymous => Ok(()),\n                    _ => Err(None),\n                }\n            },\n        )?;\n        if !item_struct.generics.params.is_empty() {\n            return Err(format_err_spanned!(\n                item_struct.generics.params,\n                \"generic ink! event structs are not supported\",\n            ))\n        }\n        utils::ensure_pub_visibility(\"event structs\", struct_span, &item_struct.vis)?;\n        'repeat: for field in item_struct.fields.iter() {\n            let field_span = field.span();\n            let (ink_attrs, _) = ir::partition_attributes(field.attrs.clone())?;\n            if ink_attrs.is_empty() {\n                continue 'repeat\n            }\n            let normalized =\n                ir::InkAttribute::from_expanded(ink_attrs).map_err(|err| {\n                    err.into_combine(format_err!(field_span, \"at this invocation\",))\n                })?;\n            if !matches!(normalized.first().kind(), ir::AttributeArg::Topic) {\n                return Err(format_err!(\n                    field_span,\n                    \"first optional ink! attribute of an event field must be #[ink(topic)]\",\n                ))\n            }\n            for arg in normalized.args() {\n                if !matches!(arg.kind(), ir::AttributeArg::Topic) {\n                    return Err(format_err!(\n                        arg.span(),\n                        \"encountered conflicting ink! attribute for event field\",\n                    ))\n                }\n            }\n        }\n        Ok(Self {\n            item: syn::ItemStruct {\n                attrs: other_attrs,\n                ..item_struct\n            },\n            anonymous: ink_attrs.is_anonymous(),\n        })\n    }\n}\n\nimpl Event {\n    /// Returns the identifier of the event struct.\n    pub fn ident(&self) -> &Ident {\n        &self.item.ident\n    }\n\n    /// Returns an iterator yielding all the `#[ink(topic)]` annotated fields\n    /// of the event struct.\n    pub fn fields(&self) -> EventFieldsIter {\n        EventFieldsIter::new(self)\n    }\n\n    /// Returns all non-ink! attributes.\n    pub fn attrs(&self) -> &[syn::Attribute] {\n        &self.item.attrs\n    }\n}\n\n/// An event field with a flag indicating if this field is an event topic.\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\npub struct EventField<'a> {\n    /// The associated `field` is an event topic if this is `true`.\n    pub is_topic: bool,\n    /// The event field.\n    field: &'a syn::Field,\n}\n\nimpl<'a> EventField<'a> {\n    /// Returns the span of the event field.\n    pub fn span(self) -> Span {\n        self.field.span()\n    }\n\n    /// Returns all non-ink! attributes of the event field.\n    pub fn attrs(self) -> Vec<syn::Attribute> {\n        let (_, non_ink_attrs) = ir::partition_attributes(self.field.attrs.clone())\n            .expect(\"encountered invalid event field attributes\");\n        non_ink_attrs\n    }\n\n    /// Returns the visibility of the event field.\n    pub fn vis(self) -> &'a syn::Visibility {\n        &self.field.vis\n    }\n\n    /// Returns the identifier of the event field if any.\n    pub fn ident(self) -> Option<&'a Ident> {\n        self.field.ident.as_ref()\n    }\n\n    /// Returns the type of the event field.\n    pub fn ty(self) -> &'a syn::Type {\n        &self.field.ty\n    }\n}\n\n/// Iterator yielding all `#[ink(topic)]` annotated fields of an event struct.\npub struct EventFieldsIter<'a> {\n    iter: syn::punctuated::Iter<'a, syn::Field>,\n}\n\nimpl<'a> EventFieldsIter<'a> {\n    /// Creates a new topics fields iterator for the given ink! event struct.\n    fn new(event: &'a Event) -> Self {\n        Self {\n            iter: event.item.fields.iter(),\n        }\n    }\n}\n\nimpl<'a> Iterator for EventFieldsIter<'a> {\n    type Item = EventField<'a>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.iter.next() {\n            None => None,\n            Some(field) => {\n                let is_topic = ir::first_ink_attribute(&field.attrs)\n                    .unwrap_or_default()\n                    .map(|attr| matches!(attr.first().kind(), ir::AttributeArg::Topic))\n                    .unwrap_or_default();\n                Some(EventField { is_topic, field })\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn simple_try_from_works() {\n        let item_struct: syn::ItemStruct = syn::parse_quote! {\n            #[ink(event)]\n            pub struct MyEvent {\n                #[ink(topic)]\n                field_1: i32,\n                field_2: bool,\n            }\n        };\n        assert!(Event::try_from(item_struct).is_ok());\n    }\n\n    fn assert_try_from_fails(item_struct: syn::ItemStruct, expected: &str) {\n        assert_eq!(\n            Event::try_from(item_struct).map_err(|err| err.to_string()),\n            Err(expected.to_string())\n        )\n    }\n\n    #[test]\n    fn conflicting_struct_attributes_fails() {\n        assert_try_from_fails(\n            syn::parse_quote! {\n                #[ink(event)]\n                #[ink(storage)]\n                pub struct MyEvent {\n                    #[ink(topic)]\n                    field_1: i32,\n                    field_2: bool,\n                }\n            },\n            \"encountered conflicting ink! attribute argument\",\n        )\n    }\n\n    #[test]\n    fn duplicate_struct_attributes_fails() {\n        assert_try_from_fails(\n            syn::parse_quote! {\n                #[ink(event)]\n                #[ink(event)]\n                pub struct MyEvent {\n                    #[ink(topic)]\n                    field_1: i32,\n                    field_2: bool,\n                }\n            },\n            \"encountered duplicate ink! attribute\",\n        )\n    }\n\n    #[test]\n    fn wrong_first_struct_attribute_fails() {\n        assert_try_from_fails(\n            syn::parse_quote! {\n                #[ink(storage)]\n                #[ink(event)]\n                pub struct MyEvent {\n                    #[ink(topic)]\n                    field_1: i32,\n                    field_2: bool,\n                }\n            },\n            \"unexpected first ink! attribute argument\",\n        )\n    }\n\n    #[test]\n    fn missing_storage_attribute_fails() {\n        assert_try_from_fails(\n            syn::parse_quote! {\n                pub struct MyEvent {\n                    #[ink(topic)]\n                    field_1: i32,\n                    field_2: bool,\n                }\n            },\n            \"encountered unexpected empty expanded ink! attribute arguments\",\n        )\n    }\n\n    #[test]\n    fn generic_event_fails() {\n        assert_try_from_fails(\n            syn::parse_quote! {\n                #[ink(event)]\n                pub struct GenericEvent<T> {\n                    #[ink(topic)]\n                    field_1: T,\n                    field_2: bool,\n                }\n            },\n            \"generic ink! event structs are not supported\",\n        )\n    }\n\n    #[test]\n    fn non_pub_event_struct() {\n        assert_try_from_fails(\n            syn::parse_quote! {\n                #[ink(event)]\n                struct PrivateEvent {\n                    #[ink(topic)]\n                    field_1: i32,\n                    field_2: bool,\n                }\n            },\n            \"non `pub` ink! event structs are not supported\",\n        )\n    }\n\n    #[test]\n    fn duplicate_field_attributes_fails() {\n        assert_try_from_fails(\n            syn::parse_quote! {\n                #[ink(event)]\n                pub struct MyEvent {\n                    #[ink(topic)]\n                    #[ink(topic)]\n                    field_1: i32,\n                    field_2: bool,\n                }\n            },\n            \"encountered duplicate ink! attribute\",\n        )\n    }\n\n    #[test]\n    fn invalid_field_attributes_fails() {\n        assert_try_from_fails(\n            syn::parse_quote! {\n                #[ink(event)]\n                pub struct MyEvent {\n                    #[ink(message)]\n                    field_1: i32,\n                    field_2: bool,\n                }\n            },\n            \"first optional ink! attribute of an event field must be #[ink(topic)]\",\n        )\n    }\n\n    #[test]\n    fn conflicting_field_attributes_fails() {\n        assert_try_from_fails(\n            syn::parse_quote! {\n                #[ink(event)]\n                pub struct MyEvent {\n                    #[ink(topic)]\n                    #[ink(payable)]\n                    field_1: i32,\n                    field_2: bool,\n                }\n            },\n            \"encountered conflicting ink! attribute for event field\",\n        )\n    }\n\n    /// Used for the event fields iterator unit test because `syn::Field` does\n    /// not provide a `syn::parse::Parse` implementation.\n    #[derive(Debug, PartialEq, Eq)]\n    struct NamedField(syn::Field);\n\n    impl syn::parse::Parse for NamedField {\n        fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {\n            Ok(Self(syn::Field::parse_named(input)?))\n        }\n    }\n\n    impl NamedField {\n        /// Returns the identifier of the named field.\n        pub fn ident(&self) -> &Ident {\n            self.0.ident.as_ref().unwrap()\n        }\n\n        /// Returns the type of the named field.\n        pub fn ty(&self) -> &syn::Type {\n            &self.0.ty\n        }\n    }\n\n    #[test]\n    fn event_fields_iter_works() {\n        let expected_fields: Vec<(bool, NamedField)> = vec![\n            (\n                true,\n                syn::parse_quote! {\n                    field_1: i32\n                },\n            ),\n            (\n                false,\n                syn::parse_quote! {\n                    field_2: u64\n                },\n            ),\n            (\n                true,\n                syn::parse_quote! {\n                    field_3: [u8; 32]\n                },\n            ),\n        ];\n        let input = <Event as TryFrom<syn::ItemStruct>>::try_from(syn::parse_quote! {\n            #[ink(event)]\n            pub struct MyEvent {\n                #[ink(topic)]\n                field_1: i32,\n                field_2: u64,\n                #[ink(topic)]\n                field_3: [u8; 32],\n            }\n        })\n        .unwrap();\n        let mut fields_iter = input.fields();\n        for (is_topic, expected_field) in expected_fields {\n            let field = fields_iter.next().unwrap();\n            assert_eq!(field.is_topic, is_topic);\n            assert_eq!(field.ident(), Some(expected_field.ident()));\n            assert_eq!(field.ty(), expected_field.ty());\n        }\n    }\n\n    #[test]\n    fn anonymous_event_works() {\n        fn assert_anonymous_event(event: syn::ItemStruct) {\n            match Event::try_from(event) {\n                Ok(event) => {\n                    assert!(event.anonymous);\n                }\n                Err(_) => panic!(\"encountered unexpected invalid anonymous event\"),\n            }\n        }\n        assert_anonymous_event(syn::parse_quote! {\n            #[ink(event)]\n            #[ink(anonymous)]\n            pub struct MyEvent {\n                #[ink(topic)]\n                field_1: i32,\n                field_2: bool,\n            }\n        });\n        assert_anonymous_event(syn::parse_quote! {\n            #[ink(event, anonymous)]\n            pub struct MyEvent {\n                #[ink(topic)]\n                field_1: i32,\n                field_2: bool,\n            }\n        });\n    }\n}\n"],["932","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::{\n    ir,\n    ir::utils,\n};\nuse core::convert::TryFrom;\nuse proc_macro2::Ident;\nuse syn::spanned::Spanned as _;\n\n/// An ink! storage struct definition.\n///\n/// Noticed by ink! through the `#[ink(storage)]` annotation.\n///\n/// # Note\n///\n/// An ink! smart contract must have exactly one storage definition.\n/// The storage definition must be found in the root of the ink! module.\n///\n/// # Example\n///\n/// ```\n/// # use core::convert::TryFrom;\n/// # <ink_lang_ir::Storage as TryFrom<syn::ItemStruct>>::try_from(syn::parse_quote! {\n/// #[ink(storage)]\n/// pub struct MyStorage {\n///     my_value: bool,\n///      counter: u32,\n/// }\n/// # }).unwrap();\n/// ```\n#[derive(Debug, PartialEq, Eq)]\npub struct Storage {\n    /// The underlying `struct` Rust item.\n    ast: syn::ItemStruct,\n}\n\nimpl quote::ToTokens for Storage {\n    /// We mainly implement this trait for this ink! type to have a derived\n    /// [`Spanned`](`syn::spanned::Spanned`) implementation for it.\n    fn to_tokens(&self, tokens: &mut proc_macro2::TokenStream) {\n        self.ast.to_tokens(tokens)\n    }\n}\n\nimpl Storage {\n    /// Returns `true` if the first ink! annotation on the given struct is\n    /// `#[ink(storage)]`.\n    ///\n    /// # Errors\n    ///\n    /// If the first found ink! attribute is malformed.\n    pub(super) fn is_ink_storage(\n        item_struct: &syn::ItemStruct,\n    ) -> Result<bool, syn::Error> {\n        if !ir::contains_ink_attributes(&item_struct.attrs) {\n            return Ok(false)\n        }\n        // At this point we know that there must be at least one ink!\n        // attribute. This can be either the ink! storage struct,\n        // an ink! event or an invalid ink! attribute.\n        let attr = ir::first_ink_attribute(&item_struct.attrs)?\n            .expect(\"missing expected ink! attribute for struct\");\n        Ok(matches!(attr.first().kind(), ir::AttributeArg::Storage))\n    }\n}\n\nimpl TryFrom<syn::ItemStruct> for Storage {\n    type Error = syn::Error;\n\n    fn try_from(item_struct: syn::ItemStruct) -> Result<Self, Self::Error> {\n        let struct_span = item_struct.span();\n        let (_ink_attrs, other_attrs) = ir::sanitize_attributes(\n            struct_span,\n            item_struct.attrs,\n            &ir::AttributeArgKind::Storage,\n            |arg| {\n                match arg.kind() {\n                    ir::AttributeArg::Storage => Ok(()),\n                    _ => Err(None),\n                }\n            },\n        )?;\n        if !item_struct.generics.params.is_empty() {\n            return Err(format_err_spanned!(\n                item_struct.generics.params,\n                \"generic ink! storage structs are not supported\",\n            ))\n        }\n        utils::ensure_pub_visibility(\"storage structs\", struct_span, &item_struct.vis)?;\n        Ok(Self {\n            ast: syn::ItemStruct {\n                attrs: other_attrs,\n                ..item_struct\n            },\n        })\n    }\n}\n\nimpl Storage {\n    /// Returns the non-ink! attributes of the ink! storage struct.\n    pub fn attrs(&self) -> &[syn::Attribute] {\n        &self.ast.attrs\n    }\n\n    /// Returns the identifier of the storage struct.\n    pub fn ident(&self) -> &Ident {\n        &self.ast.ident\n    }\n\n    /// Returns an iter yielding all fields of the storage struct.\n    pub fn fields(&self) -> syn::punctuated::Iter<syn::Field> {\n        self.ast.fields.iter()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn simple_try_from_works() {\n        let item_struct: syn::ItemStruct = syn::parse_quote! {\n            #[ink(storage)]\n            pub struct MyStorage {\n                field_1: i32,\n                field_2: bool,\n            }\n        };\n        assert!(Storage::try_from(item_struct).is_ok())\n    }\n\n    fn assert_try_from_fails(item_struct: syn::ItemStruct, expected: &str) {\n        assert_eq!(\n            Storage::try_from(item_struct).map_err(|err| err.to_string()),\n            Err(expected.to_string())\n        )\n    }\n\n    #[test]\n    fn conflicting_attributes_fails() {\n        assert_try_from_fails(\n            syn::parse_quote! {\n                #[ink(storage)]\n                #[ink(event)]\n                pub struct MyStorage {\n                    field_1: i32,\n                    field_2: bool,\n                }\n            },\n            \"encountered conflicting ink! attribute argument\",\n        )\n    }\n\n    #[test]\n    fn duplicate_attributes_fails() {\n        assert_try_from_fails(\n            syn::parse_quote! {\n                #[ink(storage)]\n                #[ink(storage)]\n                pub struct MyStorage {\n                    field_1: i32,\n                    field_2: bool,\n                }\n            },\n            \"encountered duplicate ink! attribute\",\n        )\n    }\n\n    #[test]\n    fn wrong_first_attribute_fails() {\n        assert_try_from_fails(\n            syn::parse_quote! {\n                #[ink(event)]\n                #[ink(storage)]\n                pub struct MyStorage {\n                    field_1: i32,\n                    field_2: bool,\n                }\n            },\n            \"unexpected first ink! attribute argument\",\n        )\n    }\n\n    #[test]\n    fn missing_storage_attribute_fails() {\n        assert_try_from_fails(\n            syn::parse_quote! {\n                pub struct MyStorage {\n                    field_1: i32,\n                    field_2: bool,\n                }\n            },\n            \"encountered unexpected empty expanded ink! attribute arguments\",\n        )\n    }\n\n    #[test]\n    fn generic_storage_fails() {\n        assert_try_from_fails(\n            syn::parse_quote! {\n                #[ink(storage)]\n                pub struct GenericStorage<T> {\n                    field_1: T,\n                }\n            },\n            \"generic ink! storage structs are not supported\",\n        )\n    }\n\n    #[test]\n    fn non_pub_storage_struct() {\n        assert_try_from_fails(\n            syn::parse_quote! {\n                #[ink(storage)]\n                struct PrivateStorage {\n                    field_1: i32,\n                    field_2: bool,\n                }\n            },\n            \"non `pub` ink! storage structs are not supported\",\n        )\n    }\n}\n"],["933","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/// Returns `Ok` if there are no occurrences of identifiers starting with `__ink_`.\n///\n/// # Errors\n///\n/// Returns a combined error for every instance of `__ink_` prefixed identifier found.\npub fn ensure_no_ink_identifiers<T>(checked: &T) -> Result<(), syn::Error>\nwhere\n    T: VisitBy,\n{\n    let mut visitor = private::IdentVisitor::default();\n    checked.visit_by(&mut visitor);\n    visitor.into_result()\n}\n\n/// Makes sure to call the correct visitor function on the given visitor.\npub trait VisitBy: private::Sealed {\n    fn visit_by(&self, visitor: &mut private::IdentVisitor);\n}\n\nmod private {\n    use super::VisitBy;\n    use proc_macro2::Ident;\n\n    /// Seals the implementation of `VisitBy`.\n    pub trait Sealed {}\n    impl Sealed for syn::ItemMod {}\n    impl Sealed for syn::ItemTrait {}\n    impl Sealed for syn::ItemFn {}\n\n    impl VisitBy for syn::ItemMod {\n        fn visit_by(&self, visitor: &mut IdentVisitor) {\n            syn::visit::visit_item_mod(visitor, self);\n        }\n    }\n\n    impl VisitBy for syn::ItemTrait {\n        fn visit_by(&self, visitor: &mut IdentVisitor) {\n            syn::visit::visit_item_trait(visitor, self);\n        }\n    }\n\n    impl VisitBy for syn::ItemFn {\n        fn visit_by(&self, visitor: &mut IdentVisitor) {\n            syn::visit::visit_item_fn(visitor, self);\n        }\n    }\n\n    /// Visitor to ensure that there are no identifiers starting with `__ink_` as prefix.\n    ///\n    /// # Errors\n    ///\n    /// If there are identifiers starting with `__ink_` as prefix in the input.\n    /// Will yield one combined error for all found encounters.\n    #[derive(Default)]\n    pub struct IdentVisitor {\n        errors: Vec<syn::Error>,\n    }\n\n    impl IdentVisitor {\n        /// Converts the visitor into the errors it found if any.\n        ///\n        /// Returns `Ok` if it found no errors during visitation.\n        pub fn into_result(self) -> Result<(), syn::Error> {\n            match self.errors.split_first() {\n                None => Ok(()),\n                Some((first, rest)) => {\n                    let mut combined = first.clone();\n                    for error in rest {\n                        combined.combine(error.clone());\n                    }\n                    Err(combined)\n                }\n            }\n        }\n    }\n\n    impl<'ast> syn::visit::Visit<'ast> for IdentVisitor {\n        fn visit_ident(&mut self, ident: &'ast Ident) {\n            if ident.to_string().starts_with(\"__ink_\") {\n                self.errors.push(format_err!(\n                    ident,\n                    \"encountered invalid identifier starting with __ink_\",\n                ))\n            }\n        }\n    }\n}\n"],["934","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#![allow(dead_code)]\n\nmod attrs;\nmod blake2;\nmod chain_extension;\nmod config;\nmod contract;\nmod idents_lint;\nmod ink_test;\nmod item;\nmod item_impl;\nmod item_mod;\nmod selector;\nmod trait_def;\npub mod utils;\n\n#[cfg(test)]\nuse self::attrs::Attribute;\n\nuse self::attrs::{\n    contains_ink_attributes,\n    first_ink_attribute,\n    partition_attributes,\n    sanitize_attributes,\n    AttributeArg,\n    AttributeArgKind,\n    AttributeFrag,\n    InkAttribute,\n};\npub use self::{\n    attrs::Namespace,\n    chain_extension::{\n        ChainExtension,\n        ChainExtensionMethod,\n        ExtensionId,\n    },\n    config::Config,\n    contract::Contract,\n    ink_test::InkTest,\n    item::{\n        Event,\n        InkItem,\n        Item,\n        Storage,\n    },\n    item_impl::{\n        Callable,\n        CallableKind,\n        CallableWithSelector,\n        Constructor,\n        ImplItem,\n        InputsIter,\n        ItemImpl,\n        IterConstructors,\n        IterMessages,\n        Message,\n        Receiver,\n        Visibility,\n    },\n    item_mod::{\n        ItemMod,\n        IterEvents,\n        IterItemImpls,\n    },\n    selector::Selector,\n    trait_def::{\n        InkTrait,\n        InkTraitConstructor,\n        InkTraitItem,\n        InkTraitMessage,\n        IterInkTraitItems,\n    },\n};\n"],["935","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::ir::idents_lint;\nuse core::convert::TryFrom;\nuse proc_macro2::TokenStream as TokenStream2;\n\n/// The ink! test with all required information.\npub struct InkTest {\n    /// The function which was annotated.\n    pub item_fn: syn::ItemFn,\n}\n\nimpl TryFrom<syn::ItemFn> for InkTest {\n    type Error = syn::Error;\n\n    fn try_from(item_fn: syn::ItemFn) -> Result<Self, Self::Error> {\n        idents_lint::ensure_no_ink_identifiers(&item_fn)?;\n        Ok(Self { item_fn })\n    }\n}\n\nimpl InkTest {\n    /// Returns `Ok` if the trait matches all requirements for an ink! trait definition.\n    pub fn new(attr: TokenStream2, input: TokenStream2) -> Result<Self, syn::Error> {\n        if !attr.is_empty() {\n            return Err(format_err_spanned!(\n                attr,\n                \"unexpected attribute input for ink! trait definition\"\n            ))\n        }\n        let item_fn = syn::parse2::<syn::ItemFn>(input)?;\n        InkTest::try_from(item_fn)\n    }\n}\n"],["936","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse proc_macro2::{\n    Ident,\n    TokenStream as TokenStream2,\n};\nuse quote::ToTokens;\nuse syn::{\n    ext::IdentExt as _,\n    parse::{\n        Parse,\n        ParseStream,\n    },\n    punctuated::Punctuated,\n    Token,\n};\n\n/// The attribute arguments for the configuration of an ink! smart contract.\n///\n/// These are the segments `env = ::my::env::Environment` and `compile_as_dependency = true`\n/// in `#[ink::contract(env = ::my::env::Environment, compile_as_dependency = true`.\n#[derive(Debug, PartialEq, Eq)]\npub struct AttributeArgs {\n    args: Punctuated<MetaNameValue, Token![,]>,\n}\n\n/// A name-value pair within an attribute, like feature = \"nightly\".\n///\n/// The only difference from `syn::MetaNameValue` is that this additionally\n/// allows the `value` to be a plain identifier or path.\n#[derive(Debug, PartialEq, Eq)]\npub struct MetaNameValue {\n    pub name: syn::Path,\n    pub eq_token: syn::token::Eq,\n    pub value: PathOrLit,\n}\n\n/// Either a path or a literal.\n#[derive(Debug, PartialEq, Eq)]\npub enum PathOrLit {\n    Path(syn::Path),\n    Lit(syn::Lit),\n}\n\nimpl IntoIterator for AttributeArgs {\n    type Item = MetaNameValue;\n    type IntoIter = syn::punctuated::IntoIter<MetaNameValue>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.args.into_iter()\n    }\n}\n\nimpl Parse for AttributeArgs {\n    fn parse(input: ParseStream) -> Result<Self, syn::Error> {\n        Ok(Self {\n            args: Punctuated::parse_terminated(input)?,\n        })\n    }\n}\n\nimpl Parse for MetaNameValue {\n    fn parse(input: ParseStream) -> Result<Self, syn::Error> {\n        let path = input.call(Self::parse_meta_path)?;\n        Self::parse_meta_name_value_after_path(path, input)\n    }\n}\n\nimpl ToTokens for PathOrLit {\n    fn to_tokens(&self, tokens: &mut TokenStream2) {\n        match self {\n            Self::Lit(lit) => lit.to_tokens(tokens),\n            Self::Path(path) => path.to_tokens(tokens),\n        }\n    }\n}\n\nimpl ToTokens for MetaNameValue {\n    fn to_tokens(&self, tokens: &mut TokenStream2) {\n        self.name.to_tokens(tokens);\n        self.eq_token.to_tokens(tokens);\n        self.value.to_tokens(tokens);\n    }\n}\n\nimpl MetaNameValue {\n    /// Like [`syn::Path::parse_mod_style`] but accepts keywords in the path.\n    ///\n    /// # Note\n    ///\n    /// This code was taken from the `syn` implementation for a very similar\n    /// syntactical pattern.\n    fn parse_meta_path(input: ParseStream) -> Result<syn::Path, syn::Error> {\n        Ok(syn::Path {\n            leading_colon: input.parse()?,\n            segments: {\n                let mut segments = Punctuated::new();\n                while input.peek(Ident::peek_any) {\n                    let ident = Ident::parse_any(input)?;\n                    segments.push_value(syn::PathSegment::from(ident));\n                    if !input.peek(syn::Token![::]) {\n                        break\n                    }\n                    let punct = input.parse()?;\n                    segments.push_punct(punct);\n                }\n                if segments.is_empty() {\n                    return Err(input.error(\"expected path\"))\n                } else if segments.trailing_punct() {\n                    return Err(input.error(\"expected path segment\"))\n                }\n                segments\n            },\n        })\n    }\n\n    fn parse_meta_name_value_after_path(\n        name: syn::Path,\n        input: ParseStream,\n    ) -> Result<MetaNameValue, syn::Error> {\n        Ok(MetaNameValue {\n            name,\n            eq_token: input.parse()?,\n            value: input.parse()?,\n        })\n    }\n}\n\nimpl Parse for PathOrLit {\n    fn parse(input: ParseStream) -> Result<Self, syn::Error> {\n        if input.fork().peek(syn::Lit) {\n            return input.parse::<syn::Lit>().map(PathOrLit::Lit)\n        }\n        if input.fork().peek(Ident::peek_any) || input.fork().peek(Token![::]) {\n            return input.parse::<syn::Path>().map(PathOrLit::Path)\n        }\n        Err(input.error(\"cannot parse into either literal or path\"))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use quote::quote;\n\n    impl AttributeArgs {\n        /// Creates a new attribute argument list from the given arguments.\n        pub fn new<I>(args: I) -> Self\n        where\n            I: IntoIterator<Item = MetaNameValue>,\n        {\n            Self {\n                args: args.into_iter().collect(),\n            }\n        }\n    }\n\n    #[test]\n    fn empty_works() {\n        assert_eq!(\n            syn::parse2::<AttributeArgs>(quote! {}).unwrap(),\n            AttributeArgs::new(vec![])\n        )\n    }\n\n    #[test]\n    fn literal_bool_value_works() {\n        assert_eq!(\n            syn::parse2::<AttributeArgs>(quote! { name = true }).unwrap(),\n            AttributeArgs::new(vec![MetaNameValue {\n                name: syn::parse_quote! { name },\n                eq_token: syn::parse_quote! { = },\n                value: PathOrLit::Lit(syn::parse_quote! { true }),\n            }])\n        )\n    }\n\n    #[test]\n    fn literal_str_value_works() {\n        assert_eq!(\n            syn::parse2::<AttributeArgs>(quote! { name = \"string literal\" }).unwrap(),\n            AttributeArgs::new(vec![MetaNameValue {\n                name: syn::parse_quote! { name },\n                eq_token: syn::parse_quote! { = },\n                value: PathOrLit::Lit(syn::parse_quote! { \"string literal\" }),\n            }])\n        )\n    }\n\n    #[test]\n    fn ident_value_works() {\n        assert_eq!(\n            syn::parse2::<AttributeArgs>(quote! { name = MyIdentifier }).unwrap(),\n            AttributeArgs::new(vec![MetaNameValue {\n                name: syn::parse_quote! { name },\n                eq_token: syn::parse_quote! { = },\n                value: PathOrLit::Path(syn::parse_quote! { MyIdentifier }),\n            }])\n        )\n    }\n\n    #[test]\n    fn root_path_value_works() {\n        assert_eq!(\n            syn::parse2::<AttributeArgs>(quote! { name = ::this::is::my::Path }).unwrap(),\n            AttributeArgs::new(vec![MetaNameValue {\n                name: syn::parse_quote! { name },\n                eq_token: syn::parse_quote! { = },\n                value: PathOrLit::Path(syn::parse_quote! { ::this::is::my::Path }),\n            }])\n        )\n    }\n\n    #[test]\n    fn relative_path_value_works() {\n        assert_eq!(\n            syn::parse2::<AttributeArgs>(quote! { name = this::is::my::relative::Path })\n                .unwrap(),\n            AttributeArgs::new(vec![MetaNameValue {\n                name: syn::parse_quote! { name },\n                eq_token: syn::parse_quote! { = },\n                value: PathOrLit::Path(\n                    syn::parse_quote! { this::is::my::relative::Path }\n                ),\n            }])\n        )\n    }\n\n    #[test]\n    fn trailing_comma_works() {\n        let mut expected_args = Punctuated::new();\n        expected_args.push_value(MetaNameValue {\n            name: syn::parse_quote! { name },\n            eq_token: syn::parse_quote! { = },\n            value: PathOrLit::Path(syn::parse_quote! { value }),\n        });\n        expected_args.push_punct(<Token![,]>::default());\n        assert_eq!(\n            syn::parse2::<AttributeArgs>(quote! { name = value, }).unwrap(),\n            AttributeArgs {\n                args: expected_args,\n            }\n        )\n    }\n\n    #[test]\n    fn many_mixed_works() {\n        assert_eq!(\n            syn::parse2::<AttributeArgs>(quote! {\n                name1 = ::root::Path,\n                name2 = false,\n                name3 = \"string literal\",\n                name4 = 42,\n                name5 = 7.7\n            })\n            .unwrap(),\n            AttributeArgs::new(vec![\n                MetaNameValue {\n                    name: syn::parse_quote! { name1 },\n                    eq_token: syn::parse_quote! { = },\n                    value: PathOrLit::Path(syn::parse_quote! { ::root::Path }),\n                },\n                MetaNameValue {\n                    name: syn::parse_quote! { name2 },\n                    eq_token: syn::parse_quote! { = },\n                    value: PathOrLit::Lit(syn::parse_quote! { false }),\n                },\n                MetaNameValue {\n                    name: syn::parse_quote! { name3 },\n                    eq_token: syn::parse_quote! { = },\n                    value: PathOrLit::Lit(syn::parse_quote! { \"string literal\" }),\n                },\n                MetaNameValue {\n                    name: syn::parse_quote! { name4 },\n                    eq_token: syn::parse_quote! { = },\n                    value: PathOrLit::Lit(syn::parse_quote! { 42 }),\n                },\n                MetaNameValue {\n                    name: syn::parse_quote! { name5 },\n                    eq_token: syn::parse_quote! { = },\n                    value: PathOrLit::Lit(syn::parse_quote! { 7.7 }),\n                },\n            ])\n        )\n    }\n}\n"],["937","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Types and abstractions for ink! definitions that require custom syntax.\n//!\n//! # Note\n//!\n//! In general we try not to require any sort of custom non-standard Rust\n//! syntax.\n//!\n//! At the time of this writing we currently only use this for the argument\n//! parsing of ink! config header `#[ink(env = my::env::Types, etc...)]` in order\n//! to be able to parse identifiers in `name = value` segments for the `value`\n//! part.\n\nmod attr_args;\n\npub use self::attr_args::{\n    AttributeArgs,\n    MetaNameValue,\n    PathOrLit,\n};\n"],["938","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse ink_lang_codegen::generate_code;\nuse proc_macro2::TokenStream as TokenStream2;\nuse syn::Result;\n\npub fn analyze(attr: TokenStream2, input: TokenStream2) -> TokenStream2 {\n    match analyze_or_err(attr, input) {\n        Ok(tokens) => tokens,\n        Err(err) => err.to_compile_error(),\n    }\n}\n\npub fn analyze_or_err(attr: TokenStream2, input: TokenStream2) -> Result<TokenStream2> {\n    let trait_definition = ink_lang_ir::InkTrait::new(attr, input)?;\n    Ok(generate_code(&trait_definition))\n}\n"],["939","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse ink_lang_codegen::generate_code;\nuse proc_macro2::TokenStream as TokenStream2;\nuse syn::Result;\n\npub fn generate(attr: TokenStream2, input: TokenStream2) -> TokenStream2 {\n    match generate_or_err(attr, input) {\n        Ok(tokens) => tokens,\n        Err(err) => err.to_compile_error(),\n    }\n}\n\npub fn generate_or_err(attr: TokenStream2, input: TokenStream2) -> Result<TokenStream2> {\n    let chain_extension = ink_lang_ir::ChainExtension::new(attr, input)?;\n    Ok(generate_code(&chain_extension))\n}\n"],["940","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse ink_lang_codegen::generate_code;\nuse proc_macro2::TokenStream as TokenStream2;\nuse syn::Result;\n\npub fn generate(attr: TokenStream2, input: TokenStream2) -> TokenStream2 {\n    match generate_or_err(attr, input) {\n        Ok(tokens) => tokens,\n        Err(err) => err.to_compile_error(),\n    }\n}\n\npub fn generate_or_err(attr: TokenStream2, input: TokenStream2) -> Result<TokenStream2> {\n    let test_definition = ink_lang_ir::InkTest::new(attr, input)?;\n    Ok(generate_code(&test_definition))\n}\n"],["941","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse ink_lang_codegen::generate_code;\nuse ink_lang_ir::Contract;\nuse proc_macro2::TokenStream as TokenStream2;\nuse syn::Result;\n\npub fn generate(attr: TokenStream2, input: TokenStream2) -> TokenStream2 {\n    match generate_or_err(attr, input) {\n        Ok(tokens) => tokens,\n        Err(err) => err.to_compile_error(),\n    }\n}\n\npub fn generate_or_err(attr: TokenStream2, input: TokenStream2) -> Result<TokenStream2> {\n    let contract = Contract::new(attr, input)?;\n    Ok(generate_code(&contract))\n}\n"],["942","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#![allow(clippy::new_ret_no_self)]\n\nuse crate::serde_hex;\n#[cfg(not(feature = \"std\"))]\nuse alloc::{\n    format,\n    vec,\n    vec::Vec,\n};\nuse core::marker::PhantomData;\nuse scale_info::{\n    form::{\n        Form,\n        MetaForm,\n        PortableForm,\n    },\n    meta_type,\n    IntoPortable,\n    Registry,\n    TypeInfo,\n};\nuse serde::{\n    de::DeserializeOwned,\n    Deserialize,\n    Serialize,\n};\n\n/// Describes a contract.\n#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(bound(\n    serialize = \"F::Type: Serialize, F::String: Serialize\",\n    deserialize = \"F::Type: DeserializeOwned, F::String: DeserializeOwned\"\n))]\npub struct ContractSpec<F: Form = MetaForm> {\n    /// The set of constructors of the contract.\n    constructors: Vec<ConstructorSpec<F>>,\n    /// The external messages of the contract.\n    messages: Vec<MessageSpec<F>>,\n    /// The events of the contract.\n    events: Vec<EventSpec<F>>,\n    /// The contract documentation.\n    docs: Vec<F::String>,\n}\n\nimpl IntoPortable for ContractSpec {\n    type Output = ContractSpec<PortableForm>;\n\n    fn into_portable(self, registry: &mut Registry) -> Self::Output {\n        ContractSpec {\n            constructors: self\n                .constructors\n                .into_iter()\n                .map(|constructor| constructor.into_portable(registry))\n                .collect::<Vec<_>>(),\n            messages: self\n                .messages\n                .into_iter()\n                .map(|msg| msg.into_portable(registry))\n                .collect::<Vec<_>>(),\n            events: self\n                .events\n                .into_iter()\n                .map(|event| event.into_portable(registry))\n                .collect::<Vec<_>>(),\n            docs: registry.map_into_portable(self.docs),\n        }\n    }\n}\n\nimpl<F> ContractSpec<F>\nwhere\n    F: Form,\n{\n    /// Returns the set of constructors of the contract.\n    pub fn constructors(&self) -> &[ConstructorSpec<F>] {\n        &self.constructors\n    }\n\n    /// Returns the external messages of the contract.\n    pub fn messages(&self) -> &[MessageSpec<F>] {\n        &self.messages\n    }\n\n    /// Returns the events of the contract.\n    pub fn events(&self) -> &[EventSpec<F>] {\n        &self.events\n    }\n\n    /// Returns the contract documentation.\n    pub fn docs(&self) -> &[F::String] {\n        &self.docs\n    }\n}\n\n/// The message builder is ready to finalize construction.\npub enum Valid {}\n/// The message builder is not ready to finalize construction.\npub enum Invalid {}\n\n/// A builder for contracts.\npub struct ContractSpecBuilder<S = Invalid> {\n    /// The to-be-constructed contract specification.\n    spec: ContractSpec,\n    /// Marker for compile-time checking of valid contract specifications.\n    marker: PhantomData<fn() -> S>,\n}\n\nimpl ContractSpecBuilder<Invalid> {\n    /// Sets the constructors of the contract specification.\n    pub fn constructors<C>(self, constructors: C) -> ContractSpecBuilder<Valid>\n    where\n        C: IntoIterator<Item = ConstructorSpec>,\n    {\n        debug_assert!(self.spec.constructors.is_empty());\n        ContractSpecBuilder {\n            spec: ContractSpec {\n                constructors: constructors.into_iter().collect::<Vec<_>>(),\n                ..self.spec\n            },\n            marker: Default::default(),\n        }\n    }\n}\n\nimpl<S> ContractSpecBuilder<S> {\n    /// Sets the messages of the contract specification.\n    pub fn messages<M>(self, messages: M) -> Self\n    where\n        M: IntoIterator<Item = MessageSpec>,\n    {\n        debug_assert!(self.spec.messages.is_empty());\n        Self {\n            spec: ContractSpec {\n                messages: messages.into_iter().collect::<Vec<_>>(),\n                ..self.spec\n            },\n            ..self\n        }\n    }\n\n    /// Sets the events of the contract specification.\n    pub fn events<E>(self, events: E) -> Self\n    where\n        E: IntoIterator<Item = EventSpec>,\n    {\n        debug_assert!(self.spec.events.is_empty());\n        Self {\n            spec: ContractSpec {\n                events: events.into_iter().collect::<Vec<_>>(),\n                ..self.spec\n            },\n            ..self\n        }\n    }\n\n    /// Sets the documentation of the contract specification.\n    pub fn docs<D>(self, docs: D) -> Self\n    where\n        D: IntoIterator<Item = &'static str>,\n    {\n        debug_assert!(self.spec.docs.is_empty());\n        Self {\n            spec: ContractSpec {\n                docs: docs.into_iter().collect::<Vec<_>>(),\n                ..self.spec\n            },\n            ..self\n        }\n    }\n}\n\nimpl ContractSpecBuilder<Valid> {\n    /// Finalizes construction of the contract specification.\n    pub fn done(self) -> ContractSpec {\n        assert!(\n            !self.spec.constructors.is_empty(),\n            \"must have at least one constructor\"\n        );\n        assert!(\n            !self.spec.messages.is_empty(),\n            \"must have at least one message\"\n        );\n        self.spec\n    }\n}\n\nimpl ContractSpec {\n    /// Creates a new contract specification.\n    pub fn new() -> ContractSpecBuilder {\n        ContractSpecBuilder {\n            spec: Self {\n                constructors: Vec::new(),\n                messages: Vec::new(),\n                events: Vec::new(),\n                docs: Vec::new(),\n            },\n            marker: PhantomData,\n        }\n    }\n}\n\n/// Describes a constructor of a contract.\n#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(bound(\n    serialize = \"F::Type: Serialize, F::String: Serialize\",\n    deserialize = \"F::Type: DeserializeOwned, F::String: DeserializeOwned\"\n))]\npub struct ConstructorSpec<F: Form = MetaForm> {\n    /// The name of the message.\n    ///\n    /// In case of a trait provided constructor the trait name is prefixed.\n    pub name: Vec<F::String>,\n    /// The selector hash of the message.\n    pub selector: Selector,\n    /// The parameters of the deploy handler.\n    pub args: Vec<MessageParamSpec<F>>,\n    /// The deploy handler documentation.\n    pub docs: Vec<F::String>,\n}\n\nimpl IntoPortable for ConstructorSpec {\n    type Output = ConstructorSpec<PortableForm>;\n\n    fn into_portable(self, registry: &mut Registry) -> Self::Output {\n        ConstructorSpec {\n            name: registry.map_into_portable(self.name),\n            selector: self.selector,\n            args: self\n                .args\n                .into_iter()\n                .map(|arg| arg.into_portable(registry))\n                .collect::<Vec<_>>(),\n            docs: registry.map_into_portable(self.docs),\n        }\n    }\n}\n\nimpl<F> ConstructorSpec<F>\nwhere\n    F: Form,\n{\n    /// Returns the name of the message.\n    ///\n    /// In case of a trait provided constructor the trait name is prefixed.\n    pub fn name(&self) -> &[F::String] {\n        &self.name\n    }\n\n    /// Returns the selector hash of the message.\n    pub fn selector(&self) -> &Selector {\n        &self.selector\n    }\n\n    /// Returns the parameters of the deploy handler.\n    pub fn args(&self) -> &[MessageParamSpec<F>] {\n        &self.args\n    }\n\n    /// Returns the deploy handler documentation.\n    pub fn docs(&self) -> &[F::String] {\n        &self.docs\n    }\n}\n\n/// A builder for constructors.\n///\n/// # Dev\n///\n/// Some of the fields are guarded by a type-state pattern to\n/// fail at compile-time instead of at run-time. This is useful\n/// to better debug code-gen macros.\npub struct ConstructorSpecBuilder<Selector> {\n    spec: ConstructorSpec,\n    marker: PhantomData<fn() -> Selector>,\n}\n\nimpl ConstructorSpec {\n    /// Creates a new constructor spec builder.\n    fn from_name_segments(\n        segments: Vec<&'static str>,\n    ) -> ConstructorSpecBuilder<Missing<state::Selector>> {\n        ConstructorSpecBuilder {\n            spec: Self {\n                name: segments,\n                selector: Selector::default(),\n                args: Vec::new(),\n                docs: Vec::new(),\n            },\n            marker: PhantomData,\n        }\n    }\n\n    /// Creates a new constructor spec builder.\n    pub fn from_name(\n        name: &'static str,\n    ) -> ConstructorSpecBuilder<Missing<state::Selector>> {\n        Self::from_name_segments(vec![name])\n    }\n\n    /// Creates a new constructor spec builder for a trait provided constructor.\n    pub fn from_trait_and_name(\n        trait_name: &'static str,\n        constructor_name: &'static str,\n    ) -> ConstructorSpecBuilder<Missing<state::Selector>> {\n        Self::from_name_segments(vec![trait_name, constructor_name])\n    }\n}\n\nimpl ConstructorSpecBuilder<Missing<state::Selector>> {\n    /// Sets the function selector of the message.\n    pub fn selector(self, selector: [u8; 4]) -> ConstructorSpecBuilder<state::Selector> {\n        ConstructorSpecBuilder {\n            spec: ConstructorSpec {\n                selector: selector.into(),\n                ..self.spec\n            },\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl<S> ConstructorSpecBuilder<S> {\n    /// Sets the input arguments of the message specification.\n    pub fn args<A>(self, args: A) -> Self\n    where\n        A: IntoIterator<Item = MessageParamSpec>,\n    {\n        let mut this = self;\n        debug_assert!(this.spec.args.is_empty());\n        this.spec.args = args.into_iter().collect::<Vec<_>>();\n        this\n    }\n\n    /// Sets the documentation of the message specification.\n    pub fn docs<D>(self, docs: D) -> Self\n    where\n        D: IntoIterator<Item = &'static str>,\n    {\n        let mut this = self;\n        debug_assert!(this.spec.docs.is_empty());\n        this.spec.docs = docs.into_iter().map(str::trim).collect::<Vec<_>>();\n        this\n    }\n}\n\nimpl ConstructorSpecBuilder<state::Selector> {\n    /// Finishes construction of the constructor.\n    pub fn done(self) -> ConstructorSpec {\n        self.spec\n    }\n}\n\n/// Describes a contract message.\n#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(bound(\n    serialize = \"F::Type: Serialize, F::String: Serialize\",\n    deserialize = \"F::Type: DeserializeOwned, F::String: DeserializeOwned\"\n))]\n#[serde(rename_all = \"camelCase\")]\npub struct MessageSpec<F: Form = MetaForm> {\n    /// The name of the message and some optional prefixes.\n    ///\n    /// In case of trait provided messages and constructors the prefix\n    /// by convention in ink! is the name of the trait.\n    name: Vec<F::String>,\n    /// The selector hash of the message.\n    selector: Selector,\n    /// If the message is allowed to mutate the contract state.\n    mutates: bool,\n    /// If the message is payable by the caller.\n    payable: bool,\n    /// The parameters of the message.\n    args: Vec<MessageParamSpec<F>>,\n    /// The return type of the message.\n    return_type: ReturnTypeSpec<F>,\n    /// The message documentation.\n    docs: Vec<F::String>,\n}\n\n/// Type state for builders to tell that some mandatory state has not yet been set\n/// yet or to fail upon setting the same state multiple times.\npub struct Missing<S>(PhantomData<fn() -> S>);\n\nmod state {\n    //! Type states that tell what state of a message has not\n    //! yet been set properly for a valid construction.\n\n    /// Type state for the message selector of a message.\n    pub struct Selector;\n    /// Type state for the mutability of a message.\n    pub struct Mutates;\n    /// Type state for telling if the message is payable.\n    pub struct IsPayable;\n    /// Type state for the return type of a message.\n    pub struct Returns;\n}\n\nimpl MessageSpec {\n    /// Creates a new message spec from the given name segments.\n    fn from_name_segments(\n        segments: Vec<&'static str>,\n    ) -> MessageSpecBuilder<\n        Missing<state::Selector>,\n        Missing<state::Mutates>,\n        Missing<state::IsPayable>,\n        Missing<state::Returns>,\n    > {\n        MessageSpecBuilder {\n            spec: Self {\n                name: segments,\n                selector: Selector::default(),\n                mutates: false,\n                payable: false,\n                args: Vec::new(),\n                return_type: ReturnTypeSpec::new(None),\n                docs: Vec::new(),\n            },\n            marker: PhantomData,\n        }\n    }\n\n    /// Creates a new message spec builder.\n    pub fn from_name(\n        name: &'static str,\n    ) -> MessageSpecBuilder<\n        Missing<state::Selector>,\n        Missing<state::Mutates>,\n        Missing<state::IsPayable>,\n        Missing<state::Returns>,\n    > {\n        Self::from_name_segments(vec![name])\n    }\n\n    /// Creates a new message spec builder for a trait provided message.\n    pub fn from_trait_and_name(\n        trait_name: &'static str,\n        message_name: &'static str,\n    ) -> MessageSpecBuilder<\n        Missing<state::Selector>,\n        Missing<state::Mutates>,\n        Missing<state::IsPayable>,\n        Missing<state::Returns>,\n    > {\n        Self::from_name_segments(vec![trait_name, message_name])\n    }\n}\n\nimpl<F> MessageSpec<F>\nwhere\n    F: Form,\n{\n    /// Returns the name of the message and some optional prefixes.\n    ///\n    /// In case of trait provided messages and constructors the prefix\n    /// by convention in ink! is the name of the trait.\n    pub fn name(&self) -> &[F::String] {\n        &self.name\n    }\n\n    /// Returns the selector hash of the message.\n    pub fn selector(&self) -> &Selector {\n        &self.selector\n    }\n\n    /// Returns true if the message is allowed to mutate the contract state.\n    pub fn mutates(&self) -> bool {\n        self.mutates\n    }\n\n    /// Returns true if the message is payable by the caller.\n    pub fn payable(&self) -> bool {\n        self.payable\n    }\n\n    /// Returns the parameters of the message.\n    pub fn args(&self) -> &[MessageParamSpec<F>] {\n        &self.args\n    }\n\n    /// Returns the return type of the message.\n    pub fn return_type(&self) -> &ReturnTypeSpec<F> {\n        &self.return_type\n    }\n\n    /// Returns the message documentation.\n    pub fn docs(&self) -> &[F::String] {\n        &self.docs\n    }\n}\n\n/// A builder for messages.\n///\n/// # Dev\n///\n/// Some of the fields are guarded by a type-state pattern to\n/// fail at compile-time instead of at run-time. This is useful\n/// to better debug code-gen macros.\n#[allow(clippy::type_complexity)]\npub struct MessageSpecBuilder<Selector, Mutates, IsPayable, Returns> {\n    spec: MessageSpec,\n    marker: PhantomData<fn() -> (Selector, Mutates, IsPayable, Returns)>,\n}\n\nimpl<M, P, R> MessageSpecBuilder<Missing<state::Selector>, M, P, R> {\n    /// Sets the function selector of the message.\n    pub fn selector(\n        self,\n        selector: [u8; 4],\n    ) -> MessageSpecBuilder<state::Selector, M, P, R> {\n        MessageSpecBuilder {\n            spec: MessageSpec {\n                selector: selector.into(),\n                ..self.spec\n            },\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl<S, P, R> MessageSpecBuilder<S, Missing<state::Mutates>, P, R> {\n    /// Sets if the message is mutable, thus taking `&mut self` or not thus taking `&self`.\n    pub fn mutates(self, mutates: bool) -> MessageSpecBuilder<S, state::Mutates, P, R> {\n        MessageSpecBuilder {\n            spec: MessageSpec {\n                mutates,\n                ..self.spec\n            },\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl<S, M, R> MessageSpecBuilder<S, M, Missing<state::IsPayable>, R> {\n    /// Sets if the message is mutable, thus taking `&mut self` or not thus taking `&self`.\n    pub fn payable(\n        self,\n        is_payable: bool,\n    ) -> MessageSpecBuilder<S, M, state::IsPayable, R> {\n        MessageSpecBuilder {\n            spec: MessageSpec {\n                payable: is_payable,\n                ..self.spec\n            },\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl<M, S, P> MessageSpecBuilder<S, M, P, Missing<state::Returns>> {\n    /// Sets the return type of the message.\n    pub fn returns(\n        self,\n        return_type: ReturnTypeSpec,\n    ) -> MessageSpecBuilder<S, M, P, state::Returns> {\n        MessageSpecBuilder {\n            spec: MessageSpec {\n                return_type,\n                ..self.spec\n            },\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl<S, M, P, R> MessageSpecBuilder<S, M, P, R> {\n    /// Sets the input arguments of the message specification.\n    pub fn args<A>(self, args: A) -> Self\n    where\n        A: IntoIterator<Item = MessageParamSpec>,\n    {\n        let mut this = self;\n        debug_assert!(this.spec.args.is_empty());\n        this.spec.args = args.into_iter().collect::<Vec<_>>();\n        this\n    }\n\n    /// Sets the documentation of the message specification.\n    pub fn docs<D>(self, docs: D) -> Self\n    where\n        D: IntoIterator<Item = &'static str>,\n    {\n        let mut this = self;\n        debug_assert!(this.spec.docs.is_empty());\n        this.spec.docs = docs.into_iter().collect::<Vec<_>>();\n        this\n    }\n}\n\nimpl\n    MessageSpecBuilder<state::Selector, state::Mutates, state::IsPayable, state::Returns>\n{\n    /// Finishes construction of the message.\n    pub fn done(self) -> MessageSpec {\n        self.spec\n    }\n}\n\nimpl IntoPortable for MessageSpec {\n    type Output = MessageSpec<PortableForm>;\n\n    fn into_portable(self, registry: &mut Registry) -> Self::Output {\n        MessageSpec {\n            name: registry.map_into_portable(self.name),\n            selector: self.selector,\n            mutates: self.mutates,\n            payable: self.payable,\n            args: self\n                .args\n                .into_iter()\n                .map(|arg| arg.into_portable(registry))\n                .collect::<Vec<_>>(),\n            return_type: self.return_type.into_portable(registry),\n            docs: registry.map_into_portable(self.docs),\n        }\n    }\n}\n\n/// Describes an event definition.\n#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(bound(\n    serialize = \"F::Type: Serialize, F::String: Serialize\",\n    deserialize = \"F::Type: DeserializeOwned, F::String: DeserializeOwned\"\n))]\npub struct EventSpec<F: Form = MetaForm> {\n    /// The name of the event.\n    name: F::String,\n    /// The event arguments.\n    args: Vec<EventParamSpec<F>>,\n    /// The event documentation.\n    docs: Vec<F::String>,\n}\n\n/// An event specification builder.\npub struct EventSpecBuilder {\n    spec: EventSpec,\n}\n\nimpl EventSpecBuilder {\n    /// Sets the input arguments of the event specification.\n    pub fn args<A>(self, args: A) -> Self\n    where\n        A: IntoIterator<Item = EventParamSpec>,\n    {\n        let mut this = self;\n        debug_assert!(this.spec.args.is_empty());\n        this.spec.args = args.into_iter().collect::<Vec<_>>();\n        this\n    }\n\n    /// Sets the input arguments of the event specification.\n    pub fn docs<D>(self, docs: D) -> Self\n    where\n        D: IntoIterator<Item = &'static str>,\n    {\n        let mut this = self;\n        debug_assert!(this.spec.docs.is_empty());\n        this.spec.docs = docs.into_iter().collect::<Vec<_>>();\n        this\n    }\n\n    /// Finalizes building the event specification.\n    pub fn done(self) -> EventSpec {\n        self.spec\n    }\n}\n\nimpl IntoPortable for EventSpec {\n    type Output = EventSpec<PortableForm>;\n\n    fn into_portable(self, registry: &mut Registry) -> Self::Output {\n        EventSpec {\n            name: self.name.into_portable(registry),\n            args: self\n                .args\n                .into_iter()\n                .map(|arg| arg.into_portable(registry))\n                .collect::<Vec<_>>(),\n            docs: registry.map_into_portable(self.docs),\n        }\n    }\n}\n\nimpl EventSpec {\n    /// Creates a new event specification builder.\n    pub fn new(name: &'static str) -> EventSpecBuilder {\n        EventSpecBuilder {\n            spec: Self {\n                name,\n                args: Vec::new(),\n                docs: Vec::new(),\n            },\n        }\n    }\n}\n\nimpl<F> EventSpec<F>\nwhere\n    F: Form,\n{\n    /// Returns the name of the event.\n    pub fn name(&self) -> &F::String {\n        &self.name\n    }\n\n    /// The event arguments.\n    pub fn args(&self) -> &[EventParamSpec<F>] {\n        &self.args\n    }\n\n    /// The event documentation.\n    pub fn docs(&self) -> &[F::String] {\n        &self.docs\n    }\n}\n\n/// The 4 byte selector to identify constructors and messages\n#[derive(Debug, Default, PartialEq, Eq, derive_more::From)]\npub struct Selector([u8; 4]);\n\nimpl serde::Serialize for Selector {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {\n        serde_hex::serialize(&self.0, serializer)\n    }\n}\n\nimpl<'de> serde::Deserialize<'de> for Selector {\n    fn deserialize<D>(d: D) -> Result<Self, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        let mut arr = [0; 4];\n        serde_hex::deserialize_check_len(d, serde_hex::ExpectedLen::Exact(&mut arr[..]))?;\n        Ok(arr.into())\n    }\n}\n\nimpl Selector {\n    /// Returns the underlying selector bytes.\n    pub fn to_bytes(&self) -> &[u8] {\n        &self.0\n    }\n}\n\n/// Describes the syntactical name of a type at a given type position.\n///\n/// This is important when trying to work with type aliases.\n/// Normally a type alias is transparent and so scenarios such as\n/// ```no_compile\n/// type Foo = i32;\n/// fn bar(foo: Foo);\n/// ```\n/// Will only communicate that `foo` is of type `i32` which is correct,\n/// however, it will miss the potentially important information that it\n/// is being used through a type alias named `Foo`.\n///\n/// In ink! we current experience this problem with environmental types\n/// such as the `Balance` type that is just a type alias to `u128` in the\n/// default setup. Even though it would be useful for third party tools\n/// such as the Polkadot UI to know that we are handling with `Balance`\n/// types, we currently cannot communicate this without display names.\npub type DisplayName<F> = scale_info::Path<F>;\n\n/// A type specification.\n///\n/// This contains the actual type as well as an optional compile-time\n/// known displayed representation of the type. This is useful for cases\n/// where the type is used through a type alias in order to provide\n/// information about the alias name.\n///\n/// # Examples\n///\n/// Consider the following Rust function:\n/// ```no_compile\n/// fn is_sorted(input: &[i32], pred: Predicate) -> bool;\n/// ```\n/// In this above example `input` would have no displayable name,\n/// `pred`'s display name is `Predicate` and the display name of\n/// the return type is simply `bool`. Note that `Predicate` could\n/// simply be a type alias to `fn(i32, i32) -> Ordering`.\n#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(bound(\n    serialize = \"F::Type: Serialize, F::String: Serialize\",\n    deserialize = \"F::Type: DeserializeOwned, F::String: DeserializeOwned\"\n))]\n#[serde(rename_all = \"camelCase\")]\npub struct TypeSpec<F: Form = MetaForm> {\n    /// The actual type.\n    #[serde(rename = \"type\")]\n    ty: F::Type,\n    /// The compile-time known displayed representation of the type.\n    display_name: DisplayName<F>,\n}\n\nimpl IntoPortable for TypeSpec {\n    type Output = TypeSpec<PortableForm>;\n\n    fn into_portable(self, registry: &mut Registry) -> Self::Output {\n        TypeSpec {\n            ty: registry.register_type(&self.ty),\n            display_name: self.display_name.into_portable(registry),\n        }\n    }\n}\n\nimpl TypeSpec {\n    /// Creates a new type specification with a display name.\n    ///\n    /// The name is any valid Rust identifier or path.\n    ///\n    /// # Examples\n    ///\n    /// Valid display names are `foo`, `foo::bar`, `foo::bar::Baz`, etc.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the given display name is invalid.\n    pub fn with_name_str<T>(display_name: &'static str) -> Self\n    where\n        T: TypeInfo + 'static,\n    {\n        Self::with_name_segs::<T, _>(display_name.split(\"::\"))\n    }\n\n    /// Creates a new type specification with a display name\n    /// represented by the given path segments.\n    ///\n    /// The display name segments all must be valid Rust identifiers.\n    ///\n    /// # Examples\n    ///\n    /// Valid display names are `foo`, `foo::bar`, `foo::bar::Baz`, etc.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the given display name is invalid.\n    pub fn with_name_segs<T, S>(segments: S) -> Self\n    where\n        T: TypeInfo + 'static,\n        S: IntoIterator<Item = &'static str>,\n    {\n        Self {\n            ty: meta_type::<T>(),\n            display_name: DisplayName::from_segments(segments)\n                .expect(\"display name is invalid\"),\n        }\n    }\n\n    /// Creates a new type specification without a display name.\n    pub fn new<T>() -> Self\n    where\n        T: TypeInfo + 'static,\n    {\n        Self {\n            ty: meta_type::<T>(),\n            display_name: DisplayName::default(),\n        }\n    }\n}\n\nimpl<F> TypeSpec<F>\nwhere\n    F: Form,\n{\n    /// Returns the actual type.\n    pub fn ty(&self) -> &F::Type {\n        &self.ty\n    }\n\n    /// Returns the compile-time known displayed representation of the type.\n    pub fn display_name(&self) -> &DisplayName<F> {\n        &self.display_name\n    }\n}\n\n/// Describes a pair of parameter name and type.\n#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(bound(\n    serialize = \"F::Type: Serialize, F::String: Serialize\",\n    deserialize = \"F::Type: DeserializeOwned, F::String: DeserializeOwned\"\n))]\npub struct EventParamSpec<F: Form = MetaForm> {\n    /// The name of the parameter.\n    name: F::String,\n    /// If the event parameter is indexed.\n    indexed: bool,\n    /// The type of the parameter.\n    #[serde(rename = \"type\")]\n    ty: TypeSpec<F>,\n    /// The documentation associated with the arguments.\n    docs: Vec<F::String>,\n}\n\nimpl IntoPortable for EventParamSpec {\n    type Output = EventParamSpec<PortableForm>;\n\n    fn into_portable(self, registry: &mut Registry) -> Self::Output {\n        EventParamSpec {\n            name: self.name.into_portable(registry),\n            indexed: self.indexed,\n            ty: self.ty.into_portable(registry),\n            docs: registry.map_into_portable(self.docs),\n        }\n    }\n}\n\nimpl EventParamSpec {\n    /// Creates a new event parameter specification builder.\n    pub fn new(name: &'static str) -> EventParamSpecBuilder {\n        EventParamSpecBuilder {\n            spec: Self {\n                name,\n                // By default event parameters are not indexed.\n                indexed: false,\n                // We initialize every parameter type as `()`.\n                ty: TypeSpec::new::<()>(),\n                // We start with empty docs.\n                docs: vec![],\n            },\n        }\n    }\n}\n\nimpl<F> EventParamSpec<F>\nwhere\n    F: Form,\n{\n    /// Returns the name of the parameter.\n    pub fn name(&self) -> &F::String {\n        &self.name\n    }\n\n    /// Returns true if the event parameter is indexed.\n    pub fn indexed(&self) -> bool {\n        self.indexed\n    }\n\n    /// Returns the type of the parameter.\n    pub fn ty(&self) -> &TypeSpec<F> {\n        &self.ty\n    }\n\n    /// Returns the documentation associated with the arguments.\n    pub fn docs(&self) -> &[F::String] {\n        &self.docs\n    }\n}\n\n/// Used to construct an event parameter specification.\npub struct EventParamSpecBuilder {\n    /// The built-up event parameter specification.\n    spec: EventParamSpec,\n}\n\nimpl EventParamSpecBuilder {\n    /// Sets the type of the event parameter.\n    pub fn of_type(self, spec: TypeSpec) -> Self {\n        let mut this = self;\n        this.spec.ty = spec;\n        this\n    }\n\n    /// If the event parameter is indexed.\n    pub fn indexed(self, is_indexed: bool) -> Self {\n        let mut this = self;\n        this.spec.indexed = is_indexed;\n        this\n    }\n\n    /// Sets the documentation of the event parameter.\n    pub fn docs<D>(self, docs: D) -> Self\n    where\n        D: IntoIterator<Item = &'static str>,\n    {\n        debug_assert!(self.spec.docs.is_empty());\n        Self {\n            spec: EventParamSpec {\n                docs: docs.into_iter().collect::<Vec<_>>(),\n                ..self.spec\n            },\n        }\n    }\n\n    /// Finishes constructing the event parameter spec.\n    pub fn done(self) -> EventParamSpec {\n        self.spec\n    }\n}\n\n/// Describes the return type of a contract message.\n#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(transparent)]\n#[serde(bound(\n    serialize = \"F::Type: Serialize, F::String: Serialize\",\n    deserialize = \"F::Type: DeserializeOwned, F::String: DeserializeOwned\"\n))]\npub struct ReturnTypeSpec<F: Form = MetaForm> {\n    #[serde(rename = \"type\")]\n    opt_type: Option<TypeSpec<F>>,\n}\n\nimpl IntoPortable for ReturnTypeSpec {\n    type Output = ReturnTypeSpec<PortableForm>;\n\n    fn into_portable(self, registry: &mut Registry) -> Self::Output {\n        ReturnTypeSpec {\n            opt_type: self\n                .opt_type\n                .map(|opt_type| opt_type.into_portable(registry)),\n        }\n    }\n}\n\nimpl ReturnTypeSpec {\n    /// Creates a new return type specification from the given type or `None`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use ink_metadata::{TypeSpec, ReturnTypeSpec};\n    /// ReturnTypeSpec::new(None); // no return type;\n    /// ReturnTypeSpec::new(TypeSpec::new::<i32>()); // return type of `i32`\n    /// ```\n    pub fn new<T>(ty: T) -> Self\n    where\n        T: Into<Option<TypeSpec>>,\n    {\n        Self {\n            opt_type: ty.into(),\n        }\n    }\n}\n\nimpl<F> ReturnTypeSpec<F>\nwhere\n    F: Form,\n{\n    /// Returns the optional return type\n    pub fn opt_type(&self) -> Option<&TypeSpec<F>> {\n        self.opt_type.as_ref()\n    }\n}\n\n/// Describes a pair of parameter name and type.\n#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(bound(\n    serialize = \"F::Type: Serialize, F::String: Serialize\",\n    deserialize = \"F::Type: DeserializeOwned, F::String: DeserializeOwned\"\n))]\npub struct MessageParamSpec<F: Form = MetaForm> {\n    /// The name of the parameter.\n    name: F::String,\n    /// The type of the parameter.\n    #[serde(rename = \"type\")]\n    ty: TypeSpec<F>,\n}\n\nimpl IntoPortable for MessageParamSpec {\n    type Output = MessageParamSpec<PortableForm>;\n\n    fn into_portable(self, registry: &mut Registry) -> Self::Output {\n        MessageParamSpec {\n            name: self.name.into_portable(registry),\n            ty: self.ty.into_portable(registry),\n        }\n    }\n}\n\nimpl MessageParamSpec {\n    /// Constructs a new message parameter specification via builder.\n    pub fn new(name: &'static str) -> MessageParamSpecBuilder {\n        MessageParamSpecBuilder {\n            spec: Self {\n                name,\n                // Uses `()` type by default.\n                ty: TypeSpec::new::<()>(),\n            },\n        }\n    }\n}\n\nimpl<F> MessageParamSpec<F>\nwhere\n    F: Form,\n{\n    /// Returns the name of the parameter.\n    pub fn name(&self) -> &F::String {\n        &self.name\n    }\n\n    /// Returns the type of the parameter.\n    pub fn ty(&self) -> &TypeSpec<F> {\n        &self.ty\n    }\n}\n\n/// Used to construct a message parameter specification.\npub struct MessageParamSpecBuilder {\n    /// The to-be-constructed message parameter specification.\n    spec: MessageParamSpec,\n}\n\nimpl MessageParamSpecBuilder {\n    /// Sets the type of the message parameter.\n    pub fn of_type(self, ty: TypeSpec) -> Self {\n        let mut this = self;\n        this.spec.ty = ty;\n        this\n    }\n\n    /// Finishes construction of the message parameter.\n    pub fn done(self) -> MessageParamSpec {\n        self.spec\n    }\n}\n"],["943","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::*;\nuse ink_primitives::KeyPtr;\nuse pretty_assertions::assert_eq;\n\n#[test]\nfn layout_key_works() {\n    let layout_key = LayoutKey::from(Key::from([0x01; 32]));\n    let json = serde_json::to_string(&layout_key).unwrap();\n    assert_eq!(\n        json,\n        \"\\\"0x0101010101010101010101010101010101010101010101010101010101010101\\\"\",\n    );\n}\n\nfn named_fields_struct_layout(key_ptr: &mut KeyPtr) -> Layout {\n    StructLayout::new(vec![\n        FieldLayout::new(\n            \"a\",\n            CellLayout::new::<i32>(LayoutKey::from(key_ptr.advance_by(1))),\n        ),\n        FieldLayout::new(\n            \"b\",\n            CellLayout::new::<i64>(LayoutKey::from(key_ptr.advance_by(1))),\n        ),\n    ])\n    .into()\n}\n\n#[test]\nfn named_fields_work() {\n    let layout = named_fields_struct_layout(&mut KeyPtr::from(Key::from([0x00; 32])));\n    let mut registry = Registry::new();\n    let compacted = layout.into_portable(&mut registry);\n    let json = serde_json::to_value(&compacted).unwrap();\n    let expected = serde_json::json! {\n        {\n            \"struct\": {\n                \"fields\": [\n                    {\n                        \"layout\": {\n                            \"cell\": {\n                                \"key\": \"0x\\\n                                    0000000000000000\\\n                                    0000000000000000\\\n                                    0000000000000000\\\n                                    0000000000000000\",\n                                \"ty\": 1,\n                            }\n                        },\n                        \"name\": \"a\",\n                    },\n                    {\n                        \"layout\": {\n                            \"cell\": {\n                                \"key\": \"0x\\\n                                    0100000000000000\\\n                                    0000000000000000\\\n                                    0000000000000000\\\n                                    0000000000000000\",\n                                \"ty\": 2,\n                            }\n                        },\n                        \"name\": \"b\",\n                    }\n                ]\n            }\n        }\n    };\n    assert_eq!(json, expected);\n}\n\nfn tuple_struct_layout(key_ptr: &mut KeyPtr) -> Layout {\n    StructLayout::new(vec![\n        FieldLayout::new(\n            None,\n            CellLayout::new::<i32>(LayoutKey::from(key_ptr.advance_by(1))),\n        ),\n        FieldLayout::new(\n            None,\n            CellLayout::new::<i64>(LayoutKey::from(key_ptr.advance_by(1))),\n        ),\n    ])\n    .into()\n}\n\n#[test]\nfn tuple_struct_work() {\n    let layout = tuple_struct_layout(&mut KeyPtr::from(Key::from([0x00; 32])));\n    let mut registry = Registry::new();\n    let compacted = layout.into_portable(&mut registry);\n    let json = serde_json::to_value(&compacted).unwrap();\n    let expected = serde_json::json! {\n        {\n            \"struct\": {\n                \"fields\": [\n                    {\n                        \"layout\": {\n                            \"cell\": {\n                                \"key\": \"0x\\\n                                    0000000000000000\\\n                                    0000000000000000\\\n                                    0000000000000000\\\n                                    0000000000000000\",\n                                \"ty\": 1,\n                            }\n                        },\n                        \"name\": null,\n                    },\n                    {\n                        \"layout\": {\n                            \"cell\": {\n                                \"key\": \"0x\\\n                                    0100000000000000\\\n                                    0000000000000000\\\n                                    0000000000000000\\\n                                    0000000000000000\",\n                                \"ty\": 2,\n                            }\n                        },\n                        \"name\": null,\n                    }\n                ]\n            }\n        }\n    };\n    assert_eq!(json, expected);\n}\n\nfn clike_enum_layout(key_ptr: &mut KeyPtr) -> Layout {\n    EnumLayout::new(\n        key_ptr.advance_by(1),\n        vec![\n            (Discriminant(0), StructLayout::new(vec![])),\n            (Discriminant(1), StructLayout::new(vec![])),\n            (Discriminant(2), StructLayout::new(vec![])),\n        ],\n    )\n    .into()\n}\n\n#[test]\nfn clike_enum_work() {\n    let layout = clike_enum_layout(&mut KeyPtr::from(Key::from([0x00; 32])));\n    let mut registry = Registry::new();\n    let compacted = layout.into_portable(&mut registry);\n    let json = serde_json::to_value(&compacted).unwrap();\n    let expected = serde_json::json! {\n        {\n            \"enum\": {\n                \"dispatchKey\": \"0x\\\n                    0000000000000000\\\n                    0000000000000000\\\n                    0000000000000000\\\n                    0000000000000000\",\n                \"variants\": {\n                    \"0\": {\n                        \"fields\": [],\n                    },\n                    \"1\": {\n                        \"fields\": [],\n                    },\n                    \"2\": {\n                        \"fields\": [],\n                    },\n                }\n            }\n        }\n    };\n    assert_eq!(json, expected);\n}\n\nfn mixed_enum_layout(key_ptr: &mut KeyPtr) -> Layout {\n    EnumLayout::new(\n        *key_ptr.advance_by(1),\n        vec![\n            (Discriminant(0), StructLayout::new(vec![])),\n            {\n                let mut variant_key_ptr = key_ptr.clone();\n                (\n                    Discriminant(1),\n                    StructLayout::new(vec![\n                        FieldLayout::new(\n                            None,\n                            CellLayout::new::<i32>(LayoutKey::from(\n                                variant_key_ptr.advance_by(1),\n                            )),\n                        ),\n                        FieldLayout::new(\n                            None,\n                            CellLayout::new::<i64>(LayoutKey::from(\n                                variant_key_ptr.advance_by(1),\n                            )),\n                        ),\n                    ]),\n                )\n            },\n            {\n                let mut variant_key_ptr = key_ptr.clone();\n                (\n                    Discriminant(2),\n                    StructLayout::new(vec![\n                        FieldLayout::new(\n                            \"a\",\n                            CellLayout::new::<i32>(LayoutKey::from(\n                                variant_key_ptr.advance_by(1),\n                            )),\n                        ),\n                        FieldLayout::new(\n                            \"b\",\n                            CellLayout::new::<i64>(LayoutKey::from(\n                                variant_key_ptr.advance_by(1),\n                            )),\n                        ),\n                    ]),\n                )\n            },\n        ],\n    )\n    .into()\n}\n\n#[test]\nfn mixed_enum_work() {\n    let layout = mixed_enum_layout(&mut KeyPtr::from(Key::from([0x00; 32])));\n    let mut registry = Registry::new();\n    let compacted = layout.into_portable(&mut registry);\n    let json = serde_json::to_value(&compacted).unwrap();\n    let expected = serde_json::json! {\n        {\n            \"enum\": {\n                \"dispatchKey\": \"0x\\\n                    0000000000000000\\\n                    0000000000000000\\\n                    0000000000000000\\\n                    0000000000000000\",\n                \"variants\": {\n                    \"0\": {\n                        \"fields\": [],\n                    },\n                    \"1\": {\n                        \"fields\": [\n                            {\n                                \"layout\": {\n                                    \"cell\": {\n                                        \"key\": \"0x\\\n                                            0100000000000000\\\n                                            0000000000000000\\\n                                            0000000000000000\\\n                                            0000000000000000\",\n                                        \"ty\": 1,\n                                    }\n                                },\n                                \"name\": null,\n                            },\n                            {\n                                \"layout\": {\n                                    \"cell\": {\n                                        \"key\": \"0x\\\n                                            0200000000000000\\\n                                            0000000000000000\\\n                                            0000000000000000\\\n                                            0000000000000000\",\n                                        \"ty\": 2,\n                                    }\n                                },\n                                \"name\": null,\n                            }\n                        ],\n                    },\n                    \"2\": {\n                        \"fields\": [\n                            {\n                                \"layout\": {\n                                    \"cell\": {\n                                        \"key\": \"0x\\\n                                            0100000000000000\\\n                                            0000000000000000\\\n                                            0000000000000000\\\n                                            0000000000000000\",\n                                        \"ty\": 1,\n                                    }\n                                },\n                                \"name\": \"a\",\n                            },\n                            {\n                                \"layout\": {\n                                    \"cell\": {\n                                        \"key\": \"0x\\\n                                            0200000000000000\\\n                                            0000000000000000\\\n                                            0000000000000000\\\n                                            0000000000000000\",\n                                        \"ty\": 2,\n                                    }\n                                },\n                                \"name\": \"b\",\n                            }\n                        ],\n                    },\n                }\n            }\n        }\n    };\n    assert_eq!(json, expected);\n}\n\nfn unbounded_hashing_layout(key_ptr: &mut KeyPtr) -> Layout {\n    let root_key = key_ptr.advance_by(1);\n    HashLayout::new(\n        root_key,\n        HashingStrategy::new(\n            CryptoHasher::Blake2x256,\n            b\"ink storage hashmap\".to_vec(),\n            Vec::new(),\n        ),\n        CellLayout::new::<(i32, bool)>(LayoutKey::from(root_key)),\n    )\n    .into()\n}\n\n#[test]\nfn unbounded_layout_works() {\n    let layout = unbounded_hashing_layout(&mut KeyPtr::from(Key::from([0x00; 32])));\n    let mut registry = Registry::new();\n    let compacted = layout.into_portable(&mut registry);\n    let json = serde_json::to_value(&compacted).unwrap();\n    let expected = serde_json::json! {\n        {\n            \"hash\": {\n                \"layout\": {\n                    \"cell\": {\n                        \"key\": \"0x\\\n                            0000000000000000\\\n                            0000000000000000\\\n                            0000000000000000\\\n                            0000000000000000\",\n                        \"ty\": 1\n                    }\n                },\n                \"offset\": \"0x\\\n                    0000000000000000\\\n                    0000000000000000\\\n                    0000000000000000\\\n                    0000000000000000\",\n                \"strategy\": {\n                        \"hasher\": \"Blake2x256\",\n                        \"prefix\": \"0x696e6b2073746f7261676520686173686d6170\",\n                        \"postfix\": \"\",\n                }\n            }\n        }\n    };\n    assert_eq!(json, expected);\n}\n"],["944","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#[cfg(test)]\nmod tests;\n\nuse crate::{\n    serde_hex,\n    utils::{\n        deserialize_from_byte_str,\n        serialize_as_byte_str,\n    },\n};\nuse derive_more::From;\nuse ink_prelude::collections::btree_map::BTreeMap;\nuse ink_primitives::Key;\nuse scale_info::{\n    form::{\n        Form,\n        MetaForm,\n        PortableForm,\n    },\n    meta_type,\n    IntoPortable,\n    Registry,\n    TypeInfo,\n};\nuse serde::{\n    de::DeserializeOwned,\n    Deserialize,\n    Serialize,\n};\n\n/// Represents the static storage layout of an ink! smart contract.\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, From, Serialize, Deserialize)]\n#[serde(bound(\n    serialize = \"F::Type: Serialize, F::String: Serialize\",\n    deserialize = \"F::Type: DeserializeOwned, F::String: DeserializeOwned\"\n))]\n#[serde(rename_all = \"camelCase\")]\npub enum Layout<F: Form = MetaForm> {\n    /// An encoded cell.\n    ///\n    /// This is the only leaf node within the layout graph.\n    /// All layout nodes have this node type as their leafs.\n    ///\n    /// This represents the encoding of a single cell mapped to a single key.\n    Cell(CellLayout<F>),\n    /// A layout that hashes values into the entire storage key space.\n    ///\n    /// This is commonly used by ink! hashmaps and similar data structures.\n    Hash(HashLayout<F>),\n    /// An array of associated storage cells encoded with a given type.\n    ///\n    /// This can also represent only a single cell.\n    Array(ArrayLayout<F>),\n    /// A struct layout with fields of different types.\n    Struct(StructLayout<F>),\n    /// An enum layout with a discriminant telling which variant is layed out.\n    Enum(EnumLayout<F>),\n}\n\n/// A pointer into some storage region.\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, From)]\npub struct LayoutKey {\n    key: [u8; 32],\n}\n\nimpl serde::Serialize for LayoutKey {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {\n        serde_hex::serialize(&self.key, serializer)\n    }\n}\n\nimpl<'de> serde::Deserialize<'de> for LayoutKey {\n    fn deserialize<D>(d: D) -> Result<Self, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        let mut arr = [0; 32];\n        serde_hex::deserialize_check_len(d, serde_hex::ExpectedLen::Exact(&mut arr[..]))?;\n        Ok(arr.into())\n    }\n}\n\nimpl<'a> From<&'a Key> for LayoutKey {\n    fn from(key: &'a Key) -> Self {\n        Self {\n            key: key.to_bytes(),\n        }\n    }\n}\n\nimpl From<Key> for LayoutKey {\n    fn from(key: Key) -> Self {\n        Self {\n            key: key.to_bytes(),\n        }\n    }\n}\n\nimpl LayoutKey {\n    /// Returns the underlying bytes of the layout key.\n    pub fn to_bytes(&self) -> &[u8] {\n        &self.key\n    }\n}\n\n/// A SCALE encoded cell.\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, From, Serialize, Deserialize)]\n#[serde(bound(\n    serialize = \"F::Type: Serialize, F::String: Serialize\",\n    deserialize = \"F::Type: DeserializeOwned, F::String: DeserializeOwned\"\n))]\npub struct CellLayout<F: Form = MetaForm> {\n    /// The offset key into the storage.\n    key: LayoutKey,\n    /// The type of the encoded entity.\n    ty: <F as Form>::Type,\n}\n\nimpl CellLayout {\n    /// Creates a new cell layout.\n    pub fn new<T>(key: LayoutKey) -> Self\n    where\n        T: TypeInfo + 'static,\n    {\n        Self {\n            key,\n            ty: meta_type::<T>(),\n        }\n    }\n}\n\nimpl IntoPortable for CellLayout {\n    type Output = CellLayout<PortableForm>;\n\n    fn into_portable(self, registry: &mut Registry) -> Self::Output {\n        CellLayout {\n            key: self.key,\n            ty: registry.register_type(&self.ty),\n        }\n    }\n}\n\nimpl IntoPortable for Layout {\n    type Output = Layout<PortableForm>;\n\n    fn into_portable(self, registry: &mut Registry) -> Self::Output {\n        match self {\n            Layout::Cell(encoded_cell) => {\n                Layout::Cell(encoded_cell.into_portable(registry))\n            }\n            Layout::Hash(hash_layout) => {\n                Layout::Hash(hash_layout.into_portable(registry))\n            }\n            Layout::Array(array_layout) => {\n                Layout::Array(array_layout.into_portable(registry))\n            }\n            Layout::Struct(struct_layout) => {\n                Layout::Struct(struct_layout.into_portable(registry))\n            }\n            Layout::Enum(enum_layout) => {\n                Layout::Enum(enum_layout.into_portable(registry))\n            }\n        }\n    }\n}\n\nimpl<F> CellLayout<F>\nwhere\n    F: Form,\n{\n    /// Returns the offset key into the storage.\n    pub fn key(&self) -> &LayoutKey {\n        &self.key\n    }\n\n    /// Returns the type of the encoded entity.\n    pub fn ty(&self) -> &F::Type {\n        &self.ty\n    }\n}\n\n/// A hashing layout potentially hitting all cells of the storage.\n///\n/// Every hashing layout has an offset and a strategy to compute its keys.\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]\n#[serde(bound(\n    serialize = \"F::Type: Serialize, F::String: Serialize\",\n    deserialize = \"F::Type: DeserializeOwned, F::String: DeserializeOwned\"\n))]\npub struct HashLayout<F: Form = MetaForm> {\n    /// The key offset used by the strategy.\n    offset: LayoutKey,\n    /// The hashing strategy to layout the underlying elements.\n    strategy: HashingStrategy,\n    /// The storage layout of the unbounded layout elements.\n    layout: Box<Layout<F>>,\n}\n\nimpl IntoPortable for HashLayout {\n    type Output = HashLayout<PortableForm>;\n\n    fn into_portable(self, registry: &mut Registry) -> Self::Output {\n        HashLayout {\n            offset: self.offset,\n            strategy: self.strategy,\n            layout: Box::new(self.layout.into_portable(registry)),\n        }\n    }\n}\n\nimpl HashLayout {\n    /// Creates a new unbounded layout.\n    pub fn new<K, L>(offset: K, strategy: HashingStrategy, layout: L) -> Self\n    where\n        K: Into<LayoutKey>,\n        L: Into<Layout>,\n    {\n        Self {\n            offset: offset.into(),\n            strategy,\n            layout: Box::new(layout.into()),\n        }\n    }\n}\n\nimpl<F> HashLayout<F>\nwhere\n    F: Form,\n{\n    /// Returns the key offset used by the strategy.\n    pub fn offset(&self) -> &LayoutKey {\n        &self.offset\n    }\n\n    /// Returns the hashing strategy to layout the underlying elements.\n    pub fn strategy(&self) -> &HashingStrategy {\n        &self.strategy\n    }\n\n    /// Returns the storage layout of the unbounded layout elements.\n    pub fn layout(&self) -> &Layout<F> {\n        &self.layout\n    }\n}\n\n/// The unbounded hashing strategy.\n///\n/// The offset key is used as another postfix for the computation.\n/// So the actual formula is: `hasher(prefix + encoded(key) + offset + postfix)`\n/// Where `+` in this contexts means append of the byte slices.\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]\npub struct HashingStrategy {\n    /// One of the supported crypto hashers.\n    hasher: CryptoHasher,\n    /// An optional prefix to the computed hash.\n    #[serde(\n        serialize_with = \"serialize_as_byte_str\",\n        deserialize_with = \"deserialize_from_byte_str\"\n    )]\n    prefix: Vec<u8>,\n    /// An optional postfix to the computed hash.\n    #[serde(\n        serialize_with = \"serialize_as_byte_str\",\n        deserialize_with = \"deserialize_from_byte_str\"\n    )]\n    postfix: Vec<u8>,\n}\n\nimpl HashingStrategy {\n    /// Creates a new unbounded hashing strategy.\n    pub fn new(hasher: CryptoHasher, prefix: Vec<u8>, postfix: Vec<u8>) -> Self {\n        Self {\n            hasher,\n            prefix,\n            postfix,\n        }\n    }\n\n    /// Returns the supported crypto hasher.\n    pub fn hasher(&self) -> &CryptoHasher {\n        &self.hasher\n    }\n\n    /// Returns the optional prefix to the computed hash.\n    pub fn prefix(&self) -> &[u8] {\n        &self.prefix\n    }\n\n    /// Returns the optional postfix to the computed hash.\n    pub fn postfix(&self) -> &[u8] {\n        &self.postfix\n    }\n}\n\n/// One of the supported crypto hashers.\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]\npub enum CryptoHasher {\n    /// The BLAKE-2 crypto hasher with an output of 256 bits.\n    Blake2x256,\n    /// The SHA-2 crypto hasher with an output of 256 bits.\n    Sha2x256,\n    /// The KECCAK crypto hasher with an output of 256 bits.\n    Keccak256,\n}\n\n/// A layout for an array of associated cells with the same encoding.\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]\n#[serde(bound(\n    serialize = \"F::Type: Serialize, F::String: Serialize\",\n    deserialize = \"F::Type: DeserializeOwned, F::String: DeserializeOwned\"\n))]\n#[serde(rename_all = \"camelCase\")]\npub struct ArrayLayout<F: Form = MetaForm> {\n    /// The offset key of the array layout.\n    ///\n    /// This is the same key as the 0-th element of the array layout.\n    offset: LayoutKey,\n    /// The number of elements in the array layout.\n    len: u32,\n    /// The number of cells each element in the array layout consists of.\n    cells_per_elem: u64,\n    /// The layout of the elements stored in the array layout.\n    layout: Box<Layout<F>>,\n}\n\nimpl ArrayLayout {\n    /// Creates an array layout with the given length.\n    pub fn new<K, L>(at: K, len: u32, cells_per_elem: u64, layout: L) -> Self\n    where\n        K: Into<LayoutKey>,\n        L: Into<Layout>,\n    {\n        Self {\n            offset: at.into(),\n            len,\n            cells_per_elem,\n            layout: Box::new(layout.into()),\n        }\n    }\n}\n\n#[allow(clippy::len_without_is_empty)]\nimpl<F> ArrayLayout<F>\nwhere\n    F: Form,\n{\n    /// Returns the offset key of the array layout.\n    ///\n    /// This is the same key as the 0-th element of the array layout.\n    pub fn offset(&self) -> &LayoutKey {\n        &self.offset\n    }\n\n    /// Returns the number of elements in the array layout.\n    pub fn len(&self) -> u32 {\n        self.len\n    }\n\n    /// Returns he number of cells each element in the array layout consists of.\n    pub fn cells_per_elem(&self) -> u64 {\n        self.cells_per_elem\n    }\n\n    /// Returns the layout of the elements stored in the array layout.\n    pub fn layout(&self) -> &Layout<F> {\n        &self.layout\n    }\n}\n\nimpl IntoPortable for ArrayLayout {\n    type Output = ArrayLayout<PortableForm>;\n\n    fn into_portable(self, registry: &mut Registry) -> Self::Output {\n        ArrayLayout {\n            offset: self.offset,\n            len: self.len,\n            cells_per_elem: self.cells_per_elem,\n            layout: Box::new(self.layout.into_portable(registry)),\n        }\n    }\n}\n\n/// A struct layout with consecutive fields of different layout.\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]\n#[serde(bound(\n    serialize = \"F::Type: Serialize, F::String: Serialize\",\n    deserialize = \"F::Type: DeserializeOwned, F::String: DeserializeOwned\"\n))]\npub struct StructLayout<F: Form = MetaForm> {\n    /// The fields of the struct layout.\n    fields: Vec<FieldLayout<F>>,\n}\n\nimpl StructLayout {\n    /// Creates a new struct layout.\n    pub fn new<F>(fields: F) -> Self\n    where\n        F: IntoIterator<Item = FieldLayout>,\n    {\n        Self {\n            fields: fields.into_iter().collect(),\n        }\n    }\n}\n\nimpl<F> StructLayout<F>\nwhere\n    F: Form,\n{\n    /// Returns the fields of the struct layout.\n    pub fn fields(&self) -> &[FieldLayout<F>] {\n        &self.fields\n    }\n}\n\nimpl IntoPortable for StructLayout {\n    type Output = StructLayout<PortableForm>;\n\n    fn into_portable(self, registry: &mut Registry) -> Self::Output {\n        StructLayout {\n            fields: self\n                .fields\n                .into_iter()\n                .map(|field| field.into_portable(registry))\n                .collect::<Vec<_>>(),\n        }\n    }\n}\n\n/// The layout for a particular field of a struct layout.\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]\n#[serde(bound(\n    serialize = \"F::Type: Serialize, F::String: Serialize\",\n    deserialize = \"F::Type: DeserializeOwned, F::String: DeserializeOwned\"\n))]\npub struct FieldLayout<F: Form = MetaForm> {\n    /// The name of the field.\n    ///\n    /// Can be missing, e.g. in case of an enum tuple struct variant.\n    name: Option<F::String>,\n    /// The kind of the field.\n    ///\n    /// This is either a direct layout bound\n    /// or another recursive layout sub-struct.\n    layout: Layout<F>,\n}\n\nimpl FieldLayout {\n    /// Creates a new field layout.\n    pub fn new<N, L>(name: N, layout: L) -> Self\n    where\n        N: Into<Option<&'static str>>,\n        L: Into<Layout>,\n    {\n        Self {\n            name: name.into(),\n            layout: layout.into(),\n        }\n    }\n}\n\nimpl<F> FieldLayout<F>\nwhere\n    F: Form,\n{\n    /// Returns the name of the field.\n    ///\n    /// Can be missing, e.g. in case of an enum tuple struct variant.\n    pub fn name(&self) -> Option<&F::String> {\n        self.name.as_ref()\n    }\n\n    /// Returns the kind of the field.\n    ///\n    /// This is either a direct layout bound\n    /// or another recursive layout sub-struct.\n    pub fn layout(&self) -> &Layout<F> {\n        &self.layout\n    }\n}\n\nimpl IntoPortable for FieldLayout {\n    type Output = FieldLayout<PortableForm>;\n\n    fn into_portable(self, registry: &mut Registry) -> Self::Output {\n        FieldLayout {\n            name: self.name.map(|name| name.into_portable(registry)),\n            layout: self.layout.into_portable(registry),\n        }\n    }\n}\n\n/// The discriminant of an enum variant.\n#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]\npub struct Discriminant(usize);\n\nimpl From<usize> for Discriminant {\n    fn from(value: usize) -> Self {\n        Self(value)\n    }\n}\n\nimpl Discriminant {\n    /// Returns the value of the discriminant\n    pub fn value(&self) -> usize {\n        self.0\n    }\n}\n\n/// An enum storage layout.\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]\n#[serde(bound(\n    serialize = \"F::Type: Serialize, F::String: Serialize\",\n    deserialize = \"F::Type: DeserializeOwned, F::String: DeserializeOwned\"\n))]\n#[serde(rename_all = \"camelCase\")]\npub struct EnumLayout<F: Form = MetaForm> {\n    /// The key where the discriminant is stored to dispatch the variants.\n    dispatch_key: LayoutKey,\n    /// The variants of the enum.\n    variants: BTreeMap<Discriminant, StructLayout<F>>,\n}\n\nimpl EnumLayout {\n    /// Creates a new enum layout.\n    pub fn new<K, V>(dispatch_key: K, variants: V) -> Self\n    where\n        K: Into<LayoutKey>,\n        V: IntoIterator<Item = (Discriminant, StructLayout)>,\n    {\n        Self {\n            dispatch_key: dispatch_key.into(),\n            variants: variants.into_iter().collect(),\n        }\n    }\n}\n\nimpl<F> EnumLayout<F>\nwhere\n    F: Form,\n{\n    /// Returns the key where the discriminant is stored to dispatch the variants.\n    pub fn dispatch_key(&self) -> &LayoutKey {\n        &self.dispatch_key\n    }\n\n    /// Returns the variants of the enum.\n    pub fn variants(&self) -> &BTreeMap<Discriminant, StructLayout<F>> {\n        &self.variants\n    }\n}\n\nimpl IntoPortable for EnumLayout {\n    type Output = EnumLayout<PortableForm>;\n\n    fn into_portable(self, registry: &mut Registry) -> Self::Output {\n        EnumLayout {\n            dispatch_key: self.dispatch_key,\n            variants: self\n                .variants\n                .into_iter()\n                .map(|(discriminant, layout)| {\n                    (discriminant, layout.into_portable(registry))\n                })\n                .collect(),\n        }\n    }\n}\n"],["945","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::serde_hex;\n\n/// Serializes the given bytes as byte string.\npub fn serialize_as_byte_str<S>(bytes: &[u8], serializer: S) -> Result<S::Ok, S::Error>\nwhere\n    S: serde::Serializer,\n{\n    if bytes.is_empty() {\n        // Return empty string without prepended `0x`.\n        return serializer.serialize_str(\"\")\n    }\n    serde_hex::serialize(bytes, serializer)\n}\n\n/// Deserializes the given hex string with optional `0x` prefix.\npub fn deserialize_from_byte_str<'de, D>(deserializer: D) -> Result<Vec<u8>, D::Error>\nwhere\n    D: serde::Deserializer<'de>,\n{\n    struct Visitor;\n\n    impl<'b> serde::de::Visitor<'b> for Visitor {\n        type Value = Vec<u8>;\n\n        fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {\n            write!(formatter, \"hex string with optional 0x prefix\")\n        }\n\n        fn visit_str<E: serde::de::Error>(self, v: &str) -> Result<Self::Value, E> {\n            let result = if v.starts_with(\"0x\") {\n                serde_hex::from_hex(v)\n            } else {\n                serde_hex::from_hex(&format!(\"0x{}\", v))\n            };\n            result.map_err(E::custom)\n        }\n\n        fn visit_string<E: serde::de::Error>(self, v: String) -> Result<Self::Value, E> {\n            self.visit_str(&v)\n        }\n    }\n\n    deserializer.deserialize_str(Visitor)\n}\n"],["946","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::*;\nuse pretty_assertions::assert_eq;\nuse scale_info::{\n    IntoPortable,\n    Registry,\n};\nuse serde_json::json;\n\n#[test]\nfn spec_constructor_selector_must_serialize_to_hex() {\n    // given\n    let name = \"foo\";\n    let cs = ConstructorSpec::from_name(name)\n        .selector(123_456_789u32.to_be_bytes())\n        .done();\n    let mut registry = Registry::new();\n    let portable_spec = cs.into_portable(&mut registry);\n\n    // when\n    let json = serde_json::to_value(&portable_spec).unwrap();\n    let deserialized: ConstructorSpec<PortableForm> =\n        serde_json::from_value(json.clone()).unwrap();\n\n    // then\n    assert_eq!(\n        json,\n        json!({\n            \"name\": [\"foo\"],\n            \"selector\": \"0x075bcd15\",\n            \"args\": [],\n            \"docs\": []\n        })\n    );\n    assert_eq!(deserialized.selector, portable_spec.selector);\n}\n\n#[test]\nfn spec_contract_json() {\n    // given\n    let contract: ContractSpec = ContractSpec::new()\n        .constructors(vec![\n            ConstructorSpec::from_name(\"new\")\n                .selector([94u8, 189u8, 136u8, 214u8])\n                .args(vec![MessageParamSpec::new(\"init_value\")\n                    .of_type(TypeSpec::with_name_segs::<i32, _>(\n                        vec![\"i32\"].into_iter().map(AsRef::as_ref),\n                    ))\n                    .done()])\n                .docs(Vec::new())\n                .done(),\n            ConstructorSpec::from_name(\"default\")\n                .selector([2u8, 34u8, 255u8, 24u8])\n                .args(Vec::new())\n                .docs(Vec::new())\n                .done(),\n        ])\n        .messages(vec![\n            MessageSpec::from_name(\"inc\")\n                .selector([231u8, 208u8, 89u8, 15u8])\n                .mutates(true)\n                .payable(true)\n                .args(vec![MessageParamSpec::new(\"by\")\n                    .of_type(TypeSpec::with_name_segs::<i32, _>(\n                        vec![\"i32\"].into_iter().map(AsRef::as_ref),\n                    ))\n                    .done()])\n                .docs(Vec::new())\n                .returns(ReturnTypeSpec::new(None))\n                .done(),\n            MessageSpec::from_name(\"get\")\n                .selector([37u8, 68u8, 74u8, 254u8])\n                .mutates(false)\n                .payable(false)\n                .args(Vec::new())\n                .docs(Vec::new())\n                .returns(ReturnTypeSpec::new(TypeSpec::with_name_segs::<i32, _>(\n                    vec![\"i32\"].into_iter().map(AsRef::as_ref),\n                )))\n                .done(),\n        ])\n        .events(Vec::new())\n        .docs(Vec::new())\n        .done();\n\n    let mut registry = Registry::new();\n\n    // when\n    let json = serde_json::to_value(&contract.into_portable(&mut registry)).unwrap();\n\n    // then\n    assert_eq!(\n        json,\n        json!({\n            \"constructors\": [\n                {\n                    \"args\": [\n                        {\n                            \"name\": \"init_value\",\n                            \"type\": {\n                                \"displayName\": [\n                                    \"i32\"\n                                ],\n                                \"type\": 1\n                            }\n                        }\n                    ],\n                    \"docs\": [],\n                    \"name\": [\"new\"],\n                    \"selector\": \"0x5ebd88d6\"\n                },\n                {\n                    \"args\": [],\n                    \"docs\": [],\n                    \"name\": [\"default\"],\n                    \"selector\": \"0x0222ff18\"\n                }\n            ],\n            \"docs\": [],\n            \"events\": [],\n            \"messages\": [\n                {\n                    \"args\": [\n                        {\n                            \"name\": \"by\",\n                            \"type\": {\n                                \"displayName\": [\n                                    \"i32\"\n                                ],\n                                \"type\": 1\n                            }\n                        }\n                    ],\n                    \"docs\": [],\n                    \"mutates\": true,\n                    \"payable\": true,\n                    \"name\": [\"inc\"],\n                    \"returnType\": null,\n                    \"selector\": \"0xe7d0590f\"\n                },\n                {\n                    \"args\": [],\n                    \"docs\": [],\n                    \"mutates\": false,\n                    \"payable\": false,\n                    \"name\": [\"get\"],\n                    \"returnType\": {\n                        \"displayName\": [\n                            \"i32\"\n                        ],\n                        \"type\": 1\n                    },\n                    \"selector\": \"0x25444afe\"\n                }\n            ],\n        })\n    )\n}\n\n#[test]\nfn trim_docs() {\n    // given\n    let name = \"foo\";\n    let cs = ConstructorSpec::from_name(name)\n        .selector(123_456_789u32.to_be_bytes())\n        .docs(vec![\" foobar      \"])\n        .done();\n    let mut registry = Registry::new();\n    let compact_spec = cs.into_portable(&mut registry);\n\n    // when\n    let json = serde_json::to_value(&compact_spec).unwrap();\n    let deserialized: ConstructorSpec<PortableForm> =\n        serde_json::from_value(json.clone()).unwrap();\n\n    // then\n    assert_eq!(\n        json,\n        json!({\n            \"name\": [\"foo\"],\n            \"selector\": \"0x075bcd15\",\n            \"args\": [],\n            \"docs\": [\"foobar\"]\n        })\n    );\n    assert_eq!(deserialized.docs, compact_spec.docs);\n}\n"],["947","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::Key;\n\n/// A key pointer.\n///\n/// This wraps a base key and provides an interface to mimic pointer arithmetics.\n/// Mainly used to coordinate keys through static storage structures.\n#[derive(Debug, Copy, Clone, Eq, PartialEq)]\npub struct KeyPtr {\n    /// The underlying offset key.\n    key: Key,\n    /// The last shift performed.\n    last_shift: u64,\n}\n\nimpl From<Key> for KeyPtr {\n    #[inline]\n    fn from(key: Key) -> Self {\n        Self { key, last_shift: 0 }\n    }\n}\n\nimpl KeyPtr {\n    /// Advances the key pointer by the given amount and returns the old value.\n    #[inline]\n    pub fn advance_by(&mut self, new_shift: u64) -> &Key {\n        let old_shift = core::mem::replace(&mut self.last_shift, new_shift);\n        self.key += old_shift;\n        &self.key\n    }\n\n    /// Returns the underlying offset key.\n    pub fn key(&self) -> &Key {\n        &self.key\n    }\n}\n"],["948","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse core::{\n    fmt,\n    ops::{\n        Add,\n        AddAssign,\n    },\n};\n\n/// Key into contract storage.\n///\n/// Used to identify contract storage cells for read and write operations.\n/// Can be compared to a raw pointer and features simple pointer arithmetic.\n///\n/// # Note\n///\n/// This is the most low-level primitive to identify contract storage cells.\n///\n/// # Unsafe\n///\n/// Prefer using high-level types found in `ink_storage` to operate on the contract\n/// storage.\n#[derive(Copy, Default, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[repr(transparent)]\npub struct Key([u64; 4]);\n\nimpl Key {\n    fn write_bytes(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"0x\")?;\n        for limb in &self.0 {\n            write!(f, \"_\")?;\n            for byte in &limb.to_le_bytes() {\n                write!(f, \"{:02X}\", byte)?;\n            }\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Debug for Key {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"Key(\")?;\n        self.write_bytes(f)?;\n        write!(f, \")\")?;\n        Ok(())\n    }\n}\n\nimpl fmt::Display for Key {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.write_bytes(f)\n    }\n}\n\nimpl From<[u8; 32]> for Key {\n    #[inline]\n    fn from(bytes: [u8; 32]) -> Self {\n        if cfg!(target_endian = \"little\") {\n            // SAFETY: If the machine has little endian byte ordering we can\n            //         simply transmute the input bytes into the correct `u64`\n            //         byte ordering for the `Key` data structure. Otherwise\n            //         we have to manually convert them via the\n            //         `from_bytes_be_fallback` procedure.\n            //\n            // We decided to have the little endian as default format for Key\n            // instance since WebAssembly dictates little endian byte ordering\n            // for the execution environment.\n            Self(unsafe { ::core::mem::transmute::<[u8; 32], [u64; 4]>(bytes) })\n        } else {\n            Self::from_bytes_be_fallback(bytes)\n        }\n    }\n}\n\nimpl Key {\n    /// Creates a new key from the given bytes.\n    ///\n    /// # Note\n    ///\n    /// This is a fallback procedure in case the target machine does not have\n    /// little endian byte ordering.\n    #[inline]\n    fn from_bytes_be_fallback(bytes: [u8; 32]) -> Self {\n        #[inline]\n        fn carve_out_u64_bytes(bytes: &[u8; 32], offset: u8) -> [u8; 8] {\n            let o = (offset * 8) as usize;\n            [\n                bytes[o],\n                bytes[o + 1],\n                bytes[o + 2],\n                bytes[o + 3],\n                bytes[o + 4],\n                bytes[o + 5],\n                bytes[o + 6],\n                bytes[o + 7],\n            ]\n        }\n        Self([\n            u64::from_le_bytes(carve_out_u64_bytes(&bytes, 0)),\n            u64::from_le_bytes(carve_out_u64_bytes(&bytes, 1)),\n            u64::from_le_bytes(carve_out_u64_bytes(&bytes, 2)),\n            u64::from_le_bytes(carve_out_u64_bytes(&bytes, 3)),\n        ])\n    }\n\n    /// Tries to return the underlying bytes as slice.\n    ///\n    /// This only returns `Some` if the execution environment has little-endian\n    /// byte order.\n    pub fn try_as_bytes(&self) -> Option<&[u8; 32]> {\n        if cfg!(target_endian = \"little\") {\n            return Some(self.as_bytes())\n        }\n        None\n    }\n\n    /// Returns the underlying bytes of the key.\n    ///\n    /// This only works and is supported if the target machine has little-endian\n    /// byte ordering. Use [`Key::try_as_bytes`] as a general procedure instead.\n    #[cfg(target_endian = \"little\")]\n    pub fn as_bytes(&self) -> &[u8; 32] {\n        // SAFETY: This pointer cast is possible since the outer struct\n        //         (Key) is `repr(transparent)` and since we restrict\n        //         ourselves to little-endian byte ordering. In any other\n        //         case this is invalid which is why return `None` as\n        //         fallback.\n        unsafe { &*(&self.0 as *const [u64; 4] as *const [u8; 32]) }\n    }\n}\n\nimpl scale::Encode for Key {\n    #[inline(always)]\n    fn size_hint(&self) -> usize {\n        32\n    }\n\n    #[inline]\n    fn encode_to<T: scale::Output + ?Sized>(&self, dest: &mut T) {\n        if cfg!(target_endian = \"little\") {\n            dest.write(self.try_as_bytes().expect(\"little endian is asserted\"))\n        } else {\n            dest.write(&self.to_bytes())\n        }\n    }\n}\n\nimpl scale::Decode for Key {\n    #[inline]\n    fn decode<I: scale::Input>(input: &mut I) -> Result<Self, scale::Error> {\n        Ok(Self::from(<[u8; 32] as scale::Decode>::decode(input)?))\n    }\n}\n\n#[cfg(target_endian = \"little\")]\nimpl Key {\n    /// Returns the bytes that are representing the key.\n    #[inline]\n    pub fn to_bytes(&self) -> [u8; 32] {\n        if cfg!(target_endian = \"little\") {\n            // SAFETY: This pointer cast is possible since the outer struct\n            //         (Key) is `repr(transparent)` and since we restrict\n            //         ourselves to little-endian byte ordering. In any other\n            //         case this is invalid which is why return `None` as\n            //         fallback.\n            unsafe { core::mem::transmute::<[u64; 4], [u8; 32]>(self.0) }\n        } else {\n            self.to_bytes_be_fallback()\n        }\n    }\n\n    /// Fallback big-endian procedure to return the underlying bytes of `self`.\n    fn to_bytes_be_fallback(&self) -> [u8; 32] {\n        let mut result = [0x00; 32];\n        for i in 0..4 {\n            let o = i * 8;\n            result[o..(o + 8)].copy_from_slice(&self.0[i].to_le_bytes());\n        }\n        result\n    }\n}\n\nimpl Add<u64> for Key {\n    type Output = Key;\n\n    fn add(mut self, rhs: u64) -> Self::Output {\n        self += rhs;\n        self\n    }\n}\n\nimpl<'a> Add<u64> for &'a Key {\n    type Output = Key;\n\n    fn add(self, rhs: u64) -> Self::Output {\n        <Key as Add<u64>>::add(*self, rhs)\n    }\n}\n\nimpl<'a> Add<&'a u64> for Key {\n    type Output = Key;\n\n    fn add(self, rhs: &'a u64) -> Self::Output {\n        <Key as Add<u64>>::add(self, *rhs)\n    }\n}\n\nimpl<'a, 'b> Add<&'b u64> for &'a Key {\n    type Output = Key;\n\n    fn add(self, rhs: &'b u64) -> Self::Output {\n        <&'a Key as Add<u64>>::add(self, *rhs)\n    }\n}\n\n#[cfg(feature = \"std\")]\nconst _: () = {\n    use scale_info::{\n        build::Fields,\n        Path,\n        Type,\n        TypeInfo,\n    };\n\n    impl TypeInfo for Key {\n        type Identity = Self;\n\n        fn type_info() -> Type {\n            Type::builder()\n                .path(Path::new(\"Key\", \"ink_primitives\"))\n                .composite(Fields::unnamed().field_of::<[u8; 32]>(\"[u8; 32]\"))\n        }\n    }\n};\n\nimpl AddAssign<u64> for Key {\n    #[inline]\n    #[rustfmt::skip]\n    fn add_assign(&mut self, rhs: u64) {\n        let (res_0,  ovfl_0) = self.0[0].overflowing_add(rhs);\n        let (res_1,  ovfl_1) = self.0[1].overflowing_add(ovfl_0 as u64);\n        let (res_2,  ovfl_2) = self.0[2].overflowing_add(ovfl_1 as u64);\n        let (res_3, _ovfl_3) = self.0[3].overflowing_add(ovfl_2 as u64);\n        self.0[0] = res_0;\n        self.0[1] = res_1;\n        self.0[2] = res_2;\n        self.0[3] = res_3;\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn test_bytes() -> [u8; 32] {\n        *b\"\\\n            \\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\\n            \\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x0E\\x0F\\\n            \\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\\n            \\x18\\x19\\x1A\\x1B\\x1C\\x1D\\x1E\\x1F\\\n        \"\n    }\n\n    #[test]\n    fn default_works() {\n        assert_eq!(<Key as Default>::default().to_bytes(), [0x00; 32]);\n    }\n\n    #[test]\n    fn debug_works() {\n        let key = Key::from(test_bytes());\n        assert_eq!(\n            format!(\"{:?}\", key),\n            String::from(\n                \"Key(0x\\\n                    _0001020304050607\\\n                    _08090A0B0C0D0E0F\\\n                    _1011121314151617\\\n                    _18191A1B1C1D1E1F\\\n                )\"\n            ),\n        );\n    }\n\n    #[test]\n    #[rustfmt::skip]\n    fn from_works() {\n        let test_bytes = test_bytes();\n        assert_eq!(Key::from(test_bytes).to_bytes(), test_bytes);\n        assert_eq!(Key::from_bytes_be_fallback(test_bytes).to_bytes(), test_bytes);\n        assert_eq!(Key::from(test_bytes).to_bytes_be_fallback(), test_bytes);\n        assert_eq!(Key::from_bytes_be_fallback(test_bytes).to_bytes_be_fallback(), test_bytes);\n    }\n\n    #[test]\n    fn add_one_to_zero() {\n        let bytes = [0x00; 32];\n        let expected = {\n            let mut bytes = [0x00; 32];\n            bytes[0] = 0x01;\n            bytes\n        };\n        let mut key = Key::from(bytes);\n        key.add_assign(1u64);\n        assert_eq!(key.to_bytes(), expected);\n    }\n\n    #[test]\n    fn add_with_ovfl() {\n        let bytes = *b\"\\\n            \\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\\n            \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\\n            \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\\n            \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\\n        \";\n        let expected = {\n            let mut expected = [0x00; 32];\n            expected[8] = 0x01;\n            expected\n        };\n        let mut key = Key::from(bytes);\n        key.add_assign(1u64);\n        assert_eq!(key.to_bytes(), expected);\n    }\n\n    #[test]\n    fn add_with_ovfl_2() {\n        let bytes = *b\"\\\n            \\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\\n            \\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\\n            \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\\n            \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\\n        \";\n        let expected = {\n            let mut expected = [0x00; 32];\n            expected[16] = 0x01;\n            expected\n        };\n        let mut key = Key::from(bytes);\n        key.add_assign(1u64);\n        assert_eq!(key.to_bytes(), expected);\n    }\n\n    #[test]\n    fn add_with_ovfl_3() {\n        let bytes = *b\"\\\n            \\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\\n            \\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\\n            \\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\\n            \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\\n        \";\n        let expected = {\n            let mut expected = [0x00; 32];\n            expected[24] = 0x01;\n            expected\n        };\n        let mut key = Key::from(bytes);\n        key.add_assign(1u64);\n        assert_eq!(key.to_bytes(), expected);\n    }\n\n    #[test]\n    fn add_with_wrap() {\n        let bytes = [0xFF; 32];\n        let expected = [0x00; 32];\n        let mut key = Key::from(bytes);\n        key.add_assign(1u64);\n        assert_eq!(key.to_bytes(), expected);\n    }\n\n    #[test]\n    fn add_assign_to_zero() {\n        for test_value in &[0_u64, 1, 42, 10_000, u32::MAX as u64, u64::MAX] {\n            let mut key = <Key as Default>::default();\n            let expected = {\n                let mut expected = [0x00; 32];\n                expected[0..8].copy_from_slice(&test_value.to_le_bytes());\n                expected\n            };\n            key.add_assign(*test_value);\n            assert_eq!(key.to_bytes(), expected);\n        }\n    }\n}\n"],["949","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::traits::{\n    clear_spread_root,\n    forward_clear_packed,\n    forward_pull_packed,\n    forward_push_packed,\n    KeyPtr,\n    PackedLayout,\n    SpreadLayout,\n};\nuse ink_prelude::vec::Vec;\nuse ink_primitives::Key;\n\n/// Packs the inner `T` so that it only occupies a single contract storage cell.\n///\n/// # Note\n///\n/// This is an important modular building stone in order to manage contract\n/// storage occupation. By default types try to distribute themselves onto\n/// their respective contract storage area. However, upon packing them into\n/// `Pack<T>` they will be compressed to only ever make use of a single\n/// contract storage cell. Sometimes this can be advantageous for performance\n/// reasons.\n///\n/// # Usage\n///\n/// - A `Pack<i32>` is equivalent to `i32` in its storage occupation.\n/// - A `Pack<(i32, i32)>` will occupy a single cell compared to `(i32, i32)`\n///   which occupies a cell per `i32`.\n/// - A `Lazy<Pack<[u8; 8]>>` lazily loads a `Pack<[u8; 8]>` which occupies\n///   a single cell whereas a `[u8; 8]` would occupy 8 cells in total - one for\n///   each `u8`.\n/// - Rust collections will never use more than a single cell. So\n///   `Pack<LinkedList<T>>` and `LinkedList<T>` will occupy the same amount of\n///   cells, namely 1.\n/// - Packs can be packed. So for example a\n///   `Pack<(Pack<(i32, i32)>, Pack<[u8; 8]>)` uses just one cell instead of\n///   two cells which is the case for `(Pack<(i32, i32)>, Pack<[u8; 8]>)`.\n/// - Not all `storage` types can be packed. Only those that are implementing\n///   the `PackedLayout` trait. For example `storage::Vec<T>` does not implement\n///   this trait and thus cannot be packed.\n///\n/// As a general advice pack values together that are frequently used together.\n/// Also pack many very small elements (e.g. `u8`, `bool`, `u16`) together.\n#[derive(Debug, Clone)]\npub struct Pack<T>\nwhere\n    T: PackedLayout,\n{\n    /// The packed `T` value.\n    inner: T,\n    /// The key to load the packed value from.\n    ///\n    /// # Note\n    ///\n    /// This can be `None` on contract initialization, but will be\n    /// initialized with a concrete value on `pull_spread`.\n    key: Option<Key>,\n}\n\nimpl<T> scale::Encode for Pack<T>\nwhere\n    T: scale::Encode + PackedLayout,\n{\n    #[inline]\n    fn size_hint(&self) -> usize {\n        <T as scale::Encode>::size_hint(&self.inner)\n    }\n\n    #[inline]\n    fn encode_to<O: scale::Output + ?Sized>(&self, dest: &mut O) {\n        <T as scale::Encode>::encode_to(&self.inner, dest)\n    }\n\n    #[inline]\n    fn encode(&self) -> Vec<u8> {\n        <T as scale::Encode>::encode(&self.inner)\n    }\n\n    #[inline]\n    fn using_encoded<R, F: FnOnce(&[u8]) -> R>(&self, f: F) -> R {\n        <T as scale::Encode>::using_encoded(&self.inner, f)\n    }\n}\n\nimpl<T> scale::Decode for Pack<T>\nwhere\n    T: scale::Decode + PackedLayout,\n{\n    fn decode<I: scale::Input>(input: &mut I) -> Result<Self, scale::Error> {\n        Ok(Self::new(<T as scale::Decode>::decode(input)?))\n    }\n}\n\nimpl<T> Pack<T>\nwhere\n    T: PackedLayout,\n{\n    /// Creates a new packed value.\n    pub fn new(value: T) -> Self {\n        Self {\n            inner: value,\n            key: None,\n        }\n    }\n\n    /// Returns a shared reference to the packed value.\n    pub fn as_inner(pack: &Pack<T>) -> &T {\n        &pack.inner\n    }\n\n    /// Returns an exclusive reference to the packed value.\n    pub fn as_inner_mut(pack: &mut Pack<T>) -> &mut T {\n        &mut pack.inner\n    }\n}\n\nimpl<T> Drop for Pack<T>\nwhere\n    T: PackedLayout,\n{\n    fn drop(&mut self) {\n        if let Some(key) = self.key {\n            clear_spread_root::<T>(&self.inner, &key)\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nconst _: () = {\n    use crate::traits::StorageLayout;\n    use ink_metadata::layout::{\n        CellLayout,\n        Layout,\n        LayoutKey,\n    };\n    use scale_info::TypeInfo;\n\n    impl<T> StorageLayout for Pack<T>\n    where\n        T: PackedLayout + TypeInfo + 'static,\n    {\n        fn layout(key_ptr: &mut KeyPtr) -> Layout {\n            Layout::Cell(CellLayout::new::<T>(LayoutKey::from(key_ptr.advance_by(1))))\n        }\n    }\n};\n\nimpl<T> SpreadLayout for Pack<T>\nwhere\n    T: PackedLayout,\n{\n    const FOOTPRINT: u64 = 1;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        let inner = forward_pull_packed::<T>(ptr);\n        Self {\n            inner,\n            key: Some(*ptr.key()),\n        }\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        forward_push_packed::<T>(Self::as_inner(self), ptr)\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        forward_clear_packed::<T>(Self::as_inner(self), ptr)\n    }\n}\n\nimpl<T> PackedLayout for Pack<T>\nwhere\n    T: PackedLayout,\n{\n    fn pull_packed(&mut self, at: &Key) {\n        <T as PackedLayout>::pull_packed(Self::as_inner_mut(self), at)\n    }\n    fn push_packed(&self, at: &Key) {\n        <T as PackedLayout>::push_packed(Self::as_inner(self), at)\n    }\n    fn clear_packed(&self, at: &Key) {\n        <T as PackedLayout>::clear_packed(Self::as_inner(self), at)\n    }\n}\n\nimpl<T> From<T> for Pack<T>\nwhere\n    T: PackedLayout,\n{\n    fn from(value: T) -> Self {\n        Self::new(value)\n    }\n}\n\nimpl<T> Default for Pack<T>\nwhere\n    T: Default + PackedLayout,\n{\n    fn default() -> Self {\n        Self::new(Default::default())\n    }\n}\n\nimpl<T> core::ops::Deref for Pack<T>\nwhere\n    T: PackedLayout,\n{\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        Self::as_inner(self)\n    }\n}\n\nimpl<T> core::ops::DerefMut for Pack<T>\nwhere\n    T: PackedLayout,\n{\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        Self::as_inner_mut(self)\n    }\n}\n\nimpl<T> core::cmp::PartialEq for Pack<T>\nwhere\n    T: PartialEq + PackedLayout,\n{\n    fn eq(&self, other: &Self) -> bool {\n        PartialEq::eq(Self::as_inner(self), Self::as_inner(other))\n    }\n}\n\nimpl<T> core::cmp::Eq for Pack<T> where T: Eq + PackedLayout {}\n\nimpl<T> core::cmp::PartialOrd for Pack<T>\nwhere\n    T: PartialOrd + PackedLayout,\n{\n    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n        PartialOrd::partial_cmp(Self::as_inner(self), Self::as_inner(other))\n    }\n    fn lt(&self, other: &Self) -> bool {\n        PartialOrd::lt(Self::as_inner(self), Self::as_inner(other))\n    }\n    fn le(&self, other: &Self) -> bool {\n        PartialOrd::le(Self::as_inner(self), Self::as_inner(other))\n    }\n    fn ge(&self, other: &Self) -> bool {\n        PartialOrd::ge(Self::as_inner(self), Self::as_inner(other))\n    }\n    fn gt(&self, other: &Self) -> bool {\n        PartialOrd::gt(Self::as_inner(self), Self::as_inner(other))\n    }\n}\n\nimpl<T> core::cmp::Ord for Pack<T>\nwhere\n    T: core::cmp::Ord + PackedLayout,\n{\n    fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n        Ord::cmp(Self::as_inner(self), Self::as_inner(other))\n    }\n}\n\nimpl<T> core::fmt::Display for Pack<T>\nwhere\n    T: core::fmt::Display + PackedLayout,\n{\n    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n        core::fmt::Display::fmt(Self::as_inner(self), f)\n    }\n}\n\nimpl<T> core::hash::Hash for Pack<T>\nwhere\n    T: core::hash::Hash + PackedLayout,\n{\n    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {\n        Self::as_inner(self).hash(state);\n    }\n}\n\nimpl<T> core::convert::AsRef<T> for Pack<T>\nwhere\n    T: PackedLayout,\n{\n    fn as_ref(&self) -> &T {\n        Self::as_inner(self)\n    }\n}\n\nimpl<T> core::convert::AsMut<T> for Pack<T>\nwhere\n    T: PackedLayout,\n{\n    fn as_mut(&mut self) -> &mut T {\n        Self::as_inner_mut(self)\n    }\n}\n\nimpl<T> ink_prelude::borrow::Borrow<T> for Pack<T>\nwhere\n    T: PackedLayout,\n{\n    fn borrow(&self) -> &T {\n        Self::as_inner(self)\n    }\n}\n\nimpl<T> ink_prelude::borrow::BorrowMut<T> for Pack<T>\nwhere\n    T: PackedLayout,\n{\n    fn borrow_mut(&mut self) -> &mut T {\n        Self::as_inner_mut(self)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Pack;\n    use crate::traits::{\n        pull_packed_root,\n        push_packed_root,\n        KeyPtr,\n        PackedLayout,\n        SpreadLayout,\n    };\n    use core::{\n        cmp::Ordering,\n        convert::{\n            AsMut,\n            AsRef,\n        },\n        ops::{\n            Deref,\n            DerefMut,\n        },\n    };\n    use ink_env::test::DefaultAccounts;\n    use ink_prelude::borrow::{\n        Borrow,\n        BorrowMut,\n    };\n    use ink_primitives::Key;\n\n    type ComplexTuple = (u8, [i32; 4], (bool, i32));\n\n    fn complex_value() -> ComplexTuple {\n        (b'A', [0x00; 4], (true, 42))\n    }\n\n    #[test]\n    fn new_works() {\n        let mut expected = complex_value();\n        let mut pack = Pack::new(expected);\n        assert_eq!(<Pack<_> as Deref>::deref(&pack), &expected);\n        assert_eq!(<Pack<_> as DerefMut>::deref_mut(&mut pack), &mut expected);\n        assert_eq!(<Pack<_> as AsRef<_>>::as_ref(&pack), &expected);\n        assert_eq!(<Pack<_> as AsMut<_>>::as_mut(&mut pack), &mut expected);\n        assert_eq!(Borrow::<ComplexTuple>::borrow(&pack), &expected);\n        assert_eq!(\n            BorrowMut::<ComplexTuple>::borrow_mut(&mut pack),\n            &mut expected\n        );\n        assert_eq!(Pack::as_inner(&pack), &expected);\n        assert_eq!(Pack::as_inner_mut(&mut pack), &mut expected);\n        assert_eq!(pack.inner, expected);\n    }\n\n    #[test]\n    fn from_works() {\n        let mut expected = complex_value();\n        let mut from = Pack::from(expected);\n        assert_eq!(from, Pack::new(expected));\n        assert_eq!(Pack::as_inner(&from), &expected);\n        assert_eq!(Pack::as_inner_mut(&mut from), &mut expected);\n        assert_eq!(from.inner, expected);\n    }\n\n    #[test]\n    fn default_works() {\n        use core::fmt::Debug;\n        fn assert_default<T>()\n        where\n            T: Debug + Default + PartialEq + PackedLayout,\n        {\n            let pack_default = <Pack<T> as Default>::default();\n            assert_eq!(pack_default.inner, <T as Default>::default());\n        }\n        assert_default::<bool>();\n        assert_default::<u8>();\n        assert_default::<Option<i32>>();\n        assert_default::<Pack<[u8; 4]>>();\n    }\n\n    #[test]\n    fn partial_eq_works() {\n        let b1 = Pack::new(b'X');\n        let b2 = Pack::new(b'Y');\n        let b3 = Pack::new(b'X');\n        assert!(<Pack<u8> as PartialEq>::ne(&b1, &b2));\n        assert!(<Pack<u8> as PartialEq>::eq(&b1, &b3));\n    }\n\n    #[test]\n    fn partial_ord_works() {\n        let b1 = Pack::new(1);\n        let b2 = Pack::new(2);\n        let b3 = Pack::new(1);\n        assert_eq!(\n            <Pack<u8> as PartialOrd>::partial_cmp(&b1, &b2),\n            Some(Ordering::Less)\n        );\n        assert_eq!(\n            <Pack<u8> as PartialOrd>::partial_cmp(&b2, &b1),\n            Some(Ordering::Greater)\n        );\n        assert_eq!(\n            <Pack<u8> as PartialOrd>::partial_cmp(&b1, &b3),\n            Some(Ordering::Equal)\n        );\n        // Less-than\n        assert!(<Pack<u8> as PartialOrd>::lt(&b1, &b2));\n        // Less-than-or-equals\n        assert!(<Pack<u8> as PartialOrd>::le(&b1, &b2));\n        assert!(<Pack<u8> as PartialOrd>::le(&b1, &b3));\n        // Greater-than\n        assert!(<Pack<u8> as PartialOrd>::gt(&b2, &b1));\n        // Greater-than-or-equals\n        assert!(<Pack<u8> as PartialOrd>::ge(&b2, &b1));\n        assert!(<Pack<u8> as PartialOrd>::ge(&b3, &b1));\n    }\n\n    fn run_test<F>(f: F)\n    where\n        F: FnOnce(DefaultAccounts<ink_env::DefaultEnvironment>),\n    {\n        ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|default_accounts| {\n            f(default_accounts);\n            Ok(())\n        })\n        .unwrap()\n    }\n\n    #[test]\n    fn spread_layout_push_pull_works() {\n        run_test(|_| {\n            let p1 = Pack::new((b'A', [0x00; 4], (true, 42)));\n            assert_eq!(*p1, (b'A', [0x00; 4], (true, 42)));\n            let root_key = Key::from([0x42; 32]);\n            SpreadLayout::push_spread(&p1, &mut KeyPtr::from(root_key));\n            // Now load another instance of a pack from the same key and check\n            // if both instances are equal:\n            let p2 = SpreadLayout::pull_spread(&mut KeyPtr::from(root_key));\n            assert_eq!(p1, p2);\n        })\n    }\n\n    #[test]\n    #[should_panic(expected = \"storage entry was empty\")]\n    fn spread_layout_clear_works() {\n        run_test(|_| {\n            let p1 = Pack::new((b'A', [0x00; 4], (true, 42)));\n            assert_eq!(*p1, (b'A', [0x00; 4], (true, 42)));\n            let root_key = Key::from([0x42; 32]);\n            SpreadLayout::push_spread(&p1, &mut KeyPtr::from(root_key));\n            // Now load another instance of a pack from the same key and check\n            // if both instances are equal:\n            let p2 = SpreadLayout::pull_spread(&mut KeyPtr::from(root_key));\n            assert_eq!(p1, p2);\n            // Clearing the underlying storage of p2 immediately so that\n            // loading another instance of pack again should panic.\n            SpreadLayout::clear_spread(&p2, &mut KeyPtr::from(root_key));\n            let p3 = SpreadLayout::pull_spread(&mut KeyPtr::from(root_key));\n            assert_eq!(p1, p3);\n        })\n    }\n\n    #[test]\n    fn spread_and_packed_layout_are_equal() {\n        run_test(|_| {\n            // Push as spread, pull as packed:\n            let p1 = Pack::new((b'A', [0x00; 4], (true, 42)));\n            assert_eq!(*p1, (b'A', [0x00; 4], (true, 42)));\n            let root_key = Key::from([0x42; 32]);\n            SpreadLayout::push_spread(&p1, &mut KeyPtr::from(root_key));\n            let p2 = pull_packed_root::<Pack<(u8, [i32; 4], (bool, i32))>>(&root_key);\n            assert_eq!(p1, p2);\n            // Push as packed, pull as spread:\n            let root_key2 = Key::from([0x43; 32]);\n            push_packed_root(&p2, &root_key2);\n            let p3 = SpreadLayout::pull_spread(&mut KeyPtr::from(root_key2));\n            assert_eq!(p2, p3);\n        })\n    }\n}\n\n#[cfg(all(test, feature = \"std\", feature = \"ink-fuzz-tests\"))]\nuse quickcheck::{\n    Arbitrary,\n    Gen,\n};\n\n#[cfg(all(test, feature = \"std\", feature = \"ink-fuzz-tests\"))]\nimpl<T: Arbitrary + PackedLayout + Send + Clone + 'static> Arbitrary for Pack<T> {\n    fn arbitrary(g: &mut Gen) -> Pack<T> {\n        let a = <T as Arbitrary>::arbitrary(g);\n        Pack::new(a)\n    }\n}\n"],["950","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse core::ops::{\n    Index,\n    IndexMut,\n};\n\n/// Stores the number of set bits for each 256-bits block in a compact `u8`.\n#[derive(Debug, Default, PartialEq, Eq, scale::Encode, scale::Decode)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\npub struct CountFree {\n    /// Set bits per 256-bit chunk.\n    counts: [u8; 32],\n    /// Since with `u8` can only count up to 255 but there might be the need\n    /// to count up to 256 bits for 256-bit chunks we need to store one extra\n    /// bit per counter to determine filled chunks.\n    full: FullMask,\n}\n\nimpl Index<u8> for CountFree {\n    type Output = u8;\n\n    fn index(&self, index: u8) -> &Self::Output {\n        &self.counts[index as usize]\n    }\n}\n\nimpl IndexMut<u8> for CountFree {\n    fn index_mut(&mut self, index: u8) -> &mut Self::Output {\n        &mut self.counts[index as usize]\n    }\n}\n\n#[derive(Debug, Default, Copy, Clone, PartialEq, Eq, scale::Encode, scale::Decode)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\npub struct FullMask(u32);\n\nimpl FullMask {\n    /// Returns `true` if the 256-bit chunk at the given index is full.\n    pub fn is_full(self, index: u8) -> bool {\n        assert!(index < 32);\n        (self.0 >> (31 - index as u32)) & 0x01 == 1\n    }\n\n    /// Sets the flag for the 256-bit chunk at the given index to `full`.\n    pub fn set_full(&mut self, index: u8) {\n        self.0 |= 1_u32 << (31 - index as u32);\n    }\n\n    /// Resets the flag for the 256-bit chunk at the given index to not `full`.\n    pub fn reset_full(&mut self, index: u8) {\n        self.0 &= !(1_u32 << (31 - index as u32));\n    }\n}\n\nimpl CountFree {\n    /// Returns the position of the first free `u8` in the free counts.\n    ///\n    /// Returns `None` if all counts are `0xFF`.\n    pub fn position_first_zero(&self) -> Option<u8> {\n        let i = (!self.full.0).leading_zeros();\n        if i == 32 {\n            return None\n        }\n        Some(i as u8)\n    }\n\n    /// Increases the number of set bits for the given index.\n    ///\n    /// # Panics\n    ///\n    /// - If the given index is out of bounds.\n    /// - If the increment would cause an overflow.\n    pub fn inc(&mut self, index: usize) {\n        assert!(index < 32, \"index is out of bounds\");\n        if self.counts[index] == !0 {\n            self.full.set_full(index as u8);\n        } else {\n            self.counts[index] += 1;\n        }\n    }\n\n    /// Decreases the number of set bits for the given index.\n    ///\n    /// Returns the new number of set bits.\n    ///\n    /// # Panics\n    ///\n    /// - If the given index is out of bounds.\n    /// - If the decrement would cause an overflow.\n    pub fn dec(&mut self, index: u8) -> u8 {\n        assert!(index < 32, \"index is out of bounds\");\n        if self.full.is_full(index) {\n            self.full.reset_full(index);\n        } else {\n            let new_value = self.counts[index as usize]\n                .checked_sub(1)\n                .expect(\"set bits decrement overflowed\");\n            self.counts[index as usize] = new_value;\n        }\n        self.counts[index as usize]\n    }\n}\n"],["951","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::BitStash;\nuse crate::traits::{\n    KeyPtr,\n    SpreadLayout,\n};\nuse ink_primitives::Key;\n\ncfg_if::cfg_if! {\n    if #[cfg(miri)] {\n        // We need to lower the test allocations because miri's stacked borrows\n        // analysis currently is super linear for some work loads.\n        // Read more here: https://github.com/rust-lang/miri/issues/1367\n        const TEST_ALLOCATIONS: u32 = 10;\n    } else {\n        const TEST_ALLOCATIONS: u32 = 10_000;\n    }\n}\n\n#[test]\nfn default_works() {\n    let default = BitStash::default();\n    assert_eq!(default.get(0), None);\n}\n\n#[test]\nfn put_and_take_works() {\n    let mut default = BitStash::default();\n    assert_eq!(default.get(0), None);\n    assert_eq!(default.put(), 0);\n    assert_eq!(default.get(0), Some(true));\n    assert_eq!(default.take(0), Some(true));\n    assert_eq!(default.get(0), Some(false));\n}\n\n#[test]\nfn put_works() {\n    let mut default = BitStash::default();\n    for i in 0..TEST_ALLOCATIONS {\n        assert_eq!(default.get(i), None);\n        assert_eq!(default.put(), i);\n        assert_eq!(default.get(i), Some(true));\n    }\n}\n\nfn filled_bitstash() -> BitStash {\n    let mut default = BitStash::default();\n    for i in 0..TEST_ALLOCATIONS {\n        assert_eq!(default.put(), i);\n        assert_eq!(default.get(i), Some(true));\n    }\n    default\n}\n\n#[test]\nfn get_works() {\n    let mut default = filled_bitstash();\n    // Remove all bits at indices `(% 3 == 0)` and `(% 5 == 0)`.\n    for i in 0..TEST_ALLOCATIONS {\n        if i % 3 == 0 || i % 5 == 0 {\n            default.take(i);\n        }\n    }\n    for i in 0..TEST_ALLOCATIONS {\n        let expected = !(i % 3 == 0 || i % 5 == 0);\n        assert_eq!(default.get(i), Some(expected));\n    }\n}\n\n#[test]\nfn take_in_order_works() {\n    let mut default = filled_bitstash();\n    for i in 0..TEST_ALLOCATIONS {\n        assert_eq!(default.get(i), Some(true));\n        assert_eq!(default.take(i), Some(true));\n        assert_eq!(default.get(i), Some(false));\n    }\n}\n\n#[test]\nfn take_in_rev_order_works() {\n    let mut default = filled_bitstash();\n    for i in (0..TEST_ALLOCATIONS).rev() {\n        assert_eq!(default.get(i), Some(true));\n        assert_eq!(default.take(i), Some(true));\n        assert_eq!(default.get(i), Some(false));\n    }\n}\n\n#[test]\nfn take_refill_works() {\n    let mut default = filled_bitstash();\n    for i in 0..TEST_ALLOCATIONS {\n        assert_eq!(default.get(i), Some(true));\n        assert_eq!(default.take(i), Some(true));\n        assert_eq!(default.get(i), Some(false));\n        assert_eq!(default.put(), i);\n        assert_eq!(default.get(i), Some(true));\n    }\n}\n\n#[test]\nfn take_refill_rev_works() {\n    let mut default = filled_bitstash();\n    for i in (0..TEST_ALLOCATIONS).rev() {\n        assert_eq!(default.get(i), Some(true));\n        assert_eq!(default.take(i), Some(true));\n        assert_eq!(default.get(i), Some(false));\n        assert_eq!(default.put(), i);\n        assert_eq!(default.get(i), Some(true));\n    }\n}\n\n#[test]\nfn spread_layout_push_pull_works() {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let default = filled_bitstash();\n        let root_key = Key::from([0x42; 32]);\n        SpreadLayout::push_spread(&default, &mut KeyPtr::from(root_key));\n        let pulled = <BitStash as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n        assert_eq!(default, pulled);\n        Ok(())\n    })\n    .unwrap()\n}\n\n#[test]\n#[should_panic(expected = \"encountered empty storage cell\")]\nfn spread_layout_clear_works() {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let default = filled_bitstash();\n        // First push the instance to the contract storage.\n        // Then load a valid instance, check it and clear its associated storage.\n        // Afterwards load the invalid instance from the same storage region\n        // and try to interact with it which is expected to fail.\n        let root_key = Key::from([0x42; 32]);\n        SpreadLayout::push_spread(&default, &mut KeyPtr::from(root_key));\n        let pulled = <BitStash as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n        assert_eq!(default, pulled);\n        SpreadLayout::clear_spread(&pulled, &mut KeyPtr::from(root_key));\n        let invalid =\n            <BitStash as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n        // We have to prevent calling its destructor since that would also panic but\n        // in an uncontrollable way.\n        let mut invalid = core::mem::ManuallyDrop::new(invalid);\n        // Now interact with invalid instance.\n        let _ = invalid.put();\n        Ok(())\n    })\n    .unwrap()\n}\n"],["952","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::{\n    BitStash,\n    CountFree,\n};\nuse crate::{\n    collections::{\n        Bitvec as StorageBitvec,\n        Vec as StorageVec,\n    },\n    traits::{\n        forward_clear_packed,\n        forward_pull_packed,\n        forward_push_packed,\n        KeyPtr,\n        PackedLayout,\n        SpreadLayout,\n    },\n};\nuse ink_primitives::Key;\n\n#[cfg(feature = \"std\")]\nconst _: () = {\n    use crate::traits::StorageLayout;\n    use ink_metadata::layout::{\n        FieldLayout,\n        Layout,\n        StructLayout,\n    };\n\n    impl StorageLayout for BitStash {\n        fn layout(key_ptr: &mut KeyPtr) -> Layout {\n            Layout::Struct(StructLayout::new(vec![\n                FieldLayout::new(\n                    \"counts\",\n                    <StorageVec<CountFree> as StorageLayout>::layout(key_ptr),\n                ),\n                FieldLayout::new(\n                    \"elems\",\n                    <StorageBitvec as StorageLayout>::layout(key_ptr),\n                ),\n            ]))\n        }\n    }\n};\n\nimpl SpreadLayout for CountFree {\n    const FOOTPRINT: u64 = 1;\n    const REQUIRES_DEEP_CLEAN_UP: bool = false;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        forward_pull_packed::<Self>(ptr)\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        forward_push_packed::<Self>(self, ptr)\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        forward_clear_packed::<Self>(self, ptr)\n    }\n}\n\nimpl PackedLayout for CountFree {\n    fn pull_packed(&mut self, _at: &Key) {}\n    fn push_packed(&self, _at: &Key) {}\n    fn clear_packed(&self, _at: &Key) {}\n}\n\nimpl SpreadLayout for BitStash {\n    const FOOTPRINT: u64 = <StorageVec<CountFree> as SpreadLayout>::FOOTPRINT\n        + <StorageBitvec as SpreadLayout>::FOOTPRINT;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        Self {\n            counts: SpreadLayout::pull_spread(ptr),\n            free: SpreadLayout::pull_spread(ptr),\n        }\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        SpreadLayout::push_spread(&self.counts, ptr);\n        SpreadLayout::push_spread(&self.free, ptr);\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        SpreadLayout::clear_spread(&self.counts, ptr);\n        SpreadLayout::clear_spread(&self.free, ptr);\n    }\n}\n"],["953","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Storage bit stash data structure and utilities.\n//!\n//! Allows to compactly and efficiently put and take bits in a compressed\n//! and very efficient way.\n\nmod counts;\nmod storage;\n\n#[cfg(test)]\nmod tests;\n\n#[cfg(all(test, feature = \"ink-fuzz-tests\"))]\nmod fuzz_tests;\n\nuse self::counts::CountFree;\nuse crate::collections::{\n    Bitvec as StorageBitvec,\n    Vec as StorageVec,\n};\n\n/// The index type used in the storage bit stash.\ntype Index = u32;\n\n/// A stash for bits operating on the contract storage.\n///\n/// Allows to efficiently put and take bits and\n/// stores the underlying bits in an extremely compressed format.\n#[derive(Debug, Default, PartialEq, Eq)]\npub struct BitStash {\n    /// Counter for set bits in a 256-bit chunk of the `free` list.\n    ///\n    /// For every 256-bit chunk stored in `free` stores a `u8` that counts\n    /// the number of set bits in the 256-bit chunk. This information is used\n    /// to compact the information in `free` to make a `first fit` linear\n    /// search for a new free storage slot more scalable. Since `u8` can only\n    /// represent 256 different states but since we consider 0 we need an extra\n    /// 9th bit. This 9th bit tells for every 256-bit chunk if it is full.\n    ///\n    /// In theory it is possible to search up to 8192 storage cells for free\n    /// slots with a single contract storage look-up. By iterating over the 32\n    /// `CountFree` instances of a single instance.\n    counts: StorageVec<CountFree>,\n    /// Stores the underlying bits of the storage bit stash.\n    free: StorageBitvec,\n}\n\nimpl BitStash {\n    /// Creates a new storage bit stash.\n    pub fn new() -> Self {\n        Self {\n            counts: StorageVec::new(),\n            free: StorageBitvec::new(),\n        }\n    }\n\n    /// Returns the bit position of the first 256-bit chunk with zero bits\n    /// in the `free` list.\n    ///\n    /// Returns the bit position of the first bit in the 256-bit chunk and not\n    /// the chunk position since that's what\n    /// [`Bitvec::get_chunk`][`crate::collections::Bitvec::get_chunk`]\n    /// expects.\n    ///\n    /// Also directly increases the count of the first found free bit chunk.\n    fn position_first_zero(&mut self) -> Option<u64> {\n        // Iterate over the `counts` list of the bit stash.\n        // The counts list consists of packs of 32 counts per element.\n        for (n, counts) in self.counts.iter_mut().enumerate() {\n            if let Some(i) = counts.position_first_zero() {\n                counts.inc(i as usize);\n                let n = n as u64;\n                let i = i as u64;\n                return Some(n * (32 * 256) + i * 256)\n            }\n        }\n        None\n    }\n\n    /// Returns the number of required counts elements.\n    fn required_counts(&self) -> u32 {\n        let capacity = self.free.capacity();\n        if capacity == 0 {\n            return 0\n        }\n        1 + ((capacity - 1) / (32 * 256)) as u32\n    }\n\n    /// Returns `true` if the bit at the indexed slot is set (`1`).\n    ///\n    /// Returns `None` if the index is out of bounds.\n    pub fn get(&self, index: Index) -> Option<bool> {\n        self.free.get(index)\n    }\n\n    /// Puts another set bit into the storage bit stash.\n    ///\n    /// Returns the index to the slot where the set bit has been inserted.\n    pub fn put(&mut self) -> Index {\n        if let Some(index) = self.position_first_zero() {\n            if index == self.free.len() as u64 {\n                self.free.push(true);\n                return self.free.len() - 1\n            }\n            let mut bits256 = self\n                .free\n                .get_chunk_mut(index as u32)\n                .expect(\"must exist if indices have been found\");\n            if let Some(first_zero) = bits256.position_first_zero() {\n                bits256\n                    .get_mut(first_zero)\n                    .expect(\"first zero is invalid\")\n                    .set();\n                index as u32 + first_zero as u32\n            } else {\n                // We found a free storage slot but it isn't within the valid\n                // bounds of the free list but points to its end. So we simply\n                // append another 1 bit (`true`) to the free list and return\n                // a new index pointing to it. No need to push to the counts\n                // list in this case.\n                self.free.push(true);\n                self.free.len() - 1\n            }\n        } else {\n            // We found no free 256-bit slot:\n            //\n            // - Check if we already have allocated too many (2^32) bits and\n            // panic if that's the case. The check is done on the internal\n            // storage bit vector.\n            // - Otherwise allocate a new pack of 256-bits in the free list\n            // and mirror it in the counts list.\n            self.free.push(true);\n            if self.counts.len() < self.required_counts() {\n                // We need to push another counts element.\n                let mut counter = CountFree::default();\n                counter[0_u8] = 1;\n                self.counts.push(counter);\n            }\n            // Return the new slot.\n            self.free.len() - 1\n        }\n    }\n\n    /// Takes the bit from the given index and returns it.\n    ///\n    /// Returns `true` if the indexed bit was set (`1`).\n    /// Returns `None` if the index is out of bounds.\n    ///\n    /// # Note\n    ///\n    /// This frees up the indexed slot for putting in another set bit.\n    pub fn take(&mut self, index: Index) -> Option<bool> {\n        if index >= self.free.len() {\n            // Bail out early if index is out of bounds.\n            return None\n        }\n        let mut access = self.free.get_mut(index).expect(\"index is out of bounds\");\n        if !access.get() {\n            return Some(false)\n        }\n        // At this point the bit was found to be set (`true`) and we have\n        // update the underlying internals in order to reset it so the index\n        // becomes free for another bit again.\n        access.reset();\n        // Update the counts list.\n        let counts_id = index / (256 * 32);\n        let byte_id = ((index / 256) % 32) as u8;\n        self.counts\n            .get_mut(counts_id)\n            .expect(\"invalid counts ID\")\n            .dec(byte_id);\n        Some(true)\n    }\n}\n"],["954","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::BitStash;\n\n/// Conducts repeated insert and remove operations into the stash by iterating\n/// over `xs`. Typically the `xs` and `inserts_each` arguments are provided\n/// by our fuzzing engine in an iterative manner.\n///\n/// For each odd `x` in `xs` a number of put operations are executed.\n/// For each even `x` it is asserted that the previously inserted elements\n/// are in the stash and they are taken out subsequently.\n///\n/// The reasoning behind this even/odd sequence is to introduce some\n/// randomness into when elements are inserted/removed.\n///\n/// `inserts_each` was chosen as `u8` to keep the number of inserts per `x` in\n/// a reasonable range.\nfn put_and_take(xs: Vec<i32>, additional_puts_each: u8) {\n    let mut stash = BitStash::new();\n    let mut previous_even_x = None;\n    let mut last_put_indices = Vec::new();\n\n    for x in 0..xs.len() as u32 {\n        if x % 2 == 0 {\n            // On even numbers we put\n            let mut put_index = None;\n            for _ in 0..x + additional_puts_each as u32 {\n                let index = stash.put();\n                assert_eq!(stash.get(index), Some(true));\n                last_put_indices.push(index);\n                put_index = Some(index);\n            }\n            if previous_even_x.is_none() && put_index.is_some() {\n                previous_even_x = put_index;\n            }\n        } else if previous_even_x.is_some() {\n            // If it's an odd number and we inserted in a previous run we assert\n            // that the last insert worked correctly and remove the elements again.\n            //\n            // It can happen that after one insert run there are many more\n            // insert runs (i.e. more susbequent even `x` in `xs`) before we remove\n            // the numbers of the last run again. This is intentional, as to include\n            // testing if subsequent insert operations have an effect on already\n            // inserted items.\n            while let Some(index) = last_put_indices.pop() {\n                assert_eq!(stash.get(index), Some(true));\n                assert_eq!(stash.take(index), Some(true));\n                assert_eq!(stash.get(index), Some(false));\n            }\n            previous_even_x = None;\n        }\n    }\n}\n\n#[quickcheck]\nfn fuzz_repeated_puts_and_takes(xs: Vec<i32>, additional_puts_each: u8) {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        put_and_take(xs, additional_puts_each);\n        Ok(())\n    })\n    .unwrap()\n}\n"],["955","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Implementation of ink! storage traits.\n\nuse super::{\n    HashMap as StorageHashMap,\n    ValueEntry,\n};\nuse crate::{\n    collections::Stash as StorageStash,\n    traits::{\n        forward_clear_packed,\n        forward_pull_packed,\n        forward_push_packed,\n        KeyPtr,\n        PackedLayout,\n        SpreadLayout,\n    },\n};\nuse ink_env::hash::{\n    CryptoHash,\n    HashOutput,\n};\nuse ink_primitives::Key;\n\n#[cfg(feature = \"std\")]\nconst _: () = {\n    use crate::{\n        lazy::LazyHashMap,\n        traits::{\n            LayoutCryptoHasher,\n            StorageLayout,\n        },\n    };\n    use ink_metadata::layout::{\n        FieldLayout,\n        Layout,\n        StructLayout,\n    };\n    use scale_info::TypeInfo;\n\n    impl<K, V, H> StorageLayout for StorageHashMap<K, V, H>\n    where\n        K: TypeInfo + Ord + Clone + PackedLayout + 'static,\n        V: TypeInfo + PackedLayout + 'static,\n        H: LayoutCryptoHasher + CryptoHash,\n        Key: From<<H as HashOutput>::Type>,\n    {\n        fn layout(key_ptr: &mut KeyPtr) -> Layout {\n            Layout::Struct(StructLayout::new(vec![\n                FieldLayout::new(\n                    \"keys\",\n                    <StorageStash<K> as StorageLayout>::layout(key_ptr),\n                ),\n                FieldLayout::new(\n                    \"values\",\n                    <LazyHashMap<K, ValueEntry<V>, H> as StorageLayout>::layout(key_ptr),\n                ),\n            ]))\n        }\n    }\n};\n\nimpl<T> SpreadLayout for ValueEntry<T>\nwhere\n    T: PackedLayout,\n{\n    const FOOTPRINT: u64 = 1;\n    const REQUIRES_DEEP_CLEAN_UP: bool = <T as SpreadLayout>::REQUIRES_DEEP_CLEAN_UP;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        forward_pull_packed::<Self>(ptr)\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        forward_push_packed::<Self>(self, ptr)\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        forward_clear_packed::<Self>(self, ptr)\n    }\n}\n\nimpl<T> PackedLayout for ValueEntry<T>\nwhere\n    T: PackedLayout,\n{\n    fn pull_packed(&mut self, at: &Key) {\n        <T as PackedLayout>::pull_packed(&mut self.value, at)\n    }\n\n    fn push_packed(&self, at: &Key) {\n        <T as PackedLayout>::push_packed(&self.value, at)\n    }\n\n    fn clear_packed(&self, at: &Key) {\n        <T as PackedLayout>::clear_packed(&self.value, at)\n    }\n}\n\nimpl<K, V, H> SpreadLayout for StorageHashMap<K, V, H>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    const FOOTPRINT: u64 = 1 + <StorageStash<K> as SpreadLayout>::FOOTPRINT;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        Self {\n            keys: SpreadLayout::pull_spread(ptr),\n            values: SpreadLayout::pull_spread(ptr),\n        }\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        SpreadLayout::push_spread(&self.keys, ptr);\n        SpreadLayout::push_spread(&self.values, ptr);\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        self.clear_cells();\n        SpreadLayout::clear_spread(&self.keys, ptr);\n        SpreadLayout::clear_spread(&self.values, ptr);\n    }\n}\n"],["956","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::HashMap as StorageHashMap;\nuse crate::{\n    test_utils::FuzzCollection,\n    traits::{\n        KeyPtr,\n        PackedLayout,\n        SpreadLayout,\n    },\n    Pack,\n};\nuse ink_primitives::Key;\nuse itertools::Itertools;\nuse quickcheck::{\n    Arbitrary,\n    Gen,\n};\nuse std::{\n    collections::HashMap,\n    iter::FromIterator,\n};\n\n/// Conducts repeated insert and remove operations into the map by iterating\n/// over `xs`. For each odd `x` in `xs` a defined number of insert operations\n/// (`inserts_each`) is executed. For each even `x` it's asserted that the\n/// previously inserted elements are in the map and they are removed subsequently.\n///\n/// The reasoning behind this even/odd sequence is to introduce some\n/// randomness into when elements are inserted/removed.\n///\n/// `inserts_each` was chosen as `u8` to keep the number of inserts per `x` in\n/// a reasonable range.\nfn insert_and_remove(xs: Vec<i32>, inserts_each: u8) -> StorageHashMap<i32, i32> {\n    let mut map = <StorageHashMap<i32, i32>>::new();\n    let mut cnt_inserts = 0;\n    let mut previous_even_x = None;\n    let inserts_each = inserts_each as i32;\n\n    for x in 0..xs.len() as i32 {\n        if x % 2 == 0 {\n            // On even numbers we insert\n            for key in x..x + inserts_each {\n                let val = key.saturating_mul(10);\n                if map.insert(key, val).is_none() {\n                    assert_eq!(map.get(&key), Some(&val));\n                    cnt_inserts += 1;\n                }\n                assert_eq!(map.len(), cnt_inserts);\n            }\n            if previous_even_x.is_none() {\n                previous_even_x = Some(x);\n            }\n        } else if previous_even_x.is_some() {\n            // If it's an odd number and we inserted in a previous run we assert\n            // that the last insert worked correctly and remove the elements again.\n            //\n            // It can happen that after one insert run there are many more\n            // insert runs (i.e. even `x` in `xs`) before we remove the numbers\n            // of the last run again. This is intentional, as to include testing\n            // if subsequent insert operations have an effect on already inserted\n            // items.\n            let x = previous_even_x.unwrap();\n            for key in x..x + inserts_each {\n                let val = key.saturating_mul(10);\n                assert_eq!(map.get(&key), Some(&val));\n                assert_eq!(map.take(&key), Some(val));\n                assert_eq!(map.get(&key), None);\n                cnt_inserts -= 1;\n                assert_eq!(map.len(), cnt_inserts);\n            }\n            previous_even_x = None;\n        }\n    }\n    map\n}\n\n#[quickcheck]\nfn fuzz_inserts_and_removes(xs: Vec<i32>, inserts_each: u8) {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let _ = insert_and_remove(xs, inserts_each);\n        Ok(())\n    })\n    .unwrap()\n}\n\n/// Inserts all elements from `xs`. Then removes each `xth` element from the map\n/// and asserts that all non-`xth` elements are still in the map.\n#[quickcheck]\nfn fuzz_removes(xs: Vec<i32>, xth: usize) {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        // given\n        let xs: Vec<i32> = xs.into_iter().unique().collect();\n        let xth = xth.max(1);\n        let mut map = <StorageHashMap<i32, i32>>::new();\n        let mut len = map.len();\n\n        // when\n        // 1) insert all\n        for x in 0..xs.len() {\n            let i = xs.get(x).expect(\n                \"x is always in bounds since we iterate over the vec length; qed\",\n            );\n            assert_eq!(map.insert(*i, i.saturating_mul(10)), None);\n            len += 1;\n            assert_eq!(map.len(), len);\n        }\n\n        // 2) remove every `xth` element of `xs` from the map\n        for x in 0..xs.len() {\n            if x % xth == 0 {\n                let i = xs.get(x).expect(\n                    \"x is always in bounds since we iterate over the vec length; qed\",\n                );\n                assert_eq!(map.take(&i), Some(i.saturating_mul(10)));\n                len -= 1;\n            }\n            assert_eq!(map.len(), len);\n        }\n\n        // then\n        // everything else must still be get-able\n        for x in 0..xs.len() {\n            if x % xth != 0 {\n                let i = xs.get(x).expect(\n                    \"x is always in bounds since we iterate over the vec length; qed\",\n                );\n                assert_eq!(map.get(&i), Some(&(i.saturating_mul(10))));\n            }\n        }\n\n        Ok(())\n    })\n    .unwrap()\n}\n\n#[quickcheck]\nfn fuzz_defrag(xs: Vec<i32>, inserts_each: u8) {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        // Create a `HashMap<i32, i32>` and execute some pseudo-randomized\n        // insert/remove operations on it.\n        let mut map = insert_and_remove(xs, inserts_each);\n\n        // Build a collection of the keys/values in this hash map\n        let kv_pairs: Vec<(i32, i32)> = map\n            .keys\n            .iter()\n            .map(|key| {\n                (\n                    key.to_owned(),\n                    map.get(key).expect(\"value must exist\").to_owned(),\n                )\n            })\n            .collect();\n        assert_eq!(map.len(), kv_pairs.len() as u32);\n\n        // Then defragment the hash map\n        map.defrag(None);\n\n        // Then we push the defragmented hash map to storage and pull it again\n        let root_key = Key::from([0x00; 32]);\n        SpreadLayout::push_spread(&map, &mut KeyPtr::from(root_key));\n        let map2: StorageHashMap<i32, i32> =\n            SpreadLayout::pull_spread(&mut KeyPtr::from(root_key));\n\n        // Assert that everything that should be is still in the hash map\n        assert_eq!(map2.len(), kv_pairs.len() as u32);\n        for (key, val) in kv_pairs {\n            assert_eq!(map2.get(&key), Some(&val));\n        }\n\n        Ok(())\n    })\n    .unwrap()\n}\n\nimpl<K, V> Arbitrary for StorageHashMap<K, V>\nwhere\n    K: Arbitrary + Ord + PackedLayout + Send + Clone + std::hash::Hash + 'static,\n    V: Arbitrary + PackedLayout + Send + Clone + 'static,\n{\n    fn arbitrary(g: &mut Gen) -> StorageHashMap<K, V> {\n        let hmap = HashMap::<K, V>::arbitrary(g);\n        StorageHashMap::<K, V>::from_iter(hmap)\n    }\n}\n\nimpl<K, V> Clone for StorageHashMap<K, V>\nwhere\n    K: Ord + PackedLayout + Clone + std::hash::Hash,\n    V: PackedLayout + Clone,\n{\n    fn clone(&self) -> Self {\n        let mut shmap = StorageHashMap::<K, V>::new();\n        self.iter().for_each(|(k, v)| {\n            let _ = shmap.insert(k.clone(), v.clone());\n        });\n        shmap\n    }\n}\n\nimpl<'a, K, V> FuzzCollection for &'a mut StorageHashMap<K, V>\nwhere\n    V: Clone + PackedLayout + 'a,\n    K: PackedLayout + Ord + Clone + 'a,\n{\n    type Collection = StorageHashMap<K, V>;\n    type Item = (&'a K, &'a mut V);\n\n    /// Makes `self` equal to `instance2` by executing a series of operations\n    /// on `self`.\n    fn equalize(&mut self, instance2: &Self::Collection) {\n        let hmap_keys = self.keys().cloned().collect::<Vec<K>>();\n        for k in hmap_keys {\n            if !instance2.contains_key(&k) {\n                let _ = self.take(&k);\n            }\n        }\n\n        let template_keys = instance2.keys().cloned();\n        for k in template_keys {\n            if let Some(template_val) = instance2.get(&k) {\n                let _ = self.insert(k, template_val.clone());\n            }\n        }\n    }\n\n    /// `item` is an item from the hash map. We check if `item.key` is\n    /// in `self` and if existent assign its value to `item.value`\n    /// of `self` and assign it to `val`.\n    ///\n    /// Hence this method only might modify values of `item`, leaving\n    /// others intact.\n    fn assign(&mut self, item: Self::Item) {\n        let (key, value) = item;\n        if let Some(existent_value) = self.get(key) {\n            *value = existent_value.clone();\n        }\n    }\n}\n\ncrate::fuzz_storage!(\"hashmap_1\", StorageHashMap<u32, u32>);\ncrate::fuzz_storage!(\"hashmap_2\", StorageHashMap<u32, Option<Pack<Option<u32>>>>);\ncrate::fuzz_storage!(\n    \"hashmap_3\",\n    StorageHashMap<Option<Option<u32>>, Option<Pack<Option<u32>>>>\n);\ncrate::fuzz_storage!(\n    \"hashmap_4\",\n    StorageHashMap<Pack<(u32, i128)>, (bool, (u32, u128))>\n);\ncrate::fuzz_storage!(\"hashmap_5\", StorageHashMap<u32, (i128, u32, bool, Option<(u32, i128)>, u32)>);\n"],["957","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::HashMap as StorageHashMap;\nuse crate::{\n    traits::{\n        KeyPtr,\n        SpreadLayout,\n    },\n    Lazy,\n};\nuse ink_primitives::Key;\n\n/// Returns always the same `KeyPtr`.\nfn key_ptr() -> KeyPtr {\n    let root_key = Key::from([0x42; 32]);\n    KeyPtr::from(root_key)\n}\n\n/// Pushes a `HashMap` instance into the contract storage.\nfn push_hmap(hmap: &StorageHashMap<u8, i32>) {\n    SpreadLayout::push_spread(hmap, &mut key_ptr());\n}\n\n/// Pulls a `HashMap` instance from the contract storage.\nfn pull_hmap() -> StorageHashMap<u8, i32> {\n    <StorageHashMap<u8, i32> as SpreadLayout>::pull_spread(&mut key_ptr())\n}\n\nfn filled_hmap() -> StorageHashMap<u8, i32> {\n    [(b'A', 1), (b'B', 2), (b'C', 3), (b'D', 4)]\n        .iter()\n        .copied()\n        .collect::<StorageHashMap<u8, i32>>()\n}\n\n#[test]\nfn new_works() {\n    // `StorageHashMap::new`\n    let hmap = <StorageHashMap<u8, i32>>::new();\n    assert!(hmap.is_empty());\n    assert_eq!(hmap.len(), 0);\n    assert!(hmap.iter().next().is_none());\n    // `StorageHashMap::default`\n    let default = <StorageHashMap<u8, i32> as Default>::default();\n    assert!(default.is_empty());\n    assert_eq!(default.len(), 0);\n    assert!(default.iter().next().is_none());\n    // `StorageHashMap::new` and `StorageHashMap::default` should be equal.\n    assert_eq!(hmap, default);\n}\n\n#[test]\nfn from_iterator_works() {\n    let test_values = [(b'A', 1), (b'B', 2), (b'C', 3), (b'D', 4)];\n    let hmap = test_values\n        .iter()\n        .copied()\n        .collect::<StorageHashMap<u8, i32>>();\n    assert!(!hmap.is_empty());\n    assert_eq!(hmap.len(), 4);\n    assert_eq!(hmap, {\n        let mut hmap = <StorageHashMap<u8, i32>>::new();\n        for (key, value) in &test_values {\n            assert_eq!(hmap.insert(*key, *value), None);\n        }\n        hmap\n    });\n}\n\n#[test]\nfn from_empty_iterator_works() {\n    assert_eq!(\n        [].iter().copied().collect::<StorageHashMap<u8, i32>>(),\n        <StorageHashMap<u8, i32>>::new(),\n    );\n}\n\n#[test]\nfn contains_key_works() {\n    // Empty hash map.\n    let hmap = <StorageHashMap<u8, i32>>::new();\n    assert!(!hmap.contains_key(&b'A'));\n    assert!(!hmap.contains_key(&b'E'));\n    // Filled hash map.\n    let hmap = [(b'A', 1), (b'B', 2), (b'C', 3), (b'D', 4)]\n        .iter()\n        .copied()\n        .collect::<StorageHashMap<u8, i32>>();\n    assert!(hmap.contains_key(&b'A'));\n    assert!(hmap.contains_key(&b'B'));\n    assert!(hmap.contains_key(&b'C'));\n    assert!(hmap.contains_key(&b'D'));\n    assert!(!hmap.contains_key(&b'E'));\n}\n\n#[test]\nfn get_works() {\n    // Empty hash map.\n    let hmap = <StorageHashMap<u8, i32>>::new();\n    assert_eq!(hmap.get(&b'A'), None);\n    assert_eq!(hmap.get(&b'E'), None);\n    // Filled hash map: `get`\n    let hmap = filled_hmap();\n    assert_eq!(hmap.get(&b'A'), Some(&1));\n    assert_eq!(hmap.get(&b'B'), Some(&2));\n    assert_eq!(hmap.get(&b'C'), Some(&3));\n    assert_eq!(hmap.get(&b'D'), Some(&4));\n    assert_eq!(hmap.get(&b'E'), None);\n    // Filled hash map: `get_mut`\n    let mut hmap = hmap;\n    assert_eq!(hmap.get_mut(&b'A'), Some(&mut 1));\n    assert_eq!(hmap.get_mut(&b'B'), Some(&mut 2));\n    assert_eq!(hmap.get_mut(&b'C'), Some(&mut 3));\n    assert_eq!(hmap.get_mut(&b'D'), Some(&mut 4));\n    assert_eq!(hmap.get_mut(&b'E'), None);\n}\n\n#[test]\nfn insert_works() {\n    let mut hmap = <StorageHashMap<u8, i32>>::new();\n    // Start with an empty hash map.\n    assert_eq!(hmap.len(), 0);\n    assert_eq!(hmap.get(&b'A'), None);\n    // Insert first value.\n    hmap.insert(b'A', 1);\n    assert_eq!(hmap.len(), 1);\n    assert_eq!(hmap.get(&b'A'), Some(&1));\n    assert_eq!(hmap.get_mut(&b'A'), Some(&mut 1));\n    // Update the inserted value.\n    hmap.insert(b'A', 2);\n    assert_eq!(hmap.len(), 1);\n    assert_eq!(hmap.get(&b'A'), Some(&2));\n    assert_eq!(hmap.get_mut(&b'A'), Some(&mut 2));\n    // Insert another value.\n    hmap.insert(b'B', 3);\n    assert_eq!(hmap.len(), 2);\n    assert_eq!(hmap.get(&b'B'), Some(&3));\n    assert_eq!(hmap.get_mut(&b'B'), Some(&mut 3));\n}\n\n#[test]\nfn take_works() {\n    // Empty hash map.\n    let mut hmap = <StorageHashMap<u8, i32>>::new();\n    assert_eq!(hmap.take(&b'A'), None);\n    assert_eq!(hmap.take(&b'E'), None);\n    // Filled hash map: `get`\n    let mut hmap = filled_hmap();\n    assert_eq!(hmap.len(), 4);\n    assert_eq!(hmap.take(&b'A'), Some(1));\n    assert_eq!(hmap.len(), 3);\n    assert_eq!(hmap.take(&b'A'), None);\n    assert_eq!(hmap.len(), 3);\n    assert_eq!(hmap.take(&b'B'), Some(2));\n    assert_eq!(hmap.len(), 2);\n    assert_eq!(hmap.take(&b'C'), Some(3));\n    assert_eq!(hmap.len(), 1);\n    assert_eq!(hmap.take(&b'D'), Some(4));\n    assert_eq!(hmap.len(), 0);\n    assert_eq!(hmap.take(&b'E'), None);\n    assert_eq!(hmap.len(), 0);\n}\n\n#[test]\nfn iter_next_works() {\n    let hmap = filled_hmap();\n    // Test iterator over shared references:\n    let mut iter = hmap.iter();\n    assert_eq!(iter.count(), 4);\n    assert_eq!(iter.size_hint(), (4, Some(4)));\n    assert_eq!(iter.next(), Some((&b'A', &1)));\n    assert_eq!(iter.size_hint(), (3, Some(3)));\n    assert_eq!(iter.next(), Some((&b'B', &2)));\n    assert_eq!(iter.size_hint(), (2, Some(2)));\n    assert_eq!(iter.count(), 2);\n    assert_eq!(iter.next(), Some((&b'C', &3)));\n    assert_eq!(iter.size_hint(), (1, Some(1)));\n    assert_eq!(iter.next(), Some((&b'D', &4)));\n    assert_eq!(iter.size_hint(), (0, Some(0)));\n    assert_eq!(iter.count(), 0);\n    assert_eq!(iter.next(), None);\n    // Test iterator over exclusive references:\n    let mut hmap = hmap;\n    let mut iter = hmap.iter_mut();\n    assert_eq!(iter.size_hint(), (4, Some(4)));\n    assert_eq!(iter.next(), Some((&b'A', &mut 1)));\n    assert_eq!(iter.size_hint(), (3, Some(3)));\n    assert_eq!(iter.next(), Some((&b'B', &mut 2)));\n    assert_eq!(iter.size_hint(), (2, Some(2)));\n    assert_eq!(iter.next(), Some((&b'C', &mut 3)));\n    assert_eq!(iter.size_hint(), (1, Some(1)));\n    assert_eq!(iter.next(), Some((&b'D', &mut 4)));\n    assert_eq!(iter.size_hint(), (0, Some(0)));\n    assert_eq!(iter.next(), None);\n    assert_eq!(iter.count(), 0);\n}\n\n#[test]\nfn values_next_works() {\n    let hmap = filled_hmap();\n    // Test iterator over shared references:\n    let mut iter = hmap.values();\n    assert_eq!(iter.count(), 4);\n    assert_eq!(iter.size_hint(), (4, Some(4)));\n    assert_eq!(iter.next(), Some(&1));\n    assert_eq!(iter.size_hint(), (3, Some(3)));\n    assert_eq!(iter.next(), Some(&2));\n    assert_eq!(iter.size_hint(), (2, Some(2)));\n    assert_eq!(iter.count(), 2);\n    assert_eq!(iter.next(), Some(&3));\n    assert_eq!(iter.size_hint(), (1, Some(1)));\n    assert_eq!(iter.next(), Some(&4));\n    assert_eq!(iter.size_hint(), (0, Some(0)));\n    assert_eq!(iter.count(), 0);\n    assert_eq!(iter.next(), None);\n    // Test iterator over exclusive references:\n    let mut hmap = hmap;\n    let mut iter = hmap.values_mut();\n    assert_eq!(iter.size_hint(), (4, Some(4)));\n    assert_eq!(iter.next(), Some(&mut 1));\n    assert_eq!(iter.size_hint(), (3, Some(3)));\n    assert_eq!(iter.next(), Some(&mut 2));\n    assert_eq!(iter.size_hint(), (2, Some(2)));\n    assert_eq!(iter.next(), Some(&mut 3));\n    assert_eq!(iter.size_hint(), (1, Some(1)));\n    assert_eq!(iter.next(), Some(&mut 4));\n    assert_eq!(iter.size_hint(), (0, Some(0)));\n    assert_eq!(iter.next(), None);\n    assert_eq!(iter.count(), 0);\n}\n\n#[test]\nfn keys_next_works() {\n    let hmap = filled_hmap();\n    let mut iter = hmap.keys();\n    assert_eq!(iter.count(), 4);\n    assert_eq!(iter.size_hint(), (4, Some(4)));\n    assert_eq!(iter.next(), Some(&b'A'));\n    assert_eq!(iter.size_hint(), (3, Some(3)));\n    assert_eq!(iter.next(), Some(&b'B'));\n    assert_eq!(iter.size_hint(), (2, Some(2)));\n    assert_eq!(iter.count(), 2);\n    assert_eq!(iter.next(), Some(&b'C'));\n    assert_eq!(iter.size_hint(), (1, Some(1)));\n    assert_eq!(iter.next(), Some(&b'D'));\n    assert_eq!(iter.size_hint(), (0, Some(0)));\n    assert_eq!(iter.count(), 0);\n    assert_eq!(iter.next(), None);\n}\n\n#[test]\nfn defrag_works() {\n    let expected = [(b'A', 1), (b'D', 4)]\n        .iter()\n        .copied()\n        .collect::<StorageHashMap<u8, i32>>();\n    // Defrag without limits:\n    let mut hmap = filled_hmap();\n    assert_eq!(hmap.defrag(None), 0);\n    assert_eq!(hmap.take(&b'B'), Some(2));\n    assert_eq!(hmap.take(&b'C'), Some(3));\n    assert_eq!(hmap.defrag(None), 2);\n    assert_eq!(hmap.defrag(None), 0);\n    assert_eq!(hmap, expected);\n    // Defrag with limits:\n    let mut hmap = [(b'A', 1), (b'B', 2), (b'C', 3), (b'D', 4)]\n        .iter()\n        .copied()\n        .collect::<StorageHashMap<u8, i32>>();\n    assert_eq!(hmap.defrag(None), 0);\n    assert_eq!(hmap.take(&b'B'), Some(2));\n    assert_eq!(hmap.take(&b'C'), Some(3));\n    assert_eq!(hmap.defrag(Some(1)), 1);\n    assert_eq!(hmap.defrag(Some(1)), 1);\n    assert_eq!(hmap.defrag(Some(1)), 0);\n    assert_eq!(hmap, expected);\n}\n\n#[test]\nfn spread_layout_push_pull_works() -> ink_env::Result<()> {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let hmap1 = filled_hmap();\n        push_hmap(&hmap1);\n        // Load the pushed storage hmap into another instance and check that\n        // both instances are equal:\n        let hmap2 = pull_hmap();\n        assert_eq!(hmap1, hmap2);\n        Ok(())\n    })\n}\n\n#[test]\n#[should_panic(expected = \"storage entry was empty\")]\nfn spread_layout_clear_works() {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let hmap1 = filled_hmap();\n        let root_key = Key::from([0x42; 32]);\n        SpreadLayout::push_spread(&hmap1, &mut KeyPtr::from(root_key));\n        // It has already been asserted that a valid instance can be pulled\n        // from contract storage after a push to the same storage region.\n        //\n        // Now clear the associated storage from `hmap1` and check whether\n        // loading another instance from this storage will panic since the\n        // hmap's length property cannot read a value:\n        SpreadLayout::clear_spread(&hmap1, &mut KeyPtr::from(root_key));\n        let _ = <StorageHashMap<u8, i32> as SpreadLayout>::pull_spread(\n            &mut KeyPtr::from(root_key),\n        );\n        Ok(())\n    })\n    .unwrap()\n}\n\n#[test]\nfn storage_is_cleared_completely_after_pull_lazy() {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        // given\n        let root_key = Key::from([0x42; 32]);\n        let lazy_hmap = Lazy::new(filled_hmap());\n        SpreadLayout::push_spread(&lazy_hmap, &mut KeyPtr::from(root_key));\n        let pulled_hmap = <Lazy<StorageHashMap<u8, i32>> as SpreadLayout>::pull_spread(\n            &mut KeyPtr::from(root_key),\n        );\n\n        // when\n        SpreadLayout::clear_spread(&pulled_hmap, &mut KeyPtr::from(root_key));\n\n        // then\n        let contract_id = ink_env::test::get_current_contract_account_id::<\n            ink_env::DefaultEnvironment,\n        >()\n        .expect(\"Cannot get contract id\");\n        let used_cells = ink_env::test::count_used_storage_cells::<\n            ink_env::DefaultEnvironment,\n        >(&contract_id)\n        .expect(\"used cells must be returned\");\n        assert_eq!(used_cells, 0);\n\n        Ok(())\n    })\n    .unwrap()\n}\n\n#[test]\n#[should_panic(expected = \"storage entry was empty\")]\nfn drop_works() {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let root_key = Key::from([0x42; 32]);\n\n        // if the setup panics it should not cause the test to pass\n        let setup_result = std::panic::catch_unwind(|| {\n            let hmap = filled_hmap();\n            SpreadLayout::push_spread(&hmap, &mut KeyPtr::from(root_key));\n            let _ = <StorageHashMap<u8, i32> as SpreadLayout>::pull_spread(\n                &mut KeyPtr::from(root_key),\n            );\n            // hmap is dropped which should clear the cells\n        });\n        assert!(setup_result.is_ok(), \"setup should not panic\");\n\n        let contract_id = ink_env::test::get_current_contract_account_id::<\n            ink_env::DefaultEnvironment,\n        >()\n        .expect(\"Cannot get contract id\");\n        let used_cells = ink_env::test::count_used_storage_cells::<\n            ink_env::DefaultEnvironment,\n        >(&contract_id)\n        .expect(\"used cells must be returned\");\n        assert_eq!(used_cells, 0);\n\n        let _ = <StorageHashMap<u8, i32> as SpreadLayout>::pull_spread(\n            &mut KeyPtr::from(root_key),\n        );\n        Ok(())\n    })\n    .unwrap()\n}\n"],["958","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::ValueEntry;\nuse crate::{\n    collections::{\n        extend_lifetime,\n        stash::Iter as StashIter,\n        HashMap as StorageHashMap,\n    },\n    lazy::LazyHashMap,\n    traits::PackedLayout,\n};\nuse ink_env::hash::{\n    CryptoHash,\n    HashOutput,\n};\nuse ink_primitives::Key;\n\n/// An iterator over shared references to the elements of a storage hash map.\n#[derive(Debug, Copy, Clone)]\npub struct Iter<'a, K, V, H>\nwhere\n    K: PackedLayout,\n{\n    /// The iterator over the map's keys.\n    keys_iter: StashIter<'a, K>,\n    /// The lazy hash map to query the values.\n    values: &'a LazyHashMap<K, ValueEntry<V>, H>,\n}\n\nimpl<'a, K, V, H> Iter<'a, K, V, H>\nwhere\n    K: Ord + Clone + PackedLayout,\n{\n    /// Creates a new iterator for the given storage hash map.\n    pub(crate) fn new(hash_map: &'a StorageHashMap<K, V, H>) -> Self\n    where\n        V: PackedLayout,\n        H: CryptoHash,\n        Key: From<<H as HashOutput>::Type>,\n    {\n        Self {\n            keys_iter: hash_map.keys.iter(),\n            values: &hash_map.values,\n        }\n    }\n}\n\nimpl<'a, K, V, H> Iter<'a, K, V, H>\nwhere\n    K: Ord + Eq + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    /// Queries the value for the given key and returns the key/value pair.\n    ///\n    /// # Panics\n    ///\n    /// If the key refers to an invalid element.\n    fn query_value(&self, key: &'a K) -> <Self as Iterator>::Item {\n        let entry = self\n            .values\n            .get(key)\n            .expect(\"a key must always refer to an existing entry\");\n        (key, &entry.value)\n    }\n}\n\nimpl<'a, K, V, H> Iterator for Iter<'a, K, V, H>\nwhere\n    K: Ord + Eq + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    type Item = (&'a K, &'a V);\n\n    fn count(self) -> usize {\n        self.keys_iter.count()\n    }\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let key = self.keys_iter.next()?;\n        Some(self.query_value(key))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.keys_iter.size_hint()\n    }\n}\n\nimpl<'a, K, V, H> ExactSizeIterator for Iter<'a, K, V, H>\nwhere\n    K: Ord + Eq + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n}\n\nimpl<'a, K, V, H> DoubleEndedIterator for Iter<'a, K, V, H>\nwhere\n    K: Ord + Eq + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        let key = self.keys_iter.next_back()?;\n        Some(self.query_value(key))\n    }\n}\n\n/// An iterator over shared references to the elements of a storage hash map.\n#[derive(Debug)]\npub struct IterMut<'a, K, V, H>\nwhere\n    K: PackedLayout,\n{\n    /// The iterator over the map's keys.\n    keys_iter: StashIter<'a, K>,\n    /// The lazy hash map to query the values.\n    values: &'a mut LazyHashMap<K, ValueEntry<V>, H>,\n}\n\nimpl<'a, K, V, H> IterMut<'a, K, V, H>\nwhere\n    K: Ord + Clone + PackedLayout,\n{\n    /// Creates a new iterator for the given storage hash map.\n    pub(crate) fn new(hash_map: &'a mut StorageHashMap<K, V, H>) -> Self\n    where\n        V: PackedLayout,\n        H: CryptoHash,\n        Key: From<<H as HashOutput>::Type>,\n    {\n        Self {\n            keys_iter: hash_map.keys.iter(),\n            values: &mut hash_map.values,\n        }\n    }\n}\n\nimpl<'a, K, V, H> IterMut<'a, K, V, H>\nwhere\n    K: Ord + Eq + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    /// Queries the value for the given key and returns the key/value pair.\n    ///\n    /// # Panics\n    ///\n    /// If the key refers to an invalid element.\n    fn query_value<'b>(&'b mut self, key: &'a K) -> <Self as Iterator>::Item {\n        let entry = self\n            .values\n            .get_mut(key)\n            .expect(\"a key must always refer to an existing entry\");\n        (key, unsafe {\n            extend_lifetime::<'b, 'a, V>(&mut entry.value)\n        })\n    }\n}\n\nimpl<'a, K, V, H> Iterator for IterMut<'a, K, V, H>\nwhere\n    K: Ord + Eq + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    type Item = (&'a K, &'a mut V);\n\n    fn count(self) -> usize {\n        self.keys_iter.count()\n    }\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let key = self.keys_iter.next()?;\n        Some(self.query_value(key))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.keys_iter.size_hint()\n    }\n}\n\nimpl<'a, K, V, H> ExactSizeIterator for IterMut<'a, K, V, H>\nwhere\n    K: Ord + Eq + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n}\n\nimpl<'a, K, V, H> DoubleEndedIterator for IterMut<'a, K, V, H>\nwhere\n    K: Ord + Eq + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        let key = self.keys_iter.next_back()?;\n        Some(self.query_value(key))\n    }\n}\n\n/// An iterator over shared references to the values of a storage hash map.\n#[derive(Debug, Copy, Clone)]\npub struct Values<'a, K, V, H>\nwhere\n    K: PackedLayout,\n{\n    /// The key/values pair iterator.\n    iter: Iter<'a, K, V, H>,\n}\n\nimpl<'a, K, V, H> Values<'a, K, V, H>\nwhere\n    K: Ord + Clone + PackedLayout,\n{\n    /// Creates a new iterator for the given storage hash map.\n    pub(crate) fn new(hash_map: &'a StorageHashMap<K, V, H>) -> Self\n    where\n        V: PackedLayout,\n        H: CryptoHash,\n        Key: From<<H as HashOutput>::Type>,\n    {\n        Self {\n            iter: hash_map.iter(),\n        }\n    }\n}\n\nimpl<'a, K, V, H> Iterator for Values<'a, K, V, H>\nwhere\n    K: Ord + Eq + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    type Item = &'a V;\n\n    fn count(self) -> usize {\n        self.iter.count()\n    }\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|(_key, value)| value)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\nimpl<'a, K, V, H> ExactSizeIterator for Values<'a, K, V, H>\nwhere\n    K: Ord + Eq + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n}\n\nimpl<'a, K, V, H> DoubleEndedIterator for Values<'a, K, V, H>\nwhere\n    K: Ord + Eq + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.iter.next_back().map(|(_key, value)| value)\n    }\n}\n\n/// An iterator over exclusive references to the values of a storage hash map.\n#[derive(Debug)]\npub struct ValuesMut<'a, K, V, H>\nwhere\n    K: PackedLayout,\n{\n    /// The key/values pair iterator.\n    iter: IterMut<'a, K, V, H>,\n}\n\nimpl<'a, K, V, H> ValuesMut<'a, K, V, H>\nwhere\n    K: Ord + Clone + PackedLayout,\n{\n    /// Creates a new iterator for the given storage hash map.\n    pub(crate) fn new(hash_map: &'a mut StorageHashMap<K, V, H>) -> Self\n    where\n        V: PackedLayout,\n        H: CryptoHash,\n        Key: From<<H as HashOutput>::Type>,\n    {\n        Self {\n            iter: hash_map.iter_mut(),\n        }\n    }\n}\n\nimpl<'a, K, V, H> Iterator for ValuesMut<'a, K, V, H>\nwhere\n    K: Ord + Eq + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    type Item = &'a mut V;\n\n    fn count(self) -> usize {\n        self.iter.count()\n    }\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|(_key, value)| value)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\nimpl<'a, K, V, H> ExactSizeIterator for ValuesMut<'a, K, V, H>\nwhere\n    K: Ord + Eq + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n}\n\nimpl<'a, K, V, H> DoubleEndedIterator for ValuesMut<'a, K, V, H>\nwhere\n    K: Ord + Eq + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.iter.next_back().map(|(_key, value)| value)\n    }\n}\n\n/// An iterator over references to the keys of a storage hash map.\n#[derive(Debug, Copy, Clone)]\npub struct Keys<'a, K>\nwhere\n    K: PackedLayout,\n{\n    /// The key iterator.\n    iter: StashIter<'a, K>,\n}\n\nimpl<'a, K> Keys<'a, K>\nwhere\n    K: Ord + Clone + PackedLayout,\n{\n    /// Creates a new iterator for the given storage hash map.\n    pub(crate) fn new<V, H>(hash_map: &'a StorageHashMap<K, V, H>) -> Self\n    where\n        V: PackedLayout,\n        H: CryptoHash,\n        Key: From<<H as HashOutput>::Type>,\n    {\n        Self {\n            iter: hash_map.keys.iter(),\n        }\n    }\n}\n\nimpl<'a, K> Iterator for Keys<'a, K>\nwhere\n    K: PackedLayout,\n{\n    type Item = &'a K;\n\n    fn count(self) -> usize {\n        self.iter.count()\n    }\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next()\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\nimpl<'a, K> ExactSizeIterator for Keys<'a, K> where K: PackedLayout {}\n\nimpl<'a, K> DoubleEndedIterator for Keys<'a, K>\nwhere\n    K: PackedLayout,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.iter.next_back()\n    }\n}\n"],["959","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! A storage hash map that allows to associate keys with values.\n\nmod impls;\nmod iter;\nmod storage;\n\n#[cfg(test)]\nmod tests;\n\n#[cfg(all(test, feature = \"ink-fuzz-tests\"))]\nmod fuzz_tests;\n\npub use self::iter::{\n    Iter,\n    IterMut,\n    Keys,\n    Values,\n    ValuesMut,\n};\nuse crate::{\n    collections::Stash,\n    lazy::lazy_hmap::{\n        Entry as LazyEntry,\n        LazyHashMap,\n        OccupiedEntry as LazyOccupiedEntry,\n        VacantEntry as LazyVacantEntry,\n    },\n    traits::PackedLayout,\n};\nuse core::{\n    borrow::Borrow,\n    cmp::Eq,\n};\nuse ink_env::hash::{\n    Blake2x256,\n    CryptoHash,\n    HashOutput,\n};\nuse ink_prelude::borrow::ToOwned;\nuse ink_primitives::Key;\n\n/// The index type within a hashmap.\n///\n/// # Note\n///\n/// Used for key indices internal to the hashmap.\ntype KeyIndex = u32;\n\n/// A hash map operating on the contract storage.\n///\n/// Stores a mapping between keys and values.\n///\n/// # Note\n///\n/// Unlike Rust's standard `HashMap` that uses the [`core::hash::Hash`] trait\n/// in order to hash its keys the storage hash map uses the [`scale::Encode`]\n/// encoding in order to hash its keys using a built-in cryptographic\n/// hash function provided by the chain runtime.\n///\n/// The main difference between the lower-level `LazyHashMap` and the\n/// `storage::HashMap` is that the latter is aware of its associated keys and\n/// values and operates on those instances directly as opposed to `Option`\n/// instances of them. Also it provides a more high-level and user focused\n/// API.\n///\n/// Users should generally prefer using this storage hash map over the low-level\n/// `LazyHashMap` for direct usage in their smart contracts.\n#[derive(Debug)]\npub struct HashMap<K, V, H = Blake2x256>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    /// The keys of the storage hash map.\n    keys: Stash<K>,\n    /// The values of the storage hash map.\n    values: LazyHashMap<K, ValueEntry<V>, H>,\n}\n\n/// An entry within the storage hash map.\n///\n/// Stores the value as well as the index to its associated key.\n#[derive(Debug, scale::Encode, scale::Decode)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\nstruct ValueEntry<V> {\n    /// The value stored in this entry.\n    value: V,\n    /// The index of the key associated with this value.\n    key_index: KeyIndex,\n}\n\n/// An occupied entry that holds the value.\npub struct OccupiedEntry<'a, K, V>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PackedLayout,\n{\n    /// A reference to the `Stash` instance, containing the keys.\n    keys: &'a mut Stash<K>,\n    /// The `LazyHashMap::OccupiedEntry`.\n    values_entry: LazyOccupiedEntry<'a, K, ValueEntry<V>>,\n}\n\n/// A vacant entry with previous and next vacant indices.\npub struct VacantEntry<'a, K, V>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PackedLayout,\n{\n    /// A reference to the `Stash` instance, containing the keys.\n    keys: &'a mut Stash<K>,\n    /// The `LazyHashMap::VacantEntry`.\n    values_entry: LazyVacantEntry<'a, K, ValueEntry<V>>,\n}\n\n/// An entry within the stash.\n///\n/// The vacant entries within a storage stash form a doubly linked list of\n/// vacant entries that is used to quickly re-use their vacant storage.\npub enum Entry<'a, K: 'a, V: 'a>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PackedLayout,\n{\n    /// A vacant entry that holds the index to the next and previous vacant entry.\n    Vacant(VacantEntry<'a, K, V>),\n    /// An occupied entry that holds the value.\n    Occupied(OccupiedEntry<'a, K, V>),\n}\n\nimpl<K, V, H> HashMap<K, V, H>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    /// Creates a new empty storage hash map.\n    pub fn new() -> Self {\n        Self {\n            keys: Stash::new(),\n            values: LazyHashMap::new(),\n        }\n    }\n\n    /// Returns the number of key-value pairs stored in the hash map.\n    pub fn len(&self) -> u32 {\n        self.keys.len()\n    }\n\n    /// Returns the number of key-value pairs stored in the cache.\n    #[cfg(test)]\n    pub(crate) fn len_cached_entries(&self) -> u32 {\n        self.keys.len()\n    }\n\n    /// Returns `true` if the hash map is empty.\n    pub fn is_empty(&self) -> bool {\n        self.keys.is_empty()\n    }\n\n    /// Returns an iterator yielding shared references to all key/value pairs\n    /// of the hash map.\n    ///\n    /// # Note\n    ///\n    /// - Avoid unbounded iteration over big storage hash maps.\n    /// - Prefer using methods like `Iterator::take` in order to limit the number\n    ///   of yielded elements.\n    pub fn iter(&self) -> Iter<K, V, H> {\n        Iter::new(self)\n    }\n\n    /// Returns an iterator yielding exclusive references to all key/value pairs\n    /// of the hash map.\n    ///\n    /// # Note\n    ///\n    /// - Avoid unbounded iteration over big storage hash maps.\n    /// - Prefer using methods like `Iterator::take` in order to limit the number\n    ///   of yielded elements.\n    pub fn iter_mut(&mut self) -> IterMut<K, V, H> {\n        IterMut::new(self)\n    }\n\n    /// Returns an iterator yielding shared references to all values of the hash map.\n    ///\n    /// # Note\n    ///\n    /// - Avoid unbounded iteration over big storage hash maps.\n    /// - Prefer using methods like `Iterator::take` in order to limit the number\n    ///   of yielded elements.\n    pub fn values(&self) -> Values<K, V, H> {\n        Values::new(self)\n    }\n\n    /// Returns an iterator yielding shared references to all values of the hash map.\n    ///\n    /// # Note\n    ///\n    /// - Avoid unbounded iteration over big storage hash maps.\n    /// - Prefer using methods like `Iterator::take` in order to limit the number\n    ///   of yielded elements.\n    pub fn values_mut(&mut self) -> ValuesMut<K, V, H> {\n        ValuesMut::new(self)\n    }\n\n    /// Returns an iterator yielding shared references to all keys of the hash map.\n    ///\n    /// # Note\n    ///\n    /// - Avoid unbounded iteration over big storage hash maps.\n    /// - Prefer using methods like `Iterator::take` in order to limit the number\n    ///   of yielded elements.\n    pub fn keys(&self) -> Keys<K> {\n        Keys::new(self)\n    }\n}\n\nimpl<K, V, H> HashMap<K, V, H>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    fn clear_cells(&self) {\n        if self.values.key().is_none() {\n            // We won't clear any storage if we are in lazy state since there\n            // probably has not been any state written to storage, yet.\n            return\n        }\n        for key in self.keys() {\n            // It might seem wasteful to clear all entries instead of just\n            // the occupied ones. However this spares us from having one extra\n            // read for every element in the storage stash to filter out vacant\n            // entries. So this is actually a trade-off and at the time of this\n            // implementation it is unclear which path is more efficient.\n            //\n            // The bet is that clearing a storage cell is cheaper than reading one.\n            self.values.clear_packed_at(key);\n        }\n    }\n}\n\nimpl<K, V, H> HashMap<K, V, H>\nwhere\n    K: Ord + Eq + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    /// Inserts a key-value pair into the map.\n    ///\n    /// Returns the previous value associated with the same key if any.\n    /// If the map did not have this key present, `None` is returned.\n    ///\n    /// # Note\n    ///\n    /// - If the map did have this key present, the value is updated,\n    ///   and the old value is returned. The key is not updated, though;\n    ///   this matters for types that can be `==` without being identical.\n    pub fn insert(&mut self, key: K, new_value: V) -> Option<V> {\n        if let Some(occupied) = self.values.get_mut(&key) {\n            // Update value, don't update key.\n            let old_value = core::mem::replace(&mut occupied.value, new_value);\n            return Some(old_value)\n        }\n        // At this point we know that `key` does not yet exist in the map.\n        let key_index = self.keys.put(key.to_owned());\n        self.values.put(\n            key,\n            Some(ValueEntry {\n                value: new_value,\n                key_index,\n            }),\n        );\n        None\n    }\n\n    /// Removes the key/value pair from the map associated with the given key.\n    ///\n    /// - Returns the removed value if any.\n    ///\n    /// # Note\n    ///\n    /// The key may be any borrowed form of the map's key type,\n    /// but `Hash` and `Eq` on the borrowed form must match those for the key type.\n    pub fn take<Q>(&mut self, key: &Q) -> Option<V>\n    where\n        K: Borrow<Q>,\n        Q: Ord + scale::Encode + ToOwned<Owned = K>,\n    {\n        let entry = self.values.put_get(key, None)?;\n        self.keys\n            .take(entry.key_index)\n            .expect(\"`key_index` must point to a valid key entry\");\n        Some(entry.value)\n    }\n\n    /// Returns a shared reference to the value corresponding to the key.\n    ///\n    /// The key may be any borrowed form of the map's key type,\n    /// but `Hash` and `Eq` on the borrowed form must match those for the key type.\n    pub fn get<Q>(&self, key: &Q) -> Option<&V>\n    where\n        K: Borrow<Q>,\n        Q: Ord + scale::Encode + ToOwned<Owned = K>,\n    {\n        self.values.get(key).map(|entry| &entry.value)\n    }\n\n    /// Returns a mutable reference to the value corresponding to the key.\n    ///\n    /// The key may be any borrowed form of the map's key type,\n    /// but `Hash` and `Eq` on the borrowed form must match those for the key type.\n    pub fn get_mut<Q>(&mut self, key: &Q) -> Option<&mut V>\n    where\n        K: Borrow<Q>,\n        Q: Ord + scale::Encode + ToOwned<Owned = K>,\n    {\n        self.values.get_mut(key).map(|entry| &mut entry.value)\n    }\n\n    /// Returns `true` if there is an entry corresponding to the key in the map.\n    pub fn contains_key<Q>(&self, key: &Q) -> bool\n    where\n        K: Borrow<Q>,\n        Q: Ord + PartialEq<K> + Eq + scale::Encode + ToOwned<Owned = K>,\n    {\n        // We do not check if the given key is equal to the queried key which is\n        // what normally a hash map implementation does because we do not resolve\n        // or prevent collisions in this hash map implementation at any level.\n        // Having a collision is virtually impossible since we\n        // are using a keyspace of 2^256 bit.\n        self.values.get(key).is_some()\n    }\n\n    /// Defragments storage used by the storage hash map.\n    ///\n    /// Returns the number of storage cells freed this way.\n    ///\n    /// A `max_iterations` parameter of `None` means that there is no limit\n    /// to the number of iterations performed. This is generally not advised.\n    ///\n    /// # Note\n    ///\n    /// This frees storage that is held but not necessary for the hash map to hold.\n    /// This operation might be expensive, especially for big `max_iteration`\n    /// parameters. The `max_iterations` parameter can be used to limit the\n    /// expensiveness for this operation and instead free up storage incrementally.\n    pub fn defrag(&mut self, max_iterations: Option<u32>) -> u32 {\n        // This method just defrags the underlying `storage::Stash` used to\n        // store the keys as it can sometimes take a lot of unused storage\n        // if many keys have been removed at some point. Some hash map\n        // implementations might even prefer to perform this operation with a\n        // limit set to 1 after every successful removal.\n        if let Some(0) = max_iterations {\n            // Bail out early if the iteration limit is set to 0 anyways to\n            // completely avoid doing work in this case.\n            return 0\n        }\n        let len_vacant = self.keys.capacity() - self.keys.len();\n        let max_iterations = max_iterations.unwrap_or(len_vacant);\n        let values = &mut self.values;\n        let callback = |old_index, new_index, key: &K| {\n            let value_entry = values.get_mut(key).expect(\"key must be valid\");\n            debug_assert_eq!(value_entry.key_index, old_index);\n            value_entry.key_index = new_index;\n        };\n        self.keys.defrag(Some(max_iterations), callback)\n    }\n\n    /// Gets the given key's corresponding entry in the map for in-place manipulation.\n    pub fn entry(&mut self, key: K) -> Entry<K, V> {\n        let entry = self.values.entry(key);\n        match entry {\n            LazyEntry::Occupied(o) => {\n                Entry::Occupied(OccupiedEntry {\n                    keys: &mut self.keys,\n                    values_entry: o,\n                })\n            }\n            LazyEntry::Vacant(v) => {\n                Entry::Vacant(VacantEntry {\n                    keys: &mut self.keys,\n                    values_entry: v,\n                })\n            }\n        }\n    }\n}\n\nimpl<'a, K, V> Entry<'a, K, V>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PackedLayout + core::fmt::Debug + core::cmp::Eq + Default,\n{\n    /// Returns a reference to this entry's key.\n    pub fn key(&self) -> &K {\n        match self {\n            Entry::Occupied(entry) => &entry.values_entry.key(),\n            Entry::Vacant(entry) => &entry.values_entry.key(),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the default value if empty, and returns\n    /// a reference to the value in the entry.\n    pub fn or_default(self) -> &'a V {\n        match self {\n            Entry::Occupied(entry) => &mut entry.values_entry.into_mut().value,\n            Entry::Vacant(entry) => entry.insert(V::default()),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the default if empty, and returns\n    /// a mutable reference to the value in the entry.\n    pub fn or_insert(self, default: V) -> &'a mut V {\n        match self {\n            Entry::Occupied(entry) => &mut entry.values_entry.into_mut().value,\n            Entry::Vacant(entry) => entry.insert(default),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n    /// and returns mutable references to the key and value in the entry.\n    pub fn or_insert_with<F>(self, default: F) -> &'a mut V\n    where\n        F: FnOnce() -> V,\n    {\n        match self {\n            Entry::Occupied(entry) => &mut entry.values_entry.into_mut().value,\n            Entry::Vacant(entry) => Entry::insert(default(), entry),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting, if empty, the result of the default\n    /// function, which takes the key as its argument, and returns a mutable reference to\n    /// the value in the entry.\n    pub fn or_insert_with_key<F>(self, default: F) -> &'a mut V\n    where\n        F: FnOnce(&K) -> V,\n    {\n        match self {\n            Entry::Occupied(entry) => &mut entry.values_entry.into_mut().value,\n            Entry::Vacant(entry) => Entry::insert(default(&entry.key()), entry),\n        }\n    }\n\n    /// Provides in-place mutable access to an occupied entry before any\n    /// potential inserts into the map.\n    pub fn and_modify<F>(self, f: F) -> Self\n    where\n        F: FnOnce(&mut V),\n    {\n        match self {\n            Entry::Occupied(mut entry) => {\n                {\n                    let v = entry.values_entry.get_mut();\n                    f(&mut v.value);\n                }\n                Entry::Occupied(entry)\n            }\n            Entry::Vacant(entry) => Entry::Vacant(entry),\n        }\n    }\n\n    /// Inserts `value` into `entry`.\n    fn insert(value: V, entry: VacantEntry<'a, K, V>) -> &'a mut V {\n        entry.insert(value)\n    }\n}\n\nimpl<'a, K, V> VacantEntry<'a, K, V>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PackedLayout,\n{\n    /// Gets a reference to the key that would be used when inserting a value through the VacantEntry.\n    pub fn key(&self) -> &K {\n        &self.values_entry.key()\n    }\n\n    /// Take ownership of the key.\n    pub fn into_key(self) -> K {\n        self.values_entry.into_key()\n    }\n\n    /// Sets the value of the entry with the `VacantEntry`'s key, and returns a mutable reference to it.\n    pub fn insert(self, value: V) -> &'a mut V {\n        // At this point we know that `key` does not yet exist in the map.\n        let key_index = self.keys.put(self.key().to_owned());\n        &mut self\n            .values_entry\n            .insert(ValueEntry { value, key_index })\n            .value\n    }\n}\n\nimpl<'a, K, V> OccupiedEntry<'a, K, V>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PackedLayout,\n{\n    /// Gets a reference to the key in the entry.\n    pub fn key(&self) -> &K {\n        &self.values_entry.key()\n    }\n\n    /// Take the ownership of the key and value from the map.\n    pub fn remove_entry(self) -> (K, V) {\n        let k = self.values_entry.key().to_owned();\n        let v = self.values_entry.remove();\n        self.keys\n            .take(v.key_index)\n            .expect(\"`key_index` must point to a valid key entry\");\n        (k, v.value)\n    }\n\n    /// Gets a reference to the value in the entry.\n    pub fn get(&self) -> &V {\n        &self.values_entry.get().value\n    }\n\n    /// Gets a mutable reference to the value in the entry.\n    ///\n    /// If you need a reference to the `OccupiedEntry` which may outlive the destruction of the\n    /// `Entry` value, see `into_mut`.\n    pub fn get_mut(&mut self) -> &mut V {\n        &mut self.values_entry.get_mut().value\n    }\n\n    /// Sets the value of the entry, and returns the entry's old value.\n    pub fn insert(&mut self, new_value: V) -> V {\n        core::mem::replace(&mut self.values_entry.get_mut().value, new_value)\n    }\n\n    /// Takes the value out of the entry, and returns it.\n    pub fn remove(self) -> V {\n        self.remove_entry().1\n    }\n\n    /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n    /// with a lifetime bound to the map itself.\n    pub fn into_mut(self) -> &'a mut V {\n        &mut self.values_entry.into_mut().value\n    }\n}\n"],["960","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::{\n    HashMap as StorageHashMap,\n    Iter,\n    IterMut,\n};\nuse crate::traits::PackedLayout;\nuse core::{\n    cmp::{\n        Eq,\n        Ord,\n        PartialEq,\n    },\n    iter::FromIterator,\n    ops,\n};\nuse ink_env::hash::{\n    CryptoHash,\n    HashOutput,\n};\nuse ink_prelude::borrow::{\n    Borrow,\n    ToOwned,\n};\nuse ink_primitives::Key;\n\nimpl<K, V, H> Drop for StorageHashMap<K, V, H>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    fn drop(&mut self) {\n        self.clear_cells();\n    }\n}\n\nimpl<K, V, H> Default for StorageHashMap<K, V, H>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl<'a, K, V, H, Q> ops::Index<&'a Q> for StorageHashMap<K, V, H>\nwhere\n    Q: Ord + scale::Encode + ToOwned<Owned = K>,\n    K: Borrow<Q> + Ord + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    type Output = V;\n\n    fn index(&self, index: &Q) -> &Self::Output {\n        self.get(index).expect(\"index out of bounds\")\n    }\n}\n\nimpl<'a, K, V, H, Q> ops::IndexMut<&'a Q> for StorageHashMap<K, V, H>\nwhere\n    Q: Ord + scale::Encode + ToOwned<Owned = K>,\n    K: Borrow<Q> + Ord + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    fn index_mut(&mut self, index: &Q) -> &mut Self::Output {\n        self.get_mut(index).expect(\"index out of bounds\")\n    }\n}\n\nimpl<'a, K: 'a, V: 'a, H> IntoIterator for &'a StorageHashMap<K, V, H>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    type Item = (&'a K, &'a V);\n    type IntoIter = Iter<'a, K, V, H>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.iter()\n    }\n}\n\nimpl<'a, K: 'a, V: 'a, H> IntoIterator for &'a mut StorageHashMap<K, V, H>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    type Item = (&'a K, &'a mut V);\n    type IntoIter = IterMut<'a, K, V, H>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.iter_mut()\n    }\n}\n\nimpl<K, V, H> Extend<(K, V)> for StorageHashMap<K, V, H>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    fn extend<I>(&mut self, iter: I)\n    where\n        I: IntoIterator<Item = (K, V)>,\n    {\n        for (key, value) in iter {\n            self.insert(key, value);\n        }\n    }\n}\n\nimpl<K, V, H> FromIterator<(K, V)> for StorageHashMap<K, V, H>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = (K, V)>,\n    {\n        let mut vec = StorageHashMap::new();\n        vec.extend(iter);\n        vec\n    }\n}\n\nimpl<K, V, H> PartialEq for StorageHashMap<K, V, H>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PartialEq + PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    fn eq(&self, other: &Self) -> bool {\n        if self.len() != other.len() {\n            return false\n        }\n        self.iter()\n            .map(|(key, value)| (value, other.get(key)))\n            .all(|(lhs, maybe_rhs)| maybe_rhs.map(|rhs| rhs == lhs).unwrap_or(false))\n    }\n}\n\nimpl<K, V, H> Eq for StorageHashMap<K, V, H>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: Eq + PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n}\n"],["961","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! A small storage vector that allows to store a limited amount of elements.\n//!\n//! Prefer using [`SmallVec`] over [`Vec`][`crate::Vec`] if you know up front\n//! the maximum amount of unique elements that have to be stored in the vector\n//! at the same time, given the number is fairly low: e.g. not exceeding several\n//! hundreds of elements.\n\nmod impls;\nmod iter;\nmod storage;\n\n#[cfg(test)]\nmod tests;\n\npub use self::iter::{\n    Iter,\n    IterMut,\n};\nuse crate::{\n    lazy::{\n        Lazy,\n        LazyArray,\n    },\n    traits::PackedLayout,\n};\n\n/// The used index type.\ntype Index = u32;\n\n/// A contiguous growable array type.\n///\n/// # Note\n///\n/// - The `storage::SmallVec` has a very similar API compared to a `storage::Vec`.\n///   The major difference between both data structures is that the `SmallVec`\n///   can only contain up to a fixed amount of elements given by `N` whereas the\n///   `Vec` can contain up to 2^32 elements which is the maximum for 32-bit Wasm\n///   targets.\n/// - The performance characteristics may be different from Rust's\n///   `Vec` due to the internal differences.\n/// - Allows to store up to N elements.\n#[derive(Debug)]\npub struct SmallVec<T, const N: usize>\nwhere\n    T: PackedLayout,\n{\n    /// The current length of the small vector.\n    len: Lazy<u32>,\n    /// The entries of the small vector.\n    elems: LazyArray<T, N>,\n}\n\nimpl<T, const N: usize> Default for SmallVec<T, N>\nwhere\n    T: PackedLayout,\n{\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl<T, const N: usize> SmallVec<T, N>\nwhere\n    T: PackedLayout,\n{\n    /// Clears the underlying storage cells of the storage vector.\n    ///\n    /// # Note\n    ///\n    /// This completely invalidates the storage vector's invariants about\n    /// the contents of its associated storage region.\n    ///\n    /// This API is used for the `Drop` implementation of [`Vec`] as well as\n    /// for the [`SpreadLayout::clear_spread`][`crate::traits::SpreadLayout::clear_spread`]\n    /// trait implementation.\n    fn clear_cells(&self) {\n        if self.elems.key().is_none() {\n            // We won't clear any storage if we are in lazy state since there\n            // probably has not been any state written to storage, yet.\n            return\n        }\n        for index in 0..self.len() {\n            self.elems.clear_packed_at(index);\n        }\n    }\n}\n\nimpl<T, const N: usize> SmallVec<T, N>\nwhere\n    T: PackedLayout,\n{\n    /// Creates a new empty vector.\n    pub fn new() -> Self {\n        Self {\n            len: Lazy::new(0),\n            elems: Default::default(),\n        }\n    }\n\n    /// Returns the capacity of the small vector.\n    #[inline]\n    pub fn capacity(&self) -> u32 {\n        self.elems.capacity()\n    }\n\n    /// Returns the number of elements in the vector, also referred to as its 'length'.\n    #[inline]\n    pub fn len(&self) -> u32 {\n        *self.len\n    }\n\n    /// Returns `true` if the vector contains no elements.\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n}\n\nimpl<T, const N: usize> SmallVec<T, N>\nwhere\n    T: PackedLayout,\n{\n    /// Returns an iterator yielding shared references to all elements.\n    ///\n    /// # Note\n    ///\n    /// - Avoid unbounded iteration over big storage vectors.\n    /// - Prefer using methods like `Iterator::take` in order to limit the number\n    ///   of yielded elements.\n    pub fn iter(&self) -> Iter<T, N> {\n        Iter::new(self)\n    }\n\n    /// Returns an iterator yielding exclusive references to all elements.\n    ///\n    /// # Note\n    ///\n    /// - Avoid unbounded iteration over big storage vectors.\n    /// - Prefer using methods like `Iterator::take` in order to limit the number\n    ///   of yielded elements.\n    pub fn iter_mut(&mut self) -> IterMut<T, N> {\n        IterMut::new(self)\n    }\n\n    /// Returns the index if it is witihn bounds or `None` otherwise.\n    fn within_bounds(&self, index: Index) -> Option<Index> {\n        if index < self.len() {\n            return Some(index)\n        }\n        None\n    }\n\n    /// Returns a shared reference to the first element if any.\n    pub fn first(&self) -> Option<&T> {\n        if self.is_empty() {\n            return None\n        }\n        self.get(0)\n    }\n\n    /// Returns a shared reference to the last element if any.\n    pub fn last(&self) -> Option<&T> {\n        if self.is_empty() {\n            return None\n        }\n        let last_index = self.len() - 1;\n        self.get(last_index)\n    }\n\n    /// Returns a shared reference to the indexed element.\n    ///\n    /// Returns `None` if `index` is out of bounds.\n    pub fn get(&self, index: u32) -> Option<&T> {\n        self.within_bounds(index)\n            .and_then(|index| self.elems.get(index))\n    }\n}\n\nimpl<T, const N: usize> SmallVec<T, N>\nwhere\n    T: PackedLayout,\n{\n    /// Appends an element to the back of the vector.\n    pub fn push(&mut self, value: T) {\n        assert!(\n            self.len() < self.capacity(),\n            \"cannot push more elements into the vector\"\n        );\n        let last_index = self.len();\n        *self.len += 1;\n        self.elems.put(last_index, Some(value));\n    }\n}\n\nimpl<T, const N: usize> SmallVec<T, N>\nwhere\n    T: PackedLayout,\n{\n    /// Pops the last element from the vector and returns it.\n    //\n    /// Returns `None` if the vector is empty.\n    pub fn pop(&mut self) -> Option<T> {\n        if self.is_empty() {\n            return None\n        }\n        let last_index = self.len() - 1;\n        *self.len = last_index;\n        self.elems.put_get(last_index, None)\n    }\n\n    /// Pops the last element from the vector and immediately drops it.\n    ///\n    /// Returns `Some(())` if an element has been removed and `None` otherwise.\n    ///\n    /// # Note\n    ///\n    /// This operation is a bit more efficient than [`SmallVec::pop`]\n    /// since it avoids reading from contract storage in some use cases.\n    pub fn pop_drop(&mut self) -> Option<()> {\n        if self.is_empty() {\n            return None\n        }\n        let last_index = self.len() - 1;\n        *self.len = last_index;\n        self.elems.put(last_index, None);\n        Some(())\n    }\n\n    /// Returns an exclusive reference to the first element if any.\n    pub fn first_mut(&mut self) -> Option<&mut T> {\n        if self.is_empty() {\n            return None\n        }\n        self.get_mut(0)\n    }\n\n    /// Returns an exclusive reference to the last element if any.\n    pub fn last_mut(&mut self) -> Option<&mut T> {\n        if self.is_empty() {\n            return None\n        }\n        let last_index = self.len() - 1;\n        self.get_mut(last_index)\n    }\n\n    /// Returns an exclusive reference to the indexed element.\n    ///\n    /// Returns `None` if `index` is out of bounds.\n    pub fn get_mut(&mut self, index: u32) -> Option<&mut T> {\n        self.within_bounds(index)\n            .and_then(move |index| self.elems.get_mut(index))\n    }\n\n    /// Swaps the elements at the given indices.\n    ///\n    /// # Panics\n    ///\n    /// If one or both indices are out of bounds.\n    pub fn swap(&mut self, a: u32, b: u32) {\n        assert!(\n            a < self.len() && b < self.len(),\n            \"indices are out of bounds\"\n        );\n        self.elems.swap(a, b)\n    }\n\n    /// Removes the indexed element from the vector and returns it.\n    ///\n    /// The last element of the vector is put into the indexed slot.\n    /// Returns `None` and does not mutate the vector if the index is out of bounds.\n    ///\n    /// # Note\n    ///\n    /// This operation does not preserve ordering but is constant time.\n    pub fn swap_remove(&mut self, n: u32) -> Option<T> {\n        if self.is_empty() {\n            return None\n        }\n        self.elems.swap(n, self.len() - 1);\n        self.pop()\n    }\n\n    /// Removes the indexed element from the vector.\n    ///\n    /// The last element of the vector is put into the indexed slot.\n    /// Returns `Some(())` if an element has been removed and `None` otherwise.\n    ///\n    /// # Note\n    ///\n    /// This operation should be preferred over [`Vec::swap_remove`] if there is\n    /// no need to return the removed element since it avoids a contract storage\n    /// read for some use cases.\n    pub fn swap_remove_drop(&mut self, n: u32) -> Option<()> {\n        if self.is_empty() {\n            return None\n        }\n        self.elems.put(n, None);\n        let last_index = self.len() - 1;\n        let last = self.elems.put_get(last_index, None);\n        self.elems.put(n, last);\n        *self.len = last_index;\n        Some(())\n    }\n}\n"],["962","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::SmallVec;\nuse crate::traits::{\n    KeyPtr,\n    PackedLayout,\n    SpreadLayout,\n};\n\n#[cfg(feature = \"std\")]\nconst _: () = {\n    #[cfg(feature = \"ink-unstable\")]\n    use crate::lazy::LazyArray;\n    use crate::traits::StorageLayout;\n    use ink_metadata::layout::{\n        FieldLayout,\n        Layout,\n        StructLayout,\n    };\n    use scale_info::TypeInfo;\n\n    impl<T, const N: usize> StorageLayout for SmallVec<T, N>\n    where\n        T: PackedLayout + TypeInfo + 'static,\n    {\n        fn layout(key_ptr: &mut KeyPtr) -> Layout {\n            Layout::Struct(StructLayout::new(vec![\n                FieldLayout::new(\"len\", <u32 as StorageLayout>::layout(key_ptr)),\n                FieldLayout::new(\n                    \"elems\",\n                    <LazyArray<T, N> as StorageLayout>::layout(key_ptr),\n                ),\n            ]))\n        }\n    }\n};\n\nimpl<T, const N: usize> SpreadLayout for SmallVec<T, N>\nwhere\n    T: PackedLayout,\n{\n    const FOOTPRINT: u64 = 1 + N as u64;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        Self {\n            len: SpreadLayout::pull_spread(ptr),\n            elems: SpreadLayout::pull_spread(ptr),\n        }\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        SpreadLayout::push_spread(&self.len, ptr);\n        SpreadLayout::push_spread(&self.elems, ptr);\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        self.clear_cells();\n        SpreadLayout::clear_spread(&self.len, ptr);\n        SpreadLayout::clear_spread(&self.elems, ptr);\n    }\n}\n"],["963","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::{\n    Iter,\n    SmallVec,\n};\nuse crate::traits::PackedLayout;\nuse core::iter::{\n    Extend,\n    FromIterator,\n};\n\nimpl<T, const N: usize> Drop for SmallVec<T, N>\nwhere\n    T: PackedLayout,\n{\n    fn drop(&mut self) {\n        self.clear_cells()\n    }\n}\n\nimpl<T, const N: usize> core::ops::Index<u32> for SmallVec<T, N>\nwhere\n    T: PackedLayout,\n{\n    type Output = T;\n\n    fn index(&self, index: u32) -> &Self::Output {\n        match self.get(index) {\n            Some(value) => value,\n            None => {\n                panic!(\n                    \"index out of bounds: the len is {} but the index is {}\",\n                    self.len(),\n                    index\n                )\n            }\n        }\n    }\n}\n\nimpl<T, const N: usize> core::ops::IndexMut<u32> for SmallVec<T, N>\nwhere\n    T: PackedLayout,\n{\n    fn index_mut(&mut self, index: u32) -> &mut Self::Output {\n        let len = self.len();\n        match self.get_mut(index) {\n            Some(value) => value,\n            None => {\n                panic!(\n                    \"index out of bounds: the len is {} but the index is {}\",\n                    len, index\n                )\n            }\n        }\n    }\n}\n\nimpl<'a, T: 'a, const N: usize> IntoIterator for &'a SmallVec<T, N>\nwhere\n    T: PackedLayout,\n{\n    type Item = &'a T;\n    type IntoIter = Iter<'a, T, N>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.iter()\n    }\n}\n\nimpl<T, const N: usize> Extend<T> for SmallVec<T, N>\nwhere\n    T: PackedLayout,\n{\n    fn extend<I>(&mut self, iter: I)\n    where\n        I: IntoIterator<Item = T>,\n    {\n        for item in iter {\n            self.push(item)\n        }\n    }\n}\n\nimpl<T, const N: usize> FromIterator<T> for SmallVec<T, N>\nwhere\n    T: PackedLayout,\n{\n    fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = T>,\n    {\n        let mut vec = SmallVec::new();\n        vec.extend(iter);\n        vec\n    }\n}\n\nimpl<T, const N: usize> core::cmp::PartialEq for SmallVec<T, N>\nwhere\n    T: PartialEq + PackedLayout,\n{\n    fn eq(&self, other: &Self) -> bool {\n        if self.len() != other.len() {\n            return false\n        }\n        self.iter().zip(other.iter()).all(|(lhs, rhs)| lhs == rhs)\n    }\n}\n\nimpl<T, const N: usize> core::cmp::Eq for SmallVec<T, N> where T: Eq + PackedLayout {}\n"],["964","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::SmallVec;\nuse crate::{\n    traits::{\n        KeyPtr,\n        SpreadLayout,\n    },\n    Lazy,\n};\nuse ink_primitives::Key;\n\n#[test]\nfn new_vec_works() {\n    let vec = <SmallVec<i32, 4>>::new();\n    assert!(vec.is_empty());\n    assert_eq!(vec.len(), 0);\n    assert_eq!(vec.get(0), None);\n    assert!(vec.iter().next().is_none());\n    let default = <SmallVec<i32, 4> as Default>::default();\n    assert!(default.is_empty());\n    assert_eq!(default.len(), 0);\n    assert_eq!(vec.get(0), None);\n    assert!(default.iter().next().is_none());\n}\n\n#[test]\nfn from_iterator_works() {\n    let some_primes = [b'A', b'B', b'C', b'D'];\n    assert_eq!(some_primes.iter().copied().collect::<SmallVec<_, 4>>(), {\n        let mut vec = SmallVec::new();\n        for prime in &some_primes {\n            vec.push(*prime)\n        }\n        vec\n    });\n}\n\n#[test]\n#[should_panic]\nfn from_iterator_too_many() {\n    let some_primes = [b'A', b'B', b'C', b'D', b'E'];\n    let _ = some_primes.iter().copied().collect::<SmallVec<_, 4>>();\n}\n\n#[test]\nfn from_empty_iterator_works() {\n    assert_eq!(\n        [].iter().copied().collect::<SmallVec<u8, 4>>(),\n        SmallVec::new(),\n    );\n}\n\n#[test]\nfn first_last_of_empty() {\n    let mut vec = <SmallVec<u8, 4>>::new();\n    assert_eq!(vec.first(), None);\n    assert_eq!(vec.first_mut(), None);\n    assert_eq!(vec.last(), None);\n    assert_eq!(vec.last_mut(), None);\n}\n\n#[test]\nfn pop_on_empty_works() {\n    let mut vec = <SmallVec<u8, 4>>::new();\n    assert_eq!(vec.pop(), None);\n}\n\n#[test]\nfn push_pop_first_last_works() {\n    /// Asserts conditions are met for the given storage vector.\n    fn assert_vec<F, L>(vec: &SmallVec<u8, 4>, len: u32, first: F, last: L)\n    where\n        F: Into<Option<u8>>,\n        L: Into<Option<u8>>,\n    {\n        assert_eq!(vec.is_empty(), len == 0);\n        assert_eq!(vec.len(), len);\n        assert_eq!(vec.first().copied(), first.into());\n        assert_eq!(vec.last().copied(), last.into());\n    }\n\n    let mut vec = SmallVec::new();\n    assert_vec(&vec, 0, None, None);\n\n    // Sequence of `push`\n    vec.push(b'A');\n    assert_vec(&vec, 1, b'A', b'A');\n    vec.push(b'B');\n    assert_vec(&vec, 2, b'A', b'B');\n    vec.push(b'C');\n    assert_vec(&vec, 3, b'A', b'C');\n    vec.push(b'D');\n    assert_vec(&vec, 4, b'A', b'D');\n\n    // Sequence of `pop`\n    assert_eq!(vec.pop(), Some(b'D'));\n    assert_vec(&vec, 3, b'A', b'C');\n    assert_eq!(vec.pop(), Some(b'C'));\n    assert_vec(&vec, 2, b'A', b'B');\n    assert_eq!(vec.pop(), Some(b'B'));\n    assert_vec(&vec, 1, b'A', b'A');\n    assert_eq!(vec.pop(), Some(b'A'));\n    assert_vec(&vec, 0, None, None);\n\n    // Pop from empty vector.\n    assert_eq!(vec.pop(), None);\n    assert_vec(&vec, 0, None, None);\n}\n\n#[test]\n#[should_panic]\nfn push_beyond_limits_fails() {\n    let mut vec = [b'A', b'B', b'C', b'D']\n        .iter()\n        .copied()\n        .collect::<SmallVec<_, 4>>();\n    vec.push(b'E');\n}\n\n/// Creates a storage vector from the given slice.\nfn vec_from_slice(slice: &[u8]) -> SmallVec<u8, 4> {\n    slice.iter().copied().collect::<SmallVec<u8, 4>>()\n}\n\n/// Asserts that the the given ordered storage vector elements are equal to the\n/// ordered elements of the given slice.\nfn assert_eq_slice(vec: &SmallVec<u8, 4>, slice: &[u8]) {\n    assert_eq!(vec.len() as usize, slice.len());\n    let vec_copy = vec.iter().copied().collect::<Vec<u8>>();\n    assert_eq!(vec_copy.as_slice(), slice);\n}\n\n#[test]\nfn pop_drop_works() {\n    let elems = [b'A', b'B', b'C', b'D'];\n    let mut vec = vec_from_slice(&elems);\n    assert_eq!(vec.pop_drop(), Some(()));\n    assert_eq_slice(&vec, &elems[0..3]);\n    assert_eq!(vec.pop_drop(), Some(()));\n    assert_eq_slice(&vec, &elems[0..2]);\n    assert_eq!(vec.pop_drop(), Some(()));\n    assert_eq_slice(&vec, &elems[0..1]);\n    assert_eq!(vec.pop_drop(), Some(()));\n    assert_eq_slice(&vec, &[]);\n    assert_eq!(vec.pop_drop(), None);\n    assert_eq_slice(&vec, &[]);\n}\n\n#[test]\nfn get_works() {\n    let elems = [b'A', b'B', b'C', b'D'];\n    let mut vec = vec_from_slice(&elems);\n    for (n, mut expected) in elems.iter().copied().enumerate() {\n        let n = n as u32;\n        assert_eq!(vec.get(n), Some(&expected));\n        assert_eq!(vec.get_mut(n), Some(&mut expected));\n        assert_eq!(&vec[n], &expected);\n        assert_eq!(&mut vec[n], &mut expected);\n    }\n    let len = vec.len();\n    assert_eq!(vec.get(len), None);\n    assert_eq!(vec.get_mut(len), None);\n}\n\n#[test]\n#[should_panic(expected = \"index out of bounds: the len is 3 but the index is 3\")]\nfn index_out_of_bounds_works() {\n    let test_values = [b'a', b'b', b'c'];\n    let vec = vec_from_slice(&test_values);\n    let _ = &vec[test_values.len() as u32];\n}\n\n#[test]\n#[should_panic(expected = \"index out of bounds: the len is 3 but the index is 3\")]\nfn index_mut_out_of_bounds_works() {\n    let test_values = [b'a', b'b', b'c'];\n    let mut vec = vec_from_slice(&test_values);\n    let _ = &mut vec[test_values.len() as u32];\n}\n\n#[test]\nfn iter_next_works() {\n    let elems = [b'A', b'B', b'C', b'D'];\n    let vec = vec_from_slice(&elems);\n    // Test iterator over shared references.\n    let mut iter = vec.iter();\n    assert_eq!(iter.count(), 4);\n    assert_eq!(iter.next(), Some(&b'A'));\n    assert_eq!(iter.next(), Some(&b'B'));\n    assert_eq!(iter.count(), 2);\n    assert_eq!(iter.next(), Some(&b'C'));\n    assert_eq!(iter.next(), Some(&b'D'));\n    assert_eq!(iter.count(), 0);\n    assert_eq!(iter.next(), None);\n    // Test iterator over exclusive references.\n    let mut vec = vec;\n    let mut iter = vec.iter_mut();\n    assert_eq!(iter.next(), Some(&mut b'A'));\n    assert_eq!(iter.next(), Some(&mut b'B'));\n    assert_eq!(iter.next(), Some(&mut b'C'));\n    assert_eq!(iter.next(), Some(&mut b'D'));\n    assert_eq!(iter.next(), None);\n    assert_eq!(iter.count(), 0);\n}\n\n#[test]\nfn iter_nth_works() {\n    let elems = [b'A', b'B', b'C', b'D'];\n    let vec = vec_from_slice(&elems);\n    // Test iterator over shared references.\n    let mut iter = vec.iter();\n    assert_eq!(iter.count(), 4);\n    assert_eq!(iter.nth(1), Some(&b'B'));\n    assert_eq!(iter.count(), 2);\n    assert_eq!(iter.nth(1), Some(&b'D'));\n    assert_eq!(iter.count(), 0);\n    assert_eq!(iter.nth(1), None);\n    // Test iterator over exclusive references.\n    let mut vec = vec;\n    let mut iter = vec.iter_mut();\n    assert_eq!(iter.nth(1), Some(&mut b'B'));\n    assert_eq!(iter.nth(1), Some(&mut b'D'));\n    assert_eq!(iter.nth(1), None);\n    assert_eq!(iter.count(), 0);\n}\n\n#[test]\nfn iter_next_back_works() {\n    let elems = [b'A', b'B', b'C', b'D'];\n    let vec = vec_from_slice(&elems);\n    // Test iterator over shared references.\n    let mut iter = vec.iter().rev();\n    assert_eq!(iter.clone().count(), 4);\n    assert_eq!(iter.next(), Some(&b'D'));\n    assert_eq!(iter.next(), Some(&b'C'));\n    assert_eq!(iter.clone().count(), 2);\n    assert_eq!(iter.next(), Some(&b'B'));\n    assert_eq!(iter.next(), Some(&b'A'));\n    assert_eq!(iter.clone().count(), 0);\n    assert_eq!(iter.next(), None);\n    // Test iterator over exclusive references.\n    let mut vec = vec;\n    let mut iter = vec.iter_mut().rev();\n    assert_eq!(iter.next(), Some(&mut b'D'));\n    assert_eq!(iter.next(), Some(&mut b'C'));\n    assert_eq!(iter.next(), Some(&mut b'B'));\n    assert_eq!(iter.next(), Some(&mut b'A'));\n    assert_eq!(iter.next(), None);\n    assert_eq!(iter.count(), 0);\n}\n\n#[test]\nfn iter_nth_back_works() {\n    let elems = [b'A', b'B', b'C', b'D'];\n    let vec = vec_from_slice(&elems);\n    // Test iterator over shared references.\n    let mut iter = vec.iter().rev();\n    assert_eq!(iter.clone().count(), 4);\n    assert_eq!(iter.nth(1), Some(&b'C'));\n    assert_eq!(iter.clone().count(), 2);\n    assert_eq!(iter.nth(1), Some(&b'A'));\n    assert_eq!(iter.clone().count(), 0);\n    assert_eq!(iter.nth(1), None);\n    // Test iterator over exclusive references.\n    let mut vec = vec;\n    let mut iter = vec.iter_mut().rev();\n    assert_eq!(iter.nth(1), Some(&mut b'C'));\n    assert_eq!(iter.nth(1), Some(&mut b'A'));\n    assert_eq!(iter.nth(1), None);\n    assert_eq!(iter.count(), 0);\n}\n\n#[test]\nfn swap_works() {\n    let elems = [b'A', b'B', b'C', b'D'];\n    let mut vec = vec_from_slice(&elems);\n\n    // Swap at same position is a no-op.\n    for index in 0..elems.len() as u32 {\n        vec.swap(index, index);\n        assert_eq_slice(&vec, &elems);\n    }\n\n    // Swap first and second\n    vec.swap(0, 1);\n    assert_eq_slice(&vec, &[b'B', b'A', b'C', b'D']);\n    // Swap third and last\n    vec.swap(2, 3);\n    assert_eq_slice(&vec, &[b'B', b'A', b'D', b'C']);\n    // Swap first and last\n    vec.swap(0, 3);\n    assert_eq_slice(&vec, &[b'C', b'A', b'D', b'B']);\n}\n\n#[test]\n#[should_panic]\nfn swap_one_invalid_index() {\n    let mut vec = vec_from_slice(&[b'A', b'B', b'C', b'D']);\n    vec.swap(0, vec.len());\n}\n\n#[test]\n#[should_panic]\nfn swap_both_invalid_indices() {\n    let mut vec = vec_from_slice(&[b'A', b'B', b'C', b'D']);\n    vec.swap(vec.len(), vec.len());\n}\n\n#[test]\nfn swap_remove_works() {\n    let mut vec = vec_from_slice(&[b'A', b'B', b'C', b'D']);\n\n    // Swap remove first element.\n    assert_eq!(vec.swap_remove(0), Some(b'A'));\n    assert_eq_slice(&vec, &[b'D', b'B', b'C']);\n    // Swap remove middle element.\n    assert_eq!(vec.swap_remove(1), Some(b'B'));\n    assert_eq_slice(&vec, &[b'D', b'C']);\n    // Swap remove last element.\n    assert_eq!(vec.swap_remove(1), Some(b'C'));\n    assert_eq_slice(&vec, &[b'D']);\n    // Swap remove only element.\n    assert_eq!(vec.swap_remove(0), Some(b'D'));\n    assert_eq_slice(&vec, &[]);\n    // Swap remove from empty vector.\n    assert_eq!(vec.swap_remove(0), None);\n    assert_eq_slice(&vec, &[]);\n}\n\n#[test]\nfn swap_remove_drop_works() {\n    let mut vec = vec_from_slice(&[b'A', b'B', b'C', b'D']);\n\n    // Swap remove first element.\n    assert_eq!(vec.swap_remove_drop(0), Some(()));\n    assert_eq_slice(&vec, &[b'D', b'B', b'C']);\n    // Swap remove middle element.\n    assert_eq!(vec.swap_remove_drop(1), Some(()));\n    assert_eq_slice(&vec, &[b'D', b'C']);\n    // Swap remove last element.\n    assert_eq!(vec.swap_remove_drop(1), Some(()));\n    assert_eq_slice(&vec, &[b'D']);\n    // Swap remove only element.\n    assert_eq!(vec.swap_remove_drop(0), Some(()));\n    assert_eq_slice(&vec, &[]);\n    // Swap remove from empty vector.\n    assert_eq!(vec.swap_remove_drop(0), None);\n    assert_eq_slice(&vec, &[]);\n}\n\n#[test]\nfn spread_layout_push_pull_works() -> ink_env::Result<()> {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let vec1 = vec_from_slice(&[b'a', b'b', b'c', b'd']);\n        let root_key = Key::from([0x42; 32]);\n        SpreadLayout::push_spread(&vec1, &mut KeyPtr::from(root_key));\n        // Load the pushed storage vector into another instance and check that\n        // both instances are equal:\n        let vec2 =\n            <SmallVec<u8, 4> as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n        assert_eq!(vec1, vec2);\n        Ok(())\n    })\n}\n\n#[test]\n#[should_panic(expected = \"encountered empty storage cell\")]\nfn spread_layout_clear_works() {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let vec1 = vec_from_slice(&[b'a', b'b', b'c', b'd']);\n        let root_key = Key::from([0x42; 32]);\n        SpreadLayout::push_spread(&vec1, &mut KeyPtr::from(root_key));\n        // It has already been asserted that a valid instance can be pulled\n        // from contract storage after a push to the same storage region.\n        //\n        // Now clear the associated storage from `vec1` and check whether\n        // loading another instance from this storage will panic since the\n        // vector's length property cannot read a value:\n        SpreadLayout::clear_spread(&vec1, &mut KeyPtr::from(root_key));\n        let _ =\n            <SmallVec<u8, 4> as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n        Ok(())\n    })\n    .unwrap()\n}\n\n#[test]\nfn storage_is_cleared_completely_after_pull_lazy() {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        // given\n        let root_key = Key::from([0x42; 32]);\n        let lazy_vec = Lazy::new(vec_from_slice(&[b'a', b'b', b'c', b'd']));\n        SpreadLayout::push_spread(&lazy_vec, &mut KeyPtr::from(root_key));\n        let pulled_vec = <Lazy<SmallVec<u8, 4>> as SpreadLayout>::pull_spread(\n            &mut KeyPtr::from(root_key),\n        );\n\n        // when\n        SpreadLayout::clear_spread(&pulled_vec, &mut KeyPtr::from(root_key));\n\n        // then\n        let contract_id = ink_env::test::get_current_contract_account_id::<\n            ink_env::DefaultEnvironment,\n        >()\n        .expect(\"contract id must exist\");\n        let used_cells = ink_env::test::count_used_storage_cells::<\n            ink_env::DefaultEnvironment,\n        >(&contract_id)\n        .expect(\"used cells must be returned\");\n        assert_eq!(used_cells, 0);\n\n        Ok(())\n    })\n    .unwrap()\n}\n\n#[test]\n#[should_panic(expected = \"encountered empty storage cell\")]\nfn drop_works() {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let root_key = Key::from([0x42; 32]);\n\n        // if the setup panics it should not cause the test to pass\n        let setup_result = std::panic::catch_unwind(|| {\n            let vec = vec_from_slice(&[b'a', b'b', b'c', b'd']);\n            SpreadLayout::push_spread(&vec, &mut KeyPtr::from(root_key));\n            let _ = <SmallVec<u8, 4> as SpreadLayout>::pull_spread(&mut KeyPtr::from(\n                root_key,\n            ));\n            // vec is dropped which should clear the cells\n        });\n        assert!(setup_result.is_ok(), \"setup should not panic\");\n\n        let contract_id = ink_env::test::get_current_contract_account_id::<\n            ink_env::DefaultEnvironment,\n        >()\n        .expect(\"Cannot get contract id\");\n        let used_cells = ink_env::test::count_used_storage_cells::<\n            ink_env::DefaultEnvironment,\n        >(&contract_id)\n        .expect(\"used cells must be returned\");\n        assert_eq!(used_cells, 0);\n\n        let _ =\n            <SmallVec<u8, 4> as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n        Ok(())\n    })\n    .unwrap()\n}\n"],["965","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::SmallVec;\nuse crate::{\n    collections::extend_lifetime,\n    traits::PackedLayout,\n};\n\n/// An iterator over shared references to the elements of a small storage vector.\n#[derive(Debug, Clone, Copy)]\npub struct Iter<'a, T, const N: usize>\nwhere\n    T: PackedLayout,\n{\n    /// The storage vector to iterate over.\n    vec: &'a SmallVec<T, N>,\n    /// The current begin of the iteration.\n    begin: u32,\n    /// The current end of the iteration.\n    end: u32,\n}\n\nimpl<'a, T, const N: usize> Iter<'a, T, N>\nwhere\n    T: PackedLayout,\n{\n    /// Creates a new iterator for the given storage vector.\n    pub(crate) fn new(vec: &'a SmallVec<T, N>) -> Self {\n        Self {\n            vec,\n            begin: 0,\n            end: vec.len(),\n        }\n    }\n\n    /// Returns the amount of remaining elements to yield by the iterator.\n    fn remaining(&self) -> u32 {\n        self.end - self.begin\n    }\n}\n\nimpl<'a, T, const N: usize> Iterator for Iter<'a, T, N>\nwhere\n    T: PackedLayout,\n{\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        <Self as Iterator>::nth(self, 0)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let remaining = self.remaining() as usize;\n        (remaining, Some(remaining))\n    }\n\n    fn count(self) -> usize {\n        self.remaining() as usize\n    }\n\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        debug_assert!(self.begin <= self.end);\n        let n = n as u32;\n        if self.begin + n >= self.end {\n            return None\n        }\n        let cur = self.begin + n;\n        self.begin += 1 + n;\n        self.vec.get(cur).expect(\"access is within bounds\").into()\n    }\n}\n\nimpl<'a, T, const N: usize> ExactSizeIterator for Iter<'a, T, N> where T: PackedLayout {}\n\nimpl<'a, T, const N: usize> DoubleEndedIterator for Iter<'a, T, N>\nwhere\n    T: PackedLayout,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        <Self as DoubleEndedIterator>::nth_back(self, 0)\n    }\n\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n        debug_assert!(self.begin <= self.end);\n        let n = n as u32;\n        if self.begin >= self.end.saturating_sub(n) {\n            return None\n        }\n        self.end -= 1 + n;\n        self.vec\n            .get(self.end)\n            .expect(\"access is within bounds\")\n            .into()\n    }\n}\n\n/// An iterator over exclusive references to the elements of a small storage vector.\n#[derive(Debug)]\npub struct IterMut<'a, T, const N: usize>\nwhere\n    T: PackedLayout,\n{\n    /// The storage vector to iterate over.\n    vec: &'a mut SmallVec<T, N>,\n    /// The current begin of the iteration.\n    begin: u32,\n    /// The current end of the iteration.\n    end: u32,\n}\n\nimpl<'a, T, const N: usize> IterMut<'a, T, N>\nwhere\n    T: PackedLayout,\n{\n    /// Creates a new iterator for the given storage vector.\n    pub(crate) fn new(vec: &'a mut SmallVec<T, N>) -> Self {\n        let len = vec.len();\n        Self {\n            vec,\n            begin: 0,\n            end: len,\n        }\n    }\n\n    /// Returns the amount of remaining elements to yield by the iterator.\n    fn remaining(&self) -> u32 {\n        self.end - self.begin\n    }\n}\n\nimpl<'a, T, const N: usize> IterMut<'a, T, N>\nwhere\n    T: PackedLayout,\n{\n    fn get_mut<'b>(&'b mut self, at: u32) -> Option<&'a mut T> {\n        self.vec.get_mut(at).map(|value| {\n            // SAFETY: We extend the lifetime of the reference here.\n            //\n            //         This is safe because the iterator yields an exclusive\n            //         reference to every element in the iterated vector\n            //         just once and also there can be only one such iterator\n            //         for the same vector at the same time which is\n            //         guaranteed by the constructor of the iterator.\n            unsafe { extend_lifetime::<'b, 'a, T>(value) }\n        })\n    }\n}\n\nimpl<'a, T, const N: usize> Iterator for IterMut<'a, T, N>\nwhere\n    T: PackedLayout,\n{\n    type Item = &'a mut T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        <Self as Iterator>::nth(self, 0)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let remaining = self.remaining() as usize;\n        (remaining, Some(remaining))\n    }\n\n    fn count(self) -> usize {\n        self.remaining() as usize\n    }\n\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        debug_assert!(self.begin <= self.end);\n        let n = n as u32;\n        if self.begin + n >= self.end {\n            return None\n        }\n        let cur = self.begin + n;\n        self.begin += 1 + n;\n        self.get_mut(cur).expect(\"access is within bounds\").into()\n    }\n}\n\nimpl<'a, T, const N: usize> ExactSizeIterator for IterMut<'a, T, N> where T: PackedLayout {}\n\nimpl<'a, T, const N: usize> DoubleEndedIterator for IterMut<'a, T, N>\nwhere\n    T: PackedLayout,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        <Self as DoubleEndedIterator>::nth_back(self, 0)\n    }\n\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n        debug_assert!(self.begin <= self.end);\n        let n = n as u32;\n        if self.begin >= self.end.saturating_sub(n) {\n            return None\n        }\n        self.end -= 1 + n;\n        self.get_mut(self.end)\n            .expect(\"access is within bounds\")\n            .into()\n    }\n}\n"],["966","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Implementation of generic traits that are useful for the storage stash.\n\nuse super::{\n    Iter,\n    IterMut,\n    Stash as StorageStash,\n};\nuse crate::traits::PackedLayout;\nuse core::iter::{\n    Extend,\n    FromIterator,\n};\n\nimpl<T> Drop for StorageStash<T>\nwhere\n    T: PackedLayout,\n{\n    fn drop(&mut self) {\n        self.clear_cells();\n    }\n}\n\nimpl<T> Default for StorageStash<T>\nwhere\n    T: PackedLayout,\n{\n    fn default() -> Self {\n        StorageStash::new()\n    }\n}\n\nimpl<T> StorageStash<T>\nwhere\n    T: PackedLayout,\n{\n    fn assert_index_within_bounds(&self, index: u32) {\n        if cfg!(debug_assertions) {\n            assert!(\n                index < self.len(),\n                \"index out of bounds: the len is {} but the index is {}\",\n                self.len(),\n                index\n            )\n        }\n    }\n}\n\nimpl<T> core::ops::Index<u32> for StorageStash<T>\nwhere\n    T: PackedLayout,\n{\n    type Output = T;\n\n    fn index(&self, index: u32) -> &Self::Output {\n        self.assert_index_within_bounds(index);\n        match self.get(index) {\n            Some(value) => value,\n            None => panic!(\"indexed vacant entry: at index {}\", index),\n        }\n    }\n}\n\nimpl<T> core::ops::IndexMut<u32> for StorageStash<T>\nwhere\n    T: PackedLayout,\n{\n    fn index_mut(&mut self, index: u32) -> &mut Self::Output {\n        self.assert_index_within_bounds(index);\n        match self.get_mut(index) {\n            Some(value) => value,\n            None => panic!(\"indexed vacant entry: at index {}\", index),\n        }\n    }\n}\n\nimpl<'a, T: 'a> IntoIterator for &'a StorageStash<T>\nwhere\n    T: PackedLayout,\n{\n    type Item = &'a T;\n    type IntoIter = Iter<'a, T>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.iter()\n    }\n}\n\nimpl<'a, T: 'a> IntoIterator for &'a mut StorageStash<T>\nwhere\n    T: PackedLayout,\n{\n    type Item = &'a mut T;\n    type IntoIter = IterMut<'a, T>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.iter_mut()\n    }\n}\n\nimpl<T> Extend<T> for StorageStash<T>\nwhere\n    T: PackedLayout,\n{\n    fn extend<I>(&mut self, iter: I)\n    where\n        I: IntoIterator<Item = T>,\n    {\n        for item in iter {\n            self.put(item);\n        }\n    }\n}\n\nimpl<T> FromIterator<T> for StorageStash<T>\nwhere\n    T: PackedLayout,\n{\n    fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = T>,\n    {\n        let mut vec = StorageStash::new();\n        vec.extend(iter);\n        vec\n    }\n}\n\nimpl<T> core::cmp::PartialEq for StorageStash<T>\nwhere\n    T: PartialEq + PackedLayout,\n{\n    fn eq(&self, other: &Self) -> bool {\n        if self.len() != other.len() {\n            return false\n        }\n        self.iter().zip(other.iter()).all(|(lhs, rhs)| lhs == rhs)\n    }\n}\n\nimpl<T> core::cmp::Eq for StorageStash<T> where T: scale::Decode + Eq + PackedLayout {}\n"],["967","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::Stash as StorageStash;\nuse crate::{\n    traits::{\n        KeyPtr,\n        SpreadLayout,\n    },\n    Lazy,\n};\nuse ink_primitives::Key;\n\n#[test]\nfn regression_stash_unreachable_minified() {\n    // This regression has been discovered in the ERC721 example implementation\n    // `approved_for_all_works` unit test. The fix was to adjust\n    // `Stash::remove_vacant_entry` to update `header.last_vacant` if the\n    // removed index was the last remaining vacant index in the stash.\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let mut stash: StorageStash<u32> = StorageStash::new();\n        stash.put(1);\n        stash.put(2);\n        stash.take(0);\n        stash.put(99);\n        stash.take(1);\n        stash.put(99);\n        Ok(())\n    })\n    .unwrap()\n}\n\n#[test]\nfn new_works() {\n    // `StorageVec::new`\n    let stash = <StorageStash<i32>>::new();\n    assert!(stash.is_empty());\n    assert_eq!(stash.len(), 0);\n    assert_eq!(stash.get(0), None);\n    assert!(stash.iter().next().is_none());\n    // `StorageVec::default`\n    let default = <StorageStash<i32> as Default>::default();\n    assert!(default.is_empty());\n    assert_eq!(default.len(), 0);\n    assert_eq!(stash.get(0), None);\n    assert!(default.iter().next().is_none());\n    // `StorageVec::new` and `StorageVec::default` should be equal.\n    assert_eq!(stash, default);\n}\n\n#[test]\nfn from_iterator_works() {\n    let test_values = [b'A', b'B', b'C', b'D', b'E', b'F'];\n    let stash = test_values.iter().copied().collect::<StorageStash<_>>();\n    assert_eq!(stash, {\n        let mut stash = StorageStash::new();\n        for (index, value) in test_values.iter().enumerate() {\n            assert_eq!(index as u32, stash.put(*value));\n        }\n        stash\n    });\n    assert_eq!(stash.len(), test_values.len() as u32);\n    assert_eq!(stash.is_empty(), false);\n}\n\n#[test]\nfn from_empty_iterator_works() {\n    assert_eq!(\n        [].iter().copied().collect::<StorageStash<i32>>(),\n        StorageStash::new(),\n    );\n}\n\n#[test]\nfn take_from_filled_works() {\n    let test_values = [b'A', b'B', b'C', b'D', b'E', b'F'];\n    let mut stash = test_values.iter().copied().collect::<StorageStash<_>>();\n    for (index, expected_value) in test_values.iter().enumerate() {\n        assert_eq!(stash.take(index as u32), Some(*expected_value));\n    }\n}\n\n#[test]\nfn take_from_empty_works() {\n    let mut stash = <StorageStash<u8>>::new();\n    assert_eq!(stash.take(0), None);\n}\n\n#[test]\nfn take_out_of_bounds_works() {\n    let mut stash = [b'A', b'B', b'C']\n        .iter()\n        .copied()\n        .collect::<StorageStash<_>>();\n    assert_eq!(stash.take(3), None);\n}\n\n#[test]\nfn remove_from_filled_works() {\n    let test_values = [b'A', b'B', b'C', b'D', b'E', b'F'];\n    let mut stash = test_values.iter().copied().collect::<StorageStash<_>>();\n\n    let mut count = stash.len();\n    for (index, val) in test_values.iter().enumerate() {\n        let index = index as u32;\n        assert_eq!(stash.get(index), Some(val));\n        assert_eq!(unsafe { stash.remove_occupied(index) }, Some(()));\n        assert_eq!(stash.get(index), None);\n        count -= 1;\n        assert_eq!(stash.len(), count);\n    }\n    assert_eq!(stash.len(), 0);\n}\n\n#[test]\nfn remove_from_empty_works() {\n    let mut stash = <StorageStash<u8>>::new();\n    assert_eq!(unsafe { stash.remove_occupied(0) }, None);\n}\n\n#[test]\nfn remove_out_of_bounds_works() {\n    let mut stash = [b'A', b'B', b'C']\n        .iter()\n        .copied()\n        .collect::<StorageStash<_>>();\n    assert_eq!(unsafe { stash.remove_occupied(3) }, None);\n}\n\n#[test]\nfn remove_works_with_spread_layout_push_pull() -> ink_env::Result<()> {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        // First populate some storage Stash and writes that to the contract storage using pull_spread\n        // and some known Key.\n        let stash = [b'A', b'B', b'C']\n            .iter()\n            .copied()\n            .collect::<StorageStash<_>>();\n        let root_key = Key::from([0x00; 32]);\n        SpreadLayout::push_spread(&stash, &mut KeyPtr::from(root_key));\n\n        // Then load another instance from the same key lazily and remove some of\n        // the known-to-be-populated entries from it. Afterwards push_spread this second instance and\n        // load yet another using pull_spread again.\n        let mut stash2 =\n            <StorageStash<u8> as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n        assert_eq!(unsafe { stash2.remove_occupied(0) }, Some(()));\n        SpreadLayout::push_spread(&stash2, &mut KeyPtr::from(root_key));\n\n        // This time we check from the third instance using\n        // get if the expected cells are still there or have been successfully removed.\n        let stash3 =\n            <StorageStash<u8> as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n        assert_eq!(stash3.get(0), None);\n        assert_eq!(stash3.get(1), Some(&b'B'));\n        assert_eq!(stash3.get(2), Some(&b'C'));\n        assert_eq!(stash3.len(), 2);\n\n        Ok(())\n    })\n}\n\n#[test]\nfn get_works() {\n    let test_values = [b'A', b'B', b'C', b'D', b'E', b'F'];\n    let mut stash = test_values.iter().copied().collect::<StorageStash<_>>();\n    for (index, &expected_value) in test_values.iter().enumerate() {\n        let mut expected_value = expected_value;\n        let index = index as u32;\n        assert_eq!(stash.get(index), Some(&expected_value));\n        assert_eq!(stash.get_mut(index), Some(&mut expected_value));\n        assert_eq!(&stash[index], &expected_value);\n        assert_eq!(&mut stash[index], &mut expected_value);\n    }\n    // Get out of bounds works:\n    let len = stash.len();\n    assert_eq!(stash.get(len), None);\n    assert_eq!(stash.get_mut(len), None);\n    // Get vacant entry works:\n    assert_eq!(stash.get(1), Some(&b'B'));\n    assert_eq!(stash.get_mut(1), Some(&mut b'B'));\n    assert_eq!(stash.take(1), Some(b'B'));\n    assert_eq!(stash.get(1), None);\n    assert_eq!(stash.get_mut(1), None);\n}\n\n#[cfg(debug_assertions)]\n#[test]\n#[should_panic(expected = \"index out of bounds: the len is 3 but the index is 3\")]\nfn index_out_of_bounds_works() {\n    let test_values = [b'a', b'b', b'c'];\n    let stash = test_values.iter().copied().collect::<StorageStash<_>>();\n    let _ = &stash[test_values.len() as u32];\n}\n\n#[cfg(debug_assertions)]\n#[test]\n#[should_panic(expected = \"index out of bounds: the len is 3 but the index is 3\")]\nfn index_mut_out_of_bounds_works() {\n    let test_values = [b'a', b'b', b'c'];\n    let mut stash = test_values.iter().copied().collect::<StorageStash<_>>();\n    let _ = &mut stash[test_values.len() as u32];\n}\n\n#[test]\n#[should_panic(expected = \"indexed vacant entry: at index 1\")]\nfn index_vacant_works() {\n    let test_values = [b'a', b'b', b'c'];\n    let mut stash = test_values.iter().copied().collect::<StorageStash<_>>();\n    assert_eq!(stash.take(1), Some(b'b'));\n    let _ = &stash[1];\n}\n\n#[test]\n#[should_panic(expected = \"indexed vacant entry: at index 1\")]\nfn index_mut_vacant_works() {\n    let test_values = [b'a', b'b', b'c'];\n    let mut stash = test_values.iter().copied().collect::<StorageStash<_>>();\n    assert_eq!(stash.take(1), Some(b'b'));\n    let _ = &mut stash[1];\n}\n\n#[test]\nfn len_is_empty_works() {\n    let mut stash = StorageStash::new();\n    assert_eq!(stash.len(), 0);\n    assert!(stash.is_empty());\n    stash.put(b'A');\n    assert_eq!(stash.len(), 1);\n    assert!(!stash.is_empty());\n    stash.take(0);\n    assert_eq!(stash.len(), 0);\n    assert!(stash.is_empty());\n}\n\n#[test]\nfn iter_works() {\n    let stash = [b'A', b'B', b'C']\n        .iter()\n        .copied()\n        .collect::<StorageStash<_>>();\n    // Test iterator over shared references.\n    let mut iter = stash.iter();\n    assert_eq!(iter.count(), 3);\n    assert_eq!(iter.next(), Some(&b'A'));\n    assert_eq!(iter.count(), 2);\n    assert_eq!(iter.next(), Some(&b'B'));\n    assert_eq!(iter.count(), 1);\n    assert_eq!(iter.next(), Some(&b'C'));\n    assert_eq!(iter.count(), 0);\n    assert_eq!(iter.next(), None);\n    // Test iterator over exclusive references.\n    let mut stash = stash;\n    let mut iter = stash.iter_mut();\n    assert_eq!(iter.next(), Some(&mut b'A'));\n    assert_eq!(iter.next(), Some(&mut b'B'));\n    assert_eq!(iter.next(), Some(&mut b'C'));\n    assert_eq!(iter.next(), None);\n    assert_eq!(iter.count(), 0);\n}\n\n/// Create a stash that only has vacant entries.\nfn create_vacant_stash() -> StorageStash<u8> {\n    let mut stash = [b'A', b'B', b'C']\n        .iter()\n        .copied()\n        .collect::<StorageStash<_>>();\n    for i in 0..stash.len() {\n        stash.take(i);\n    }\n    assert_eq!(stash.len(), 0);\n    assert!(stash.is_empty());\n    assert_eq!(stash.len_entries(), 3);\n    stash\n}\n\n/// Create a stash where every second entry is vacant.\nfn create_holey_stash() -> StorageStash<u8> {\n    let elements = [b'A', b'B', b'C', b'D', b'E', b'F'];\n    let mut stash = elements.iter().copied().collect::<StorageStash<_>>();\n    for i in 0..stash.len() {\n        stash.take(i * 2);\n    }\n    assert_eq!(stash.len() as usize, elements.len() / 2);\n    assert!(!stash.is_empty());\n    assert_eq!(stash.len_entries() as usize, elements.len());\n    stash\n}\n\n#[test]\nfn iter_over_vacant_works() {\n    let stash = create_vacant_stash();\n    // Test iterator over shared references.\n    let mut iter = stash.iter();\n    assert_eq!(iter.count(), 0);\n    assert_eq!(iter.next(), None);\n    // Test iterator over exclusive references.\n    let mut stash = stash;\n    let mut iter = stash.iter_mut();\n    assert_eq!(iter.next(), None);\n    // Test reverse iterator over shared references.\n    let mut iter = stash.iter().rev();\n    assert_eq!(iter.clone().count(), 0);\n    assert_eq!(iter.next(), None);\n    // Test reverse iterator over exclusive references.\n    let mut stash = stash;\n    let mut iter = stash.iter_mut().rev();\n    assert_eq!(iter.next(), None);\n}\n\n#[test]\nfn iter_over_holey_works() {\n    let stash = create_holey_stash();\n    // Test iterator over shared references.\n    let mut iter = stash.iter();\n    assert_eq!(iter.count(), 3);\n    assert_eq!(iter.next(), Some(&b'B'));\n    assert_eq!(iter.count(), 2);\n    assert_eq!(iter.next(), Some(&b'D'));\n    assert_eq!(iter.count(), 1);\n    assert_eq!(iter.next(), Some(&b'F'));\n    assert_eq!(iter.count(), 0);\n    assert_eq!(iter.next(), None);\n    // Test iterator over exclusive references.\n    let mut stash = stash;\n    let mut iter = stash.iter_mut();\n    assert_eq!(iter.next(), Some(&mut b'B'));\n    assert_eq!(iter.next(), Some(&mut b'D'));\n    assert_eq!(iter.next(), Some(&mut b'F'));\n    assert_eq!(iter.next(), None);\n    assert_eq!(iter.count(), 0);\n}\n\n#[test]\nfn iter_rev_over_holey_works() {\n    let stash = create_holey_stash();\n    // Test iterator over shared references.\n    let mut iter = stash.iter().rev();\n    assert_eq!(iter.clone().count(), 3);\n    assert_eq!(iter.next(), Some(&b'F'));\n    assert_eq!(iter.clone().count(), 2);\n    assert_eq!(iter.next(), Some(&b'D'));\n    assert_eq!(iter.clone().count(), 1);\n    assert_eq!(iter.next(), Some(&b'B'));\n    assert_eq!(iter.clone().count(), 0);\n    assert_eq!(iter.next(), None);\n    // Test iterator over exclusive references.\n    let mut stash = stash;\n    let mut iter = stash.iter_mut().rev();\n    assert_eq!(iter.next(), Some(&mut b'F'));\n    assert_eq!(iter.next(), Some(&mut b'D'));\n    assert_eq!(iter.next(), Some(&mut b'B'));\n    assert_eq!(iter.next(), None);\n    assert_eq!(iter.count(), 0);\n}\n\n#[test]\nfn iter_rev_works() {\n    let stash = [b'A', b'B', b'C']\n        .iter()\n        .copied()\n        .collect::<StorageStash<_>>();\n    // Test iterator over shared references.\n    let mut iter = stash.iter().rev();\n    assert_eq!(iter.next(), Some(&b'C'));\n    assert_eq!(iter.next(), Some(&b'B'));\n    assert_eq!(iter.next(), Some(&b'A'));\n    assert_eq!(iter.next(), None);\n    // Test iterator over exclusive references.\n    let mut stash = stash;\n    let mut iter = stash.iter_mut().rev();\n    assert_eq!(iter.next(), Some(&mut b'C'));\n    assert_eq!(iter.next(), Some(&mut b'B'));\n    assert_eq!(iter.next(), Some(&mut b'A'));\n    assert_eq!(iter.next(), None);\n}\n\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\nstruct EntryMove {\n    from: u32,\n    to: u32,\n    value: u8,\n}\n\n#[test]\nfn simple_defrag_works() {\n    let mut stash = [b'A', b'B', b'C', b'D', b'E', b'F']\n        .iter()\n        .copied()\n        .collect::<StorageStash<_>>();\n    assert_eq!(stash.len(), 6);\n    assert_eq!(stash.len_entries(), 6);\n    assert_eq!(stash.take(3), Some(b'D'));\n    assert_eq!(stash.take(1), Some(b'B'));\n    assert_eq!(stash.take(5), Some(b'F'));\n    assert_eq!(stash.take(4), Some(b'E'));\n    assert_eq!(stash.len(), 2);\n    assert_eq!(stash.len_entries(), 6);\n    // Now stash looks like this:\n    //\n    //    i | 0 | 1 | 2 | 3 | 4 | 5 |\n    // next |   |   |   |   |   |   |\n    // prev |   |   |   |   |   |   |\n    //  val | A |   | C |   |   |   |\n    //\n    // After defrag the stash should look like this:\n    //\n    //    i | 0 | 1 |\n    // next |   |   |\n    // prev |   |   |\n    //  val | A | C |\n    let mut entry_moves = Vec::new();\n    let callback = |from, to, value: &u8| {\n        entry_moves.push(EntryMove {\n            from,\n            to,\n            value: *value,\n        });\n    };\n    assert_eq!(stash.defrag(None, callback), 4);\n    assert_eq!(stash.len(), 2);\n    assert_eq!(stash.len_entries(), 2);\n    assert_eq!(stash.get(0), Some(&b'A'));\n    assert_eq!(stash.get(1), Some(&b'C'));\n    assert_eq!(\n        &entry_moves,\n        &[EntryMove {\n            from: 2,\n            to: 1,\n            value: 67\n        }]\n    );\n}\n\n/// Returns a storage stash that looks internally like this:\n///\n///    i | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |\n/// next |   |   |   |   |   |   |   |   |\n/// prev |   |   |   |   |   |   |   |   |\n///  val |   |   |   |   | E |   |   | H |\nfn complex_defrag_setup() -> StorageStash<u8> {\n    let mut stash = [b'A', b'B', b'C', b'D', b'E', b'F', b'G', b'H']\n        .iter()\n        .copied()\n        .collect::<StorageStash<_>>();\n    assert_eq!(stash.len(), 8);\n    assert_eq!(stash.len_entries(), 8);\n    // Remove some of the entries in specific order.\n    assert_eq!(stash.take(0), Some(b'A'));\n    assert_eq!(stash.take(6), Some(b'G'));\n    assert_eq!(stash.take(1), Some(b'B'));\n    assert_eq!(stash.take(5), Some(b'F'));\n    assert_eq!(stash.take(2), Some(b'C'));\n    assert_eq!(stash.take(3), Some(b'D'));\n    assert_eq!(stash.len(), 2);\n    assert_eq!(stash.len_entries(), 8);\n    stash\n}\n\n/// Returns the expected entry move set for the complex defragmentation test.\nfn complex_defrag_expected_moves() -> &'static [EntryMove] {\n    &[\n        EntryMove {\n            from: 7,\n            to: 0,\n            value: 72,\n        },\n        EntryMove {\n            from: 4,\n            to: 1,\n            value: 69,\n        },\n    ]\n}\n\n#[test]\nfn complex_defrag_works() {\n    let mut stash = complex_defrag_setup();\n    let mut entry_moves = Vec::new();\n    let callback = |from, to, value: &u8| {\n        entry_moves.push(EntryMove {\n            from,\n            to,\n            value: *value,\n        });\n    };\n    assert_eq!(stash.defrag(None, callback), 6);\n    // After defrag the stash should look like this:\n    //\n    //    i | 0 | 1 |\n    // next |   |   |\n    // prev |   |   |\n    //  val | H | E |\n    assert_eq!(stash.len(), 2);\n    assert_eq!(stash.len_entries(), 2);\n    assert_eq!(stash.get(0), Some(&b'H'));\n    assert_eq!(stash.get(1), Some(&b'E'));\n    assert_eq!(entry_moves.as_slice(), complex_defrag_expected_moves());\n}\n\n#[test]\nfn incremental_defrag_works() {\n    // This tests asserts that incremental defragmentation of storage stashes\n    // yields the same result as immediate defragmentation of the same stash.\n    let mut stash = complex_defrag_setup();\n    let mut entry_moves = Vec::new();\n    let mut callback = |from, to, value: &u8| {\n        entry_moves.push(EntryMove {\n            from,\n            to,\n            value: *value,\n        });\n    };\n    let len_entries_before = stash.len_entries();\n    for i in 0..stash.len_entries() {\n        stash.defrag(Some(1), &mut callback);\n        assert_eq!(\n            stash.len_entries(),\n            core::cmp::max(2, len_entries_before - i - 1)\n        );\n    }\n    // After defrag the stash should look like this:\n    //\n    //    i | 0 | 1 |\n    // next |   |   |\n    // prev |   |   |\n    //  val | H | E |\n    assert_eq!(stash.len(), 2);\n    assert_eq!(stash.len_entries(), 2);\n    assert_eq!(stash.get(0), Some(&b'H'));\n    assert_eq!(stash.get(1), Some(&b'E'));\n    assert_eq!(entry_moves.as_slice(), complex_defrag_expected_moves());\n}\n\n#[derive(Debug, PartialEq, Eq)]\nenum Entry {\n    /// Vacant entry with `prev` and `next` links.\n    Vacant(u32, u32),\n    /// Occupied entry with value.\n    Occupied(u8),\n}\n\nfn entries_of_stash(stash: &StorageStash<u8>) -> Vec<Entry> {\n    stash\n        .entries()\n        .map(|entry| {\n            use super::Entry as StashEntry;\n            match entry {\n                StashEntry::Vacant(entry) => Entry::Vacant(entry.prev, entry.next),\n                StashEntry::Occupied(value) => Entry::Occupied(*value),\n            }\n        })\n        .collect::<Vec<_>>()\n}\n\n#[test]\nfn take_in_order_works() {\n    let mut stash = [b'A', b'B', b'C', b'D']\n        .iter()\n        .copied()\n        .collect::<StorageStash<_>>();\n    assert_eq!(stash.len(), 4);\n    assert_eq!(stash.len_entries(), 4);\n    assert_eq!(stash.last_vacant_index(), None);\n    assert_eq!(\n        entries_of_stash(&stash),\n        vec![\n            Entry::Occupied(b'A'),\n            Entry::Occupied(b'B'),\n            Entry::Occupied(b'C'),\n            Entry::Occupied(b'D')\n        ]\n    );\n    // Take first.\n    assert_eq!(stash.take(0), Some(b'A'));\n    assert_eq!(stash.len(), 3);\n    assert_eq!(stash.len_entries(), 4);\n    assert_eq!(stash.last_vacant_index(), Some(0));\n    assert_eq!(\n        entries_of_stash(&stash),\n        vec![\n            Entry::Vacant(0, 0),\n            Entry::Occupied(b'B'),\n            Entry::Occupied(b'C'),\n            Entry::Occupied(b'D')\n        ]\n    );\n    // Take second.\n    assert_eq!(stash.take(1), Some(b'B'));\n    assert_eq!(stash.len(), 2);\n    assert_eq!(stash.len_entries(), 4);\n    assert_eq!(stash.last_vacant_index(), Some(0));\n    assert_eq!(\n        entries_of_stash(&stash),\n        vec![\n            Entry::Vacant(1, 1),\n            Entry::Vacant(0, 0),\n            Entry::Occupied(b'C'),\n            Entry::Occupied(b'D')\n        ]\n    );\n    // Take third.\n    assert_eq!(stash.take(2), Some(b'C'));\n    assert_eq!(stash.len(), 1);\n    assert_eq!(stash.len_entries(), 4);\n    assert_eq!(stash.last_vacant_index(), Some(0));\n    assert_eq!(\n        entries_of_stash(&stash),\n        vec![\n            Entry::Vacant(2, 1),\n            Entry::Vacant(0, 2),\n            Entry::Vacant(1, 0),\n            Entry::Occupied(b'D')\n        ]\n    );\n    // Take last.\n    assert_eq!(stash.take(3), Some(b'D'));\n    assert_eq!(stash.len(), 0);\n    assert_eq!(stash.len_entries(), 4);\n    assert_eq!(stash.last_vacant_index(), Some(0));\n    assert_eq!(\n        entries_of_stash(&stash),\n        vec![\n            Entry::Vacant(3, 1),\n            Entry::Vacant(0, 2),\n            Entry::Vacant(1, 3),\n            Entry::Vacant(2, 0),\n        ]\n    );\n}\n\n#[test]\nfn take_rev_order_works() {\n    let mut stash = [b'A', b'B', b'C', b'D']\n        .iter()\n        .copied()\n        .collect::<StorageStash<_>>();\n    assert_eq!(stash.len(), 4);\n    assert_eq!(stash.len_entries(), 4);\n    assert_eq!(stash.last_vacant_index(), None);\n    assert_eq!(\n        entries_of_stash(&stash),\n        vec![\n            Entry::Occupied(b'A'),\n            Entry::Occupied(b'B'),\n            Entry::Occupied(b'C'),\n            Entry::Occupied(b'D')\n        ]\n    );\n    // Take last.\n    assert_eq!(stash.take(3), Some(b'D'));\n    assert_eq!(stash.len(), 3);\n    assert_eq!(stash.len_entries(), 4);\n    assert_eq!(stash.last_vacant_index(), Some(3));\n    assert_eq!(\n        entries_of_stash(&stash),\n        vec![\n            Entry::Occupied(b'A'),\n            Entry::Occupied(b'B'),\n            Entry::Occupied(b'C'),\n            Entry::Vacant(3, 3)\n        ]\n    );\n    // Take third.\n    assert_eq!(stash.take(2), Some(b'C'));\n    assert_eq!(stash.len(), 2);\n    assert_eq!(stash.len_entries(), 4);\n    assert_eq!(stash.last_vacant_index(), Some(2));\n    assert_eq!(\n        entries_of_stash(&stash),\n        vec![\n            Entry::Occupied(b'A'),\n            Entry::Occupied(b'B'),\n            Entry::Vacant(3, 3),\n            Entry::Vacant(2, 2)\n        ]\n    );\n    // Take second.\n    assert_eq!(stash.take(1), Some(b'B'));\n    assert_eq!(stash.len(), 1);\n    assert_eq!(stash.len_entries(), 4);\n    assert_eq!(stash.last_vacant_index(), Some(1));\n    assert_eq!(\n        entries_of_stash(&stash),\n        vec![\n            Entry::Occupied(b'A'),\n            Entry::Vacant(3, 2),\n            Entry::Vacant(1, 3),\n            Entry::Vacant(2, 1)\n        ]\n    );\n    // Take first.\n    assert_eq!(stash.take(0), Some(b'A'));\n    assert_eq!(stash.len(), 0);\n    assert_eq!(stash.len_entries(), 4);\n    assert_eq!(stash.last_vacant_index(), Some(0));\n    assert_eq!(\n        entries_of_stash(&stash),\n        vec![\n            Entry::Vacant(3, 1),\n            Entry::Vacant(0, 2),\n            Entry::Vacant(1, 3),\n            Entry::Vacant(2, 0)\n        ]\n    );\n}\n\n#[test]\nfn spread_layout_push_pull_works() -> ink_env::Result<()> {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let stash1 = create_holey_stash();\n        let root_key = Key::from([0x42; 32]);\n        SpreadLayout::push_spread(&stash1, &mut KeyPtr::from(root_key));\n        // Load the pushed storage vector into another instance and check that\n        // both instances are equal:\n        let stash2 =\n            <StorageStash<u8> as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n        assert_eq!(stash1, stash2);\n        Ok(())\n    })\n}\n\n#[test]\n#[should_panic(expected = \"storage entry was empty\")]\nfn spread_layout_clear_works() {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let stash1 = create_holey_stash();\n        let root_key = Key::from([0x42; 32]);\n        SpreadLayout::push_spread(&stash1, &mut KeyPtr::from(root_key));\n        // It has already been asserted that a valid instance can be pulled\n        // from contract storage after a push to the same storage region.\n        //\n        // Now clear the associated storage from `stash1` and check whether\n        // loading another instance from this storage will panic since the\n        // vector's length property cannot read a value:\n        SpreadLayout::clear_spread(&stash1, &mut KeyPtr::from(root_key));\n        let _ =\n            <StorageStash<u8> as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n        Ok(())\n    })\n    .unwrap()\n}\n\n#[test]\nfn storage_is_cleared_completely_after_pull_lazy() {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        // given\n        let root_key = Key::from([0x42; 32]);\n        let lazy_stash = Lazy::new(create_holey_stash());\n        SpreadLayout::push_spread(&lazy_stash, &mut KeyPtr::from(root_key));\n        let pulled_stash = <Lazy<StorageStash<u8>> as SpreadLayout>::pull_spread(\n            &mut KeyPtr::from(root_key),\n        );\n\n        // when\n        SpreadLayout::clear_spread(&pulled_stash, &mut KeyPtr::from(root_key));\n\n        // then\n        let contract_id = ink_env::test::get_current_contract_account_id::<\n            ink_env::DefaultEnvironment,\n        >()\n        .expect(\"Cannot get contract id\");\n        let storage_used = ink_env::test::count_used_storage_cells::<\n            ink_env::DefaultEnvironment,\n        >(&contract_id)\n        .expect(\"used cells must be returned\");\n        assert_eq!(storage_used, 0);\n\n        Ok(())\n    })\n    .unwrap()\n}\n\n#[test]\n#[should_panic(expected = \"storage entry was empty\")]\nfn drop_works() {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let root_key = Key::from([0x42; 32]);\n\n        // if the setup panics it should not cause the test to pass\n        let setup_result = std::panic::catch_unwind(|| {\n            let stash = create_holey_stash();\n            SpreadLayout::push_spread(&stash, &mut KeyPtr::from(root_key));\n            let _ = <StorageStash<u8> as SpreadLayout>::pull_spread(&mut KeyPtr::from(\n                root_key,\n            ));\n            // stash is dropped which should clear the cells\n        });\n        assert!(setup_result.is_ok(), \"setup should not panic\");\n\n        let contract_id = ink_env::test::get_current_contract_account_id::<\n            ink_env::DefaultEnvironment,\n        >()\n        .expect(\"Cannot get contract id\");\n        let used_cells = ink_env::test::count_used_storage_cells::<\n            ink_env::DefaultEnvironment,\n        >(&contract_id)\n        .expect(\"used cells must be returned\");\n        assert_eq!(used_cells, 0);\n\n        let _ =\n            <StorageStash<u8> as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n        Ok(())\n    })\n    .unwrap()\n}\n"],["968","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::{\n    Entry,\n    Stash,\n};\nuse crate::{\n    collections::extend_lifetime,\n    traits::PackedLayout,\n};\n\n/// An iterator over shared references to the elements of a storage stash.\n#[derive(Debug, Clone, Copy)]\npub struct Iter<'a, T>\nwhere\n    T: PackedLayout,\n{\n    /// The storage stash to iterate over.\n    stash: &'a Stash<T>,\n    /// The number of already yielded elements.\n    ///\n    /// # Note\n    ///\n    /// This is important to make this iterator an `ExactSizeIterator`.\n    yielded: u32,\n    /// The current begin of the iteration.\n    begin: u32,\n    /// The current end of the iteration.\n    end: u32,\n}\n\nimpl<'a, T> Iter<'a, T>\nwhere\n    T: PackedLayout,\n{\n    /// Creates a new iterator for the given storage stash.\n    pub(crate) fn new(stash: &'a Stash<T>) -> Self {\n        Self {\n            stash,\n            yielded: 0,\n            begin: 0,\n            end: stash.len_entries(),\n        }\n    }\n\n    /// Returns the amount of remaining elements to yield by the iterator.\n    fn remaining(&self) -> u32 {\n        self.stash.len() - self.yielded\n    }\n}\n\nimpl<'a, T> Iterator for Iter<'a, T>\nwhere\n    T: PackedLayout,\n{\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            debug_assert!(self.begin <= self.end);\n            if self.begin == self.end {\n                return None\n            }\n            let cur = self.begin;\n            self.begin += 1;\n            match self.stash.get(cur) {\n                Some(value) => {\n                    self.yielded += 1;\n                    return Some(value)\n                }\n                None => continue,\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let remaining = self.remaining() as usize;\n        (remaining, Some(remaining))\n    }\n\n    fn count(self) -> usize {\n        self.remaining() as usize\n    }\n}\n\nimpl<'a, T> ExactSizeIterator for Iter<'a, T> where T: PackedLayout {}\n\nimpl<'a, T> DoubleEndedIterator for Iter<'a, T>\nwhere\n    T: PackedLayout,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        loop {\n            debug_assert!(self.begin <= self.end);\n            if self.begin == self.end {\n                return None\n            }\n            debug_assert_ne!(self.end, 0);\n            self.end -= 1;\n            match self.stash.get(self.end) {\n                Some(value) => {\n                    self.yielded += 1;\n                    return Some(value)\n                }\n                None => continue,\n            }\n        }\n    }\n}\n\n/// An iterator over exclusive references to the elements of a storage stash.\n#[derive(Debug)]\npub struct IterMut<'a, T>\nwhere\n    T: PackedLayout,\n{\n    /// The storage stash to iterate over.\n    stash: &'a mut Stash<T>,\n    /// The number of already yielded elements.\n    ///\n    /// # Note\n    ///\n    /// This is important to make this iterator an `ExactSizeIterator`.\n    yielded: u32,\n    /// The current begin of the iteration.\n    begin: u32,\n    /// The current end of the iteration.\n    end: u32,\n}\n\nimpl<'a, T> IterMut<'a, T>\nwhere\n    T: PackedLayout,\n{\n    /// Creates a new iterator for the given storage stash.\n    pub(crate) fn new(stash: &'a mut Stash<T>) -> Self {\n        let len = stash.len_entries();\n        Self {\n            stash,\n            yielded: 0,\n            begin: 0,\n            end: len,\n        }\n    }\n\n    /// Returns the amount of remaining elements to yield by the iterator.\n    fn remaining(&self) -> u32 {\n        self.stash.len() - self.yielded\n    }\n}\n\nimpl<'a, T> IterMut<'a, T>\nwhere\n    T: PackedLayout,\n{\n    fn get_mut<'b>(&'b mut self, at: u32) -> Option<&'a mut T> {\n        self.stash.get_mut(at).map(|value| {\n            // SAFETY: We extend the lifetime of the reference here.\n            //\n            //         This is safe because the iterator yields an exclusive\n            //         reference to every element in the iterated vector\n            //         just once and also there can be only one such iterator\n            //         for the same vector at the same time which is\n            //         guaranteed by the constructor of the iterator.\n            unsafe { extend_lifetime::<'b, 'a, T>(value) }\n        })\n    }\n}\n\nimpl<'a, T> Iterator for IterMut<'a, T>\nwhere\n    T: PackedLayout,\n{\n    type Item = &'a mut T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            debug_assert!(self.begin <= self.end);\n            if self.begin == self.end {\n                return None\n            }\n            let cur = self.begin;\n            self.begin += 1;\n            match self.get_mut(cur) {\n                Some(value) => {\n                    self.yielded += 1;\n                    return Some(value)\n                }\n                None => continue,\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let remaining = self.remaining() as usize;\n        (remaining, Some(remaining))\n    }\n\n    fn count(self) -> usize {\n        self.remaining() as usize\n    }\n}\n\nimpl<'a, T> ExactSizeIterator for IterMut<'a, T> where T: PackedLayout {}\n\nimpl<'a, T> DoubleEndedIterator for IterMut<'a, T>\nwhere\n    T: PackedLayout,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        loop {\n            debug_assert!(self.begin <= self.end);\n            if self.begin == self.end {\n                return None\n            }\n            debug_assert_ne!(self.end, 0);\n            self.end -= 1;\n            match self.get_mut(self.end) {\n                Some(value) => {\n                    self.yielded += 1;\n                    return Some(value)\n                }\n                None => continue,\n            }\n        }\n    }\n}\n\n/// An iterator over shared references to the entries of a storage stash.\n///\n/// # Note\n///\n/// This is an internal API and mainly used for testing the storage stash.\n#[derive(Debug, Clone, Copy)]\npub struct Entries<'a, T>\nwhere\n    T: PackedLayout,\n{\n    /// The storage stash to iterate over.\n    stash: &'a Stash<T>,\n    /// The current begin of the iteration.\n    begin: u32,\n    /// The current end of the iteration.\n    end: u32,\n}\n\nimpl<'a, T> Entries<'a, T>\nwhere\n    T: PackedLayout,\n{\n    /// Creates a new iterator for the given storage stash.\n    pub(crate) fn new(stash: &'a Stash<T>) -> Self {\n        let len = stash.len_entries();\n        Self {\n            stash,\n            begin: 0,\n            end: len,\n        }\n    }\n}\n\nimpl<'a, T> Iterator for Entries<'a, T>\nwhere\n    T: PackedLayout,\n{\n    type Item = &'a Entry<T>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        debug_assert!(self.begin <= self.end);\n        if self.begin == self.end {\n            return None\n        }\n        let cur = self.begin;\n        self.begin += 1;\n        let entry = self\n            .stash\n            .entries\n            .get(cur)\n            .expect(\"iterator indices are within bounds\");\n        Some(entry)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let remaining = (self.end - self.begin) as usize;\n        (remaining, Some(remaining))\n    }\n}\n\nimpl<'a, T> ExactSizeIterator for Entries<'a, T> where T: PackedLayout {}\n\nimpl<'a, T> DoubleEndedIterator for Entries<'a, T>\nwhere\n    T: PackedLayout,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        debug_assert!(self.begin <= self.end);\n        if self.begin == self.end {\n            return None\n        }\n        debug_assert_ne!(self.end, 0);\n        self.end -= 1;\n        let entry = self\n            .stash\n            .entries\n            .get(self.end)\n            .expect(\"iterator indices are within bounds\");\n        Some(entry)\n    }\n}\n"],["969","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! A storage stash allowing to store indexed elements efficiently.\n\nmod impls;\nmod iter;\nmod storage;\n\n#[cfg(test)]\nmod tests;\n\nuse self::iter::Entries;\npub use self::iter::{\n    Iter,\n    IterMut,\n};\nuse crate::{\n    lazy::LazyIndexMap,\n    traits::PackedLayout,\n    Pack,\n};\nuse ink_primitives::Key;\n\n/// An index into the stash.\ntype Index = u32;\n\n/// A stash data structure operating on contract storage.\n///\n/// This allows to store information similar to a vector but in unordered\n/// fashion which enables constant time random deletion of elements. This allows\n/// for efficient attachment of data to some numeric indices.\n#[derive(Debug)]\npub struct Stash<T>\nwhere\n    T: PackedLayout,\n{\n    /// The combined and commonly used header data.\n    header: Pack<Header>,\n    /// The storage entries of the stash.\n    entries: LazyIndexMap<Entry<T>>,\n}\n\n/// Stores general commonly required information about the storage stash.\n#[derive(Debug, scale::Encode, scale::Decode)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\nstruct Header {\n    /// The latest vacant index.\n    ///\n    /// - If all entries are occupied:\n    ///     - Points to the entry at index `self.len`.\n    /// - If some entries are vacant:\n    ///     - Points to the entry that has been vacated most recently.\n    last_vacant: Index,\n    /// The number of items stored in the stash.\n    ///\n    /// # Note\n    ///\n    /// We cannot simply use the underlying length of the vector\n    /// since it would include vacant slots as well.\n    len: u32,\n    /// The number of entries currently managed by the stash.\n    len_entries: u32,\n}\n\n/// A vacant entry with previous and next vacant indices.\n#[derive(Debug, Copy, Clone, scale::Encode, scale::Decode)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\npub struct VacantEntry {\n    /// The next vacant index.\n    next: Index,\n    /// The previous vacant index.\n    prev: Index,\n}\n\n/// An entry within the stash.\n///\n/// The vacant entries within a storage stash form a doubly linked list of\n/// vacant entries that is used to quickly re-use their vacant storage.\n#[derive(Debug, scale::Encode, scale::Decode)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\npub enum Entry<T> {\n    /// A vacant entry that holds the index to the next and previous vacant entry.\n    Vacant(VacantEntry),\n    /// An occupied entry that hold the value.\n    Occupied(T),\n}\n\nimpl<T> Entry<T> {\n    /// Returns `true` if the entry is occupied.\n    pub fn is_occupied(&self) -> bool {\n        if let Entry::Occupied(_) = self {\n            return true\n        }\n        false\n    }\n\n    /// Returns `true` if the entry is vacant.\n    pub fn is_vacant(&self) -> bool {\n        !self.is_occupied()\n    }\n\n    /// Returns the vacant entry if the entry is vacant, otherwise returns `None`.\n    fn try_to_vacant(&self) -> Option<VacantEntry> {\n        match self {\n            Entry::Occupied(_) => None,\n            Entry::Vacant(vacant_entry) => Some(*vacant_entry),\n        }\n    }\n\n    /// Returns the vacant entry if the entry is vacant, otherwise returns `None`.\n    fn try_to_vacant_mut(&mut self) -> Option<&mut VacantEntry> {\n        match self {\n            Entry::Occupied(_) => None,\n            Entry::Vacant(vacant_entry) => Some(vacant_entry),\n        }\n    }\n}\n\nimpl<T> Stash<T>\nwhere\n    T: PackedLayout,\n{\n    /// Creates a new empty stash.\n    pub fn new() -> Self {\n        Self {\n            header: Pack::new(Header {\n                last_vacant: 0,\n                len: 0,\n                len_entries: 0,\n            }),\n            entries: LazyIndexMap::new(),\n        }\n    }\n\n    /// Returns the number of elements stored in the stash.\n    pub fn len(&self) -> u32 {\n        self.header.len\n    }\n\n    /// Returns `true` if the stash contains no elements.\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Returns the number of entries the stash can hold without\n    /// allocating another storage cell.\n    ///\n    /// # Note\n    ///\n    /// This is the total number of occupied and vacant entries of the stash.\n    pub fn capacity(&self) -> u32 {\n        self.len_entries()\n    }\n\n    /// Returns the number of entries currently managed by the storage stash.\n    fn len_entries(&self) -> u32 {\n        self.header.len_entries\n    }\n\n    /// Returns the underlying key to the cells.\n    ///\n    /// # Note\n    ///\n    /// This is a low-level utility getter and should\n    /// normally not be required by users.\n    pub fn entries_key(&self) -> Option<&Key> {\n        self.entries.key()\n    }\n\n    /// Returns an iterator yielding shared references to all elements of the stash.\n    ///\n    /// # Note\n    ///\n    /// Avoid unbounded iteration over big storage stashes.\n    /// Prefer using methods like `Iterator::take` in order to limit the number\n    /// of yielded elements.\n    pub fn iter(&self) -> Iter<T> {\n        Iter::new(self)\n    }\n\n    /// Returns an iterator yielding exclusive references to all elements of the stash.\n    ///\n    /// # Note\n    ///\n    /// Avoid unbounded iteration over big storage stashes.\n    /// Prefer using methods like `Iterator::take` in order to limit the number\n    /// of yielded elements.\n    pub fn iter_mut(&mut self) -> IterMut<T> {\n        IterMut::new(self)\n    }\n\n    /// Returns an iterator yielding shared references to all entries of the stash.\n    pub fn entries(&self) -> Entries<T> {\n        Entries::new(self)\n    }\n\n    /// Returns `true` if the storage stash has vacant entries.\n    fn has_vacant_entries(&self) -> bool {\n        self.header.len != self.header.len_entries\n    }\n\n    /// Returns the index of the last vacant entry if any.\n    fn last_vacant_index(&self) -> Option<Index> {\n        if self.has_vacant_entries() {\n            Some(self.header.last_vacant)\n        } else {\n            None\n        }\n    }\n}\n\nimpl<T> Stash<T>\nwhere\n    T: PackedLayout,\n{\n    /// Returns a shared reference to the element at the given index.\n    pub fn get(&self, at: Index) -> Option<&T> {\n        if at >= self.len_entries() {\n            // Bail out early if the index is out of bounds.\n            return None\n        }\n        self.entries.get(at).and_then(|entry| {\n            match entry {\n                Entry::Occupied(val) => Some(val),\n                Entry::Vacant { .. } => None,\n            }\n        })\n    }\n\n    /// Returns an exclusive reference to the element at the given index.\n    pub fn get_mut(&mut self, at: Index) -> Option<&mut T> {\n        if at >= self.len_entries() {\n            // Bail out early if the index is out of bounds.\n            return None\n        }\n        self.entries.get_mut(at).and_then(|entry| {\n            match entry {\n                Entry::Occupied(val) => Some(val),\n                Entry::Vacant { .. } => None,\n            }\n        })\n    }\n}\n\nimpl<T> Stash<T>\nwhere\n    T: PackedLayout,\n{\n    /// Clears the underlying storage cells of the storage vector.\n    ///\n    /// # Note\n    ///\n    /// This completely invalidates the storage vector's invariants about\n    /// the contents of its associated storage region.\n    ///\n    /// This API is used for the `Drop` implementation of [`Vec`] as well as\n    /// for the [`SpreadLayout::clear_spread`][`crate::traits::SpreadLayout::clear_spread`]\n    /// trait implementation.\n    fn clear_cells(&self) {\n        if self.entries.key().is_none() {\n            // We won't clear any storage if we are in lazy state since there\n            // probably has not been any state written to storage, yet.\n            return\n        }\n        for index in 0..self.len_entries() {\n            // It might seem wasteful to clear all entries instead of just\n            // the occupied ones. However this spares us from having one extra\n            // read for every element in the storage stash to filter out vacant\n            // entries. So this is actually a trade-off and at the time of this\n            // implementation it is unclear which path is more efficient.\n            //\n            // The bet is that clearing a storage cell is cheaper than reading one.\n            self.entries.clear_packed_at(index);\n        }\n    }\n}\n\nimpl<T> Stash<T>\nwhere\n    T: PackedLayout,\n{\n    /// Rebinds the `prev` and `next` bindings of the neighbours of the vacant entry.\n    ///\n    /// # Note\n    ///\n    /// The `removed_index` points to the index of the removed vacant entry.\n    fn remove_vacant_entry(&mut self, removed_index: Index, vacant_entry: VacantEntry) {\n        let prev_vacant = vacant_entry.prev;\n        let next_vacant = vacant_entry.next;\n        if prev_vacant == removed_index && next_vacant == removed_index {\n            // There is no other vacant entry left in the storage stash so\n            // there is nothing to update. Bail out early.\n            self.header.last_vacant = self.header.len;\n            return\n        }\n        if prev_vacant == next_vacant {\n            // There is only one other vacant entry left.\n            // We can update the single vacant entry in a single look-up.\n            let entry = self\n                .entries\n                .get_mut(prev_vacant)\n                .map(Entry::try_to_vacant_mut)\n                .flatten()\n                .expect(\"`prev` must point to an existing entry at this point\");\n            debug_assert_eq!(entry.prev, removed_index);\n            debug_assert_eq!(entry.next, removed_index);\n            entry.prev = prev_vacant;\n            entry.next = prev_vacant;\n        } else {\n            // There are multiple other vacant entries left.\n            let prev = self\n                .entries\n                .get_mut(prev_vacant)\n                .map(Entry::try_to_vacant_mut)\n                .flatten()\n                .expect(\"`prev` must point to an existing entry at this point\");\n            debug_assert_eq!(prev.next, removed_index);\n            prev.next = next_vacant;\n            let next = self\n                .entries\n                .get_mut(next_vacant)\n                .map(Entry::try_to_vacant_mut)\n                .flatten()\n                .expect(\"`next` must point to an existing entry at this point\");\n            debug_assert_eq!(next.prev, removed_index);\n            next.prev = prev_vacant;\n        }\n        // Bind the last vacant pointer to the vacant position with the lower index.\n        // This has the effect that lower indices are refilled more quickly.\n        use core::cmp::min;\n        if removed_index == self.header.last_vacant {\n            self.header.last_vacant = min(prev_vacant, next_vacant);\n        }\n    }\n\n    /// Returns the previous and next vacant entry for the entry at index `at`.\n    ///\n    /// If there exists a last vacant entry, the return value is a tuple\n    /// `(index_of_previous_vacant, index_of_next_vacant)`.\n    /// The two `index_` values hereby are selected in a way that makes it\n    /// more likely that the stash is refilled from low indices.\n    ///\n    /// If no vacant entry exists a self-referential tuple of `(at, at)`\n    /// is returned.\n    fn fetch_prev_and_next_vacant_entry(&self, at: Index) -> (Index, Index) {\n        if let Some(index) = self.last_vacant_index() {\n            let root_vacant = self\n                .entries\n                .get(index)\n                .map(|entry| entry.try_to_vacant())\n                .flatten()\n                .expect(\"last_vacant must point to an existing vacant entry\");\n            // Form the linked vacant entries in a way that makes it more likely\n            // for them to refill the stash from low indices.\n            if at < index {\n                // Insert before root if new vacant index is smaller than root.\n                (root_vacant.prev, index)\n            } else if at < root_vacant.next {\n                // Insert between root and its next vacant entry if smaller than\n                // current root's next index.\n                (index, root_vacant.next)\n            } else {\n                // Insert before root entry if index is greater. But we won't\n                // update the new element to be the new root index in this case.\n                (root_vacant.prev, index)\n            }\n        } else {\n            // Default prev and next to the given at index.\n            // So the resulting vacant index is pointing to itself.\n            (at, at)\n        }\n    }\n\n    /// Updates links from and to neighbouring vacant entries.\n    fn update_neighboring_vacant_entry_links(\n        &mut self,\n        prev: Index,\n        next: Index,\n        at: Index,\n    ) {\n        if prev == next {\n            // Previous and next are the same so we can update the vacant\n            // neighbour with a single look-up.\n            let entry = self\n                .entries\n                .get_mut(next)\n                .map(Entry::try_to_vacant_mut)\n                .flatten()\n                .expect(\"`next` must point to an existing vacant entry at this point\");\n            entry.prev = at;\n            entry.next = at;\n        } else {\n            // Previous and next vacant entries are different and thus need\n            // different look-ups to update them.\n            self.entries\n                .get_mut(prev)\n                .map(Entry::try_to_vacant_mut)\n                .flatten()\n                .expect(\"`prev` must point to an existing vacant entry at this point\")\n                .next = at;\n            self.entries\n                .get_mut(next)\n                .map(Entry::try_to_vacant_mut)\n                .flatten()\n                .expect(\"`next` must point to an existing vacant entry at this point\")\n                .prev = at;\n        }\n    }\n\n    /// Put the element into the stash at the next vacant position.\n    ///\n    /// Returns the stash index that the element was put into.\n    pub fn put(&mut self, new_value: T) -> Index {\n        let new_entry = Some(Entry::Occupied(new_value));\n        let new_index = if let Some(index) = self.last_vacant_index() {\n            // Put the new element to the most recent vacant index if not all entries are occupied.\n            let old_entry = self\n                .entries\n                .put_get(index, new_entry)\n                .expect(\"a `last_vacant_index()` must point to an occupied cell\");\n            let vacant_entry = match old_entry {\n                Entry::Vacant(vacant_entry) => vacant_entry,\n                Entry::Occupied(_) => {\n                    unreachable!(\"`last_vacant_index()` must point to a vacant entry\")\n                }\n            };\n            self.remove_vacant_entry(index, vacant_entry);\n            index\n        } else {\n            // Push the new element to the end if all entries are occupied.\n            let new_index = self.header.len_entries;\n            self.entries.put(new_index, new_entry);\n            self.header.last_vacant += 1;\n            self.header.len_entries += 1;\n            new_index\n        };\n        self.header.len += 1;\n        new_index\n    }\n\n    /// Takes the element stored at the given index if any.\n    pub fn take(&mut self, at: Index) -> Option<T> {\n        // Cases:\n        // - There are vacant entries already.\n        // - There are no vacant entries before.\n        if at >= self.len_entries() {\n            // Early return since `at` index is out of bounds.\n            return None\n        }\n        // Precompute prev and next vacant entries as we might need them later.\n        // Due to borrow checker constraints we cannot have this at a later stage.\n        let (prev, next) = self.fetch_prev_and_next_vacant_entry(at);\n        let entry_mut = self.entries.get_mut(at).expect(\"index is out of bounds\");\n        if entry_mut.is_vacant() {\n            // Early return if the taken entry is already vacant.\n            return None\n        }\n        // At this point we know that the entry is occupied with a value.\n        let new_vacant_entry = Entry::Vacant(VacantEntry { next, prev });\n        let taken_entry = core::mem::replace(entry_mut, new_vacant_entry);\n        self.update_neighboring_vacant_entry_links(prev, next, at);\n        // Take the value out of the taken occupied entry and return it.\n        match taken_entry {\n            Entry::Occupied(value) => {\n                use core::cmp::min;\n                self.header.last_vacant =\n                    min(self.header.last_vacant, min(at, min(prev, next)));\n                self.header.len -= 1;\n                Some(value)\n            }\n            Entry::Vacant { .. } => {\n                unreachable!(\"the taken entry is known to be occupied\")\n            }\n        }\n    }\n\n    /// Removes the element stored at the given index if any.\n    ///\n    /// This method acts similar to the take API and even still returns an Option.\n    /// However, it guarantees to make no contract storage reads to the indexed\n    /// element and will only write to its internal low-level lazy cache that the\n    /// element at the given index is going to be removed at the end of the contract\n    /// execution.\n    ///\n    /// Calling this method with an index out of bounds for the returns `None` and\n    /// does not `remove` the element, otherwise it returns `Some(())`.\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure that `at` refers to an occupied index. Behavior is\n    /// unspecified if `at` refers to a vacant index and could seriously damage the\n    /// contract storage integrity.\n    pub unsafe fn remove_occupied(&mut self, at: Index) -> Option<()> {\n        // This function is written similar to [`Stash::take`], with the exception\n        // that the caller has to ensure that `at` refers to an occupied entry whereby\n        // the procedure can avoid loading the occupied entry which might be handy if\n        // the stored `T` is especially costly to load from contract storage.\n        if at >= self.len_entries() {\n            // Early return since `at` index is out of bounds.\n            return None\n        }\n        // Precompute prev and next vacant entries as we might need them later.\n        // Due to borrow checker constraints we cannot have this at a later stage.\n        let (prev, next) = self.fetch_prev_and_next_vacant_entry(at);\n        let new_vacant_entry = Entry::Vacant(VacantEntry { next, prev });\n        self.entries.put(at, Some(new_vacant_entry));\n        self.update_neighboring_vacant_entry_links(prev, next, at);\n        use core::cmp::min;\n        self.header.last_vacant = min(self.header.last_vacant, min(at, min(prev, next)));\n        self.header.len -= 1;\n        Some(())\n    }\n\n    /// Defragments the underlying storage to minimize footprint.\n    ///\n    /// Returns the number of storage cells freed this way.\n    ///\n    /// This might invalidate indices stored outside of the stash.\n    ///\n    /// # Callback\n    ///\n    /// In order to keep those indices up-to-date the caller can provide\n    /// a callback function that is called for every moved entry\n    /// with a shared reference to the entries value and the old as well\n    /// as the new index.\n    ///\n    /// # Note\n    ///\n    /// - If `max_iterations` is `Some` concrete value it is used in order to\n    ///   bound the number of iterations and won't try to defrag until the stash\n    ///   is optimally compacted.\n    /// - Users are advised to call this method using `Some` concrete\n    ///   value to keep gas costs within certain bounds.\n    /// - The call to the given callback takes place before the reinsertion\n    ///   of the shifted occupied entry.\n    pub fn defrag<C>(&mut self, max_iterations: Option<u32>, mut callback: C) -> u32\n    where\n        C: FnMut(Index, Index, &T),\n    {\n        let len_entries = self.len_entries();\n        let mut freed_cells = 0;\n        for index in (0..len_entries)\n            .rev()\n            .take(max_iterations.unwrap_or(len_entries) as usize)\n        {\n            if !self.has_vacant_entries() {\n                // Bail out as soon as there are no more vacant entries left.\n                return freed_cells\n            }\n            // In any case we are going to free yet another storage cell.\n            freed_cells += 1;\n            match self\n                .entries\n                .put_get(index, None)\n                .expect(\"index is out of bounds\")\n            {\n                Entry::Vacant(vacant_entry) => {\n                    // Remove the vacant entry and rebind its neighbours.\n                    self.remove_vacant_entry(index, vacant_entry);\n                }\n                Entry::Occupied(value) => {\n                    // Move the occupied entry into one of the remaining vacant\n                    // entries. We do not re-use the `put` method to not update\n                    // the length and other header information.\n                    let vacant_index = self\n                        .last_vacant_index()\n                        .expect(\"it has been asserted that there are vacant entries\");\n                    callback(index, vacant_index, &value);\n                    let new_entry = Some(Entry::Occupied(value));\n                    let old_entry = self.entries.put_get(vacant_index, new_entry).expect(\n                        \"`last_vacant_index` index must point to an occupied cell\",\n                    );\n                    let vacant_entry = match old_entry {\n                        Entry::Vacant(vacant_entry) => vacant_entry,\n                        Entry::Occupied(_) => {\n                            unreachable!(\n                                \"`last_vacant_index` must point to a vacant entry\"\n                            )\n                        }\n                    };\n                    self.remove_vacant_entry(vacant_index, vacant_entry);\n                }\n            }\n            self.header.len_entries -= 1;\n        }\n        freed_cells\n    }\n}\n"],["970","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Implementation of ink! storage traits.\n\nuse super::{\n    Entry,\n    Header,\n    Stash as StorageStash,\n};\nuse crate::{\n    lazy::LazyIndexMap,\n    traits::{\n        forward_clear_packed,\n        forward_pull_packed,\n        forward_push_packed,\n        KeyPtr,\n        PackedLayout,\n        SpreadLayout,\n    },\n};\nuse ink_primitives::Key;\n\n#[cfg(feature = \"std\")]\nconst _: () = {\n    use crate::{\n        collections::Vec as StorageVec,\n        traits::StorageLayout,\n    };\n    use ink_metadata::layout::{\n        CellLayout,\n        FieldLayout,\n        Layout,\n        LayoutKey,\n        StructLayout,\n    };\n    use scale_info::TypeInfo;\n\n    impl StorageLayout for Header {\n        fn layout(key_ptr: &mut KeyPtr) -> Layout {\n            Layout::Cell(CellLayout::new::<Header>(LayoutKey::from(\n                key_ptr.advance_by(1),\n            )))\n        }\n    }\n\n    impl<T> StorageLayout for StorageStash<T>\n    where\n        T: PackedLayout + TypeInfo + 'static,\n    {\n        fn layout(key_ptr: &mut KeyPtr) -> Layout {\n            Layout::Struct(StructLayout::new(vec![\n                FieldLayout::new(\"header\", <Header as StorageLayout>::layout(key_ptr)),\n                FieldLayout::new(\n                    \"entries\",\n                    <StorageVec<Entry<T>> as StorageLayout>::layout(key_ptr),\n                ),\n            ]))\n        }\n    }\n};\n\nimpl SpreadLayout for Header {\n    const FOOTPRINT: u64 = 1;\n    const REQUIRES_DEEP_CLEAN_UP: bool = false;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        forward_pull_packed::<Self>(ptr)\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        forward_push_packed::<Self>(self, ptr)\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        forward_clear_packed::<Self>(self, ptr)\n    }\n}\n\nimpl PackedLayout for Header {\n    fn pull_packed(&mut self, _at: &Key) {}\n    fn push_packed(&self, _at: &Key) {}\n    fn clear_packed(&self, _at: &Key) {}\n}\n\nimpl<T> SpreadLayout for Entry<T>\nwhere\n    T: PackedLayout,\n{\n    const FOOTPRINT: u64 = 1;\n    const REQUIRES_DEEP_CLEAN_UP: bool = <T as SpreadLayout>::REQUIRES_DEEP_CLEAN_UP;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        forward_pull_packed::<Self>(ptr)\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        forward_push_packed::<Self>(self, ptr)\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        forward_clear_packed::<Self>(self, ptr)\n    }\n}\n\nimpl<T> PackedLayout for Entry<T>\nwhere\n    T: PackedLayout,\n{\n    fn pull_packed(&mut self, at: &Key) {\n        if let Entry::Occupied(value) = self {\n            <T as PackedLayout>::pull_packed(value, at)\n        }\n    }\n\n    fn push_packed(&self, at: &Key) {\n        if let Entry::Occupied(value) = self {\n            <T as PackedLayout>::push_packed(value, at)\n        }\n    }\n\n    fn clear_packed(&self, at: &Key) {\n        if let Entry::Occupied(value) = self {\n            <T as PackedLayout>::clear_packed(value, at)\n        }\n    }\n}\n\nimpl<T> SpreadLayout for StorageStash<T>\nwhere\n    T: PackedLayout,\n{\n    const FOOTPRINT: u64 = 1 + <LazyIndexMap<T> as SpreadLayout>::FOOTPRINT;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        Self {\n            header: SpreadLayout::pull_spread(ptr),\n            entries: SpreadLayout::pull_spread(ptr),\n        }\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        SpreadLayout::push_spread(&self.header, ptr);\n        SpreadLayout::push_spread(&self.entries, ptr);\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        self.clear_cells();\n        SpreadLayout::clear_spread(&self.header, ptr);\n        SpreadLayout::clear_spread(&self.entries, ptr);\n    }\n}\n"],["971","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::{\n    BinaryHeap,\n    PeekMut,\n    Reverse,\n};\nuse crate::traits::{\n    KeyPtr,\n    PackedLayout,\n    SpreadLayout,\n};\nuse ink_primitives::Key;\n\nfn heap_from_slice<T>(slice: &[T]) -> BinaryHeap<T>\nwhere\n    T: Clone + PackedLayout + Ord,\n{\n    slice.iter().cloned().collect()\n}\n\n/// Creates a heap populated with `n` consecutive values.\nfn heap_of_size(n: u32) -> BinaryHeap<u32> {\n    std::iter::repeat(0u32)\n        .take(n as usize)\n        .enumerate()\n        .map(|(i, _)| i as u32 + 1)\n        .collect()\n}\n\n/// Returns the number of cells a binary tree of `heap_size` occupies\n/// in the storage.\n///\n/// *Note*: `heap_size` must be even, if it is odd we cannot calculate\n/// the number of cells with certainty, since for e.g. `heap_size = 5`\n/// there might be two leaf cells with one element each or alternatively\n/// one leaf with two elements.\nfn get_count_cells(heap_size: u32) -> u32 {\n    fn division_round_up(dividend: u32, divisor: u32) -> u32 {\n        (dividend + divisor - 1) / divisor\n    }\n    assert!(heap_size % 2 == 0, \"heap_size must be even\");\n    let rest = match heap_size {\n        0 => 0,\n        1 => 0,\n        _ => division_round_up(heap_size, super::children::CHILDREN_PER_NODE),\n    };\n    rest + 1\n}\n\n#[test]\nfn new_binary_heap_works() {\n    // `BinaryHeap::new`\n    let heap = <BinaryHeap<i32>>::new();\n    assert!(heap.is_empty());\n    assert_eq!(heap.len(), 0);\n    // `BinaryHeap::default`\n    let default = <BinaryHeap<i32> as Default>::default();\n    assert!(default.is_empty());\n    assert_eq!(default.len(), 0);\n    // `BinaryHeap::new` and `BinaryHeap::default` should be equal.\n    assert_eq!(heap, default);\n}\n\n#[test]\nfn empty_pop_works() {\n    let mut heap = BinaryHeap::<i32>::new();\n    assert!(heap.pop().is_none());\n}\n\n#[test]\nfn empty_peek_works() {\n    let empty = BinaryHeap::<i32>::new();\n    assert!(empty.peek().is_none());\n}\n\n#[test]\nfn empty_peek_mut_works() {\n    let mut empty = BinaryHeap::<i32>::new();\n    assert!(empty.peek_mut().is_none());\n}\n\n#[test]\nfn empty_iter_works() {\n    let empty = BinaryHeap::<i32>::new();\n    assert!(empty.iter().next().is_none());\n}\n\n#[test]\nfn from_iterator_works() {\n    let some_primes = [1, 2, 3, 5, 7, 11, 13];\n    assert_eq!(some_primes.iter().copied().collect::<BinaryHeap<_>>(), {\n        let mut vec = BinaryHeap::new();\n        for prime in &some_primes {\n            vec.push(*prime)\n        }\n        vec\n    });\n}\n\n#[test]\nfn from_empty_iterator_works() {\n    assert_eq!(\n        [].iter().copied().collect::<BinaryHeap<i32>>(),\n        BinaryHeap::new(),\n    );\n}\n\n#[test]\nfn push_works() {\n    let mut heap = heap_from_slice(&[2, 4, 9]);\n    assert_eq!(heap.len(), 3);\n    assert_eq!(*heap.peek().unwrap(), 9);\n    heap.push(11);\n    assert_eq!(heap.len(), 4);\n    assert_eq!(*heap.peek().unwrap(), 11);\n    heap.push(5);\n    assert_eq!(heap.len(), 5);\n    assert_eq!(*heap.peek().unwrap(), 11);\n    heap.push(27);\n    assert_eq!(heap.len(), 6);\n    assert_eq!(*heap.peek().unwrap(), 27);\n    heap.push(3);\n    assert_eq!(heap.len(), 7);\n    assert_eq!(*heap.peek().unwrap(), 27);\n    heap.push(103);\n    assert_eq!(heap.len(), 8);\n    assert_eq!(*heap.peek().unwrap(), 103);\n}\n\n#[test]\nfn peek_works() {\n    let mut heap = <BinaryHeap<i32>>::new();\n    heap.push(33);\n\n    assert_eq!(heap.peek(), Some(&33));\n}\n\n#[test]\nfn peek_and_pop_works() {\n    let data = vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];\n    let mut sorted = data.clone();\n    sorted.sort();\n    let mut heap = heap_from_slice(&data);\n    while !heap.is_empty() {\n        assert_eq!(heap.peek().unwrap(), sorted.last().unwrap());\n        assert_eq!(heap.pop().unwrap(), sorted.pop().unwrap());\n    }\n}\n\n#[test]\nfn peek_mut_works() {\n    let data = vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];\n    let mut heap = heap_from_slice(&data);\n    assert_eq!(heap.peek(), Some(&10));\n    {\n        let mut top = heap.peek_mut().unwrap();\n        *top -= 2;\n    }\n    assert_eq!(heap.peek(), Some(&9));\n}\n\n#[test]\nfn peek_mut_pop_works() {\n    let data = vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];\n    let mut heap = heap_from_slice(&data);\n    assert_eq!(heap.peek(), Some(&10));\n    {\n        let mut top = heap.peek_mut().unwrap();\n        *top -= 2;\n        assert_eq!(PeekMut::pop(top), 8);\n    }\n    assert_eq!(heap.peek(), Some(&9));\n}\n\n#[test]\nfn min_heap_works() {\n    let data = vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1]\n        .iter()\n        .map(|x| Reverse::new(*x))\n        .collect::<Vec<_>>();\n    let mut sorted = data.clone();\n    sorted.sort();\n    let mut heap = heap_from_slice(&data);\n    while !heap.is_empty() {\n        assert_eq!(heap.peek().unwrap(), sorted.last().unwrap());\n        assert_eq!(heap.pop().unwrap(), sorted.pop().unwrap());\n    }\n}\n\n#[test]\nfn spread_layout_push_pull_works() -> ink_env::Result<()> {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let heap1 = heap_from_slice(&[b'a', b'b', b'c', b'd']);\n        let root_key = Key::from([0x42; 32]);\n        SpreadLayout::push_spread(&heap1, &mut KeyPtr::from(root_key));\n        // Load the pushed binary heap into another instance and check that\n        // both instances are equal:\n        let heap2 =\n            <BinaryHeap<u8> as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n        assert_eq!(heap1, heap2);\n        Ok(())\n    })\n}\n\n#[test]\n#[should_panic(expected = \"encountered empty storage cell\")]\nfn spread_layout_clear_works() {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let heap1 = heap_from_slice(&[b'a', b'b', b'c', b'd']);\n        let root_key = Key::from([0x42; 32]);\n        SpreadLayout::push_spread(&heap1, &mut KeyPtr::from(root_key));\n        // It has already been asserted that a valid instance can be pulled\n        // from contract storage after a push to the same storage region.\n        //\n        // Now clear the associated storage from `heap1` and check whether\n        // loading another instance from this storage will panic since the\n        // heap's length property cannot read a value:\n        SpreadLayout::clear_spread(&heap1, &mut KeyPtr::from(root_key));\n        let _ =\n            <BinaryHeap<u8> as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n        Ok(())\n    })\n    .unwrap()\n}\n\n#[test]\n#[should_panic(expected = \"encountered empty storage cell\")]\nfn drop_works() {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let root_key = Key::from([0x42; 32]);\n\n        // if the setup panics it should not cause the test to pass\n        let setup_result = std::panic::catch_unwind(|| {\n            let heap = heap_from_slice(&[23, 25, 65]);\n            SpreadLayout::push_spread(&heap, &mut KeyPtr::from(root_key));\n\n            let _ = <BinaryHeap<u8> as SpreadLayout>::pull_spread(&mut KeyPtr::from(\n                root_key,\n            ));\n            // heap is dropped which should clear the cells\n        });\n\n        assert!(setup_result.is_ok(), \"setup should not panic\");\n\n        let contract_id = ink_env::test::get_current_contract_account_id::<\n            ink_env::DefaultEnvironment,\n        >()\n        .expect(\"Cannot get contract id\");\n        let used_cells = ink_env::test::count_used_storage_cells::<\n            ink_env::DefaultEnvironment,\n        >(&contract_id)\n        .expect(\"Used cells must be returned\");\n        assert_eq!(used_cells, 0);\n\n        let _ =\n            <BinaryHeap<u8> as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n        Ok(())\n    })\n    .unwrap()\n}\n\n#[test]\nfn clear_works_on_filled_heap() {\n    let mut heap = heap_from_slice(&[b'a', b'b', b'c', b'd']);\n    heap.clear();\n    assert!(heap.is_empty());\n}\n\n#[test]\nfn clear_works_on_empty_heap() {\n    let mut heap = BinaryHeap::<u8>::default();\n    heap.clear();\n    assert!(heap.is_empty());\n}\n\nfn check_complexity_read_writes<F>(\n    heap_size: u32,\n    heap_op: F,\n    expected_net_reads: usize,\n    expected_net_writes: usize,\n) -> ink_env::Result<()>\nwhere\n    F: FnOnce(&mut BinaryHeap<u32>),\n{\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let heap1 = heap_of_size(heap_size);\n        let root_key = Key::from([0x42; 32]);\n        SpreadLayout::push_spread(&heap1, &mut KeyPtr::from(root_key));\n        let contract_account = ink_env::test::get_current_contract_account_id::<\n            ink_env::DefaultEnvironment,\n        >()?;\n\n        let mut lazy_heap =\n            <BinaryHeap<u32> as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n\n        let (base_reads, base_writes) = ink_env::test::get_contract_storage_rw::<\n            ink_env::DefaultEnvironment,\n        >(&contract_account)?;\n\n        // elements.len + vec.len\n        const CONST_WRITES: u32 = 2;\n        assert_eq!(\n            (base_reads as u32, base_writes as u32),\n            (0, CONST_WRITES + get_count_cells(heap_size))\n        );\n\n        heap_op(&mut lazy_heap);\n\n        // write back to storage so we can see how many writes required\n        SpreadLayout::push_spread(&lazy_heap, &mut KeyPtr::from(root_key));\n\n        let (reads, writes) = ink_env::test::get_contract_storage_rw::<\n            ink_env::DefaultEnvironment,\n        >(&contract_account)?;\n        let net_reads = reads - base_reads;\n        let net_writes = writes - base_writes;\n\n        assert_eq!(\n            net_reads, expected_net_reads,\n            \"size {}: storage reads\",\n            heap_size\n        );\n        assert_eq!(\n            net_writes, expected_net_writes,\n            \"size {}: storage writes\",\n            heap_size\n        );\n\n        Ok(())\n    })\n}\n\n#[test]\nfn push_largest_value_complexity_big_o_log_n() -> ink_env::Result<()> {\n    // 1 elements overhead (#508) + 1 elements.len + 1 heap overhead (#508) + 1 heap.len + 1 cell\n    const CONST_READS: usize = 5;\n\n    // 1 elements.len + 1 cell which was pushed to\n    // vec.len doesn't get larger because no cell is added\n    const CONST_WRITES: usize = 2;\n\n    for (n, log_n) in &[(2, 1), (4, 2), (8, 3), (16, 4), (32, 5), (64, 6)] {\n        let largest_value = n + 1;\n        let expected_reads = log_n + CONST_READS;\n        let expected_writes = log_n + CONST_WRITES;\n        check_complexity_read_writes(\n            *n,\n            |heap| heap.push(largest_value),\n            expected_reads,\n            expected_writes,\n        )?;\n    }\n    Ok(())\n}\n\n#[test]\nfn push_smallest_value_complexity_big_o_1() -> ink_env::Result<()> {\n    const SMALLEST_VALUE: u32 = 0;\n\n    // 1 elements overhead (#508) + 1 elements.len + 1 vec overhead (#508) +\n    // 1 vec.len + 1 vec.cell in which to insert + 1 parent cell during `sift_up`\n    const EXPECTED_READS: usize = 6;\n\n    // binary heap len + one cell\n    // vec.len doesn't get larger because no cell is added\n    const EXPECTED_WRITES: usize = 2;\n\n    for n in &[2, 4, 8, 16, 32, 64] {\n        check_complexity_read_writes(\n            *n,\n            |heap| {\n                heap.push(SMALLEST_VALUE);\n            },\n            EXPECTED_READS,\n            EXPECTED_WRITES,\n        )?;\n    }\n    Ok(())\n}\n\n#[test]\nfn pop_complexity_big_o_log_n() -> ink_env::Result<()> {\n    // 1 elements overhead (#508) + elements.len + 1 vec overhead (#508) +\n    // 1 vec.len + 1 vec.cell from which to pop\n    const CONST_READS: usize = 5;\n\n    // 1 elements.len + 1 vec.len + cell which was modified\n    const CONST_WRITES: usize = 3;\n\n    for (n, log_n) in &[(2, 1), (4, 2), (8, 3), (16, 4), (32, 5), (64, 6)] {\n        let expected_reads = log_n + CONST_READS;\n        let expected_writes = log_n + CONST_WRITES;\n\n        check_complexity_read_writes(\n            *n,\n            |heap| {\n                heap.pop();\n            },\n            expected_reads,\n            expected_writes,\n        )?;\n    }\n    Ok(())\n}\n\n#[cfg(feature = \"ink-fuzz-tests\")]\n#[quickcheck]\nfn fuzz_pop_always_returns_largest_element(xs: Vec<i32>) {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let mut sorted = xs.clone();\n        sorted.sort();\n        let mut heap = heap_from_slice(&xs);\n\n        for x in sorted.iter().rev() {\n            assert_eq!(Some(*x), heap.pop())\n        }\n\n        assert_eq!(heap.len(), 0);\n\n        // all elements must have been removed as well\n        assert_eq!(heap.elements.children_count(), 0);\n\n        Ok(())\n    })\n    .unwrap()\n}\n"],["972","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! [`BinaryHeap`](`super::BinaryHeap`) is a max-heap by default, where the *largest* element will\n//! be returned by `heap.pop()`. To use a [`BinaryHeap`](`super::BinaryHeap`) as a min-heap, where\n//! the *smallest* element returned by `heap.pop()`, the type `T` of the binary heap can be wrapped\n//! in a `Reverse<T>`.\n//!\n//! [`Reverse`] simply wraps [`core::cmp::Reverse`] and implements all the required traits for use\n//! as a storage struct.\n\nuse crate::traits::{\n    KeyPtr,\n    PackedLayout,\n    SpreadLayout,\n};\nuse ink_prelude::vec::Vec;\nuse ink_primitives::Key;\n\n/// Wrapper for [`core::cmp::Reverse`] for using a [`BinaryHeap`](`super::BinaryHeap`) as a\n/// min-heap.\n#[derive(PartialEq, Eq, Ord, PartialOrd, Debug, Copy, Clone, Default)]\npub struct Reverse<T>(core::cmp::Reverse<T>);\n\nimpl<T> Reverse<T>\nwhere\n    T: PackedLayout + Ord,\n{\n    /// Construct a new [`Reverse`] from the given value.\n    pub fn new(value: T) -> Self {\n        Self(core::cmp::Reverse(value))\n    }\n\n    /// Return a shared reference to the inner value.\n    pub fn value(&self) -> &T {\n        &(self.0).0\n    }\n}\n\nimpl<T> SpreadLayout for Reverse<T>\nwhere\n    T: PackedLayout + Ord,\n{\n    const FOOTPRINT: u64 = <T as SpreadLayout>::FOOTPRINT;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        Self::new(SpreadLayout::pull_spread(ptr))\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        SpreadLayout::push_spread(self.value(), ptr);\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        SpreadLayout::clear_spread(self.value(), ptr);\n    }\n}\n\nimpl<T> PackedLayout for Reverse<T>\nwhere\n    T: PackedLayout + Ord,\n{\n    fn pull_packed(&mut self, at: &Key) {\n        <T as PackedLayout>::pull_packed(&mut (self.0).0, at)\n    }\n\n    fn push_packed(&self, at: &Key) {\n        <T as PackedLayout>::push_packed(&(self.0).0, at)\n    }\n\n    fn clear_packed(&self, at: &Key) {\n        <T as PackedLayout>::clear_packed(&(self.0).0, at)\n    }\n}\n\nimpl<T> scale::Encode for Reverse<T>\nwhere\n    T: PackedLayout + Ord + scale::Encode,\n{\n    #[inline]\n    fn size_hint(&self) -> usize {\n        <T as scale::Encode>::size_hint(self.value())\n    }\n\n    #[inline]\n    fn encode_to<O: scale::Output + ?Sized>(&self, dest: &mut O) {\n        <T as scale::Encode>::encode_to(self.value(), dest)\n    }\n\n    #[inline]\n    fn encode(&self) -> Vec<u8> {\n        <T as scale::Encode>::encode(self.value())\n    }\n\n    #[inline]\n    fn using_encoded<R, F: FnOnce(&[u8]) -> R>(&self, f: F) -> R {\n        <T as scale::Encode>::using_encoded(self.value(), f)\n    }\n}\n\nimpl<T> scale::Decode for Reverse<T>\nwhere\n    T: PackedLayout + Ord + scale::Decode,\n{\n    fn decode<I: scale::Input>(value: &mut I) -> Result<Self, scale::Error> {\n        let value = <T as scale::Decode>::decode(value)?;\n        Ok(Self::new(value))\n    }\n}\n"],["973","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Implementation of ink! storage traits.\n\nuse super::{\n    BinaryHeap,\n    ChildrenVec,\n};\nuse crate::traits::{\n    KeyPtr,\n    PackedLayout,\n    SpreadLayout,\n};\n\n#[cfg(feature = \"std\")]\nconst _: () = {\n    use crate::traits::StorageLayout;\n    use ink_metadata::layout::{\n        FieldLayout,\n        Layout,\n        StructLayout,\n    };\n    use scale_info::TypeInfo;\n\n    impl<T> StorageLayout for BinaryHeap<T>\n    where\n        T: PackedLayout + Ord + TypeInfo + 'static,\n    {\n        fn layout(key_ptr: &mut KeyPtr) -> Layout {\n            Layout::Struct(StructLayout::new(vec![FieldLayout::new(\n                \"elements\",\n                <ChildrenVec<T> as StorageLayout>::layout(key_ptr),\n            )]))\n        }\n    }\n};\n\n#[cfg(feature = \"std\")]\nconst _: () = {\n    use super::children::Children;\n    use crate::{\n        collections::binary_heap::StorageVec,\n        lazy::Lazy,\n        traits::StorageLayout,\n    };\n    use ink_metadata::layout::{\n        FieldLayout,\n        Layout,\n        StructLayout,\n    };\n    use scale_info::TypeInfo;\n\n    impl<T> StorageLayout for ChildrenVec<T>\n    where\n        T: PackedLayout + Ord + TypeInfo + 'static,\n    {\n        fn layout(key_ptr: &mut KeyPtr) -> Layout {\n            Layout::Struct(StructLayout::new(vec![\n                FieldLayout::new(\"len\", <Lazy<u32> as StorageLayout>::layout(key_ptr)),\n                FieldLayout::new(\n                    \"children\",\n                    <StorageVec<Children<T>> as StorageLayout>::layout(key_ptr),\n                ),\n            ]))\n        }\n    }\n};\n\nimpl<T> SpreadLayout for BinaryHeap<T>\nwhere\n    T: PackedLayout + Ord,\n{\n    const FOOTPRINT: u64 = <ChildrenVec<T> as SpreadLayout>::FOOTPRINT;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        Self {\n            elements: SpreadLayout::pull_spread(ptr),\n        }\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        SpreadLayout::push_spread(&self.elements, ptr);\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        SpreadLayout::clear_spread(&self.elements, ptr);\n    }\n}\n"],["974","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Provides an interface around the vector used to store elements of the\n//! [`BinaryHeap`](`super::BinaryHeap`) in storage. This is necessary since\n//! we don't just store each element in it's own storage cell, but rather\n//! optimize storage access by putting children together in one storage cell.\n\nuse super::{\n    children,\n    children::Children,\n    StorageVec,\n};\nuse crate::{\n    traits::{\n        KeyPtr,\n        PackedLayout,\n        SpreadLayout,\n    },\n    Lazy,\n};\n\n/// Provides an interface for accessing elements in the `BinaryHeap`.\n///\n/// Elements of the heap are stored in a vector of `Children` objects, whereby\n/// each `Children` object contains two elements. When operating on indices of\n/// the `BinaryHeap` this interface transposes heap indices to the child inside\n/// the `Children` object, in which the element is stored.\n#[derive(Default, PartialEq, Eq, Debug)]\npub struct ChildrenVec<T>\nwhere\n    T: PackedLayout + Ord,\n{\n    /// The number of elements stored in the heap.\n    /// We cannot use the length of the storage vector, since each entry (i.e. each\n    /// `Children` object) in the vector contains two child elements (except the root\n    /// element which occupies a `Children` object on its own.\n    len: Lazy<u32>,\n    /// The underlying storage vec containing the `Children`.\n    children: StorageVec<Children<T>>,\n}\n\n/// Encapsulates information regarding a particular child.\npub(super) struct ChildInfo<'a, T> {\n    /// A reference to the value in this child, if existent.\n    pub child: &'a Option<T>,\n}\n\nimpl<'a, T> ChildInfo<'a, T> {\n    /// Creates a new `ChildInfo` object.\n    fn new(child: &'a Option<T>) -> Self {\n        Self { child }\n    }\n}\n\n/// Encapsulates information regarding a particular child.\npub(super) struct ChildInfoMut<'a, T> {\n    /// A mutable reference to the value in this child, if existent.\n    pub child: &'a mut Option<T>,\n    /// The number of children which are set in this `Children` object.\n    ///\n    /// This property exists only in `ChildInfoMut`, but not in `ChildInfo`.\n    /// The reason is that in the case of pop-ping a child from a `Children`\n    /// object we need to check if the child count of that object is `0` after\n    /// the pop operation. In that case no children are left in the object\n    /// and it can be removed altogether from the heap.\n    pub child_count: usize,\n}\n\nimpl<'a, T> ChildInfoMut<'a, T> {\n    /// Creates a new `ChildInfoMut` object.\n    fn new(child: &'a mut Option<T>, child_count: usize) -> Self {\n        Self { child, child_count }\n    }\n}\n\nimpl<T> ChildrenVec<T>\nwhere\n    T: PackedLayout + Ord,\n{\n    /// Creates a new empty storage heap.\n    #[inline]\n    pub fn new() -> Self {\n        Self {\n            len: Lazy::new(0),\n            children: StorageVec::new(),\n        }\n    }\n\n    /// Returns the number of elements in the heap, also referred to as its 'length'.\n    #[inline]\n    pub fn len(&self) -> u32 {\n        *self.len\n    }\n\n    /// Returns the amount of `Children` objects stored in the vector.\n    #[allow(dead_code)]\n    #[cfg(all(test, feature = \"ink-fuzz-tests\"))]\n    pub fn children_count(&self) -> u32 {\n        self.children.len()\n    }\n\n    /// Returns `true` if the heap contains no elements.\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Returns a shared reference to the indexed element.\n    ///\n    /// Returns `None` if `index` is out of bounds.\n    pub fn get(&self, index: u32) -> Option<&T> {\n        self.get_child(index)?.child.as_ref()\n    }\n\n    /// Returns an exclusive reference to the indexed element.\n    /// The element in a `Children` is an `Option<T>`.\n    ///\n    /// Returns `None` if `index` is out of bounds.\n    pub fn get_mut(&mut self, index: u32) -> Option<&mut T> {\n        let child_info = self.get_child_mut(index)?;\n        child_info.child.as_mut()\n    }\n\n    /// Swaps the elements at the given indices.\n    ///\n    /// # Panics\n    ///\n    /// If one or both indices are out of bounds.\n    pub fn swap(&mut self, a: u32, b: u32) {\n        if a == b {\n            return\n        }\n        assert!(a < self.len(), \"a is out of bounds\");\n        assert!(b < self.len(), \"b is out of bounds\");\n\n        let child_info_a = self.get_child_mut(a).expect(\"index a must exist\");\n        let a_opt = child_info_a.child.take();\n\n        let child_info_b = self.get_child_mut(b).expect(\"index b must exist\");\n        let b_opt = core::mem::replace(child_info_b.child, a_opt);\n\n        let child_info_a = self.get_child_mut(a).expect(\"index a must exist\");\n        *child_info_a.child = b_opt;\n    }\n\n    /// Removes the element at `index` from the heap and returns it.\n    ///\n    /// The last element of the heap is put into the slot at `index`.\n    /// Returns `None` and does not mutate the heap if it is empty.\n    pub fn swap_remove(&mut self, index: u32) -> Option<T> {\n        if self.is_empty() {\n            return None\n        }\n        self.swap(index, self.len() - 1);\n        self.pop()\n    }\n\n    /// Returns an iterator yielding shared references to all elements of the heap.\n    ///\n    /// # Note\n    ///\n    /// Avoid unbounded iteration over big storage heaps.\n    /// Prefer using methods like `Iterator::take` in order to limit the number\n    /// of yielded elements.\n    pub fn iter(&self) -> Iter<T> {\n        Iter::new(&self)\n    }\n\n    /// Returns a shared reference to the first element if any.\n    pub fn first(&self) -> Option<&T> {\n        if self.is_empty() {\n            return None\n        }\n        self.get(0)\n    }\n\n    /// Returns an exclusive reference to the first element if any.\n    pub fn first_mut(&mut self) -> Option<&mut T> {\n        if self.is_empty() {\n            return None\n        }\n        self.get_mut(0)\n    }\n\n    /// Removes all elements from this heap.\n    ///\n    /// # Note\n    ///\n    /// Use this method to clear the heap instead of e.g. iterative `pop()`.\n    /// This method performs significantly better and does not actually read\n    /// any of the elements (whereas `pop()` does).\n    pub fn clear(&mut self) {\n        if self.is_empty() {\n            return\n        }\n        self.children.clear();\n        self.len = Lazy::new(0);\n    }\n\n    /// Appends an element to the back of the heap.\n    pub fn push(&mut self, value: T) {\n        assert!(\n            self.len() < core::u32::MAX,\n            \"cannot push more elements into the storage heap\"\n        );\n        let last_index = self.len();\n        *self.len += 1;\n        self.insert(last_index, Some(value));\n    }\n\n    /// Returns information about the child at the heap index if any.\n    pub(super) fn get_child(&self, index: u32) -> Option<ChildInfo<T>> {\n        let storage_index = children::get_children_storage_index(index);\n        let child_pos = children::get_child_pos(index);\n        let children = self.children.get(storage_index)?;\n        let child = children.child(child_pos);\n        Some(ChildInfo::new(child))\n    }\n\n    /// Returns information about the child at the heap index if any.\n    ///\n    /// The returned `ChildInfoMut` contains a mutable reference to the value `T`.\n    pub(super) fn get_child_mut(&mut self, index: u32) -> Option<ChildInfoMut<T>> {\n        let storage_index = children::get_children_storage_index(index);\n        let child_pos = children::get_child_pos(index);\n        let children = self.children.get_mut(storage_index)?;\n        let count = children.count();\n        let child = children.child_mut(child_pos);\n        Some(ChildInfoMut::new(child, count))\n    }\n\n    /// Inserts `value` at the heap index `index`.\n    ///\n    /// If there is already a child in storage which `index` resolves to\n    /// then `value` is inserted there. Otherwise a new child is created.\n    fn insert(&mut self, index: u32, value: Option<T>) {\n        let info = self.get_child_mut(index);\n        if let Some(info) = info {\n            *info.child = value;\n            return\n        }\n\n        self.children.push(Children::new(value, None));\n        debug_assert!(\n            {\n                let storage_index = children::get_children_storage_index(index);\n                self.children.get(storage_index).is_some()\n            },\n            \"the new children were not placed at children_index!\"\n        );\n    }\n\n    /// Pops the last element from the heap and returns it.\n    //\n    /// Returns `None` if the heap is empty.\n    fn pop(&mut self) -> Option<T> {\n        if self.is_empty() {\n            return None\n        }\n        let last_index = self.len() - 1;\n        *self.len = last_index;\n\n        let info = self\n            .get_child_mut(last_index)\n            .expect(\"children must exist at last_index\");\n        let popped_val = info.child.take();\n        if info.child_count == 1 {\n            // if both children are non-existent the entire `Children` object can be removed\n            self.children.pop();\n        }\n        popped_val\n    }\n}\n\nimpl<T> SpreadLayout for ChildrenVec<T>\nwhere\n    T: SpreadLayout + Ord + PackedLayout,\n{\n    const FOOTPRINT: u64 = 1 + <StorageVec<Children<T>> as SpreadLayout>::FOOTPRINT;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        let len = SpreadLayout::pull_spread(ptr);\n        let children = SpreadLayout::pull_spread(ptr);\n        Self { len, children }\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        SpreadLayout::push_spread(&self.len, ptr);\n        SpreadLayout::push_spread(&self.children, ptr);\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        SpreadLayout::clear_spread(&self.len, ptr);\n        SpreadLayout::clear_spread(&self.children, ptr);\n    }\n}\n\n/// An iterator over shared references to the elements of the `BinaryHeap`.\n#[derive(Debug, Clone, Copy)]\npub struct Iter<'a, T>\nwhere\n    T: PackedLayout + Ord,\n{\n    /// The heap elements to iterate over.\n    elements: &'a ChildrenVec<T>,\n    /// The current begin of the iteration.\n    begin: u32,\n    /// The current end of the iteration.\n    end: u32,\n}\n\nimpl<'a, T> Iter<'a, T>\nwhere\n    T: PackedLayout + Ord,\n{\n    /// Creates a new iterator for the given heap elements.\n    pub fn new(elements: &'a ChildrenVec<T>) -> Self {\n        Self {\n            elements,\n            begin: 0,\n            end: elements.len(),\n        }\n    }\n\n    /// Returns the amount of remaining elements to yield by the iterator.\n    fn remaining(&self) -> u32 {\n        self.end - self.begin\n    }\n}\n\nimpl<'a, T> Iterator for Iter<'a, T>\nwhere\n    T: PackedLayout + Ord,\n{\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        <Self as Iterator>::nth(self, 0)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let remaining = self.remaining() as usize;\n        (remaining, Some(remaining))\n    }\n\n    fn count(self) -> usize {\n        self.remaining() as usize\n    }\n\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        debug_assert!(self.begin <= self.end);\n        let n = n as u32;\n        if self.begin + n >= self.end {\n            return None\n        }\n        let cur = self.begin + n;\n        self.begin += 1 + n;\n\n        self.elements.get_child(cur)?.child.as_ref()\n    }\n}\n"],["975","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::BinaryHeap;\nuse crate::traits::PackedLayout;\nuse core::iter::{\n    Extend,\n    FromIterator,\n};\n\nimpl<T> Extend<T> for BinaryHeap<T>\nwhere\n    T: PackedLayout + Ord,\n{\n    fn extend<I>(&mut self, iter: I)\n    where\n        I: IntoIterator<Item = T>,\n    {\n        for item in iter {\n            self.push(item)\n        }\n    }\n}\n\nimpl<T> FromIterator<T> for BinaryHeap<T>\nwhere\n    T: PackedLayout + Ord,\n{\n    fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = T>,\n    {\n        let mut heap = Self::new();\n        heap.extend(iter);\n        heap\n    }\n}\n"],["976","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! A priority queue implemented with a binary heap.\n//!\n//! Insertion and popping the largest element have `O(log(n))` complexity.\n//! Checking the largest element is `O(1)`.\n\nmod children;\nmod children_vec;\nmod impls;\nmod reverse;\nmod storage;\n\n#[cfg(test)]\nmod tests;\n\nuse self::children_vec::ChildrenVec;\nuse crate::{\n    collections::vec::Vec as StorageVec,\n    traits::PackedLayout,\n};\n\npub use children_vec::Iter;\npub use reverse::Reverse;\n\n/// A priority queue implemented with a binary heap.\n///\n/// # Note\n///\n/// The heap is a *max-heap* by default, i.e. the first element is the largest.\n/// Either [`Reverse`] or a custom `Ord` implementation can be used to\n/// make `BinaryHeap` a *min-heap*. This makes `heap.pop()` return the smallest\n/// value instead of the largest one.\n#[derive(Default, PartialEq, Eq, Debug)]\npub struct BinaryHeap<T>\nwhere\n    T: PackedLayout + Ord,\n{\n    /// The individual elements of the heap.\n    elements: ChildrenVec<T>,\n}\n\nimpl<T> BinaryHeap<T>\nwhere\n    T: PackedLayout + Ord,\n{\n    /// Creates a new empty storage heap.\n    pub fn new() -> Self {\n        Self {\n            elements: ChildrenVec::new(),\n        }\n    }\n\n    /// Returns the number of elements in the heap, also referred to as its 'length'.\n    pub fn len(&self) -> u32 {\n        self.elements.len()\n    }\n\n    /// Returns `true` if the heap contains no elements.\n    pub fn is_empty(&self) -> bool {\n        self.elements.is_empty()\n    }\n}\n\nimpl<T> BinaryHeap<T>\nwhere\n    T: PackedLayout + Ord,\n{\n    /// Returns an iterator yielding shared references to all elements of the heap.\n    ///\n    /// # Note\n    ///\n    /// Avoid unbounded iteration over large heaps.\n    /// Prefer using methods like `Iterator::take` in order to limit the number\n    /// of yielded elements.\n    pub fn iter(&self) -> Iter<T> {\n        self.elements.iter()\n    }\n\n    /// Returns a shared reference to the greatest element of the heap\n    ///\n    /// Returns `None` if the heap is empty\n    pub fn peek(&self) -> Option<&T> {\n        self.elements.first()\n    }\n\n    /// Returns an exclusive reference to the greatest element of the heap\n    ///\n    /// Returns `None` if the heap is empty\n    ///\n    /// # Note:\n    ///\n    /// If the `PeekMut` value is leaked, the heap may be in an inconsistent state.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use ink_storage::collections::BinaryHeap;\n    /// let mut heap = BinaryHeap::new();\n    /// assert!(heap.peek_mut().is_none());\n    ///\n    /// heap.push(1);\n    /// heap.push(5);\n    /// heap.push(2);\n    /// {\n    ///     let mut val = heap.peek_mut().unwrap();\n    ///     *val = 0;\n    /// }\n    /// assert_eq!(heap.peek(), Some(&2));\n    /// ```\n    pub fn peek_mut(&mut self) -> Option<PeekMut<'_, T>> {\n        if self.is_empty() {\n            None\n        } else {\n            Some(PeekMut {\n                heap: self,\n                sift: true,\n            })\n        }\n    }\n\n    /// Take an element at `pos` and move it down the heap, while its children\n    /// are smaller.\n    fn sift_down(&mut self, mut pos: u32) {\n        let end = self.len();\n        let mut child = 2 * pos + 1;\n        while child < end {\n            let right = child + 1;\n            // compare with the greater of the two children\n            if right < end && self.elements.get(child) <= self.elements.get(right) {\n                child = right;\n            }\n            // if we are already in order, stop.\n            if self.elements.get(pos) >= self.elements.get(child) {\n                break\n            }\n            self.elements.swap(child, pos);\n            pos = child;\n            child = 2 * pos + 1;\n        }\n    }\n\n    /// Pops greatest element from the heap and returns it\n    ///\n    /// Returns `None` if the heap is empty\n    pub fn pop(&mut self) -> Option<T> {\n        // replace the root of the heap with the last element\n        let elem = self.elements.swap_remove(0);\n        self.sift_down(0);\n        elem\n    }\n\n    /// Removes all elements from this heap.\n    ///\n    /// # Note\n    ///\n    /// Use this method to clear the heap instead of e.g. iterative `pop()`.\n    /// This method performs significantly better and does not actually read\n    /// any of the elements (whereas `pop()` does).\n    pub fn clear(&mut self) {\n        self.elements.clear()\n    }\n}\n\nimpl<T> BinaryHeap<T>\nwhere\n    T: PackedLayout + Ord,\n{\n    /// Take an element at `pos` and move it up the heap, while its parent is\n    /// larger.\n    fn sift_up(&mut self, mut pos: u32) {\n        while pos > 0 {\n            let parent = (pos - 1) / 2;\n            if self.elements.get(pos) <= self.elements.get(parent) {\n                break\n            }\n            self.elements.swap(parent, pos);\n            pos = parent;\n        }\n    }\n\n    /// Pushes the given element to the binary heap.\n    pub fn push(&mut self, value: T) {\n        let old_len = self.len();\n        self.elements.push(value);\n        self.sift_up(old_len)\n    }\n}\n\n/// Structure wrapping a mutable reference to the greatest item on a\n/// [`BinaryHeap`].\n///\n/// This `struct` is created by the [`BinaryHeap::peek_mut`] method.\npub struct PeekMut<'a, T>\nwhere\n    T: 'a + PackedLayout + Ord,\n{\n    heap: &'a mut BinaryHeap<T>,\n    /// If `true`, on `drop()` will sift the peeked value down the tree if after mutation it is no\n    /// longer the largest value, in order to keep the heap in a consistent state.\n    ///\n    /// If the peeked value is consumed via `PeekMut::pop()` then this is set to false to prevent\n    /// a redundant reorg which would already have happened via `BinaryHeap::pop()`.\n    sift: bool,\n}\n\nimpl<T> Drop for PeekMut<'_, T>\nwhere\n    T: PackedLayout + Ord,\n{\n    fn drop(&mut self) {\n        if self.sift {\n            self.heap.sift_down(0);\n        }\n    }\n}\n\nimpl<T> core::ops::Deref for PeekMut<'_, T>\nwhere\n    T: PackedLayout + Ord,\n{\n    type Target = T;\n    fn deref(&self) -> &T {\n        self.heap\n            .elements\n            .first()\n            .expect(\"PeekMut is only instantiated for non-empty heaps\")\n    }\n}\n\nimpl<T> core::ops::DerefMut for PeekMut<'_, T>\nwhere\n    T: PackedLayout + Ord,\n{\n    fn deref_mut(&mut self) -> &mut T {\n        self.heap\n            .elements\n            .first_mut()\n            .expect(\"PeekMut is only instantiated for non-empty heaps\")\n    }\n}\n\nimpl<'a, T> PeekMut<'a, T>\nwhere\n    T: PackedLayout + Ord,\n{\n    /// Removes the peeked value from the heap and returns it.\n    pub fn pop(mut this: PeekMut<'a, T>) -> T {\n        let value = this\n            .heap\n            .pop()\n            .expect(\"PeekMut is only instantiated for non-empty heaps\");\n        this.sift = false;\n        value\n    }\n}\n"],["977","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! A `Children` object consists of two elements: a left and right child.\n\nuse crate::traits::{\n    forward_clear_packed,\n    forward_pull_packed,\n    forward_push_packed,\n    KeyPtr,\n    PackedLayout,\n    SpreadLayout,\n};\nuse ink_primitives::Key;\n\n#[cfg(feature = \"std\")]\nuse scale_info::TypeInfo;\n\n/// Each `Children` object may contain up to two elements. It is always\n/// stored in one single storage cell. This reduces storage access operations\n/// of the binary heap algorithm.\n#[cfg_attr(feature = \"std\", derive(TypeInfo))]\n#[derive(scale::Encode, scale::Decode, Default, PartialEq, Eq, Debug)]\npub(super) struct Children<T: PackedLayout + Ord> {\n    left: Option<T>,\n    right: Option<T>,\n}\n\n/// The position which a child has in a `Children` object.\n#[derive(Copy, Clone, PartialEq, Debug)]\npub(super) enum ChildPosition {\n    Left,\n    Right,\n}\n\n/// Number of elements stored in each `Children` object.\n///\n/// Note that the first `Children` object (at index `0`) will only ever\n/// contain one element (the root element).\npub(super) const CHILDREN_PER_NODE: u32 = 2;\n\n/// Returns the index of the `Children` object in which the `n`-th element of\n/// the heap is stored.\npub(super) fn get_children_storage_index(n: u32) -> u32 {\n    if n == 0 {\n        return 0\n    }\n    // The first `Children` object only ever contains the root element:\n    // `[Some(root), None]`. So when calculating indices we need to account\n    // for the items which have been left empty in the first `Children` object.\n    let padding = CHILDREN_PER_NODE - 1;\n    (n + padding) / CHILDREN_PER_NODE\n}\n\n/// Returns the `ChildPosition` of the `n`-th heap element.\n///\n/// For example, the element `3` is found at the child position `0`\n/// (within the `Children` object at storage index `2`).\npub(super) fn get_child_pos(n: u32) -> ChildPosition {\n    let storage_index = get_children_storage_index(n);\n    match (storage_index, n) {\n        (0, 0) => ChildPosition::Left,\n        (0, _) => panic!(\"first children object contains only the root element\"),\n        (_, _) => {\n            let child_pos = (n - 1) % CHILDREN_PER_NODE;\n            match child_pos {\n                0 => ChildPosition::Left,\n                1 => ChildPosition::Right,\n                _ => {\n                    unreachable!(\n                        \"CHILDREN_PER_NODE is 2, following the modulo op index must be 0 or 1\"\n                    )\n                }\n            }\n        }\n    }\n}\n\nimpl<T> Children<T>\nwhere\n    T: PackedLayout + Ord,\n{\n    /// Creates a new `Children` object with a left and right element.\n    pub fn new(left: Option<T>, right: Option<T>) -> Self {\n        Self { left, right }\n    }\n\n    /// Returns the number of existent children in this object.\n    pub fn count(&self) -> usize {\n        self.left.is_some() as usize + self.right.is_some() as usize\n    }\n\n    /// Returns a shared reference to the element at `which`.\n    pub fn child(&self, which: ChildPosition) -> &Option<T> {\n        match which {\n            ChildPosition::Left => &self.left,\n            ChildPosition::Right => &self.right,\n        }\n    }\n\n    /// Returns an exclusive reference to the element at `which`.\n    pub fn child_mut(&mut self, which: ChildPosition) -> &mut Option<T> {\n        match which {\n            ChildPosition::Left => &mut self.left,\n            ChildPosition::Right => &mut self.right,\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nconst _: () = {\n    use crate::traits::StorageLayout;\n    use ink_metadata::layout::{\n        CellLayout,\n        Layout,\n        LayoutKey,\n    };\n\n    impl<T> StorageLayout for Children<T>\n    where\n        T: PackedLayout + Ord + TypeInfo + 'static,\n    {\n        fn layout(key_ptr: &mut KeyPtr) -> Layout {\n            Layout::Cell(CellLayout::new::<Children<T>>(LayoutKey::from(\n                key_ptr.advance_by(1),\n            )))\n        }\n    }\n};\n\nimpl<T> SpreadLayout for Children<T>\nwhere\n    T: PackedLayout + Ord,\n{\n    const FOOTPRINT: u64 = 1;\n    const REQUIRES_DEEP_CLEAN_UP: bool = false;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        forward_pull_packed::<Self>(ptr)\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        forward_push_packed::<Self>(self, ptr)\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        forward_clear_packed::<Self>(self, ptr)\n    }\n}\n\nimpl<T> PackedLayout for Children<T>\nwhere\n    T: PackedLayout + Ord,\n{\n    fn push_packed(&self, at: &Key) {\n        <Option<T> as PackedLayout>::push_packed(&self.left, at);\n        <Option<T> as PackedLayout>::push_packed(&self.right, at);\n    }\n\n    fn clear_packed(&self, at: &Key) {\n        <Option<T> as PackedLayout>::clear_packed(&self.left, at);\n        <Option<T> as PackedLayout>::clear_packed(&self.right, at);\n    }\n\n    fn pull_packed(&mut self, at: &Key) {\n        <Option<T> as PackedLayout>::pull_packed(&mut self.left, at);\n        <Option<T> as PackedLayout>::pull_packed(&mut self.right, at);\n    }\n}\n\n#[test]\nfn get_children_storage_index_works() {\n    // root is in cell 0\n    assert_eq!(get_children_storage_index(0), 0);\n\n    // element 1 + 2 are childrent of element 0 and\n    // should be in one cell together\n    assert_eq!(get_children_storage_index(1), 1);\n    assert_eq!(get_children_storage_index(2), 1);\n\n    // element 3 and 4 should be in one cell\n    assert_eq!(get_children_storage_index(3), 2);\n    assert_eq!(get_children_storage_index(4), 2);\n}\n\n#[test]\nfn get_child_pos_works() {\n    assert_eq!(get_child_pos(0), ChildPosition::Left);\n\n    assert_eq!(get_child_pos(1), ChildPosition::Left);\n    assert_eq!(get_child_pos(2), ChildPosition::Right);\n\n    assert_eq!(get_child_pos(3), ChildPosition::Left);\n    assert_eq!(get_child_pos(4), ChildPosition::Right);\n\n    assert_eq!(get_child_pos(5), ChildPosition::Left);\n    assert_eq!(get_child_pos(6), ChildPosition::Right);\n}\n"],["978","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! High-level collections used to manage storage entities in the persisted\n//! contract storage.\n//!\n//! Users should generally use these collections in their contracts directly\n//! or as building blocks for their collections and algorithms.\n\npub mod binary_heap;\npub mod bitstash;\npub mod bitvec;\npub mod hashmap;\n#[cfg(feature = \"ink-unstable\")]\npub mod smallvec;\npub mod stash;\npub mod vec;\n\n#[doc(inline)]\npub use self::{\n    binary_heap::BinaryHeap,\n    bitstash::BitStash,\n    bitvec::Bitvec,\n    hashmap::HashMap,\n    stash::Stash,\n    vec::Vec,\n};\n\n#[cfg(feature = \"ink-unstable\")]\n#[doc(inline)]\npub use self::smallvec::SmallVec;\n\n/// Extends the lifetime 'a to the outliving lifetime 'b for the given reference.\n///\n/// # Note\n///\n/// This interface is a bit more constraint than a simple\n/// [transmut](`core::mem::transmute`) and therefore preferred\n/// for extending lifetimes only.\n///\n/// # Safety\n///\n/// This function is `unsafe` because lifetimes can be extended beyond the\n/// lifetimes of the objects they are referencing and thus potentially create\n/// dangling references if not used carefully.\npub(crate) unsafe fn extend_lifetime<'a, 'b: 'a, T>(reference: &'a mut T) -> &'b mut T {\n    core::mem::transmute::<&'a mut T, &'b mut T>(reference)\n}\n"],["979","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::{\n    Bits256,\n    Bitvec as StorageBitvec,\n};\nuse crate::{\n    traits::{\n        forward_clear_packed,\n        forward_pull_packed,\n        forward_push_packed,\n        KeyPtr,\n        PackedLayout,\n        SpreadLayout,\n    },\n    Pack,\n    Vec as StorageVec,\n};\nuse ink_primitives::Key;\n\n#[cfg(feature = \"std\")]\nconst _: () = {\n    use crate::{\n        lazy::Lazy,\n        traits::StorageLayout,\n    };\n    use ink_metadata::layout::{\n        FieldLayout,\n        Layout,\n        StructLayout,\n    };\n\n    impl StorageLayout for StorageBitvec {\n        fn layout(key_ptr: &mut KeyPtr) -> Layout {\n            Layout::Struct(StructLayout::new(vec![\n                FieldLayout::new(\"len\", <Lazy<u32> as StorageLayout>::layout(key_ptr)),\n                FieldLayout::new(\n                    \"elems\",\n                    <StorageVec<Bits256> as StorageLayout>::layout(key_ptr),\n                ),\n            ]))\n        }\n    }\n};\n\nimpl SpreadLayout for Bits256 {\n    const FOOTPRINT: u64 = 1;\n    const REQUIRES_DEEP_CLEAN_UP: bool = false;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        forward_pull_packed::<Self>(ptr)\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        forward_push_packed::<Self>(self, ptr)\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        forward_clear_packed::<Self>(self, ptr)\n    }\n}\n\nimpl PackedLayout for Bits256 {\n    fn pull_packed(&mut self, _at: &Key) {}\n    fn push_packed(&self, _at: &Key) {}\n    fn clear_packed(&self, _at: &Key) {}\n}\n\nimpl SpreadLayout for StorageBitvec {\n    const FOOTPRINT: u64 = 1 + <StorageVec<Pack<Bits256>> as SpreadLayout>::FOOTPRINT;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        Self {\n            len: SpreadLayout::pull_spread(ptr),\n            bits: SpreadLayout::pull_spread(ptr),\n        }\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        SpreadLayout::push_spread(&self.len, ptr);\n        SpreadLayout::push_spread(&self.bits, ptr);\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        SpreadLayout::clear_spread(&self.len, ptr);\n        SpreadLayout::clear_spread(&self.bits, ptr);\n    }\n}\n"],["980","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Storage bit vector data structure and utilities.\n//!\n//! Allows to compactly and efficiently store and manipulate on single bits.\n\nmod bitref;\nmod bits256;\nmod bitsref;\nmod impls;\nmod iter;\nmod storage;\n\n#[cfg(test)]\nmod tests;\n\npub use self::{\n    bitref::BitRefMut,\n    bitsref::ChunkRef,\n    iter::{\n        BitsIter,\n        BitsIterMut,\n    },\n};\nuse self::{\n    bits256::{\n        Bits256,\n        Iter as Bits256BitsIter,\n        IterMut as Bits256BitsIterMut,\n    },\n    iter::{\n        Bits256Iter,\n        Bits256IterMut,\n    },\n};\nuse crate::{\n    Lazy,\n    Vec as StorageVec,\n};\n\n/// The index of a bit pack within the bit vector.\ntype Index = u32;\n\n/// A bit position within a 256-bit package.\ntype Index256 = u8;\n\n/// A bit position within a `u64`.\ntype Index64 = u8;\n\n/// A pack of 64 bits.\ntype Bits64 = u64;\n\n/// A storage bit vector.\n///\n/// # Note\n///\n/// Organizes its bits in chunks of 256 bits.\n/// Allows to `push`, `pop`, inspect and manipulate the underlying bits.\n#[derive(Debug)]\npub struct Bitvec {\n    /// The length of the bit vector.\n    len: Lazy<u32>,\n    /// The bits of the bit vector.\n    ///\n    /// Organized in packs of 256 bits.\n    bits: StorageVec<Bits256>,\n}\n\nimpl Bitvec {\n    /// Creates a new empty bit vector.\n    pub fn new() -> Self {\n        Self {\n            len: Lazy::from(0),\n            bits: StorageVec::new(),\n        }\n    }\n\n    /// Returns the length of the bit vector in bits.\n    pub fn len(&self) -> u32 {\n        *self.len\n    }\n\n    /// Returns `true` if the bit vector is empty.\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Returns the capacity of the bit vector in bits.\n    ///\n    /// # Note\n    ///\n    /// Returns a `u64` since it is always greater than or equal to `self.len()`\n    /// which itself returns a `u32`.\n    pub fn capacity(&self) -> u64 {\n        (self.bits.len() * 256) as u64\n    }\n\n    /// Returns an iterator over the bits of the storage bit vector.\n    pub fn bits(&self) -> BitsIter {\n        BitsIter::new(self)\n    }\n\n    /// Returns an iterator over the mutable bits of the storage bit vector.\n    pub fn bits_mut(&mut self) -> BitsIterMut {\n        BitsIterMut::new(self)\n    }\n\n    /// Returns an iterator over the 256-bit chunks of the storage bit vector.\n    pub(super) fn iter_chunks(&self) -> Bits256Iter {\n        Bits256Iter::new(self)\n    }\n\n    /// Returns an iterator over the mutable 256-bit chunks of the storage bit vector.\n    pub(super) fn iter_chunks_mut(&mut self) -> Bits256IterMut {\n        Bits256IterMut::new(self)\n    }\n\n    /// Splits the given index into a 256-bit pack index and bit position index.\n    fn split_index(&self, at: Index) -> Option<(Index, Index256)> {\n        if at >= self.len() {\n            return None\n        }\n        Some((at / 256, (at % 256) as u8))\n    }\n\n    /// Returns the immutable access pair to the underlying 256-bits pack and bit.\n    ///\n    /// Returns `None` if the given index is out of bounds.\n    fn get_bits256(&self, at: Index) -> Option<(&Bits256, Index256)> {\n        let (index, pos256) = self.split_index(at)?;\n        let bits256 = self.bits.get(index).expect(\"index is out of bounds\");\n        Some((bits256, pos256))\n    }\n\n    /// Returns the mutable access pair to the underlying 256-bits pack and bit.\n    ///\n    /// Returns `None` if the given index is out of bounds.\n    fn get_bits256_mut(&mut self, at: Index) -> Option<(&mut Bits256, Index256)> {\n        let (index, pos256) = self.split_index(at)?;\n        let bits256 = self.bits.get_mut(index).expect(\"index is out of bounds\");\n        Some((bits256, pos256))\n    }\n\n    /// Returns a mutable bit access to the bit at the given index if any.\n    fn get_access_mut(&mut self, at: Index) -> Option<BitRefMut> {\n        self.get_bits256_mut(at)\n            .map(|(bits256, pos256)| BitRefMut::new(bits256, pos256))\n    }\n\n    /// Returns the value of the bit at the given index if any.\n    pub fn get(&self, at: Index) -> Option<bool> {\n        self.get_bits256(at)\n            .map(|(bits256, pos256)| bits256.get(pos256))\n    }\n\n    /// Returns a mutable bit access to the bit at the given index if any.\n    pub fn get_mut(&mut self, at: Index) -> Option<BitRefMut> {\n        self.get_access_mut(at)\n    }\n\n    /// Returns a shared reference to the 256-bit chunk for the bit at the given index.\n    pub fn get_chunk(&self, at: Index) -> Option<ChunkRef<&Bits256>> {\n        if at >= self.len() {\n            return None\n        }\n        use core::cmp::min;\n        let chunk_id = at / 256;\n        let chunk_len = min(256, self.len() - at);\n        let bits256 = self.bits.get(chunk_id).expect(\"index is out of bounds\");\n        Some(ChunkRef::shared(bits256, chunk_len))\n    }\n\n    /// Returns an exclusive reference to the 256-bit chunk for the bit at the given index.\n    pub fn get_chunk_mut(&mut self, at: Index) -> Option<ChunkRef<&mut Bits256>> {\n        if at >= self.len() {\n            return None\n        }\n        use core::cmp::min;\n        let chunk_id = at / 256;\n        let chunk_len = min(256, self.len() - at);\n        let bits256 = self.bits.get_mut(chunk_id).expect(\"index is out of bounds\");\n        Some(ChunkRef::exclusive(bits256, chunk_len))\n    }\n\n    /// Returns the first bit of the bit vector.\n    ///\n    /// # Note\n    ///\n    /// Returns `None` if the bit vector is empty.\n    pub fn first(&self) -> Option<bool> {\n        if self.is_empty() {\n            return None\n        }\n        self.get(0)\n    }\n\n    /// Returns a mutable bit access to the first bit of the bit vector.\n    ///\n    /// # Note\n    ///\n    /// Returns `None` if the bit vector is empty.\n    pub fn first_mut(&mut self) -> Option<BitRefMut> {\n        if self.is_empty() {\n            return None\n        }\n        self.get_access_mut(0)\n    }\n\n    /// Returns the last bit of the bit vector.\n    ///\n    /// # Note\n    ///\n    /// Returns `None` if the bit vector is empty.\n    pub fn last(&self) -> Option<bool> {\n        if self.is_empty() {\n            return None\n        }\n        self.get(self.len() - 1)\n    }\n\n    /// Returns a mutable bit access to the last bit of the bit vector.\n    ///\n    /// # Note\n    ///\n    /// Returns `None` if the bit vector is empty.\n    pub fn last_mut(&mut self) -> Option<BitRefMut> {\n        if self.is_empty() {\n            return None\n        }\n        self.get_access_mut(self.len() - 1)\n    }\n\n    /// The maximum number of bits that can be pushed to a storage bit vector.\n    fn maximum_capacity(&self) -> u32 {\n        u32::MAX\n    }\n\n    /// Pushes the given value onto the bit vector.\n    ///\n    /// # Note\n    ///\n    /// This increases the length of the bit vector.\n    ///\n    /// # Panics\n    ///\n    /// If the storage bit vector reached its maximum capacity.\n    pub fn push(&mut self, value: bool) {\n        assert!(\n            self.len() < self.maximum_capacity(),\n            \"reached maximum capacity for storage bit vector\"\n        );\n        if self.len() as u64 == self.capacity() {\n            // Case: All 256-bits packs are full or there are none:\n            // Need to push another 256-bit pack to the storage vector.\n            let mut bits256 = Bits256::default();\n            if value {\n                // If `value` is `true` set its first bit to `1`.\n                bits256.set(0);\n                debug_assert_eq!(bits256.get(0), true);\n            };\n            self.bits.push(bits256);\n            *self.len += 1;\n        } else {\n            // Case: The last 256-bit pack has unused bits:\n            // - Set last bit of last 256-bit pack to the given value.\n            // - Opt.: Since bits are initialized as 0 we only need\n            //         to mutate this value if `value` is `true`.\n            *self.len += 1;\n            if value {\n                self.last_mut()\n                    .expect(\"must have at least a valid bit in this case\")\n                    .set()\n            }\n        }\n    }\n\n    /// Pops the last bit from the bit vector.\n    ///\n    /// Returns the popped bit as `bool`.\n    ///\n    /// # Note\n    ///\n    /// This reduces the length of the bit vector by one.\n    pub fn pop(&mut self) -> Option<bool> {\n        if self.is_empty() {\n            // Bail out early if the bit vector is emtpy.\n            return None\n        }\n        let mut access = self.last_mut().expect(\"must be some if non-empty\");\n        let popped = access.get();\n        access.reset();\n        *self.len -= 1;\n        Some(popped)\n    }\n}\n"],["981","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::{\n    super::extend_lifetime,\n    BitRefMut,\n    Bits64,\n    Index256,\n    Index64,\n};\n\n/// A chunk of 256 bits.\n#[derive(Debug, Copy, Clone, PartialEq, Eq, scale::Encode, scale::Decode)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\npub struct Bits256 {\n    bits: [Bits64; 4],\n}\n\nimpl Default for Bits256 {\n    fn default() -> Self {\n        Self {\n            bits: Default::default(),\n        }\n    }\n}\n\n/// Iterator over the valid bits of a pack of 256 bits.\n#[derive(Debug, Copy, Clone)]\npub struct Iter<'a> {\n    bits: &'a Bits256,\n    start: u16,\n    end: u16,\n}\n\nimpl<'a> Iter<'a> {\n    fn new(bits256: &'a Bits256, len: u16) -> Self {\n        Self {\n            bits: bits256,\n            start: 0,\n            end: len,\n        }\n    }\n\n    fn remaining(&self) -> u16 {\n        self.end - self.start\n    }\n}\n\nimpl<'a> ExactSizeIterator for Iter<'a> {}\n\nimpl<'a> Iterator for Iter<'a> {\n    type Item = bool;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        <Self as Iterator>::nth(self, 0)\n    }\n\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        assert!(n < 256);\n        let n = n as u16;\n        if self.start + n >= self.end {\n            return None\n        }\n        let start = self.start + n;\n        self.start += 1 + n;\n        Some(self.bits.get(start as u8))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let remaining = self.remaining() as usize;\n        (remaining, Some(remaining))\n    }\n\n    fn count(self) -> usize {\n        self.remaining() as usize\n    }\n}\n\nimpl<'a> DoubleEndedIterator for Iter<'a> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        <Self as DoubleEndedIterator>::nth_back(self, 0)\n    }\n\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n        assert!(n < 256);\n        let n = n as u16;\n        if self.start + n >= self.end {\n            return None\n        }\n        self.end -= 1 + n;\n        Some(self.bits.get(self.end as u8))\n    }\n}\n\n/// Iterator over the valid mutable bits of a pack of 256 bits.\n#[derive(Debug)]\npub struct IterMut<'a> {\n    bits: &'a mut Bits256,\n    start: u16,\n    end: u16,\n}\n\nimpl<'a> IterMut<'a> {\n    fn new(bits256: &'a mut Bits256, len: u16) -> Self {\n        Self {\n            bits: bits256,\n            start: 0,\n            end: len,\n        }\n    }\n\n    fn remaining(&self) -> u16 {\n        self.end - self.start\n    }\n\n    /// Returns a bit access for the given index with extended but valid lifetimes.\n    fn get<'b>(&'b mut self, index: u8) -> BitRefMut<'a> {\n        unsafe { BitRefMut::new(extend_lifetime(&mut self.bits), index) }\n    }\n}\n\nimpl<'a> ExactSizeIterator for IterMut<'a> {}\n\nimpl<'a> Iterator for IterMut<'a> {\n    type Item = BitRefMut<'a>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        <Self as Iterator>::nth(self, 0)\n    }\n\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        assert!(n < 256);\n        let n = n as u16;\n        if self.start + n >= self.end {\n            return None\n        }\n        let start = self.start + n;\n        self.start += 1 + n;\n        Some(self.get(start as u8))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let remaining = self.remaining() as usize;\n        (remaining, Some(remaining))\n    }\n\n    fn count(self) -> usize {\n        self.remaining() as usize\n    }\n}\n\nimpl<'a> DoubleEndedIterator for IterMut<'a> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        <Self as DoubleEndedIterator>::nth_back(self, 0)\n    }\n\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n        assert!(n < 256);\n        let n = n as u16;\n        if self.start + n >= self.end {\n            return None\n        }\n        self.end -= 1 + n;\n        Some(self.get(self.end as u8))\n    }\n}\n\nimpl Bits256 {\n    fn bits_at(&self, index: Index256) -> (&u64, Index64) {\n        (&self.bits[(index / 64) as usize], index % 64)\n    }\n\n    fn bits_at_mut(&mut self, index: Index256) -> (&mut u64, Index64) {\n        (&mut self.bits[(index / 64) as usize], index % 64)\n    }\n\n    /// Yields the first `len` bits of the pack of 256 bits.\n    pub(super) fn iter(&self, len: u16) -> Iter {\n        Iter::new(self, len)\n    }\n\n    /// Yields mutable accessors to the first `len` bits of the pack of 256 bits.\n    pub(super) fn iter_mut(&mut self, len: u16) -> IterMut {\n        IterMut::new(self, len)\n    }\n\n    /// Returns the bit value for the bit at the given index.\n    pub fn get(&self, at: Index256) -> bool {\n        let (bits64, pos64) = self.bits_at(at);\n        bits64 & (0x01 << (63 - pos64)) != 0\n    }\n\n    /// Sets the bit value for the bit at the given index to the given value.\n    pub(super) fn set_to(&mut self, at: Index256, new_value: bool) {\n        if new_value {\n            self.set(at)\n        } else {\n            self.reset(at)\n        }\n    }\n\n    /// Flips the bit value for the bit at the given index.\n    pub(super) fn flip(&mut self, at: Index256) {\n        self.xor(at, true)\n    }\n\n    /// Sets the bit value for the bit at the given index to 1 (`true`).\n    pub(super) fn set(&mut self, at: Index256) {\n        self.or(at, true)\n    }\n\n    /// Sets the bit value for the bit at the given index to 0 (`false`).\n    pub(super) fn reset(&mut self, at: Index256) {\n        self.and(at, false)\n    }\n\n    fn op_at_with<F>(&mut self, at: Index256, rhs: bool, op: F)\n    where\n        F: FnOnce(&mut Bits64, Bits64),\n    {\n        let (bits64, pos64) = self.bits_at_mut(at);\n        let rhs = (rhs as u64) << (63 - pos64);\n        op(bits64, rhs);\n    }\n\n    /// Computes bitwise AND for the bit at the given index and `rhs`.\n    pub(super) fn and(&mut self, at: Index256, rhs: bool) {\n        self.op_at_with(at, !rhs, |bits64, rhs| *bits64 &= !rhs)\n    }\n\n    /// Computes bitwise OR for the bit at the given index and `rhs`.\n    pub(super) fn or(&mut self, at: Index256, rhs: bool) {\n        self.op_at_with(at, rhs, |bits64, rhs| *bits64 |= rhs)\n    }\n\n    /// Computes bitwise XOR for the bit at the given index and `rhs`.\n    pub(super) fn xor(&mut self, at: Index256, rhs: bool) {\n        self.op_at_with(at, rhs, |bits64, rhs| *bits64 ^= rhs)\n    }\n\n    /// Returns the position of the first zero bit if any.\n    pub fn position_first_zero(&self) -> Option<u8> {\n        let mut offset: u32 = 0;\n        for bits64 in &self.bits {\n            if *bits64 != !0 {\n                return Some(((!bits64).leading_zeros() + offset) as u8)\n            }\n            offset += 64;\n        }\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Bits256;\n\n    #[test]\n    fn default_works() {\n        assert_eq!(\n            Bits256::default(),\n            Bits256 {\n                bits: [0x00, 0x00, 0x00, 0x00],\n            }\n        );\n    }\n\n    fn populated_bits256() -> Bits256 {\n        let mut bits256 = Bits256::default();\n        for i in 0..256 {\n            let i = i as u8;\n            bits256.set_to(i, (i % 5) == 0 || (i % 13) == 0);\n        }\n        bits256\n    }\n\n    #[test]\n    fn get_works() {\n        let bits256 = populated_bits256();\n        for i in 0..256 {\n            let i = i as u8;\n            assert_eq!(bits256.get(i), (i % 5) == 0 || (i % 13) == 0);\n        }\n    }\n\n    #[test]\n    fn set_works() {\n        let mut bits256 = populated_bits256();\n        for i in 0..256 {\n            let i = i as u8;\n            bits256.set(i);\n            assert_eq!(bits256.get(i), true);\n        }\n    }\n\n    #[test]\n    fn reset_works() {\n        let mut bits256 = populated_bits256();\n        for i in 0..256 {\n            let i = i as u8;\n            bits256.reset(i);\n            assert_eq!(bits256.get(i), false);\n        }\n    }\n\n    #[test]\n    fn and_works() {\n        let mut bits256 = populated_bits256();\n        for i in 0..256 {\n            let i = i as u8;\n            bits256.and(i, i % 2 == 0);\n            assert_eq!(\n                bits256.get(i),\n                (i % 2) == 0 && ((i % 5) == 0 || (i % 13) == 0)\n            );\n        }\n    }\n\n    #[test]\n    fn or_works() {\n        let mut bits256 = populated_bits256();\n        for i in 0..256 {\n            let i = i as u8;\n            bits256.or(i, i % 2 == 0);\n            assert_eq!(\n                bits256.get(i),\n                (i % 2) == 0 || (i % 5) == 0 || (i % 13) == 0\n            );\n        }\n    }\n\n    #[test]\n    fn xor_works() {\n        let mut bits256 = populated_bits256();\n        for i in 0..256 {\n            let i = i as u8;\n            bits256.xor(i, i % 2 == 0);\n            let a = (i % 2) == 0;\n            let b = (i % 5) == 0 || (i % 13) == 0;\n            assert_eq!(bits256.get(i), a != b);\n        }\n    }\n\n    #[test]\n    fn position_first_zero_works() {\n        // Zero bits256:\n        let empty = Bits256::default();\n        assert_eq!(empty.position_first_zero(), Some(0));\n        // First bit is set:\n        let first_bit_is_set = Bits256 {\n            bits: [0x8000_0000_0000_0000, 0x00, 0x00, 0x00],\n        };\n        assert_eq!(first_bit_is_set.position_first_zero(), Some(1));\n        // Last bit is unset:\n        let first_bit_is_set = Bits256 {\n            bits: [!0, !0, !0, !1],\n        };\n        assert_eq!(first_bit_is_set.position_first_zero(), Some(3 * 64 + 63));\n        // Some middle bit is unset:\n        let first_bit_is_set = Bits256 {\n            bits: [!0, !0, !0xFFFF_FFFF, !1],\n        };\n        assert_eq!(first_bit_is_set.position_first_zero(), Some(2 * 64 + 32));\n        // All bits set:\n        let all_bits_set = Bits256 {\n            bits: [!0, !0, !0, !0],\n        };\n        assert_eq!(all_bits_set.position_first_zero(), None);\n    }\n}\n"],["982","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#![allow(clippy::len_without_is_empty)]\n\nuse super::{\n    Bits256,\n    Index256,\n};\n\n/// A mutable bit access for operating on a single bit within a 256-bit pack.\n#[derive(Debug)]\npub struct BitRefMut<'a> {\n    /// The queried pack of 256 bits.\n    bits: &'a mut Bits256,\n    /// The bit position witihn the queried bit pack.\n    at: u8,\n}\n\nimpl<'a> PartialEq for BitRefMut<'a> {\n    fn eq(&self, other: &Self) -> bool {\n        self.get() == other.get()\n    }\n}\n\nimpl<'a> Eq for BitRefMut<'a> {}\n\nimpl<'a> BitRefMut<'a> {\n    /// Creates a new bit access for the indexed bit within the 256-bit pack.\n    pub(super) fn new(bits: &'a mut Bits256, at: Index256) -> Self {\n        Self { bits, at }\n    }\n\n    /// Returns the value of the indexed bit.\n    ///\n    /// # Note\n    ///\n    /// - If 0: returns `false`\n    /// - If 1: returns `true`\n    pub fn get(&self) -> bool {\n        self.bits.get(self.at)\n    }\n\n    /// Sets the value of the indexed bit to the given new value.\n    pub fn set_to(&mut self, new_value: bool) {\n        self.bits.set_to(self.at, new_value)\n    }\n\n    /// Sets the indexed bit to `1` (true).\n    pub fn set(&mut self) {\n        self.bits.set(self.at)\n    }\n\n    /// Resets the indexed bit to `0` (false).\n    pub fn reset(&mut self) {\n        self.bits.reset(self.at)\n    }\n\n    /// Flips the indexed bit.\n    pub fn flip(&mut self) {\n        self.bits.flip(self.at)\n    }\n\n    /// Computes bitwise XOR for the indexed bit and `rhs`.\n    pub fn xor(&mut self, rhs: bool) {\n        self.bits.xor(self.at, rhs)\n    }\n\n    /// Computes bitwise AND for the indexed bit and `rhs`.\n    pub fn and(&mut self, rhs: bool) {\n        self.bits.and(self.at, rhs)\n    }\n\n    /// Computes bitwise OR for the indexed bit and `rhs`.\n    pub fn or(&mut self, rhs: bool) {\n        self.bits.or(self.at, rhs)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::BitRefMut;\n    use crate::collections::bitvec::Bits256;\n\n    fn is_populated_bit_set(index: u8) -> bool {\n        (index % 5) == 0 || (index % 13) == 0\n    }\n\n    fn populated_bits256() -> Bits256 {\n        let mut bits256 = Bits256::default();\n        for i in 0..256 {\n            let i = i as u8;\n            bits256.set_to(i, is_populated_bit_set(i));\n        }\n        bits256\n    }\n\n    #[test]\n    fn get_set_works() {\n        let mut bits256 = populated_bits256();\n        for i in 0..=255 {\n            let mut bitref = BitRefMut::new(&mut bits256, i);\n            let expected = is_populated_bit_set(i);\n            assert_eq!(bitref.get(), expected);\n            // Set only every second bit to true and check this later:\n            bitref.set_to(i % 2 == 0);\n        }\n        // Check if `set_to` was successful:\n        for i in 0..=255 {\n            assert_eq!(bits256.get(i), i % 2 == 0);\n        }\n    }\n\n    #[test]\n    fn flip_works() {\n        let mut bits256 = populated_bits256();\n        for i in 0..=255 {\n            let mut bitref = BitRefMut::new(&mut bits256, i);\n            bitref.flip();\n        }\n        // Check if `flip` was successful:\n        for i in 0..=255 {\n            assert_eq!(bits256.get(i), !is_populated_bit_set(i));\n        }\n    }\n\n    #[test]\n    fn set_and_reset_works() {\n        let mut bits256 = populated_bits256();\n        for i in 0..=255 {\n            let mut bitref = BitRefMut::new(&mut bits256, i);\n            if i % 2 == 0 {\n                bitref.set();\n            } else {\n                bitref.reset();\n            }\n        }\n        // Check if `set` and `reset` was successful:\n        for i in 0..=255 {\n            assert_eq!(bits256.get(i), i % 2 == 0);\n        }\n    }\n\n    #[test]\n    fn bitops_works() {\n        let mut bits256 = populated_bits256();\n        for i in 0..=255 {\n            let mut bitref = BitRefMut::new(&mut bits256, i);\n            let expected = is_populated_bit_set(i);\n            fn test_xor(bitref: &mut BitRefMut, expected: bool) {\n                fn test_xor_for(bitref: &mut BitRefMut, expected: bool, input: bool) {\n                    assert_eq!(bitref.get(), expected);\n                    bitref.xor(input);\n                    assert_eq!(bitref.get(), expected ^ input);\n                    bitref.set_to(expected);\n                }\n                test_xor_for(bitref, expected, false);\n                test_xor_for(bitref, expected, true);\n            }\n            test_xor(&mut bitref, expected);\n            fn test_and(bitref: &mut BitRefMut, expected: bool) {\n                fn test_and_for(bitref: &mut BitRefMut, expected: bool, input: bool) {\n                    assert_eq!(bitref.get(), expected);\n                    bitref.and(input);\n                    assert_eq!(bitref.get(), expected & input);\n                    bitref.set_to(expected);\n                }\n                test_and_for(bitref, expected, false);\n                test_and_for(bitref, expected, true);\n            }\n            test_and(&mut bitref, expected);\n            fn test_or(bitref: &mut BitRefMut, expected: bool) {\n                fn test_or_for(bitref: &mut BitRefMut, expected: bool, input: bool) {\n                    assert_eq!(bitref.get(), expected);\n                    bitref.or(input);\n                    assert_eq!(bitref.get(), expected | input);\n                    bitref.set_to(expected);\n                }\n                test_or_for(bitref, expected, false);\n                test_or_for(bitref, expected, true);\n            }\n            test_or(&mut bitref, expected);\n        }\n    }\n}\n"],["983","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::Bitvec as StorageBitvec;\nuse crate::traits::{\n    KeyPtr,\n    SpreadLayout,\n};\nuse ink_primitives::Key;\n\n#[test]\nfn new_default_works() {\n    // Check if `Bitvec::new` works:\n    let mut bitvec = StorageBitvec::new();\n    assert_eq!(bitvec.len(), 0);\n    assert_eq!(bitvec.capacity(), 0);\n    assert!(bitvec.is_empty());\n    assert_eq!(bitvec.bits().next(), None);\n    assert_eq!(bitvec.get(0), None);\n    assert!(bitvec.first().is_none());\n    assert!(bitvec.first_mut().is_none());\n    assert!(bitvec.last().is_none());\n    assert!(bitvec.last_mut().is_none());\n    // Check if `Bitvec::default` works:\n    let mut default = StorageBitvec::default();\n    assert_eq!(default.len(), 0);\n    assert_eq!(bitvec.capacity(), 0);\n    assert!(default.is_empty());\n    assert_eq!(default.bits().next(), None);\n    assert_eq!(default.get(0), None);\n    assert!(default.first().is_none());\n    assert!(default.first_mut().is_none());\n    assert!(default.last().is_none());\n    assert!(default.last_mut().is_none());\n    // Check if both are equal:\n    assert_eq!(bitvec, default);\n}\n\n/// Creates a storage bitvector where every bit at every 5th and 13th index\n/// is set to `1` (true). The bitvector has a total length of 600 bits which\n/// requires it to have 3 chunks of 256-bit giving a capacity of 768 bits.\nfn bitvec_600() -> StorageBitvec {\n    let bitvec = (0..600)\n        .map(|i| (i % 5) == 0 || (i % 13) == 0)\n        .collect::<StorageBitvec>();\n    assert_eq!(bitvec.len(), 600);\n    assert_eq!(bitvec.capacity(), 768);\n    bitvec\n}\n\n#[test]\nfn get_works() {\n    let mut bitvec = bitvec_600();\n    for i in 0..bitvec.len() {\n        assert_eq!(bitvec.get(i), Some((i % 5) == 0 || (i % 13) == 0));\n        assert_eq!(\n            bitvec.get_mut(i).map(|b| b.get()),\n            Some((i % 5) == 0 || (i % 13) == 0)\n        );\n    }\n}\n\n#[test]\nfn iter_next_works() {\n    let bitvec = bitvec_600();\n    // Test iterator over read-only bits.\n    for (i, bit) in bitvec.bits().enumerate() {\n        assert_eq!(bit, (i % 5) == 0 || (i % 13) == 0);\n    }\n    // Test iterator over mutable accessors to bits.\n    let mut bitvec = bitvec;\n    for (i, accessor) in bitvec.bits_mut().enumerate() {\n        assert_eq!(accessor.get(), (i % 5) == 0 || (i % 13) == 0);\n    }\n}\n\n#[test]\nfn iter_next_back_works() {\n    let bitvec = bitvec_600();\n    // Test iterator over read-only bits.\n    for (i, bit) in bitvec.bits().enumerate().rev() {\n        assert_eq!(bit, (i % 5) == 0 || (i % 13) == 0);\n    }\n    // Test iterator over mutable accessors to bits.\n    let mut bitvec = bitvec;\n    for (i, accessor) in bitvec.bits_mut().enumerate().rev() {\n        assert_eq!(accessor.get(), (i % 5) == 0 || (i % 13) == 0);\n    }\n}\n\n#[test]\nfn double_ended_iter_works() {\n    let mut bitvec = StorageBitvec::default();\n    bitvec.push(true);\n    bitvec.push(true);\n    bitvec.push(true);\n\n    let mut iter = bitvec.bits();\n    assert_eq!(Some(true), iter.next());\n    assert_eq!(Some(true), iter.next_back());\n    assert_eq!(Some(true), iter.next());\n    assert_eq!(None, iter.next());\n    assert_eq!(None, iter.next_back());\n}\n\n#[test]\nfn push_works() {\n    let mut bitvec = StorageBitvec::new();\n    assert_eq!(bitvec.len(), 0);\n    assert_eq!(bitvec.capacity(), 0);\n    // Push `1`\n    bitvec.push(true);\n    assert_eq!(bitvec.len(), 1);\n    assert_eq!(bitvec.capacity(), 256);\n    assert_eq!(bitvec.first(), Some(true));\n    assert_eq!(bitvec.first_mut().map(|access| access.get()), Some(true));\n    assert_eq!(bitvec.last(), Some(true));\n    assert_eq!(bitvec.last_mut().map(|access| access.get()), Some(true));\n    // Push `0`\n    bitvec.push(false);\n    assert_eq!(bitvec.len(), 2);\n    assert_eq!(bitvec.capacity(), 256);\n    assert_eq!(bitvec.first(), Some(true));\n    assert_eq!(bitvec.first_mut().map(|access| access.get()), Some(true));\n    assert_eq!(bitvec.last(), Some(false));\n    assert_eq!(bitvec.last_mut().map(|access| access.get()), Some(false));\n    // Push `1`\n    bitvec.push(true);\n    assert_eq!(bitvec.len(), 3);\n    assert_eq!(bitvec.capacity(), 256);\n    assert_eq!(bitvec.first(), Some(true));\n    assert_eq!(bitvec.first_mut().map(|access| access.get()), Some(true));\n    assert_eq!(bitvec.last(), Some(true));\n    assert_eq!(bitvec.last_mut().map(|access| access.get()), Some(true));\n}\n\n#[test]\nfn pop_works() {\n    let mut bitvec = [true, false, true].iter().collect::<StorageBitvec>();\n    assert_eq!(bitvec.len(), 3);\n    assert_eq!(bitvec.capacity(), 256);\n    // Pop `1` (true)\n    assert_eq!(bitvec.pop(), Some(true));\n    assert_eq!(bitvec.len(), 2);\n    assert_eq!(bitvec.capacity(), 256);\n    assert_eq!(bitvec.first(), Some(true));\n    assert_eq!(bitvec.first_mut().map(|access| access.get()), Some(true));\n    assert_eq!(bitvec.last(), Some(false));\n    assert_eq!(bitvec.last_mut().map(|access| access.get()), Some(false));\n    // Pop `0` (false)\n    assert_eq!(bitvec.pop(), Some(false));\n    assert_eq!(bitvec.len(), 1);\n    assert_eq!(bitvec.capacity(), 256);\n    assert_eq!(bitvec.first(), Some(true));\n    assert_eq!(bitvec.first_mut().map(|access| access.get()), Some(true));\n    assert_eq!(bitvec.last(), Some(true));\n    assert_eq!(bitvec.last_mut().map(|access| access.get()), Some(true));\n    // Pop `1` (true)\n    assert_eq!(bitvec.pop(), Some(true));\n    assert_eq!(bitvec.len(), 0);\n    assert_eq!(bitvec.capacity(), 256);\n    assert!(bitvec.first().is_none());\n    assert!(bitvec.first_mut().is_none());\n    assert!(bitvec.last().is_none());\n    assert!(bitvec.last_mut().is_none());\n}\n\n#[test]\nfn spread_layout_push_pull_works() -> ink_env::Result<()> {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let bv1 = bitvec_600();\n        let root_key = Key::from([0x42; 32]);\n        SpreadLayout::push_spread(&bv1, &mut KeyPtr::from(root_key));\n        // Load the pushed storage vector into another instance and check that\n        // both instances are equal:\n        let bv2 =\n            <StorageBitvec as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n        assert_eq!(bv1, bv2);\n        Ok(())\n    })\n}\n\n#[test]\n#[should_panic(expected = \"encountered empty storage cell\")]\nfn spread_layout_clear_works() {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let bv1 = bitvec_600();\n        let root_key = Key::from([0x42; 32]);\n        SpreadLayout::push_spread(&bv1, &mut KeyPtr::from(root_key));\n        // It has already been asserted that a valid instance can be pulled\n        // from contract storage after a push to the same storage region.\n        //\n        // Now clear the associated storage from `bv1` and check whether\n        // loading another instance from this storage will panic since the\n        // vector's length property cannot read a value:\n        SpreadLayout::clear_spread(&bv1, &mut KeyPtr::from(root_key));\n        let _ = <StorageBitvec as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n        Ok(())\n    })\n    .unwrap()\n}\n"],["984","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#![allow(clippy::len_without_is_empty)]\n\nuse super::{\n    BitRefMut,\n    Bits256,\n    Bits256BitsIter,\n    Bits256BitsIterMut,\n};\n\n/// A reference to a subslice within a 256-bit chunk.\n///\n/// This is a reference wrapper around either a shared 256-bit chunk\n/// or an exclusive 256-bit chunk. Also it prevents accesses to out of bounds\n/// bits.\n#[derive(Debug, Copy, Clone)]\n#[repr(C)] // This is repr(C) to be on the safe side for the Deref impl.\npub struct ChunkRef<T> {\n    /// The reference to the 256-bits chunk.\n    bits: T,\n    /// The length of the accessible chunk area.\n    len: u32,\n}\n\nimpl<T> ChunkRef<T> {\n    /// Returns the length of the 256-bit chunk.\n    ///\n    /// # Note\n    ///\n    /// This is the number of valid bits in the chunk of 256 bits.\n    /// The valid bits are consecutive and always start from index 0.\n    pub fn len(&self) -> u32 {\n        self.len\n    }\n}\n\nimpl<'a> ChunkRef<&'a Bits256> {\n    /// Creates a new shared 256-bit chunk access with the given length.\n    pub(super) fn shared(bits: &'a Bits256, len: u32) -> Self {\n        Self { bits, len }\n    }\n\n    /// Returns the position of the first valid zero bit if any.\n    pub fn position_first_zero(&self) -> Option<u8> {\n        let position = self.bits.position_first_zero()?;\n        if position as u32 >= self.len() {\n            return None\n        }\n        Some(position)\n    }\n\n    /// Returns the value of the indexed bit.\n    ///\n    /// # Note\n    ///\n    /// - If 0: returns `false`\n    /// - If 1: returns `true`\n    pub fn get(&self, index: u8) -> Option<bool> {\n        if index as u32 >= self.len {\n            return None\n        }\n        self.bits.get(index).into()\n    }\n\n    /// Returns an iterator over the valid bits of `self`.\n    pub(super) fn iter(&self) -> Bits256BitsIter {\n        self.bits.iter(self.len as u16)\n    }\n}\n\nimpl<'a> ChunkRef<&'a mut Bits256> {\n    /// Creates a new exclusive 256-bit chunk access with the given length.\n    pub(super) fn exclusive(bits: &'a mut Bits256, len: u32) -> Self {\n        Self { bits, len }\n    }\n\n    /// Returns mutable access to a single bit if the index is out of bounds.\n    pub fn get_mut(&mut self, index: u8) -> Option<BitRefMut> {\n        if index as u32 >= self.len {\n            return None\n        }\n        BitRefMut::new(self.bits, index).into()\n    }\n\n    /// Returns an iterator over mutable accessors to the valid bits of `self`.\n    pub(super) fn iter_mut(&mut self) -> Bits256BitsIterMut {\n        self.bits.iter_mut(self.len as u16)\n    }\n}\n\nimpl<'a> core::ops::Deref for ChunkRef<&'a mut Bits256> {\n    type Target = ChunkRef<&'a Bits256>;\n\n    fn deref(&self) -> &Self::Target {\n        // This implementation allows to mirror the interface on\n        // `ChunkRef<&'a Bits256>` onto `ChunkRef<&'a mut Bits256>`\n        // without the need of separate implementations.\n        //\n        // SAFETY: The `ChunkRef` struct is `repr(C)` which should guarantee\n        //         that both `ChunkRef<&'a mut Bits256>` as well as\n        //         `ChunkRef<&'a Bits256>` have the same internal layout\n        //         and thus can be transmuted safely.\n        let ptr: *const Self = self;\n        unsafe { &*(ptr as *const Self::Target) }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{\n        Bits256,\n        ChunkRef,\n    };\n\n    fn is_populated_bit_set(index: u8) -> bool {\n        (index % 5) == 0 || (index % 13) == 0\n    }\n\n    fn populated_bits256() -> Bits256 {\n        let mut bits256 = Bits256::default();\n        for i in 0..256 {\n            let i = i as u8;\n            bits256.set_to(i, is_populated_bit_set(i));\n        }\n        bits256\n    }\n\n    #[test]\n    fn shared_works() {\n        let len: u8 = 100;\n        let bits = populated_bits256();\n        let cref = ChunkRef::shared(&bits, len as u32);\n        assert_eq!(cref.len(), len as u32);\n        // Get works:\n        for i in 0..len {\n            assert_eq!(cref.get(i), Some(is_populated_bit_set(i)));\n        }\n        assert_eq!(cref.get(len), None);\n        // Iter works:\n        for (i, val) in cref.iter().enumerate() {\n            assert_eq!(val, is_populated_bit_set(i as u8));\n        }\n    }\n\n    #[test]\n    fn exclusive_works() {\n        let len: u8 = 100;\n        let mut bits = populated_bits256();\n        let mut cref = ChunkRef::exclusive(&mut bits, len as u32);\n        assert_eq!(cref.len(), len as u32);\n        // `get` and `get_mut` works:\n        for i in 0..len {\n            assert_eq!(cref.get(i), Some(is_populated_bit_set(i)));\n            assert_eq!(\n                cref.get_mut(i).map(|br| br.get()),\n                Some(is_populated_bit_set(i))\n            );\n        }\n        assert_eq!(cref.get(len), None);\n        assert_eq!(cref.get_mut(len), None);\n        // `iter` works:\n        for (i, val) in cref.iter().enumerate() {\n            assert_eq!(val, is_populated_bit_set(i as u8));\n        }\n    }\n\n    #[test]\n    fn position_first_zero_works() {\n        let len = 256;\n        let mut zeros = Default::default();\n        let mut cref = ChunkRef::exclusive(&mut zeros, len);\n        for i in 0..len {\n            assert_eq!(cref.position_first_zero(), Some(i as u8));\n            cref.get_mut(i as u8).unwrap().set();\n        }\n        // Now all bits are set to `1`:\n        assert_eq!(cref.position_first_zero(), None);\n    }\n\n    #[test]\n    fn iter_mut_works() {\n        let len = 100;\n        let mut zeros = Default::default();\n        let mut cref = ChunkRef::exclusive(&mut zeros, len);\n        // Initialize all bits with 0 and set them to 1 via `iter_mut`.\n        // Then check if they are 1:\n        for mut byte in cref.iter_mut() {\n            assert!(!byte.get());\n            byte.set();\n        }\n        assert!(cref.iter().all(|byte| byte));\n    }\n}\n"],["985","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::{\n    super::extend_lifetime,\n    BitRefMut,\n    Bits256,\n    Bits256BitsIter,\n    Bits256BitsIterMut,\n    Bitvec as StorageBitvec,\n    ChunkRef,\n};\nuse crate::collections::vec::{\n    Iter as StorageVecIter,\n    IterMut as StorageVecIterMut,\n};\nuse core::cmp::min;\n\n/// Iterator over the bits of a storage bit vector.\n#[derive(Debug, Copy, Clone)]\npub struct BitsIter<'a> {\n    remaining: u32,\n    bits256_iter: Bits256Iter<'a>,\n    front_iter: Option<Bits256BitsIter<'a>>,\n    back_iter: Option<Bits256BitsIter<'a>>,\n}\n\nimpl<'a> BitsIter<'a> {\n    /// Creates a new iterator yielding the bits of the storage bit vector.\n    pub(super) fn new(bitvec: &'a StorageBitvec) -> Self {\n        Self {\n            remaining: bitvec.len(),\n            bits256_iter: bitvec.iter_chunks(),\n            front_iter: None,\n            back_iter: None,\n        }\n    }\n}\n\nimpl<'a> ExactSizeIterator for BitsIter<'a> {}\n\nimpl<'a> Iterator for BitsIter<'a> {\n    type Item = bool;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            if let Some(ref mut front_iter) = self.front_iter {\n                if let front @ Some(_) = front_iter.next() {\n                    self.remaining -= 1;\n                    return front\n                }\n            }\n            match self.bits256_iter.next() {\n                None => {\n                    if let Some(back) = self.back_iter.as_mut()?.next() {\n                        self.remaining -= 1;\n                        return Some(back)\n                    }\n                    return None\n                }\n                Some(ref mut front) => {\n                    self.front_iter = Some(unsafe { extend_lifetime(front) }.iter());\n                }\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let remaining = self.remaining as usize;\n        (remaining, Some(remaining))\n    }\n\n    fn count(self) -> usize {\n        self.remaining as usize\n    }\n}\n\nimpl<'a> DoubleEndedIterator for BitsIter<'a> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        loop {\n            if let Some(ref mut back_iter) = self.back_iter {\n                if let back @ Some(_) = back_iter.next_back() {\n                    self.remaining -= 1;\n                    return back\n                }\n            }\n            match self.bits256_iter.next_back() {\n                None => {\n                    if let Some(front) = self.front_iter.as_mut()?.next_back() {\n                        self.remaining -= 1;\n                        return Some(front)\n                    }\n                    return None\n                }\n                Some(ref mut back) => {\n                    self.back_iter = Some(unsafe { extend_lifetime(back) }.iter());\n                }\n            }\n        }\n    }\n}\n\n/// Iterator over the bits of a storage bit vector.\n#[derive(Debug)]\npub struct BitsIterMut<'a> {\n    remaining: u32,\n    bits256_iter: Bits256IterMut<'a>,\n    front_iter: Option<Bits256BitsIterMut<'a>>,\n    back_iter: Option<Bits256BitsIterMut<'a>>,\n}\n\nimpl<'a> BitsIterMut<'a> {\n    /// Creates a new iterator yielding the bits of the storage bit vector.\n    pub(super) fn new(bitvec: &'a mut StorageBitvec) -> Self {\n        Self {\n            remaining: bitvec.len(),\n            bits256_iter: bitvec.iter_chunks_mut(),\n            front_iter: None,\n            back_iter: None,\n        }\n    }\n}\n\nimpl<'a> ExactSizeIterator for BitsIterMut<'a> {}\n\nimpl<'a> Iterator for BitsIterMut<'a> {\n    type Item = BitRefMut<'a>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            if let Some(ref mut front_iter) = self.front_iter {\n                if let front @ Some(_) = front_iter.next() {\n                    self.remaining -= 1;\n                    return front\n                }\n            }\n            match self.bits256_iter.next() {\n                None => {\n                    if let Some(back) = self.back_iter.as_mut()?.next() {\n                        self.remaining -= 1;\n                        return Some(back)\n                    }\n                    return None\n                }\n                Some(ref mut front) => {\n                    self.front_iter = Some(unsafe { extend_lifetime(front) }.iter_mut());\n                }\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let remaining = self.remaining as usize;\n        (remaining, Some(remaining))\n    }\n\n    fn count(self) -> usize {\n        self.remaining as usize\n    }\n}\n\nimpl<'a> DoubleEndedIterator for BitsIterMut<'a> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        loop {\n            if let Some(ref mut back_iter) = self.back_iter {\n                if let back @ Some(_) = back_iter.next_back() {\n                    self.remaining -= 1;\n                    return back\n                }\n            }\n            match self.bits256_iter.next_back() {\n                None => {\n                    if let Some(front) = self.front_iter.as_mut()?.next_back() {\n                        self.remaining -= 1;\n                        return Some(front)\n                    }\n                    return None\n                }\n                Some(ref mut back) => {\n                    self.back_iter = Some(unsafe { extend_lifetime(back) }.iter_mut());\n                }\n            }\n        }\n    }\n}\n\n/// Iterator over the 256-bit chunks of a storage bitvector.\n#[derive(Debug, Copy, Clone)]\npub struct Bits256Iter<'a> {\n    /// The storage vector iterator over the internal 256-bit chunks.\n    iter: StorageVecIter<'a, Bits256>,\n    /// The remaining bits to be yielded.\n    remaining: u32,\n}\n\nimpl<'a> Bits256Iter<'a> {\n    /// Creates a new 256-bit chunks iterator over the given storage bitvector.\n    pub(super) fn new(bitvec: &'a StorageBitvec) -> Self {\n        Self {\n            iter: bitvec.bits.iter(),\n            remaining: bitvec.len(),\n        }\n    }\n}\n\nimpl<'a> Iterator for Bits256Iter<'a> {\n    type Item = ChunkRef<&'a Bits256>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.remaining == 0 {\n            return None\n        }\n        let len = min(256, self.remaining);\n        self.remaining = self.remaining.saturating_sub(256);\n        self.iter\n            .next()\n            .map(|bits256| ChunkRef::shared(bits256, len))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn count(self) -> usize {\n        self.iter.count()\n    }\n}\n\nimpl<'a> DoubleEndedIterator for Bits256Iter<'a> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if self.remaining == 0 {\n            return None\n        }\n        let mut len = self.remaining % 256;\n        if len == 0 {\n            len = 256;\n        }\n        self.remaining = self.remaining.saturating_sub(len);\n        self.iter\n            .next_back()\n            .map(|bits256| ChunkRef::shared(bits256, len))\n    }\n}\n\nimpl<'a> ExactSizeIterator for Bits256Iter<'a> {}\n\n/// Iterator over mutable 256-bit chunks of a storage bitvector.\n#[derive(Debug)]\npub struct Bits256IterMut<'a> {\n    /// The storage vector iterator over the internal mutable 256-bit chunks.\n    iter: StorageVecIterMut<'a, Bits256>,\n    /// The remaining bits to be yielded.\n    remaining: u32,\n}\n\nimpl<'a> Bits256IterMut<'a> {\n    /// Creates a new 256-bit chunks iterator over the given storage bitvector.\n    pub(super) fn new(bitvec: &'a mut StorageBitvec) -> Self {\n        Self {\n            remaining: bitvec.len(),\n            iter: bitvec.bits.iter_mut(),\n        }\n    }\n}\n\nimpl<'a> Iterator for Bits256IterMut<'a> {\n    type Item = ChunkRef<&'a mut Bits256>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let len = min(256, self.remaining);\n        self.remaining = self.remaining.saturating_sub(256);\n        self.iter\n            .next()\n            .map(|bits256| ChunkRef::exclusive(bits256, len))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn count(self) -> usize {\n        self.iter.count()\n    }\n}\n\nimpl<'a> DoubleEndedIterator for Bits256IterMut<'a> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        let mut len = self.remaining % 256;\n        self.remaining -= len;\n        if len == 0 {\n            len = 256;\n        }\n        self.iter\n            .next_back()\n            .map(|bits256| ChunkRef::exclusive(bits256, len))\n    }\n}\n\nimpl<'a> ExactSizeIterator for Bits256IterMut<'a> {}\n"],["986","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::{\n    BitsIter,\n    Bitvec as StorageBitvec,\n};\nuse core::iter::FromIterator;\n\nimpl Default for StorageBitvec {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl PartialEq for StorageBitvec {\n    fn eq(&self, other: &Self) -> bool {\n        if self.len() != other.len() {\n            return false\n        }\n        self.bits.eq(&other.bits)\n    }\n}\n\nimpl Eq for StorageBitvec {}\n\nimpl Extend<bool> for StorageBitvec {\n    fn extend<T: IntoIterator<Item = bool>>(&mut self, iter: T) {\n        for value in iter {\n            self.push(value)\n        }\n    }\n}\n\nimpl<'a> Extend<&'a bool> for StorageBitvec {\n    fn extend<T: IntoIterator<Item = &'a bool>>(&mut self, iter: T) {\n        for value in iter {\n            self.push(*value)\n        }\n    }\n}\n\nimpl FromIterator<bool> for StorageBitvec {\n    fn from_iter<T: IntoIterator<Item = bool>>(iter: T) -> Self {\n        let mut bitvec = Self::default();\n        bitvec.extend(iter);\n        bitvec\n    }\n}\n\nimpl<'a> FromIterator<&'a bool> for StorageBitvec {\n    fn from_iter<T: IntoIterator<Item = &'a bool>>(iter: T) -> Self {\n        <Self as FromIterator<bool>>::from_iter(iter.into_iter().copied())\n    }\n}\n\nimpl<'a> IntoIterator for &'a StorageBitvec {\n    type Item = bool;\n    type IntoIter = BitsIter<'a>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.bits()\n    }\n}\n"],["987","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::{\n    collections::extend_lifetime,\n    traits::PackedLayout,\n    Vec as StorageVec,\n};\n\n/// An iterator over shared references to the elements of a storage vector.\n#[derive(Debug, Clone, Copy)]\npub struct Iter<'a, T>\nwhere\n    T: PackedLayout,\n{\n    /// The storage vector to iterate over.\n    vec: &'a StorageVec<T>,\n    /// The current begin of the iteration.\n    begin: u32,\n    /// The current end of the iteration.\n    end: u32,\n}\n\nimpl<'a, T> Iter<'a, T>\nwhere\n    T: PackedLayout,\n{\n    /// Creates a new iterator for the given storage vector.\n    pub(crate) fn new(vec: &'a StorageVec<T>) -> Self {\n        Self {\n            vec,\n            begin: 0,\n            end: vec.len(),\n        }\n    }\n\n    /// Returns the amount of remaining elements to yield by the iterator.\n    fn remaining(&self) -> u32 {\n        self.end - self.begin\n    }\n}\n\nimpl<'a, T> Iterator for Iter<'a, T>\nwhere\n    T: PackedLayout,\n{\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        <Self as Iterator>::nth(self, 0)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let remaining = self.remaining() as usize;\n        (remaining, Some(remaining))\n    }\n\n    fn count(self) -> usize {\n        self.remaining() as usize\n    }\n\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        debug_assert!(self.begin <= self.end);\n        let n = n as u32;\n        if self.begin + n >= self.end {\n            return None\n        }\n        let cur = self.begin + n;\n        self.begin += 1 + n;\n        self.vec.get(cur).expect(\"access is within bounds\").into()\n    }\n}\n\nimpl<'a, T> ExactSizeIterator for Iter<'a, T> where T: PackedLayout {}\n\nimpl<'a, T> DoubleEndedIterator for Iter<'a, T>\nwhere\n    T: PackedLayout,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        <Self as DoubleEndedIterator>::nth_back(self, 0)\n    }\n\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n        debug_assert!(self.begin <= self.end);\n        let n = n as u32;\n        if self.begin >= self.end.saturating_sub(n) {\n            return None\n        }\n        self.end -= 1 + n;\n        self.vec\n            .get(self.end)\n            .expect(\"access is within bounds\")\n            .into()\n    }\n}\n\n/// An iterator over exclusive references to the elements of a storage vector.\n#[derive(Debug)]\npub struct IterMut<'a, T>\nwhere\n    T: PackedLayout,\n{\n    /// The storage vector to iterate over.\n    vec: &'a mut StorageVec<T>,\n    /// The current begin of the iteration.\n    begin: u32,\n    /// The current end of the iteration.\n    end: u32,\n}\n\nimpl<'a, T> IterMut<'a, T>\nwhere\n    T: PackedLayout,\n{\n    /// Creates a new iterator for the given storage vector.\n    pub(crate) fn new(vec: &'a mut StorageVec<T>) -> Self {\n        let len = vec.len();\n        Self {\n            vec,\n            begin: 0,\n            end: len,\n        }\n    }\n\n    /// Returns the amount of remaining elements to yield by the iterator.\n    fn remaining(&self) -> u32 {\n        self.end - self.begin\n    }\n}\n\nimpl<'a, T> IterMut<'a, T>\nwhere\n    T: PackedLayout,\n{\n    fn get_mut<'b>(&'b mut self, at: u32) -> Option<&'a mut T> {\n        self.vec.get_mut(at).map(|value| {\n            // SAFETY: We extend the lifetime of the reference here.\n            //\n            //         This is safe because the iterator yields an exclusive\n            //         reference to every element in the iterated vector\n            //         just once and also there can be only one such iterator\n            //         for the same vector at the same time which is\n            //         guaranteed by the constructor of the iterator.\n            unsafe { extend_lifetime::<'b, 'a, T>(value) }\n        })\n    }\n}\n\nimpl<'a, T> Iterator for IterMut<'a, T>\nwhere\n    T: PackedLayout,\n{\n    type Item = &'a mut T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        <Self as Iterator>::nth(self, 0)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let remaining = self.remaining() as usize;\n        (remaining, Some(remaining))\n    }\n\n    fn count(self) -> usize {\n        self.remaining() as usize\n    }\n\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        debug_assert!(self.begin <= self.end);\n        let n = n as u32;\n        if self.begin + n >= self.end {\n            return None\n        }\n        let cur = self.begin + n;\n        self.begin += 1 + n;\n        self.get_mut(cur).expect(\"access is within bounds\").into()\n    }\n}\n\nimpl<'a, T> ExactSizeIterator for IterMut<'a, T> where T: PackedLayout {}\n\nimpl<'a, T> DoubleEndedIterator for IterMut<'a, T>\nwhere\n    T: PackedLayout,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        <Self as DoubleEndedIterator>::nth_back(self, 0)\n    }\n\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n        debug_assert!(self.begin <= self.end);\n        let n = n as u32;\n        if self.begin >= self.end.saturating_sub(n) {\n            return None\n        }\n        self.end -= 1 + n;\n        self.get_mut(self.end)\n            .expect(\"access is within bounds\")\n            .into()\n    }\n}\n"],["988","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Implementation of ink! storage traits.\n\nuse super::Vec as StorageVec;\nuse crate::{\n    lazy::LazyIndexMap,\n    traits::{\n        KeyPtr,\n        PackedLayout,\n        SpreadLayout,\n    },\n};\n\n#[cfg(feature = \"std\")]\nconst _: () = {\n    use crate::{\n        lazy::Lazy,\n        traits::StorageLayout,\n    };\n    use ink_metadata::layout::{\n        FieldLayout,\n        Layout,\n        StructLayout,\n    };\n    use scale_info::TypeInfo;\n\n    impl<T> StorageLayout for StorageVec<T>\n    where\n        T: PackedLayout + TypeInfo + 'static,\n    {\n        fn layout(key_ptr: &mut KeyPtr) -> Layout {\n            Layout::Struct(StructLayout::new(vec![\n                FieldLayout::new(\"len\", <Lazy<u32> as StorageLayout>::layout(key_ptr)),\n                FieldLayout::new(\n                    \"elems\",\n                    <LazyIndexMap<T> as StorageLayout>::layout(key_ptr),\n                ),\n            ]))\n        }\n    }\n};\n\nimpl<T> SpreadLayout for StorageVec<T>\nwhere\n    T: PackedLayout,\n{\n    const FOOTPRINT: u64 = 1 + <LazyIndexMap<T> as SpreadLayout>::FOOTPRINT;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        Self {\n            len: SpreadLayout::pull_spread(ptr),\n            elems: SpreadLayout::pull_spread(ptr),\n        }\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        SpreadLayout::push_spread(&self.len, ptr);\n        SpreadLayout::push_spread(&self.elems, ptr);\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        self.clear_cells();\n        SpreadLayout::clear_spread(&self.len, ptr);\n        SpreadLayout::clear_spread(&self.elems, ptr);\n    }\n}\n"],["989","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! A storage vector used to store elements in a contiguous sequenced order.\n//!\n//! This is by default the go-to collection for most smart contracts if there\n//! are not special requirements to the storage data structure.\n\nmod impls;\nmod iter;\nmod storage;\n\n#[cfg(test)]\nmod tests;\n\n#[cfg(all(test, feature = \"ink-fuzz-tests\"))]\nmod fuzz_tests;\n\npub use self::iter::{\n    Iter,\n    IterMut,\n};\nuse crate::{\n    lazy::{\n        Lazy,\n        LazyIndexMap,\n    },\n    traits::PackedLayout,\n};\n\n/// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n///\n/// # Note\n///\n/// Despite the similarity to Rust's `Vec` type this storage `Vec` has many\n/// differences in its internal data layout. While it stores its data in contiguous\n/// storage slots this does not mean that the data is actually densely stored\n/// in memory.\n///\n/// Also its technical performance characteristics may be different from Rust's\n/// `Vec` due to the differences stated above.\n///\n/// Allows to store up to `2^32` elements and is guaranteed to not reallocate\n/// upon pushing new elements to it.\n#[derive(Debug)]\npub struct Vec<T>\nwhere\n    T: PackedLayout,\n{\n    /// The length of the vector.\n    len: Lazy<u32>,\n    /// The synchronized cells to operate on the contract storage.\n    elems: LazyIndexMap<T>,\n}\n\n/// The index is out of the bounds of this vector.\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]\npub struct IndexOutOfBounds;\n\nimpl<T> Default for Vec<T>\nwhere\n    T: PackedLayout,\n{\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl<T> Vec<T>\nwhere\n    T: PackedLayout,\n{\n    /// Creates a new empty storage vector.\n    pub fn new() -> Self {\n        Self {\n            len: Lazy::new(0),\n            elems: LazyIndexMap::new(),\n        }\n    }\n\n    /// Returns the number of elements in the vector, also referred to as its 'length'.\n    pub fn len(&self) -> u32 {\n        *self.len\n    }\n\n    /// Returns `true` if the vector contains no elements.\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n}\n\nimpl<T> Vec<T>\nwhere\n    T: PackedLayout,\n{\n    /// Clears the underlying storage cells of the storage vector.\n    ///\n    /// # Note\n    ///\n    /// This completely invalidates the storage vector's invariants about\n    /// the contents of its associated storage region.\n    ///\n    /// This API is used for the `Drop` implementation of [`Vec`] as well as\n    /// for the [`SpreadLayout::clear_spread`][`crate::traits::SpreadLayout::clear_spread`]\n    /// trait implementation.\n    fn clear_cells(&self) {\n        if self.elems.key().is_none() {\n            // We won't clear any storage if we are in lazy state since there\n            // probably has not been any state written to storage, yet.\n            return\n        }\n        for index in 0..self.len() {\n            self.elems.clear_packed_at(index);\n        }\n    }\n}\n\nimpl<T> Vec<T>\nwhere\n    T: PackedLayout,\n{\n    /// Returns an iterator yielding shared references to all elements of the vector.\n    ///\n    /// # Note\n    ///\n    /// Avoid unbounded iteration over big storage vectors.\n    /// Prefer using methods like `Iterator::take` in order to limit the number\n    /// of yielded elements.\n    pub fn iter(&self) -> Iter<T> {\n        Iter::new(self)\n    }\n\n    /// Returns an iterator yielding exclusive references to all elements of the vector.\n    ///\n    /// # Note\n    ///\n    /// Avoid unbounded iteration over big storage vectors.\n    /// Prefer using methods like `Iterator::take` in order to limit the number\n    /// of yielded elements.\n    pub fn iter_mut(&mut self) -> IterMut<T> {\n        IterMut::new(self)\n    }\n\n    /// Returns the index if it is within bounds or `None` otherwise.\n    fn within_bounds(&self, index: u32) -> Option<u32> {\n        if index < self.len() {\n            return Some(index)\n        }\n        None\n    }\n\n    /// Returns a shared reference to the first element if any.\n    pub fn first(&self) -> Option<&T> {\n        if self.is_empty() {\n            return None\n        }\n        self.get(0)\n    }\n\n    /// Returns a shared reference to the last element if any.\n    pub fn last(&self) -> Option<&T> {\n        if self.is_empty() {\n            return None\n        }\n        let last_index = self.len() - 1;\n        self.get(last_index)\n    }\n\n    /// Returns a shared reference to the indexed element.\n    ///\n    /// Returns `None` if `index` is out of bounds.\n    pub fn get(&self, index: u32) -> Option<&T> {\n        self.within_bounds(index)\n            .and_then(|index| self.elems.get(index))\n    }\n}\n\nimpl<T> Vec<T>\nwhere\n    T: PackedLayout,\n{\n    /// Appends an element to the back of the vector.\n    pub fn push(&mut self, value: T) {\n        assert!(\n            self.len() < core::u32::MAX,\n            \"cannot push more elements into the storage vector\"\n        );\n        let last_index = self.len();\n        *self.len += 1;\n        self.elems.put(last_index, Some(value));\n    }\n}\n\nimpl<T> Vec<T>\nwhere\n    T: PackedLayout,\n{\n    /// Pops the last element from the vector and returns it.\n    //\n    /// Returns `None` if the vector is empty.\n    pub fn pop(&mut self) -> Option<T> {\n        if self.is_empty() {\n            return None\n        }\n        let last_index = self.len() - 1;\n        *self.len = last_index;\n        self.elems.put_get(last_index, None)\n    }\n\n    /// Pops the last element from the vector and immediately drops it.\n    ///\n    /// Returns `Some(())` if an element has been removed and `None` otherwise.\n    ///\n    /// # Note\n    ///\n    /// This operation is a bit more efficient than [`Vec::pop`]\n    /// since it avoids reading from contract storage in some use cases.\n    pub fn pop_drop(&mut self) -> Option<()> {\n        if self.is_empty() {\n            return None\n        }\n        let last_index = self.len() - 1;\n        *self.len = last_index;\n        self.elems.put(last_index, None);\n        Some(())\n    }\n\n    /// Returns an exclusive reference to the first element if any.\n    pub fn first_mut(&mut self) -> Option<&mut T> {\n        if self.is_empty() {\n            return None\n        }\n        self.get_mut(0)\n    }\n\n    /// Returns an exclusive reference to the last element if any.\n    pub fn last_mut(&mut self) -> Option<&mut T> {\n        if self.is_empty() {\n            return None\n        }\n        let last_index = self.len() - 1;\n        self.get_mut(last_index)\n    }\n\n    /// Returns an exclusive reference to the indexed element.\n    ///\n    /// Returns `None` if `index` is out of bounds.\n    pub fn get_mut(&mut self, index: u32) -> Option<&mut T> {\n        self.within_bounds(index)\n            .and_then(move |index| self.elems.get_mut(index))\n    }\n\n    /// Swaps the elements at the given indices.\n    ///\n    /// # Panics\n    ///\n    /// If one or both indices are out of bounds.\n    pub fn swap(&mut self, a: u32, b: u32) {\n        assert!(\n            a < self.len() && b < self.len(),\n            \"indices are out of bounds\"\n        );\n        self.elems.swap(a, b)\n    }\n\n    /// Removes the indexed element from the vector and returns it.\n    ///\n    /// The last element of the vector is put into the indexed slot.\n    /// Returns `None` and does not mutate the vector if the index is out of bounds.\n    ///\n    /// # Note\n    ///\n    /// This operation does not preserve ordering but is constant time.\n    pub fn swap_remove(&mut self, n: u32) -> Option<T> {\n        if self.is_empty() {\n            return None\n        }\n        self.elems.swap(n, self.len() - 1);\n        self.pop()\n    }\n\n    /// Removes the indexed element from the vector.\n    ///\n    /// The last element of the vector is put into the indexed slot.\n    /// Returns `Some(())` if an element has been removed and `None` otherwise.\n    ///\n    /// # Note\n    ///\n    /// This operation should be preferred over [`Vec::swap_remove`] if there is\n    /// no need to return the removed element since it avoids a contract storage\n    /// read for some use cases.\n    pub fn swap_remove_drop(&mut self, n: u32) -> Option<()> {\n        if self.is_empty() {\n            return None\n        }\n        self.elems.put(n, None);\n        let last_index = self.len() - 1;\n        let last = self.elems.put_get(last_index, None);\n        self.elems.put(n, last);\n        *self.len = last_index;\n        Some(())\n    }\n\n    /// Sets the elements at the given index to the new value.\n    ///\n    /// Won't return the old element back to the caller.\n    /// Prefer this operation over other method of overriding an element\n    /// in the storage vector since this is more efficient.\n    #[inline]\n    pub fn set(&mut self, index: u32, new_value: T) -> Result<(), IndexOutOfBounds> {\n        if self.within_bounds(index).is_none() {\n            return Err(IndexOutOfBounds)\n        }\n        self.elems.put(index, Some(new_value));\n        Ok(())\n    }\n\n    /// Removes all elements from this vector.\n    ///\n    /// # Note\n    ///\n    /// Use this method to clear the vector instead of e.g. iterative `pop()`.\n    /// This method performs significantly better and does not actually read\n    /// any of the elements (whereas `pop()` does).\n    pub fn clear(&mut self) {\n        if self.is_empty() {\n            return\n        }\n        for index in 0..self.len() {\n            self.elems.put(index, None);\n        }\n        *self.len = 0;\n    }\n}\n"],["990","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::Vec as StorageVec;\nuse crate::{\n    collections::vec::IndexOutOfBounds,\n    traits::{\n        KeyPtr,\n        SpreadLayout,\n    },\n    Lazy,\n};\nuse ink_primitives::Key;\n\n#[test]\nfn new_vec_works() {\n    // `StorageVec::new`\n    let vec = <StorageVec<i32>>::new();\n    assert!(vec.is_empty());\n    assert_eq!(vec.len(), 0);\n    assert_eq!(vec.get(0), None);\n    assert!(vec.iter().next().is_none());\n    // `StorageVec::default`\n    let default = <StorageVec<i32> as Default>::default();\n    assert!(default.is_empty());\n    assert_eq!(default.len(), 0);\n    assert_eq!(vec.get(0), None);\n    assert!(default.iter().next().is_none());\n    // `StorageVec::new` and `StorageVec::default` should be equal.\n    assert_eq!(vec, default);\n}\n\n#[test]\nfn from_iterator_works() {\n    let some_primes = [1, 2, 3, 5, 7, 11, 13];\n    assert_eq!(some_primes.iter().copied().collect::<StorageVec<_>>(), {\n        let mut vec = StorageVec::new();\n        for prime in &some_primes {\n            vec.push(*prime)\n        }\n        vec\n    });\n}\n\n#[test]\nfn from_empty_iterator_works() {\n    assert_eq!(\n        [].iter().copied().collect::<StorageVec<i32>>(),\n        StorageVec::new(),\n    );\n}\n\n#[test]\nfn first_last_of_empty() {\n    let mut vec = <StorageVec<u8>>::new();\n    assert_eq!(vec.first(), None);\n    assert_eq!(vec.first_mut(), None);\n    assert_eq!(vec.last(), None);\n    assert_eq!(vec.last_mut(), None);\n}\n\n#[test]\nfn push_pop_first_last_works() {\n    /// Asserts conditions are met for the given storage vector.\n    fn assert_vec<F, L>(vec: &StorageVec<u8>, len: u32, first: F, last: L)\n    where\n        F: Into<Option<u8>>,\n        L: Into<Option<u8>>,\n    {\n        assert_eq!(vec.is_empty(), len == 0);\n        assert_eq!(vec.len(), len);\n        assert_eq!(vec.first().copied(), first.into());\n        assert_eq!(vec.last().copied(), last.into());\n    }\n\n    let mut vec = StorageVec::new();\n    assert_vec(&vec, 0, None, None);\n\n    // Sequence of `push`\n    vec.push(b'a');\n    assert_vec(&vec, 1, b'a', b'a');\n    vec.push(b'b');\n    assert_vec(&vec, 2, b'a', b'b');\n    vec.push(b'c');\n    assert_vec(&vec, 3, b'a', b'c');\n    vec.push(b'd');\n    assert_vec(&vec, 4, b'a', b'd');\n\n    // Sequence of `pop`\n    assert_eq!(vec.pop(), Some(b'd'));\n    assert_vec(&vec, 3, b'a', b'c');\n    assert_eq!(vec.pop(), Some(b'c'));\n    assert_vec(&vec, 2, b'a', b'b');\n    assert_eq!(vec.pop(), Some(b'b'));\n    assert_vec(&vec, 1, b'a', b'a');\n    assert_eq!(vec.pop(), Some(b'a'));\n    assert_vec(&vec, 0, None, None);\n\n    // Pop from empty vector.\n    assert_eq!(vec.pop(), None);\n    assert_vec(&vec, 0, None, None);\n}\n\n#[test]\nfn pop_drop_works() {\n    let elems = [b'a', b'b', b'c', b'd'];\n    let mut vec = vec_from_slice(&elems);\n    assert_eq!(vec.pop_drop(), Some(()));\n    assert_eq_slice(&vec, &elems[0..3]);\n    assert_eq!(vec.pop_drop(), Some(()));\n    assert_eq_slice(&vec, &elems[0..2]);\n    assert_eq!(vec.pop_drop(), Some(()));\n    assert_eq_slice(&vec, &elems[0..1]);\n    assert_eq!(vec.pop_drop(), Some(()));\n    assert_eq_slice(&vec, &[]);\n    assert_eq!(vec.pop_drop(), None);\n    assert_eq_slice(&vec, &[]);\n}\n\n#[test]\nfn get_works() {\n    let elems = [b'a', b'b', b'c', b'd'];\n    let mut vec = vec_from_slice(&elems);\n    for (n, mut expected) in elems.iter().copied().enumerate() {\n        let n = n as u32;\n        assert_eq!(vec.get(n), Some(&expected));\n        assert_eq!(vec.get_mut(n), Some(&mut expected));\n        assert_eq!(&vec[n], &expected);\n        assert_eq!(&mut vec[n], &mut expected);\n    }\n    let len = vec.len();\n    assert_eq!(vec.get(len), None);\n    assert_eq!(vec.get_mut(len), None);\n}\n\n#[test]\n#[should_panic(expected = \"index out of bounds: the len is 3 but the index is 3\")]\nfn index_out_of_bounds_works() {\n    let test_values = [b'a', b'b', b'c'];\n    let vec = vec_from_slice(&test_values);\n    let _ = &vec[test_values.len() as u32];\n}\n\n#[test]\n#[should_panic(expected = \"index out of bounds: the len is 3 but the index is 3\")]\nfn index_mut_out_of_bounds_works() {\n    let test_values = [b'a', b'b', b'c'];\n    let mut vec = vec_from_slice(&test_values);\n    let _ = &mut vec[test_values.len() as u32];\n}\n\n#[test]\nfn iter_next_works() {\n    let elems = [b'a', b'b', b'c', b'd'];\n    let vec = vec_from_slice(&elems);\n    // Test iterator over `&T`:\n    let mut iter = vec.iter();\n    assert_eq!(iter.count(), 4);\n    assert_eq!(iter.size_hint(), (4, Some(4)));\n    assert_eq!(iter.next(), Some(&b'a'));\n    assert_eq!(iter.size_hint(), (3, Some(3)));\n    assert_eq!(iter.next(), Some(&b'b'));\n    assert_eq!(iter.size_hint(), (2, Some(2)));\n    assert_eq!(iter.count(), 2);\n    assert_eq!(iter.next(), Some(&b'c'));\n    assert_eq!(iter.size_hint(), (1, Some(1)));\n    assert_eq!(iter.next(), Some(&b'd'));\n    assert_eq!(iter.size_hint(), (0, Some(0)));\n    assert_eq!(iter.count(), 0);\n    assert_eq!(iter.next(), None);\n    // Test iterator over `&mut T`:\n    let mut vec = vec;\n    let mut iter = vec.iter_mut();\n    assert_eq!(iter.size_hint(), (4, Some(4)));\n    assert_eq!(iter.next(), Some(&mut b'a'));\n    assert_eq!(iter.size_hint(), (3, Some(3)));\n    assert_eq!(iter.next(), Some(&mut b'b'));\n    assert_eq!(iter.size_hint(), (2, Some(2)));\n    assert_eq!(iter.next(), Some(&mut b'c'));\n    assert_eq!(iter.size_hint(), (1, Some(1)));\n    assert_eq!(iter.next(), Some(&mut b'd'));\n    assert_eq!(iter.size_hint(), (0, Some(0)));\n    assert_eq!(iter.next(), None);\n    assert_eq!(iter.count(), 0);\n}\n\n#[test]\nfn iter_nth_works() {\n    let elems = [b'a', b'b', b'c', b'd'];\n    let vec = vec_from_slice(&elems);\n    // Test iterator over `&T`:\n    let mut iter = vec.iter();\n    assert_eq!(iter.count(), 4);\n    assert_eq!(iter.size_hint(), (4, Some(4)));\n    assert_eq!(iter.nth(1), Some(&b'b'));\n    assert_eq!(iter.count(), 2);\n    assert_eq!(iter.size_hint(), (2, Some(2)));\n    assert_eq!(iter.nth(1), Some(&b'd'));\n    assert_eq!(iter.size_hint(), (0, Some(0)));\n    assert_eq!(iter.count(), 0);\n    assert_eq!(iter.nth(1), None);\n    // Test iterator over `&mut T`:\n    let mut vec = vec;\n    let mut iter = vec.iter_mut();\n    assert_eq!(iter.size_hint(), (4, Some(4)));\n    assert_eq!(iter.nth(1), Some(&mut b'b'));\n    assert_eq!(iter.size_hint(), (2, Some(2)));\n    assert_eq!(iter.nth(1), Some(&mut b'd'));\n    assert_eq!(iter.size_hint(), (0, Some(0)));\n    assert_eq!(iter.nth(1), None);\n    assert_eq!(iter.count(), 0);\n}\n\n#[test]\nfn iter_next_back_works() {\n    let elems = [b'a', b'b', b'c', b'd'];\n    let vec = vec_from_slice(&elems);\n    // Test iterator over `&T`:\n    let mut iter = vec.iter().rev();\n    assert_eq!(iter.clone().count(), 4);\n    assert_eq!(iter.next(), Some(&b'd'));\n    assert_eq!(iter.next(), Some(&b'c'));\n    assert_eq!(iter.clone().count(), 2);\n    assert_eq!(iter.next(), Some(&b'b'));\n    assert_eq!(iter.next(), Some(&b'a'));\n    assert_eq!(iter.clone().count(), 0);\n    assert_eq!(iter.next(), None);\n    // Test iterator over `&mut T`:\n    let mut vec = vec;\n    let mut iter = vec.iter_mut().rev();\n    assert_eq!(iter.next(), Some(&mut b'd'));\n    assert_eq!(iter.next(), Some(&mut b'c'));\n    assert_eq!(iter.next(), Some(&mut b'b'));\n    assert_eq!(iter.next(), Some(&mut b'a'));\n    assert_eq!(iter.next(), None);\n    assert_eq!(iter.count(), 0);\n}\n\n#[test]\nfn iter_nth_back_works() {\n    let elems = [b'a', b'b', b'c', b'd'];\n    let vec = vec_from_slice(&elems);\n    // Test iterator over `&T`:\n    let mut iter = vec.iter().rev();\n    assert_eq!(iter.clone().count(), 4);\n    assert_eq!(iter.nth(1), Some(&b'c'));\n    assert_eq!(iter.clone().count(), 2);\n    assert_eq!(iter.nth(1), Some(&b'a'));\n    assert_eq!(iter.clone().count(), 0);\n    assert_eq!(iter.nth(1), None);\n    // Test iterator over `&mut T`:\n    let mut vec = vec;\n    let mut iter = vec.iter_mut().rev();\n    assert_eq!(iter.nth(1), Some(&mut b'c'));\n    assert_eq!(iter.nth(1), Some(&mut b'a'));\n    assert_eq!(iter.nth(1), None);\n    assert_eq!(iter.count(), 0);\n}\n\n/// Asserts that the the given ordered storage vector elements are equal to the\n/// ordered elements of the given slice.\nfn assert_eq_slice(vec: &StorageVec<u8>, slice: &[u8]) {\n    assert_eq!(vec.len() as usize, slice.len());\n    assert!(vec.iter().zip(slice.iter()).all(|(lhs, rhs)| *lhs == *rhs))\n}\n\n/// Creates a storage vector from the given slice.\nfn vec_from_slice(slice: &[u8]) -> StorageVec<u8> {\n    slice.iter().copied().collect::<StorageVec<u8>>()\n}\n\n#[test]\nfn swap_works() {\n    let elems = [b'a', b'b', b'c', b'd'];\n    let mut vec = vec_from_slice(&elems);\n\n    // Swap at same position is a no-op.\n    for index in 0..elems.len() as u32 {\n        vec.swap(index, index);\n        assert_eq_slice(&vec, &elems);\n    }\n\n    // Swap first and second\n    vec.swap(0, 1);\n    assert_eq_slice(&vec, &[b'b', b'a', b'c', b'd']);\n    // Swap third and last\n    vec.swap(2, 3);\n    assert_eq_slice(&vec, &[b'b', b'a', b'd', b'c']);\n    // Swap first and last\n    vec.swap(0, 3);\n    assert_eq_slice(&vec, &[b'c', b'a', b'd', b'b']);\n}\n\n#[test]\n#[should_panic]\nfn swap_one_invalid_index() {\n    let mut vec = vec_from_slice(&[b'a', b'b', b'c', b'd']);\n    vec.swap(0, vec.len());\n}\n\n#[test]\n#[should_panic]\nfn swap_both_invalid_indices() {\n    let mut vec = vec_from_slice(&[b'a', b'b', b'c', b'd']);\n    vec.swap(vec.len(), vec.len());\n}\n\n#[test]\nfn swap_remove_works() {\n    let mut vec = vec_from_slice(&[b'a', b'b', b'c', b'd']);\n\n    // Swap remove first element.\n    assert_eq!(vec.swap_remove(0), Some(b'a'));\n    assert_eq_slice(&vec, &[b'd', b'b', b'c']);\n    // Swap remove middle element.\n    assert_eq!(vec.swap_remove(1), Some(b'b'));\n    assert_eq_slice(&vec, &[b'd', b'c']);\n    // Swap remove last element.\n    assert_eq!(vec.swap_remove(1), Some(b'c'));\n    assert_eq_slice(&vec, &[b'd']);\n    // Swap remove only element.\n    assert_eq!(vec.swap_remove(0), Some(b'd'));\n    assert_eq_slice(&vec, &[]);\n    // Swap remove from empty vector.\n    assert_eq!(vec.swap_remove(0), None);\n    assert_eq_slice(&vec, &[]);\n}\n\n#[test]\nfn swap_remove_drop_works() {\n    let mut vec = vec_from_slice(&[b'a', b'b', b'c', b'd']);\n\n    // Swap remove first element.\n    assert_eq!(vec.swap_remove_drop(0), Some(()));\n    assert_eq_slice(&vec, &[b'd', b'b', b'c']);\n    // Swap remove middle element.\n    assert_eq!(vec.swap_remove_drop(1), Some(()));\n    assert_eq_slice(&vec, &[b'd', b'c']);\n    // Swap remove last element.\n    assert_eq!(vec.swap_remove_drop(1), Some(()));\n    assert_eq_slice(&vec, &[b'd']);\n    // Swap remove only element.\n    assert_eq!(vec.swap_remove_drop(0), Some(()));\n    assert_eq_slice(&vec, &[]);\n    // Swap remove from empty vector.\n    assert_eq!(vec.swap_remove_drop(0), None);\n    assert_eq_slice(&vec, &[]);\n}\n\n#[test]\nfn spread_layout_push_pull_works() -> ink_env::Result<()> {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let vec1 = vec_from_slice(&[b'a', b'b', b'c', b'd']);\n        let root_key = Key::from([0x42; 32]);\n        SpreadLayout::push_spread(&vec1, &mut KeyPtr::from(root_key));\n        // Load the pushed storage vector into another instance and check that\n        // both instances are equal:\n        let vec2 =\n            <StorageVec<u8> as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n        assert_eq!(vec1, vec2);\n        Ok(())\n    })\n}\n\n#[test]\n#[should_panic(expected = \"encountered empty storage cell\")]\nfn spread_layout_clear_works() {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let vec1 = vec_from_slice(&[b'a', b'b', b'c', b'd']);\n        let root_key = Key::from([0x42; 32]);\n        SpreadLayout::push_spread(&vec1, &mut KeyPtr::from(root_key));\n        // It has already been asserted that a valid instance can be pulled\n        // from contract storage after a push to the same storage region.\n        //\n        // Now clear the associated storage from `vec1` and check whether\n        // loading another instance from this storage will panic since the\n        // vector's length property cannot read a value:\n        SpreadLayout::clear_spread(&vec1, &mut KeyPtr::from(root_key));\n        let _ =\n            <StorageVec<u8> as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n        Ok(())\n    })\n    .unwrap()\n}\n\n#[test]\nfn set_works() {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let mut vec = vec_from_slice(&[b'a', b'b', b'c', b'd']);\n        let _ = vec.set(0, b'x').unwrap();\n        let expected = vec_from_slice(&[b'x', b'b', b'c', b'd']);\n        assert_eq!(vec, expected);\n        Ok(())\n    })\n    .unwrap()\n}\n\n#[test]\nfn set_fails_when_index_oob() {\n    let mut vec = vec_from_slice(&[b'a']);\n    let res = vec.set(1, b'x');\n    assert_eq!(res, Err(IndexOutOfBounds));\n}\n\n#[test]\nfn clear_works_on_filled_vec() {\n    let mut vec = vec_from_slice(&[b'a', b'b', b'c', b'd']);\n    vec.clear();\n    assert!(vec.is_empty());\n}\n\n#[test]\nfn clear_works_on_empty_vec() {\n    let mut vec = vec_from_slice(&[]);\n    vec.clear();\n    assert!(vec.is_empty());\n}\n\n#[test]\n#[should_panic(expected = \"encountered empty storage cell\")]\nfn storage_is_cleared_completely_after_pull_lazy() {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        // given\n        let root_key = Key::from([0x42; 32]);\n        let mut lazy_vec: Lazy<StorageVec<u32>> = Lazy::new(StorageVec::new());\n        lazy_vec.push(13u32);\n        lazy_vec.push(13u32);\n        SpreadLayout::push_spread(&lazy_vec, &mut KeyPtr::from(root_key));\n        let pulled_vec = <Lazy<StorageVec<u32>> as SpreadLayout>::pull_spread(\n            &mut KeyPtr::from(root_key),\n        );\n\n        // when\n        SpreadLayout::clear_spread(&pulled_vec, &mut KeyPtr::from(root_key));\n\n        // then\n        let contract_id = ink_env::test::get_current_contract_account_id::<\n            ink_env::DefaultEnvironment,\n        >()\n        .expect(\"Cannot get contract id\");\n        let used_cells = ink_env::test::count_used_storage_cells::<\n            ink_env::DefaultEnvironment,\n        >(&contract_id)\n        .expect(\"used cells must be returned\");\n        assert_eq!(used_cells, 0);\n        let _ =\n            *<Lazy<Lazy<u32>> as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n\n        Ok(())\n    })\n    .unwrap()\n}\n\n#[test]\n#[should_panic(expected = \"encountered empty storage cell\")]\nfn drop_works() {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let root_key = Key::from([0x42; 32]);\n\n        // if the setup panics it should not cause the test to pass\n        let setup_result = std::panic::catch_unwind(|| {\n            let vec = vec_from_slice(&[b'a', b'b', b'c', b'd']);\n            SpreadLayout::push_spread(&vec, &mut KeyPtr::from(root_key));\n            let _ = <StorageVec<u8> as SpreadLayout>::pull_spread(&mut KeyPtr::from(\n                root_key,\n            ));\n            // vec is dropped which should clear the cells\n        });\n        assert!(setup_result.is_ok(), \"setup should not panic\");\n\n        let contract_id = ink_env::test::get_current_contract_account_id::<\n            ink_env::DefaultEnvironment,\n        >()\n        .expect(\"Cannot get contract id\");\n        let used_cells = ink_env::test::count_used_storage_cells::<\n            ink_env::DefaultEnvironment,\n        >(&contract_id)\n        .expect(\"used cells must be returned\");\n        assert_eq!(used_cells, 0);\n\n        let _ =\n            <StorageVec<u8> as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n        Ok(())\n    })\n    .unwrap()\n}\n"],["991","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Implementation of generic traits that are useful for the storage vector.\n\nuse super::{\n    Iter,\n    IterMut,\n    Vec as StorageVec,\n};\nuse crate::traits::PackedLayout;\nuse core::iter::{\n    Extend,\n    FromIterator,\n};\n\nimpl<T> Drop for StorageVec<T>\nwhere\n    T: PackedLayout,\n{\n    fn drop(&mut self) {\n        self.clear_cells();\n    }\n}\n\nimpl<T> core::ops::Index<u32> for StorageVec<T>\nwhere\n    T: PackedLayout,\n{\n    type Output = T;\n\n    fn index(&self, index: u32) -> &Self::Output {\n        match self.get(index) {\n            Some(value) => value,\n            None => {\n                panic!(\n                    \"index out of bounds: the len is {} but the index is {}\",\n                    self.len(),\n                    index\n                )\n            }\n        }\n    }\n}\n\nimpl<T> core::ops::IndexMut<u32> for StorageVec<T>\nwhere\n    T: PackedLayout,\n{\n    fn index_mut(&mut self, index: u32) -> &mut Self::Output {\n        let len = self.len();\n        match self.get_mut(index) {\n            Some(value) => value,\n            None => {\n                panic!(\n                    \"index out of bounds: the len is {} but the index is {}\",\n                    len, index\n                )\n            }\n        }\n    }\n}\n\nimpl<'a, T: 'a> IntoIterator for &'a StorageVec<T>\nwhere\n    T: PackedLayout,\n{\n    type Item = &'a T;\n    type IntoIter = Iter<'a, T>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.iter()\n    }\n}\n\nimpl<'a, T: 'a> IntoIterator for &'a mut StorageVec<T>\nwhere\n    T: PackedLayout,\n{\n    type Item = &'a mut T;\n    type IntoIter = IterMut<'a, T>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.iter_mut()\n    }\n}\n\nimpl<T> Extend<T> for StorageVec<T>\nwhere\n    T: PackedLayout,\n{\n    fn extend<I>(&mut self, iter: I)\n    where\n        I: IntoIterator<Item = T>,\n    {\n        for item in iter {\n            self.push(item)\n        }\n    }\n}\n\nimpl<T> FromIterator<T> for StorageVec<T>\nwhere\n    T: PackedLayout,\n{\n    fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = T>,\n    {\n        let mut vec = StorageVec::new();\n        vec.extend(iter);\n        vec\n    }\n}\n\nimpl<T> core::cmp::PartialEq for StorageVec<T>\nwhere\n    T: PartialEq + PackedLayout,\n{\n    fn eq(&self, other: &Self) -> bool {\n        if self.len() != other.len() {\n            return false\n        }\n        self.iter().zip(other.iter()).all(|(lhs, rhs)| lhs == rhs)\n    }\n}\n\nimpl<T> core::cmp::Eq for StorageVec<T> where T: Eq + PackedLayout {}\n"],["992","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::Vec as StorageVec;\nuse crate::{\n    test_utils::FuzzCollection,\n    traits::{\n        KeyPtr,\n        PackedLayout,\n        SpreadLayout,\n    },\n    Pack,\n};\n\nuse quickcheck::{\n    Arbitrary,\n    Gen,\n};\nuse std::{\n    iter::FromIterator,\n    vec::Vec,\n};\n\nimpl<T> Arbitrary for StorageVec<T>\nwhere\n    T: Arbitrary + PackedLayout + Send + Clone + 'static,\n{\n    fn arbitrary(g: &mut Gen) -> StorageVec<T> {\n        let vec = Vec::<T>::arbitrary(g);\n        StorageVec::<T>::from_iter(vec)\n    }\n}\n\nimpl<T> Clone for StorageVec<T>\nwhere\n    T: PackedLayout + Clone,\n{\n    fn clone(&self) -> Self {\n        let mut svec = StorageVec::<T>::new();\n        self.iter().for_each(|v| svec.push(v.clone()));\n        svec\n    }\n}\n\nimpl<'a, T> FuzzCollection for &'a mut StorageVec<T>\nwhere\n    T: Clone + PackedLayout,\n{\n    type Collection = StorageVec<T>;\n    type Item = &'a mut T;\n\n    /// Makes `self` equal to `instance2` by executing a series of operations\n    /// on `self`.\n    fn equalize(&mut self, instance2: &Self::Collection) {\n        self.clear();\n        instance2.into_iter().for_each(|v| self.push(v.clone()));\n    }\n\n    /// `val` is a value from the vector. We take an element out\n    /// of `self` and assign it to `val`.\n    ///\n    /// Hence this method only might modify values of `item`, leaving\n    /// others intact.\n    fn assign(&mut self, val: Self::Item) {\n        if let Some(popped_val) = self.pop() {\n            *val = popped_val.clone();\n        }\n    }\n}\n\ncrate::fuzz_storage!(\"vec_1\", StorageVec<u32>);\ncrate::fuzz_storage!(\"vec_2\", StorageVec<Option<Pack<Option<u32>>>>);\ncrate::fuzz_storage!(\"vec_3\", StorageVec<(bool, (u32, u128))>);\ncrate::fuzz_storage!(\"vec_4\", StorageVec<(i128, u32, bool, Option<(u32, i128)>)>);\n"],["993","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::traits::{\n    KeyPtr,\n    SpreadLayout,\n};\nuse ink_primitives::Key;\n\n#[cfg(test)]\nmacro_rules! gen_tests_for_backend {\n    ( $backend:ty ) => {\n        /// Returns some test values.\n        fn test_values() -> [(u8, i32); 2] {\n            [(b'A', 13), (b'B', 23)]\n        }\n\n        /// Returns a prefilled hashmap with `[('A', 13), ['B', 23])`.\n        fn prefilled_hmap() -> $backend {\n            test_values().iter().copied().collect::<$backend>()\n        }\n\n        /// Returns always the same `KeyPtr`.\n        fn key_ptr() -> KeyPtr {\n            let root_key = Key::from([0x42; 32]);\n            KeyPtr::from(root_key)\n        }\n\n        /// Pushes a `HashMap` instance into the contract storage.\n        fn push_hmap(hmap: &$backend) {\n            SpreadLayout::push_spread(hmap, &mut key_ptr());\n        }\n\n        /// Pulls a `HashMap` instance from the contract storage.\n        fn pull_hmap() -> $backend {\n            <$backend as SpreadLayout>::pull_spread(&mut key_ptr())\n        }\n\n        fn push_pull_prefilled_hmap() -> $backend {\n            let hmap1 = prefilled_hmap();\n            assert_eq!(hmap1.get(&b'A'), Some(&13));\n            push_hmap(&hmap1);\n            pull_hmap()\n        }\n\n        #[test]\n        fn insert_inexistent_works_with_empty() {\n            // given\n            let mut hmap = <$backend>::new();\n            assert!(matches!(hmap.entry(b'A'), Vacant(_)));\n            assert!(hmap.get(&b'A').is_none());\n\n            // when\n            assert_eq!(*hmap.entry(b'A').or_insert(77), 77);\n\n            // then\n            assert_eq!(hmap.get(&b'A'), Some(&77));\n            assert_eq!(hmap.len_cached_entries(), 1);\n        }\n\n        #[test]\n        fn insert_existent_works() {\n            // given\n            let mut hmap = prefilled_hmap();\n            match hmap.entry(b'A') {\n                Vacant(_) => panic!(),\n                Occupied(o) => assert_eq!(o.get(), &13),\n            }\n\n            // when\n            hmap.entry(b'A').or_insert(77);\n\n            // then\n            assert_eq!(hmap.get(&b'A'), Some(&13));\n            assert_eq!(hmap.len_cached_entries(), 2);\n        }\n\n        #[test]\n        fn mutations_work_with_push_pull() -> ink_env::Result<()> {\n            ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n                // given\n                let hmap1 = prefilled_hmap();\n                assert_eq!(hmap1.get(&b'A'), Some(&13));\n                push_hmap(&hmap1);\n\n                let mut hmap2 = pull_hmap();\n                assert_eq!(hmap2.get(&b'A'), Some(&13));\n\n                // when\n                let v = hmap2.entry(b'A').or_insert(42);\n                *v += 1;\n                assert_eq!(hmap2.get(&b'A'), Some(&14));\n                push_hmap(&hmap2);\n\n                // then\n                let hmap3 = pull_hmap();\n                assert_eq!(hmap3.get(&b'A'), Some(&14));\n                Ok(())\n            })\n        }\n\n        #[test]\n        fn simple_insert_with_works() {\n            // given\n            let mut hmap = prefilled_hmap();\n\n            // when\n            assert!(hmap.get(&b'C').is_none());\n            let v = hmap.entry(b'C').or_insert_with(|| 42);\n\n            // then\n            assert_eq!(*v, 42);\n            assert_eq!(hmap.get(&b'C'), Some(&42));\n            assert_eq!(hmap.len_cached_entries(), 3);\n        }\n\n        #[test]\n        fn simple_default_insert_works() {\n            // given\n            let mut hmap = <$backend>::new();\n\n            // when\n            let v = hmap.entry(b'A').or_default();\n\n            // then\n            assert_eq!(*v, 0);\n            assert_eq!(hmap.get(&b'A'), Some(&0));\n        }\n\n        #[test]\n        fn insert_with_works_with_mutations() {\n            // given\n            let mut hmap = <$backend>::new();\n            let v = hmap.entry(b'A').or_insert_with(|| 42);\n            assert_eq!(*v, 42);\n\n            // when\n            *v += 1;\n\n            // then\n            assert_eq!(hmap.get(&b'A'), Some(&43));\n            assert_eq!(hmap.len_cached_entries(), 1);\n        }\n\n        #[test]\n        fn insert_with_works_with_push_pull() -> ink_env::Result<()> {\n            ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n                // given\n                let mut hmap1 = <$backend>::new();\n                let value = hmap1.entry(b'A').or_insert_with(|| 42);\n\n                // when\n                *value = 43;\n                push_hmap(&hmap1);\n\n                // then\n                let hmap2 = pull_hmap();\n                assert_eq!(hmap2.get(&b'A'), Some(&43));\n                Ok(())\n            })\n        }\n\n        #[test]\n        fn simple_insert_with_key_works() {\n            // given\n            let mut hmap = <$backend>::new();\n\n            // when\n            let _ = hmap.entry(b'A').or_insert_with_key(|key| (key * 2).into());\n\n            // then\n            assert_eq!(hmap.get(&b'A'), Some(&130));\n        }\n\n        #[test]\n        fn key_get_works_with_nonexistent() {\n            let mut hmap = <$backend>::new();\n            assert_eq!(hmap.entry(b'A').key(), &b'A');\n        }\n\n        #[test]\n        fn key_get_works_with_existent() {\n            let mut hmap = prefilled_hmap();\n            assert_eq!(hmap.entry(b'A').key(), &b'A');\n            assert_eq!(hmap.entry(b'B').key(), &b'B');\n        }\n\n        #[test]\n        fn and_modify_has_no_effect_for_nonexistent() {\n            // given\n            let mut hmap = <$backend>::new();\n\n            // when\n            hmap.entry(b'B').and_modify(|e| *e += 1).or_insert(42);\n\n            // then\n            assert_eq!(hmap.get(&b'B'), Some(&42));\n        }\n\n        #[test]\n        fn and_modify_works_for_existent() {\n            // given\n            let mut hmap = prefilled_hmap();\n\n            // when\n            assert_eq!(hmap.get(&b'B'), Some(&23));\n            hmap.entry(b'B').and_modify(|e| *e += 1).or_insert(7);\n\n            // then\n            assert_eq!(hmap.get(&b'B'), Some(&24));\n        }\n\n        #[test]\n        fn occupied_entry_api_works_with_push_pull() -> ink_env::Result<()> {\n            ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n                // given\n                let mut hmap1 = prefilled_hmap();\n                assert_eq!(hmap1.get(&b'A'), Some(&13));\n                match hmap1.entry(b'A') {\n                    Entry::Occupied(mut o) => {\n                        assert_eq!(o.key(), &b'A');\n                        assert_eq!(o.insert(15), 13);\n                    }\n                    Entry::Vacant(_) => panic!(),\n                }\n                push_hmap(&hmap1);\n\n                // when\n                let mut hmap2 = pull_hmap();\n                assert_eq!(hmap2.get(&b'A'), Some(&15));\n                match hmap2.entry(b'A') {\n                    Entry::Occupied(o) => {\n                        assert_eq!(o.remove_entry(), (b'A', 15));\n                    }\n                    Entry::Vacant(_) => panic!(),\n                }\n                push_hmap(&hmap2);\n\n                // then\n                let hmap3 = pull_hmap();\n                assert_eq!(hmap3.get(&b'A'), None);\n\n                Ok(())\n            })\n        }\n\n        #[test]\n        fn vacant_api_works() {\n            let mut hmap = <$backend>::new();\n            match hmap.entry(b'A') {\n                Entry::Occupied(_) => panic!(),\n                Entry::Vacant(v) => {\n                    assert_eq!(v.key(), &b'A');\n                    assert_eq!(v.into_key(), b'A');\n                }\n            }\n        }\n\n        #[test]\n        fn vacant_api_works_with_push_pull() -> ink_env::Result<()> {\n            ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n                // given\n                let mut hmap1 = <$backend>::new();\n                match hmap1.entry(b'A') {\n                    Entry::Occupied(_) => panic!(),\n                    Entry::Vacant(v) => {\n                        let val = v.insert(42);\n                        *val += 1;\n                    }\n                }\n                push_hmap(&hmap1);\n\n                // when\n                let hmap2 = pull_hmap();\n\n                // then\n                assert_eq!(hmap2.get(&b'A'), Some(&43));\n                Ok(())\n            })\n        }\n\n        #[test]\n        fn pulling_occupied_entry_must_succeed() -> ink_env::Result<()> {\n            ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n                // given\n                let hmap1 = prefilled_hmap();\n                push_hmap(&hmap1);\n\n                // when\n                let mut hmap2 = pull_hmap();\n\n                // then\n                for (k, _v) in test_values().iter() {\n                    match hmap2.entry(*k) {\n                        Entry::Occupied(_) => (),\n                        Entry::Vacant(_) => panic!(\"the entry must be occupied\"),\n                    }\n                }\n                Ok(())\n            })\n        }\n\n        #[test]\n        fn value_not_in_cache_but_in_storage_get_and_get_mut() -> ink_env::Result<()> {\n            ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n                // given\n                let mut hmap2 = push_pull_prefilled_hmap();\n\n                // then\n                match hmap2.entry(b'A') {\n                    Entry::Occupied(mut o) => {\n                        assert_eq!(o.get(), &13);\n                        assert_eq!(o.get_mut(), &mut 13);\n                    }\n                    Entry::Vacant(_) => panic!(),\n                }\n\n                Ok(())\n            })\n        }\n\n        #[test]\n        fn value_not_in_cache_but_in_storage_insert() -> ink_env::Result<()> {\n            ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n                // given\n                let mut hmap2 = push_pull_prefilled_hmap();\n\n                // then\n                match hmap2.entry(b'A') {\n                    Entry::Occupied(mut o) => {\n                        assert_eq!(o.insert(999), 13);\n                    }\n                    Entry::Vacant(_) => panic!(),\n                }\n                assert_eq!(hmap2.get(&b'A'), Some(&999));\n\n                Ok(())\n            })\n        }\n\n        #[test]\n        fn value_not_in_cache_but_in_storage_remove_entry() -> ink_env::Result<()> {\n            ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n                // given\n                let mut hmap2 = push_pull_prefilled_hmap();\n\n                // then\n                match hmap2.entry(b'A') {\n                    Entry::Occupied(o) => {\n                        assert_eq!(o.remove_entry(), (b'A', 13));\n                        assert_eq!(hmap2.get(&b'A'), None);\n                        push_hmap(&hmap2);\n                    }\n                    Entry::Vacant(_) => panic!(),\n                }\n\n                let hmap3 = pull_hmap();\n                assert_eq!(hmap3.get(&b'A'), None);\n                Ok(())\n            })\n        }\n\n        #[test]\n        fn value_not_in_cache_is_properly_flushed_after_insert() -> ink_env::Result<()> {\n            ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n                // given\n                let mut hmap2 = push_pull_prefilled_hmap();\n\n                // when\n                match hmap2.entry(b'A') {\n                    Entry::Occupied(mut o) => {\n                        assert_eq!(o.insert(999), 13);\n                    }\n                    Entry::Vacant(_) => panic!(),\n                }\n                assert_eq!(hmap2.get(&b'A'), Some(&999));\n                push_hmap(&hmap2);\n\n                // then\n                // the value must have been flushed, which implies that after the\n                // insert is was marked as `Mutated`.\n                let hmap3 = pull_hmap();\n                assert_eq!(hmap3.get(&b'A'), Some(&999));\n\n                Ok(())\n            })\n        }\n\n        #[test]\n        fn value_not_in_cache_but_in_storage_into_mut() -> ink_env::Result<()> {\n            ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n                // given\n                let mut hmap2 = push_pull_prefilled_hmap();\n\n                // then\n                match hmap2.entry(b'A') {\n                    Entry::Occupied(o) => assert_eq!(o.into_mut(), &mut 13),\n                    Entry::Vacant(_) => panic!(),\n                }\n\n                Ok(())\n            })\n        }\n    };\n}\n\nmod lazyhmap_backend {\n    use super::*;\n    use crate::lazy::lazy_hmap::{\n        Entry,\n        Entry::{\n            Occupied,\n            Vacant,\n        },\n        LazyHashMap,\n    };\n    use ink_env::hash::Blake2x256;\n\n    gen_tests_for_backend!(LazyHashMap<u8, i32, Blake2x256>);\n}\n\nmod hashmap_backend {\n    use super::*;\n    use crate::collections::hashmap::{\n        Entry,\n        Entry::{\n            Occupied,\n            Vacant,\n        },\n        HashMap as StorageHashMap,\n    };\n    use ink_env::hash::Blake2x256;\n\n    gen_tests_for_backend!(StorageHashMap<u8, i32, Blake2x256>);\n}\n"],["994","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::traits::{\n    KeyPtr,\n    SpreadLayout,\n};\nuse core::{\n    convert::{\n        self,\n        AsRef,\n    },\n    fmt,\n    fmt::Display,\n    ops::{\n        Deref,\n        DerefMut,\n    },\n};\nuse ink_prelude::borrow::{\n    Borrow,\n    BorrowMut,\n};\n\n/// An instance that is solely stored within the contract's memory.\n///\n/// This will never be stored to or loaded from contract storage.\n///\n/// # Note\n///\n/// Use instances of this type in order to have some shared state between\n/// contract messages and functions.\n/// Its usage is comparable to the Solidity's `memory` instances.\n/// Pulling an instance of this type from the contract storage will always\n/// yield a default constructed value.\n#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub struct Memory<T> {\n    /// The inner value that will always be stored within contract memory.\n    inner: T,\n}\n\n#[cfg(feature = \"std\")]\nconst _: () = {\n    use crate::traits::StorageLayout;\n    use ink_metadata::layout::{\n        CellLayout,\n        Layout,\n        LayoutKey,\n    };\n\n    impl<T> StorageLayout for Memory<T> {\n        fn layout(key_ptr: &mut KeyPtr) -> Layout {\n            Layout::Cell(CellLayout::new::<()>(LayoutKey::from(\n                key_ptr.advance_by(0),\n            )))\n        }\n    }\n};\n\nimpl<T> SpreadLayout for Memory<T>\nwhere\n    T: Default,\n{\n    const FOOTPRINT: u64 = 0;\n\n    fn pull_spread(_ptr: &mut KeyPtr) -> Self {\n        Default::default()\n    }\n\n    fn push_spread(&self, _ptr: &mut KeyPtr) {}\n    fn clear_spread(&self, _ptr: &mut KeyPtr) {}\n}\n\nimpl<T> Memory<T> {\n    /// Creates a new memory instance.\n    pub fn new(inner: T) -> Self {\n        Self { inner }\n    }\n\n    /// Returns a shared reference to the inner `T`.\n    pub fn get(memory: &Self) -> &T {\n        &memory.inner\n    }\n\n    /// Returns an exclusive reference to the inner `T`.\n    pub fn get_mut(memory: &mut Self) -> &mut T {\n        &mut memory.inner\n    }\n}\n\nimpl<T> From<T> for Memory<T> {\n    fn from(inner: T) -> Self {\n        Self::new(inner)\n    }\n}\n\nimpl<T> Default for Memory<T>\nwhere\n    T: Default,\n{\n    fn default() -> Self {\n        Self::new(<T as Default>::default())\n    }\n}\n\nimpl<T> Display for Memory<T>\nwhere\n    T: Display,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        core::fmt::Display::fmt(Self::get(self), f)\n    }\n}\n\nimpl<T> Deref for Memory<T> {\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        Self::get(self)\n    }\n}\n\nimpl<T> DerefMut for Memory<T> {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        Self::get_mut(self)\n    }\n}\n\nimpl<T> AsRef<T> for Memory<T>\nwhere\n    T: SpreadLayout,\n{\n    fn as_ref(&self) -> &T {\n        Self::get(self)\n    }\n}\n\nimpl<T> convert::AsMut<T> for Memory<T>\nwhere\n    T: SpreadLayout,\n{\n    fn as_mut(&mut self) -> &mut T {\n        Self::get_mut(self)\n    }\n}\n\nimpl<T> Borrow<T> for Memory<T>\nwhere\n    T: SpreadLayout,\n{\n    fn borrow(&self) -> &T {\n        Self::get(self)\n    }\n}\n\nimpl<T> BorrowMut<T> for Memory<T>\nwhere\n    T: SpreadLayout,\n{\n    fn borrow_mut(&mut self) -> &mut T {\n        Self::get_mut(self)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Memory;\n    use crate::traits::{\n        KeyPtr,\n        SpreadLayout,\n    };\n    use core::{\n        convert::{\n            AsMut,\n            AsRef,\n        },\n        ops::{\n            Deref,\n            DerefMut,\n        },\n    };\n    use ink_env::test::DefaultAccounts;\n    use ink_prelude::borrow::{\n        Borrow,\n        BorrowMut,\n    };\n    use ink_primitives::Key;\n\n    type ComplexTuple = (u8, [i32; 4], (bool, i32));\n\n    fn complex_value() -> ComplexTuple {\n        (b'A', [0x00; 4], (true, 42))\n    }\n\n    #[test]\n    fn new_works() {\n        let mut expected = complex_value();\n        let mut mem = Memory::new(expected);\n        assert_eq!(<Memory<_> as Deref>::deref(&mem), &expected);\n        assert_eq!(<Memory<_> as DerefMut>::deref_mut(&mut mem), &mut expected);\n        assert_eq!(<Memory<_> as AsRef<_>>::as_ref(&mem), &expected);\n        assert_eq!(<Memory<_> as AsMut<_>>::as_mut(&mut mem), &mut expected);\n        assert_eq!(Borrow::<ComplexTuple>::borrow(&mem), &expected);\n        assert_eq!(\n            BorrowMut::<ComplexTuple>::borrow_mut(&mut mem),\n            &mut expected\n        );\n        assert_eq!(Memory::get(&mem), &expected);\n        assert_eq!(Memory::get_mut(&mut mem), &mut expected);\n    }\n\n    #[test]\n    fn from_works() {\n        let mut expected = complex_value();\n        let mut from = Memory::from(expected);\n        assert_eq!(from, Memory::new(expected));\n        assert_eq!(Memory::get(&from), &expected);\n        assert_eq!(Memory::get_mut(&mut from), &mut expected);\n    }\n\n    #[test]\n    fn default_works() {\n        use core::fmt::Debug;\n        fn assert_default<T>()\n        where\n            T: Debug + Default + PartialEq,\n        {\n            let mut memory_default = <Memory<T> as Default>::default();\n            let mut default = <T as Default>::default();\n            assert_eq!(<Memory<T>>::get(&memory_default), &default);\n            assert_eq!(<Memory<T>>::get_mut(&mut memory_default), &mut default);\n        }\n        assert_default::<bool>();\n        assert_default::<u8>();\n        assert_default::<Option<i32>>();\n        assert_default::<Memory<[u8; 4]>>();\n    }\n\n    #[test]\n    fn spread_layout_push_pull_works() {\n        let p1 = Memory::new((b'A', [0x00; 4], (true, 42)));\n        assert_eq!(*p1, (b'A', [0x00; 4], (true, 42)));\n        assert_ne!(p1, Default::default());\n        let root_key = Key::from([0x42; 32]);\n        SpreadLayout::push_spread(&p1, &mut KeyPtr::from(root_key));\n        // Now load another instance of a pack from the same key and check\n        // if both instances are equal:\n        let p2 = SpreadLayout::pull_spread(&mut KeyPtr::from(root_key));\n        assert_ne!(p1, p2);\n        assert_eq!(p2, Default::default());\n    }\n\n    fn run_test<F>(f: F)\n    where\n        F: FnOnce(DefaultAccounts<ink_env::DefaultEnvironment>),\n    {\n        ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|default_accounts| {\n            f(default_accounts);\n            Ok(())\n        })\n        .unwrap()\n    }\n\n    #[test]\n    fn spread_layout_clear_works() {\n        run_test(|_| {\n            // Clearing a memory instance should have no effect on the underlying\n            // contract storage. We can test this by pushing and pulling a storage\n            // affecting entity in between on the same storage region:\n            let root_key = Key::from([0x42; 32]);\n            <i32 as SpreadLayout>::push_spread(&42, &mut KeyPtr::from(root_key));\n            let loaded1 = <i32 as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n            assert_eq!(loaded1, 42);\n            let mem = Memory::new(77);\n            SpreadLayout::push_spread(&mem, &mut KeyPtr::from(root_key));\n            let loaded2 = <i32 as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n            assert_eq!(loaded2, 42);\n            // Now we clear the `i32` from storage and check whether that works.\n            // We load as `Option<i32>` in order to expect `None`:\n            <i32 as SpreadLayout>::clear_spread(&loaded2, &mut KeyPtr::from(root_key));\n            use crate::traits::pull_packed_root_opt;\n            let loaded3 = pull_packed_root_opt::<Option<i32>>(&root_key);\n            assert_eq!(loaded3, None);\n        })\n    }\n}\n"],["995","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::DynamicAllocator;\nuse crate::traits::{\n    pull_spread_root,\n    push_spread_root,\n};\nuse cfg_if::cfg_if;\nuse core::{\n    mem,\n    mem::ManuallyDrop,\n};\nuse ink_primitives::Key;\n\n/// The default dynamic allocator key offset.\n///\n/// This is where the dynamic allocator is stored on the contract storage.\nconst DYNAMIC_ALLOCATOR_KEY_OFFSET: [u8; 32] = [0xFE; 32];\n\n/// The phase in which a contract execution can be.\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\npub enum ContractPhase {\n    /// Initializes the global dynamic storage allocator from scratch.\n    ///\n    /// Upon initialization it will be created from scratch as if the\n    /// contract has been deployed for the first time.\n    Deploy,\n    /// Initializes the global dynamic storage allocator from storage.\n    ///\n    /// Upon initialization the dynamic storage allocator will be pulled\n    /// from the contract storage with the assumption that a former\n    /// contract deployment has already taken place in the past.\n    Call,\n}\n\n/// The state of the dynamic allocator global instance.\n#[derive(Debug)]\n#[allow(clippy::large_enum_variant)]\nenum DynamicAllocatorState {\n    /// The global instance has not yet been initialized.\n    ///\n    /// Upon initialization it will be created from scratch as if the\n    /// contract has been deployed for the first time.\n    UninitDeploy,\n    /// The global instance has not yet been initialized.\n    ///\n    /// Upon initialization it will be pulled from the contract storage\n    /// with the assumption that a former contract deployment has already\n    /// taken place in the past.\n    UninitCall,\n    /// The global instance has been initialized successfully and can be used.\n    Initialized(DynamicAllocator),\n    /// The global instance has been finalized and can no longer be used.\n    Finalized,\n}\n\nimpl From<ContractPhase> for DynamicAllocatorState {\n    fn from(phase: ContractPhase) -> Self {\n        match phase {\n            ContractPhase::Deploy => DynamicAllocatorState::UninitDeploy,\n            ContractPhase::Call => DynamicAllocatorState::UninitCall,\n        }\n    }\n}\n\nimpl DynamicAllocatorState {\n    /// Initializes the global dynamic storage allocator instance.\n    ///\n    /// The `phase` parameter describes for which execution phase the dynamic\n    /// storage allocator needs to be initialized since this is different\n    /// in contract instantiations and calls.\n    pub fn initialize(&mut self, phase: ContractPhase) {\n        match self {\n            DynamicAllocatorState::Initialized(_)\n                // We only perform this check on Wasm compilation to avoid\n                // some overly constrained check for the off-chain testing.\n                if cfg!(all(not(feature = \"std\"), target_arch = \"wasm32\")) =>\n            {\n                panic!(\n                    \"cannot initialize the dynamic storage \\\n                     allocator instance twice in Wasm\",\n                )\n            }\n            DynamicAllocatorState::Finalized => {\n                panic!(\n                    \"cannot initialize the dynamic storage \\\n                 allocator after it has been finalized\",\n                )\n            }\n            state => {\n                *state = phase.into();\n            }\n        }\n    }\n\n    /// Finalizes the global instance for the dynamic storage allocator.\n    ///\n    /// The global dynamic storage allocator must not be used after this!\n    pub fn finalize(&mut self) {\n        match self {\n            DynamicAllocatorState::Initialized(allocator) => {\n                // Push all state of the global dynamic storage allocator\n                // instance back onto the contract storage.\n                push_spread_root::<DynamicAllocator>(\n                    &allocator,\n                    &Key::from(DYNAMIC_ALLOCATOR_KEY_OFFSET),\n                );\n                // Prevent calling `drop` on the dynamic storage allocator\n                // instance since this would clear all contract storage\n                // again.\n                let _ = ManuallyDrop::new(mem::take(allocator));\n                *self = DynamicAllocatorState::Finalized;\n            }\n            DynamicAllocatorState::Finalized => {\n                panic!(\n                    \"cannot finalize the dynamic storage allocator \\\n                     after it has already been finalized\"\n                )\n            }\n            DynamicAllocatorState::UninitCall | DynamicAllocatorState::UninitDeploy => {\n                // Nothing to do in these states.\n            }\n        }\n    }\n\n    /// Runs the closure on the global instance for the dynamic storage allocator.\n    ///\n    /// Will automatically initialize the global allocator instance if it has not\n    /// yet been initialized.\n    ///\n    /// # Panics\n    ///\n    /// If the global dynamic storage allocator instance has already been finalized.\n    pub fn on_instance<F, R>(&mut self, f: F) -> R\n    where\n        F: FnOnce(&mut DynamicAllocator) -> R,\n    {\n        match self {\n            DynamicAllocatorState::UninitDeploy => {\n                let mut allocator = DynamicAllocator::default();\n                let result = f(&mut allocator);\n                *self = DynamicAllocatorState::Initialized(allocator);\n                result\n            }\n            DynamicAllocatorState::UninitCall => {\n                let mut allocator = pull_spread_root::<DynamicAllocator>(&Key::from(\n                    DYNAMIC_ALLOCATOR_KEY_OFFSET,\n                ));\n                let result = f(&mut allocator);\n                *self = DynamicAllocatorState::Initialized(allocator);\n                result\n            }\n            DynamicAllocatorState::Initialized(ref mut allocator) => f(allocator),\n            DynamicAllocatorState::Finalized => {\n                panic!(\n                    \"cannot operate on the dynamic storage \\\n                     allocator after it has been finalized\"\n                );\n            }\n        }\n    }\n}\n\ncfg_if! {\n    if #[cfg(all(not(feature = \"std\"), target_arch = \"wasm32\"))] {\n        // Procedures for the Wasm compilation:\n\n        /// The global instance for the dynamic storage allocator.\n        static mut GLOBAL_INSTANCE: DynamicAllocatorState = DynamicAllocatorState::UninitDeploy;\n\n        /// Forwards to the `initialize` of the global dynamic storage allocator instance.\n        pub fn initialize(phase: ContractPhase) {\n            // SAFETY: Accessing the global allocator in Wasm mode is single\n            //         threaded and will not return back a reference to its\n            //         internal state. Also the `initialize` method won't\n            //         re-enter the dynamic storage in any possible way.\n            unsafe { &mut GLOBAL_INSTANCE }.initialize(phase);\n        }\n\n        /// Forwards to the `finalize` of the global dynamic storage allocator instance.\n        pub fn finalize() {\n            // SAFETY: Accessing the global allocator in Wasm mode is single\n            //         threaded and will not return back a reference to its\n            //         internal state. Also the `finalize` method won't\n            //         re-enter the dynamic storage in any possible way.\n            unsafe { &mut GLOBAL_INSTANCE }.finalize();\n        }\n\n        /// Forwards to the `on_instance` of the global dynamic storage allocator instance.\n        pub fn on_instance<F, R>(f: F) -> R\n        where\n            F: FnOnce(&mut DynamicAllocator) -> R,\n        {\n            // SAFETY: Accessing the global allocator in Wasm mode is single\n            //         threaded and will not return back a reference to its\n            //         internal state. Also this is an internal API only called\n            //         through `alloc` and `free` both of which do not return\n            //         anything that could allow to re-enter the dynamic storage\n            //         allocator instance.\n            unsafe { &mut GLOBAL_INSTANCE }.on_instance(f)\n        }\n\n    } else if #[cfg(feature = \"std\")] {\n        // Procedures for the off-chain environment and testing compilation:\n\n        use ::core::cell::RefCell;\n        thread_local!(\n            /// The global instance for the dynamic storage allocator.\n            static GLOBAL_INSTANCE: RefCell<DynamicAllocatorState> = RefCell::new(\n                DynamicAllocatorState::UninitDeploy\n            );\n        );\n        /// Forwards to the `initialize` of the global dynamic storage allocator instance.\n        pub fn initialize(phase: ContractPhase) {\n            GLOBAL_INSTANCE.with(|instance| {\n                instance.borrow_mut().initialize(phase)\n            });\n        }\n\n        /// Forwards to the `finalize` of the global dynamic storage allocator instance.\n        pub fn finalize() {\n            GLOBAL_INSTANCE.with(|instance| {\n                instance.borrow_mut().finalize()\n            });\n        }\n\n        /// Forwards to the `on_instance` of the global dynamic storage allocator instance.\n        pub fn on_instance<F, R>(f: F) -> R\n        where\n            F: FnOnce(&mut DynamicAllocator) -> R,\n        {\n            GLOBAL_INSTANCE.with(|instance| {\n                instance.borrow_mut().on_instance(f)\n            })\n        }\n\n    } else {\n        compile_error! {\n            \"ink! only support compilation as `std` or `no_std` + `wasm32-unknown`\"\n        }\n    }\n}\n"],["996","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! The default dynamic storage allocator.\n//!\n//! Allows to allocate storage cells in a dynamic fashion.\n//! This is important if users want to combine types of varying storage\n//! footprints. For example, dynamic allocations are required whenever\n//! a user wants to use a storage collection (e.g. `storage::Vec`) in\n//! another storage collection: `storage::Vec<storage::Vec<T>>`\n//!\n//! # Simplification\n//!\n//! The contracts pallet is using 256 bit keys for identifying storage cells.\n//! This implies a storage space of 2^256 cells which is big enough to say that\n//! there are probably never going to happen collisions anywhere at any time\n//! if keys are chosen randomly. Using the built-in crypto hashers on unique\n//! input we can be sure that there are never going to be collisions in this\n//! space of 2^256 cells.\n//!\n//! This way we can reduce the problem of finding another region in our storage\n//! that fits certain requirements (e.g. a minimum size) to the problem of\n//! finding another uniform slot. Since we are on 32-bit WebAssembly we have\n//! memory limitations that make it impractical to have more than 2^32 dynamic\n//! allocated entities and so we can create another limitation for having a\n//! total of 2^32 dynamic allocations at any point in time.\n//! This enables us to have 32-bit keys instead of 256-bit keys.\n//!\n//! We can convert such 32-bit keys (represented by e.g. a `u32`) into 256-bit\n//! keys by using one of the built-in crypto hashes that has a 256-bit output,\n//! e.g. KECCAK, SHA2 or BLAKE2. For technical reasons we should prepend the\n//! bytes of the 32-bit key by some unique byte sequence, e.g.:\n//! ```no_compile\n//! let key256 = blake2x256(b\"DYNAMICALLY ALLOCATED\", bytes(key32));\n//! ```\n//!\n//! # Internals\n//!\n//! As described in [# Simplification] there are 2^32 possible uniform dynamic\n//! allocations available. For each such slot the dynamic allocator stores via\n//! a single bit in a bitvector if that slot is free or occupied.\n//! This bitvector is called the `free` list.\n//! However, searching in this `free` list for a 0 bit and thus a free slot\n//! for a dynamic allocation would mean that for every 256 consecutively\n//! occupied dynamic allocations there was a contract storage lookup required.\n//! This might seem a lot but given that there could be thousands or\n//! tens of thousands of dynamic allocations at any given time this might not scale\n//! well.\n//! For the reason of improving scalability we added another vector: the\n//! so-called `set_bits` vector.\n//! In this vector every `u8` element densely stores the number of set bits\n//! (bits that are `1` or `true`) for each 256-bit package in the `free` list.\n//! (Note that the `free` list is organized in 256-bit chunks of bits.)\n//!\n//! This way, to search for an unoccupied dynamic allocation we iterate over\n//! the set-bits vector which is 32 times more dense than our `free` list.\n//! The additional density implies that we can query up to 8192 potential\n//! dynamic storage allocations with a single contract storage look-up.\n\nmod allocation;\nmod allocator;\nmod boxed;\nmod init;\n\n#[cfg(test)]\nmod tests;\n\nuse self::allocator::DynamicAllocator;\npub use self::{\n    allocation::DynamicAllocation,\n    boxed::Box,\n    init::ContractPhase,\n};\n\n/// Returns a new dynamic storage allocation.\npub fn alloc() -> DynamicAllocation {\n    init::on_instance(DynamicAllocator::alloc)\n}\n\n/// Frees the given dynamic storage allocation.\n///\n/// This makes the given dynamic storage allocation available again\n/// for new dynamic storage allocations.\npub fn free(allocation: DynamicAllocation) {\n    init::on_instance(|allocator| allocator.free(allocation))\n}\n\n/// Tells the global dynamic storage allocator instance how it shall initialize.\n///\n/// # Note\n///\n/// Normally users of ink! do not have to call this function directly as it is\n/// automatically being use in the correct order and way by the generated code.\n///\n/// - The `phase` parameter describes for which execution phase the dynamic\n///   storage allocator needs to be initialized since this is different\n///   in contract instantiations and calls.\n/// - This has to be issued before the first interaction with the global allocator.\n/// - The actual instantiation will happen only upon the first interaction with\n///   the global allocator, e.g. using its `alloc` or `free` calls. Until then\n///   it remains uninitialized.\n///\n/// If this function is not called before the first global allocator interaction\n/// then the default initialization scheme is for contract instantiation.\n/// However, this behavior might change and must not be relied upon.\npub fn initialize(phase: ContractPhase) {\n    init::initialize(phase);\n}\n\n/// Finalizes the global dynamic storage allocator instance.\n///\n/// This pushes all the accumulated state from this contract execution back to\n/// the contract storage to be used in the next contract execution for the same\n/// contract instance.\n///\n/// The global dynamic storage allocator must not be used after this!\n///\n/// # Note\n///\n/// Normally users of ink! do not have to call this function directly as it is\n/// automatically being use in the correct order and way by the generated code.\npub fn finalize() {\n    init::finalize()\n}\n"],["997","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::DynamicAllocation;\nuse crate::{\n    collections::BitStash,\n    traits::{\n        KeyPtr,\n        SpreadLayout,\n    },\n};\n\n/// The dynamic allocator.\n///\n/// Manages dynamic storage allocations in a very efficient and economic way.\n#[derive(Debug, Default, PartialEq, Eq)]\npub struct DynamicAllocator {\n    allocations: BitStash,\n}\n\n#[cfg(feature = \"std\")]\nconst _: () = {\n    use crate::traits::StorageLayout;\n    use ink_metadata::layout::{\n        FieldLayout,\n        Layout,\n        StructLayout,\n    };\n\n    impl StorageLayout for DynamicAllocator {\n        fn layout(key_ptr: &mut KeyPtr) -> Layout {\n            Layout::Struct(StructLayout::new(vec![FieldLayout::new(\n                \"allocations\",\n                <BitStash as StorageLayout>::layout(key_ptr),\n            )]))\n        }\n    }\n};\n\nimpl SpreadLayout for DynamicAllocator {\n    const FOOTPRINT: u64 = <BitStash as SpreadLayout>::FOOTPRINT;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        Self {\n            allocations: SpreadLayout::pull_spread(ptr),\n        }\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        SpreadLayout::push_spread(&self.allocations, ptr);\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        SpreadLayout::clear_spread(&self.allocations, ptr);\n    }\n}\n\nimpl DynamicAllocator {\n    /// Returns a new dynamic storage allocation.\n    ///\n    /// # Panics\n    ///\n    /// If the dynamic allocator ran out of free dynamic allocations.\n    pub fn alloc(&mut self) -> DynamicAllocation {\n        DynamicAllocation(self.allocations.put())\n    }\n\n    /// Frees the given dynamic storage allocation.\n    ///\n    /// This makes the given dynamic storage allocation available again\n    /// for new dynamic storage allocations.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the given dynamic allocation is invalid.\n    /// A dynamic allocation is invalid if it is not represented as occupied\n    /// in the `free` list.\n    pub fn free(&mut self, allocation: DynamicAllocation) {\n        let index = allocation.get();\n        if !self\n            .allocations\n            .take(index)\n            .expect(\"invalid dynamic storage allocation\")\n        {\n            panic!(\n                \"encountered double free of dynamic storage: at index {}\",\n                index\n            )\n        }\n    }\n}\n"],["998","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::Box as StorageBox;\nuse crate::{\n    alloc::DynamicAllocation,\n    traits::{\n        forward_clear_packed,\n        forward_pull_packed,\n        forward_push_packed,\n        KeyPtr,\n        PackedLayout,\n        SpreadLayout,\n    },\n};\nuse ink_prelude::vec::Vec;\nuse ink_primitives::Key;\n\n#[cfg(feature = \"std\")]\nconst _: () = {\n    use crate::traits::StorageLayout;\n    use ink_metadata::layout::{\n        CellLayout,\n        Layout,\n        LayoutKey,\n    };\n\n    impl<T> StorageLayout for StorageBox<T>\n    where\n        T: SpreadLayout,\n    {\n        fn layout(key_ptr: &mut KeyPtr) -> Layout {\n            Layout::Cell(CellLayout::new::<DynamicAllocation>(LayoutKey::from(\n                key_ptr.advance_by(1),\n            )))\n        }\n    }\n\n    impl<T> scale_info::TypeInfo for StorageBox<T>\n    where\n        T: SpreadLayout + 'static,\n    {\n        type Identity = Self;\n\n        fn type_info() -> scale_info::Type {\n            scale_info::Type::builder()\n                .path(\n                    scale_info::Path::from_segments(vec![\"ink_storage\", \"alloc\", \"Box\"])\n                        .expect(\"encountered invalid Rust path\"),\n                )\n                // Unfortunately we cannot encode the type parameters of the box since they\n                // have to be `T: scale::Codec`. However, them not requiring to be encodable\n                // is the purpose of the storage `Box<T>`.\n                // Until we found a solution to this problem we cannot uncomment the below\n                // line of code:\n                //\n                // .type_params(vec![scale_info::MetaType::new::<T>()])\n                .composite(\n                    scale_info::build::Fields::named()\n                        .field_of::<DynamicAllocation>(\"allocation\", \"DynamicAllocation\"),\n                )\n        }\n    }\n};\n\nimpl<T> SpreadLayout for StorageBox<T>\nwhere\n    T: SpreadLayout,\n{\n    const FOOTPRINT: u64 = 1;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        forward_pull_packed::<Self>(ptr)\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        forward_push_packed::<Self>(&self, ptr)\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        forward_clear_packed::<Self>(&self, ptr)\n    }\n}\n\nimpl<T> scale::Encode for StorageBox<T>\nwhere\n    T: SpreadLayout,\n{\n    fn size_hint(&self) -> usize {\n        <DynamicAllocation as scale::Encode>::size_hint(&self.allocation)\n    }\n\n    fn encode_to<O: scale::Output + ?Sized>(&self, dest: &mut O) {\n        <DynamicAllocation as scale::Encode>::encode_to(&self.allocation, dest)\n    }\n\n    fn encode(&self) -> Vec<u8> {\n        <DynamicAllocation as scale::Encode>::encode(&self.allocation)\n    }\n\n    fn using_encoded<R, F: FnOnce(&[u8]) -> R>(&self, f: F) -> R {\n        <DynamicAllocation as scale::Encode>::using_encoded(&self.allocation, f)\n    }\n}\n\nimpl<T> scale::Decode for StorageBox<T>\nwhere\n    T: SpreadLayout,\n{\n    fn decode<I: scale::Input>(value: &mut I) -> Result<Self, scale::Error> {\n        Ok(StorageBox::lazy(\n            <DynamicAllocation as scale::Decode>::decode(value)?,\n        ))\n    }\n}\n\nimpl<T> PackedLayout for StorageBox<T>\nwhere\n    T: SpreadLayout,\n{\n    fn pull_packed(&mut self, _at: &Key) {}\n\n    fn push_packed(&self, _at: &Key) {\n        <T as SpreadLayout>::push_spread(Self::get(self), &mut KeyPtr::from(self.key()))\n    }\n\n    fn clear_packed(&self, _at: &Key) {\n        <T as SpreadLayout>::clear_spread(Self::get(self), &mut KeyPtr::from(self.key()))\n    }\n}\n"],["999","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::Box as StorageBox;\nuse crate::{\n    alloc,\n    alloc::ContractPhase,\n    traits::{\n        KeyPtr,\n        SpreadLayout,\n    },\n    Pack,\n};\nuse core::{\n    cmp::Ordering,\n    convert::{\n        AsMut,\n        AsRef,\n    },\n    ops::{\n        Deref,\n        DerefMut,\n    },\n};\nuse ink_env::test::DefaultAccounts;\nuse ink_prelude::borrow::{\n    Borrow,\n    BorrowMut,\n};\nuse ink_primitives::Key;\n\nfn run_test<F>(f: F)\nwhere\n    F: FnOnce(DefaultAccounts<ink_env::DefaultEnvironment>),\n{\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|default_accounts| {\n        alloc::initialize(ContractPhase::Deploy);\n        f(default_accounts);\n        Ok(())\n    })\n    .unwrap()\n}\n\n#[test]\nfn new_works() {\n    run_test(|_| {\n        let mut expected = 1;\n        let mut boxed = StorageBox::new(expected);\n        assert_eq!(StorageBox::get(&boxed), &expected);\n        assert_eq!(StorageBox::get_mut(&mut boxed), &mut expected);\n        assert_eq!(Deref::deref(&boxed), &expected);\n        assert_eq!(DerefMut::deref_mut(&mut boxed), &mut expected);\n        assert_eq!(AsRef::as_ref(&boxed), &expected);\n        assert_eq!(AsMut::as_mut(&mut boxed), &mut expected);\n        assert_eq!(Borrow::<i32>::borrow(&boxed), &expected);\n        assert_eq!(BorrowMut::<i32>::borrow_mut(&mut boxed), &mut expected);\n    })\n}\n\n#[test]\nfn partial_eq_works() {\n    run_test(|_| {\n        let b1 = StorageBox::new(b'X');\n        let b2 = StorageBox::new(b'Y');\n        let b3 = StorageBox::new(b'X');\n        assert!(<StorageBox<u8> as PartialEq>::ne(&b1, &b2));\n        assert!(<StorageBox<u8> as PartialEq>::eq(&b1, &b3));\n    })\n}\n\n#[test]\nfn partial_ord_works() {\n    run_test(|_| {\n        let b1 = StorageBox::new(1);\n        let b2 = StorageBox::new(2);\n        let b3 = StorageBox::new(1);\n        assert_eq!(\n            <StorageBox<u8> as PartialOrd>::partial_cmp(&b1, &b2),\n            Some(Ordering::Less)\n        );\n        assert_eq!(\n            <StorageBox<u8> as PartialOrd>::partial_cmp(&b2, &b1),\n            Some(Ordering::Greater)\n        );\n        assert_eq!(\n            <StorageBox<u8> as PartialOrd>::partial_cmp(&b1, &b3),\n            Some(Ordering::Equal)\n        );\n    })\n}\n\n#[test]\nfn spread_layout_push_pull_works() {\n    run_test(|_| {\n        let b1 = StorageBox::new(b'A');\n        assert_eq!(*b1, b'A');\n        let root_key = Key::from([0x42; 32]);\n        SpreadLayout::push_spread(&b1, &mut KeyPtr::from(root_key));\n        // Now load another instance of storage box from the same key and check\n        // if both instances are equal:\n        let b2 = SpreadLayout::pull_spread(&mut KeyPtr::from(root_key));\n        assert_eq!(b1, b2);\n        // We have to forget one of the storage boxes because we otherwise get\n        // a double free panic since their `Drop` implementations both try to\n        // free the same dynamic allocation.\n        core::mem::forget(b2);\n    })\n}\n\n#[test]\n#[should_panic(expected = \"storage entry was empty\")]\nfn spread_layout_clear_works() {\n    run_test(|_| {\n        let b1 = StorageBox::new(b'A');\n        assert_eq!(*b1, b'A');\n        let root_key = Key::from([0x42; 32]);\n        // Manually clear the storage of `b1`. Then another load from the same\n        // key region should panic since the entry is empty:\n        SpreadLayout::push_spread(&b1, &mut KeyPtr::from(root_key));\n        SpreadLayout::clear_spread(&b1, &mut KeyPtr::from(root_key));\n        let b2: StorageBox<u8> = SpreadLayout::pull_spread(&mut KeyPtr::from(root_key));\n        // We have to forget one of the storage boxes because we otherwise get\n        // a double free panic since their `Drop` implementations both try to\n        // free the same dynamic allocation.\n        core::mem::forget(b2);\n    })\n}\n\n#[test]\nfn packed_layout_works() {\n    run_test(|_| {\n        let p1 = Pack::new((StorageBox::new(b'A'), StorageBox::new([0x01; 4])));\n        assert_eq!(*p1.0, b'A');\n        assert_eq!(*p1.1, [0x01; 4]);\n        let root_key = Key::from([0x42; 32]);\n        SpreadLayout::push_spread(&p1, &mut KeyPtr::from(root_key));\n        // Now load another instance of storage box from the same key and check\n        // if both instances are equal:\n        let p2: Pack<(StorageBox<u8>, StorageBox<[i32; 4]>)> =\n            SpreadLayout::pull_spread(&mut KeyPtr::from(root_key));\n        assert_eq!(p1, p2);\n        // We have to forget one of the storage boxes because we otherwise get\n        // a double free panic since their `Drop` implementations both try to\n        // free the same dynamic allocation.\n        core::mem::forget(p2);\n    })\n}\n\n#[test]\nfn recursive_pull_push_works() {\n    run_test(|_| {\n        let rec1 = StorageBox::new(StorageBox::new(b'A'));\n        assert_eq!(**rec1, b'A');\n        let root_key = Key::from([0x42; 32]);\n        SpreadLayout::push_spread(&rec1, &mut KeyPtr::from(root_key));\n        // Now load another instance of storage box from the same key and check\n        // if both instances are equal:\n        let rec2: StorageBox<StorageBox<u8>> =\n            SpreadLayout::pull_spread(&mut KeyPtr::from(root_key));\n        assert_eq!(rec1, rec2);\n        // We have to forget one of the storage boxes because we otherwise get\n        // a double free panic since their `Drop` implementations both try to\n        // free the same dynamic allocation.\n        core::mem::forget(rec2);\n    })\n}\n\n#[test]\n#[should_panic(expected = \"storage entry was empty\")]\nfn recursive_clear_works() {\n    run_test(|_| {\n        let rec1 = StorageBox::new(StorageBox::new(b'A'));\n        assert_eq!(**rec1, b'A');\n        let root_key = Key::from([0x42; 32]);\n        // Manually clear the storage of `rec1`. Then another load from the same\n        // key region should panic since the entry is empty:\n        SpreadLayout::push_spread(&rec1, &mut KeyPtr::from(root_key));\n        SpreadLayout::clear_spread(&rec1, &mut KeyPtr::from(root_key));\n        let rec2: StorageBox<StorageBox<u8>> =\n            SpreadLayout::pull_spread(&mut KeyPtr::from(root_key));\n        // We have to forget one of the storage boxes because we otherwise get\n        // a double free panic since their `Drop` implementations both try to\n        // free the same dynamic allocation.\n        core::mem::forget(rec2);\n    })\n}\n\n#[test]\n#[should_panic(expected = \"encountered double free of dynamic storage: at index 0\")]\nfn double_free_panics() {\n    run_test(|_| {\n        let b1 = StorageBox::new(b'A');\n        let root_key = Key::from([0x42; 32]);\n        // Manually clear the storage of `rec1`. Then another load from the same\n        // key region should panic since the entry is empty:\n        SpreadLayout::push_spread(&b1, &mut KeyPtr::from(root_key));\n        let b2: StorageBox<u8> = SpreadLayout::pull_spread(&mut KeyPtr::from(root_key));\n        assert_eq!(b1, b2);\n        // At this point both `b1` and `b2` are getting dropped trying to free\n        // the same dynamic allocation which panics.\n    })\n}\n"],["1000","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::Box as StorageBox;\nuse crate::traits::{\n    clear_spread_root,\n    SpreadLayout,\n};\n\nimpl<T> Drop for StorageBox<T>\nwhere\n    T: SpreadLayout,\n{\n    fn drop(&mut self) {\n        clear_spread_root::<T>(self, &self.allocation.key());\n        crate::alloc::free(self.allocation);\n    }\n}\n\nimpl<T> core::cmp::PartialEq for StorageBox<T>\nwhere\n    T: PartialEq + SpreadLayout,\n{\n    fn eq(&self, other: &Self) -> bool {\n        PartialEq::eq(StorageBox::get(self), StorageBox::get(other))\n    }\n}\n\nimpl<T> core::cmp::Eq for StorageBox<T> where T: Eq + SpreadLayout {}\n\nimpl<T> core::cmp::PartialOrd for StorageBox<T>\nwhere\n    T: PartialOrd + SpreadLayout,\n{\n    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n        PartialOrd::partial_cmp(StorageBox::get(self), StorageBox::get(other))\n    }\n    fn lt(&self, other: &Self) -> bool {\n        PartialOrd::lt(StorageBox::get(self), StorageBox::get(other))\n    }\n    fn le(&self, other: &Self) -> bool {\n        PartialOrd::le(StorageBox::get(self), StorageBox::get(other))\n    }\n    fn ge(&self, other: &Self) -> bool {\n        PartialOrd::ge(StorageBox::get(self), StorageBox::get(other))\n    }\n    fn gt(&self, other: &Self) -> bool {\n        PartialOrd::gt(StorageBox::get(self), StorageBox::get(other))\n    }\n}\n\nimpl<T> core::cmp::Ord for StorageBox<T>\nwhere\n    T: core::cmp::Ord + SpreadLayout,\n{\n    fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n        Ord::cmp(StorageBox::get(self), StorageBox::get(other))\n    }\n}\n\nimpl<T> core::fmt::Display for StorageBox<T>\nwhere\n    T: core::fmt::Display + SpreadLayout,\n{\n    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n        core::fmt::Display::fmt(StorageBox::get(self), f)\n    }\n}\n\nimpl<T> core::hash::Hash for StorageBox<T>\nwhere\n    T: core::hash::Hash + SpreadLayout,\n{\n    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {\n        StorageBox::get(self).hash(state)\n    }\n}\n\nimpl<T> core::convert::AsRef<T> for StorageBox<T>\nwhere\n    T: SpreadLayout,\n{\n    fn as_ref(&self) -> &T {\n        StorageBox::get(self)\n    }\n}\n\nimpl<T> core::convert::AsMut<T> for StorageBox<T>\nwhere\n    T: SpreadLayout,\n{\n    fn as_mut(&mut self) -> &mut T {\n        StorageBox::get_mut(self)\n    }\n}\n\nimpl<T> ink_prelude::borrow::Borrow<T> for StorageBox<T>\nwhere\n    T: SpreadLayout,\n{\n    fn borrow(&self) -> &T {\n        StorageBox::get(self)\n    }\n}\n\nimpl<T> ink_prelude::borrow::BorrowMut<T> for StorageBox<T>\nwhere\n    T: SpreadLayout,\n{\n    fn borrow_mut(&mut self) -> &mut T {\n        StorageBox::get_mut(self)\n    }\n}\n\nimpl<T> core::ops::Deref for StorageBox<T>\nwhere\n    T: SpreadLayout,\n{\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        StorageBox::get(self)\n    }\n}\n\nimpl<T> core::ops::DerefMut for StorageBox<T>\nwhere\n    T: SpreadLayout,\n{\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        StorageBox::get_mut(self)\n    }\n}\n"],["1001","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nmod impls;\nmod storage;\n\n#[cfg(test)]\nmod tests;\n\nuse crate::{\n    alloc::{\n        alloc,\n        DynamicAllocation,\n    },\n    lazy::Lazy,\n    traits::SpreadLayout,\n};\nuse ink_primitives::Key;\n\n/// A dynamically allocated storage entity.\n///\n/// Users can use this in order to make certain `SpreadLayout` storage entities\n/// used in contexts that require a `PackedLayout` storage entity by simply\n/// packing the storage entity witihn a `storage::Box`.\n///\n/// Dynamic allocations caused by the creation of `storage::Box` instances do\n/// have some limited overhead:\n///\n/// - The dynamic allocation itself has to be provided by some dynamic storage\n///   allocator that needs to be invoked.\n/// - Each dynamic storage allocation implies roughly 1.12 bits of overhead.\n/// - Upon ever first dereferencing of a `storage::Box` instance a cryptographic\n///   hash routine is run in order to compute the underlying storage key.\n///\n/// Use this abstraction with caution due to the aforementioned performance\n/// implications.\n#[derive(Debug)]\npub struct Box<T>\nwhere\n    T: SpreadLayout,\n{\n    /// The storage area where the boxed storage entity is stored.\n    allocation: DynamicAllocation,\n    /// The cache for the boxed storage entity.\n    value: Lazy<T>,\n}\n\nimpl<T> Box<T>\nwhere\n    T: SpreadLayout,\n{\n    /// Creates a new boxed entity.\n    pub fn new(value: T) -> Self {\n        Self {\n            allocation: alloc(),\n            value: Lazy::new(value),\n        }\n    }\n\n    /// Creates a new boxed entity that has not yet loaded its value.\n    fn lazy(allocation: DynamicAllocation) -> Self {\n        Self {\n            allocation,\n            value: Lazy::lazy(allocation.key()),\n        }\n    }\n\n    /// Returns the underlying storage key for the dynamic allocated entity.\n    fn key(&self) -> Key {\n        self.allocation.key()\n    }\n}\n\nimpl<T> Box<T>\nwhere\n    T: SpreadLayout,\n{\n    /// Returns a shared reference to the boxed value.\n    ///\n    /// # Note\n    ///\n    /// This loads the value from the pointed to contract storage\n    /// if this did not happen before.\n    ///\n    /// # Panics\n    ///\n    /// If loading from contract storage failed.\n    #[must_use]\n    pub fn get(boxed: &Self) -> &T {\n        &boxed.value\n    }\n\n    /// Returns an exclusive reference to the boxed value.\n    ///\n    /// # Note\n    ///\n    /// This loads the value from the pointed to contract storage\n    /// if this did not happen before.\n    ///\n    /// # Panics\n    ///\n    /// If loading from contract storage failed.\n    #[must_use]\n    pub fn get_mut(boxed: &mut Self) -> &mut T {\n        &mut boxed.value\n    }\n}\n"],["1002","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse ink_env::hash::{\n    Blake2x256,\n    CryptoHash,\n    HashOutput,\n};\nuse ink_primitives::Key;\n\n/// A unique dynamic allocation.\n///\n/// This can refer to a dynamically allocated storage cell.\n/// It has been created by a dynamic storage allocator.\n/// The initiator of the allocation has to make sure to deallocate\n/// this dynamic allocation again using the same dynamic allocator\n/// if it is no longer in use.\n///\n/// # Note\n///\n/// Normally instances of this type are not used directly and instead\n/// a [`storage::Box`](`crate::Box`) is used instead.\n#[derive(\n    Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, scale::Encode, scale::Decode,\n)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\npub struct DynamicAllocation(pub(super) u32);\n\n/// Wraps a bytes buffer and turns it into an accumulator.\n///\n/// # Panics\n///\n/// Upon hash calculation if the underlying buffer length does not suffice the\n/// needs of the accumulated hash buffer.\nstruct Wrap<'a> {\n    /// The underlying wrapped buffer.\n    buffer: &'a mut [u8],\n    /// The current length of the filled area.\n    len: usize,\n}\n\nimpl Wrap<'_> {\n    /// Returns the capacity of the underlying buffer.\n    fn capacity(&self) -> usize {\n        self.buffer.len()\n    }\n\n    /// Returns the length of the underlying buffer.\n    fn len(&self) -> usize {\n        self.len\n    }\n\n    /// Appends the given bytes to the end of the wrapped buffer.\n    fn append_bytes(&mut self, bytes: &[u8]) {\n        debug_assert!(self.len() + bytes.len() <= self.capacity());\n        let len = self.len;\n        let bytes_len = bytes.len();\n        self.buffer[len..(len + bytes_len)].copy_from_slice(bytes);\n        self.len += bytes_len;\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl<'a> std::io::Write for Wrap<'a> {\n    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {\n        self.append_bytes(buf);\n        Ok(buf.len())\n    }\n\n    fn flush(&mut self) -> std::io::Result<()> {\n        Ok(())\n    }\n}\n\nimpl<'a> From<&'a mut [u8]> for Wrap<'a> {\n    fn from(buffer: &'a mut [u8]) -> Self {\n        Self { buffer, len: 0 }\n    }\n}\n\n#[cfg(not(feature = \"std\"))]\nimpl<'a> scale::Output for Wrap<'a> {\n    fn write(&mut self, bytes: &[u8]) {\n        self.append_bytes(bytes)\n    }\n\n    fn push_byte(&mut self, byte: u8) {\n        debug_assert!(self.len() < self.capacity());\n        self.buffer[self.len] = byte;\n        self.len += 1;\n    }\n}\n\nimpl DynamicAllocation {\n    /// Returns the allocation identifier as `u32`.\n    pub(super) fn get(self) -> u32 {\n        self.0\n    }\n\n    /// Returns the storage key associated with this dynamic allocation.\n    pub fn key(self) -> Key {\n        // We create a 25-bytes buffer for the hashing.\n        // This is due to the fact that we prepend the `u32` encoded identifier\n        // with the `b\"DYNAMICALLY ALLOCATED\"` byte string which has a length\n        // 21 bytes. Since `u32` always has an encoding length of 4 bytes we\n        // end up requiring 25 bytes in total.\n        // Optimization Opportunity:\n        // Since ink! always runs single threaded we could make this buffer\n        // static and instead reuse its contents with every invocation of this\n        // method. However, this would introduce `unsafe` Rust usage.\n        pub struct EncodeWrapper(u32);\n        impl scale::Encode for EncodeWrapper {\n            #[rustfmt::skip]\n            fn encode_to<O>(&self, output: &mut O)\n            where\n                O: scale::Output + ?Sized,\n            {\n                <[u8; 21] as scale::Encode>::encode_to(&[\n                    b'D', b'Y', b'N', b'A', b'M', b'I', b'C', b'A', b'L', b'L', b'Y',\n                    b' ',\n                    b'A', b'L', b'L', b'O', b'C', b'A', b'T', b'E', b'D',\n                ], output);\n                <u32 as scale::Encode>::encode_to(&self.0, output);\n            }\n        }\n        // Encode the `u32` identifier requires a 4 bytes buffer.\n        #[rustfmt::skip]\n        let mut buffer: [u8; 25] = [\n            b'D', b'Y', b'N', b'A', b'M', b'I', b'C', b'A', b'L', b'L', b'Y',\n            b' ',\n            b'A', b'L', b'L', b'O', b'C', b'A', b'T', b'E', b'D',\n            b'_', b'_', b'_', b'_',\n        ];\n        {\n            let mut wrapped = Wrap::from(&mut buffer[21..25]);\n            <u32 as scale::Encode>::encode_to(&self.0, &mut wrapped);\n        }\n        let mut output = <Blake2x256 as HashOutput>::Type::default();\n        <Blake2x256 as CryptoHash>::hash(&buffer, &mut output);\n        Key::from(output)\n    }\n}\n\n#[test]\nfn get_works() {\n    let expected_keys = [\n        b\"\\\n            \\x0A\\x0F\\xF5\\x30\\xBD\\x5A\\xB6\\x67\\\n            \\x85\\xC9\\x74\\x6D\\x01\\x33\\xD7\\xE1\\\n            \\x24\\x40\\xC4\\x67\\xA9\\xF0\\x6D\\xCA\\\n            \\xE7\\xED\\x2E\\x78\\x32\\x77\\xE9\\x10\",\n        b\"\\\n            \\x11\\x5A\\xC0\\xB2\\x29\\xA5\\x34\\x10\\\n            \\xB0\\xC0\\x2D\\x47\\x49\\xDC\\x7A\\x09\\\n            \\xB9\\x6D\\xF9\\x51\\xB6\\x1D\\x4F\\x3B\\\n            \\x4E\\x75\\xAC\\x3B\\x14\\x57\\x47\\x96\",\n    ];\n    assert_eq!(DynamicAllocation(0).key(), Key::from(*expected_keys[0]));\n    assert_eq!(DynamicAllocation(1).key(), Key::from(*expected_keys[1]));\n}\n"],["1003","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::{\n    alloc,\n    free,\n    ContractPhase,\n    DynamicAllocation,\n    DynamicAllocator,\n};\nuse crate::{\n    alloc,\n    traits::{\n        KeyPtr,\n        SpreadLayout,\n    },\n};\nuse ink_env::{\n    test,\n    DefaultEnvironment,\n};\nuse ink_primitives::Key;\n\nfn run_default_test<F>(f: F)\nwhere\n    F: FnOnce(),\n{\n    alloc::initialize(ContractPhase::Deploy);\n    test::run_test::<DefaultEnvironment, _>(|_| {\n        f();\n        Ok(())\n    })\n    .unwrap();\n}\n\n#[test]\nfn alloc_works() {\n    run_default_test(|| {\n        assert_eq!(alloc(), DynamicAllocation(0));\n    })\n}\n\ncfg_if::cfg_if! {\n    if #[cfg(miri)] {\n        // We need to lower the test allocations because miri's stacked borrows\n        // analysis currently is super linear for some work loads.\n        // Read more here: https://github.com/rust-lang/miri/issues/1367\n        const TEST_ALLOCATIONS: u32 = 10;\n    } else {\n        const TEST_ALLOCATIONS: u32 = 10_000;\n    }\n}\n\n#[test]\nfn many_allocs_works() {\n    run_default_test(|| {\n        for i in 0..TEST_ALLOCATIONS {\n            assert_eq!(alloc(), DynamicAllocation(i));\n        }\n    })\n}\n\n#[test]\nfn free_works() {\n    run_default_test(|| {\n        // Check that this pattern does not panic.\n        free(alloc());\n    })\n}\n\n#[test]\nfn many_alloc_and_free_works() {\n    run_default_test(|| {\n        for i in 0..TEST_ALLOCATIONS {\n            assert_eq!(alloc(), DynamicAllocation(i));\n        }\n        for i in 0..TEST_ALLOCATIONS {\n            free(DynamicAllocation(i))\n        }\n        assert_eq!(alloc(), DynamicAllocation(0));\n    })\n}\n\n#[test]\nfn alloc_free_in_the_middle() {\n    run_default_test(|| {\n        for i in 0..TEST_ALLOCATIONS {\n            assert_eq!(alloc(), DynamicAllocation(i));\n        }\n        for i in 0..TEST_ALLOCATIONS {\n            free(DynamicAllocation(i));\n            assert_eq!(alloc(), DynamicAllocation(i));\n        }\n    })\n}\n\n#[test]\n#[should_panic(expected = \"encountered double free of dynamic storage: at index 0\")]\nfn double_free_panics() {\n    run_default_test(|| {\n        let a0 = alloc();\n        let _ = alloc();\n        free(a0);\n        free(a0);\n    })\n}\n\n#[test]\n#[should_panic(expected = \"invalid dynamic storage allocation\")]\nfn free_out_of_bounds() {\n    run_default_test(|| {\n        free(DynamicAllocation(0));\n    })\n}\n\nfn spread_layout_alloc_setup() -> DynamicAllocator {\n    let mut alloc = DynamicAllocator::default();\n    assert_eq!(alloc.alloc(), DynamicAllocation(0));\n    assert_eq!(alloc.alloc(), DynamicAllocation(1));\n    assert_eq!(alloc.alloc(), DynamicAllocation(2));\n    assert_eq!(alloc.alloc(), DynamicAllocation(3));\n    assert_eq!(alloc.alloc(), DynamicAllocation(4));\n    alloc.free(DynamicAllocation(3));\n    alloc.free(DynamicAllocation(1));\n    alloc\n}\n\n#[test]\nfn spread_pull_push_works() {\n    run_default_test(|| {\n        let mut alloc = spread_layout_alloc_setup();\n        let root_key = Key::from([0x77; 32]);\n        // Push the current state of the dynamic storage allocator to the storage:\n        SpreadLayout::push_spread(&alloc, &mut KeyPtr::from(root_key));\n        // Now check if the new allocations are filling the freed ones:\n        assert_eq!(alloc.alloc(), DynamicAllocation(1));\n        assert_eq!(alloc.alloc(), DynamicAllocation(3));\n        // Pull another instance of the storage allocator from storage,\n        // then check if both allocators are equal after also allocating the same\n        // allocation slots:\n        let mut alloc2 =\n            <DynamicAllocator as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n        assert_eq!(alloc2.alloc(), DynamicAllocation(1));\n        assert_eq!(alloc2.alloc(), DynamicAllocation(3));\n        assert_eq!(alloc2, alloc);\n    })\n}\n\n#[test]\n#[should_panic(expected = \"encountered empty storage cell\")]\nfn spread_clear_works() {\n    run_default_test(|| {\n        let alloc = spread_layout_alloc_setup();\n        let root_key = Key::from([0x42; 32]);\n        // Push the current state of the dynamic storage allocator to the storage:\n        SpreadLayout::push_spread(&alloc, &mut KeyPtr::from(root_key));\n        // Pull another instance of the storage allocator from storage,\n        // then check if both allocators are equal after also allocating the same\n        // allocation slots:\n        let alloc2 =\n            <DynamicAllocator as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n        assert_eq!(alloc2, alloc);\n        // Now clear the storage associated with `alloc2` again and test if another\n        // loaded instance from the same storage region panics upon pulling:\n        SpreadLayout::clear_spread(&alloc2, &mut KeyPtr::from(root_key));\n        // We have to prevent calling `Drop` of `alloc3` since it has been created\n        // deliberately upon invalid contract storage. Since interacting with `alloc3`\n        // panics which immediately initiates the dropping routines we have to\n        // wrap it in `ManuallyDrop` before we interact with it to avoid to panic\n        // while panicking.\n        let alloc3 =\n            <DynamicAllocator as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n        let mut alloc3 = core::mem::ManuallyDrop::new(alloc3);\n        // Now interact with `alloc3` to make it load from the invalid storage:\n        let _ = alloc3.alloc();\n    })\n}\n\n#[test]\nfn test_call_setup_works() {\n    test::run_test::<DefaultEnvironment, _>(|_| {\n        let mut allocator = DynamicAllocator::default();\n        assert_eq!(allocator.alloc(), DynamicAllocation(0));\n        assert_eq!(allocator.alloc(), DynamicAllocation(1));\n        let root_key = Key::from([0xFE; 32]);\n        DynamicAllocator::push_spread(&allocator, &mut KeyPtr::from(root_key));\n        alloc::initialize(ContractPhase::Call);\n        assert_eq!(alloc(), DynamicAllocation(2));\n        assert_eq!(alloc(), DynamicAllocation(3));\n        free(DynamicAllocation(0));\n        free(DynamicAllocation(2));\n        Ok(())\n    })\n    .unwrap();\n}\n"],["1004","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::traits::{\n    KeyPtr,\n    PackedLayout,\n    SpreadLayout,\n};\nuse ink_primitives::Key;\n\nmacro_rules! impl_layout_for_tuple {\n    ( $($frag:ident),* $(,)? ) => {\n        impl<$($frag),*> SpreadLayout for ($($frag),* ,)\n        where\n            $(\n                $frag: SpreadLayout,\n            )*\n        {\n            const FOOTPRINT: u64 = 0 $(+ <$frag as SpreadLayout>::FOOTPRINT)*;\n            const REQUIRES_DEEP_CLEAN_UP: bool = false $(|| <$frag as SpreadLayout>::REQUIRES_DEEP_CLEAN_UP)*;\n\n            fn push_spread(&self, ptr: &mut KeyPtr) {\n                #[allow(non_snake_case)]\n                let ($($frag),*,) = self;\n                $(\n                    <$frag as SpreadLayout>::push_spread($frag, ptr);\n                )*\n            }\n\n            fn clear_spread(&self, ptr: &mut KeyPtr) {\n                #[allow(non_snake_case)]\n                let ($($frag),*,) = self;\n                $(\n                    <$frag as SpreadLayout>::clear_spread($frag, ptr);\n                )*\n            }\n\n            fn pull_spread(ptr: &mut KeyPtr) -> Self {\n                (\n                    $(\n                        <$frag as SpreadLayout>::pull_spread(ptr),\n                    )*\n                )\n            }\n        }\n\n        impl<$($frag),*> PackedLayout for ($($frag),* ,)\n        where\n            $(\n                $frag: PackedLayout,\n            )*\n        {\n            #[inline]\n            fn push_packed(&self, at: &Key) {\n                #[allow(non_snake_case)]\n                let ($($frag),*,) = self;\n                $(\n                    <$frag as PackedLayout>::push_packed($frag, at);\n                )*\n            }\n\n            #[inline]\n            fn clear_packed(&self, at: &Key) {\n                #[allow(non_snake_case)]\n                let ($($frag),*,) = self;\n                $(\n                    <$frag as PackedLayout>::clear_packed($frag, at);\n                )*\n            }\n\n            #[inline]\n            fn pull_packed(&mut self, at: &Key) {\n                #[allow(non_snake_case)]\n                let ($($frag),*,) = self;\n                $(\n                    <$frag as PackedLayout>::pull_packed($frag, at);\n                )*\n            }\n        }\n    }\n}\nimpl_layout_for_tuple!(A);\nimpl_layout_for_tuple!(A, B);\nimpl_layout_for_tuple!(A, B, C);\nimpl_layout_for_tuple!(A, B, C, D);\nimpl_layout_for_tuple!(A, B, C, D, E);\nimpl_layout_for_tuple!(A, B, C, D, E, F);\nimpl_layout_for_tuple!(A, B, C, D, E, F, G);\nimpl_layout_for_tuple!(A, B, C, D, E, F, G, H);\nimpl_layout_for_tuple!(A, B, C, D, E, F, G, H, I);\nimpl_layout_for_tuple!(A, B, C, D, E, F, G, H, I, J);\n\n#[cfg(test)]\nmod tests {\n    use crate::push_pull_works_for_primitive;\n\n    type TupleSix = (i32, u32, String, u8, bool, Box<Option<i32>>);\n    push_pull_works_for_primitive!(\n        TupleSix,\n        [\n            (\n                -1,\n                1,\n                String::from(\"foobar\"),\n                13,\n                true,\n                Box::new(Some(i32::MIN))\n            ),\n            (\n                i32::MIN,\n                u32::MAX,\n                String::from(\"â¤ â™¡ â¤ â™¡ â¤\"),\n                Default::default(),\n                false,\n                Box::new(Some(i32::MAX))\n            ),\n            (\n                Default::default(),\n                Default::default(),\n                Default::default(),\n                Default::default(),\n                Default::default(),\n                Default::default()\n            )\n        ]\n    );\n}\n"],["1005","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::traits::{\n    impls::{\n        forward_clear_packed,\n        forward_pull_packed,\n        forward_push_packed,\n    },\n    KeyPtr,\n    PackedLayout,\n    SpreadLayout,\n};\nuse ink_prelude::{\n    collections::{\n        BTreeMap as StdBTreeMap,\n        BTreeSet as StdBTreeSet,\n        BinaryHeap as StdBinaryHeap,\n        LinkedList as StdLinkedList,\n        VecDeque as StdVecDeque,\n    },\n    vec::Vec,\n};\nuse ink_primitives::Key;\n\nimpl<K, V> SpreadLayout for StdBTreeMap<K, V>\nwhere\n    K: PackedLayout + Ord,\n    V: PackedLayout,\n{\n    const FOOTPRINT: u64 = 1;\n    const REQUIRES_DEEP_CLEAN_UP: bool = <V as SpreadLayout>::REQUIRES_DEEP_CLEAN_UP;\n\n    #[inline]\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        forward_pull_packed::<Self>(ptr)\n    }\n\n    #[inline]\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        forward_push_packed::<Self>(self, ptr)\n    }\n\n    #[inline]\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        forward_clear_packed::<Self>(self, ptr)\n    }\n}\n\nimpl<K, V> PackedLayout for StdBTreeMap<K, V>\nwhere\n    K: PackedLayout + Ord,\n    V: PackedLayout,\n{\n    fn push_packed(&self, at: &Key) {\n        for (key, val) in self {\n            <K as PackedLayout>::push_packed(key, at);\n            <V as PackedLayout>::push_packed(val, at);\n        }\n    }\n\n    fn clear_packed(&self, at: &Key) {\n        for (key, val) in self {\n            <K as PackedLayout>::clear_packed(key, at);\n            <V as PackedLayout>::clear_packed(val, at);\n        }\n    }\n\n    fn pull_packed(&mut self, at: &Key) {\n        // We cannot mutate keys in a map so we can forward pull signals\n        // only to the values of a map.\n        for val in self.values_mut() {\n            <V as PackedLayout>::pull_packed(val, at);\n        }\n    }\n}\n\nimpl<T> SpreadLayout for StdBTreeSet<T>\nwhere\n    T: PackedLayout + Ord,\n{\n    const FOOTPRINT: u64 = 1;\n    const REQUIRES_DEEP_CLEAN_UP: bool = <T as SpreadLayout>::REQUIRES_DEEP_CLEAN_UP;\n\n    #[inline]\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        forward_pull_packed::<Self>(ptr)\n    }\n\n    #[inline]\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        forward_push_packed::<Self>(self, ptr)\n    }\n\n    #[inline]\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        forward_clear_packed::<Self>(self, ptr)\n    }\n}\n\nimpl<T> PackedLayout for StdBTreeSet<T>\nwhere\n    T: PackedLayout + Ord,\n{\n    fn push_packed(&self, at: &Key) {\n        for key in self {\n            <T as PackedLayout>::push_packed(key, at);\n        }\n    }\n\n    fn clear_packed(&self, at: &Key) {\n        for key in self {\n            <T as PackedLayout>::clear_packed(key, at);\n        }\n    }\n\n    #[inline(always)]\n    fn pull_packed(&mut self, _at: &Key) {\n        // We cannot mutate keys in a set so we cannot forward pull signals.\n    }\n}\n\nimpl<T> SpreadLayout for StdBinaryHeap<T>\nwhere\n    T: PackedLayout + Ord,\n{\n    const FOOTPRINT: u64 = 1;\n    const REQUIRES_DEEP_CLEAN_UP: bool = <T as SpreadLayout>::REQUIRES_DEEP_CLEAN_UP;\n\n    #[inline]\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        forward_pull_packed::<Self>(ptr)\n    }\n\n    #[inline]\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        forward_push_packed::<Self>(self, ptr)\n    }\n\n    #[inline]\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        forward_clear_packed::<Self>(self, ptr)\n    }\n}\n\nimpl<T> PackedLayout for StdBinaryHeap<T>\nwhere\n    T: PackedLayout + Ord,\n{\n    fn push_packed(&self, at: &Key) {\n        for value in self {\n            <T as PackedLayout>::push_packed(value, at);\n        }\n    }\n\n    fn clear_packed(&self, at: &Key) {\n        for value in self {\n            <T as PackedLayout>::clear_packed(value, at);\n        }\n    }\n\n    #[inline(always)]\n    fn pull_packed(&mut self, _at: &Key) {\n        // We cannot mutate keys in a heap so we cannot forward pull signals.\n    }\n}\n\nmacro_rules! impl_push_at_for_collection {\n    ( $($collection:ident),* $(,)? ) => {\n        $(\n            impl_always_packed_layout!($collection<T>, deep: <T as SpreadLayout>::REQUIRES_DEEP_CLEAN_UP);\n\n            impl<T> PackedLayout for $collection<T>\n            where\n                T: PackedLayout,\n            {\n                fn push_packed(&self, at: &Key) {\n                    for elem in self {\n                        <T as PackedLayout>::push_packed(elem, at)\n                    }\n                }\n\n                fn clear_packed(&self, at: &Key) {\n                    for elem in self {\n                        <T as PackedLayout>::clear_packed(elem, at)\n                    }\n                }\n\n                fn pull_packed(&mut self, at: &Key) {\n                    for elem in self {\n                        <T as PackedLayout>::pull_packed(elem, at)\n                    }\n                }\n            }\n        )*\n    };\n}\nimpl_push_at_for_collection!(Vec, StdLinkedList, StdVecDeque,);\n"],["1006","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::max;\nuse crate::traits::{\n    KeyPtr,\n    PackedLayout,\n    SpreadLayout,\n};\nuse ink_env::{\n    AccountId,\n    Hash,\n};\nuse ink_prelude::{\n    boxed::Box,\n    string::String,\n};\nuse ink_primitives::Key;\n\nmacro_rules! impl_layout_for_primitive {\n    ( $($ty:ty),* $(,)? ) => {\n        $(\n            impl_always_packed_layout!($ty, deep: false);\n            impl PackedLayout for $ty {\n                #[inline(always)]\n                fn pull_packed(&mut self, _at: &Key) {}\n                #[inline(always)]\n                fn push_packed(&self, _at: &Key) {}\n                #[inline(always)]\n                fn clear_packed(&self, _at: &Key) {}\n            }\n        )*\n    };\n}\n#[rustfmt::skip]\nimpl_layout_for_primitive!(\n    // We do not include `f32` and `f64` since Wasm contracts currently\n    // do not support them since they are non deterministic. We might add them\n    // to this list once we add deterministic support for those primitives.\n    Key, Hash, AccountId, (),\n    String,\n    bool,\n    u8, u16, u32, u64, u128,\n    i8, i16, i32, i64, i128,\n);\n\nimpl<T> SpreadLayout for Option<T>\nwhere\n    T: SpreadLayout,\n{\n    const FOOTPRINT: u64 = 1 + <T as SpreadLayout>::FOOTPRINT;\n    const REQUIRES_DEEP_CLEAN_UP: bool = <T as SpreadLayout>::REQUIRES_DEEP_CLEAN_UP;\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        <u8 as SpreadLayout>::push_spread(&(self.is_some() as u8), ptr);\n        if let Some(value) = self {\n            <T as SpreadLayout>::push_spread(value, ptr);\n        } else {\n            ptr.advance_by(<T as SpreadLayout>::FOOTPRINT);\n        }\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        // We do not really need the reference to 0 (zero)\n        // in order to clean-up the `bool` value from the storage.\n        // However the API is demanding a reference so we give it one.\n        <u8 as SpreadLayout>::clear_spread(&0, ptr);\n        if let Some(value) = self {\n            <T as SpreadLayout>::clear_spread(value, ptr)\n        } else {\n            ptr.advance_by(<T as SpreadLayout>::FOOTPRINT);\n        }\n    }\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        match <u8 as SpreadLayout>::pull_spread(ptr) {\n            0u8 => {\n                ptr.advance_by(<T as SpreadLayout>::FOOTPRINT);\n                None\n            }\n            1u8 => Some(<T as SpreadLayout>::pull_spread(ptr)),\n            _ => unreachable!(\"invalid Option discriminant\"),\n        }\n    }\n}\n\nimpl<T> PackedLayout for Option<T>\nwhere\n    T: PackedLayout,\n{\n    #[inline]\n    fn push_packed(&self, at: &Key) {\n        if let Some(value) = self {\n            <T as PackedLayout>::push_packed(value, at)\n        }\n    }\n\n    #[inline]\n    fn clear_packed(&self, at: &Key) {\n        if let Some(value) = self {\n            <T as PackedLayout>::clear_packed(value, at)\n        }\n    }\n\n    #[inline]\n    fn pull_packed(&mut self, at: &Key) {\n        if let Some(value) = self {\n            <T as PackedLayout>::pull_packed(value, at)\n        }\n    }\n}\n\nimpl<T, E> SpreadLayout for Result<T, E>\nwhere\n    T: SpreadLayout,\n    E: SpreadLayout,\n{\n    const FOOTPRINT: u64 = 1 + max(\n        <T as SpreadLayout>::FOOTPRINT,\n        <E as SpreadLayout>::FOOTPRINT,\n    );\n    const REQUIRES_DEEP_CLEAN_UP: bool = <T as SpreadLayout>::REQUIRES_DEEP_CLEAN_UP\n        || <E as SpreadLayout>::REQUIRES_DEEP_CLEAN_UP;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        match <u8 as SpreadLayout>::pull_spread(ptr) {\n            0 => Ok(<T as SpreadLayout>::pull_spread(ptr)),\n            1 => Err(<E as SpreadLayout>::pull_spread(ptr)),\n            _ => unreachable!(\"invalid Result discriminant\"),\n        }\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        match self {\n            Ok(value) => {\n                <u8 as SpreadLayout>::push_spread(&0, ptr);\n                <T as SpreadLayout>::push_spread(value, ptr);\n            }\n            Err(error) => {\n                <u8 as SpreadLayout>::push_spread(&1, ptr);\n                <E as SpreadLayout>::push_spread(error, ptr);\n            }\n        }\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        // Clear the discriminant, same for all variants.\n        <u8 as SpreadLayout>::clear_spread(&0, ptr);\n        match self {\n            Ok(value) => {\n                <T as SpreadLayout>::clear_spread(value, ptr);\n            }\n            Err(error) => {\n                <E as SpreadLayout>::clear_spread(error, ptr);\n            }\n        }\n    }\n}\n\nimpl<T, E> PackedLayout for Result<T, E>\nwhere\n    T: PackedLayout,\n    E: PackedLayout,\n{\n    #[inline]\n    fn push_packed(&self, at: &Key) {\n        match self {\n            Ok(value) => <T as PackedLayout>::push_packed(value, at),\n            Err(error) => <E as PackedLayout>::push_packed(error, at),\n        }\n    }\n\n    #[inline]\n    fn clear_packed(&self, at: &Key) {\n        match self {\n            Ok(value) => <T as PackedLayout>::clear_packed(value, at),\n            Err(error) => <E as PackedLayout>::clear_packed(error, at),\n        }\n    }\n\n    #[inline]\n    fn pull_packed(&mut self, at: &Key) {\n        match self {\n            Ok(value) => <T as PackedLayout>::pull_packed(value, at),\n            Err(error) => <E as PackedLayout>::pull_packed(error, at),\n        }\n    }\n}\n\nimpl<T> SpreadLayout for Box<T>\nwhere\n    T: SpreadLayout,\n{\n    const FOOTPRINT: u64 = <T as SpreadLayout>::FOOTPRINT;\n    const REQUIRES_DEEP_CLEAN_UP: bool = <T as SpreadLayout>::REQUIRES_DEEP_CLEAN_UP;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        Box::new(<T as SpreadLayout>::pull_spread(ptr))\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        <T as SpreadLayout>::push_spread(&*self, ptr)\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        <T as SpreadLayout>::clear_spread(&*self, ptr)\n    }\n}\n\nimpl<T> PackedLayout for Box<T>\nwhere\n    T: PackedLayout,\n{\n    #[inline]\n    fn push_packed(&self, at: &Key) {\n        <T as PackedLayout>::push_packed(&*self, at)\n    }\n\n    #[inline]\n    fn clear_packed(&self, at: &Key) {\n        <T as PackedLayout>::clear_packed(&*self, at)\n    }\n\n    #[inline]\n    fn pull_packed(&mut self, at: &Key) {\n        <T as PackedLayout>::pull_packed(&mut *self, at)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::push_pull_works_for_primitive;\n    use ink_env::AccountId;\n    use ink_primitives::Key;\n\n    push_pull_works_for_primitive!(bool, [false, true]);\n    push_pull_works_for_primitive!(\n        String,\n        [Default::default(), String::from(\"Hello, World!\")]\n    );\n    push_pull_works_for_primitive!(\n        Key,\n        [\n            Key::from([0x00; 32]),\n            Key::from([0x42; 32]),\n            Key::from([0xFF; 32])\n        ]\n    );\n    push_pull_works_for_primitive!(\n        AccountId,\n        [\n            AccountId::from([0x00; 32]),\n            AccountId::from([0x42; 32]),\n            AccountId::from([0xFF; 32])\n        ]\n    );\n    push_pull_works_for_primitive!(i8, [0, Default::default(), 1, i8::MIN, i8::MAX]);\n    push_pull_works_for_primitive!(i16, [0, Default::default(), 2, i16::MIN, i16::MAX]);\n    push_pull_works_for_primitive!(i32, [0, Default::default(), 3, i32::MIN, i32::MAX]);\n    push_pull_works_for_primitive!(i64, [0, Default::default(), 4, i64::MIN, i64::MAX]);\n    push_pull_works_for_primitive!(\n        i128,\n        [0, Default::default(), 5, i128::MIN, i128::MAX]\n    );\n    push_pull_works_for_primitive!(u8, [0, Default::default(), 10, u8::MIN, u8::MAX]);\n    push_pull_works_for_primitive!(u16, [0, Default::default(), 20, u16::MIN, u16::MAX]);\n    push_pull_works_for_primitive!(u32, [0, Default::default(), 30, u32::MIN, u32::MAX]);\n    push_pull_works_for_primitive!(u64, [0, Default::default(), 40, u64::MIN, u64::MAX]);\n    push_pull_works_for_primitive!(\n        u128,\n        [0, Default::default(), 50, u128::MIN, u128::MAX]\n    );\n\n    type OptionU8 = Option<u8>;\n    push_pull_works_for_primitive!(OptionU8, [Some(13u8), None]);\n\n    type ResultU8 = Result<u8, bool>;\n    push_pull_works_for_primitive!(ResultU8, [Ok(13u8), Err(false)]);\n\n    type BoxU8 = Box<u8>;\n    push_pull_works_for_primitive!(BoxU8, [Box::new(27u8)]);\n\n    type BoxOptionU8 = Box<Option<u8>>;\n    push_pull_works_for_primitive!(BoxOptionU8, [Box::new(Some(27)), Box::new(None)]);\n}\n"],["1007","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::traits::{\n    KeyPtr,\n    PackedLayout,\n    SpreadLayout,\n};\nuse array_init::array_init;\nuse ink_primitives::Key;\n\n#[rustfmt::skip]\nmacro_rules! forward_supported_array_lens {\n    ( $mac:ident ) => {\n        $mac! {\n                 1,  2,  3,  4,  5,  6,  7,  8,  9,\n            10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n            20, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n            30, 31, 32,\n        }\n    };\n}\n\nmacro_rules! impl_layout_for_array {\n    ( $($len:literal),* $(,)? ) => {\n        $(\n            impl<T> SpreadLayout for [T; $len]\n            where\n                T: SpreadLayout,\n            {\n                const FOOTPRINT: u64 = $len * <T as SpreadLayout>::FOOTPRINT;\n                const REQUIRES_DEEP_CLEAN_UP: bool = <T as SpreadLayout>::REQUIRES_DEEP_CLEAN_UP;\n\n                fn push_spread(&self, ptr: &mut KeyPtr) {\n                    for elem in self {\n                        <T as SpreadLayout>::push_spread(elem, ptr)\n                    }\n                }\n\n                fn clear_spread(&self, ptr: &mut KeyPtr) {\n                    for elem in self {\n                        <T as SpreadLayout>::clear_spread(elem, ptr)\n                    }\n                }\n\n                fn pull_spread(ptr: &mut KeyPtr) -> Self {\n                    array_init::<Self, _>(|_| <T as SpreadLayout>::pull_spread(ptr))\n                }\n            }\n\n            impl<T> PackedLayout for [T; $len]\n            where\n                T: PackedLayout,\n            {\n                #[inline]\n                fn push_packed(&self, at: &Key) {\n                    for elem in self {\n                        <T as PackedLayout>::push_packed(elem, at)\n                    }\n                }\n\n                #[inline]\n                fn clear_packed(&self, at: &Key) {\n                    for elem in self {\n                        <T as PackedLayout>::clear_packed(elem, at)\n                    }\n                }\n\n                #[inline]\n                fn pull_packed(&mut self, at: &Key) {\n                    for elem in self {\n                        <T as PackedLayout>::pull_packed(elem, at)\n                    }\n                }\n            }\n        )*\n    }\n}\nforward_supported_array_lens!(impl_layout_for_array);\n\n#[cfg(test)]\nmod tests {\n    use crate::push_pull_works_for_primitive;\n\n    type Array = [i32; 4];\n    push_pull_works_for_primitive!(\n        Array,\n        [\n            [0, 1, 2, 3],\n            [i32::MAX, i32::MIN, i32::MAX, i32::MIN],\n            [Default::default(), i32::MAX, Default::default(), i32::MIN]\n        ]\n    );\n\n    type ArrayTuples = [(i32, i32); 2];\n    push_pull_works_for_primitive!(\n        ArrayTuples,\n        [\n            [(0, 1), (2, 3)],\n            [(i32::MAX, i32::MIN), (i32::MIN, i32::MAX)],\n            [\n                (Default::default(), i32::MAX),\n                (Default::default(), i32::MIN)\n            ]\n        ]\n    );\n}\n"],["1008","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Fuzz tests for some storage primitives.\n\n#[cfg(all(test, feature = \"std\", feature = \"ink-fuzz-tests\"))]\nuse quickcheck::TestResult;\n\n#[cfg(all(test, feature = \"std\", feature = \"ink-fuzz-tests\"))]\nuse std::convert::AsMut;\n\n///  Receives a slice, returns an array.\nfn clone_into_array<A, T>(slice: &[T]) -> A\nwhere\n    A: Default + AsMut<[T]>,\n    T: Clone,\n{\n    let mut a = A::default();\n    <A as AsMut<[T]>>::as_mut(&mut a).clone_from_slice(slice);\n    a\n}\n\n/// Tests if a fuzzed `[i32; 32]` array results in the same object when\n/// pushed/pulled from storage (for `spread` and `packed`).\n#[quickcheck]\nfn fuzz_pull_push_pull_array(x: Vec<i32>) -> TestResult {\n    // We want to have only vectors of length 32 fuzzed in here.\n    // The reason is that quickcheck does not directly support\n    // Array's as a parameter to be fuzzed. So we use this\n    // workaround of asking for a Vec with length 32 and convert\n    // it to an array with 32 elements subsequently.\n    //\n    // The guided fuzzing will notice that every Vec of greater/smaller\n    // length is always discarded and aim to input vectors of length 32.\n    if x.len() != 32 {\n        return TestResult::discard()\n    }\n\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let key = ink_primitives::Key::from([0x42; 32]);\n        let key2 = ink_primitives::Key::from([0x77; 32]);\n\n        let arr: [i32; 32] = clone_into_array(&x[0..32]);\n        crate::traits::push_spread_root(&arr, &key);\n\n        let y: [i32; 32] = crate::traits::pull_spread_root(&key);\n        assert_eq!(arr, y);\n\n        crate::traits::push_packed_root(&arr, &key2);\n        let z: [i32; 32] = crate::traits::pull_packed_root(&key2);\n        assert_eq!(arr, z);\n\n        Ok(())\n    })\n    .unwrap();\n    TestResult::from_bool(true)\n}\n\n/// Tests if a fuzzed `String` results in the same object when pushed/pulled\n/// from storage (for `spread` and `packed`).\n#[cfg(feature = \"ink-fuzz-tests\")]\n#[quickcheck]\nfn fuzz_pull_push_pull_string(x: String) {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let key = ink_primitives::Key::from([0x42; 32]);\n        let key2 = ink_primitives::Key::from([0x77; 32]);\n\n        crate::traits::push_spread_root(&x, &key);\n        let y: String = crate::traits::pull_spread_root(&key);\n        assert_eq!(x, y);\n\n        crate::traits::push_packed_root(&x, &key2);\n        let z: String = crate::traits::pull_packed_root(&key2);\n        assert_eq!(x, z);\n        Ok(())\n    })\n    .unwrap()\n}\n"],["1009","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::traits::ExtKeyPtr as _;\n\nmacro_rules! impl_always_packed_layout {\n    ( $name:ident < $($frag:ident),+ >, deep: $deep:expr ) => {\n        const _: () = {\n            use crate::traits::impls::{\n                forward_clear_packed,\n                forward_pull_packed,\n                forward_push_packed,\n            };\n            impl<$($frag),+> SpreadLayout for $name < $($frag),+ >\n            where\n                $(\n                    $frag: PackedLayout,\n                )+\n            {\n                const FOOTPRINT: u64 = 1;\n\n                const REQUIRES_DEEP_CLEAN_UP: bool = $deep;\n\n                #[inline]\n                fn pull_spread(ptr: &mut KeyPtr) -> Self {\n                    forward_pull_packed::<Self>(ptr)\n                }\n\n                #[inline]\n                fn push_spread(&self, ptr: &mut KeyPtr) {\n                    forward_push_packed::<Self>(self, ptr)\n                }\n\n                #[inline]\n                fn clear_spread(&self, ptr: &mut KeyPtr) {\n                    forward_clear_packed::<Self>(self, ptr)\n                }\n            }\n        };\n    };\n    ( $name:ty, deep: $deep:expr ) => {\n        const _: () = {\n            use crate::traits::impls::{\n                forward_clear_packed,\n                forward_pull_packed,\n                forward_push_packed,\n            };\n            impl SpreadLayout for $name\n            where\n                Self: PackedLayout,\n            {\n                const FOOTPRINT: u64 = 1;\n\n                const REQUIRES_DEEP_CLEAN_UP: bool = $deep;\n\n                #[inline]\n                fn pull_spread(ptr: &mut KeyPtr) -> Self {\n                    forward_pull_packed::<Self>(ptr)\n                }\n\n                #[inline]\n                fn push_spread(&self, ptr: &mut KeyPtr) {\n                    forward_push_packed::<Self>(self, ptr)\n                }\n\n                #[inline]\n                fn clear_spread(&self, ptr: &mut KeyPtr) {\n                    forward_clear_packed::<Self>(self, ptr)\n                }\n            }\n        };\n    };\n}\n\nmod arrays;\nmod collections;\nmod prims;\nmod tuples;\n\n#[cfg(all(test, feature = \"ink-fuzz-tests\"))]\nmod fuzz_tests;\n\nuse super::{\n    clear_packed_root,\n    pull_packed_root,\n    push_packed_root,\n    PackedLayout,\n};\nuse crate::traits::KeyPtr;\n\n/// Returns the greater of both values.\nconst fn max(a: u64, b: u64) -> u64 {\n    [a, b][(a > b) as usize]\n}\n\n/// Pulls an instance of type `T` in packed fashion from the contract storage.\n///\n/// Loads the instance from the storage location identified by `ptr`.\n/// The storage entity is expected to be decodable in its packed form.\n///\n/// # Note\n///\n/// Use this utility function to use a packed pull operation for the type\n/// instead of a spreaded pull operation.\n#[inline]\npub fn forward_pull_packed<T>(ptr: &mut KeyPtr) -> T\nwhere\n    T: PackedLayout,\n{\n    pull_packed_root::<T>(&ptr.next_for::<T>())\n}\n\n/// Pushes an instance of type `T` in packed fashion to the contract storage.\n///\n/// Stores the instance to the storage location identified by `ptr`.\n/// The storage entity is expected to be encodable in its packed form.\n///\n/// # Note\n///\n/// Use this utility function to use a packed push operation for the type\n/// instead of a spreaded push operation.\n#[inline]\npub fn forward_push_packed<T>(entity: &T, ptr: &mut KeyPtr)\nwhere\n    T: PackedLayout,\n{\n    push_packed_root::<T>(entity, &ptr.next_for::<T>())\n}\n\n/// Clears an instance of type `T` in packed fashion from the contract storage.\n///\n/// Clears the instance from the storage location identified by `ptr`.\n/// The cleared storage entity is expected to be encoded in its packed form.\n///\n/// # Note\n///\n/// Use this utility function to use a packed clear operation for the type\n/// instead of a spreaded clear operation.\n#[inline]\npub fn forward_clear_packed<T>(entity: &T, ptr: &mut KeyPtr)\nwhere\n    T: PackedLayout,\n{\n    clear_packed_root::<T>(entity, &ptr.next_for::<T>())\n}\n"],["1010","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::SpreadLayout;\nuse ink_primitives::Key;\n\n/// Types that can be stored to and loaded from a single contract storage cell.\npub trait PackedLayout: SpreadLayout + scale::Encode + scale::Decode {\n    /// Indicates to `self` that is has just been pulled from the storage.\n    ///\n    /// # Note\n    ///\n    /// Most types will have to implement a simple forwarding to their fields.\n    /// However, some types such as [`storage::Box`](`crate::Box`)\n    /// are required to perform some special handling upon receiving this signal.\n    fn pull_packed(&mut self, at: &Key);\n\n    /// Indicates to `self` that it is about to be pushed to contract storage.\n    ///\n    /// # Note\n    ///\n    /// Most types will have to implement a simple forwarding to their fields.\n    /// However, some types such as [`storage::Box`](`crate::Box`)\n    /// are required to perform some special handling upon receiving this signal.\n    fn push_packed(&self, at: &Key);\n\n    /// Indicates to `self` that it is about to be cleared from contract storage.\n    ///\n    /// # Note\n    ///\n    /// Most types will have to implement a simple forwarding to their fields.\n    /// However, some types such as [`storage::Box`](`crate::Box`)\n    /// are required to perform some special handling upon receiving this signal.\n    fn clear_packed(&self, at: &Key);\n}\n"],["1011","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::KeyPtr;\n\n/// This constant is used by some types to make sure that cleaning up\n/// behind them won't become way too expensive. Since we are missing\n/// Substrate's storage bulk removal feature we cannot do better than\n/// this at the moment.\n/// The number is arbitrarily chosen. Might need adjustments later.\npub const FOOTPRINT_CLEANUP_THRESHOLD: u64 = 32;\n\n/// Types that can be stored to and loaded from the contract storage.\npub trait SpreadLayout {\n    /// The footprint of the type.\n    ///\n    /// This is the number of adjunctive cells the type requires in order to\n    /// be stored in the contract storage with spread layout.\n    ///\n    /// # Examples\n    ///\n    /// An instance of type `i32` requires one storage cell so its footprint is\n    /// 1. An instance of type `(i32, i32)` requires 2 storage cells since a\n    /// tuple or any other combined data structure always associates disjunct\n    /// cells for its sub types. The same applies to arrays, e.g. `[i32; 5]`\n    /// has a footprint of 5.\n    const FOOTPRINT: u64;\n\n    /// Indicates whether a type requires deep clean-up of its state meaning that\n    /// a clean-up routine has to decode an entity into an instance in order to\n    /// eventually recurse upon its tear-down.\n    /// This is not required for the majority of primitive data types such as `i32`,\n    /// however types such as `storage::Box` that might want to forward the clean-up\n    /// procedure to their inner `T` require a deep clean-up.\n    ///\n    /// # Note\n    ///\n    /// The default is set to `true` in order to have correctness by default since\n    /// no type invariants break if a deep clean-up is performed on a type that does\n    /// not need it but performing a shallow clean-up for a type that requires a\n    /// deep clean-up would break invariants.\n    /// This is solely a setting to improve performance upon clean-up for some types.\n    const REQUIRES_DEEP_CLEAN_UP: bool = true;\n\n    /// Pulls an instance of `Self` from the contract storage.\n    ///\n    /// The key pointer denotes the position where the instance is being pulled\n    /// from within the contract storage\n    ///\n    /// # Note\n    ///\n    /// This method of pulling is depth-first: Sub-types are pulled first and\n    /// construct the super-type through this procedure.\n    fn pull_spread(ptr: &mut KeyPtr) -> Self;\n\n    /// Pushes an instance of `Self` to the contract storage.\n    ///\n    /// - Tries to spread `Self` to as many storage cells as possible.\n    /// - The key pointer denotes the position where the instance is being pushed\n    /// to the contract storage.\n    ///\n    /// # Note\n    ///\n    /// This method of pushing is depth-first: Sub-types are pushed before\n    /// their parent or super type.\n    fn push_spread(&self, ptr: &mut KeyPtr);\n\n    /// Clears an instance of `Self` from the contract storage.\n    ///\n    /// - Tries to clean `Self` from contract storage as if `self` was stored\n    ///   in it using spread layout.\n    /// - The key pointer denotes the position where the instance is being cleared\n    ///   from the contract storage.\n    ///\n    /// # Note\n    ///\n    /// This method of clearing is depth-first: Sub-types are cleared before\n    /// their parent or super type.\n    fn clear_spread(&self, ptr: &mut KeyPtr);\n}\n"],["1012","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::StorageLayout;\nuse crate::traits::{\n    ExtKeyPtr as _,\n    KeyPtr,\n    SpreadLayout,\n};\nuse ink_env::{\n    AccountId,\n    Hash,\n};\nuse ink_metadata::layout::{\n    ArrayLayout,\n    CellLayout,\n    Discriminant,\n    EnumLayout,\n    FieldLayout,\n    Layout,\n    LayoutKey,\n    StructLayout,\n};\nuse ink_prelude::{\n    boxed::Box,\n    collections::BTreeMap,\n    string::String,\n    vec::Vec,\n};\nuse ink_primitives::Key;\nuse scale_info::TypeInfo;\n\nmacro_rules! impl_storage_layout_for_primitives {\n    ( $($name:ty),* $(,)? ) => {\n        $(\n            impl StorageLayout for $name {\n                fn layout(key_ptr: &mut KeyPtr) -> Layout {\n                    Layout::Cell(CellLayout::new::<$name>(LayoutKey::from(key_ptr.advance_by(1))))\n                }\n            }\n        )*\n    };\n}\n#[rustfmt::skip]\nimpl_storage_layout_for_primitives!(\n    Key, Hash, AccountId, String,\n    bool, char, (),\n    u8, u16, u32, u64, u128,\n    i8, i16, i32, i64, i128,\n);\n\nmacro_rules! impl_storage_layout_for_arrays {\n    ( $($len:literal),* $(,)? ) => {\n        $(\n            impl<T> StorageLayout for [T; $len]\n            where\n                T: StorageLayout + SpreadLayout,\n            {\n                fn layout(key_ptr: &mut KeyPtr) -> Layout {\n                    let len: u32 = $len;\n                    let elem_footprint = <T as SpreadLayout>::FOOTPRINT;\n                    Layout::Array(ArrayLayout::new(\n                        LayoutKey::from(key_ptr.next_for::<[T; $len]>()),\n                        len,\n                        elem_footprint,\n                        <T as StorageLayout>::layout(&mut key_ptr.clone()),\n                    ))\n                }\n            }\n        )*\n    };\n}\n#[rustfmt::skip]\nimpl_storage_layout_for_arrays!(\n         1,  2,  3,  4,  5,  6,  7,  8,  9,\n    10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n    20, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n    30, 31, 32,\n);\n\nmacro_rules! impl_layout_for_tuple {\n    ( $($frag:ident),* $(,)? ) => {\n        impl<$($frag),*> StorageLayout for ($($frag),* ,)\n        where\n            $(\n                $frag: StorageLayout,\n            )*\n        {\n            fn layout(key_ptr: &mut KeyPtr) -> Layout {\n                Layout::Struct(\n                    StructLayout::new(vec![\n                        $(\n                            FieldLayout::new(None, <$frag as StorageLayout>::layout(key_ptr)),\n                        )*\n                    ])\n                )\n            }\n        }\n    }\n}\nimpl_layout_for_tuple!(A);\nimpl_layout_for_tuple!(A, B);\nimpl_layout_for_tuple!(A, B, C);\nimpl_layout_for_tuple!(A, B, C, D);\nimpl_layout_for_tuple!(A, B, C, D, E);\nimpl_layout_for_tuple!(A, B, C, D, E, F);\nimpl_layout_for_tuple!(A, B, C, D, E, F, G);\nimpl_layout_for_tuple!(A, B, C, D, E, F, G, H);\nimpl_layout_for_tuple!(A, B, C, D, E, F, G, H, I);\nimpl_layout_for_tuple!(A, B, C, D, E, F, G, H, I, J);\n\nimpl<T> StorageLayout for Box<T>\nwhere\n    T: StorageLayout,\n{\n    fn layout(key_ptr: &mut KeyPtr) -> Layout {\n        <T as StorageLayout>::layout(key_ptr)\n    }\n}\n\nimpl<T> StorageLayout for Option<T>\nwhere\n    T: StorageLayout,\n{\n    fn layout(key_ptr: &mut KeyPtr) -> Layout {\n        let dispatch_key = key_ptr.advance_by(1);\n        Layout::Enum(EnumLayout::new(\n            *dispatch_key,\n            vec![\n                (\n                    Discriminant::from(0),\n                    StructLayout::new(vec![FieldLayout::new(\n                        None,\n                        <T as StorageLayout>::layout(&mut key_ptr.clone()),\n                    )]),\n                ),\n                (Discriminant::from(1), StructLayout::new(Vec::new())),\n            ],\n        ))\n    }\n}\n\nimpl<T, E> StorageLayout for Result<T, E>\nwhere\n    T: StorageLayout,\n    E: StorageLayout,\n{\n    fn layout(key_ptr: &mut KeyPtr) -> Layout {\n        let dispatch_key = key_ptr.advance_by(1);\n        Layout::Enum(EnumLayout::new(\n            *dispatch_key,\n            vec![\n                (\n                    Discriminant::from(0),\n                    StructLayout::new(vec![FieldLayout::new(\n                        None,\n                        <T as StorageLayout>::layout(&mut key_ptr.clone()),\n                    )]),\n                ),\n                (\n                    Discriminant::from(1),\n                    StructLayout::new(vec![FieldLayout::new(\n                        None,\n                        <E as StorageLayout>::layout(&mut key_ptr.clone()),\n                    )]),\n                ),\n            ],\n        ))\n    }\n}\n\nimpl<T> StorageLayout for Vec<T>\nwhere\n    T: TypeInfo + 'static,\n{\n    fn layout(key_ptr: &mut KeyPtr) -> Layout {\n        Layout::Cell(CellLayout::new::<Self>(LayoutKey::from(\n            key_ptr.advance_by(1),\n        )))\n    }\n}\n\nimpl<K, V> StorageLayout for BTreeMap<K, V>\nwhere\n    K: TypeInfo + 'static,\n    V: TypeInfo + 'static,\n{\n    fn layout(key_ptr: &mut KeyPtr) -> Layout {\n        Layout::Cell(CellLayout::new::<Self>(LayoutKey::from(\n            key_ptr.advance_by(1),\n        )))\n    }\n}\n"],["1013","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n"],["1014","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nmod impls;\n\n#[cfg(test)]\nmod tests;\n\nuse crate::traits::KeyPtr;\nuse ink_env::hash::{\n    Blake2x256,\n    Keccak256,\n    Sha2x256,\n};\nuse ink_metadata::layout::{\n    CryptoHasher,\n    Layout,\n};\n\n/// Implemented by types that have a storage layout.\npub trait StorageLayout {\n    /// Returns the static storage layout of `Self`.\n    ///\n    /// The given key pointer is guiding the allocation of static fields onto\n    /// the contract storage regions.\n    fn layout(key_ptr: &mut KeyPtr) -> Layout;\n}\n\n/// Types implementing this trait are supported layouting crypto hashers.\npub trait LayoutCryptoHasher {\n    /// Returns the layout crypto hasher for `Self`.\n    fn crypto_hasher() -> CryptoHasher;\n}\n\nimpl LayoutCryptoHasher for Blake2x256 {\n    fn crypto_hasher() -> CryptoHasher {\n        CryptoHasher::Blake2x256\n    }\n}\n\nimpl LayoutCryptoHasher for Sha2x256 {\n    fn crypto_hasher() -> CryptoHasher {\n        CryptoHasher::Sha2x256\n    }\n}\n\nimpl LayoutCryptoHasher for Keccak256 {\n    fn crypto_hasher() -> CryptoHasher {\n        CryptoHasher::Keccak256\n    }\n}\n"],["1015","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Traits and interfaces to operate with storage entities.\n//!\n//! Generally a type is said to be a storage entity if it implements the\n//! `SpreadLayout` trait. This defines certain constants and routines in order\n//! to tell a smart contract how to load and store instances of this type\n//! from and to the contract's storage.\n//!\n//! The `PackedLayout` trait can then be implemented on top of the `SpreadLayout`\n//! for types that further allow to be stored in the contract storage in a more\n//! compressed format to a single storage cell.\n\nmod impls;\nmod keyptr;\nmod optspec;\nmod packed;\nmod spread;\n\n#[cfg(feature = \"std\")]\nmod layout;\n\n#[cfg(feature = \"std\")]\npub use self::layout::{\n    LayoutCryptoHasher,\n    StorageLayout,\n};\npub(crate) use self::optspec::{\n    clear_spread_root_opt,\n    pull_packed_root_opt,\n    pull_spread_root_opt,\n    push_packed_root_opt,\n    push_spread_root_opt,\n};\npub use self::{\n    impls::{\n        forward_clear_packed,\n        forward_pull_packed,\n        forward_push_packed,\n    },\n    keyptr::{\n        ExtKeyPtr,\n        KeyPtr,\n    },\n    packed::PackedLayout,\n    spread::{\n        SpreadLayout,\n        FOOTPRINT_CLEANUP_THRESHOLD,\n    },\n};\npub use ::ink_storage_derive::{\n    PackedLayout,\n    SpreadLayout,\n    StorageLayout,\n};\nuse ink_primitives::Key;\n\n/// Pulls an instance of type `T` from the contract storage using spread layout.\n///\n/// The root key denotes the offset into the contract storage where the\n/// instance of type `T` is being pulled from.\n///\n/// # Note\n///\n/// - The routine assumes that the instance has previously been stored to\n///   the contract storage using spread layout.\n/// - Users should prefer using this function directly instead of using the\n///   trait methods on [`SpreadLayout`].\npub fn pull_spread_root<T>(root_key: &Key) -> T\nwhere\n    T: SpreadLayout,\n{\n    let mut ptr = KeyPtr::from(*root_key);\n    <T as SpreadLayout>::pull_spread(&mut ptr)\n}\n\n/// Clears the entity from the contract storage using spread layout.\n///\n/// The root key denotes the offset into the contract storage where the\n/// instance of type `T` is being cleared from.\n///\n/// # Note\n///\n/// - The routine assumes that the instance has previously been stored to\n///   the contract storage using spread layout.\n/// - Users should prefer using this function directly instead of using the\n///   trait methods on [`SpreadLayout`].\npub fn clear_spread_root<T>(entity: &T, root_key: &Key)\nwhere\n    T: SpreadLayout,\n{\n    let mut ptr = KeyPtr::from(*root_key);\n    <T as SpreadLayout>::clear_spread(entity, &mut ptr);\n}\n\n/// Pushes the entity to the contract storage using spread layout.\n///\n/// The root key denotes the offset into the contract storage where the\n/// instance of type `T` is being pushed to.\n///\n/// # Note\n///\n/// - The routine will push the given entity to the contract storage using\n///   spread layout.\n/// - Users should prefer using this function directly instead of using the\n///   trait methods on [`SpreadLayout`].\npub fn push_spread_root<T>(entity: &T, root_key: &Key)\nwhere\n    T: SpreadLayout,\n{\n    let mut ptr = KeyPtr::from(*root_key);\n    <T as SpreadLayout>::push_spread(entity, &mut ptr);\n}\n\n/// Pulls an instance of type `T` from the contract storage using packed layout.\n///\n/// The root key denotes the offset into the contract storage where the\n/// instance of type `T` is being pulled from.\n///\n/// # Note\n///\n/// - The routine assumes that the instance has previously been stored to\n///   the contract storage using packed layout.\n/// - Users should prefer using this function directly instead of using the\n///   trait methods on [`PackedLayout`].\npub fn pull_packed_root<T>(root_key: &Key) -> T\nwhere\n    T: PackedLayout,\n{\n    let mut entity = ink_env::get_contract_storage::<T>(root_key)\n        .expect(\"could not properly decode storage entry\")\n        .expect(\"storage entry was empty\");\n    <T as PackedLayout>::pull_packed(&mut entity, root_key);\n    entity\n}\n\n/// Pushes the entity to the contract storage using packed layout.\n///\n/// The root key denotes the offset into the contract storage where the\n/// instance of type `T` is being pushed to.\n///\n/// # Note\n///\n/// - The routine will push the given entity to the contract storage using\n///   packed layout.\n/// - Users should prefer using this function directly instead of using the\n///   trait methods on [`PackedLayout`].\npub fn push_packed_root<T>(entity: &T, root_key: &Key)\nwhere\n    T: PackedLayout,\n{\n    <T as PackedLayout>::push_packed(entity, root_key);\n    ink_env::set_contract_storage(root_key, entity);\n}\n\n/// Clears the entity from the contract storage using packed layout.\n///\n/// The root key denotes the offset into the contract storage where the\n/// instance of type `T` is being cleared from.\n///\n/// # Note\n///\n/// - The routine assumes that the instance has previously been stored to\n///   the contract storage using packed layout.\n/// - Users should prefer using this function directly instead of using the\n///   trait methods on [`PackedLayout`].\npub fn clear_packed_root<T>(entity: &T, root_key: &Key)\nwhere\n    T: PackedLayout,\n{\n    <T as PackedLayout>::clear_packed(entity, root_key);\n    ink_env::clear_contract_storage(root_key);\n}\n"],["1016","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Implement specialized routines for managing Option<T> storage entities.\n//!\n//! These are mere optimizations compared to the non specialized root functions.\n//! The specializations make use of the storage entry state (occupied or vacant)\n//! in order to store the option's state thus using less storage in total.\n\nuse super::{\n    KeyPtr,\n    PackedLayout,\n    SpreadLayout,\n};\nuse ink_primitives::Key;\n\npub fn pull_spread_root_opt<T>(root_key: &Key) -> Option<T>\nwhere\n    T: SpreadLayout,\n{\n    // In case the contract storage is occupied we handle\n    // the Option<T> as if it was a T.\n    ink_env::get_contract_storage::<()>(root_key)\n        .ok()\n        .flatten()\n        .map(|_| super::pull_spread_root::<T>(root_key))\n}\n\npub fn push_spread_root_opt<T>(entity: Option<&T>, root_key: &Key)\nwhere\n    T: SpreadLayout,\n{\n    match entity {\n        Some(value) => {\n            // Handle the Option<T> as if it was a T.\n            //\n            // Sadly this doesn't not work well with `Option<Option<T>>`.\n            // For this we'd need specialization in Rust or similar.\n            super::push_spread_root(value, root_key)\n        }\n        None => clear_spread_root_opt::<T, _>(root_key, || entity),\n    }\n}\n\npub fn clear_spread_root_opt<'a, T: 'a, F>(root_key: &Key, f: F)\nwhere\n    T: SpreadLayout,\n    F: FnOnce() -> Option<&'a T>,\n{\n    // We can clean up some storage entity using its `SpreadLayout::clear_spread`\n    // implementation or its defined storage footprint.\n    //\n    // While using its `SpreadLayout::clear_spread` implementation is more precise\n    // and will only clean-up what is necessary it requires an actual instance.\n    // Loading such an instance if it is not already in the memory cache of some\n    // lazy abstraction will incur significant overhead.\n    // Using its defined storage footprint this procedure can eagerly clean-up\n    // the associated contract storage region, however, this might clean-up more\n    // cells than needed.\n    //\n    // There are types that need a so-called \"deep\" clean-up. An example for this\n    // is `storage::Box<storage::Box<T>>` where the outer storage box definitely\n    // needs to propagate clearing signals onto its inner `storage::Box` in order\n    // to properly clean-up the whole associate contract storage region.\n    // This is when we cannot avoid loading the entity for the clean-up procedure.\n    //\n    // If the entity that shall be cleaned-up does not require deep clean-up we\n    // check if its storage footprint exceeds a certain threshold and only then\n    // we will still load it first in order to not clean-up too many unneeded\n    // storage cells.\n    let footprint = <T as SpreadLayout>::FOOTPRINT;\n    if footprint >= super::FOOTPRINT_CLEANUP_THRESHOLD\n        || <T as SpreadLayout>::REQUIRES_DEEP_CLEAN_UP\n    {\n        // We need to load the entity before we remove its associated contract storage\n        // because it requires a deep clean-up which propagates clearing to its fields,\n        // for example in the case of `T` being a `storage::Box`.\n        if let Some(value) = f() {\n            super::clear_spread_root(value, root_key);\n            return\n        }\n    }\n    // Clean-up eagerly without potentially loading the entity from storage:\n    let mut ptr = KeyPtr::from(*root_key);\n    for _ in 0..footprint {\n        ink_env::clear_contract_storage(ptr.advance_by(1));\n    }\n}\n\npub fn pull_packed_root_opt<T>(root_key: &Key) -> Option<T>\nwhere\n    T: PackedLayout,\n{\n    match ink_env::get_contract_storage::<T>(root_key)\n        .expect(\"decoding does not match expected type\")\n    {\n        Some(mut value) => {\n            // In case the contract storage is occupied we handle\n            // the Option<T> as if it was a T.\n            <T as PackedLayout>::pull_packed(&mut value, root_key);\n            Some(value)\n        }\n        None => None,\n    }\n}\n\npub fn push_packed_root_opt<T>(entity: Option<&T>, root_key: &Key)\nwhere\n    T: PackedLayout,\n{\n    match entity {\n        Some(value) => {\n            // Handle the Option<T> as if it was a T.\n            //\n            // Sadly this doesn't not work well with `Option<Option<T>>`.\n            // For this we'd need specialization in Rust or similar.\n            super::push_packed_root(value, root_key)\n        }\n        None => {\n            // Clear the associated storage cell.\n            ink_env::clear_contract_storage(root_key);\n        }\n    }\n}\n"],["1017","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::SpreadLayout;\nuse ink_primitives::Key;\npub use ink_primitives::KeyPtr;\n\n/// Extension trait to make `KeyPtr` simpler to use for `T: SpreadLayout` types.\npub trait ExtKeyPtr {\n    /// Advances the key pointer by the same amount of the footprint of the\n    /// generic type parameter of `T` and returns the old value.\n    fn next_for<T>(&mut self) -> &Key\n    where\n        T: SpreadLayout;\n}\n\nimpl ExtKeyPtr for KeyPtr {\n    fn next_for<T>(&mut self) -> &Key\n    where\n        T: SpreadLayout,\n    {\n        self.advance_by(<T as SpreadLayout>::FOOTPRINT)\n    }\n}\n"],["1018","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Utilities for testing if the storage interaction of an object\n//! which is pushed/pulled/cleared to/from storage behaves as it should.\n\n/// Runs `f` using the off-chain testing environment.\n#[cfg(test)]\npub fn run_test<F>(f: F)\nwhere\n    F: FnOnce(),\n{\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        f();\n        Ok(())\n    })\n    .unwrap()\n}\n\n/// Creates two tests:\n/// (1) Tests if an object which is `push_spread`-ed to storage results in exactly\n///     the same object when it is `pull_spread`-ed again. Subsequently the object\n///     undergoes the same test for `push_packed` and `pull_packed`.\n/// (2) Tests if `clear_spread` removes the object properly from storage.\n#[macro_export]\nmacro_rules! push_pull_works_for_primitive {\n    ( $name:ty, [$($value:expr),*] ) => {\n        paste::item! {\n            #[test]\n            #[allow(non_snake_case)]\n            fn [<$name _pull_push_works>] () {\n                crate::test_utils::run_test(|| {\n                    $({\n                        let x: $name = $value;\n                        let key = ink_primitives::Key::from([0x42; 32]);\n                        let key2 = ink_primitives::Key::from([0x77; 32]);\n                        crate::traits::push_spread_root(&x, &key);\n                        let y: $name = crate::traits::pull_spread_root(&key);\n                        assert_eq!(x, y);\n                        crate::traits::push_packed_root(&x, &key2);\n                        let z: $name = crate::traits::pull_packed_root(&key2);\n                        assert_eq!(x, z);\n                    })*\n                })\n            }\n\n            #[test]\n            #[should_panic(expected = \"storage entry was empty\")]\n            #[allow(non_snake_case)]\n            fn [<$name _clean_works>]() {\n                crate::test_utils::run_test(|| {\n                    $({\n                        let x: $name = $value;\n                        let key = ink_primitives::Key::from([0x42; 32]);\n                        crate::traits::push_spread_root(&x, &key);\n                        // Works since we just populated the storage.\n                        let y: $name = crate::traits::pull_spread_root(&key);\n                        assert_eq!(x, y);\n                        crate::traits::clear_spread_root(&x, &key);\n                        // Panics since it loads eagerly from cleared storage.\n                        let _: $name = crate::traits::pull_spread_root(&key);\n                    })*\n                })\n            }\n        }\n    };\n}\n\n/// A trait to enable running some fuzz tests on a collection.\npub trait FuzzCollection {\n    type Collection;\n    type Item;\n\n    /// Executes a series of operations on `self` in order to make it\n    /// equal to `template`.\n    fn equalize(&mut self, template: &Self::Collection);\n\n    /// Takes a value from `self` and puts it into `item`.\n    fn assign(&mut self, item: Self::Item);\n}\n\n/// Creates two fuzz tests. Both tests have the same flow:\n///     - Take two instances of the collection, generated by our fuzzer\n///     - Push `instance2` to storage, pull it out and assert that what\n///       is pulled out is what was pushed.\n///     - Do some mutations on the `pulled` object. Here the two tests\n///       behave differently:\n///\n///         * `fuzz_ $id _mutate_some` Mutates some entries of the data\n///           structure based on the content of `instance2`.\n///\n///         * `fuzz_ $id _mutate_all` Mutates the entire data structure,\n///           so that it has the same content as `instance2`.\n///\n///     - Push the mutated `pulled` object into storage again, pull it\n///       out as `pulled2` and assert that both objects are equal.\n///     - Clear the object from storage and assert that storage was\n///       cleared up properly, without any leftovers.\n#[macro_export]\nmacro_rules! fuzz_storage {\n    ($id:literal, $collection_type:ty) => {\n        ::paste::paste! {\n            /// Does some basic storage interaction tests whilst mutating\n            /// *some* of the data structure's entries.\n            #[allow(trivial_casts)]\n            #[quickcheck]\n            fn [< fuzz_ $id _mutate_some >] (\n                instance1: $collection_type,\n                mut instance2: $collection_type,\n            ) {\n                ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n                    // we push the generated object into storage\n                    let root_key = ink_primitives::Key::from([0x42; 32]);\n                    let ptr = KeyPtr::from(root_key);\n                    crate::traits::push_spread_root(&instance1, &mut root_key.clone());\n\n                    // we pull what's in storage and assert that this is what was just pushed\n                    let mut pulled: $collection_type = crate::traits::pull_spread_root(&root_key.clone());\n                    assert_eq!(instance1, pulled);\n\n                    // we iterate over what was pulled and call `assign` for all entries.\n                    // this function may or may not modify elements of `pulled`.\n                    pulled.iter_mut().for_each(|item| {\n                        // this may leave some entries of `pulled` in `State::Preserved`.\n                        // even though the instance which is supposed to be mutated is\n                        // `pulled`, we still need to call this on a mutable `instance2`,\n                        // since e.g. Vec does a `pop()` in assign, so that we don't always\n                        // execute the same operation.\n                        (&mut instance2).assign(item);\n                    });\n\n                    // we push the `pulled` object, on which we just executed mutations\n                    // back into storage and asserts it can be pulled out intact again.\n                    crate::traits::push_spread_root(&pulled, &mut root_key.clone());\n                    let pulled2: $collection_type = crate::traits::pull_spread_root(&mut root_key.clone());\n                    assert_eq!(pulled, pulled2);\n\n                    // we clear the object from storage and assert that everything was\n                    // removed without any leftovers.\n                    SpreadLayout::clear_spread(&pulled2, &mut ptr.clone());\n                    crate::test_utils::assert_storage_clean();\n\n                    Ok(())\n                })\n                    .unwrap()\n            }\n\n            /// Does some basic storage interaction tests whilst mutating\n            /// *all* of the data structure's entries.\n            #[allow(trivial_casts)]\n            #[quickcheck]\n            fn [< fuzz_ $id _mutate_all >] (\n                instance1: $collection_type,\n                instance2: $collection_type,\n            ) {\n                ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n                    // we push the generated object into storage\n                    let root_key = ink_primitives::Key::from([0x42; 32]);\n                    let ptr = KeyPtr::from(root_key);\n                    crate::traits::push_spread_root(&instance1, &mut root_key.clone());\n\n                    // we pull what's in storage and assert that this is what was just pushed\n                    let mut pulled: $collection_type = crate::traits::pull_spread_root(&root_key.clone());\n                    assert_eq!(instance1, pulled);\n\n                    // `pulled` is going to be equalized to `\n                    (&mut pulled).equalize(&instance2);\n\n                    // we push the `pulled` object, on which we just executed mutations\n                    // back into storage and assert it can be pulled out intact again and\n                    // is equal to `instance2`.\n                    crate::traits::push_spread_root(&pulled, &mut root_key.clone());\n                    let pulled2: $collection_type = crate::traits::pull_spread_root(&mut root_key.clone());\n                    assert_eq!(pulled, pulled2);\n                    assert_eq!(pulled2, instance2);\n\n                    // we clear the object from storage and assert that everything was\n                    // removed without any leftovers.\n                    SpreadLayout::clear_spread(&pulled2, &mut ptr.clone());\n                    crate::test_utils::assert_storage_clean();\n\n                    Ok(())\n\n                })\n                    .unwrap()\n            }\n        }\n    };\n}\n\n/// Asserts that the storage is empty, without any leftovers.\n#[cfg(all(test, feature = \"ink-fuzz-tests\"))]\npub fn assert_storage_clean() {\n    let contract_id =\n        ink_env::test::get_current_contract_account_id::<ink_env::DefaultEnvironment>()\n            .expect(\"contract id must exist\");\n    let used_cells =\n        ink_env::test::count_used_storage_cells::<ink_env::DefaultEnvironment>(\n            &contract_id,\n        )\n        .expect(\"used cells must be returned\");\n    assert_eq!(used_cells, 0);\n}\n"],["1019","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::{\n    CacheCell,\n    EntryState,\n    StorageEntry,\n};\nuse crate::traits::{\n    clear_spread_root_opt,\n    pull_spread_root_opt,\n    ExtKeyPtr,\n    KeyPtr,\n    SpreadLayout,\n};\nuse core::{\n    fmt,\n    fmt::Debug,\n    ptr::NonNull,\n};\nuse ink_primitives::Key;\n\n/// A lazy storage entity.\n///\n/// This loads its value from storage upon first use.\n///\n/// # Note\n///\n/// Use this if the storage field doesn't need to be loaded in some or most cases.\npub struct LazyCell<T>\nwhere\n    T: SpreadLayout,\n{\n    /// The key to lazily load the value from.\n    ///\n    /// # Note\n    ///\n    /// This can be `None` on contract initialization where a `LazyCell` is\n    /// normally initialized given a concrete value.\n    key: Option<Key>,\n    /// The low-level cache for the lazily loaded storage value.\n    ///\n    /// # Safety (Dev)\n    ///\n    /// We use `UnsafeCell` instead of `RefCell` because\n    /// the intended use-case is to hand out references (`&` and `&mut`)\n    /// to the callers of `Lazy`. This cannot be done without `unsafe`\n    /// code even with `RefCell`. Also `RefCell` has a larger memory footprint\n    /// and has additional overhead that we can avoid by the interface\n    /// and the fact that ink! code is always run single-threaded.\n    /// Being efficient is important here because this is intended to be\n    /// a low-level primitive with lots of dependencies.\n    cache: CacheCell<Option<StorageEntry<T>>>,\n}\n\nimpl<T> Debug for LazyCell<T>\nwhere\n    T: Debug + SpreadLayout,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"LazyCell\")\n            .field(\"key\", &self.key)\n            .field(\"cache\", self.cache.as_inner())\n            .finish()\n    }\n}\n\n#[test]\nfn debug_impl_works() -> ink_env::Result<()> {\n    ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n        let c1 = <LazyCell<i32>>::new(None);\n        assert_eq!(\n            format!(\"{:?}\", &c1),\n            \"LazyCell { key: None, cache: Some(Entry { value: None, state: Mutated }) }\",\n        );\n        let c2 = <LazyCell<i32>>::new(Some(42));\n        assert_eq!(\n            format!(\"{:?}\", &c2),\n            \"LazyCell { key: None, cache: Some(Entry { value: Some(42), state: Mutated }) }\",\n        );\n        let c3 = <LazyCell<i32>>::lazy(Key::from([0x00; 32]));\n        assert_eq!(\n            format!(\"{:?}\", &c3),\n            \"LazyCell { \\\n            key: Some(Key(0x_\\\n                0000000000000000_\\\n                0000000000000000_\\\n                0000000000000000_\\\n                0000000000000000)\\\n            ), \\\n            cache: None \\\n        }\",\n        );\n        Ok(())\n    })\n}\n\nimpl<T> Drop for LazyCell<T>\nwhere\n    T: SpreadLayout,\n{\n    fn drop(&mut self) {\n        if let Some(root_key) = self.key() {\n            match self.entry() {\n                Some(entry) => {\n                    // The inner cell needs to be cleared, no matter if it has\n                    // been loaded or not. Otherwise there might be leftovers.\n                    // Load from storage and then clear:\n                    clear_spread_root_opt::<T, _>(root_key, || entry.value().into())\n                }\n                None => {\n                    // The value is not yet in the cache. we need it in there\n                    // though in order to properly clean up.\n                    if <T as SpreadLayout>::REQUIRES_DEEP_CLEAN_UP {\n                        // The inner cell needs to be cleared, no matter if it has\n                        // been loaded or not. Otherwise there might be leftovers.\n                        // Load from storage and then clear:\n                        clear_spread_root_opt::<T, _>(root_key, || self.get())\n                    } else {\n                        // Clear without loading from storage:\n                        let footprint = <T as SpreadLayout>::FOOTPRINT;\n                        assert_footprint_threshold(footprint);\n                        let mut key_ptr = KeyPtr::from(*root_key);\n                        for _ in 0..footprint {\n                            ink_env::clear_contract_storage(key_ptr.advance_by(1));\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nconst _: () = {\n    use crate::traits::StorageLayout;\n    use ink_metadata::layout::Layout;\n\n    impl<T> StorageLayout for LazyCell<T>\n    where\n        T: StorageLayout + SpreadLayout,\n    {\n        fn layout(key_ptr: &mut KeyPtr) -> Layout {\n            <T as StorageLayout>::layout(key_ptr)\n        }\n    }\n};\n\nimpl<T> SpreadLayout for LazyCell<T>\nwhere\n    T: SpreadLayout,\n{\n    const FOOTPRINT: u64 = <T as SpreadLayout>::FOOTPRINT;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        let root_key = ExtKeyPtr::next_for::<Self>(ptr);\n        Self::lazy(*root_key)\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        let root_key = ExtKeyPtr::next_for::<Self>(ptr);\n        if let Some(entry) = self.entry() {\n            entry.push_spread_root(root_key)\n        }\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        let root_key = ExtKeyPtr::next_for::<Self>(ptr);\n        match <T as SpreadLayout>::REQUIRES_DEEP_CLEAN_UP {\n            true => {\n                // The inner cell needs to be cleared, no matter if it has\n                // been loaded or not. Otherwise there might be leftovers.\n                // Load from storage and then clear:\n                clear_spread_root_opt::<T, _>(root_key, || self.get())\n            }\n            false => {\n                // Clear without loading from storage:\n                let footprint = <T as SpreadLayout>::FOOTPRINT;\n                assert_footprint_threshold(footprint);\n                let mut key_ptr = KeyPtr::from(*root_key);\n                for _ in 0..footprint {\n                    ink_env::clear_contract_storage(key_ptr.advance_by(1));\n                }\n            }\n        }\n    }\n}\n\n// # Developer Note\n//\n// Implementing PackedLayout for LazyCell is not useful since that would\n// potentially allow overlapping distinct LazyCell instances by pulling\n// from the same underlying storage cell.\n//\n// If a user wants a packed LazyCell they can instead pack its inner type.\n\nimpl<T> From<T> for LazyCell<T>\nwhere\n    T: SpreadLayout,\n{\n    fn from(value: T) -> Self {\n        Self::new(Some(value))\n    }\n}\n\nimpl<T> Default for LazyCell<T>\nwhere\n    T: Default + SpreadLayout,\n{\n    fn default() -> Self {\n        Self::new(Some(Default::default()))\n    }\n}\n\nimpl<T> LazyCell<T>\nwhere\n    T: SpreadLayout,\n{\n    /// Creates an already populated lazy storage cell.\n    ///\n    /// # Note\n    ///\n    /// Since this already has a value it will never actually load from\n    /// the contract storage.\n    #[must_use]\n    pub fn new(value: Option<T>) -> Self {\n        Self {\n            key: None,\n            cache: CacheCell::new(Some(StorageEntry::new(value, EntryState::Mutated))),\n        }\n    }\n\n    /// Creates a lazy storage cell for the given key.\n    ///\n    /// # Note\n    ///\n    /// This will actually lazily load from the associated storage cell\n    /// upon access.\n    #[must_use]\n    pub fn lazy(key: Key) -> Self {\n        Self {\n            key: Some(key),\n            cache: CacheCell::new(None),\n        }\n    }\n\n    /// Returns the lazy key if any.\n    ///\n    /// # Note\n    ///\n    /// The key is `None` if the `LazyCell` has been initialized as a value.\n    /// This generally only happens in ink! constructors.\n    fn key(&self) -> Option<&Key> {\n        self.key.as_ref()\n    }\n\n    /// Returns the cached entry.\n    fn entry(&self) -> Option<&StorageEntry<T>> {\n        self.cache.as_inner().as_ref()\n    }\n}\n\nimpl<T> LazyCell<T>\nwhere\n    T: SpreadLayout,\n{\n    /// Loads the storage entry.\n    ///\n    /// Tries to load the entry from cache and falls back to lazily load the\n    /// entry from the contract storage.\n    unsafe fn load_through_cache(&self) -> NonNull<StorageEntry<T>> {\n        // SAFETY: This is critical because we mutably access the entry.\n        //         However, we mutate the entry only if it is vacant.\n        //         If the entry is occupied by a value we return early.\n        //         This way we do not invalidate pointers to this value.\n        let cache = &mut *self.cache.get_ptr().as_ptr();\n        if cache.is_none() {\n            // Load value from storage and then return the cached entry.\n            let value = self\n                .key\n                .map(|key| pull_spread_root_opt::<T>(&key))\n                .unwrap_or(None);\n            *cache = Some(StorageEntry::new(value, EntryState::Preserved));\n        }\n        debug_assert!(cache.is_some());\n        NonNull::from(cache.as_mut().expect(\"unpopulated cache entry\"))\n    }\n\n    /// Returns a shared reference to the entry.\n    fn load_entry(&self) -> &StorageEntry<T> {\n        // SAFETY: We load the entry either from cache of from contract storage.\n        //\n        //         This is safe because we are just returning a shared reference\n        //         from within a `&self` method. This also cannot change the\n        //         loaded value and thus cannot change the `mutate` flag of the\n        //         entry. Aliases using this method are safe since ink! is\n        //         single-threaded.\n        unsafe { &*self.load_through_cache().as_ptr() }\n    }\n\n    /// Returns an exclusive reference to the entry.\n    fn load_entry_mut(&mut self) -> &mut StorageEntry<T> {\n        // SAFETY: We load the entry either from cache of from contract storage.\n        //\n        //         This is safe because we are just returning an exclusive reference\n        //         from within a `&mut self` method. This may change the\n        //         loaded value and thus the `mutate` flag of the entry is set.\n        //         Aliases cannot happen through this method since ink! is\n        //         single-threaded.\n        let entry = unsafe { &mut *self.load_through_cache().as_ptr() };\n        entry.replace_state(EntryState::Mutated);\n        entry\n    }\n\n    /// Returns a shared reference to the value.\n    ///\n    /// # Note\n    ///\n    /// This eventually lazily loads the value from the contract storage.\n    ///\n    /// # Panics\n    ///\n    /// If decoding the loaded value to `T` failed.\n    #[must_use]\n    pub fn get(&self) -> Option<&T> {\n        self.load_entry().value().into()\n    }\n\n    /// Returns an exclusive reference to the value.\n    ///\n    /// # Note\n    ///\n    /// This eventually lazily loads the value from the contract storage.\n    ///\n    /// # Panics\n    ///\n    /// If decoding the loaded value to `T` failed.\n    #[must_use]\n    pub fn get_mut(&mut self) -> Option<&mut T> {\n        self.load_entry_mut().value_mut().into()\n    }\n\n    /// Sets the value in this cell to `value`, without executing any reads.\n    ///\n    /// # Note\n    ///\n    /// No reads from contract storage will be executed.\n    ///\n    /// This method should be preferred over dereferencing or `get_mut`\n    /// in case the returned value is of no interest to the caller.\n    ///\n    /// # Panics\n    ///\n    /// If accessing the inner value fails.\n    #[inline]\n    pub fn set(&mut self, new_value: T) {\n        // SAFETY: This is critical because we mutably access the entry.\n        let cache = unsafe { &mut *self.cache.get_ptr().as_ptr() };\n        if let Some(cache) = cache.as_mut() {\n            //  Cache is already populated we simply overwrite its already existing value.\n            cache.put(Some(new_value));\n        } else {\n            // Cache is empty, so we simply set the cache to the value.\n            // The key does not need to exist for this to work, we only need to\n            // write the value into the cache and are done. Writing to contract\n            // storage happens during setup/teardown of a contract.\n            *cache = Some(StorageEntry::new(Some(new_value), EntryState::Mutated));\n        }\n        debug_assert!(cache.is_some());\n    }\n}\n\n/// Asserts that the given `footprint` is below `FOOTPRINT_CLEANUP_THRESHOLD`.\nfn assert_footprint_threshold(footprint: u64) {\n    let footprint_threshold = crate::traits::FOOTPRINT_CLEANUP_THRESHOLD;\n    assert!(\n        footprint <= footprint_threshold,\n        \"cannot clean-up a storage entity with a footprint of {}. maximum threshold for clean-up is {}.\",\n        footprint,\n        footprint_threshold,\n    );\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{\n        EntryState,\n        LazyCell,\n        StorageEntry,\n    };\n    use crate::{\n        traits::{\n            KeyPtr,\n            SpreadLayout,\n        },\n        Lazy,\n    };\n    use ink_env::test::run_test;\n    use ink_primitives::Key;\n\n    #[test]\n    fn new_works() {\n        // Initialized via some value:\n        let mut a = <LazyCell<u8>>::new(Some(b'A'));\n        assert_eq!(a.key(), None);\n        assert_eq!(\n            a.entry(),\n            Some(&StorageEntry::new(Some(b'A'), EntryState::Mutated))\n        );\n        assert_eq!(a.get(), Some(&b'A'));\n        assert_eq!(a.get_mut(), Some(&mut b'A'));\n        // Initialized as none:\n        let mut b = <LazyCell<u8>>::new(None);\n        assert_eq!(b.key(), None);\n        assert_eq!(\n            b.entry(),\n            Some(&StorageEntry::new(None, EntryState::Mutated))\n        );\n        assert_eq!(b.get(), None);\n        assert_eq!(b.get_mut(), None);\n        // Same as default or from:\n        let default_lc = <LazyCell<u8>>::default();\n        let from_lc = LazyCell::from(u8::default());\n        let new_lc = LazyCell::new(Some(u8::default()));\n        assert_eq!(default_lc.get(), from_lc.get());\n        assert_eq!(from_lc.get(), new_lc.get());\n        assert_eq!(new_lc.get(), Some(&u8::default()));\n    }\n\n    #[test]\n    fn lazy_works() -> ink_env::Result<()> {\n        run_test::<ink_env::DefaultEnvironment, _>(|_| {\n            let root_key = Key::from([0x42; 32]);\n            let cell = <LazyCell<u8>>::lazy(root_key);\n            assert_eq!(cell.key(), Some(&root_key));\n            Ok(())\n        })\n    }\n\n    #[test]\n    fn lazy_get_works() -> ink_env::Result<()> {\n        run_test::<ink_env::DefaultEnvironment, _>(|_| {\n            let cell = <LazyCell<u8>>::lazy(Key::from([0x42; 32]));\n            let value = cell.get();\n            // We do the normally unreachable check in order to have an easier\n            // time finding the issue if the above execution did not panic.\n            assert_eq!(value, None);\n            Ok(())\n        })\n    }\n\n    #[test]\n    fn get_mut_works() {\n        let mut cell = <LazyCell<i32>>::new(Some(1));\n        assert_eq!(cell.get(), Some(&1));\n        *cell.get_mut().unwrap() += 1;\n        assert_eq!(cell.get(), Some(&2));\n    }\n\n    #[test]\n    fn spread_layout_works() -> ink_env::Result<()> {\n        run_test::<ink_env::DefaultEnvironment, _>(|_| {\n            let cell_a0 = <LazyCell<u8>>::new(Some(b'A'));\n            assert_eq!(cell_a0.get(), Some(&b'A'));\n            // Push `cell_a0` to the contract storage.\n            // Then, pull `cell_a1` from the contract storage and check if it is\n            // equal to `cell_a0`.\n            let root_key = Key::from([0x42; 32]);\n            SpreadLayout::push_spread(&cell_a0, &mut KeyPtr::from(root_key));\n            let cell_a1 =\n                <LazyCell<u8> as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n            assert_eq!(cell_a1.get(), cell_a0.get());\n            assert_eq!(cell_a1.get(), Some(&b'A'));\n            assert_eq!(\n                cell_a1.entry(),\n                Some(&StorageEntry::new(Some(b'A'), EntryState::Preserved))\n            );\n            // Also test if a lazily instantiated cell works:\n            let cell_a2 = <LazyCell<u8>>::lazy(root_key);\n            assert_eq!(cell_a2.get(), cell_a0.get());\n            assert_eq!(cell_a2.get(), Some(&b'A'));\n            assert_eq!(\n                cell_a2.entry(),\n                Some(&StorageEntry::new(Some(b'A'), EntryState::Preserved))\n            );\n            // Test if clearing works:\n            SpreadLayout::clear_spread(&cell_a1, &mut KeyPtr::from(root_key));\n            let cell_a3 = <LazyCell<u8>>::lazy(root_key);\n            assert_eq!(cell_a3.get(), None);\n            assert_eq!(\n                cell_a3.entry(),\n                Some(&StorageEntry::new(None, EntryState::Preserved))\n            );\n            Ok(())\n        })\n    }\n\n    #[test]\n    fn set_works() {\n        let mut cell = <LazyCell<i32>>::new(Some(1));\n        cell.set(23);\n        assert_eq!(cell.get(), Some(&23));\n    }\n\n    #[test]\n    fn lazy_set_works() -> ink_env::Result<()> {\n        run_test::<ink_env::DefaultEnvironment, _>(|_| {\n            let mut cell = <LazyCell<u8>>::lazy(Key::from([0x42; 32]));\n            let value = cell.get();\n            assert_eq!(value, None);\n\n            cell.set(13);\n            assert_eq!(cell.get(), Some(&13));\n            Ok(())\n        })\n    }\n\n    #[test]\n    fn lazy_set_works_with_spread_layout_push_pull() -> ink_env::Result<()> {\n        run_test::<ink_env::DefaultEnvironment, _>(|_| {\n            type MaybeValue = Option<u8>;\n\n            // Initialize a LazyCell with None and push it to `k`\n            let k = Key::from([0x00; 32]);\n            let val: MaybeValue = None;\n            SpreadLayout::push_spread(&Lazy::new(val), &mut KeyPtr::from(k));\n\n            // Pull another instance `v` from `k`, check that it is `None`\n            let mut v =\n                <Lazy<MaybeValue> as SpreadLayout>::pull_spread(&mut KeyPtr::from(k));\n            assert_eq!(*v, None);\n\n            // Set `v` using `set` to an actual value\n            let actual_value: MaybeValue = Some(13);\n            Lazy::set(&mut v, actual_value);\n\n            // Push `v` to `k`\n            SpreadLayout::push_spread(&v, &mut KeyPtr::from(k));\n\n            // Load `v2` from `k`\n            let v2 =\n                <Lazy<MaybeValue> as SpreadLayout>::pull_spread(&mut KeyPtr::from(k));\n\n            // Check that V2 is the set value\n            assert_eq!(*v2, Some(13));\n\n            Ok(())\n        })\n    }\n\n    #[test]\n    fn regression_test_for_issue_528() -> ink_env::Result<()> {\n        run_test::<ink_env::DefaultEnvironment, _>(|_| {\n            let root_key = Key::from([0x00; 32]);\n            {\n                // Step 1: Push a valid pair onto the contract storage.\n                let pair = (LazyCell::new(Some(1i32)), 2i32);\n                SpreadLayout::push_spread(&pair, &mut KeyPtr::from(root_key));\n            }\n            {\n                // Step 2: Pull the pair from the step before.\n                //\n                // 1. Change the second `i32` value of the pair.\n                // 2. Push the pair again to contract storage.\n                //\n                // We prevent the intermediate instance from clearing the storage preemtively by wrapping\n                // it inside `ManuallyDrop`. The third step will clean up the same storage region afterwards.\n                //\n                // We explicitly do not touch or assert the value of `pulled_pair.0` in order to trigger\n                // the bug.\n                let pulled_pair: (LazyCell<i32>, i32) =\n                    SpreadLayout::pull_spread(&mut KeyPtr::from(root_key));\n                let mut pulled_pair = core::mem::ManuallyDrop::new(pulled_pair);\n                assert_eq!(pulled_pair.1, 2i32);\n                pulled_pair.1 = 3i32;\n                SpreadLayout::push_spread(&*pulled_pair, &mut KeyPtr::from(root_key));\n            }\n            {\n                // Step 3: Pull the pair again from the storage.\n                //\n                // If the bug with `Lazy` that has been fixed in PR #528 has been fixed we should be\n                // able to inspect the correct values for both pair entries which is: `(Some(1), 3)`\n                let pulled_pair: (LazyCell<i32>, i32) =\n                    SpreadLayout::pull_spread(&mut KeyPtr::from(root_key));\n                assert_eq!(pulled_pair.0.get(), Some(&1i32));\n                assert_eq!(pulled_pair.1, 3i32);\n            }\n            Ok(())\n        })\n    }\n\n    #[test]\n    fn regression_test_for_issue_570() -> ink_env::Result<()> {\n        run_test::<ink_env::DefaultEnvironment, _>(|_| {\n            let root_key = Key::from([0x00; 32]);\n            {\n                // Step 1: Push two valid values one after the other to contract storage.\n                // The first value needs to be an `Option::None` value, since the bug was\n                // then messing up following pointers.\n                let v1: Option<u32> = None;\n                let v2: u32 = 13;\n                let mut ptr = KeyPtr::from(root_key);\n\n                SpreadLayout::push_spread(&v1, &mut ptr);\n                SpreadLayout::push_spread(&v2, &mut ptr);\n            }\n            {\n                // Step 2: Pull the values from the step before.\n                //\n                // 1. Change the first values `None` to `Some(...)`.\n                // 2. Push the first value again to contract storage.\n                //\n                // We prevent the intermediate instance from clearing the storage preemptively\n                // by wrapping it inside `ManuallyDrop`. The third step will clean up the same\n                // storage region afterwards.\n                let mut ptr = KeyPtr::from(root_key);\n                let pulled_v1: Option<u32> = SpreadLayout::pull_spread(&mut ptr);\n                let mut pulled_v1 = core::mem::ManuallyDrop::new(pulled_v1);\n\n                let pulled_v2: u32 = SpreadLayout::pull_spread(&mut ptr);\n                let pulled_v2 = core::mem::ManuallyDrop::new(pulled_v2);\n\n                assert_eq!(*pulled_v1, None);\n                assert_eq!(*pulled_v2, 13);\n\n                *pulled_v1 = Some(99u32);\n                SpreadLayout::push_spread(&*pulled_v1, &mut KeyPtr::from(root_key));\n            }\n            {\n                // Step 3: Pull the values again from the storage.\n                //\n                // If the bug with `Option` has been fixed in PR #520 we must be able to inspect\n                // the correct values for both entries.\n                let mut ptr = KeyPtr::from(root_key);\n                let pulled_v1: Option<u32> = SpreadLayout::pull_spread(&mut ptr);\n                let pulled_v2: u32 = SpreadLayout::pull_spread(&mut ptr);\n\n                assert_eq!(pulled_v1, Some(99));\n                assert_eq!(pulled_v2, 13);\n            }\n            Ok(())\n        })\n    }\n\n    #[test]\n    fn second_regression_test_for_issue_570() -> ink_env::Result<()> {\n        run_test::<ink_env::DefaultEnvironment, _>(|_| {\n            // given\n            let root_key = Key::from([0x00; 32]);\n            let none: Option<u32> = None;\n            let some: Option<u32> = Some(13);\n\n            // when\n            let mut ptr_push_none = KeyPtr::from(root_key);\n            SpreadLayout::push_spread(&none, &mut ptr_push_none);\n            let mut ptr_pull_none = KeyPtr::from(root_key);\n            let v1: Option<u32> = SpreadLayout::pull_spread(&mut ptr_pull_none);\n            assert!(v1.is_none());\n            let mut ptr_clear_none = KeyPtr::from(root_key);\n            SpreadLayout::clear_spread(&none, &mut ptr_clear_none);\n\n            let mut ptr_push_some = KeyPtr::from(root_key);\n            SpreadLayout::push_spread(&some, &mut ptr_push_some);\n            let mut ptr_pull_some = KeyPtr::from(root_key);\n            let v2: Option<u32> = SpreadLayout::pull_spread(&mut ptr_pull_some);\n            assert!(v2.is_some());\n            let mut ptr_clear_some = KeyPtr::from(root_key);\n            SpreadLayout::clear_spread(&some, &mut ptr_clear_some);\n\n            // then\n            // the bug which we observed was that the pointer after push/pull/clear\n            // was set so a different value if the `Option` was `None` vs. if it was\n            // `Some`.\n            //\n            // if the bug has been fixed the pointer must be the same for `None`\n            // and `Some` after push/pull/clear. otherwise subsequent operations using\n            // the pointer will break as soon as the `Option` is changed to it's\n            // opposite (`None` -> `Some`, `Some` -> `None`).\n            let mut expected_post_op_ptr = KeyPtr::from(root_key);\n            // advance one time after the cell containing `self.is_some() as u8` has been read\n            expected_post_op_ptr.advance_by(1);\n            // advance another time after the cell containing the inner `Option` value\n            // has either been skipped (in case of the previous cell being `None`) or\n            // read (in case of `Some`).\n            expected_post_op_ptr.advance_by(1);\n\n            assert_eq!(expected_post_op_ptr, ptr_push_none);\n            assert_eq!(ptr_push_none, ptr_push_some);\n\n            assert_eq!(expected_post_op_ptr, ptr_pull_none);\n            assert_eq!(ptr_pull_none, ptr_pull_some);\n\n            assert_eq!(expected_post_op_ptr, ptr_clear_none);\n            assert_eq!(ptr_clear_none, ptr_clear_some);\n\n            Ok(())\n        })\n    }\n\n    #[test]\n    #[should_panic(expected = \"encountered empty storage cell\")]\n    fn nested_lazies_are_cleared_completely_after_pull() {\n        ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n            // given\n            let root_key = Key::from([0x42; 32]);\n            let nested_lazy: Lazy<Lazy<u32>> = Lazy::new(Lazy::new(13u32));\n            SpreadLayout::push_spread(&nested_lazy, &mut KeyPtr::from(root_key));\n            let pulled_lazy = <Lazy<Lazy<u32>> as SpreadLayout>::pull_spread(\n                &mut KeyPtr::from(root_key),\n            );\n\n            // when\n            SpreadLayout::clear_spread(&pulled_lazy, &mut KeyPtr::from(root_key));\n\n            // then\n            let contract_id = ink_env::test::get_current_contract_account_id::<\n                ink_env::DefaultEnvironment,\n            >()\n            .expect(\"Cannot get contract id\");\n            let used_cells = ink_env::test::count_used_storage_cells::<\n                ink_env::DefaultEnvironment,\n            >(&contract_id)\n            .expect(\"used cells must be returned\");\n            assert_eq!(used_cells, 0);\n            let _ = *<Lazy<Lazy<u32>> as SpreadLayout>::pull_spread(&mut KeyPtr::from(\n                root_key,\n            ));\n            Ok(())\n        })\n        .unwrap()\n    }\n\n    #[test]\n    #[should_panic(expected = \"encountered empty storage cell\")]\n    fn lazy_drop_works() {\n        ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n            // given\n            let root_key = Key::from([0x42; 32]);\n\n            // when\n            let setup_result = std::panic::catch_unwind(|| {\n                let lazy: Lazy<u32> = Lazy::new(13u32);\n                SpreadLayout::push_spread(&lazy, &mut KeyPtr::from(root_key));\n                let _pulled_lazy =\n                    <Lazy<u32> as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n                // lazy is dropped which should clear the cells\n            });\n            assert!(setup_result.is_ok(), \"setup should not panic\");\n\n            // then\n            let contract_id = ink_env::test::get_current_contract_account_id::<\n                ink_env::DefaultEnvironment,\n            >()\n            .expect(\"Cannot get contract id\");\n            let used_cells = ink_env::test::count_used_storage_cells::<\n                ink_env::DefaultEnvironment,\n            >(&contract_id)\n            .expect(\"used cells must be returned\");\n            assert_eq!(used_cells, 0);\n            let _ =\n                *<Lazy<u32> as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n            Ok(())\n        })\n        .unwrap()\n    }\n\n    #[test]\n    #[should_panic(expected = \"encountered empty storage cell\")]\n    fn lazy_drop_works_with_greater_footprint() {\n        ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n            // given\n            let root_key = Key::from([0x42; 32]);\n\n            // when\n            let setup_result = std::panic::catch_unwind(|| {\n                let lazy: Lazy<[u32; 5]> = Lazy::new([13, 14, 15, 16, 17]);\n                SpreadLayout::push_spread(&lazy, &mut KeyPtr::from(root_key));\n                let _pulled_lazy = <Lazy<[u32; 5]> as SpreadLayout>::pull_spread(\n                    &mut KeyPtr::from(root_key),\n                );\n                // lazy is dropped which should clear the cells\n            });\n            assert!(setup_result.is_ok(), \"setup should not panic\");\n\n            // then\n            let contract_id = ink_env::test::get_current_contract_account_id::<\n                ink_env::DefaultEnvironment,\n            >()\n            .expect(\"Cannot get contract id\");\n            let used_cells = ink_env::test::count_used_storage_cells::<\n                ink_env::DefaultEnvironment,\n            >(&contract_id)\n            .expect(\"used cells must be returned\");\n            assert_eq!(used_cells, 0);\n            let _ =\n                *<Lazy<u32> as SpreadLayout>::pull_spread(&mut KeyPtr::from(root_key));\n            Ok(())\n        })\n        .unwrap()\n    }\n}\n"],["1020","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::traits::{\n    clear_packed_root,\n    clear_spread_root_opt,\n    pull_packed_root_opt,\n    pull_spread_root_opt,\n    push_packed_root_opt,\n    push_spread_root_opt,\n    ExtKeyPtr,\n    KeyPtr,\n    PackedLayout,\n    SpreadLayout,\n};\nuse core::{\n    cell::Cell,\n    fmt,\n    fmt::Debug,\n};\nuse ink_prelude::vec::Vec;\nuse ink_primitives::Key;\n\n/// The entry of a single cached value of a lazy storage data structure.\n#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\npub struct StorageEntry<T> {\n    /// The value or `None` if the value has been removed.\n    value: Option<T>,\n    /// This is [`EntryState::Mutated`] if the value has been mutated and is in\n    /// need to be synchronized with the contract storage. If it is\n    /// [`EntryState::Preserved`] the value from the contract storage has been\n    /// preserved and does not need to be synchronized.\n    state: Cell<EntryState>,\n}\n\nimpl<T> Debug for StorageEntry<T>\nwhere\n    T: Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"Entry\")\n            .field(\"value\", &self.value)\n            .field(\"state\", &self.state.get())\n            .finish()\n    }\n}\n\n#[test]\nfn debug_impl_works() {\n    let e1 = <StorageEntry<i32>>::new(None, EntryState::Preserved);\n    assert_eq!(\n        format!(\"{:?}\", &e1),\n        \"Entry { value: None, state: Preserved }\",\n    );\n    let e2 = StorageEntry::new(Some(42), EntryState::Mutated);\n    assert_eq!(\n        format!(\"{:?}\", &e2),\n        \"Entry { value: Some(42), state: Mutated }\",\n    );\n}\n\n/// The state of the entry.\n#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\npub enum EntryState {\n    /// The entry's value must be synchronized with the contract storage.\n    Mutated,\n    /// The entry's value preserved the value from the contract storage.\n    Preserved,\n}\n\nimpl EntryState {\n    /// Returns `true` if the entry state is mutated.\n    pub fn is_mutated(self) -> bool {\n        match self {\n            EntryState::Mutated => true,\n            EntryState::Preserved => false,\n        }\n    }\n\n    /// Returns `true` if the entry state is preserved.\n    pub fn is_preserved(self) -> bool {\n        !self.is_mutated()\n    }\n}\n\nimpl<T> SpreadLayout for StorageEntry<T>\nwhere\n    T: SpreadLayout,\n{\n    const FOOTPRINT: u64 = <T as SpreadLayout>::FOOTPRINT;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        let root_key = ExtKeyPtr::next_for::<Self>(ptr);\n        Self::pull_spread_root(root_key)\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        let root_key = ExtKeyPtr::next_for::<Self>(ptr);\n        self.push_spread_root(root_key)\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        let root_key = ExtKeyPtr::next_for::<Self>(ptr);\n        self.clear_spread_root(root_key)\n    }\n}\n\nimpl<T> scale::Encode for StorageEntry<T>\nwhere\n    T: scale::Encode,\n{\n    #[inline]\n    fn size_hint(&self) -> usize {\n        <Option<T> as scale::Encode>::size_hint(&self.value)\n    }\n\n    #[inline]\n    fn encode_to<O: scale::Output + ?Sized>(&self, dest: &mut O) {\n        <Option<T> as scale::Encode>::encode_to(&self.value, dest)\n    }\n\n    #[inline]\n    fn encode(&self) -> Vec<u8> {\n        <Option<T> as scale::Encode>::encode(&self.value)\n    }\n\n    #[inline]\n    fn using_encoded<R, F: FnOnce(&[u8]) -> R>(&self, f: F) -> R {\n        <Option<T> as scale::Encode>::using_encoded(&self.value, f)\n    }\n}\n\nimpl<T> scale::Decode for StorageEntry<T>\nwhere\n    T: scale::Decode,\n{\n    fn decode<I: scale::Input>(input: &mut I) -> Result<Self, scale::Error> {\n        Ok(Self::new(\n            <Option<T> as scale::Decode>::decode(input)?,\n            EntryState::Preserved,\n        ))\n    }\n}\n\nimpl<T> PackedLayout for StorageEntry<T>\nwhere\n    T: PackedLayout,\n{\n    #[inline]\n    fn pull_packed(&mut self, at: &Key) {\n        PackedLayout::pull_packed(&mut self.value, at)\n    }\n\n    #[inline]\n    fn push_packed(&self, at: &Key) {\n        PackedLayout::push_packed(&self.value, at)\n    }\n\n    #[inline]\n    fn clear_packed(&self, at: &Key) {\n        PackedLayout::clear_packed(&self.value, at)\n    }\n}\n\nimpl<T> StorageEntry<T>\nwhere\n    T: SpreadLayout,\n{\n    /// Pulls the entity from the underlying associated storage as spreaded representation.\n    ///\n    /// # Note\n    ///\n    /// Mainly used by lazy storage abstractions that only allow operating on\n    /// packed storage entities such as [`LazyCell`][`crate::lazy::LazyCell`].\n    pub fn pull_spread_root(root_key: &Key) -> Self {\n        Self::new(pull_spread_root_opt::<T>(&root_key), EntryState::Preserved)\n    }\n\n    /// Pushes the underlying associated storage as spreaded representation.\n    ///\n    /// # Note\n    ///\n    /// Mainly used by lazy storage abstractions that only allow operating on\n    /// packed storage entities such as [`LazyCell`][`crate::lazy::LazyCell`].\n    pub fn push_spread_root(&self, root_key: &Key) {\n        let old_state = self.replace_state(EntryState::Preserved);\n        if old_state.is_mutated() {\n            push_spread_root_opt::<T>(self.value().into(), &root_key);\n        }\n    }\n\n    /// Clears the underlying associated storage as spreaded representation.\n    ///\n    /// # Note\n    ///\n    /// Mainly used by lazy storage abstractions that only allow operating on\n    /// packed storage entities such as [`LazyCell`][`crate::lazy::LazyCell`].\n    pub fn clear_spread_root(&self, root_key: &Key) {\n        clear_spread_root_opt::<T, _>(&root_key, || self.value().into());\n    }\n}\n\nimpl<T> StorageEntry<T>\nwhere\n    T: PackedLayout,\n{\n    /// Pulls the entity from the underlying associated storage as packed representation.\n    ///\n    /// # Note\n    ///\n    /// Mainly used by lazy storage abstractions that only allow operating on\n    /// packed storage entities such as [`LazyIndexMap`][`crate::lazy::LazyIndexMap`] or\n    /// [`LazyArray`][`crate::lazy::LazyArray`].\n    pub fn pull_packed_root(root_key: &Key) -> Self {\n        Self::new(pull_packed_root_opt::<T>(root_key), EntryState::Preserved)\n    }\n\n    /// Pushes the underlying associated storage as packed representation.\n    ///\n    /// # Note\n    ///\n    /// Mainly used by lazy storage abstractions that only allow operating on\n    /// packed storage entities such as [`LazyIndexMap`][`crate::lazy::LazyIndexMap`]\n    /// or [`LazyArray`][`crate::lazy::LazyArray`].\n    pub fn push_packed_root(&self, root_key: &Key) {\n        let old_state = self.replace_state(EntryState::Preserved);\n        if old_state.is_mutated() {\n            push_packed_root_opt::<T>(self.value().into(), &root_key);\n        }\n    }\n\n    /// Clears the underlying associated storage as packed representation.\n    ///\n    /// # Note\n    ///\n    /// Mainly used by lazy storage abstractions that only allow operating on\n    /// packed storage entities such as [`LazyIndexMap`][`crate::lazy::LazyIndexMap`]\n    /// or [`LazyArray`][`crate::lazy::LazyArray`].\n    pub fn clear_packed_root(&self, root_key: &Key) {\n        clear_packed_root::<Option<T>>(self.value(), &root_key);\n    }\n}\n\nimpl<T> StorageEntry<T> {\n    /// Creates a new entry with the value and state.\n    pub fn new(value: Option<T>, state: EntryState) -> Self {\n        Self {\n            value,\n            state: Cell::new(state),\n        }\n    }\n\n    /// Replaces the current entry state with the new state and returns it.\n    pub fn replace_state(&self, new_state: EntryState) -> EntryState {\n        // The implementation of `Cell::set` uses `Cell::replace` so instead\n        // of offering both APIs we simply opted to offer just the more general\n        // replace API for `Entry`.\n        self.state.replace(new_state)\n    }\n\n    /// Returns a shared reference to the value of the entry.\n    pub fn value(&self) -> &Option<T> {\n        &self.value\n    }\n\n    /// Returns an exclusive reference to the entry value.\n    ///\n    /// # Note\n    ///\n    /// This changes the `mutate` state of the entry if the entry was occupied\n    /// since the caller could potentially change the returned value.\n    pub fn value_mut(&mut self) -> &mut Option<T> {\n        if self.value.is_some() {\n            self.state.set(EntryState::Mutated);\n        }\n        &mut self.value\n    }\n\n    /// Converts the entry into its value.\n    pub fn into_value(self) -> Option<T> {\n        self.value\n    }\n\n    /// Puts the new value into the entry and returns the old value.\n    ///\n    /// # Note\n    ///\n    /// This changes the `mutate` state of the entry to `true` as long as at\n    /// least one of `old_value` and `new_value` is `Some`.\n    pub fn put(&mut self, new_value: Option<T>) -> Option<T> {\n        let new_value_is_some = new_value.is_some();\n        let old_value = core::mem::replace(&mut self.value, new_value);\n        if old_value.is_some() || new_value_is_some {\n            self.state.set(EntryState::Mutated);\n        }\n        old_value\n    }\n}\n"],["1021","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::{\n    CacheCell,\n    EntryState,\n    StorageEntry,\n};\nuse crate::traits::{\n    clear_packed_root,\n    pull_packed_root_opt,\n    ExtKeyPtr,\n    KeyPtr,\n    PackedLayout,\n    SpreadLayout,\n};\nuse core::{\n    fmt,\n    fmt::Debug,\n    mem,\n    ptr::NonNull,\n};\nuse ink_primitives::Key;\n\n/// The index type used in the lazy storage chunk.\npub type Index = u32;\n\n/// A lazy storage array that spans over N storage cells.\n///\n/// Storage data structure to emulate storage arrays: `[T; N]`.\n///\n/// # Note\n///\n/// Computes operations on the underlying N storage cells in a lazy fashion.\n/// Due to the size constraints the `LazyArray` is generally more efficient\n/// than the [`LazyMap`](`super::LazyIndexMap`) for most use cases with limited elements.\n///\n/// This is mainly used as low-level storage primitives by other high-level\n/// storage primitives in order to manage the contract storage for a whole\n/// chunk of storage cells.\npub struct LazyArray<T, const N: usize> {\n    /// The offset key for the N cells.\n    ///\n    /// If the lazy chunk has been initialized during contract initialization\n    /// the key will be `None` since there won't be a storage region associated\n    /// to the lazy chunk which prevents it from lazily loading elements. This,\n    /// however, is only checked at contract runtime. We might incorporate\n    /// compile-time checks for this particular use case later on.\n    key: Option<Key>,\n    /// The subset of currently cached entries of the lazy storage chunk.\n    ///\n    /// An entry is cached as soon as it is loaded or written.\n    cached_entries: EntryArray<T, N>,\n}\n\n#[cfg(feature = \"std\")]\nconst _: () = {\n    use crate::traits::StorageLayout;\n    use ink_metadata::layout::{\n        ArrayLayout,\n        CellLayout,\n        Layout,\n        LayoutKey,\n    };\n    use scale_info::TypeInfo;\n\n    impl<T, const N: usize> StorageLayout for LazyArray<T, N>\n    where\n        T: TypeInfo + 'static,\n    {\n        fn layout(key_ptr: &mut KeyPtr) -> Layout {\n            let capacity = N as u32;\n            Layout::Array(ArrayLayout::new(\n                LayoutKey::from(key_ptr.advance_by(capacity as u64)),\n                capacity,\n                1,\n                Layout::Cell(CellLayout::new::<T>(LayoutKey::from(\n                    key_ptr.advance_by(0),\n                ))),\n            ))\n        }\n    }\n};\n\nstruct DebugEntryArray<'a, T, const N: usize>(&'a EntryArray<T, N>)\nwhere\n    T: Debug;\n\nimpl<'a, T, const N: usize> Debug for DebugEntryArray<'a, T, N>\nwhere\n    T: Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_map()\n            .entries(self.0.iter().enumerate().filter_map(|(key, entry)| {\n                match entry {\n                    Some(entry) => Some((key, entry)),\n                    None => None,\n                }\n            }))\n            .finish()\n    }\n}\n\nimpl<T, const N: usize> Debug for LazyArray<T, N>\nwhere\n    T: Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"LazyArray\")\n            .field(\"key\", &self.key)\n            .field(\"cached_entries\", &DebugEntryArray(&self.cached_entries))\n            .finish()\n    }\n}\n\n#[test]\nfn debug_impl_works() {\n    let mut larray = <LazyArray<i32, 4>>::new();\n    // Empty imap.\n    assert_eq!(\n        format!(\"{:?}\", &larray),\n        \"LazyArray { key: None, cached_entries: {} }\",\n    );\n    // Filled imap.\n    larray.put(0, Some(1));\n    larray.put(2, Some(2));\n    larray.put(3, None);\n    assert_eq!(\n        format!(\"{:?}\", &larray),\n        \"LazyArray { \\\n            key: None, \\\n            cached_entries: {\\\n                0: Entry { \\\n                    value: Some(1), \\\n                    state: Mutated \\\n                }, \\\n                2: Entry { \\\n                    value: Some(2), \\\n                    state: Mutated \\\n                }, \\\n                3: Entry { \\\n                    value: None, \\\n                    state: Mutated \\\n                }\\\n            } \\\n        }\",\n    );\n}\n\n/// Returns the capacity for an array with the given array length.\nfn array_capacity<T, const N: usize>() -> u32 {\n    N as u32\n}\n\n/// The underlying array cache for the [`LazyArray`].\n#[derive(Debug)]\npub struct EntryArray<T, const N: usize> {\n    /// The cache entries of the entry array.\n    entries: [CacheCell<Option<StorageEntry<T>>>; N],\n}\n\n#[derive(Debug)]\npub struct EntriesIter<'a, T> {\n    iter: core::slice::Iter<'a, CacheCell<Option<StorageEntry<T>>>>,\n}\n\nimpl<'a, T> EntriesIter<'a, T> {\n    pub fn new<const N: usize>(entry_array: &'a EntryArray<T, N>) -> Self {\n        Self {\n            iter: entry_array.entries.iter(),\n        }\n    }\n}\n\nimpl<'a, T> Iterator for EntriesIter<'a, T> {\n    type Item = &'a Option<StorageEntry<T>>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|cell| cell.as_inner())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn count(self) -> usize\n    where\n        Self: Sized,\n    {\n        self.iter.count()\n    }\n}\n\nimpl<'a, T> DoubleEndedIterator for EntriesIter<'a, T> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.iter.next_back().map(|cell| cell.as_inner())\n    }\n}\n\nimpl<'a, T> ExactSizeIterator for EntriesIter<'a, T> {}\n\nimpl<T, const N: usize> EntryArray<T, N> {\n    /// Creates a new entry array cache.\n    pub fn new() -> Self {\n        Self {\n            entries: array_init::array_init(|_| Default::default()),\n        }\n    }\n}\n\nimpl<T, const N: usize> Default for EntryArray<T, N> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl<T, const N: usize> EntryArray<T, N> {\n    /// Returns the constant capacity of the lazy array.\n    #[inline]\n    pub fn capacity() -> u32 {\n        array_capacity::<T, N>()\n    }\n\n    /// Puts the the new value into the indexed slot and\n    /// returns the old value if any.\n    fn put(&self, at: Index, new_value: Option<T>) -> Option<T> {\n        mem::replace(\n            unsafe { self.entries[at as usize].get_ptr().as_mut() },\n            Some(StorageEntry::new(new_value, EntryState::Mutated)),\n        )\n        .map(StorageEntry::into_value)\n        .flatten()\n    }\n\n    /// Inserts a new entry into the cache and returns an exclusive reference to it.\n    unsafe fn insert_entry(\n        &self,\n        at: Index,\n        new_entry: StorageEntry<T>,\n    ) -> NonNull<StorageEntry<T>> {\n        let entry: &mut Option<StorageEntry<T>> =\n            &mut *CacheCell::get_ptr(&self.entries[at as usize]).as_ptr();\n        *entry = Some(new_entry);\n        entry\n            .as_mut()\n            .map(NonNull::from)\n            .expect(\"just inserted the entry\")\n    }\n\n    /// Returns an exclusive reference to the entry at the given index if any.\n    unsafe fn get_entry_mut(&self, at: Index) -> Option<&mut StorageEntry<T>> {\n        if at >= Self::capacity() {\n            return None\n        }\n        (&mut *CacheCell::get_ptr(&self.entries[at as usize]).as_ptr()).as_mut()\n    }\n\n    /// Returns an iterator that yields shared references to all cached entries.\n    pub fn iter(&self) -> EntriesIter<T> {\n        EntriesIter::new(self)\n    }\n}\n\nimpl<T, const N: usize> LazyArray<T, N>\nwhere\n    T: PackedLayout,\n{\n    /// Clears the underlying storage of the entry at the given index.\n    ///\n    /// # Safety\n    ///\n    /// For performance reasons this does not synchronize the lazy array's\n    /// memory-side cache which invalidates future accesses the cleared entry.\n    /// Care should be taken when using this API.\n    ///\n    /// The general use of this API is to streamline `Drop` implementations of\n    /// high-level abstractions that build upon this low-level data strcuture.\n    pub fn clear_packed_at(&self, index: Index) {\n        let root_key = self.key_at(index).expect(\"cannot clear in lazy state\");\n        if <T as SpreadLayout>::REQUIRES_DEEP_CLEAN_UP {\n            // We need to load the entity before we remove its associated contract storage\n            // because it requires a deep clean-up which propagates clearing to its fields,\n            // for example in the case of `T` being a `storage::Box`.\n            let entity = self.get(index).expect(\"cannot clear a non existing entity\");\n            clear_packed_root::<T>(&entity, &root_key);\n        } else {\n            // The type does not require deep clean-up so we can simply clean-up\n            // its associated storage cell and be done without having to load it first.\n            ink_env::clear_contract_storage(&root_key);\n        }\n    }\n}\n\nimpl<T, const N: usize> Default for LazyArray<T, N> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl<T, const N: usize> LazyArray<T, N> {\n    /// Creates a new empty lazy array.\n    ///\n    /// # Note\n    ///\n    /// A lazy array created this way cannot be used to load from the contract storage.\n    /// All operations that directly or indirectly load from storage will panic.\n    pub fn new() -> Self {\n        Self {\n            key: None,\n            cached_entries: Default::default(),\n        }\n    }\n\n    /// Creates a new empty lazy array positioned at the given key.\n    ///\n    /// # Note\n    ///\n    /// This constructor is private and should never need to be called from\n    /// outside this module. It is used to construct a lazy array from a\n    /// key that is only useful upon a contract call.\n    /// Use [`LazyArray::new`] for construction during contract initialization.\n    fn lazy(key: Key) -> Self {\n        Self {\n            key: Some(key),\n            cached_entries: Default::default(),\n        }\n    }\n\n    /// Returns the constant capacity of the lazy array.\n    #[inline]\n    pub fn capacity(&self) -> u32 {\n        array_capacity::<T, N>()\n    }\n\n    /// Returns the offset key of the lazy array if any.\n    pub fn key(&self) -> Option<&Key> {\n        self.key.as_ref()\n    }\n\n    /// Returns a shared reference to the underlying cached entries.\n    ///\n    /// # Safety\n    ///\n    /// This operation is safe since it returns a shared reference from\n    /// a `&self` which is viable in safe Rust.\n    fn cached_entries(&self) -> &EntryArray<T, N> {\n        &self.cached_entries\n    }\n\n    /// Puts a new value into the given indexed slot.\n    ///\n    /// # Note\n    ///\n    /// Use [`LazyArray::put_get`]`(None)` to remove an element.\n    pub fn put(&mut self, at: Index, new_value: Option<T>) {\n        self.cached_entries().put(at, new_value);\n    }\n}\n\nimpl<T, const N: usize> SpreadLayout for LazyArray<T, N>\nwhere\n    T: PackedLayout,\n{\n    const FOOTPRINT: u64 = N as u64;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        Self::lazy(*ExtKeyPtr::next_for::<Self>(ptr))\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        let offset_key = ExtKeyPtr::next_for::<Self>(ptr);\n        for (index, entry) in self.cached_entries().iter().enumerate() {\n            if let Some(entry) = entry {\n                let key = offset_key + (index as u64);\n                entry.push_packed_root(&key);\n            }\n        }\n    }\n\n    #[inline]\n    fn clear_spread(&self, _ptr: &mut KeyPtr) {\n        // Low-level lazy abstractions won't perform automated clean-up since\n        // they generally are not aware of their entire set of associated\n        // elements. The high-level abstractions that build upon them are\n        // responsible for cleaning up.\n    }\n}\n\nimpl<T, const N: usize> LazyArray<T, N> {\n    /// Returns the offset key for the given index if not out of bounds.\n    pub fn key_at(&self, at: Index) -> Option<Key> {\n        if at >= self.capacity() {\n            return None\n        }\n        self.key.as_ref().map(|key| key + at as u64)\n    }\n}\n\nimpl<T, const N: usize> LazyArray<T, N>\nwhere\n    T: PackedLayout,\n{\n    /// Loads the entry at the given index.\n    ///\n    /// Tries to load the entry from cache and falls back to lazily load the\n    /// entry from the contract storage.\n    fn load_through_cache(&self, at: Index) -> NonNull<StorageEntry<T>> {\n        assert!(at < self.capacity(), \"index is out of bounds\");\n        match unsafe { self.cached_entries.get_entry_mut(at) } {\n            Some(entry) => {\n                // Load value from cache.\n                NonNull::from(entry)\n            }\n            None => {\n                // Load value from storage and put into cache.\n                // Then load value from cache.\n                let value = self\n                    .key_at(at)\n                    .map(|key| pull_packed_root_opt::<T>(&key))\n                    .unwrap_or(None);\n                let entry = StorageEntry::new(value, EntryState::Preserved);\n                unsafe { self.cached_entries.insert_entry(at, entry) }\n            }\n        }\n    }\n\n    /// Loads the entry at the given index.\n    ///\n    /// Tries to load the entry from cache and falls back to lazily load the\n    /// entry from the contract storage.\n    ///\n    /// # Panics\n    ///\n    /// - If the lazy array is in a state that forbids lazy loading.\n    /// - If the given index is out of bounds.\n    fn load_through_cache_mut(&mut self, index: Index) -> &mut StorageEntry<T> {\n        // SAFETY:\n        // Returning a `&mut Entry<T>` from within a `&mut self` function\n        // won't allow creating aliasing between exclusive references.\n        unsafe { &mut *self.load_through_cache(index).as_ptr() }\n    }\n\n    /// Returns a shared reference to the element at the given index if any.\n    ///\n    /// # Note\n    ///\n    /// This operation eventually loads from contract storage.\n    ///\n    /// # Panics\n    ///\n    /// If the given index is out of bounds.\n    pub fn get(&self, at: Index) -> Option<&T> {\n        unsafe { &*self.load_through_cache(at).as_ptr() }\n            .value()\n            .into()\n    }\n\n    /// Returns an exclusive reference to the element at the given index if any.\n    ///\n    /// # Note\n    ///\n    /// This operation eventually loads from contract storage.\n    ///\n    /// # Panics\n    ///\n    /// If the given index is out of bounds.\n    pub fn get_mut(&mut self, at: Index) -> Option<&mut T> {\n        self.load_through_cache_mut(at).value_mut().into()\n    }\n\n    /// Puts the new value into the indexed slot and returns the old value if any.\n    ///\n    /// # Note\n    ///\n    /// - This operation eventually loads from contract storage.\n    /// - Prefer [`LazyArray::put`] if you are not interested in the old value.\n    /// - Use [`LazyArray::put_get`]`(None)` to remove an element.\n    ///\n    /// # Panics\n    ///\n    /// If the given index is out of bounds.\n    pub fn put_get(&mut self, at: Index, new_value: Option<T>) -> Option<T> {\n        self.load_through_cache_mut(at).put(new_value)\n    }\n\n    /// Swaps the values at indices x and y.\n    ///\n    /// # Note\n    ///\n    /// This operation eventually loads from contract storage.\n    ///\n    /// # Panics\n    ///\n    /// If any of the given indices is out of bounds.\n    pub fn swap(&mut self, a: Index, b: Index) {\n        assert!(a < self.capacity(), \"a is out of bounds\");\n        assert!(b < self.capacity(), \"b is out of bounds\");\n        if a == b {\n            // Bail out early if both indices are the same.\n            return\n        }\n        let (loaded_a, loaded_b) =\n            // SAFETY: The loaded `x` and `y` entries are distinct from each\n            //         other guaranteed by the previous checks so they cannot\n            //         alias.\n            unsafe { (\n                &mut *self.load_through_cache(a).as_ptr(),\n                &mut *self.load_through_cache(b).as_ptr(),\n            ) };\n        if loaded_a.value().is_none() && loaded_b.value().is_none() {\n            // Bail out since nothing has to be swapped if both values are `None`.\n            return\n        }\n        // At this point at least one of the values is `Some` so we have to\n        // perform the swap and set both entry states to mutated.\n        loaded_a.replace_state(EntryState::Mutated);\n        loaded_b.replace_state(EntryState::Mutated);\n        core::mem::swap(loaded_a.value_mut(), loaded_b.value_mut());\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{\n        super::{\n            EntryState,\n            StorageEntry,\n        },\n        Index,\n        LazyArray,\n    };\n    use crate::traits::{\n        KeyPtr,\n        SpreadLayout,\n    };\n    use ink_primitives::Key;\n\n    /// Asserts that the cached entries of the given `imap` is equal to the `expected` slice.\n    fn assert_cached_entries<const N: usize>(\n        larray: &LazyArray<u8, N>,\n        expected: &[(Index, StorageEntry<u8>)],\n    ) {\n        let mut len = 0;\n        for (given, expected) in larray\n            .cached_entries()\n            .iter()\n            .enumerate()\n            .filter_map(|(index, entry)| {\n                match entry {\n                    Some(entry) => Some((index as u32, entry)),\n                    None => None,\n                }\n            })\n            .zip(expected.iter().map(|(index, entry)| (*index, entry)))\n        {\n            assert_eq!(given, expected);\n            len += 1;\n        }\n        assert_eq!(len, expected.len());\n    }\n\n    #[test]\n    fn new_works() {\n        let larray = <LazyArray<u8, 4>>::new();\n        // Key must be none.\n        assert_eq!(larray.key(), None);\n        assert_eq!(larray.key_at(0), None);\n        assert_eq!(larray.capacity(), 4);\n        // Cached elements must be empty.\n        assert_cached_entries(&larray, &[]);\n        // Same as default:\n        let default_larray = <LazyArray<u8, 4>>::default();\n        assert_eq!(default_larray.key(), larray.key());\n        assert_eq!(default_larray.key_at(0), larray.key_at(0));\n        assert_eq!(larray.capacity(), 4);\n        assert_cached_entries(&default_larray, &[]);\n    }\n\n    #[test]\n    fn lazy_works() {\n        let key = Key::from([0x42; 32]);\n        let larray = <LazyArray<u8, 4>>::lazy(key);\n        // Key must be Some.\n        assert_eq!(larray.key(), Some(&key));\n        assert_eq!(larray.key_at(0), Some(key));\n        assert_eq!(larray.key_at(1), Some(key + 1u64));\n        assert_eq!(larray.capacity(), 4);\n        // Cached elements must be empty.\n        assert_cached_entries(&larray, &[]);\n    }\n\n    #[test]\n    fn get_works() {\n        let mut larray = <LazyArray<u8, 4>>::new();\n        let nothing_changed = &[\n            (0, StorageEntry::new(None, EntryState::Preserved)),\n            (1, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n            (2, StorageEntry::new(None, EntryState::Preserved)),\n            (3, StorageEntry::new(Some(b'D'), EntryState::Mutated)),\n        ];\n        // Put some values.\n        assert_eq!(larray.put_get(0, None), None);\n        assert_eq!(larray.put_get(1, Some(b'B')), None);\n        assert_eq!(larray.put_get(2, None), None);\n        assert_eq!(larray.put_get(3, Some(b'D')), None);\n        assert_cached_entries(&larray, nothing_changed);\n        // `get` works:\n        assert_eq!(larray.get(0), None);\n        assert_eq!(larray.get(1), Some(&b'B'));\n        assert_eq!(larray.get(2), None);\n        assert_eq!(larray.get(3), Some(&b'D'));\n        assert_cached_entries(&larray, nothing_changed);\n        // `get_mut` works:\n        assert_eq!(larray.get_mut(0), None);\n        assert_eq!(larray.get_mut(1), Some(&mut b'B'));\n        assert_eq!(larray.get_mut(2), None);\n        assert_eq!(larray.get_mut(3), Some(&mut b'D'));\n        assert_cached_entries(&larray, nothing_changed);\n    }\n\n    #[test]\n    #[should_panic(expected = \"index is out of bounds\")]\n    fn get_out_of_bounds_works() {\n        let larray = <LazyArray<u8, 4>>::new();\n        let _ = larray.get(4);\n    }\n\n    #[test]\n    fn put_get_works() {\n        let mut larray = <LazyArray<u8, 4>>::new();\n        // Assert that the array cache is empty at first.\n        assert_cached_entries(&larray, &[]);\n        // Put none values.\n        assert_eq!(larray.put_get(0, None), None);\n        assert_eq!(larray.put_get(1, None), None);\n        assert_eq!(larray.put_get(3, None), None);\n        assert_cached_entries(\n            &larray,\n            &[\n                (0, StorageEntry::new(None, EntryState::Preserved)),\n                (1, StorageEntry::new(None, EntryState::Preserved)),\n                (3, StorageEntry::new(None, EntryState::Preserved)),\n            ],\n        );\n        // Override with some values.\n        assert_eq!(larray.put_get(0, Some(b'A')), None);\n        assert_eq!(larray.put_get(1, Some(b'B')), None);\n        assert_eq!(larray.put_get(3, None), None);\n        assert_cached_entries(\n            &larray,\n            &[\n                (0, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (1, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n                (3, StorageEntry::new(None, EntryState::Preserved)),\n            ],\n        );\n        // Override some values with none.\n        assert_eq!(larray.put_get(1, None), Some(b'B'));\n        assert_eq!(larray.put_get(3, None), None);\n        assert_cached_entries(\n            &larray,\n            &[\n                (0, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (1, StorageEntry::new(None, EntryState::Mutated)),\n                (3, StorageEntry::new(None, EntryState::Preserved)),\n            ],\n        );\n    }\n\n    #[test]\n    #[should_panic(expected = \"index is out of bounds\")]\n    fn put_get_out_of_bounds_works() {\n        let mut larray = <LazyArray<u8, 4>>::new();\n        let _ = larray.put_get(4, Some(b'A'));\n    }\n\n    #[test]\n    fn put_works() {\n        let mut larray = <LazyArray<u8, 4>>::new();\n        // Put some values.\n        larray.put(0, None);\n        larray.put(1, Some(b'B'));\n        larray.put(3, None);\n        // The main difference between `put` and `put_get` is that `put` never\n        // loads from storage which also has one drawback: Putting a `None`\n        // value always ends-up in `Mutated` state for the entry even if the\n        // entry is already `None`.\n        assert_cached_entries(\n            &larray,\n            &[\n                (0, StorageEntry::new(None, EntryState::Mutated)),\n                (1, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n                (3, StorageEntry::new(None, EntryState::Mutated)),\n            ],\n        );\n        // Overwrite entries:\n        larray.put(0, Some(b'A'));\n        larray.put(1, None);\n        larray.put(2, Some(b'C'));\n        larray.put(3, None);\n        assert_cached_entries(\n            &larray,\n            &[\n                (0, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (1, StorageEntry::new(None, EntryState::Mutated)),\n                (2, StorageEntry::new(Some(b'C'), EntryState::Mutated)),\n                (3, StorageEntry::new(None, EntryState::Mutated)),\n            ],\n        );\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds: the len is 4 but the index is 4\")]\n    fn put_out_of_bounds_works() {\n        let mut larray = <LazyArray<u8, 4>>::new();\n        larray.put(4, Some(b'A'));\n    }\n\n    #[test]\n    fn swap_works() {\n        let mut larray = <LazyArray<u8, 4>>::new();\n        let nothing_changed = &[\n            (0, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n            (1, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n            (2, StorageEntry::new(None, EntryState::Preserved)),\n            (3, StorageEntry::new(None, EntryState::Preserved)),\n        ];\n        // Put some values.\n        assert_eq!(larray.put_get(0, Some(b'A')), None);\n        assert_eq!(larray.put_get(1, Some(b'B')), None);\n        assert_eq!(larray.put_get(2, None), None);\n        assert_eq!(larray.put_get(3, None), None);\n        assert_cached_entries(&larray, nothing_changed);\n        // Swap same indices: Check that nothing has changed.\n        for i in 0..4 {\n            larray.swap(i, i);\n        }\n        assert_cached_entries(&larray, nothing_changed);\n        // Swap `None` values: Check that nothing has changed.\n        larray.swap(2, 3);\n        larray.swap(3, 2);\n        assert_cached_entries(&larray, nothing_changed);\n        // Swap `Some` and `None`:\n        larray.swap(0, 2);\n        assert_cached_entries(\n            &larray,\n            &[\n                (0, StorageEntry::new(None, EntryState::Mutated)),\n                (1, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n                (2, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (3, StorageEntry::new(None, EntryState::Preserved)),\n            ],\n        );\n        // Swap `Some` and `Some`:\n        larray.swap(1, 2);\n        assert_cached_entries(\n            &larray,\n            &[\n                (0, StorageEntry::new(None, EntryState::Mutated)),\n                (1, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (2, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n                (3, StorageEntry::new(None, EntryState::Preserved)),\n            ],\n        );\n    }\n\n    #[test]\n    #[should_panic(expected = \"b is out of bounds\")]\n    fn swap_rhs_out_of_bounds() {\n        let mut larray = <LazyArray<u8, 4>>::new();\n        larray.swap(0, 4);\n    }\n\n    #[test]\n    #[should_panic(expected = \"a is out of bounds\")]\n    fn swap_both_out_of_bounds() {\n        let mut larray = <LazyArray<u8, 4>>::new();\n        larray.swap(4, 4);\n    }\n\n    #[test]\n    fn spread_layout_works() -> ink_env::Result<()> {\n        ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n            let mut larray = <LazyArray<u8, 4>>::new();\n            let nothing_changed = &[\n                (0, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (1, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n                (2, StorageEntry::new(None, EntryState::Preserved)),\n                (3, StorageEntry::new(None, EntryState::Preserved)),\n            ];\n            // Put some values.\n            assert_eq!(larray.put_get(0, Some(b'A')), None);\n            assert_eq!(larray.put_get(1, Some(b'B')), None);\n            assert_eq!(larray.put_get(2, None), None);\n            assert_eq!(larray.put_get(3, None), None);\n            assert_cached_entries(&larray, nothing_changed);\n            // Push the lazy index map onto the contract storage and then load\n            // another instance of it from the contract stoarge.\n            // Then: Compare both instances to be equal.\n            let root_key = Key::from([0x42; 32]);\n            SpreadLayout::push_spread(&larray, &mut KeyPtr::from(root_key));\n            let larray2 = <LazyArray<u8, 4> as SpreadLayout>::pull_spread(\n                &mut KeyPtr::from(root_key),\n            );\n            assert_cached_entries(&larray2, &[]);\n            assert_eq!(larray2.get(0), Some(&b'A'));\n            assert_eq!(larray2.get(1), Some(&b'B'));\n            assert_eq!(larray2.get(2), None);\n            assert_eq!(larray2.get(3), None);\n            assert_cached_entries(\n                &larray2,\n                &[\n                    (0, StorageEntry::new(Some(b'A'), EntryState::Preserved)),\n                    (1, StorageEntry::new(Some(b'B'), EntryState::Preserved)),\n                    (2, StorageEntry::new(None, EntryState::Preserved)),\n                    (3, StorageEntry::new(None, EntryState::Preserved)),\n                ],\n            );\n            // Clear the first lazy index map instance and reload another instance\n            // to check whether the associated storage has actually been freed\n            // again:\n            SpreadLayout::clear_spread(&larray2, &mut KeyPtr::from(root_key));\n            // The above `clear_spread` call is a no-op since lazy index map is\n            // generally not aware of its associated elements. So we have to\n            // manually clear them from the contract storage which is what the\n            // high-level data structures like `storage::Vec` would command:\n            larray2.clear_packed_at(0);\n            larray2.clear_packed_at(1);\n            larray2.clear_packed_at(2); // Not really needed here.\n            larray2.clear_packed_at(3); // Not really needed here.\n            let larray3 = <LazyArray<u8, 4> as SpreadLayout>::pull_spread(\n                &mut KeyPtr::from(root_key),\n            );\n            assert_cached_entries(&larray3, &[]);\n            assert_eq!(larray3.get(0), None);\n            assert_eq!(larray3.get(1), None);\n            assert_eq!(larray3.get(2), None);\n            assert_eq!(larray3.get(3), None);\n            assert_cached_entries(\n                &larray3,\n                &[\n                    (0, StorageEntry::new(None, EntryState::Preserved)),\n                    (1, StorageEntry::new(None, EntryState::Preserved)),\n                    (2, StorageEntry::new(None, EntryState::Preserved)),\n                    (3, StorageEntry::new(None, EntryState::Preserved)),\n                ],\n            );\n            Ok(())\n        })\n    }\n}\n"],["1022","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse core::{\n    cell::UnsafeCell,\n    fmt,\n    fmt::Debug,\n    ptr::NonNull,\n};\n\n/// A cache for a `T` that allow to mutate the inner `T` through `&self`.\n///\n/// Internally this is a thin wrapper around an `UnsafeCell<T>`.\n/// The main difference to `UnsafeCell` is that this type provides an out of the\n/// box API to safely access the inner `T` as well for single threaded contexts.\npub struct CacheCell<T: ?Sized> {\n    /// The inner value that is allowed to be mutated in shared contexts.\n    inner: UnsafeCell<T>,\n}\n\nimpl<T> CacheCell<T> {\n    /// Creates a new cache cell from the given value.\n    pub fn new(value: T) -> Self {\n        Self {\n            inner: UnsafeCell::new(value),\n        }\n    }\n\n    /// Returns the inner value.\n    #[allow(dead_code)]\n    pub fn into_inner(self) -> T {\n        self.inner.into_inner()\n    }\n}\n\nimpl<T> Debug for CacheCell<T>\nwhere\n    T: ?Sized + Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        <T as Debug>::fmt(self.as_inner(), f)\n    }\n}\n\nimpl<T> From<T> for CacheCell<T> {\n    fn from(value: T) -> Self {\n        Self::new(value)\n    }\n}\n\nimpl<T> Default for CacheCell<T>\nwhere\n    T: Default,\n{\n    fn default() -> Self {\n        Self::new(<T as Default>::default())\n    }\n}\n\nimpl<T> CacheCell<T>\nwhere\n    T: ?Sized,\n{\n    /// Returns a shared reference to the inner value.\n    pub fn as_inner(&self) -> &T {\n        // SAFETY: This is safe since we are returning a shared reference back\n        //         to the caller while this method itself accesses `self` as\n        //         shared reference.\n        unsafe { &*self.inner.get() }\n    }\n\n    /// Returns an exclusive reference to the inner value.\n    pub fn as_inner_mut(&mut self) -> &mut T {\n        // SAFETY: This is safe since we are returning the exclusive reference\n        //         of the inner value through the `get_mut` API which itself\n        //         requires exclusive reference access to the wrapping `self`\n        //         disallowing aliasing exclusive references.\n        unsafe { &mut *self.inner.get() }\n    }\n\n    /// Returns a mutable pointer to the inner value.\n    pub fn get_ptr(&self) -> NonNull<T> {\n        // SAFETY: The inner `T` of the internal `UnsafeCell` exists and thus\n        //         the pointer that we get returned to it via `UnsafeCell::get`\n        //         is never going to be `null`.\n        unsafe { NonNull::new_unchecked(self.inner.get()) }\n    }\n}\n"],["1023","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! A lazy storage mapping that stores entries under their SCALE encoded key hashes.\n\nuse super::{\n    CacheCell,\n    EntryState,\n    StorageEntry,\n};\nuse crate::traits::{\n    clear_packed_root,\n    pull_packed_root_opt,\n    ExtKeyPtr,\n    KeyPtr,\n    PackedLayout,\n    SpreadLayout,\n};\nuse core::{\n    borrow::Borrow,\n    cmp::{\n        Eq,\n        Ord,\n    },\n    fmt,\n    fmt::Debug,\n    iter::FromIterator,\n    marker::PhantomData,\n    ptr::NonNull,\n};\nuse ink_env::hash::{\n    CryptoHash,\n    HashOutput,\n};\nuse ink_prelude::{\n    borrow::ToOwned,\n    boxed::Box,\n    collections::btree_map::{\n        BTreeMap,\n        Entry as BTreeMapEntry,\n        OccupiedEntry as BTreeMapOccupiedEntry,\n    },\n};\nuse ink_primitives::Key;\n\n/// The map for the contract storage entries.\n///\n/// # Note\n///\n/// We keep the whole entry in a `Box<T>` in order to prevent pointer\n/// invalidation upon updating the cache through `&self` methods as in\n/// [`LazyHashMap::get`].\npub type EntryMap<K, V> = BTreeMap<K, Box<StorageEntry<V>>>;\n\n/// A lazy storage mapping that stores entries under their SCALE encoded key hashes.\n///\n/// # Note\n///\n/// This is mainly used as low-level storage primitives by other high-level\n/// storage primitives in order to manage the contract storage for a whole\n/// mapping of storage cells.\n///\n/// This storage data structure might store its entires anywhere in the contract\n/// storage. It is the users responsibility to keep track of the entries if it\n/// is necessary to do so.\npub struct LazyHashMap<K, V, H> {\n    /// The offset key for the storage mapping.\n    ///\n    /// This offsets the mapping for the entries stored in the contract storage\n    /// so that all lazy hash map instances store equal entries at different\n    /// locations of the contract storage and avoid collisions.\n    key: Option<Key>,\n    /// The currently cached entries of the lazy storage mapping.\n    ///\n    /// This normally only represents a subset of the total set of elements.\n    /// An entry is cached as soon as it is loaded or written.\n    cached_entries: CacheCell<EntryMap<K, V>>,\n    /// The used hash builder.\n    hash_builder: PhantomData<H>,\n}\n\n/// When querying `entry()` there is a case which needs special treatment:\n/// In `entry()` we first do a look-up in the cache. If the requested key is\n/// in the cache we return the found object.\n/// If it is not in the cache we query the storage. If we find the element\n/// in storage we insert it into the cache.\n///\n/// The problem now is that in this case we only have the `Vacant` object\n/// which we got from searching in the cache, but we need to return an\n/// `Occupied` here, since the object is now in the cache. We could do this\n/// by querying the cache another time -- but this would be an additional\n/// search. So what we do instead is to save a reference to the inserted\n/// cache value in the `Occupied`. As a consequence all Entry API operations\n/// (`get`, `remove`, ...) need to distinguish both cases.\nenum EntryOrMutableValue<E, V> {\n    /// An occupied `EntryMap` entry that holds a value.\n    /// This represents the case where the key was in the cache.\n    EntryElementWasInCache(E),\n    /// A reference to the mutable value behind a cache entry.\n    /// This represents the case where the key was not in the cache, but in storage.\n    MutableValueElementWasNotInCache(V),\n}\n\n/// An occupied `EntryMap` entry that holds a value.\ntype OccupiedCache<'a, K, V> = BTreeMapOccupiedEntry<'a, K, Box<StorageEntry<V>>>;\n\n/// An occupied entry that holds the value.\npub struct OccupiedEntry<'a, K, V>\nwhere\n    K: Clone,\n{\n    /// The key stored in this entry.\n    key: K,\n    /// Either the occupied `EntryMap` entry that holds the value or a mutable reference\n    /// to the value behind a cache entry.\n    entry: EntryOrMutableValue<OccupiedCache<'a, K, V>, &'a mut Box<StorageEntry<V>>>,\n}\n\n/// A vacant entry with previous and next vacant indices.\npub struct VacantEntry<'a, K, V>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PackedLayout,\n{\n    /// The key stored in this entry.\n    key: K,\n    /// The entry within the `LazyHashMap`. This entry can be either occupied or vacant.\n    /// In an `BTreeMapEntry::Occupied` state the entry has been marked to\n    /// be removed (with `None`), but we still want to expose the `VacantEntry` API\n    /// to the use.\n    /// In an `BTreeMapEntry::Vacant` state the entry is vacant and we want to expose\n    /// the `VacantEntry` API.\n    entry: BTreeMapEntry<'a, K, Box<StorageEntry<V>>>,\n}\n\n/// An entry within the `LazyHashMap`.\npub enum Entry<'a, K: 'a, V: 'a>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PackedLayout,\n{\n    /// A vacant entry that holds the index to the next and previous vacant entry.\n    Vacant(VacantEntry<'a, K, V>),\n    /// An occupied entry that holds the value.\n    Occupied(OccupiedEntry<'a, K, V>),\n}\n\nstruct DebugEntryMap<'a, K, V>(&'a CacheCell<EntryMap<K, V>>);\n\nimpl<'a, K, V> Debug for DebugEntryMap<'a, K, V>\nwhere\n    K: Debug,\n    V: Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_map().entries(self.0.as_inner().iter()).finish()\n    }\n}\n\nimpl<K, V, H> Debug for LazyHashMap<K, V, H>\nwhere\n    K: Debug,\n    V: Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        // The `hash_builder` field is not really required or needed for debugging purposes.\n        f.debug_struct(\"LazyHashMap\")\n            .field(\"key\", &self.key)\n            .field(\"cached_entries\", &DebugEntryMap(&self.cached_entries))\n            .finish()\n    }\n}\n\n#[test]\nfn debug_impl_works() {\n    use ink_env::hash::Blake2x256;\n    let mut hmap = <LazyHashMap<char, i32, Blake2x256>>::new();\n    // Empty hmap.\n    assert_eq!(\n        format!(\"{:?}\", &hmap),\n        \"LazyHashMap { key: None, cached_entries: {} }\",\n    );\n    // Filled hmap.\n    hmap.put('A', Some(1));\n    hmap.put('B', Some(2));\n    hmap.put('C', None);\n    assert_eq!(\n        format!(\"{:?}\", &hmap),\n        \"LazyHashMap { \\\n            key: None, \\\n            cached_entries: {\\\n                'A': Entry { \\\n                    value: Some(1), \\\n                    state: Mutated \\\n                }, \\\n                'B': Entry { \\\n                    value: Some(2), \\\n                    state: Mutated \\\n                }, \\\n                'C': Entry { \\\n                    value: None, \\\n                    state: Mutated \\\n                }\\\n            } \\\n        }\",\n    );\n}\n\n#[cfg(feature = \"std\")]\nconst _: () = {\n    use crate::traits::{\n        LayoutCryptoHasher,\n        StorageLayout,\n    };\n    use ink_metadata::layout::{\n        CellLayout,\n        HashLayout,\n        HashingStrategy,\n        Layout,\n        LayoutKey,\n    };\n    use scale_info::TypeInfo;\n\n    impl<K, V, H> StorageLayout for LazyHashMap<K, V, H>\n    where\n        K: Ord + scale::Encode,\n        V: TypeInfo + 'static,\n        H: CryptoHash + LayoutCryptoHasher,\n        Key: From<<H as HashOutput>::Type>,\n    {\n        fn layout(key_ptr: &mut KeyPtr) -> Layout {\n            Layout::Hash(HashLayout::new(\n                LayoutKey::from(key_ptr.advance_by(1)),\n                HashingStrategy::new(\n                    <H as LayoutCryptoHasher>::crypto_hasher(),\n                    b\"ink hashmap\".to_vec(),\n                    Vec::new(),\n                ),\n                Layout::Cell(CellLayout::new::<V>(LayoutKey::from(\n                    key_ptr.advance_by(0),\n                ))),\n            ))\n        }\n    }\n};\n\nimpl<K, V, H> SpreadLayout for LazyHashMap<K, V, H>\nwhere\n    K: Ord + scale::Encode,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    const FOOTPRINT: u64 = 1;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        Self::lazy(*ExtKeyPtr::next_for::<Self>(ptr))\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        let offset_key = ExtKeyPtr::next_for::<Self>(ptr);\n        for (index, entry) in self.entries().iter() {\n            let root_key = self.to_offset_key(&offset_key, index);\n            entry.push_packed_root(&root_key);\n        }\n    }\n\n    #[inline]\n    fn clear_spread(&self, _ptr: &mut KeyPtr) {\n        // Low-level lazy abstractions won't perform automated clean-up since\n        // they generally are not aware of their entire set of associated\n        // elements. The high-level abstractions that build upon them are\n        // responsible for cleaning up.\n    }\n}\n\n// # Developer Note\n//\n// Even thought `LazyHashMap` would require storing just a single key a thus\n// be a packable storage entity we cannot really make it one since this could\n// allow for overlapping lazy hash map instances.\n// An example for this would be a `Pack<(LazyHashMap, LazyHashMap)>` where\n// both lazy hash maps would use the same underlying key and thus would apply\n// the same underlying key mapping.\n\nimpl<K, V, H> Default for LazyHashMap<K, V, H>\nwhere\n    K: Ord,\n{\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl<K, V, H> FromIterator<(K, V)> for LazyHashMap<K, V, H>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = (K, V)>,\n    {\n        let mut hmap = LazyHashMap::new();\n        hmap.extend(iter);\n        hmap\n    }\n}\n\nimpl<K, V, H> Extend<(K, V)> for LazyHashMap<K, V, H>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    fn extend<I>(&mut self, iter: I)\n    where\n        I: IntoIterator<Item = (K, V)>,\n    {\n        for (key, value) in iter {\n            self.put(key, Some(value));\n        }\n    }\n}\n\nimpl<K, V, H> LazyHashMap<K, V, H>\nwhere\n    K: Ord,\n{\n    /// Creates a new empty lazy hash map.\n    ///\n    /// # Note\n    ///\n    /// A lazy map created this way cannot be used to load from the contract storage.\n    /// All operations that directly or indirectly load from storage will panic.\n    pub fn new() -> Self {\n        Self {\n            key: None,\n            cached_entries: CacheCell::new(EntryMap::new()),\n            hash_builder: Default::default(),\n        }\n    }\n\n    /// Creates a new empty lazy hash map positioned at the given key.\n    ///\n    /// # Note\n    ///\n    /// This constructor is private and should never need to be called from\n    /// outside this module. It is used to construct a lazy index map from a\n    /// key that is only useful upon a contract call. Use\n    /// [`LazyIndexMap::new`][`crate::lazy::LazyIndexMap::new`]\n    /// for construction during contract initialization.\n    fn lazy(key: Key) -> Self {\n        Self {\n            key: Some(key),\n            cached_entries: CacheCell::new(EntryMap::new()),\n            hash_builder: Default::default(),\n        }\n    }\n\n    /// Returns the offset key of the lazy map if any.\n    pub fn key(&self) -> Option<&Key> {\n        self.key.as_ref()\n    }\n\n    /// Returns the length of the cached entries.\n    #[cfg(test)]\n    pub(crate) fn len_cached_entries(&self) -> usize {\n        self.entries().len()\n    }\n\n    /// Returns a shared reference to the underlying entries.\n    fn entries(&self) -> &EntryMap<K, V> {\n        self.cached_entries.as_inner()\n    }\n\n    /// Returns an exclusive reference to the underlying entries.\n    fn entries_mut(&mut self) -> &mut EntryMap<K, V> {\n        self.cached_entries.as_inner_mut()\n    }\n\n    /// Puts the new value under the given key.\n    ///\n    /// # Note\n    ///\n    /// - Use [`LazyHashMap::put`]`(None)` in order to remove an element.\n    /// - Prefer this method over [`LazyHashMap::put_get`] if you are not interested\n    ///   in the old value of the same cell index.\n    ///\n    /// # Panics\n    ///\n    /// - If the lazy hash map is in an invalid state that forbids interaction\n    ///   with the underlying contract storage.\n    /// - If the decoding of the old element at the given index failed.\n    pub fn put(&mut self, key: K, new_value: Option<V>) {\n        self.entries_mut().insert(\n            key,\n            Box::new(StorageEntry::new(new_value, EntryState::Mutated)),\n        );\n    }\n}\n\nimpl<K, V, H> LazyHashMap<K, V, H>\nwhere\n    K: Clone + Ord + PackedLayout,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    /// Gets the given key's corresponding entry in the map for in-place manipulation.\n    pub fn entry(&mut self, key: K) -> Entry<K, V> {\n        // SAFETY: We have put the whole `cached_entries` mapping into an\n        //         `UnsafeCell` because of this caching functionality. The\n        //         trick here is that due to using `Box<T>` internally\n        //         we are able to return references to the cached entries\n        //         while maintaining the invariant that mutating the caching\n        //         `BTreeMap` will never invalidate those references.\n        //         By returning a raw pointer we enforce an `unsafe` block at\n        //         the caller site to underline that guarantees are given by the\n        //         caller.\n        let cached_entries = unsafe { &mut *self.cached_entries.get_ptr().as_ptr() };\n        // We have to clone the key here because we do not have access to the unsafe\n        // raw entry API for Rust hash maps, yet since it is unstable. We can remove\n        // the constraints on `K: Clone` once we have access to this API.\n        // Read more about the issue here: https://github.com/rust-lang/rust/issues/56167\n        match cached_entries.entry(key.to_owned()) {\n            BTreeMapEntry::Occupied(entry) => {\n                match entry.get().value() {\n                    Some(_) => {\n                        Entry::Occupied(OccupiedEntry {\n                            key,\n                            entry: EntryOrMutableValue::EntryElementWasInCache(entry),\n                        })\n                    }\n                    None => {\n                        // value is already marked as to be removed\n                        Entry::Vacant(VacantEntry {\n                            key,\n                            entry: BTreeMapEntry::Occupied(entry),\n                        })\n                    }\n                }\n            }\n            BTreeMapEntry::Vacant(entry) => {\n                let value = self\n                    .key_at(&key)\n                    .map(|key| pull_packed_root_opt::<V>(&key))\n                    .unwrap_or(None);\n                match value.is_some() {\n                    true => {\n                        // The entry was not in the cache, but in the storage. This results in\n                        // a problem: We only have `Vacant` here, but need to return `Occupied`,\n                        // to reflect this.\n                        let v_mut = entry.insert(Box::new(StorageEntry::new(\n                            value,\n                            EntryState::Preserved,\n                        )));\n                        Entry::Occupied(OccupiedEntry {\n                            key,\n                            entry: EntryOrMutableValue::MutableValueElementWasNotInCache(\n                                v_mut,\n                            ),\n                        })\n                    }\n                    false => {\n                        Entry::Vacant(VacantEntry {\n                            key,\n                            entry: BTreeMapEntry::Vacant(entry),\n                        })\n                    }\n                }\n            }\n        }\n    }\n}\n\nimpl<K, V, H> LazyHashMap<K, V, H>\nwhere\n    K: Ord + scale::Encode,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    /// Returns an offset key for the given key pair.\n    fn to_offset_key<Q>(&self, storage_key: &Key, key: &Q) -> Key\n    where\n        K: Borrow<Q>,\n        Q: scale::Encode,\n    {\n        #[derive(scale::Encode)]\n        struct KeyPair<'a, Q> {\n            prefix: [u8; 11],\n            storage_key: &'a Key,\n            value_key: &'a Q,\n        }\n        let key_pair = KeyPair {\n            prefix: [\n                b'i', b'n', b'k', b' ', b'h', b'a', b's', b'h', b'm', b'a', b'p',\n            ],\n            storage_key,\n            value_key: key,\n        };\n        let mut output = <H as HashOutput>::Type::default();\n        ink_env::hash_encoded::<H, KeyPair<Q>>(&key_pair, &mut output);\n        output.into()\n    }\n\n    /// Returns an offset key for the given key.\n    fn key_at<Q>(&self, key: &Q) -> Option<Key>\n    where\n        K: Borrow<Q>,\n        Q: scale::Encode,\n    {\n        self.key\n            .map(|storage_key| self.to_offset_key(&storage_key, key))\n    }\n}\n\nimpl<K, V, H> LazyHashMap<K, V, H>\nwhere\n    K: Ord + Eq + scale::Encode,\n    V: PackedLayout,\n    H: CryptoHash,\n    Key: From<<H as HashOutput>::Type>,\n{\n    /// Lazily loads the value at the given index.\n    ///\n    /// # Note\n    ///\n    /// Only loads a value if `key` is set and if the value has not been loaded yet.\n    /// Returns the freshly loaded or already loaded entry of the value.\n    ///\n    /// # Safety\n    ///\n    /// This function has a `&self` receiver while returning an `Option<*mut T>`\n    /// which is unsafe in isolation. The caller has to determine how to forward\n    /// the returned `*mut T`.\n    ///\n    /// # Safety\n    ///\n    /// This is an `unsafe` operation because it has a `&self` receiver but returns\n    /// a `*mut Entry<T>` pointer that allows for exclusive access. This is safe\n    /// within internal use only and should never be given outside of the lazy\n    /// entity for public `&self` methods.\n    unsafe fn lazily_load<Q>(&self, key: &Q) -> NonNull<StorageEntry<V>>\n    where\n        K: Borrow<Q>,\n        Q: Ord + scale::Encode + ToOwned<Owned = K>,\n    {\n        // SAFETY: We have put the whole `cached_entries` mapping into an\n        //         `UnsafeCell` because of this caching functionality. The\n        //         trick here is that due to using `Box<T>` internally\n        //         we are able to return references to the cached entries\n        //         while maintaining the invariant that mutating the caching\n        //         `BTreeMap` will never invalidate those references.\n        //         By returning a raw pointer we enforce an `unsafe` block at\n        //         the caller site to underline that guarantees are given by the\n        //         caller.\n        let cached_entries = &mut *self.cached_entries.get_ptr().as_ptr();\n        // We have to clone the key here because we do not have access to the unsafe\n        // raw entry API for Rust hash maps, yet since it is unstable. We can remove\n        // the contraints on `K: Clone` once we have access to this API.\n        // Read more about the issue here: https://github.com/rust-lang/rust/issues/56167\n        match cached_entries.entry(key.to_owned()) {\n            BTreeMapEntry::Occupied(occupied) => {\n                NonNull::from(&mut **occupied.into_mut())\n            }\n            BTreeMapEntry::Vacant(vacant) => {\n                let value = self\n                    .key_at(key)\n                    .map(|key| pull_packed_root_opt::<V>(&key))\n                    .unwrap_or(None);\n                NonNull::from(\n                    &mut **vacant.insert(Box::new(StorageEntry::new(\n                        value,\n                        EntryState::Preserved,\n                    ))),\n                )\n            }\n        }\n    }\n\n    /// Lazily loads the value associated with the given key.\n    ///\n    /// # Note\n    ///\n    /// Only loads a value if `key` is set and if the value has not been loaded yet.\n    /// Returns a pointer to the freshly loaded or already loaded entry of the value.\n    ///\n    /// # Panics\n    ///\n    /// - If the lazy chunk is in an invalid state that forbids interaction.\n    /// - If the lazy chunk is not in a state that allows lazy loading.\n    fn lazily_load_mut<Q>(&mut self, index: &Q) -> &mut StorageEntry<V>\n    where\n        K: Borrow<Q>,\n        Q: Ord + scale::Encode + ToOwned<Owned = K>,\n    {\n        // SAFETY:\n        // - Returning a `&mut Entry<T>` is safe because entities inside the\n        //   cache are stored within a `Box` to not invalidate references into\n        //   them upon operating on the outer cache.\n        unsafe { &mut *self.lazily_load(index).as_ptr() }\n    }\n\n    /// Clears the underlying storage of the entry at the given index.\n    ///\n    /// # Safety\n    ///\n    /// For performance reasons this does not synchronize the lazy index map's\n    /// memory-side cache which invalidates future accesses the cleared entry.\n    /// Care should be taken when using this API.\n    ///\n    /// The general use of this API is to streamline `Drop` implementations of\n    /// high-level abstractions that build upon this low-level data strcuture.\n    pub fn clear_packed_at<Q>(&self, index: &Q)\n    where\n        K: Borrow<Q>,\n        V: PackedLayout,\n        Q: Ord + scale::Encode + ToOwned<Owned = K>,\n    {\n        let root_key = self.key_at(index).expect(\"cannot clear in lazy state\");\n        if <V as SpreadLayout>::REQUIRES_DEEP_CLEAN_UP {\n            // We need to load the entity before we remove its associated contract storage\n            // because it requires a deep clean-up which propagates clearing to its fields,\n            // for example in the case of `T` being a `storage::Box`.\n            let entity = self.get(index).expect(\"cannot clear a non existing entity\");\n            clear_packed_root::<V>(&entity, &root_key);\n        } else {\n            // The type does not require deep clean-up so we can simply clean-up\n            // its associated storage cell and be done without having to load it first.\n            ink_env::clear_contract_storage(&root_key);\n        }\n    }\n\n    /// Returns a shared reference to the value associated with the given key if any.\n    ///\n    /// # Panics\n    ///\n    /// - If the lazy chunk is in an invalid state that forbids interaction.\n    /// - If the decoding of the element at the given index failed.\n    pub fn get<Q>(&self, index: &Q) -> Option<&V>\n    where\n        K: Borrow<Q>,\n        Q: Ord + scale::Encode + ToOwned<Owned = K>,\n    {\n        // SAFETY: Dereferencing the `*mut T` pointer into a `&T` is safe\n        //         since this method's receiver is `&self` so we do not\n        //         leak non-shared references to the outside.\n        unsafe { &*self.lazily_load(index).as_ptr() }.value().into()\n    }\n\n    /// Returns an exclusive reference to the value associated with the given key if any.\n    ///\n    /// # Panics\n    ///\n    /// - If the lazy chunk is in an invalid state that forbids interaction.\n    /// - If the decoding of the element at the given index failed.\n    pub fn get_mut<Q>(&mut self, index: &Q) -> Option<&mut V>\n    where\n        K: Borrow<Q>,\n        Q: Ord + scale::Encode + ToOwned<Owned = K>,\n    {\n        self.lazily_load_mut(index).value_mut().into()\n    }\n\n    /// Puts the new value under the given key and returns the old value if any.\n    ///\n    /// # Note\n    ///\n    /// - Use [`LazyHashMap::put_get`]`(None)` in order to remove an element\n    ///   and retrieve the old element back.\n    ///\n    /// # Panics\n    ///\n    /// - If the lazy hashmap is in an invalid state that forbids interaction.\n    /// - If the decoding of the old element at the given index failed.\n    pub fn put_get<Q>(&mut self, key: &Q, new_value: Option<V>) -> Option<V>\n    where\n        K: Borrow<Q>,\n        Q: Ord + scale::Encode + ToOwned<Owned = K>,\n    {\n        self.lazily_load_mut(key).put(new_value)\n    }\n\n    /// Swaps the values at entries with associated keys `x` and `y`.\n    ///\n    /// This operation tries to be as efficient as possible and reuse allocations.\n    ///\n    /// # Panics\n    ///\n    /// - If the lazy hashmap is in an invalid state that forbids interaction.\n    /// - If the decoding of one of the elements failed.\n    pub fn swap<Q1, Q2>(&mut self, x: &Q1, y: &Q2)\n    where\n        K: Borrow<Q1> + Borrow<Q2>,\n        Q1: Ord + PartialEq<Q2> + scale::Encode + ToOwned<Owned = K>,\n        Q2: Ord + PartialEq<Q1> + scale::Encode + ToOwned<Owned = K>,\n    {\n        if x == y {\n            // Bail out early if both indices are the same.\n            return\n        }\n        let (loaded_x, loaded_y) =\n            // SAFETY: The loaded `x` and `y` entries are distinct from each\n            //         other guaranteed by the previous check. Also `lazily_load`\n            //         guarantees to return a pointer to a pinned entity\n            //         so that the returned references do not conflict with\n            //         each other.\n            unsafe { (\n                &mut *self.lazily_load(x).as_ptr(),\n                &mut *self.lazily_load(y).as_ptr(),\n            ) };\n        if loaded_x.value().is_none() && loaded_y.value().is_none() {\n            // Bail out since nothing has to be swapped if both values are `None`.\n            return\n        }\n        // Set the `mutate` flag since at this point at least one of the loaded\n        // values is guaranteed to be `Some`.\n        loaded_x.replace_state(EntryState::Mutated);\n        loaded_y.replace_state(EntryState::Mutated);\n        core::mem::swap(loaded_x.value_mut(), loaded_y.value_mut());\n    }\n}\n\nimpl<'a, K, V> Entry<'a, K, V>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PackedLayout + core::fmt::Debug + core::cmp::Eq + Default,\n{\n    /// Returns a reference to this entry's key.\n    pub fn key(&self) -> &K {\n        match self {\n            Entry::Occupied(entry) => &entry.key,\n            Entry::Vacant(entry) => &entry.key,\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the default value if empty, and returns\n    /// a reference to the value in the entry.\n    pub fn or_default(self) -> &'a V {\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(V::default()),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the default if empty, and returns\n    /// a mutable reference to the value in the entry.\n    pub fn or_insert(self, default: V) -> &'a mut V {\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(default),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n    /// and returns mutable references to the key and value in the entry.\n    pub fn or_insert_with<F>(self, default: F) -> &'a mut V\n    where\n        F: FnOnce() -> V,\n    {\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(default()),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting, if empty, the result of the default\n    /// function, which takes the key as its argument, and returns a mutable reference to\n    /// the value in the entry.\n    pub fn or_insert_with_key<F>(self, default: F) -> &'a mut V\n    where\n        F: FnOnce(&K) -> V,\n    {\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => {\n                let value = default(&entry.key);\n                entry.insert(value)\n            }\n        }\n    }\n\n    /// Provides in-place mutable access to an occupied entry before any\n    /// potential inserts into the map.\n    pub fn and_modify<F>(self, f: F) -> Self\n    where\n        F: FnOnce(&mut V),\n    {\n        match self {\n            Entry::Occupied(mut entry) => {\n                {\n                    let v = entry.get_mut();\n                    f(v);\n                }\n                Entry::Occupied(entry)\n            }\n            Entry::Vacant(entry) => Entry::Vacant(entry),\n        }\n    }\n}\n\nimpl<'a, K, V> VacantEntry<'a, K, V>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PackedLayout,\n{\n    /// Gets a reference to the key that would be used when inserting a value through the VacantEntry.\n    pub fn key(&self) -> &K {\n        &self.key\n    }\n\n    /// Take ownership of the key.\n    pub fn into_key(self) -> K {\n        self.key\n    }\n\n    /// Sets the value of the entry with the VacantEntry's key, and returns a mutable reference to it.\n    pub fn insert(self, value: V) -> &'a mut V {\n        let new = Box::new(StorageEntry::new(Some(value), EntryState::Mutated));\n        match self.entry {\n            BTreeMapEntry::Vacant(vacant) => {\n                vacant\n                    .insert(new)\n                    .value_mut()\n                    .as_mut()\n                    .expect(\"insert was just executed; qed\")\n            }\n            BTreeMapEntry::Occupied(mut occupied) => {\n                occupied.insert(new);\n                occupied\n                    .into_mut()\n                    .value_mut()\n                    .as_mut()\n                    .expect(\"insert was just executed; qed\")\n            }\n        }\n    }\n}\n\nimpl<'a, K, V> OccupiedEntry<'a, K, V>\nwhere\n    K: Ord + Clone + PackedLayout,\n    V: PackedLayout,\n{\n    /// Gets a reference to the key in the entry.\n    pub fn key(&self) -> &K {\n        &self.key\n    }\n\n    /// Take the ownership of the key and value from the map.\n    pub fn remove_entry(self) -> (K, V) {\n        let old = match self.entry {\n            EntryOrMutableValue::EntryElementWasInCache(mut entry) => {\n                entry\n                    .get_mut()\n                    .value_mut()\n                    .take()\n                    .expect(\"entry behind `OccupiedEntry` must always exist\")\n            }\n            EntryOrMutableValue::MutableValueElementWasNotInCache(v_mut) => {\n                v_mut\n                    .value_mut()\n                    .take()\n                    .expect(\"entry behind `MutableValue` must always exist\")\n            }\n        };\n        (self.key, old)\n    }\n\n    /// Gets a reference to the value in the entry.\n    pub fn get(&self) -> &V {\n        match &self.entry {\n            EntryOrMutableValue::EntryElementWasInCache(entry) => {\n                entry\n                    .get()\n                    .value()\n                    .as_ref()\n                    .expect(\"entry behind `OccupiedEntry` must always exist\")\n            }\n            EntryOrMutableValue::MutableValueElementWasNotInCache(v_mut) => {\n                v_mut\n                    .value()\n                    .as_ref()\n                    .expect(\"entry behind `MutableValue` must always exist\")\n            }\n        }\n    }\n\n    /// Gets a mutable reference to the value in the entry.\n    ///\n    /// If you need a reference to the `OccupiedEntry` which may outlive the destruction of the\n    /// `Entry` value, see `into_mut`.\n    pub fn get_mut(&mut self) -> &mut V {\n        match &mut self.entry {\n            EntryOrMutableValue::EntryElementWasInCache(entry) => {\n                entry\n                    .get_mut()\n                    .value_mut()\n                    .as_mut()\n                    .expect(\"entry behind `OccupiedEntry` must always exist\")\n            }\n            EntryOrMutableValue::MutableValueElementWasNotInCache(v_mut) => {\n                v_mut\n                    .value_mut()\n                    .as_mut()\n                    .expect(\"entry behind `MutableValue` must always exist\")\n            }\n        }\n    }\n\n    /// Sets the value of the entry, and returns the entry's old value.\n    pub fn insert(&mut self, new_value: V) -> V {\n        match &mut self.entry {\n            EntryOrMutableValue::EntryElementWasInCache(entry) => {\n                let new_value =\n                    Box::new(StorageEntry::new(Some(new_value), EntryState::Mutated));\n                entry\n                    .insert(new_value)\n                    .into_value()\n                    .expect(\"entry behind `OccupiedEntry` must always exist\")\n            }\n            EntryOrMutableValue::MutableValueElementWasNotInCache(v_mut) => {\n                core::mem::replace(v_mut.value_mut(), Some(new_value))\n                    .expect(\"entry behind `MutableValue` must always exist\")\n            }\n        }\n    }\n\n    /// Takes the value out of the entry, and returns it.\n    pub fn remove(self) -> V {\n        self.remove_entry().1\n    }\n\n    /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n    /// with a lifetime bound to the map itself.\n    pub fn into_mut(self) -> &'a mut V {\n        match self.entry {\n            EntryOrMutableValue::EntryElementWasInCache(entry) => {\n                entry\n                    .into_mut()\n                    .value_mut()\n                    .as_mut()\n                    .expect(\"entry behind `OccupiedEntry` must always exist\")\n            }\n            EntryOrMutableValue::MutableValueElementWasNotInCache(v_mut) => {\n                v_mut\n                    .value_mut()\n                    .as_mut()\n                    .expect(\"entry behind `MutableValue` must always exist\")\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{\n        EntryState,\n        LazyHashMap,\n        StorageEntry,\n    };\n    use crate::traits::{\n        KeyPtr,\n        SpreadLayout,\n    };\n    use ink_env::hash::{\n        Blake2x256,\n        Sha2x256,\n    };\n    use ink_primitives::Key;\n\n    /// Asserts that the cached entries of the given `imap` is equal to the `expected` slice.\n    fn assert_cached_entries<H>(\n        hmap: &LazyHashMap<i32, u8, H>,\n        expected: &[(i32, StorageEntry<u8>)],\n    ) {\n        assert_eq!(hmap.len_cached_entries(), expected.len());\n        for (given, expected) in hmap\n            .entries()\n            .iter()\n            .map(|(index, boxed_entry)| (*index, &**boxed_entry))\n            .zip(expected.iter().map(|(index, entry)| (*index, entry)))\n        {\n            assert_eq!(given, expected);\n        }\n    }\n\n    fn new_hmap() -> LazyHashMap<i32, u8, Blake2x256> {\n        <LazyHashMap<i32, u8, Blake2x256>>::new()\n    }\n\n    #[test]\n    fn new_works() {\n        let hmap = new_hmap();\n        // Key must be none.\n        assert_eq!(hmap.key(), None);\n        assert_eq!(hmap.key_at(&0), None);\n        // Cached elements must be empty.\n        assert_cached_entries(&hmap, &[]);\n        // Same as default:\n        let default_hmap = <LazyHashMap<i32, u8, Blake2x256>>::default();\n        assert_eq!(hmap.key(), default_hmap.key());\n        assert_eq!(hmap.entries(), default_hmap.entries());\n    }\n\n    #[test]\n    fn key_at_works() {\n        let key = Key::from([0x42; 32]);\n\n        // BLAKE2 256-bit hasher:\n        let hmap1 = <LazyHashMap<i32, u8, Blake2x256>>::lazy(key);\n        // Key must be some.\n        assert_eq!(hmap1.key(), Some(&key));\n        // Cached elements must be empty.\n        assert_cached_entries(&hmap1, &[]);\n        let hmap1_at_0 = b\"\\\n        \\x67\\x7E\\xD3\\xA4\\x72\\x2A\\x83\\x60\\\n        \\x96\\x65\\x0E\\xCD\\x1F\\x2C\\xE8\\x5D\\\n        \\xBF\\x7E\\xC0\\xFF\\x16\\x40\\x8A\\xD8\\\n        \\x75\\x88\\xDE\\x52\\xF5\\x8B\\x99\\xAF\";\n        assert_eq!(hmap1.key_at(&0), Some(Key::from(*hmap1_at_0)));\n        // Same parameters must yield the same key:\n        //\n        // This tests an actual regression that happened because the\n        // hash accumulator was not reset after a hash finalization.\n        assert_cached_entries(&hmap1, &[]);\n        assert_eq!(hmap1.key_at(&0), Some(Key::from(*hmap1_at_0)));\n        assert_eq!(\n            hmap1.key_at(&1),\n            Some(Key::from(\n                *b\"\\\n                \\x9A\\x46\\x1F\\xB3\\xA1\\xC4\\x20\\xF8\\\n                \\xA0\\xD9\\xA7\\x79\\x2F\\x07\\xFB\\x7D\\\n                \\x49\\xDD\\xAB\\x08\\x67\\x90\\x96\\x15\\\n                \\xFB\\x85\\x36\\x3B\\x82\\x94\\x85\\x3F\"\n            ))\n        );\n        // SHA2 256-bit hasher:\n        let hmap2 = <LazyHashMap<i32, u8, Sha2x256>>::lazy(key);\n        // Key must be some.\n        assert_eq!(hmap2.key(), Some(&key));\n        // Cached elements must be empty.\n        assert_cached_entries(&hmap2, &[]);\n        assert_eq!(\n            hmap1.key_at(&0),\n            Some(Key::from(\n                *b\"\\\n                \\x67\\x7E\\xD3\\xA4\\x72\\x2A\\x83\\x60\\\n                \\x96\\x65\\x0E\\xCD\\x1F\\x2C\\xE8\\x5D\\\n                \\xBF\\x7E\\xC0\\xFF\\x16\\x40\\x8A\\xD8\\\n                \\x75\\x88\\xDE\\x52\\xF5\\x8B\\x99\\xAF\"\n            ))\n        );\n        assert_eq!(\n            hmap1.key_at(&1),\n            Some(Key::from(\n                *b\"\\\n                \\x9A\\x46\\x1F\\xB3\\xA1\\xC4\\x20\\xF8\\\n                \\xA0\\xD9\\xA7\\x79\\x2F\\x07\\xFB\\x7D\\\n                \\x49\\xDD\\xAB\\x08\\x67\\x90\\x96\\x15\\\n                \\xFB\\x85\\x36\\x3B\\x82\\x94\\x85\\x3F\"\n            ))\n        );\n    }\n\n    #[test]\n    fn put_get_works() {\n        let mut hmap = new_hmap();\n        // Put some values.\n        assert_eq!(hmap.put_get(&1, Some(b'A')), None);\n        assert_eq!(hmap.put_get(&2, Some(b'B')), None);\n        assert_eq!(hmap.put_get(&4, Some(b'C')), None);\n        assert_cached_entries(\n            &hmap,\n            &[\n                (1, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (2, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n                (4, StorageEntry::new(Some(b'C'), EntryState::Mutated)),\n            ],\n        );\n        // Put none values.\n        assert_eq!(hmap.put_get(&3, None), None);\n        assert_eq!(hmap.put_get(&5, None), None);\n        assert_cached_entries(\n            &hmap,\n            &[\n                (1, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (2, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n                (3, StorageEntry::new(None, EntryState::Preserved)),\n                (4, StorageEntry::new(Some(b'C'), EntryState::Mutated)),\n                (5, StorageEntry::new(None, EntryState::Preserved)),\n            ],\n        );\n        // Override some values with none.\n        assert_eq!(hmap.put_get(&2, None), Some(b'B'));\n        assert_eq!(hmap.put_get(&4, None), Some(b'C'));\n        assert_cached_entries(\n            &hmap,\n            &[\n                (1, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (2, StorageEntry::new(None, EntryState::Mutated)),\n                (3, StorageEntry::new(None, EntryState::Preserved)),\n                (4, StorageEntry::new(None, EntryState::Mutated)),\n                (5, StorageEntry::new(None, EntryState::Preserved)),\n            ],\n        );\n        // Override none values with some.\n        assert_eq!(hmap.put_get(&3, Some(b'X')), None);\n        assert_eq!(hmap.put_get(&5, Some(b'Y')), None);\n        assert_cached_entries(\n            &hmap,\n            &[\n                (1, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (2, StorageEntry::new(None, EntryState::Mutated)),\n                (3, StorageEntry::new(Some(b'X'), EntryState::Mutated)),\n                (4, StorageEntry::new(None, EntryState::Mutated)),\n                (5, StorageEntry::new(Some(b'Y'), EntryState::Mutated)),\n            ],\n        );\n    }\n\n    #[test]\n    fn get_works() {\n        let mut hmap = new_hmap();\n        let nothing_changed = &[\n            (1, StorageEntry::new(None, EntryState::Preserved)),\n            (2, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n            (3, StorageEntry::new(None, EntryState::Preserved)),\n            (4, StorageEntry::new(Some(b'D'), EntryState::Mutated)),\n        ];\n        // Put some values.\n        assert_eq!(hmap.put_get(&1, None), None);\n        assert_eq!(hmap.put_get(&2, Some(b'B')), None);\n        assert_eq!(hmap.put_get(&3, None), None);\n        assert_eq!(hmap.put_get(&4, Some(b'D')), None);\n        assert_cached_entries(&hmap, nothing_changed);\n        // `get` works:\n        assert_eq!(hmap.get(&1), None);\n        assert_eq!(hmap.get(&2), Some(&b'B'));\n        assert_eq!(hmap.get(&3), None);\n        assert_eq!(hmap.get(&4), Some(&b'D'));\n        assert_cached_entries(&hmap, nothing_changed);\n        // `get_mut` works:\n        assert_eq!(hmap.get_mut(&1), None);\n        assert_eq!(hmap.get_mut(&2), Some(&mut b'B'));\n        assert_eq!(hmap.get_mut(&3), None);\n        assert_eq!(hmap.get_mut(&4), Some(&mut b'D'));\n        assert_cached_entries(&hmap, nothing_changed);\n        // `get` or `get_mut` without cache:\n        assert_eq!(hmap.get(&5), None);\n        assert_eq!(hmap.get_mut(&5), None);\n    }\n\n    #[test]\n    fn put_works() {\n        let mut hmap = new_hmap();\n        // Put some values.\n        hmap.put(1, None);\n        hmap.put(2, Some(b'B'));\n        hmap.put(4, None);\n        // The main difference between `put` and `put_get` is that `put` never\n        // loads from storage which also has one drawback: Putting a `None`\n        // value always ends-up in `Mutated` state for the entry even if the\n        // entry is already `None`.\n        assert_cached_entries(\n            &hmap,\n            &[\n                (1, StorageEntry::new(None, EntryState::Mutated)),\n                (2, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n                (4, StorageEntry::new(None, EntryState::Mutated)),\n            ],\n        );\n        // Overwrite entries:\n        hmap.put(1, Some(b'A'));\n        hmap.put(2, None);\n        assert_cached_entries(\n            &hmap,\n            &[\n                (1, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (2, StorageEntry::new(None, EntryState::Mutated)),\n                (4, StorageEntry::new(None, EntryState::Mutated)),\n            ],\n        );\n    }\n\n    #[test]\n    fn swap_works() {\n        let mut hmap = new_hmap();\n        let nothing_changed = &[\n            (1, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n            (2, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n            (3, StorageEntry::new(None, EntryState::Preserved)),\n            (4, StorageEntry::new(None, EntryState::Preserved)),\n        ];\n        // Put some values.\n        assert_eq!(hmap.put_get(&1, Some(b'A')), None);\n        assert_eq!(hmap.put_get(&2, Some(b'B')), None);\n        assert_eq!(hmap.put_get(&3, None), None);\n        assert_eq!(hmap.put_get(&4, None), None);\n        assert_cached_entries(&hmap, nothing_changed);\n        // Swap same indices: Check that nothing has changed.\n        for i in 0..4 {\n            hmap.swap(&i, &i);\n        }\n        assert_cached_entries(&hmap, nothing_changed);\n        // Swap `None` values: Check that nothing has changed.\n        hmap.swap(&3, &4);\n        hmap.swap(&4, &3);\n        assert_cached_entries(&hmap, nothing_changed);\n        // Swap `Some` and `None`:\n        hmap.swap(&1, &3);\n        assert_cached_entries(\n            &hmap,\n            &[\n                (1, StorageEntry::new(None, EntryState::Mutated)),\n                (2, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n                (3, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (4, StorageEntry::new(None, EntryState::Preserved)),\n            ],\n        );\n        // Swap `Some` and `Some`:\n        hmap.swap(&2, &3);\n        assert_cached_entries(\n            &hmap,\n            &[\n                (1, StorageEntry::new(None, EntryState::Mutated)),\n                (2, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (3, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n                (4, StorageEntry::new(None, EntryState::Preserved)),\n            ],\n        );\n        // Swap out of bounds: `None` and `None`\n        hmap.swap(&4, &5);\n        assert_cached_entries(\n            &hmap,\n            &[\n                (1, StorageEntry::new(None, EntryState::Mutated)),\n                (2, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (3, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n                (4, StorageEntry::new(None, EntryState::Preserved)),\n                (5, StorageEntry::new(None, EntryState::Preserved)),\n            ],\n        );\n        // Swap out of bounds: `Some` and `None`\n        hmap.swap(&3, &6);\n        assert_cached_entries(\n            &hmap,\n            &[\n                (1, StorageEntry::new(None, EntryState::Mutated)),\n                (2, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (3, StorageEntry::new(None, EntryState::Mutated)),\n                (4, StorageEntry::new(None, EntryState::Preserved)),\n                (5, StorageEntry::new(None, EntryState::Preserved)),\n                (6, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n            ],\n        );\n    }\n\n    #[test]\n    fn spread_layout_works() -> ink_env::Result<()> {\n        ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n            let mut hmap = new_hmap();\n            let nothing_changed = &[\n                (1, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (2, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n                (3, StorageEntry::new(None, EntryState::Preserved)),\n                (4, StorageEntry::new(None, EntryState::Preserved)),\n            ];\n            // Put some values.\n            assert_eq!(hmap.put_get(&1, Some(b'A')), None);\n            assert_eq!(hmap.put_get(&2, Some(b'B')), None);\n            assert_eq!(hmap.put_get(&3, None), None);\n            assert_eq!(hmap.put_get(&4, None), None);\n            assert_cached_entries(&hmap, nothing_changed);\n            // Push the lazy index map onto the contract storage and then load\n            // another instance of it from the contract stoarge.\n            // Then: Compare both instances to be equal.\n            let root_key = Key::from([0x42; 32]);\n            SpreadLayout::push_spread(&hmap, &mut KeyPtr::from(root_key));\n            let hmap2 = <LazyHashMap<i32, u8, Blake2x256> as SpreadLayout>::pull_spread(\n                &mut KeyPtr::from(root_key),\n            );\n            assert_cached_entries(&hmap2, &[]);\n            assert_eq!(hmap2.key(), Some(&Key::from([0x42; 32])));\n            assert_eq!(hmap2.get(&1), Some(&b'A'));\n            assert_eq!(hmap2.get(&2), Some(&b'B'));\n            assert_eq!(hmap2.get(&3), None);\n            assert_eq!(hmap2.get(&4), None);\n            assert_cached_entries(\n                &hmap2,\n                &[\n                    (1, StorageEntry::new(Some(b'A'), EntryState::Preserved)),\n                    (2, StorageEntry::new(Some(b'B'), EntryState::Preserved)),\n                    (3, StorageEntry::new(None, EntryState::Preserved)),\n                    (4, StorageEntry::new(None, EntryState::Preserved)),\n                ],\n            );\n            // Clear the first lazy index map instance and reload another instance\n            // to check whether the associated storage has actually been freed\n            // again:\n            SpreadLayout::clear_spread(&hmap2, &mut KeyPtr::from(root_key));\n            // The above `clear_spread` call is a no-op since lazy index map is\n            // generally not aware of its associated elements. So we have to\n            // manually clear them from the contract storage which is what the\n            // high-level data structures like `storage::Vec` would command:\n            hmap2.clear_packed_at(&1);\n            hmap2.clear_packed_at(&2);\n            hmap2.clear_packed_at(&3); // Not really needed here.\n            hmap2.clear_packed_at(&4); // Not really needed here.\n            let hmap3 = <LazyHashMap<i32, u8, Blake2x256> as SpreadLayout>::pull_spread(\n                &mut KeyPtr::from(root_key),\n            );\n            assert_cached_entries(&hmap3, &[]);\n            assert_eq!(hmap3.get(&1), None);\n            assert_eq!(hmap3.get(&2), None);\n            assert_eq!(hmap3.get(&3), None);\n            assert_eq!(hmap3.get(&4), None);\n            assert_cached_entries(\n                &hmap3,\n                &[\n                    (1, StorageEntry::new(None, EntryState::Preserved)),\n                    (2, StorageEntry::new(None, EntryState::Preserved)),\n                    (3, StorageEntry::new(None, EntryState::Preserved)),\n                    (4, StorageEntry::new(None, EntryState::Preserved)),\n                ],\n            );\n            Ok(())\n        })\n    }\n}\n"],["1024","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::{\n    CacheCell,\n    EntryState,\n    StorageEntry,\n};\nuse crate::traits::{\n    clear_packed_root,\n    pull_packed_root_opt,\n    ExtKeyPtr,\n    KeyPtr,\n    PackedLayout,\n    SpreadLayout,\n};\nuse core::{\n    fmt,\n    fmt::Debug,\n    ptr::NonNull,\n};\nuse ink_prelude::{\n    boxed::Box,\n    collections::BTreeMap,\n};\nuse ink_primitives::Key;\n\n/// The index type used in the lazy storage chunk.\npub type Index = u32;\n\n/// A lazy storage chunk that spans over a whole chunk of storage cells.\n///\n/// # Note\n///\n/// This is mainly used as low-level storage primitives by other high-level\n/// storage primitives in order to manage the contract storage for a whole\n/// chunk of storage cells.\n///\n/// A chunk of storage cells is a contiguous range of 2^32 storage cells.\npub struct LazyIndexMap<V> {\n    /// The offset key for the chunk of cells.\n    ///\n    /// If the lazy chunk has been initialized during contract initialization\n    /// the key will be `None` since there won't be a storage region associated\n    /// to the lazy chunk which prevents it from lazily loading elements. This,\n    /// however, is only checked at contract runtime. We might incorporate\n    /// compile-time checks for this particular use case later on.\n    key: Option<Key>,\n    /// The subset of currently cached entries of the lazy storage chunk.\n    ///\n    /// An entry is cached as soon as it is loaded or written.\n    cached_entries: CacheCell<EntryMap<V>>,\n}\n\nstruct DebugEntryMap<'a, V>(&'a CacheCell<EntryMap<V>>);\n\nimpl<'a, V> Debug for DebugEntryMap<'a, V>\nwhere\n    V: Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_map().entries(self.0.as_inner().iter()).finish()\n    }\n}\n\nimpl<V> Debug for LazyIndexMap<V>\nwhere\n    V: Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"LazyIndexMap\")\n            .field(\"key\", &self.key)\n            .field(\"cached_entries\", &DebugEntryMap(&self.cached_entries))\n            .finish()\n    }\n}\n\n#[test]\nfn debug_impl_works() {\n    let mut imap = <LazyIndexMap<i32>>::new();\n    // Empty imap.\n    assert_eq!(\n        format!(\"{:?}\", &imap),\n        \"LazyIndexMap { key: None, cached_entries: {} }\",\n    );\n    // Filled imap.\n    imap.put(0, Some(1));\n    imap.put(42, Some(2));\n    imap.put(999, None);\n    assert_eq!(\n        format!(\"{:?}\", &imap),\n        \"LazyIndexMap { \\\n            key: None, \\\n            cached_entries: {\\\n                0: Entry { \\\n                    value: Some(1), \\\n                    state: Mutated \\\n                }, \\\n                42: Entry { \\\n                    value: Some(2), \\\n                    state: Mutated \\\n                }, \\\n                999: Entry { \\\n                    value: None, \\\n                    state: Mutated \\\n                }\\\n            } \\\n        }\",\n    );\n}\n\nimpl<V> Default for LazyIndexMap<V> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// The map for the contract storage entries.\n///\n/// # Note\n///\n/// We keep the whole entry in a `Box<T>` in order to prevent pointer\n/// invalidation upon updating the cache through `&self` methods as in\n/// [`LazyIndexMap::get`].\npub type EntryMap<V> = BTreeMap<Index, Box<StorageEntry<V>>>;\n\nimpl<V> LazyIndexMap<V> {\n    /// Creates a new empty lazy map.\n    ///\n    /// # Note\n    ///\n    /// A lazy map created this way cannot be used to load from the contract storage.\n    /// All operations that directly or indirectly load from storage will panic.\n    pub fn new() -> Self {\n        Self {\n            key: None,\n            cached_entries: CacheCell::new(EntryMap::new()),\n        }\n    }\n\n    /// Creates a new empty lazy map positioned at the given key.\n    ///\n    /// # Note\n    ///\n    /// This constructor is private and should never need to be called from\n    /// outside this module. It is used to construct a lazy index map from a\n    /// key that is only useful upon a contract call. Use [`LazyIndexMap::new`]\n    /// for construction during contract initialization.\n    fn lazy(key: Key) -> Self {\n        Self {\n            key: Some(key),\n            cached_entries: CacheCell::new(EntryMap::new()),\n        }\n    }\n\n    /// Returns the offset key of the lazy map if any.\n    pub fn key(&self) -> Option<&Key> {\n        self.key.as_ref()\n    }\n\n    /// Returns a shared reference to the underlying entries.\n    fn entries(&self) -> &EntryMap<V> {\n        self.cached_entries.as_inner()\n    }\n\n    /// Returns an exclusive reference to the underlying entries.\n    fn entries_mut(&mut self) -> &mut EntryMap<V> {\n        self.cached_entries.as_inner_mut()\n    }\n\n    /// Puts the new value at the given index.\n    ///\n    /// # Note\n    ///\n    /// - Use [`LazyIndexMap::put`]`(None)` in order to remove an element.\n    /// - Prefer this method over [`LazyIndexMap::put_get`] if you are not interested\n    ///   in the old value of the same cell index.\n    ///\n    /// # Panics\n    ///\n    /// - If the lazy chunk is in an invalid state that forbids interaction.\n    /// - If the decoding of the old element at the given index failed.\n    pub fn put(&mut self, index: Index, new_value: Option<V>) {\n        use ink_prelude::collections::btree_map::Entry as BTreeMapEntry;\n        match self.entries_mut().entry(index) {\n            BTreeMapEntry::Occupied(mut occupied) => {\n                // We can re-use the already existing boxed `Entry` and simply\n                // swap the underlying values.\n                occupied.get_mut().put(new_value);\n            }\n            BTreeMapEntry::Vacant(vacant) => {\n                vacant\n                    .insert(Box::new(StorageEntry::new(new_value, EntryState::Mutated)));\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nconst _: () = {\n    use crate::traits::StorageLayout;\n    use ink_metadata::layout::{\n        ArrayLayout,\n        CellLayout,\n        Layout,\n        LayoutKey,\n    };\n    use scale_info::TypeInfo;\n\n    impl<T> StorageLayout for LazyIndexMap<T>\n    where\n        T: TypeInfo + 'static,\n    {\n        fn layout(key_ptr: &mut KeyPtr) -> Layout {\n            let capacity = u32::MAX;\n            Layout::Array(ArrayLayout::new(\n                LayoutKey::from(key_ptr.advance_by(capacity as u64)),\n                capacity,\n                1,\n                Layout::Cell(CellLayout::new::<T>(LayoutKey::from(\n                    key_ptr.advance_by(0),\n                ))),\n            ))\n        }\n    }\n};\n\nimpl<V> SpreadLayout for LazyIndexMap<V>\nwhere\n    V: PackedLayout,\n{\n    const FOOTPRINT: u64 = 1_u64 << 32;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        Self::lazy(*ExtKeyPtr::next_for::<Self>(ptr))\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        let offset_key = ExtKeyPtr::next_for::<Self>(ptr);\n        for (&index, entry) in self.entries().iter() {\n            let root_key = offset_key + (index as u64);\n            entry.push_packed_root(&root_key);\n        }\n    }\n\n    #[inline]\n    fn clear_spread(&self, _ptr: &mut KeyPtr) {\n        // Low-level lazy abstractions won't perform automated clean-up since\n        // they generally are not aware of their entire set of associated\n        // elements. The high-level abstractions that build upon them are\n        // responsible for cleaning up.\n    }\n}\n\nimpl<V> LazyIndexMap<V>\nwhere\n    V: PackedLayout,\n{\n    /// Clears the underlying storage of the entry at the given index.\n    ///\n    /// # Safety\n    ///\n    /// For performance reasons this does not synchronize the lazy index map's\n    /// memory-side cache which invalidates future accesses the cleared entry.\n    /// Care should be taken when using this API.\n    ///\n    /// The general use of this API is to streamline `Drop` implementations of\n    /// high-level abstractions that build upon this low-level data strcuture.\n    pub fn clear_packed_at(&self, index: Index) {\n        let root_key = self.key_at(index).expect(\"cannot clear in lazy state\");\n        if <V as SpreadLayout>::REQUIRES_DEEP_CLEAN_UP {\n            // We need to load the entity before we remove its associated contract storage\n            // because it requires a deep clean-up which propagates clearing to its fields,\n            // for example in the case of `T` being a `storage::Box`.\n            let entity = self.get(index).expect(\"cannot clear a non existing entity\");\n            clear_packed_root::<V>(&entity, &root_key);\n        } else {\n            // The type does not require deep clean-up so we can simply clean-up\n            // its associated storage cell and be done without having to load it first.\n            ink_env::clear_contract_storage(&root_key);\n        }\n    }\n}\n\nimpl<V> LazyIndexMap<V>\nwhere\n    V: PackedLayout,\n{\n    /// Returns an offset key for the given index.\n    pub fn key_at(&self, index: Index) -> Option<Key> {\n        let key = self.key?;\n        let offset_key = key + index as u64;\n        Some(offset_key)\n    }\n\n    /// Lazily loads the value at the given index.\n    ///\n    /// # Note\n    ///\n    /// Only loads a value if `key` is set and if the value has not been loaded yet.\n    /// Returns the freshly loaded or already loaded entry of the value.\n    ///\n    /// # Safety\n    ///\n    /// This function has a `&self` receiver while returning an `Option<*mut T>`\n    /// which is unsafe in isolation. The caller has to determine how to forward\n    /// the returned `*mut T`.\n    ///\n    /// # Safety\n    ///\n    /// This is an `unsafe` operation because it has a `&self` receiver but returns\n    /// a `*mut Entry<T>` pointer that allows for exclusive access. This is safe\n    /// within internal use only and should never be given outside of the lazy\n    /// entity for public `&self` methods.\n    unsafe fn lazily_load(&self, index: Index) -> NonNull<StorageEntry<V>> {\n        // SAFETY: We have put the whole `cached_entries` mapping into an\n        //         `UnsafeCell` because of this caching functionality. The\n        //         trick here is that due to using `Box<T>` internally\n        //         we are able to return references to the cached entries\n        //         while maintaining the invariant that mutating the caching\n        //         `BTreeMap` will never invalidate those references.\n        //         By returning a raw pointer we enforce an `unsafe` block at\n        //         the caller site to underline that guarantees are given by the\n        //         caller.\n        let cached_entries = &mut *self.cached_entries.get_ptr().as_ptr();\n        use ink_prelude::collections::btree_map::Entry as BTreeMapEntry;\n        match cached_entries.entry(index) {\n            BTreeMapEntry::Occupied(occupied) => {\n                NonNull::from(&mut **occupied.into_mut())\n            }\n            BTreeMapEntry::Vacant(vacant) => {\n                let value = self\n                    .key_at(index)\n                    .map(|key| pull_packed_root_opt::<V>(&key))\n                    .unwrap_or(None);\n                NonNull::from(\n                    &mut **vacant.insert(Box::new(StorageEntry::new(\n                        value,\n                        EntryState::Preserved,\n                    ))),\n                )\n            }\n        }\n    }\n\n    /// Lazily loads the value at the given index.\n    ///\n    /// # Note\n    ///\n    /// Only loads a value if `key` is set and if the value has not been loaded yet.\n    /// Returns the freshly loaded or already loaded entry of the value.\n    ///\n    /// # Panics\n    ///\n    /// - If the lazy chunk is in an invalid state that forbids interaction.\n    /// - If the lazy chunk is not in a state that allows lazy loading.\n    fn lazily_load_mut(&mut self, index: Index) -> &mut StorageEntry<V> {\n        // SAFETY:\n        // - Returning a `&mut Entry<T>` is safe because entities inside the\n        //   cache are stored within a `Box` to not invalidate references into\n        //   them upon operating on the outer cache.\n        unsafe { &mut *self.lazily_load(index).as_ptr() }\n    }\n\n    /// Returns a shared reference to the element at the given index if any.\n    ///\n    /// # Panics\n    ///\n    /// - If the lazy chunk is in an invalid state that forbids interaction.\n    /// - If the decoding of the element at the given index failed.\n    pub fn get(&self, index: Index) -> Option<&V> {\n        // SAFETY: Dereferencing the `*mut T` pointer into a `&T` is safe\n        //         since this method's receiver is `&self` so we do not\n        //         leak non-shared references to the outside.\n        unsafe { &*self.lazily_load(index).as_ptr() }.value().into()\n    }\n\n    /// Returns an exclusive reference to the element at the given index if any.\n    ///\n    /// # Panics\n    ///\n    /// - If the lazy chunk is in an invalid state that forbids interaction.\n    /// - If the decoding of the element at the given index failed.\n    pub fn get_mut(&mut self, index: Index) -> Option<&mut V> {\n        self.lazily_load_mut(index).value_mut().into()\n    }\n\n    /// Puts the new value at the given index and returns the old value if any.\n    ///\n    /// # Note\n    ///\n    /// - Use [`LazyIndexMap::put_get`]`(None)` in order to remove an element\n    ///   and retrieve the old element back.\n    ///\n    /// # Panics\n    ///\n    /// - If the lazy chunk is in an invalid state that forbids interaction.\n    /// - If the decoding of the old element at the given index failed.\n    pub fn put_get(&mut self, index: Index, new_value: Option<V>) -> Option<V> {\n        self.lazily_load_mut(index).put(new_value)\n    }\n\n    /// Swaps the values at indices `x` and `y`.\n    ///\n    /// This operation tries to be as efficient as possible and reuse allocations.\n    ///\n    /// # Panics\n    ///\n    /// - If the lazy chunk is in an invalid state that forbids interaction.\n    /// - If the decoding of one of the elements failed.\n    pub fn swap(&mut self, x: Index, y: Index) {\n        if x == y {\n            // Bail out early if both indices are the same.\n            return\n        }\n        let (loaded_x, loaded_y) =\n            // SAFETY: The loaded `x` and `y` entries are distinct from each\n            //         other guaranteed by the previous check. Also `lazily_load`\n            //         guarantees to return a pointer to a pinned entity\n            //         so that the returned references do not conflict with\n            //         each other.\n            unsafe { (\n                &mut *self.lazily_load(x).as_ptr(),\n                &mut *self.lazily_load(y).as_ptr(),\n            ) };\n        if loaded_x.value().is_none() && loaded_y.value().is_none() {\n            // Bail out since nothing has to be swapped if both values are `None`.\n            return\n        }\n        // Set the `mutate` flag since at this point at least one of the loaded\n        // values is guaranteed to be `Some`.\n        loaded_x.replace_state(EntryState::Mutated);\n        loaded_y.replace_state(EntryState::Mutated);\n        core::mem::swap(loaded_x.value_mut(), loaded_y.value_mut());\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{\n        super::{\n            EntryState,\n            StorageEntry,\n        },\n        Index,\n        LazyIndexMap,\n    };\n    use crate::traits::{\n        KeyPtr,\n        SpreadLayout,\n    };\n    use ink_primitives::Key;\n\n    /// Asserts that the cached entries of the given `imap` is equal to the `expected` slice.\n    fn assert_cached_entries(\n        imap: &LazyIndexMap<u8>,\n        expected: &[(Index, StorageEntry<u8>)],\n    ) {\n        assert_eq!(imap.entries().len(), expected.len());\n        for (given, expected) in imap\n            .entries()\n            .iter()\n            .map(|(index, boxed_entry)| (*index, &**boxed_entry))\n            .zip(expected.iter().map(|(index, entry)| (*index, entry)))\n        {\n            assert_eq!(given, expected);\n        }\n    }\n\n    #[test]\n    fn new_works() {\n        let imap = <LazyIndexMap<u8>>::new();\n        // Key must be none.\n        assert_eq!(imap.key(), None);\n        assert_eq!(imap.key_at(0), None);\n        // Cached elements must be empty.\n        assert_cached_entries(&imap, &[]);\n        // Same as default:\n        let default_imap = <LazyIndexMap<u8>>::default();\n        assert_eq!(imap.key(), default_imap.key());\n        assert_eq!(imap.entries(), default_imap.entries());\n    }\n\n    #[test]\n    fn lazy_works() {\n        let key = Key::from([0x42; 32]);\n        let imap = <LazyIndexMap<u8>>::lazy(key);\n        // Key must be none.\n        assert_eq!(imap.key(), Some(&key));\n        assert_eq!(imap.key_at(0), Some(key));\n        assert_eq!(imap.key_at(1), Some(key + 1u64));\n        // Cached elements must be empty.\n        assert_cached_entries(&imap, &[]);\n    }\n\n    #[test]\n    fn put_get_works() {\n        let mut imap = <LazyIndexMap<u8>>::new();\n        // Put some values.\n        assert_eq!(imap.put_get(1, Some(b'A')), None);\n        assert_eq!(imap.put_get(2, Some(b'B')), None);\n        assert_eq!(imap.put_get(4, Some(b'C')), None);\n        assert_cached_entries(\n            &imap,\n            &[\n                (1, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (2, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n                (4, StorageEntry::new(Some(b'C'), EntryState::Mutated)),\n            ],\n        );\n        // Put none values.\n        assert_eq!(imap.put_get(3, None), None);\n        assert_eq!(imap.put_get(5, None), None);\n        assert_cached_entries(\n            &imap,\n            &[\n                (1, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (2, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n                (3, StorageEntry::new(None, EntryState::Preserved)),\n                (4, StorageEntry::new(Some(b'C'), EntryState::Mutated)),\n                (5, StorageEntry::new(None, EntryState::Preserved)),\n            ],\n        );\n        // Override some values with none.\n        assert_eq!(imap.put_get(2, None), Some(b'B'));\n        assert_eq!(imap.put_get(4, None), Some(b'C'));\n        assert_cached_entries(\n            &imap,\n            &[\n                (1, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (2, StorageEntry::new(None, EntryState::Mutated)),\n                (3, StorageEntry::new(None, EntryState::Preserved)),\n                (4, StorageEntry::new(None, EntryState::Mutated)),\n                (5, StorageEntry::new(None, EntryState::Preserved)),\n            ],\n        );\n        // Override none values with some.\n        assert_eq!(imap.put_get(3, Some(b'X')), None);\n        assert_eq!(imap.put_get(5, Some(b'Y')), None);\n        assert_cached_entries(\n            &imap,\n            &[\n                (1, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (2, StorageEntry::new(None, EntryState::Mutated)),\n                (3, StorageEntry::new(Some(b'X'), EntryState::Mutated)),\n                (4, StorageEntry::new(None, EntryState::Mutated)),\n                (5, StorageEntry::new(Some(b'Y'), EntryState::Mutated)),\n            ],\n        );\n    }\n\n    #[test]\n    fn get_works() {\n        let mut imap = <LazyIndexMap<u8>>::new();\n        let nothing_changed = &[\n            (1, StorageEntry::new(None, EntryState::Preserved)),\n            (2, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n            (3, StorageEntry::new(None, EntryState::Preserved)),\n            (4, StorageEntry::new(Some(b'D'), EntryState::Mutated)),\n        ];\n        // Put some values.\n        assert_eq!(imap.put_get(1, None), None);\n        assert_eq!(imap.put_get(2, Some(b'B')), None);\n        assert_eq!(imap.put_get(3, None), None);\n        assert_eq!(imap.put_get(4, Some(b'D')), None);\n        assert_cached_entries(&imap, nothing_changed);\n        // `get` works:\n        assert_eq!(imap.get(1), None);\n        assert_eq!(imap.get(2), Some(&b'B'));\n        assert_eq!(imap.get(3), None);\n        assert_eq!(imap.get(4), Some(&b'D'));\n        assert_cached_entries(&imap, nothing_changed);\n        // `get_mut` works:\n        assert_eq!(imap.get_mut(1), None);\n        assert_eq!(imap.get_mut(2), Some(&mut b'B'));\n        assert_eq!(imap.get_mut(3), None);\n        assert_eq!(imap.get_mut(4), Some(&mut b'D'));\n        assert_cached_entries(&imap, nothing_changed);\n        // `get` or `get_mut` without cache:\n        assert_eq!(imap.get(5), None);\n        assert_eq!(imap.get_mut(5), None);\n    }\n\n    #[test]\n    fn put_works() {\n        let mut imap = <LazyIndexMap<u8>>::new();\n        // Put some values.\n        imap.put(1, None);\n        imap.put(2, Some(b'B'));\n        imap.put(4, None);\n        // The main difference between `put` and `put_get` is that `put` never\n        // loads from storage which also has one drawback: Putting a `None`\n        // value always ends-up in `Mutated` state for the entry even if the\n        // entry is already `None`.\n        assert_cached_entries(\n            &imap,\n            &[\n                (1, StorageEntry::new(None, EntryState::Mutated)),\n                (2, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n                (4, StorageEntry::new(None, EntryState::Mutated)),\n            ],\n        );\n        // Overwrite entries:\n        imap.put(1, Some(b'A'));\n        imap.put(2, None);\n        assert_cached_entries(\n            &imap,\n            &[\n                (1, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (2, StorageEntry::new(None, EntryState::Mutated)),\n                (4, StorageEntry::new(None, EntryState::Mutated)),\n            ],\n        );\n    }\n\n    #[test]\n    fn swap_works() {\n        let mut imap = <LazyIndexMap<u8>>::new();\n        let nothing_changed = &[\n            (1, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n            (2, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n            (3, StorageEntry::new(None, EntryState::Preserved)),\n            (4, StorageEntry::new(None, EntryState::Preserved)),\n        ];\n        // Put some values.\n        assert_eq!(imap.put_get(1, Some(b'A')), None);\n        assert_eq!(imap.put_get(2, Some(b'B')), None);\n        assert_eq!(imap.put_get(3, None), None);\n        assert_eq!(imap.put_get(4, None), None);\n        assert_cached_entries(&imap, nothing_changed);\n        // Swap same indices: Check that nothing has changed.\n        for i in 0..4 {\n            imap.swap(i, i);\n        }\n        assert_cached_entries(&imap, nothing_changed);\n        // Swap `None` values: Check that nothing has changed.\n        imap.swap(3, 4);\n        imap.swap(4, 3);\n        assert_cached_entries(&imap, nothing_changed);\n        // Swap `Some` and `None`:\n        imap.swap(1, 3);\n        assert_cached_entries(\n            &imap,\n            &[\n                (1, StorageEntry::new(None, EntryState::Mutated)),\n                (2, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n                (3, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (4, StorageEntry::new(None, EntryState::Preserved)),\n            ],\n        );\n        // Swap `Some` and `Some`:\n        imap.swap(2, 3);\n        assert_cached_entries(\n            &imap,\n            &[\n                (1, StorageEntry::new(None, EntryState::Mutated)),\n                (2, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (3, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n                (4, StorageEntry::new(None, EntryState::Preserved)),\n            ],\n        );\n        // Swap out of bounds: `None` and `None`\n        imap.swap(4, 5);\n        assert_cached_entries(\n            &imap,\n            &[\n                (1, StorageEntry::new(None, EntryState::Mutated)),\n                (2, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (3, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n                (4, StorageEntry::new(None, EntryState::Preserved)),\n                (5, StorageEntry::new(None, EntryState::Preserved)),\n            ],\n        );\n        // Swap out of bounds: `Some` and `None`\n        imap.swap(3, 6);\n        assert_cached_entries(\n            &imap,\n            &[\n                (1, StorageEntry::new(None, EntryState::Mutated)),\n                (2, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (3, StorageEntry::new(None, EntryState::Mutated)),\n                (4, StorageEntry::new(None, EntryState::Preserved)),\n                (5, StorageEntry::new(None, EntryState::Preserved)),\n                (6, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n            ],\n        );\n    }\n\n    #[test]\n    fn spread_layout_works() -> ink_env::Result<()> {\n        ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| {\n            let mut imap = <LazyIndexMap<u8>>::new();\n            let nothing_changed = &[\n                (1, StorageEntry::new(Some(b'A'), EntryState::Mutated)),\n                (2, StorageEntry::new(Some(b'B'), EntryState::Mutated)),\n                (3, StorageEntry::new(None, EntryState::Preserved)),\n                (4, StorageEntry::new(None, EntryState::Preserved)),\n            ];\n            // Put some values.\n            assert_eq!(imap.put_get(1, Some(b'A')), None);\n            assert_eq!(imap.put_get(2, Some(b'B')), None);\n            assert_eq!(imap.put_get(3, None), None);\n            assert_eq!(imap.put_get(4, None), None);\n            assert_cached_entries(&imap, nothing_changed);\n            // Push the lazy index map onto the contract storage and then load\n            // another instance of it from the contract stoarge.\n            // Then: Compare both instances to be equal.\n            let root_key = Key::from([0x42; 32]);\n            SpreadLayout::push_spread(&imap, &mut KeyPtr::from(root_key));\n            let imap2 = <LazyIndexMap<u8> as SpreadLayout>::pull_spread(\n                &mut KeyPtr::from(root_key),\n            );\n            assert_cached_entries(&imap2, &[]);\n            assert_eq!(imap2.get(1), Some(&b'A'));\n            assert_eq!(imap2.get(2), Some(&b'B'));\n            assert_eq!(imap2.get(3), None);\n            assert_eq!(imap2.get(4), None);\n            assert_cached_entries(\n                &imap2,\n                &[\n                    (1, StorageEntry::new(Some(b'A'), EntryState::Preserved)),\n                    (2, StorageEntry::new(Some(b'B'), EntryState::Preserved)),\n                    (3, StorageEntry::new(None, EntryState::Preserved)),\n                    (4, StorageEntry::new(None, EntryState::Preserved)),\n                ],\n            );\n            // Clear the first lazy index map instance and reload another instance\n            // to check whether the associated storage has actually been freed\n            // again:\n            SpreadLayout::clear_spread(&imap2, &mut KeyPtr::from(root_key));\n            // The above `clear_spread` call is a no-op since lazy index map is\n            // generally not aware of its associated elements. So we have to\n            // manually clear them from the contract storage which is what the\n            // high-level data structures like `storage::Vec` would command:\n            imap2.clear_packed_at(1);\n            imap2.clear_packed_at(2);\n            imap2.clear_packed_at(3); // Not really needed here.\n            imap2.clear_packed_at(4); // Not really needed here.\n            let imap3 = <LazyIndexMap<u8> as SpreadLayout>::pull_spread(\n                &mut KeyPtr::from(root_key),\n            );\n            assert_cached_entries(&imap3, &[]);\n            assert_eq!(imap3.get(1), None);\n            assert_eq!(imap3.get(2), None);\n            assert_eq!(imap3.get(3), None);\n            assert_eq!(imap3.get(4), None);\n            assert_cached_entries(\n                &imap3,\n                &[\n                    (1, StorageEntry::new(None, EntryState::Preserved)),\n                    (2, StorageEntry::new(None, EntryState::Preserved)),\n                    (3, StorageEntry::new(None, EntryState::Preserved)),\n                    (4, StorageEntry::new(None, EntryState::Preserved)),\n                ],\n            );\n            Ok(())\n        })\n    }\n}\n"],["1025","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Low-level collections and data structures to manage storage entities in the\n//! persisted contract storage.\n//!\n//! Users should generally avoid using these collections directly in their\n//! contracts and should instead adhere to the high-level collections found\n//! in [`collections`][`crate::collections`].\n//! The low-level collections are mainly used as building blocks for internals\n//! of other higher-level storage collections.\n//!\n//! These low-level collections are not aware of the elements they manage thus\n//! extra care has to be taken when operating directly on them.\n\npub mod lazy_hmap;\n\nmod cache_cell;\nmod entry;\n#[cfg(feature = \"ink-unstable\")]\nmod lazy_array;\nmod lazy_cell;\nmod lazy_imap;\n\n#[cfg(feature = \"ink-unstable\")]\n#[doc(inline)]\npub use self::lazy_array::LazyArray;\nuse self::{\n    cache_cell::CacheCell,\n    entry::{\n        EntryState,\n        StorageEntry,\n    },\n};\n#[doc(inline)]\npub use self::{\n    lazy_cell::LazyCell,\n    lazy_hmap::LazyHashMap,\n    lazy_imap::LazyIndexMap,\n};\nuse crate::traits::{\n    KeyPtr,\n    SpreadLayout,\n};\nuse ink_primitives::Key;\n\n/// A lazy storage entity.\n///\n/// This loads its value from storage upon first use.\n///\n/// # Note\n///\n/// Use this if the storage field doesn't need to be loaded in some or most cases.\n#[derive(Debug)]\npub struct Lazy<T>\nwhere\n    T: SpreadLayout,\n{\n    cell: LazyCell<T>,\n}\n\n#[cfg(feature = \"std\")]\nconst _: () = {\n    use crate::traits::StorageLayout;\n    use ink_metadata::layout::Layout;\n\n    impl<T> StorageLayout for Lazy<T>\n    where\n        T: StorageLayout + SpreadLayout,\n    {\n        fn layout(key_ptr: &mut KeyPtr) -> Layout {\n            <T as StorageLayout>::layout(key_ptr)\n        }\n    }\n};\n\nimpl<T> SpreadLayout for Lazy<T>\nwhere\n    T: SpreadLayout,\n{\n    const FOOTPRINT: u64 = <T as SpreadLayout>::FOOTPRINT;\n\n    fn pull_spread(ptr: &mut KeyPtr) -> Self {\n        Self {\n            cell: <LazyCell<T> as SpreadLayout>::pull_spread(ptr),\n        }\n    }\n\n    fn push_spread(&self, ptr: &mut KeyPtr) {\n        SpreadLayout::push_spread(&self.cell, ptr)\n    }\n\n    fn clear_spread(&self, ptr: &mut KeyPtr) {\n        SpreadLayout::clear_spread(&self.cell, ptr)\n    }\n}\n\nimpl<T> Lazy<T>\nwhere\n    T: SpreadLayout,\n{\n    /// Creates an eagerly populated lazy storage value.\n    #[must_use]\n    pub fn new(value: T) -> Self {\n        Self {\n            cell: LazyCell::new(Some(value)),\n        }\n    }\n\n    /// Creates a true lazy storage value for the given key.\n    #[must_use]\n    pub(crate) fn lazy(key: Key) -> Self {\n        Self {\n            cell: LazyCell::lazy(key),\n        }\n    }\n}\n\nimpl<T> Lazy<T>\nwhere\n    T: SpreadLayout,\n{\n    /// Returns a shared reference to the lazily loaded value.\n    ///\n    /// # Note\n    ///\n    /// This loads the value from the contract storage if this did not happen before.\n    ///\n    /// # Panics\n    ///\n    /// If loading from contract storage failed.\n    #[must_use]\n    pub fn get(lazy: &Self) -> &T {\n        lazy.cell.get().expect(\"encountered empty storage cell\")\n    }\n\n    /// Returns an exclusive reference to the lazily loaded value.\n    ///\n    /// # Note\n    ///\n    /// This loads the value from the contract storage if this did not happen before.\n    ///\n    /// # Panics\n    ///\n    /// If loading from contract storage failed.\n    #[must_use]\n    pub fn get_mut(lazy: &mut Self) -> &mut T {\n        lazy.cell.get_mut().expect(\"encountered empty storage cell\")\n    }\n\n    /// Sets the value to `value`, without executing any reads.\n    ///\n    /// # Note\n    ///\n    /// No reads from contract storage will be executed.\n    ///\n    /// This method should be preferred over dereferencing or `get_mut`\n    /// in case the returned value is of no interest to the caller.\n    ///\n    /// # Panics\n    ///\n    /// If accessing the inner value fails.\n    #[inline]\n    pub fn set(lazy: &mut Self, new_value: T) {\n        lazy.cell.set(new_value);\n    }\n}\n\nimpl<T> From<T> for Lazy<T>\nwhere\n    T: SpreadLayout,\n{\n    fn from(value: T) -> Self {\n        Self::new(value)\n    }\n}\n\nimpl<T> Default for Lazy<T>\nwhere\n    T: Default + SpreadLayout,\n{\n    fn default() -> Self {\n        Self::new(Default::default())\n    }\n}\n\nimpl<T> core::cmp::PartialEq for Lazy<T>\nwhere\n    T: PartialEq + SpreadLayout,\n{\n    fn eq(&self, other: &Self) -> bool {\n        PartialEq::eq(Lazy::get(self), Lazy::get(other))\n    }\n}\n\nimpl<T> core::cmp::Eq for Lazy<T> where T: Eq + SpreadLayout {}\n\nimpl<T> core::cmp::PartialOrd for Lazy<T>\nwhere\n    T: PartialOrd + SpreadLayout,\n{\n    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n        PartialOrd::partial_cmp(Lazy::get(self), Lazy::get(other))\n    }\n    fn lt(&self, other: &Self) -> bool {\n        PartialOrd::lt(Lazy::get(self), Lazy::get(other))\n    }\n    fn le(&self, other: &Self) -> bool {\n        PartialOrd::le(Lazy::get(self), Lazy::get(other))\n    }\n    fn ge(&self, other: &Self) -> bool {\n        PartialOrd::ge(Lazy::get(self), Lazy::get(other))\n    }\n    fn gt(&self, other: &Self) -> bool {\n        PartialOrd::gt(Lazy::get(self), Lazy::get(other))\n    }\n}\n\nimpl<T> core::cmp::Ord for Lazy<T>\nwhere\n    T: core::cmp::Ord + SpreadLayout,\n{\n    fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n        Ord::cmp(Lazy::get(self), Lazy::get(other))\n    }\n}\n\nimpl<T> core::fmt::Display for Lazy<T>\nwhere\n    T: core::fmt::Display + SpreadLayout,\n{\n    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n        core::fmt::Display::fmt(Lazy::get(self), f)\n    }\n}\n\nimpl<T> core::hash::Hash for Lazy<T>\nwhere\n    T: core::hash::Hash + SpreadLayout,\n{\n    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {\n        Lazy::get(self).hash(state);\n    }\n}\n\nimpl<T> core::convert::AsRef<T> for Lazy<T>\nwhere\n    T: SpreadLayout,\n{\n    fn as_ref(&self) -> &T {\n        Lazy::get(self)\n    }\n}\n\nimpl<T> core::convert::AsMut<T> for Lazy<T>\nwhere\n    T: SpreadLayout,\n{\n    fn as_mut(&mut self) -> &mut T {\n        Lazy::get_mut(self)\n    }\n}\n\nimpl<T> ink_prelude::borrow::Borrow<T> for Lazy<T>\nwhere\n    T: SpreadLayout,\n{\n    fn borrow(&self) -> &T {\n        Lazy::get(self)\n    }\n}\n\nimpl<T> ink_prelude::borrow::BorrowMut<T> for Lazy<T>\nwhere\n    T: SpreadLayout,\n{\n    fn borrow_mut(&mut self) -> &mut T {\n        Lazy::get_mut(self)\n    }\n}\n\nimpl<T> core::ops::Deref for Lazy<T>\nwhere\n    T: SpreadLayout,\n{\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        Lazy::get(self)\n    }\n}\n\nimpl<T> core::ops::DerefMut for Lazy<T>\nwhere\n    T: SpreadLayout,\n{\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        Lazy::get_mut(self)\n    }\n}\n"],["1026","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse proc_macro2::TokenStream as TokenStream2;\nuse quote::quote;\n\n/// Generates the tokens to compute the maximum of the numbers given via\n/// their token streams at compilation time.\n///\n/// # Note\n///\n/// Since Rust currently does not allow conditionals in const contexts\n/// we use the array indexing trick to compute the maximum element:\n///\n/// ```no_compile\n/// max(a, b) = [a, b][(a < b) as usize]\n/// ```\nfn max_n(args: &[TokenStream2]) -> TokenStream2 {\n    match args.split_first() {\n        Some((head, rest)) => {\n            let rest = max_n(rest);\n            quote! {\n                [#head, #rest][(#head < #rest) as usize]\n            }\n        }\n        None => quote! { 0u64 },\n    }\n}\n\n/// Generates the tokens for the `SpreadLayout` footprint of some type.\nfn footprint(s: &synstructure::Structure) -> TokenStream2 {\n    let variant_footprints = s\n        .variants()\n        .iter()\n        .map(|variant| {\n            variant\n                .ast()\n                .fields\n                .iter()\n                .map(|field| &field.ty)\n                .map(|ty| quote! { <#ty as ::ink_storage::traits::SpreadLayout>::FOOTPRINT })\n                .fold(quote! { 0u64 }, |lhs, rhs| {\n                    quote! { (#lhs + #rhs) }\n                })\n        })\n        .collect::<Vec<_>>();\n    max_n(&variant_footprints[..])\n}\n\n/// Generates the tokens for the `SpreadLayout` `REQUIRES_DEEP_CLEAN_UP` constant for the given structure.\nfn requires_deep_clean_up(s: &synstructure::Structure) -> TokenStream2 {\n    s.variants()\n        .iter()\n        .map(|variant| {\n            variant\n            .ast()\n            .fields\n            .iter()\n            .map(|field| &field.ty)\n            .map(|ty| quote! { <#ty as ::ink_storage::traits::SpreadLayout>::REQUIRES_DEEP_CLEAN_UP })\n            .fold(quote! { false }, |lhs, rhs| {\n                quote! { (#lhs || #rhs) }\n            })\n        })\n        .fold(quote! { false }, |lhs, rhs| {\n            quote! { (#lhs || #rhs) }\n        })\n}\n\n/// `SpreadLayout` derive implementation for `struct` types.\nfn spread_layout_struct_derive(s: &synstructure::Structure) -> TokenStream2 {\n    assert!(s.variants().len() == 1, \"can only operate on structs\");\n    let footprint_body = footprint(s);\n    let requires_deep_clean_up_body = requires_deep_clean_up(s);\n    let variant: &synstructure::VariantInfo = &s.variants()[0];\n    let pull_body = variant.construct(|field, _index| {\n        let ty = &field.ty;\n        quote! {\n            <#ty as ::ink_storage::traits::SpreadLayout>::pull_spread(__key_ptr)\n        }\n    });\n    let push_body = variant.each(|binding| {\n        quote! {\n            ::ink_storage::traits::SpreadLayout::push_spread(#binding, __key_ptr);\n        }\n    });\n    let clear_body = s.each(|field| {\n        quote! {\n            ::ink_storage::traits::SpreadLayout::clear_spread(#field, __key_ptr);\n        }\n    });\n    s.gen_impl(quote! {\n        gen impl ::ink_storage::traits::SpreadLayout for @Self {\n            #[allow(unused_comparisons)]\n            const FOOTPRINT: u64 = #footprint_body;\n            const REQUIRES_DEEP_CLEAN_UP: bool = #requires_deep_clean_up_body;\n\n            fn pull_spread(__key_ptr: &mut ::ink_storage::traits::KeyPtr) -> Self {\n                #pull_body\n            }\n            fn push_spread(&self, __key_ptr: &mut ::ink_storage::traits::KeyPtr) {\n                match self { #push_body }\n            }\n            fn clear_spread(&self, __key_ptr: &mut ::ink_storage::traits::KeyPtr) {\n                match self { #clear_body }\n            }\n        }\n    })\n}\n\n/// `SpreadLayout` derive implementation for `enum` types.\nfn spread_layout_enum_derive(s: &synstructure::Structure) -> TokenStream2 {\n    assert!(s.variants().len() >= 2, \"can only operate on enums\");\n    let footprint_body = footprint(s);\n    let requires_deep_clean_up_body = requires_deep_clean_up(s);\n    let pull_body = s\n        .variants()\n        .iter()\n        .map(|variant| {\n            variant.construct(|field, _index| {\n                let ty = &field.ty;\n                quote! {\n                    <#ty as ::ink_storage::traits::SpreadLayout>::pull_spread(__key_ptr)\n                }\n            })\n        })\n        .enumerate()\n        .fold(quote! {}, |acc, (index, variant)| {\n            let index = index as u8;\n            quote! {\n                #acc\n                #index => #variant,\n            }\n        });\n\n    let push_body = s.variants().iter().enumerate().map(|(index, variant)| {\n        let pat = variant.pat();\n        let index = index as u8;\n        let fields = variant.bindings().iter().map(|field| {\n            quote! {\n                ::ink_storage::traits::SpreadLayout::push_spread(#field, __key_ptr);\n            }\n        });\n        quote! {\n            #pat => {\n                { <u8 as ::ink_storage::traits::SpreadLayout>::push_spread(&#index, __key_ptr); }\n                #(\n                    { #fields }\n                )*\n            }\n        }\n    });\n    let clear_body = s.each(|field| {\n        quote! {\n            ::ink_storage::traits::SpreadLayout::clear_spread(#field, __key_ptr);\n        }\n    });\n    s.gen_impl(quote! {\n        gen impl ::ink_storage::traits::SpreadLayout for @Self {\n            #[allow(unused_comparisons)]\n            const FOOTPRINT: u64 = 1 + #footprint_body;\n\n            const REQUIRES_DEEP_CLEAN_UP: bool = #requires_deep_clean_up_body;\n\n            fn pull_spread(__key_ptr: &mut ::ink_storage::traits::KeyPtr) -> Self {\n                match <u8 as ::ink_storage::traits::SpreadLayout>::pull_spread(__key_ptr) {\n                    #pull_body\n                    _ => unreachable!(\"encountered invalid enum discriminant\"),\n                }\n            }\n            fn push_spread(&self, __key_ptr: &mut ::ink_storage::traits::KeyPtr) {\n                match self {\n                    #(\n                        #push_body\n                    )*\n                }\n            }\n            fn clear_spread(&self, __key_ptr: &mut ::ink_storage::traits::KeyPtr) {\n                match self {\n                    #clear_body\n                }\n            }\n        }\n    })\n}\n\n/// Derives `ink_storage`'s `SpreadLayout` trait for the given `struct` or `enum`.\npub fn spread_layout_derive(mut s: synstructure::Structure) -> TokenStream2 {\n    s.bind_with(|_| synstructure::BindStyle::Move)\n        .add_bounds(synstructure::AddBounds::Generics)\n        .underscore_const(true);\n    match s.ast().data {\n        syn::Data::Struct(_) => spread_layout_struct_derive(&s),\n        syn::Data::Enum(_) => spread_layout_enum_derive(&s),\n        _ => {\n            panic!(\n                \"cannot derive `SpreadLayout` or `PackedLayout` for Rust `union` items\"\n            )\n        }\n    }\n}\n"],["1027","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse proc_macro2::TokenStream as TokenStream2;\nuse quote::quote;\n\n/// Derives `ink_storage`'s `PackedLayout` trait for the given `struct` or `enum`.\npub fn packed_layout_derive(mut s: synstructure::Structure) -> TokenStream2 {\n    s.bind_with(|_| synstructure::BindStyle::Move)\n        .add_bounds(synstructure::AddBounds::Generics)\n        .underscore_const(true);\n    let pull_body = s.each(|binding| {\n        quote! { ::ink_storage::traits::PackedLayout::pull_packed(#binding, __key); }\n    });\n    let push_body = s.each(|binding| {\n        quote! { ::ink_storage::traits::PackedLayout::push_packed(#binding, __key); }\n    });\n    let clear_body = s.each(|binding| {\n        quote! { ::ink_storage::traits::PackedLayout::clear_packed(#binding, __key); }\n    });\n    s.gen_impl(quote! {\n        gen impl ::ink_storage::traits::PackedLayout for @Self {\n            fn pull_packed(&mut self, __key: &::ink_primitives::Key) {\n                match self { #pull_body }\n            }\n            fn push_packed(&self, __key: &::ink_primitives::Key) {\n                match self { #push_body }\n            }\n            fn clear_packed(&self, __key: &::ink_primitives::Key) {\n                match self { #clear_body }\n            }\n        }\n    })\n}\n"],["1028","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse proc_macro2::TokenStream as TokenStream2;\nuse quote::quote;\n\nfn field_layout<'a>(\n    variant: &'a synstructure::VariantInfo,\n) -> impl Iterator<Item = TokenStream2> + 'a {\n    variant.ast().fields.iter().map(|field| {\n        let ident = match field.ident.as_ref() {\n            Some(ident) => {\n                let ident_str = ident.to_string();\n                quote! { Some(#ident_str) }\n            }\n            None => quote! { None },\n        };\n        let ty = &field.ty;\n        quote! {\n            ::ink_metadata::layout::FieldLayout::new(\n                #ident,\n                <#ty as ::ink_storage::traits::StorageLayout>::layout(__key_ptr),\n            )\n        }\n    })\n}\n\nfn storage_layout_struct(s: &synstructure::Structure) -> TokenStream2 {\n    assert!(\n        matches!(s.ast().data, syn::Data::Struct(_)),\n        \"s must be a struct item\"\n    );\n    assert!(\n        s.variants().len() == 1,\n        \"structs must have at most one variant\"\n    );\n    let variant: &synstructure::VariantInfo = &s.variants()[0];\n    let field_layouts = field_layout(variant);\n    s.gen_impl(quote! {\n        gen impl ::ink_storage::traits::StorageLayout for @Self {\n            fn layout(__key_ptr: &mut ::ink_storage::traits::KeyPtr) -> ::ink_metadata::layout::Layout {\n                ::ink_metadata::layout::Layout::Struct(\n                    ::ink_metadata::layout::StructLayout::new(vec![\n                        #(#field_layouts ,)*\n                    ])\n                )\n            }\n        }\n    })\n}\n\nfn storage_layout_enum(s: &synstructure::Structure) -> TokenStream2 {\n    assert!(\n        matches!(s.ast().data, syn::Data::Enum(_)),\n        \"s must be an enum item\"\n    );\n    let variant_layouts = s.variants().iter().enumerate().map(|(n, variant)| {\n        let discriminant = variant\n            .ast()\n            .discriminant\n            .as_ref()\n            .map(|(_, expr)| quote! { #expr })\n            .unwrap_or_else(|| quote! { #n });\n        let field_layouts = field_layout(variant);\n        quote! {\n            {\n                let mut __variant_key_ptr = __key_ptr.clone();\n                let mut __key_ptr = &mut __variant_key_ptr;\n                (\n                    ::ink_metadata::layout::Discriminant::from(#discriminant),\n                    ::ink_metadata::layout::StructLayout::new(vec![\n                        #(#field_layouts ,)*\n                    ]),\n                )\n            }\n        }\n    });\n    s.gen_impl(quote! {\n        gen impl ::ink_storage::traits::StorageLayout for @Self {\n            fn layout(__key_ptr: &mut ::ink_storage::traits::KeyPtr) -> ::ink_metadata::layout::Layout {\n                let dispatch_key = __key_ptr.advance_by(1);\n                ::ink_metadata::layout::Layout::Enum(\n                    ::ink_metadata::layout::EnumLayout::new(\n                        ::ink_metadata::layout::LayoutKey::from(dispatch_key),\n                        vec![\n                            #(#variant_layouts ,)*\n                        ]\n                    )\n                )\n            }\n        }\n    })\n}\n\npub fn storage_layout_derive(mut s: synstructure::Structure) -> TokenStream2 {\n    s.bind_with(|_| synstructure::BindStyle::Move)\n        .add_bounds(synstructure::AddBounds::Generics)\n        .underscore_const(true);\n    match s.ast().data {\n        syn::Data::Struct(_) => storage_layout_struct(&s),\n        syn::Data::Enum(_) => storage_layout_enum(&s),\n        _ => panic!(\"cannot derive `StorageLayout` for Rust `union` items\"),\n    }\n}\n"],["1029","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::spread_layout_derive;\n\n#[test]\nfn unit_struct_works() {\n    synstructure::test_derive! {\n        spread_layout_derive {\n            struct UnitStruct;\n        }\n        expands to {\n            const _: () = {\n                impl ::ink_storage::traits::SpreadLayout for UnitStruct {\n                    #[allow(unused_comparisons)]\n                    const FOOTPRINT: u64 = [0u64, 0u64][(0u64 < 0u64) as usize];\n\n                    const REQUIRES_DEEP_CLEAN_UP : bool = (false || false );\n\n                    fn pull_spread(__key_ptr: &mut ::ink_storage::traits::KeyPtr) -> Self {\n                        UnitStruct\n                    }\n\n                    fn push_spread(&self, __key_ptr: &mut ::ink_storage::traits::KeyPtr) {\n                        match self {\n                            UnitStruct => {}\n                        }\n                    }\n\n                    fn clear_spread(&self, __key_ptr: &mut ::ink_storage::traits::KeyPtr) {\n                        match self {\n                            UnitStruct => {}\n                        }\n                    }\n                }\n            };\n        }\n    }\n}\n\n#[test]\nfn struct_works() {\n    synstructure::test_derive! {\n        spread_layout_derive {\n            struct NamedFields {\n                a: i32,\n                b: [u8; 32],\n                d: Box<i32>,\n            }\n        }\n        expands to {\n            const _: () = {\n                impl ::ink_storage::traits::SpreadLayout for NamedFields {\n                    #[allow(unused_comparisons)]\n                    const FOOTPRINT: u64 = [\n                        (((0u64 + <i32 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT)\n                            + <[u8; 32] as ::ink_storage::traits::SpreadLayout>::FOOTPRINT)\n                            + <Box<i32> as ::ink_storage::traits::SpreadLayout>::FOOTPRINT),\n                        0u64\n                    ][((((0u64\n                        + <i32 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT)\n                        + <[u8; 32] as ::ink_storage::traits::SpreadLayout>::FOOTPRINT)\n                        + <Box<i32> as ::ink_storage::traits::SpreadLayout>::FOOTPRINT)\n                        < 0u64) as usize\n                    ];\n\n                    const REQUIRES_DEEP_CLEAN_UP : bool = (\n                        false || (\n                            (\n                                (\n                                    false\n                                    || <i32 as ::ink_storage::traits::SpreadLayout>::REQUIRES_DEEP_CLEAN_UP\n                                )\n                                || <[u8; 32] as ::ink_storage::traits::SpreadLayout>::REQUIRES_DEEP_CLEAN_UP\n                            )\n                            || <Box<i32> as ::ink_storage::traits::SpreadLayout>::REQUIRES_DEEP_CLEAN_UP\n                        )\n                    );\n\n                    fn pull_spread(__key_ptr: &mut ::ink_storage::traits::KeyPtr) -> Self {\n                        NamedFields {\n                            a : <i32 as ::ink_storage::traits::SpreadLayout>::pull_spread(__key_ptr),\n                            b : <[u8; 32] as ::ink_storage::traits::SpreadLayout>::pull_spread(__key_ptr),\n                            d : <Box<i32> as ::ink_storage::traits::SpreadLayout>::pull_spread(__key_ptr),\n                        }\n                    }\n\n                    fn push_spread(&self, __key_ptr: &mut ::ink_storage::traits::KeyPtr) {\n                        match self {\n                            NamedFields {\n                                a: __binding_0,\n                                b: __binding_1,\n                                d: __binding_2,\n                            } => {\n                                {\n                                    ::ink_storage::traits::SpreadLayout::push_spread(\n                                        __binding_0,\n                                        __key_ptr\n                                    );\n                                }\n                                {\n                                    ::ink_storage::traits::SpreadLayout::push_spread(\n                                        __binding_1,\n                                        __key_ptr\n                                    );\n                                }\n                                {\n                                    ::ink_storage::traits::SpreadLayout::push_spread(\n                                        __binding_2,\n                                        __key_ptr\n                                    );\n                                }\n                            }\n                        }\n                    }\n\n                    fn clear_spread(&self, __key_ptr: &mut ::ink_storage::traits::KeyPtr) {\n                        match self {\n                            NamedFields {\n                                a: __binding_0,\n                                b: __binding_1,\n                                d: __binding_2,\n                            } => {\n                                {\n                                    ::ink_storage::traits::SpreadLayout::clear_spread(\n                                        __binding_0,\n                                        __key_ptr\n                                    );\n                                }\n                                {\n                                    ::ink_storage::traits::SpreadLayout::clear_spread(\n                                        __binding_1,\n                                        __key_ptr\n                                    );\n                                }\n                                {\n                                    ::ink_storage::traits::SpreadLayout::clear_spread(\n                                        __binding_2,\n                                        __key_ptr\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n        }\n    }\n}\n\n#[test]\nfn enum_works() {\n    synstructure::test_derive! {\n        spread_layout_derive {\n            enum MixedEnum {\n                A,\n                B(i32, [u8; 32]),\n                C { a: i32, b: (bool, i32) },\n            }\n        }\n        expands to {\n            const _: () = {\n                impl ::ink_storage::traits::SpreadLayout for MixedEnum {\n                    #[allow(unused_comparisons)]\n                    const FOOTPRINT : u64 = 1 + [\n                        0u64 ,\n                        [\n                            (\n                                (\n                                    0u64\n                                    + <i32 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT\n                                )\n                                + <[u8; 32] as ::ink_storage::traits::SpreadLayout>::FOOTPRINT)\n                            ,\n                            [\n                                (\n                                    (\n                                        0u64\n                                        + <i32 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT\n                                    )\n                                    + <(bool, i32) as ::ink_storage::traits::SpreadLayout>::FOOTPRINT\n                                ),\n                                0u64\n                            ]\n                            [\n                                (\n                                    (\n                                        (\n                                            0u64\n                                            + <i32 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT\n                                        )\n                                        + <(bool, i32) as ::ink_storage::traits::SpreadLayout>::FOOTPRINT\n                                    )\n                                    < 0u64\n                                ) as usize\n                            ]\n                        ][\n                            (\n                                (\n                                    (\n                                        0u64\n                                        + <i32 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT\n                                    )\n                                    + <[u8; 32] as ::ink_storage::traits::SpreadLayout>::FOOTPRINT\n                                )\n                                <[\n                                    (\n                                        (\n                                            0u64\n                                            + <i32 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT\n                                        )\n                                        + <(bool, i32) as ::ink_storage::traits::SpreadLayout>::FOOTPRINT\n                                    ),\n                                    0u64\n                                ][\n                                    (\n                                        (\n                                            (\n                                                0u64\n                                                + <i32 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT\n                                            )\n                                            + <(bool, i32) as ::ink_storage::traits::SpreadLayout>::FOOTPRINT\n                                        )\n                                        < 0u64\n                                    ) as usize\n                                ]\n                            ) as usize\n                        ]\n                    ][\n                        (\n                            0u64 <[\n                                (\n                                    (\n                                        0u64\n                                        + <i32 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT\n                                    )\n                                    + <[u8; 32] as ::ink_storage::traits::SpreadLayout>::FOOTPRINT\n                                ),\n                                [\n                                    (\n                                        (\n                                            0u64\n                                            + <i32 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT\n                                        )\n                                        + <(bool, i32) as ::ink_storage::traits::SpreadLayout>::FOOTPRINT\n                                    ),\n                                    0u64\n                                ][\n                                    (\n                                        (\n                                            (\n                                                0u64\n                                                + <i32 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT\n                                            )\n                                            + <(bool, i32) as ::ink_storage::traits::SpreadLayout>::FOOTPRINT\n                                        )\n                                        < 0u64\n                                    ) as usize\n                                ]\n                            ][\n                                (\n                                    (\n                                        (\n                                            0u64\n                                            + <i32 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT\n                                        )\n                                        + <[u8; 32] as ::ink_storage::traits::SpreadLayout>::FOOTPRINT\n                                    )\n                                    <[\n                                        (\n                                            (\n                                                0u64\n                                                + <i32 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT\n                                            )\n                                            + <(bool, i32) as ::ink_storage::traits::SpreadLayout>::FOOTPRINT\n                                        ),\n                                        0u64\n                                    ][\n                                        (\n                                            (\n                                                (\n                                                    0u64\n                                                    + <i32 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT\n                                                )\n                                                + <(bool, i32) as ::ink_storage::traits::SpreadLayout>::FOOTPRINT\n                                            )\n                                            < 0u64\n                                        ) as usize\n                                    ]\n                                ) as usize\n                            ]\n                        ) as usize\n                    ];\n\n                    const REQUIRES_DEEP_CLEAN_UP : bool = (\n                        (\n                            (false || false)\n                            || (\n                                (\n                                    false\n                                    || <i32 as ::ink_storage::traits::SpreadLayout>::REQUIRES_DEEP_CLEAN_UP\n                                )\n                                || <[u8; 32] as ::ink_storage::traits::SpreadLayout>::REQUIRES_DEEP_CLEAN_UP\n                            )\n                        )\n                        || (\n                            (\n                                false\n                                || <i32 as ::ink_storage::traits::SpreadLayout>::REQUIRES_DEEP_CLEAN_UP\n                            )\n                            || <(bool, i32) as ::ink_storage::traits::SpreadLayout>::REQUIRES_DEEP_CLEAN_UP\n                        )\n                    );\n\n                    fn pull_spread(__key_ptr: &mut ::ink_storage::traits::KeyPtr) -> Self {\n                        match <u8 as ::ink_storage::traits::SpreadLayout>::pull_spread(__key_ptr)\n                        {\n                            0u8 => MixedEnum::A,\n                            1u8 => MixedEnum::B(\n                                <i32 as ::ink_storage::traits::SpreadLayout>::pull_spread(__key_ptr),\n                                <[u8; 32] as ::ink_storage::traits::SpreadLayout>::pull_spread(__key_ptr),\n                            ),\n                            2u8 => MixedEnum::C {\n                                a: < i32 as ::ink_storage::traits::SpreadLayout>::pull_spread(__key_ptr ),\n                                b: <(bool, i32) as ::ink_storage::traits::SpreadLayout>::pull_spread(__key_ptr),\n                            },\n                            _ => unreachable!(\"encountered invalid enum discriminant\"),\n                        }\n                    }\n                    fn push_spread(&self, __key_ptr: &mut ::ink_storage::traits::KeyPtr) {\n                        match self {\n                            MixedEnum::A => {\n                                {\n                                    <u8 as ::ink_storage::traits::SpreadLayout>::push_spread(\n                                        &0u8,\n                                        __key_ptr\n                                    );\n                                }\n                            }\n                            MixedEnum::B(__binding_0, __binding_1,) => {\n                                {\n                                    <u8 as ::ink_storage::traits::SpreadLayout>::push_spread(\n                                        &1u8,\n                                        __key_ptr\n                                    );\n                                }\n                                {\n                                    ::ink_storage::traits::SpreadLayout::push_spread(\n                                        __binding_0,\n                                        __key_ptr\n                                    );\n                                }\n                                {\n                                    ::ink_storage::traits::SpreadLayout::push_spread(\n                                        __binding_1,\n                                        __key_ptr\n                                    );\n                                }\n                            }\n                            MixedEnum::C {\n                                a: __binding_0,\n                                b: __binding_1,\n                            } => {\n                                {\n                                    <u8 as ::ink_storage::traits::SpreadLayout>::push_spread(\n                                        &2u8, __key_ptr\n                                    );\n                                }\n                                {\n                                    ::ink_storage::traits::SpreadLayout::push_spread(\n                                        __binding_0,\n                                        __key_ptr\n                                    );\n                                }\n                                {\n                                    ::ink_storage::traits::SpreadLayout::push_spread(\n                                        __binding_1,\n                                        __key_ptr\n                                    );\n                                }\n                            }\n                        }\n                    }\n                    fn clear_spread(&self, __key_ptr: &mut ::ink_storage::traits::KeyPtr) {\n                        match self {\n                            MixedEnum::A => {}\n                            MixedEnum::B(__binding_0, __binding_1,) => {\n                                {\n                                    ::ink_storage::traits::SpreadLayout::clear_spread(\n                                        __binding_0,\n                                        __key_ptr\n                                    );\n                                }\n                                {\n                                    ::ink_storage::traits::SpreadLayout::clear_spread(\n                                        __binding_1,\n                                        __key_ptr\n                                    );\n                                }\n                            }\n                            MixedEnum::C {\n                                a: __binding_0,\n                                b: __binding_1,\n                            } => {\n                                {\n                                    ::ink_storage::traits::SpreadLayout::clear_spread(\n                                        __binding_0,\n                                        __key_ptr\n                                    );\n                                }\n                                {\n                                    ::ink_storage::traits::SpreadLayout::clear_spread(\n                                        __binding_1,\n                                        __key_ptr\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n        }\n    }\n}\n\n#[test]\nfn generic_struct_works() {\n    synstructure::test_derive! {\n        spread_layout_derive {\n            struct GenericStruct<T1, T2> {\n                a: T1,\n                b: (T1, T2),\n            }\n        }\n        expands to {\n            const _: () = {\n                impl<T1, T2> ::ink_storage::traits::SpreadLayout for GenericStruct<T1, T2>\n                where\n                    T1: ::ink_storage::traits::SpreadLayout,\n                    T2: ::ink_storage::traits::SpreadLayout\n                {\n                    #[allow(unused_comparisons)]\n                    const FOOTPRINT: u64 = [\n                        ((0u64 + <T1 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT)\n                            + <(T1, T2) as ::ink_storage::traits::SpreadLayout>::FOOTPRINT),\n                        0u64\n                    ][(((0u64 + <T1 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT)\n                        + <(T1, T2) as ::ink_storage::traits::SpreadLayout>::FOOTPRINT)\n                        < 0u64) as usize\n                    ];\n\n                    const REQUIRES_DEEP_CLEAN_UP : bool = (\n                        false || (\n                            (\n                                false\n                                || <T1 as ::ink_storage::traits::SpreadLayout>::REQUIRES_DEEP_CLEAN_UP\n                            )\n                            || < (T1, T2) as ::ink_storage::traits::SpreadLayout>::REQUIRES_DEEP_CLEAN_UP\n                        )\n                    );\n\n                    fn pull_spread(__key_ptr: &mut ::ink_storage::traits::KeyPtr) -> Self {\n                        GenericStruct {\n                            a: <T1 as ::ink_storage::traits::SpreadLayout>::pull_spread(\n                                __key_ptr\n                            ),\n                            b: <(T1, T2) as ::ink_storage::traits::SpreadLayout>::pull_spread(\n                                __key_ptr\n                            ),\n                        }\n                    }\n\n                    fn push_spread(&self, __key_ptr: &mut ::ink_storage::traits::KeyPtr) {\n                        match self {\n                            GenericStruct {\n                                a: __binding_0,\n                                b: __binding_1,\n                            } => {\n                                {\n                                    ::ink_storage::traits::SpreadLayout::push_spread(\n                                        __binding_0,\n                                        __key_ptr\n                                    );\n                                }\n                                {\n                                    ::ink_storage::traits::SpreadLayout::push_spread(\n                                        __binding_1,\n                                        __key_ptr\n                                    );\n                                }\n                            }\n                        }\n                    }\n\n                    fn clear_spread(&self, __key_ptr: &mut ::ink_storage::traits::KeyPtr) {\n                        match self {\n                            GenericStruct {\n                                a: __binding_0,\n                                b: __binding_1,\n                            } => {\n                                {\n                                    ::ink_storage::traits::SpreadLayout::clear_spread(\n                                        __binding_0,\n                                        __key_ptr\n                                    );\n                                }\n                                {\n                                    ::ink_storage::traits::SpreadLayout::clear_spread(\n                                        __binding_1,\n                                        __key_ptr\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n        }\n    }\n}\n\n#[test]\nfn generic_enum_works() {\n    synstructure::test_derive! {\n        spread_layout_derive {\n            enum GenericEnum<T1, T2> {\n                Tuple(T1, T2),\n                Named { a: T1, b: T2 },\n            }\n        }\n        expands to {\n            const _: () = {\n                impl<T1, T2> ::ink_storage::traits::SpreadLayout for GenericEnum<T1, T2>\n                where\n                    T1: ::ink_storage::traits::SpreadLayout,\n                    T2: ::ink_storage::traits::SpreadLayout\n                {\n                    #[allow(unused_comparisons)]\n                    const FOOTPRINT: u64 = 1 + [\n                        ((0u64 + <T1 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT)\n                            + <T2 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT),\n                        [\n                            ((0u64 + <T1 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT)\n                                + <T2 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT),\n                            0u64\n                        ][(((0u64\n                            + <T1 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT)\n                            + <T2 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT)\n                            < 0u64) as usize]\n                    ][(((0u64 + <T1 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT)\n                        + <T2 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT)\n                        < [\n                            ((0u64 + <T1 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT)\n                                + <T2 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT),\n                            0u64\n                        ][(((0u64\n                            + <T1 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT)\n                            + <T2 as ::ink_storage::traits::SpreadLayout>::FOOTPRINT)\n                            < 0u64) as usize]) as usize\n                    ];\n\n                    const REQUIRES_DEEP_CLEAN_UP : bool = (\n                        (\n                            false || (\n                                (\n                                    false\n                                    || <T1 as ::ink_storage::traits::SpreadLayout>::REQUIRES_DEEP_CLEAN_UP\n                                )\n                                || <T2 as ::ink_storage::traits::SpreadLayout>::REQUIRES_DEEP_CLEAN_UP\n                            )\n                        )\n                        || (\n                            (\n                                false\n                                || <T1 as ::ink_storage::traits::SpreadLayout>::REQUIRES_DEEP_CLEAN_UP\n                            )\n                            || <T2 as ::ink_storage::traits::SpreadLayout>::REQUIRES_DEEP_CLEAN_UP\n                        )\n                    );\n\n                    fn pull_spread(__key_ptr: &mut ::ink_storage::traits::KeyPtr) -> Self {\n                        match <u8 as ::ink_storage::traits::SpreadLayout>::pull_spread(__key_ptr)\n                        {\n                            0u8 => GenericEnum::Tuple(\n                                <T1 as ::ink_storage::traits::SpreadLayout>::pull_spread(__key_ptr),\n                                <T2 as ::ink_storage::traits::SpreadLayout>::pull_spread(__key_ptr),\n                            ),\n                            1u8 => GenericEnum::Named {\n                                a: <T1 as ::ink_storage::traits::SpreadLayout>::pull_spread(__key_ptr),\n                                b: <T2 as ::ink_storage::traits::SpreadLayout>::pull_spread(__key_ptr),\n                            },\n                            _ => unreachable!(\"encountered invalid enum discriminant\"),\n                        }\n                    }\n\n                    fn push_spread(&self, __key_ptr: &mut ::ink_storage::traits::KeyPtr) {\n                        match self {\n                            GenericEnum::Tuple(__binding_0, __binding_1,) => {\n                                {\n                                    <u8 as ::ink_storage::traits::SpreadLayout>::push_spread(&0u8, __key_ptr);\n                                }\n                                {\n                                    ::ink_storage::traits::SpreadLayout::push_spread(\n                                        __binding_0,\n                                        __key_ptr\n                                    );\n                                }\n                                {\n                                    ::ink_storage::traits::SpreadLayout::push_spread(\n                                        __binding_1,\n                                        __key_ptr\n                                    );\n                                }\n                            }\n                            GenericEnum::Named {\n                                a: __binding_0,\n                                b: __binding_1,\n                            } => {\n                                {\n                                    <u8 as ::ink_storage::traits::SpreadLayout>::push_spread(&1u8, __key_ptr);\n                                }\n                                {\n                                    ::ink_storage::traits::SpreadLayout::push_spread(\n                                        __binding_0,\n                                        __key_ptr\n                                    );\n                                }\n                                {\n                                    ::ink_storage::traits::SpreadLayout::push_spread(\n                                        __binding_1,\n                                        __key_ptr\n                                    );\n                                }\n                            }\n                        }\n                    }\n\n                    fn clear_spread(&self, __key_ptr: &mut ::ink_storage::traits::KeyPtr) {\n                        match self {\n                            GenericEnum::Tuple(__binding_0, __binding_1,) => {\n                                {\n                                    ::ink_storage::traits::SpreadLayout::clear_spread(\n                                        __binding_0,\n                                        __key_ptr\n                                    );\n                                }\n                                {\n                                    ::ink_storage::traits::SpreadLayout::clear_spread(\n                                        __binding_1,\n                                        __key_ptr\n                                    );\n                                }\n                            }\n                            GenericEnum::Named {\n                                a: __binding_0,\n                                b: __binding_1,\n                            } => {\n                                {\n                                    ::ink_storage::traits::SpreadLayout::clear_spread(\n                                        __binding_0,\n                                        __key_ptr\n                                    );\n                                }\n                                {\n                                    ::ink_storage::traits::SpreadLayout::clear_spread(\n                                        __binding_1,\n                                        __key_ptr\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n        }\n    }\n}\n"],["1030","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nmod packed_layout;\nmod spread_layout;\nmod storage_layout;\n"],["1031","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::packed_layout_derive;\n\n#[test]\nfn unit_struct_works() {\n    synstructure::test_derive! {\n        packed_layout_derive {\n            struct UnitStruct;\n        }\n        expands to {\n            const _: () = {\n                impl ::ink_storage::traits::PackedLayout for UnitStruct {\n                    fn pull_packed(&mut self, __key: &::ink_primitives::Key) {\n                        match self {\n                            UnitStruct => {}\n                        }\n                    }\n\n                    fn push_packed(&self, __key: &::ink_primitives::Key) {\n                        match self {\n                            UnitStruct => {}\n                        }\n                    }\n\n                    fn clear_packed(&self, __key: &::ink_primitives::Key) {\n                        match self {\n                            UnitStruct => {}\n                        }\n                    }\n                }\n            };\n        }\n        no_build\n    }\n}\n\n#[test]\nfn struct_works() {\n    synstructure::test_derive! {\n        packed_layout_derive {\n            struct NamedFields {\n                a: i32,\n                b: [u8; 32],\n                d: Box<i32>,\n            }\n        }\n        expands to {\n            const _: () = {\n                impl ::ink_storage::traits::PackedLayout for NamedFields {\n                    fn pull_packed(&mut self, __key: &::ink_primitives::Key) {\n                        match self {\n                            NamedFields {\n                                a: __binding_0,\n                                b: __binding_1,\n                                d: __binding_2,\n                            } => {\n                                {\n                                    ::ink_storage::traits::PackedLayout::pull_packed(__binding_0, __key);\n                                }\n                                {\n                                    ::ink_storage::traits::PackedLayout::pull_packed(__binding_1, __key);\n                                }\n                                {\n                                    ::ink_storage::traits::PackedLayout::pull_packed(__binding_2, __key);\n                                }\n                            }\n                        }\n                    }\n                    fn push_packed(&self, __key: &::ink_primitives::Key) {\n                        match self {\n                            NamedFields {\n                                a: __binding_0,\n                                b: __binding_1,\n                                d: __binding_2,\n                            } => {\n                                {\n                                    ::ink_storage::traits::PackedLayout::push_packed(__binding_0, __key);\n                                }\n                                {\n                                    ::ink_storage::traits::PackedLayout::push_packed(__binding_1, __key);\n                                }\n                                {\n                                    ::ink_storage::traits::PackedLayout::push_packed(__binding_2, __key);\n                                }\n                            }\n                        }\n                    }\n                    fn clear_packed(&self, __key: &::ink_primitives::Key) {\n                        match self {\n                            NamedFields {\n                                a: __binding_0,\n                                b: __binding_1,\n                                d: __binding_2,\n                            } => {\n                                {\n                                    ::ink_storage::traits::PackedLayout::clear_packed(__binding_0, __key);\n                                }\n                                {\n                                    ::ink_storage::traits::PackedLayout::clear_packed(__binding_1, __key);\n                                }\n                                {\n                                    ::ink_storage::traits::PackedLayout::clear_packed(__binding_2, __key);\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n        }\n        no_build\n    }\n}\n\n#[test]\nfn enum_works() {\n    synstructure::test_derive! {\n        packed_layout_derive {\n            enum MixedEnum {\n                A,\n                B(i32, [u8; 32]),\n                C { a: i32, b: (bool, i32) },\n            }\n        }\n        expands to {\n            const _: () = {\n                impl ::ink_storage::traits::PackedLayout for MixedEnum {\n                    fn pull_packed(&mut self, __key: &::ink_primitives::Key) {\n                        match self {\n                            MixedEnum::A => {}\n                            MixedEnum::B(__binding_0, __binding_1,) => {\n                                {\n                                    ::ink_storage::traits::PackedLayout::pull_packed(__binding_0, __key);\n                                }\n                                {\n                                    ::ink_storage::traits::PackedLayout::pull_packed(__binding_1, __key);\n                                }\n                            }\n                            MixedEnum::C {\n                                a: __binding_0,\n                                b: __binding_1,\n                            } => {\n                                {\n                                    ::ink_storage::traits::PackedLayout::pull_packed(__binding_0, __key);\n                                }\n                                {\n                                    ::ink_storage::traits::PackedLayout::pull_packed(__binding_1, __key);\n                                }\n                            }\n                        }\n                    }\n                    fn push_packed(&self, __key: &::ink_primitives::Key) {\n                        match self {\n                            MixedEnum::A => {}\n                            MixedEnum::B(__binding_0, __binding_1,) => {\n                                {\n                                    ::ink_storage::traits::PackedLayout::push_packed(__binding_0, __key);\n                                }\n                                {\n                                    ::ink_storage::traits::PackedLayout::push_packed(__binding_1, __key);\n                                }\n                            }\n                            MixedEnum::C {\n                                a: __binding_0,\n                                b: __binding_1,\n                            } => {\n                                {\n                                    ::ink_storage::traits::PackedLayout::push_packed(__binding_0, __key);\n                                }\n                                {\n                                    ::ink_storage::traits::PackedLayout::push_packed(__binding_1, __key);\n                                }\n                            }\n                        }\n                    }\n                    fn clear_packed(&self, __key: &::ink_primitives::Key) {\n                        match self {\n                            MixedEnum::A => {}\n                            MixedEnum::B(__binding_0, __binding_1,) => {\n                                {\n                                    ::ink_storage::traits::PackedLayout::clear_packed(__binding_0, __key);\n                                }\n                                {\n                                    ::ink_storage::traits::PackedLayout::clear_packed(__binding_1, __key);\n                                }\n                            }\n                            MixedEnum::C {\n                                a: __binding_0,\n                                b: __binding_1,\n                            } => {\n                                {\n                                    ::ink_storage::traits::PackedLayout::clear_packed(__binding_0, __key);\n                                }\n                                {\n                                    ::ink_storage::traits::PackedLayout::clear_packed(__binding_1, __key);\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n        }\n        no_build\n    }\n}\n\n#[test]\nfn generic_struct_works() {\n    synstructure::test_derive! {\n        packed_layout_derive {\n            struct GenericStruct<T1, T2> {\n                a: T1,\n                b: (T1, T2),\n            }\n        }\n        expands to {\n            const _: () = {\n                impl<T1, T2> ::ink_storage::traits::PackedLayout for GenericStruct<T1, T2>\n                where\n                    T1: ::ink_storage::traits::PackedLayout,\n                    T2: ::ink_storage::traits::PackedLayout\n                {\n                    fn pull_packed(&mut self, __key: &::ink_primitives::Key) {\n                        match self {\n                            GenericStruct {\n                                a: __binding_0,\n                                b: __binding_1,\n                            } => {\n                                {\n                                    ::ink_storage::traits::PackedLayout::pull_packed(__binding_0, __key);\n                                }\n                                {\n                                    ::ink_storage::traits::PackedLayout::pull_packed(__binding_1, __key);\n                                }\n                            }\n                        }\n                    }\n                    fn push_packed(&self, __key: &::ink_primitives::Key) {\n                        match self {\n                            GenericStruct {\n                                a: __binding_0,\n                                b: __binding_1,\n                            } => {\n                                {\n                                    ::ink_storage::traits::PackedLayout::push_packed(__binding_0, __key);\n                                }\n                                {\n                                    ::ink_storage::traits::PackedLayout::push_packed(__binding_1, __key);\n                                }\n                            }\n                        }\n                    }\n                    fn clear_packed(&self, __key: &::ink_primitives::Key) {\n                        match self {\n                            GenericStruct {\n                                a: __binding_0,\n                                b: __binding_1,\n                            } => {\n                                {\n                                    ::ink_storage::traits::PackedLayout::clear_packed(__binding_0, __key);\n                                }\n                                {\n                                    ::ink_storage::traits::PackedLayout::clear_packed(__binding_1, __key);\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n        }\n        no_build\n    }\n}\n\n#[test]\nfn generic_enum_works() {\n    synstructure::test_derive! {\n        packed_layout_derive {\n            enum GenericEnum<T1, T2> {\n                Tuple(T1, T2),\n                Named { a: T1, b: T2 },\n            }\n        }\n        expands to {\n            const _: () = {\n                impl<T1, T2> ::ink_storage::traits::PackedLayout for GenericEnum<T1, T2>\n                where\n                    T1: ::ink_storage::traits::PackedLayout,\n                    T2: ::ink_storage::traits::PackedLayout\n                {\n                    fn pull_packed(&mut self, __key: &::ink_primitives::Key) {\n                        match self {\n                            GenericEnum::Tuple(__binding_0, __binding_1,) => {\n                                {\n                                    ::ink_storage::traits::PackedLayout::pull_packed(__binding_0, __key);\n                                }\n                                {\n                                    ::ink_storage::traits::PackedLayout::pull_packed(__binding_1, __key);\n                                }\n                            }\n                            GenericEnum::Named {\n                                a: __binding_0,\n                                b: __binding_1,\n                            } => {\n                                {\n                                    ::ink_storage::traits::PackedLayout::pull_packed(__binding_0, __key);\n                                }\n                                {\n                                    ::ink_storage::traits::PackedLayout::pull_packed(__binding_1, __key);\n                                }\n                            }\n                        }\n                    }\n                    fn push_packed(&self, __key: &::ink_primitives::Key) {\n                        match self {\n                            GenericEnum::Tuple(__binding_0, __binding_1,) => {\n                                {\n                                    ::ink_storage::traits::PackedLayout::push_packed(__binding_0, __key);\n                                }\n                                {\n                                    ::ink_storage::traits::PackedLayout::push_packed(__binding_1, __key);\n                                }\n                            }\n                            GenericEnum::Named {\n                                a: __binding_0,\n                                b: __binding_1,\n                            } => {\n                                {\n                                    ::ink_storage::traits::PackedLayout::push_packed(__binding_0, __key);\n                                }\n                                {\n                                    ::ink_storage::traits::PackedLayout::push_packed(__binding_1, __key);\n                                }\n                            }\n                        }\n                    }\n                    fn clear_packed(&self, __key: &::ink_primitives::Key) {\n                        match self {\n                            GenericEnum::Tuple(__binding_0, __binding_1,) => {\n                                {\n                                    ::ink_storage::traits::PackedLayout::clear_packed(__binding_0, __key);\n                                }\n                                {\n                                    ::ink_storage::traits::PackedLayout::clear_packed(__binding_1, __key);\n                                }\n                            }\n                            GenericEnum::Named {\n                                a: __binding_0,\n                                b: __binding_1,\n                            } => {\n                                {\n                                    ::ink_storage::traits::PackedLayout::clear_packed(__binding_0, __key);\n                                }\n                                {\n                                    ::ink_storage::traits::PackedLayout::clear_packed(__binding_1, __key);\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n        }\n        no_build\n    }\n}\n"],["1032","// Copyright 2018-2021 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::storage_layout_derive;\n\n#[test]\nfn unit_struct_works() {\n    synstructure::test_derive! {\n        storage_layout_derive {\n            struct UnitStruct;\n        }\n        expands to {\n            const _: () = {\n                impl ::ink_storage::traits::StorageLayout for UnitStruct {\n                    fn layout(__key_ptr: &mut ::ink_storage::traits::KeyPtr) -> ::ink_metadata::layout::Layout {\n                        ::ink_metadata::layout::Layout::Struct(\n                            ::ink_metadata::layout::StructLayout::new(vec![])\n                        )\n                    }\n                }\n            };\n        }\n    }\n}\n\n#[test]\nfn tuple_struct_works() {\n    synstructure::test_derive! {\n        storage_layout_derive {\n            struct TupleStruct(bool, u32, i64);\n        }\n        expands to {\n            const _: () = {\n                impl ::ink_storage::traits::StorageLayout for TupleStruct {\n                    fn layout(__key_ptr: &mut ::ink_storage::traits::KeyPtr) -> ::ink_metadata::layout::Layout {\n                        ::ink_metadata::layout::Layout::Struct(\n                            ::ink_metadata::layout::StructLayout::new(vec![\n                                ::ink_metadata::layout::FieldLayout::new(\n                                    None,\n                                    <bool as ::ink_storage::traits::StorageLayout>::layout(__key_ptr),\n                                ),\n                                ::ink_metadata::layout::FieldLayout::new(\n                                    None,\n                                    <u32 as ::ink_storage::traits::StorageLayout>::layout(__key_ptr),\n                                ),\n                                ::ink_metadata::layout::FieldLayout::new(\n                                    None,\n                                    <i64 as ::ink_storage::traits::StorageLayout>::layout(__key_ptr),\n                                ),\n                            ])\n                        )\n                    }\n                }\n            };\n        }\n    }\n}\n\n#[test]\nfn named_fields_struct_works() {\n    synstructure::test_derive! {\n        storage_layout_derive {\n            struct NamedFieldsStruct {\n                a: bool,\n                b: u32,\n                c: i64,\n            }\n        }\n        expands to {\n            const _: () = {\n                impl ::ink_storage::traits::StorageLayout for NamedFieldsStruct {\n                    fn layout(__key_ptr: &mut ::ink_storage::traits::KeyPtr) -> ::ink_metadata::layout::Layout {\n                        ::ink_metadata::layout::Layout::Struct(\n                            ::ink_metadata::layout::StructLayout::new(vec![\n                                ::ink_metadata::layout::FieldLayout::new(\n                                    Some(\"a\"),\n                                    <bool as ::ink_storage::traits::StorageLayout>::layout(__key_ptr),\n                                ),\n                                ::ink_metadata::layout::FieldLayout::new(\n                                    Some(\"b\"),\n                                    <u32 as ::ink_storage::traits::StorageLayout>::layout(__key_ptr),\n                                ),\n                                ::ink_metadata::layout::FieldLayout::new(\n                                    Some(\"c\"),\n                                    <i64 as ::ink_storage::traits::StorageLayout>::layout(__key_ptr),\n                                ),\n                            ])\n                        )\n                    }\n                }\n            };\n        }\n    }\n}\n\n#[test]\nfn clike_enum_works() {\n    synstructure::test_derive! {\n        storage_layout_derive {\n            enum ClikeEnum { A, B, C }\n        }\n        expands to {\n            const _: () = {\n                impl ::ink_storage::traits::StorageLayout for ClikeEnum {\n                    fn layout(__key_ptr: &mut ::ink_storage::traits::KeyPtr) -> ::ink_metadata::layout::Layout {\n                        let dispatch_key = __key_ptr.advance_by(1);\n                        ::ink_metadata::layout::Layout::Enum(\n                            ::ink_metadata::layout::EnumLayout::new(\n                                ::ink_metadata::layout::LayoutKey::from(dispatch_key),\n                                vec![\n                                    {\n                                        let mut __variant_key_ptr = __key_ptr.clone();\n                                        let mut __key_ptr = &mut __variant_key_ptr;\n                                        (\n                                            ::ink_metadata::layout::Discriminant::from(0usize),\n                                            ::ink_metadata::layout::StructLayout::new(vec![]),\n                                        )\n                                    },\n                                    {\n                                        let mut __variant_key_ptr = __key_ptr.clone();\n                                        let mut __key_ptr = &mut __variant_key_ptr;\n                                        (\n                                            ::ink_metadata::layout::Discriminant::from(1usize),\n                                            ::ink_metadata::layout::StructLayout::new(vec![]),\n                                        )\n                                    },\n                                    {\n                                        let mut __variant_key_ptr = __key_ptr.clone();\n                                        let mut __key_ptr = &mut __variant_key_ptr;\n                                        (\n                                            ::ink_metadata::layout::Discriminant::from(2usize),\n                                            ::ink_metadata::layout::StructLayout::new(vec![]),\n                                        )\n                                    },\n                                ]\n                            )\n                        )\n                    }\n                }\n            };\n        }\n    }\n}\n\n#[test]\nfn mixed_enum_works() {\n    synstructure::test_derive! {\n        storage_layout_derive {\n            enum MixedEnum {\n                A,\n                B(bool, u32, i64),\n                C{\n                    a: bool,\n                    b: u32,\n                    c: i64,\n                }\n            }\n        }\n        expands to {\n            const _: () = {\n                impl ::ink_storage::traits::StorageLayout for MixedEnum {\n                    fn layout(__key_ptr: &mut ::ink_storage::traits::KeyPtr) -> ::ink_metadata::layout::Layout {\n                        let dispatch_key = __key_ptr.advance_by(1);\n                        ::ink_metadata::layout::Layout::Enum(\n                            ::ink_metadata::layout::EnumLayout::new(\n                                ::ink_metadata::layout::LayoutKey::from(dispatch_key),\n                                vec![\n                                    {\n                                        let mut __variant_key_ptr = __key_ptr.clone();\n                                        let mut __key_ptr = &mut __variant_key_ptr;\n                                        (\n                                            ::ink_metadata::layout::Discriminant::from(0usize),\n                                            ::ink_metadata::layout::StructLayout::new(vec![]),\n                                        )\n                                    },\n                                    {\n                                        let mut __variant_key_ptr = __key_ptr.clone();\n                                        let mut __key_ptr = &mut __variant_key_ptr;\n                                        (\n                                            ::ink_metadata::layout::Discriminant::from(1usize),\n                                            ::ink_metadata::layout::StructLayout::new(vec![\n                                                ::ink_metadata::layout::FieldLayout::new(\n                                                    None,\n                                                    <bool as ::ink_storage::traits::StorageLayout>::layout(__key_ptr),\n                                                ),\n                                                ::ink_metadata::layout::FieldLayout::new(\n                                                    None,\n                                                    <u32 as ::ink_storage::traits::StorageLayout>::layout(__key_ptr),\n                                                ),\n                                                ::ink_metadata::layout::FieldLayout::new(\n                                                    None,\n                                                    <i64 as ::ink_storage::traits::StorageLayout>::layout(__key_ptr),\n                                                ),\n                                            ]),\n                                        )\n                                    },\n                                    {\n                                        let mut __variant_key_ptr = __key_ptr.clone();\n                                        let mut __key_ptr = &mut __variant_key_ptr;\n                                        (\n                                            ::ink_metadata::layout::Discriminant::from(2usize),\n                                            ::ink_metadata::layout::StructLayout::new(vec![\n                                                ::ink_metadata::layout::FieldLayout::new(\n                                                    Some(\"a\"),\n                                                    <bool as ::ink_storage::traits::StorageLayout>::layout(__key_ptr),\n                                                ),\n                                                ::ink_metadata::layout::FieldLayout::new(\n                                                    Some(\"b\"),\n                                                    <u32 as ::ink_storage::traits::StorageLayout>::layout(__key_ptr),\n                                                ),\n                                                ::ink_metadata::layout::FieldLayout::new(\n                                                    Some(\"c\"),\n                                                    <i64 as ::ink_storage::traits::StorageLayout>::layout(__key_ptr),\n                                                ),\n                                            ]),\n                                        )\n                                    },\n                                ]\n                            )\n                        )\n                    }\n                }\n            };\n        }\n    }\n}\n"],["1033","//! \"Diff\"ing iterators for caching elements to sequential collections without requiring the new\n//! elements' iterator to be `Clone`.\n//!\n//! - [**Diff**](./enum.Diff.html) (produced by the [**diff_with**](./fn.diff_with.html) function)\n//! describes the difference between two non-`Clone` iterators `I` and `J` after breaking ASAP from\n//! a lock-step comparison.\n\nuse crate::free::put_back;\nuse crate::structs::PutBack;\n\n/// A type returned by the [`diff_with`](./fn.diff_with.html) function.\n///\n/// `Diff` represents the way in which the elements yielded by the iterator `I` differ to some\n/// iterator `J`.\npub enum Diff<I, J>\n    where I: Iterator,\n          J: Iterator\n{\n    /// The index of the first non-matching element along with both iterator's remaining elements\n    /// starting with the first mis-match.\n    FirstMismatch(usize, PutBack<I>, PutBack<J>),\n    /// The total number of elements that were in `J` along with the remaining elements of `I`.\n    Shorter(usize, PutBack<I>),\n    /// The total number of elements that were in `I` along with the remaining elements of `J`.\n    Longer(usize, PutBack<J>),\n}\n\n/// Compares every element yielded by both `i` and `j` with the given function in lock-step and\n/// returns a `Diff` which describes how `j` differs from `i`.\n///\n/// If the number of elements yielded by `j` is less than the number of elements yielded by `i`,\n/// the number of `j` elements yielded will be returned along with `i`'s remaining elements as\n/// `Diff::Shorter`.\n///\n/// If the two elements of a step differ, the index of those elements along with the remaining\n/// elements of both `i` and `j` are returned as `Diff::FirstMismatch`.\n///\n/// If `i` becomes exhausted before `j` becomes exhausted, the number of elements in `i` along with\n/// the remaining `j` elements will be returned as `Diff::Longer`.\npub fn diff_with<I, J, F>(i: I, j: J, is_equal: F)\n    -> Option<Diff<I::IntoIter, J::IntoIter>>\n    where I: IntoIterator,\n          J: IntoIterator,\n          F: Fn(&I::Item, &J::Item) -> bool\n{\n    let mut i = i.into_iter();\n    let mut j = j.into_iter();\n    let mut idx = 0;\n    while let Some(i_elem) = i.next() {\n        match j.next() {\n            None => return Some(Diff::Shorter(idx, put_back(i).with_value(i_elem))),\n            Some(j_elem) => if !is_equal(&i_elem, &j_elem) {\n                let remaining_i = put_back(i).with_value(i_elem);\n                let remaining_j = put_back(j).with_value(j_elem);\n                return Some(Diff::FirstMismatch(idx, remaining_i, remaining_j));\n            },\n        }\n        idx += 1;\n    }\n    j.next().map(|j_elem| Diff::Longer(idx, put_back(j).with_value(j_elem)))\n}\n"],["1034","use std::iter::Fuse;\nuse crate::size_hint;\n\n/// An iterator adaptor that pads a sequence to a minimum length by filling\n/// missing elements using a closure.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.pad_using()`](../trait.Itertools.html#method.pad_using) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct PadUsing<I, F> {\n    iter: Fuse<I>,\n    min: usize,\n    pos: usize,\n    filler: F,\n}\n\n/// Create a new **PadUsing** iterator.\npub fn pad_using<I, F>(iter: I, min: usize, filler: F) -> PadUsing<I, F>\n    where I: Iterator,\n          F: FnMut(usize) -> I::Item\n{\n    PadUsing {\n        iter: iter.fuse(),\n        min,\n        pos: 0,\n        filler,\n    }\n}\n\nimpl<I, F> Iterator for PadUsing<I, F>\n    where I: Iterator,\n          F: FnMut(usize) -> I::Item\n{\n    type Item = I::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.iter.next() {\n            None => {\n                if self.pos < self.min {\n                    let e = Some((self.filler)(self.pos));\n                    self.pos += 1;\n                    e\n                } else {\n                    None\n                }\n            },\n            e => {\n                self.pos += 1;\n                e\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let tail = self.min.saturating_sub(self.pos);\n        size_hint::max(self.iter.size_hint(), (tail, Some(tail)))\n    }\n}\n\nimpl<I, F> DoubleEndedIterator for PadUsing<I, F>\n    where I: DoubleEndedIterator + ExactSizeIterator,\n          F: FnMut(usize) -> I::Item\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if self.min == 0 {\n            self.iter.next_back()\n        } else if self.iter.len() >= self.min {\n            self.min -= 1;\n            self.iter.next_back()\n        } else {\n            self.min -= 1;\n            Some((self.filler)(self.min))\n        }\n    }\n}\n\nimpl<I, F> ExactSizeIterator for PadUsing<I, F>\n    where I: ExactSizeIterator,\n          F: FnMut(usize) -> I::Item\n{}\n"],["1035","#![cfg(feature = \"use_std\")]\n\nuse std::collections::HashMap;\nuse std::hash::Hash;\nuse std::iter::Iterator;\n\n/// Return a `HashMap` of keys mapped to a list of their corresponding values.\n///\n/// See [`.into_group_map()`](../trait.Itertools.html#method.into_group_map)\n/// for more information.\npub fn into_group_map<I, K, V>(iter: I) -> HashMap<K, Vec<V>>\n    where I: Iterator<Item=(K, V)>,\n          K: Hash + Eq,\n{\n    let mut lookup = HashMap::new();\n\n    iter.for_each(|(key, val)| {\n        lookup.entry(key).or_insert_with(Vec::new).push(val);\n    });\n\n    lookup\n}\n\npub fn into_group_map_by<I, K, V>(iter: I, f: impl Fn(&V) -> K) -> HashMap<K, Vec<V>>\n    where\n        I: Iterator<Item=V>,\n        K: Hash + Eq,\n{\n    into_group_map(\n        iter.map(|v| (f(&v), v))\n    )\n}\n"],["1036","\nuse std::collections::HashMap;\nuse std::collections::hash_map::{Entry};\nuse std::hash::Hash;\nuse std::fmt;\n\n/// An iterator adapter to filter out duplicate elements.\n///\n/// See [`.unique_by()`](../trait.Itertools.html#method.unique) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct UniqueBy<I: Iterator, V, F> {\n    iter: I,\n    // Use a hashmap for the entry API\n    used: HashMap<V, ()>,\n    f: F,\n}\n\nimpl<I, V, F> fmt::Debug for UniqueBy<I, V, F>\n    where I: Iterator + fmt::Debug,\n          V: fmt::Debug + Hash + Eq,\n{\n    debug_fmt_fields!(UniqueBy, iter, used);\n}\n\n/// Create a new `UniqueBy` iterator.\npub fn unique_by<I, V, F>(iter: I, f: F) -> UniqueBy<I, V, F>\n    where V: Eq + Hash,\n          F: FnMut(&I::Item) -> V,\n          I: Iterator,\n{\n    UniqueBy {\n        iter,\n        used: HashMap::new(),\n        f,\n    }\n}\n\n// count the number of new unique keys in iterable (`used` is the set already seen)\nfn count_new_keys<I, K>(mut used: HashMap<K, ()>, iterable: I) -> usize\n    where I: IntoIterator<Item=K>,\n          K: Hash + Eq,\n{\n    let iter = iterable.into_iter();\n    let current_used = used.len();\n    used.extend(iter.map(|key| (key, ())));\n    used.len() - current_used\n}\n\nimpl<I, V, F> Iterator for UniqueBy<I, V, F>\n    where I: Iterator,\n          V: Eq + Hash,\n          F: FnMut(&I::Item) -> V\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.next() {\n            let key = (self.f)(&v);\n            if self.used.insert(key, ()).is_none() {\n                return Some(v);\n            }\n        }\n        None\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, hi) = self.iter.size_hint();\n        ((low > 0 && self.used.is_empty()) as usize, hi)\n    }\n\n    fn count(self) -> usize {\n        let mut key_f = self.f;\n        count_new_keys(self.used, self.iter.map(move |elt| key_f(&elt)))\n    }\n}\n\nimpl<I, V, F> DoubleEndedIterator for UniqueBy<I, V, F>\n    where I: DoubleEndedIterator,\n          V: Eq + Hash,\n          F: FnMut(&I::Item) -> V\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.next_back() {\n            let key = (self.f)(&v);\n            if self.used.insert(key, ()).is_none() {\n                return Some(v);\n            }\n        }\n        None\n    }\n}\n\nimpl<I> Iterator for Unique<I>\n    where I: Iterator,\n          I::Item: Eq + Hash + Clone\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.iter.next() {\n            if let Entry::Vacant(entry) = self.iter.used.entry(v) {\n                let elt = entry.key().clone();\n                entry.insert(());\n                return Some(elt);\n            }\n        }\n        None\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, hi) = self.iter.iter.size_hint();\n        ((low > 0 && self.iter.used.is_empty()) as usize, hi)\n    }\n\n    fn count(self) -> usize {\n        count_new_keys(self.iter.used, self.iter.iter)\n    }\n}\n\nimpl<I> DoubleEndedIterator for Unique<I>\n    where I: DoubleEndedIterator,\n          I::Item: Eq + Hash + Clone\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.iter.next_back() {\n            if let Entry::Vacant(entry) = self.iter.used.entry(v) {\n                let elt = entry.key().clone();\n                entry.insert(());\n                return Some(elt);\n            }\n        }\n        None\n    }\n}\n\n/// An iterator adapter to filter out duplicate elements.\n///\n/// See [`.unique()`](../trait.Itertools.html#method.unique) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Unique<I: Iterator> {\n    iter: UniqueBy<I, I::Item, ()>,\n}\n\nimpl<I> fmt::Debug for Unique<I>\n    where I: Iterator + fmt::Debug,\n          I::Item: Hash + Eq + fmt::Debug,\n{\n    debug_fmt_fields!(Unique, iter);\n}\n\npub fn unique<I>(iter: I) -> Unique<I>\n    where I: Iterator,\n          I::Item: Eq + Hash,\n{\n    Unique {\n        iter: UniqueBy {\n            iter,\n            used: HashMap::new(),\n            f: (),\n        }\n    }\n}\n"],["1037","\n/// An iterator that produces *n* repetitions of an element.\n///\n/// See [`repeat_n()`](../fn.repeat_n.html) for more information.\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n#[derive(Clone, Debug)]\npub struct RepeatN<A> {\n    elt: Option<A>,\n    n: usize,\n}\n\n/// Create an iterator that produces `n` repetitions of `element`.\npub fn repeat_n<A>(element: A, n: usize) -> RepeatN<A>\n    where A: Clone,\n{\n    if n == 0 {\n        RepeatN { elt: None, n, }\n    } else {\n        RepeatN { elt: Some(element), n, }\n    }\n}\n\nimpl<A> Iterator for RepeatN<A>\n    where A: Clone\n{\n    type Item = A;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.n > 1 {\n            self.n -= 1;\n            self.elt.as_ref().cloned()\n        } else {\n            self.n = 0;\n            self.elt.take()\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (self.n, Some(self.n))\n    }\n}\n\nimpl<A> DoubleEndedIterator for RepeatN<A>\n    where A: Clone\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.next()\n    }\n}\n\nimpl<A> ExactSizeIterator for RepeatN<A>\n    where A: Clone\n{}\n"],["1038","\nmacro_rules! impl_cons_iter(\n    ($_A:ident, $_B:ident, ) => (); // stop\n\n    ($A:ident, $($B:ident,)*) => (\n        impl_cons_iter!($($B,)*);\n        #[allow(non_snake_case)]\n        impl<X, Iter, $($B),*> Iterator for ConsTuples<Iter, (($($B,)*), X)>\n            where Iter: Iterator<Item = (($($B,)*), X)>,\n        {\n            type Item = ($($B,)* X, );\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next().map(|(($($B,)*), x)| ($($B,)* x, ))\n            }\n\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n            fn fold<Acc, Fold>(self, accum: Acc, mut f: Fold) -> Acc\n                where Fold: FnMut(Acc, Self::Item) -> Acc,\n            {\n                self.iter.fold(accum, move |acc, (($($B,)*), x)| f(acc, ($($B,)* x, )))\n            }\n        }\n\n        #[allow(non_snake_case)]\n        impl<X, Iter, $($B),*> DoubleEndedIterator for ConsTuples<Iter, (($($B,)*), X)>\n            where Iter: DoubleEndedIterator<Item = (($($B,)*), X)>,\n        {\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next().map(|(($($B,)*), x)| ($($B,)* x, ))\n            }\n        }\n\n    );\n);\n\nimpl_cons_iter!(A, B, C, D, E, F, G, H, I, J, K, L,);\n\n/// An iterator that maps an iterator of tuples like\n/// `((A, B), C)` to an iterator of `(A, B, C)`.\n///\n/// Used by the `iproduct!()` macro.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct ConsTuples<I, J>\n    where I: Iterator<Item=J>,\n{\n    iter: I,\n}\n\nimpl<I, J> Clone for ConsTuples<I, J>\n    where I: Clone + Iterator<Item=J>,\n{\n    clone_fields!(iter);\n}\n\n/// Create an iterator that maps for example iterators of\n/// `((A, B), C)` to `(A, B, C)`.\npub fn cons_tuples<I, J>(iterable: I) -> ConsTuples<I::IntoIter, J>\n    where I: IntoIterator<Item=J>\n{\n    ConsTuples { iter: iterable.into_iter() }\n}\n"],["1039","use std::fmt;\n\nuse super::lazy_buffer::LazyBuffer;\nuse alloc::vec::Vec;\n\n/// An iterator to iterate through all the `k`-length combinations in an iterator.\n///\n/// See [`.combinations()`](../trait.Itertools.html#method.combinations) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Combinations<I: Iterator> {\n    indices: Vec<usize>,\n    pool: LazyBuffer<I>,\n    first: bool,\n}\n\nimpl<I> Clone for Combinations<I>\n    where I: Clone + Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(indices, pool, first);\n}\n\nimpl<I> fmt::Debug for Combinations<I>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Combinations, indices, pool, first);\n}\n\n/// Create a new `Combinations` from a clonable iterator.\npub fn combinations<I>(iter: I, k: usize) -> Combinations<I>\n    where I: Iterator\n{\n    let mut pool = LazyBuffer::new(iter);\n    pool.prefill(k);\n\n    Combinations {\n        indices: (0..k).collect(),\n        pool,\n        first: true,\n    }\n}\n\nimpl<I: Iterator> Combinations<I> {\n    /// Returns the length of a combination produced by this iterator.\n    #[inline]\n    pub fn k(&self) -> usize { self.indices.len() }\n\n    /// Returns the (current) length of the pool from which combination elements are\n    /// selected. This value can change between invocations of [`next`].\n    ///\n    /// [`next`]: #method.next\n    #[inline]\n    pub fn n(&self) -> usize { self.pool.len() }\n\n    /// Returns a reference to the source iterator.\n    #[inline]\n    pub(crate) fn src(&self) -> &I { &self.pool.it }\n\n    /// Resets this `Combinations` back to an initial state for combinations of length\n    /// `k` over the same pool data source. If `k` is larger than the current length\n    /// of the data pool an attempt is made to prefill the pool so that it holds `k`\n    /// elements.\n    pub(crate) fn reset(&mut self, k: usize) {\n        self.first = true;\n\n        if k < self.indices.len() {\n            self.indices.truncate(k);\n            for i in 0..k {\n                self.indices[i] = i;\n            }\n\n        } else {\n            for i in 0..self.indices.len() {\n                self.indices[i] = i;\n            }\n            self.indices.extend(self.indices.len()..k);\n            self.pool.prefill(k);\n        }\n    }\n}\n\nimpl<I> Iterator for Combinations<I>\n    where I: Iterator,\n          I::Item: Clone\n{\n    type Item = Vec<I::Item>;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.first {\n            if self.k() > self.n() {\n                return None;\n            }\n            self.first = false;\n        } else if self.indices.is_empty() {\n            return None;\n        } else {\n            // Scan from the end, looking for an index to increment\n            let mut i: usize = self.indices.len() - 1;\n\n            // Check if we need to consume more from the iterator\n            if self.indices[i] == self.pool.len() - 1 {\n                self.pool.get_next(); // may change pool size\n            }\n\n            while self.indices[i] == i + self.pool.len() - self.indices.len() {\n                if i > 0 {\n                    i -= 1;\n                } else {\n                    // Reached the last combination\n                    return None;\n                }\n            }\n\n            // Increment index, and reset the ones to its right\n            self.indices[i] += 1;\n            for j in i+1..self.indices.len() {\n                self.indices[j] = self.indices[j - 1] + 1;\n            }\n        }\n\n        // Create result vector based on the indices\n        Some(self.indices.iter().map(|i| self.pool[*i].clone()).collect())\n    }\n}\n"],["1040","use std::cmp::Ordering;\nuse std::iter::Fuse;\nuse std::fmt;\n\nuse super::adaptors::{PutBack, put_back};\nuse crate::either_or_both::EitherOrBoth;\n\n/// Return an iterator adaptor that merge-joins items from the two base iterators in ascending order.\n///\n/// See [`.merge_join_by()`](trait.Itertools.html#method.merge_join_by) for more information.\npub fn merge_join_by<I, J, F>(left: I, right: J, cmp_fn: F)\n    -> MergeJoinBy<I::IntoIter, J::IntoIter, F>\n    where I: IntoIterator,\n          J: IntoIterator,\n          F: FnMut(&I::Item, &J::Item) -> Ordering\n{\n    MergeJoinBy {\n        left: put_back(left.into_iter().fuse()),\n        right: put_back(right.into_iter().fuse()),\n        cmp_fn,\n    }\n}\n\n/// An iterator adaptor that merge-joins items from the two base iterators in ascending order.\n///\n/// See [`.merge_join_by()`](../trait.Itertools.html#method.merge_join_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MergeJoinBy<I: Iterator, J: Iterator, F> {\n    left: PutBack<Fuse<I>>,\n    right: PutBack<Fuse<J>>,\n    cmp_fn: F\n}\n\nimpl<I, J, F> Clone for MergeJoinBy<I, J, F>\n    where I: Iterator,\n          J: Iterator,\n          PutBack<Fuse<I>>: Clone,\n          PutBack<Fuse<J>>: Clone,\n          F: Clone,\n{\n    clone_fields!(left, right, cmp_fn);\n}\n\nimpl<I, J, F> fmt::Debug for MergeJoinBy<I, J, F>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n          J: Iterator + fmt::Debug,\n          J::Item: fmt::Debug,\n{\n    debug_fmt_fields!(MergeJoinBy, left, right);\n}\n\nimpl<I, J, F> Iterator for MergeJoinBy<I, J, F>\n    where I: Iterator,\n          J: Iterator,\n          F: FnMut(&I::Item, &J::Item) -> Ordering\n{\n    type Item = EitherOrBoth<I::Item, J::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match (self.left.next(), self.right.next()) {\n            (None, None) => None,\n            (Some(left), None) =>\n                Some(EitherOrBoth::Left(left)),\n            (None, Some(right)) =>\n                Some(EitherOrBoth::Right(right)),\n            (Some(left), Some(right)) => {\n                match (self.cmp_fn)(&left, &right) {\n                    Ordering::Equal =>\n                        Some(EitherOrBoth::Both(left, right)),\n                    Ordering::Less => {\n                        self.right.put_back(right);\n                        Some(EitherOrBoth::Left(left))\n                    },\n                    Ordering::Greater => {\n                        self.left.put_back(left);\n                        Some(EitherOrBoth::Right(right))\n                    }\n                }\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (a_lower, a_upper) = self.left.size_hint();\n        let (b_lower, b_upper) = self.right.size_hint();\n\n        let lower = ::std::cmp::max(a_lower, b_lower);\n\n        let upper = match (a_upper, b_upper) {\n            (Some(x), Some(y)) => x.checked_add(y),\n            _ => None,\n        };\n\n        (lower, upper)\n    }\n\n    fn count(mut self) -> usize {\n        let mut count = 0;\n        loop {\n            match (self.left.next(), self.right.next()) {\n                (None, None) => break count,\n                (Some(_left), None) => break count + 1 + self.left.into_parts().1.count(),\n                (None, Some(_right)) => break count + 1 + self.right.into_parts().1.count(),\n                (Some(left), Some(right)) => {\n                    count += 1;\n                    match (self.cmp_fn)(&left, &right) {\n                        Ordering::Equal => {}\n                        Ordering::Less => self.right.put_back(right),\n                        Ordering::Greater => self.left.put_back(left),\n                    }\n                }\n            }\n        }\n    }\n\n    fn last(mut self) -> Option<Self::Item> {\n        let mut previous_element = None;\n        loop {\n            match (self.left.next(), self.right.next()) {\n                (None, None) => break previous_element,\n                (Some(left), None) => {\n                    break Some(EitherOrBoth::Left(\n                        self.left.into_parts().1.last().unwrap_or(left),\n                    ))\n                }\n                (None, Some(right)) => {\n                    break Some(EitherOrBoth::Right(\n                        self.right.into_parts().1.last().unwrap_or(right),\n                    ))\n                }\n                (Some(left), Some(right)) => {\n                    previous_element = match (self.cmp_fn)(&left, &right) {\n                        Ordering::Equal => Some(EitherOrBoth::Both(left, right)),\n                        Ordering::Less => {\n                            self.right.put_back(right);\n                            Some(EitherOrBoth::Left(left))\n                        }\n                        Ordering::Greater => {\n                            self.left.put_back(left);\n                            Some(EitherOrBoth::Right(right))\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n        loop {\n            if n == 0 {\n                break self.next();\n            }\n            n -= 1;\n            match (self.left.next(), self.right.next()) {\n                (None, None) => break None,\n                (Some(_left), None) => break self.left.nth(n).map(EitherOrBoth::Left),\n                (None, Some(_right)) => break self.right.nth(n).map(EitherOrBoth::Right),\n                (Some(left), Some(right)) => match (self.cmp_fn)(&left, &right) {\n                    Ordering::Equal => {}\n                    Ordering::Less => self.right.put_back(right),\n                    Ordering::Greater => self.left.put_back(left),\n                },\n            }\n        }\n    }\n}\n"],["1041","//! Free functions that create iterator adaptors or call iterator methods.\n//!\n//! The benefit of free functions is that they accept any `IntoIterator` as\n//! argument, so the resulting code may be easier to read.\n\n#[cfg(feature = \"use_alloc\")]\nuse std::fmt::Display;\nuse std::iter::{self, Zip};\n#[cfg(feature = \"use_alloc\")]\ntype VecIntoIter<T> = alloc::vec::IntoIter<T>;\n\n#[cfg(feature = \"use_alloc\")]\nuse alloc::{\n    string::String,\n};\n\n#[cfg(feature = \"use_alloc\")]\nuse crate::Itertools;\n\npub use crate::adaptors::{\n    interleave,\n    merge,\n    put_back,\n};\n#[cfg(feature = \"use_alloc\")]\npub use crate::put_back_n_impl::put_back_n;\n#[cfg(feature = \"use_alloc\")]\npub use crate::multipeek_impl::multipeek;\n#[cfg(feature = \"use_alloc\")]\npub use crate::peek_nth::peek_nth;\n#[cfg(feature = \"use_alloc\")]\npub use crate::kmerge_impl::kmerge;\npub use crate::zip_eq_impl::zip_eq;\npub use crate::merge_join::merge_join_by;\n#[cfg(feature = \"use_alloc\")]\npub use crate::rciter_impl::rciter;\n\n/// Iterate `iterable` with a running index.\n///\n/// `IntoIterator` enabled version of `.enumerate()`.\n///\n/// ```\n/// use itertools::enumerate;\n///\n/// for (i, elt) in enumerate(&[1, 2, 3]) {\n///     /* loop body */\n/// }\n/// ```\npub fn enumerate<I>(iterable: I) -> iter::Enumerate<I::IntoIter>\n    where I: IntoIterator\n{\n    iterable.into_iter().enumerate()\n}\n\n/// Iterate `iterable` in reverse.\n///\n/// `IntoIterator` enabled version of `.rev()`.\n///\n/// ```\n/// use itertools::rev;\n///\n/// for elt in rev(&[1, 2, 3]) {\n///     /* loop body */\n/// }\n/// ```\npub fn rev<I>(iterable: I) -> iter::Rev<I::IntoIter>\n    where I: IntoIterator,\n          I::IntoIter: DoubleEndedIterator\n{\n    iterable.into_iter().rev()\n}\n\n/// Iterate `i` and `j` in lock step.\n///\n/// `IntoIterator` enabled version of `i.zip(j)`.\n///\n/// ```\n/// use itertools::zip;\n///\n/// let data = [1, 2, 3, 4, 5];\n/// for (a, b) in zip(&data, &data[1..]) {\n///     /* loop body */\n/// }\n/// ```\npub fn zip<I, J>(i: I, j: J) -> Zip<I::IntoIter, J::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator\n{\n    i.into_iter().zip(j)\n}\n\n/// Create an iterator that first iterates `i` and then `j`.\n///\n/// `IntoIterator` enabled version of `i.chain(j)`.\n///\n/// ```\n/// use itertools::chain;\n///\n/// for elt in chain(&[1, 2, 3], &[4]) {\n///     /* loop body */\n/// }\n/// ```\npub fn chain<I, J>(i: I, j: J) -> iter::Chain<<I as IntoIterator>::IntoIter, <J as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>\n{\n    i.into_iter().chain(j)\n}\n\n/// Create an iterator that clones each element from &T to T\n///\n/// `IntoIterator` enabled version of `i.cloned()`.\n///\n/// ```\n/// use itertools::cloned;\n///\n/// assert_eq!(cloned(b\"abc\").next(), Some(b'a'));\n/// ```\npub fn cloned<'a, I, T: 'a>(iterable: I) -> iter::Cloned<I::IntoIter>\n    where I: IntoIterator<Item=&'a T>,\n          T: Clone,\n{\n    iterable.into_iter().cloned()\n}\n\n/// Perform a fold operation over the iterable.\n///\n/// `IntoIterator` enabled version of `i.fold(init, f)`\n///\n/// ```\n/// use itertools::fold;\n///\n/// assert_eq!(fold(&[1., 2., 3.], 0., |a, &b| f32::max(a, b)), 3.);\n/// ```\npub fn fold<I, B, F>(iterable: I, init: B, f: F) -> B\n    where I: IntoIterator,\n          F: FnMut(B, I::Item) -> B\n{\n    iterable.into_iter().fold(init, f)\n}\n\n/// Test whether the predicate holds for all elements in the iterable.\n///\n/// `IntoIterator` enabled version of `i.all(f)`\n///\n/// ```\n/// use itertools::all;\n///\n/// assert!(all(&[1, 2, 3], |elt| *elt > 0));\n/// ```\npub fn all<I, F>(iterable: I, f: F) -> bool\n    where I: IntoIterator,\n          F: FnMut(I::Item) -> bool\n{\n    iterable.into_iter().all(f)\n}\n\n/// Test whether the predicate holds for any elements in the iterable.\n///\n/// `IntoIterator` enabled version of `i.any(f)`\n///\n/// ```\n/// use itertools::any;\n///\n/// assert!(any(&[0, -1, 2], |elt| *elt > 0));\n/// ```\npub fn any<I, F>(iterable: I, f: F) -> bool\n    where I: IntoIterator,\n          F: FnMut(I::Item) -> bool\n{\n    iterable.into_iter().any(f)\n}\n\n/// Return the maximum value of the iterable.\n///\n/// `IntoIterator` enabled version of `i.max()`.\n///\n/// ```\n/// use itertools::max;\n///\n/// assert_eq!(max(0..10), Some(9));\n/// ```\npub fn max<I>(iterable: I) -> Option<I::Item>\n    where I: IntoIterator,\n          I::Item: Ord\n{\n    iterable.into_iter().max()\n}\n\n/// Return the minimum value of the iterable.\n///\n/// `IntoIterator` enabled version of `i.min()`.\n///\n/// ```\n/// use itertools::min;\n///\n/// assert_eq!(min(0..10), Some(0));\n/// ```\npub fn min<I>(iterable: I) -> Option<I::Item>\n    where I: IntoIterator,\n          I::Item: Ord\n{\n    iterable.into_iter().min()\n}\n\n\n/// Combine all iterator elements into one String, seperated by `sep`.\n///\n/// `IntoIterator` enabled version of `iterable.join(sep)`.\n///\n/// ```\n/// use itertools::join;\n///\n/// assert_eq!(join(&[1, 2, 3], \", \"), \"1, 2, 3\");\n/// ```\n#[cfg(feature = \"use_alloc\")]\npub fn join<I>(iterable: I, sep: &str) -> String\n    where I: IntoIterator,\n          I::Item: Display\n{\n    iterable.into_iter().join(sep)\n}\n\n/// Sort all iterator elements into a new iterator in ascending order.\n///\n/// `IntoIterator` enabled version of [`iterable.sorted()`][1].\n///\n/// [1]: trait.Itertools.html#method.sorted\n///\n/// ```\n/// use itertools::sorted;\n/// use itertools::assert_equal;\n///\n/// assert_equal(sorted(\"rust\".chars()), \"rstu\".chars());\n/// ```\n#[cfg(feature = \"use_alloc\")]\npub fn sorted<I>(iterable: I) -> VecIntoIter<I::Item>\n    where I: IntoIterator,\n          I::Item: Ord\n{\n    iterable.into_iter().sorted()\n}\n\n"],["1042","use crate::Itertools;\n\n/// Combine all an iterator's elements into one element by using `Extend`.\n///\n/// `IntoIterator`-enabled version of `.concat()`\n///\n/// This combinator will extend the first item with each of the rest of the\n/// items of the iterator. If the iterator is empty, the default value of\n/// `I::Item` is returned.\n///\n/// ```rust\n/// use itertools::concat;\n/// \n/// let input = vec![vec![1], vec![2, 3], vec![4, 5, 6]];\n/// assert_eq!(concat(input), vec![1, 2, 3, 4, 5, 6]);\n/// ```\npub fn concat<I>(iterable: I) -> I::Item\n    where I: IntoIterator,\n          I::Item: Extend<<<I as IntoIterator>::Item as IntoIterator>::Item> + IntoIterator + Default\n{\n    iterable.into_iter().fold1(|mut a, b| { a.extend(b); a }).unwrap_or_else(<_>::default)\n}\n"],["1043","use std::fmt;\nuse std::usize;\nuse alloc::vec::Vec;\n\nuse super::combinations::{Combinations, combinations};\nuse super::size_hint;\n\n/// An iterator to iterate through the powerset of the elements from an iterator.\n///\n/// See [`.powerset()`](../trait.Itertools.html#method.powerset) for more\n/// information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Powerset<I: Iterator> {\n    combs: Combinations<I>,\n    // Iterator `position` (equal to count of yielded elements).\n    pos: usize,\n}\n\nimpl<I> Clone for Powerset<I>\n    where I: Clone + Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(combs, pos);\n}\n\nimpl<I> fmt::Debug for Powerset<I>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Powerset, combs, pos);\n}\n\n/// Create a new `Powerset` from a clonable iterator.\npub fn powerset<I>(src: I) -> Powerset<I>\n    where I: Iterator,\n          I::Item: Clone,\n{\n    Powerset {\n        combs: combinations(src, 0),\n        pos: 0,\n    }\n}\n\nimpl<I> Iterator for Powerset<I>\n    where\n        I: Iterator,\n        I::Item: Clone,\n{\n    type Item = Vec<I::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if let Some(elt) = self.combs.next() {\n            self.pos = self.pos.saturating_add(1);\n            Some(elt)\n        } else if self.combs.k() < self.combs.n()\n            || self.combs.k() == 0\n        {\n            self.combs.reset(self.combs.k() + 1);\n            self.combs.next().map(|elt| {\n                self.pos = self.pos.saturating_add(1);\n                elt\n            })\n        } else {\n            None\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // Total bounds for source iterator.\n        let src_total = size_hint::add_scalar(self.combs.src().size_hint(), self.combs.n());\n\n        // Total bounds for self ( length(powerset(set) == 2 ^ length(set) )\n        let self_total = size_hint::pow_scalar_base(2, src_total);\n\n        if self.pos < usize::MAX {\n            // Subtract count of elements already yielded from total.\n            size_hint::sub_scalar(self_total, self.pos)\n        } else {\n            // Fallback: self.pos is saturated and no longer reliable.\n            (0, self_total.1)\n        }\n    }\n}\n"],["1044","use alloc::vec::Vec;\nuse std::fmt;\nuse std::iter::once;\n\nuse super::lazy_buffer::LazyBuffer;\n\n/// An iterator adaptor that iterates through all the `k`-permutations of the\n/// elements from an iterator.\n///\n/// See [`.permutations()`](../trait.Itertools.html#method.permutations) for\n/// more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Permutations<I: Iterator> {\n    vals: LazyBuffer<I>,\n    state: PermutationState,\n}\n\nimpl<I> Clone for Permutations<I>\n    where I: Clone + Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(vals, state);\n}\n\n#[derive(Clone, Debug)]\nenum PermutationState {\n    StartUnknownLen {\n        k: usize,\n    },\n    OngoingUnknownLen {\n        k: usize,\n        min_n: usize,\n    },\n    Complete(CompleteState),\n    Empty,\n}\n\n#[derive(Clone, Debug)]\nenum CompleteState {\n    Start {\n        n: usize,\n        k: usize,\n    },\n    Ongoing {\n        indices: Vec<usize>,\n        cycles: Vec<usize>,\n    }\n}\n\nenum CompleteStateRemaining {\n    Known(usize),\n    Overflow,\n}\n\nimpl<I> fmt::Debug for Permutations<I>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Permutations, vals, state);\n}\n\npub fn permutations<I: Iterator>(iter: I, k: usize) -> Permutations<I> {\n    let mut vals = LazyBuffer::new(iter);\n\n    if k == 0 {\n        // Special case, yields single empty vec; `n` is irrelevant\n        let state = PermutationState::Complete(CompleteState::Start { n: 0, k: 0 });\n\n        return Permutations {\n            vals,\n            state\n        };\n    }\n\n    let mut enough_vals = true;\n\n    while vals.len() < k {\n        if !vals.get_next() {\n            enough_vals = false;\n            break;\n        }\n    }\n\n    let state = if enough_vals {\n        PermutationState::StartUnknownLen { k }\n    } else {\n        PermutationState::Empty\n    };\n\n    Permutations {\n        vals,\n        state\n    }\n}\n\nimpl<I> Iterator for Permutations<I>\nwhere\n    I: Iterator,\n    I::Item: Clone\n{\n    type Item = Vec<I::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.advance();\n\n        let &mut Permutations { ref vals, ref state } = self;\n\n        match *state {\n            PermutationState::StartUnknownLen { .. } => panic!(\"unexpected iterator state\"),\n            PermutationState::OngoingUnknownLen { k, min_n } => {\n                let latest_idx = min_n - 1;\n                let indices = (0..(k - 1)).chain(once(latest_idx));\n\n                Some(indices.map(|i| vals[i].clone()).collect())\n            }\n            PermutationState::Complete(CompleteState::Start { .. }) => None,\n            PermutationState::Complete(CompleteState::Ongoing { ref indices, ref cycles }) => {\n                let k = cycles.len();\n\n                Some(indices[0..k].iter().map(|&i| vals[i].clone()).collect())\n            },\n            PermutationState::Empty => None\n        }\n    }\n\n    fn count(self) -> usize {\n        let Permutations { vals, state } = self;\n\n        fn from_complete(complete_state: CompleteState) -> usize {\n            match complete_state.remaining() {\n                CompleteStateRemaining::Known(count) => count,\n                CompleteStateRemaining::Overflow => {\n                    panic!(\"Iterator count greater than usize::MAX\");\n                }\n            }\n        }\n\n        match state {\n            PermutationState::StartUnknownLen { k } => {\n                let n = vals.len() + vals.it.count();\n                let complete_state = CompleteState::Start { n, k };\n\n                from_complete(complete_state)\n            }\n            PermutationState::OngoingUnknownLen { k, min_n } => {\n                let prev_iteration_count = min_n - k + 1;\n                let n = vals.len() + vals.it.count();\n                let complete_state = CompleteState::Start { n, k };\n\n                from_complete(complete_state) - prev_iteration_count\n            },\n            PermutationState::Complete(state) => from_complete(state),\n            PermutationState::Empty => 0\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        match self.state {\n            PermutationState::StartUnknownLen { .. } |\n            PermutationState::OngoingUnknownLen { .. } => (0, None), // TODO can we improve this lower bound?\n            PermutationState::Complete(ref state) => match state.remaining() {\n                CompleteStateRemaining::Known(count) => (count, Some(count)),\n                CompleteStateRemaining::Overflow => (::std::usize::MAX, None)\n            }\n            PermutationState::Empty => (0, Some(0))\n        }\n    }\n}\n\nimpl<I> Permutations<I>\nwhere\n    I: Iterator,\n    I::Item: Clone\n{\n    fn advance(&mut self) {\n        let &mut Permutations { ref mut vals, ref mut state } = self;\n\n        *state = match *state {\n            PermutationState::StartUnknownLen { k } => {\n                PermutationState::OngoingUnknownLen { k, min_n: k }\n            }\n            PermutationState::OngoingUnknownLen { k, min_n } => {\n                if vals.get_next() {\n                    PermutationState::OngoingUnknownLen { k, min_n: min_n + 1 }\n                } else {\n                    let n = min_n;\n                    let prev_iteration_count = n - k + 1;\n                    let mut complete_state = CompleteState::Start { n, k };\n\n                    // Advance the complete-state iterator to the correct point\n                    for _ in 0..(prev_iteration_count + 1) {\n                        complete_state.advance();\n                    }\n\n                    PermutationState::Complete(complete_state)\n                }\n            }\n            PermutationState::Complete(ref mut state) => {\n                state.advance();\n\n                return;\n            }\n            PermutationState::Empty => { return; }\n        };\n    }\n}\n\nimpl CompleteState {\n    fn advance(&mut self) {\n        *self = match *self {\n            CompleteState::Start { n, k } => {\n                let indices = (0..n).collect();\n                let cycles = ((n - k)..n).rev().collect();\n\n                CompleteState::Ongoing {\n                    cycles,\n                    indices\n                }\n            },\n            CompleteState::Ongoing { ref mut indices, ref mut cycles } => {\n                let n = indices.len();\n                let k = cycles.len();\n\n                for i in (0..k).rev() {\n                    if cycles[i] == 0 {\n                        cycles[i] = n - i - 1;\n\n                        let to_push = indices.remove(i);\n                        indices.push(to_push);\n                    } else {\n                        let swap_index = n - cycles[i];\n                        indices.swap(i, swap_index);\n\n                        cycles[i] -= 1;\n                        return;\n                    }\n                }\n\n                CompleteState::Start { n, k }\n            }\n        }\n    }\n\n    fn remaining(&self) -> CompleteStateRemaining {\n        use self::CompleteStateRemaining::{Known, Overflow};\n\n        match *self {\n            CompleteState::Start { n, k } => {\n                if n < k {\n                    return Known(0);\n                }\n\n                let count: Option<usize> = (n - k + 1..n + 1).fold(Some(1), |acc, i| {\n                    acc.and_then(|acc| acc.checked_mul(i))\n                });\n\n                match count {\n                    Some(count) => Known(count),\n                    None => Overflow\n                }\n            }\n            CompleteState::Ongoing { ref indices, ref cycles } => {\n                let mut count: usize = 0;\n\n                for (i, &c) in cycles.iter().enumerate() {\n                    let radix = indices.len() - i;\n                    let next_count = count.checked_mul(radix)\n                        .and_then(|count| count.checked_add(c));\n\n                    count = match next_count {\n                        Some(count) => count,\n                        None => { return Overflow; }\n                    };\n                }\n\n                Known(count)\n            }\n        }\n    }\n}\n"],["1045","use std::ops::Index;\nuse alloc::vec::Vec;\n\n#[derive(Debug, Clone)]\npub struct LazyBuffer<I: Iterator> {\n    pub it: I,\n    done: bool,\n    buffer: Vec<I::Item>,\n}\n\nimpl<I> LazyBuffer<I>\nwhere\n    I: Iterator,\n{\n    pub fn new(it: I) -> LazyBuffer<I> {\n        LazyBuffer {\n            it,\n            done: false,\n            buffer: Vec::new(),\n        }\n    }\n\n    pub fn len(&self) -> usize {\n        self.buffer.len()\n    }\n\n    pub fn get_next(&mut self) -> bool {\n        if self.done {\n            return false;\n        }\n        let next_item = self.it.next();\n        match next_item {\n            Some(x) => {\n                self.buffer.push(x);\n                true\n            }\n            None => {\n                self.done = true;\n                false\n            }\n        }\n    }\n\n    pub fn prefill(&mut self, len: usize) {\n        let buffer_len = self.buffer.len();\n\n        if !self.done && len > buffer_len {\n            let delta = len - buffer_len;\n\n            self.buffer.extend(self.it.by_ref().take(delta));\n            self.done = self.buffer.len() < len;\n        }\n    }\n}\n\nimpl<I, J> Index<J> for LazyBuffer<I>\nwhere\n    I: Iterator,\n    I::Item: Sized,\n    Vec<I::Item>: Index<J>\n{\n    type Output = <Vec<I::Item> as Index<J>>::Output;\n\n    fn index(&self, _index: J) -> &Self::Output {\n        self.buffer.index(_index)\n    }\n}\n"],["1046","//! Arithmetic on **Iterator** *.size_hint()* values.\n//!\n\nuse std::usize;\nuse std::cmp;\nuse std::u32;\n\n/// **SizeHint** is the return type of **Iterator::size_hint()**.\npub type SizeHint = (usize, Option<usize>);\n\n/// Add **SizeHint** correctly.\n#[inline]\npub fn add(a: SizeHint, b: SizeHint) -> SizeHint {\n    let min = a.0.saturating_add(b.0);\n    let max = match (a.1, b.1) {\n        (Some(x), Some(y)) => x.checked_add(y),\n        _ => None,\n    };\n\n    (min, max)\n}\n\n/// Add **x** correctly to a **SizeHint**.\n#[inline]\npub fn add_scalar(sh: SizeHint, x: usize) -> SizeHint {\n    let (mut low, mut hi) = sh;\n    low = low.saturating_add(x);\n    hi = hi.and_then(|elt| elt.checked_add(x));\n    (low, hi)\n}\n\n/// Sbb **x** correctly to a **SizeHint**.\n#[inline]\n#[allow(dead_code)]\npub fn sub_scalar(sh: SizeHint, x: usize) -> SizeHint {\n    let (mut low, mut hi) = sh;\n    low = low.saturating_sub(x);\n    hi = hi.map(|elt| elt.saturating_sub(x));\n    (low, hi)\n}\n\n\n/// Multiply **SizeHint** correctly\n///\n/// ```ignore\n/// use std::usize;\n/// use itertools::size_hint;\n///\n/// assert_eq!(size_hint::mul((3, Some(4)), (3, Some(4))),\n///            (9, Some(16)));\n///\n/// assert_eq!(size_hint::mul((3, Some(4)), (usize::MAX, None)),\n///            (usize::MAX, None));\n///\n/// assert_eq!(size_hint::mul((3, None), (0, Some(0))),\n///            (0, Some(0)));\n/// ```\n#[inline]\npub fn mul(a: SizeHint, b: SizeHint) -> SizeHint {\n    let low = a.0.saturating_mul(b.0);\n    let hi = match (a.1, b.1) {\n        (Some(x), Some(y)) => x.checked_mul(y),\n        (Some(0), None) | (None, Some(0)) => Some(0),\n        _ => None,\n    };\n    (low, hi)\n}\n\n/// Multiply **x** correctly with a **SizeHint**.\n#[inline]\npub fn mul_scalar(sh: SizeHint, x: usize) -> SizeHint {\n    let (mut low, mut hi) = sh;\n    low = low.saturating_mul(x);\n    hi = hi.and_then(|elt| elt.checked_mul(x));\n    (low, hi)\n}\n\n/// Raise `base` correctly by a **`SizeHint`** exponent.\n#[inline]\npub fn pow_scalar_base(base: usize, exp: SizeHint) -> SizeHint {\n    let exp_low = cmp::min(exp.0, u32::MAX as usize) as u32;\n    let low = base.saturating_pow(exp_low);\n\n    let hi = exp.1.and_then(|exp| {\n        let exp_hi = cmp::min(exp, u32::MAX as usize) as u32;\n        base.checked_pow(exp_hi)\n    });\n\n    (low, hi)\n}\n\n/// Return the maximum\n#[inline]\npub fn max(a: SizeHint, b: SizeHint) -> SizeHint {\n    let (a_lower, a_upper) = a;\n    let (b_lower, b_upper) = b;\n\n    let lower = cmp::max(a_lower, b_lower);\n\n    let upper = match (a_upper, b_upper) {\n        (Some(x), Some(y)) => Some(cmp::max(x, y)),\n        _ => None,\n    };\n\n    (lower, upper)\n}\n\n/// Return the minimum\n#[inline]\npub fn min(a: SizeHint, b: SizeHint) -> SizeHint {\n    let (a_lower, a_upper) = a;\n    let (b_lower, b_upper) = b;\n    let lower = cmp::min(a_lower, b_lower);\n    let upper = match (a_upper, b_upper) {\n        (Some(u1), Some(u2)) => Some(cmp::min(u1, u2)),\n        _ => a_upper.or(b_upper),\n    };\n    (lower, upper)\n}\n"],["1047","use crate::size_hint;\nuse crate::PeekingNext;\nuse alloc::collections::VecDeque;\nuse std::iter::Fuse;\n\n/// See [`peek_nth()`](../fn.peek_nth.html) for more information.\n#[derive(Clone, Debug)]\npub struct PeekNth<I>\nwhere\n    I: Iterator,\n{\n    iter: Fuse<I>,\n    buf: VecDeque<I::Item>,\n}\n\n/// A drop-in replacement for `std::iter::Peekable` which adds a `peek_nth`\n/// method allowing the user to `peek` at a value several iterations forward\n/// without advancing the base iterator.\n///\n/// This differs from `multipeek` in that subsequent calls to `peek` or\n/// `peek_nth` will always return the same value until `next` is called\n/// (making `reset_peek` unnecessary).\npub fn peek_nth<I>(iterable: I) -> PeekNth<I::IntoIter>\nwhere\n    I: IntoIterator,\n{\n    PeekNth {\n        iter: iterable.into_iter().fuse(),\n        buf: VecDeque::new(),\n    }\n}\n\nimpl<I> PeekNth<I>\nwhere\n    I: Iterator,\n{\n    /// Works exactly like the `peek` method in `std::iter::Peekable`\n    pub fn peek(&mut self) -> Option<&I::Item> {\n        self.peek_nth(0)\n    }\n\n    /// Returns a reference to the `nth` value without advancing the iterator.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```rust\n    /// use itertools::peek_nth;\n    ///\n    /// let xs = vec![1,2,3];\n    /// let mut iter = peek_nth(xs.iter());\n    ///\n    /// assert_eq!(iter.peek_nth(0), Some(&&1));\n    /// assert_eq!(iter.next(), Some(&1));\n    ///\n    /// // The iterator does not advance even if we call `peek_nth` multiple times\n    /// assert_eq!(iter.peek_nth(0), Some(&&2));\n    /// assert_eq!(iter.peek_nth(1), Some(&&3));\n    /// assert_eq!(iter.next(), Some(&2));\n    ///\n    /// // Calling `peek_nth` past the end of the iterator will return `None`\n    /// assert_eq!(iter.peek_nth(1), None);\n    /// ```\n    pub fn peek_nth(&mut self, n: usize) -> Option<&I::Item> {\n        let unbuffered_items = (n + 1).saturating_sub(self.buf.len());\n\n        self.buf.extend(self.iter.by_ref().take(unbuffered_items));\n\n        self.buf.get(n)\n    }\n}\n\nimpl<I> Iterator for PeekNth<I>\nwhere\n    I: Iterator,\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.buf.pop_front().or_else(|| self.iter.next())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.iter.size_hint(), self.buf.len())\n    }\n}\n\nimpl<I> ExactSizeIterator for PeekNth<I> where I: ExactSizeIterator {}\n\nimpl<I> PeekingNext for PeekNth<I>\nwhere\n    I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n    where\n        F: FnOnce(&Self::Item) -> bool,\n    {\n        self.peek().filter(|item| accept(item))?;\n        self.next()\n    }\n}\n"],["1048","use std::fmt;\nuse std::cell::RefCell;\n\n/// Format all iterator elements lazily, separated by `sep`.\n///\n/// The format value can only be formatted once, after that the iterator is\n/// exhausted.\n///\n/// See [`.format_with()`](../trait.Itertools.html#method.format_with) for more information.\n#[derive(Clone)]\npub struct FormatWith<'a, I, F> {\n    sep: &'a str,\n    /// FormatWith uses interior mutability because Display::fmt takes &self.\n    inner: RefCell<Option<(I, F)>>,\n}\n\n/// Format all iterator elements lazily, separated by `sep`.\n///\n/// The format value can only be formatted once, after that the iterator is\n/// exhausted.\n///\n/// See [`.format()`](../trait.Itertools.html#method.format)\n/// for more information.\n#[derive(Clone)]\npub struct Format<'a, I> {\n    sep: &'a str,\n    /// Format uses interior mutability because Display::fmt takes &self.\n    inner: RefCell<Option<I>>,\n}\n\npub fn new_format<I, F>(iter: I, separator: &str, f: F) -> FormatWith<'_, I, F>\n    where I: Iterator,\n          F: FnMut(I::Item, &mut dyn FnMut(&dyn fmt::Display) -> fmt::Result) -> fmt::Result\n{\n    FormatWith {\n        sep: separator,\n        inner: RefCell::new(Some((iter, f))),\n    }\n}\n\npub fn new_format_default<I>(iter: I, separator: &str) -> Format<'_, I>\n    where I: Iterator,\n{\n    Format {\n        sep: separator,\n        inner: RefCell::new(Some(iter)),\n    }\n}\n\nimpl<'a, I, F> fmt::Display for FormatWith<'a, I, F>\n    where I: Iterator,\n          F: FnMut(I::Item, &mut dyn  FnMut(&dyn fmt::Display) -> fmt::Result) -> fmt::Result\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let (mut iter, mut format) = match self.inner.borrow_mut().take() {\n            Some(t) => t,\n            None => panic!(\"FormatWith: was already formatted once\"),\n        };\n\n        if let Some(fst) = iter.next() {\n            format(fst, &mut |disp: &dyn fmt::Display| disp.fmt(f))?;\n            iter.try_for_each(|elt| {\n                if !self.sep.is_empty() {\n                    f.write_str(self.sep)?;\n                }\n                format(elt, &mut |disp: &dyn fmt::Display| disp.fmt(f))\n            })?;\n        }\n        Ok(())\n    }\n}\n\nimpl<'a, I> Format<'a, I>\n    where I: Iterator,\n{\n    fn format<F>(&self, f: &mut fmt::Formatter, mut cb: F) -> fmt::Result\n        where F: FnMut(&I::Item, &mut fmt::Formatter) -> fmt::Result,\n    {\n        let mut iter = match self.inner.borrow_mut().take() {\n            Some(t) => t,\n            None => panic!(\"Format: was already formatted once\"),\n        };\n\n        if let Some(fst) = iter.next() {\n            cb(&fst, f)?;\n            iter.try_for_each(|elt| {\n                if !self.sep.is_empty() {\n                    f.write_str(self.sep)?;\n                }\n                cb(&elt, f)\n            })?;\n        }\n        Ok(())\n    }\n}\n\nmacro_rules! impl_format {\n    ($($fmt_trait:ident)*) => {\n        $(\n            impl<'a, I> fmt::$fmt_trait for Format<'a, I>\n                where I: Iterator,\n                      I::Item: fmt::$fmt_trait,\n            {\n                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                    self.format(f, fmt::$fmt_trait::fmt)\n                }\n            }\n        )*\n    }\n}\n\nimpl_format!{Display Debug\n             UpperExp LowerExp UpperHex LowerHex Octal Binary Pointer}\n"],["1049","use alloc::collections::BinaryHeap;\nuse core::cmp::Ord;\n\npub(crate) fn k_smallest<T: Ord, I: Iterator<Item = T>>(mut iter: I, k: usize) -> BinaryHeap<T> {\n    if k == 0 { return BinaryHeap::new(); }\n\n    let mut heap = iter.by_ref().take(k).collect::<BinaryHeap<_>>();\n\n    for i in iter {\n        debug_assert_eq!(heap.len(), k);\n        // Equivalent to heap.push(min(i, heap.pop())) but more efficient.\n        // This should be done with a single `.peek_mut().unwrap()` but\n        //  `PeekMut` sifts-down unconditionally on Rust 1.46.0 and prior.\n        if *heap.peek().unwrap() > i {\n            *heap.peek_mut().unwrap() = i;\n        }\n    }\n\n    heap\n}\n"],["1050","use crate::size_hint;\nuse crate::Itertools;\n\nuse alloc::vec::Vec;\nuse std::mem::replace;\nuse std::fmt;\n\n/// Head element and Tail iterator pair\n///\n/// `PartialEq`, `Eq`, `PartialOrd` and `Ord` are implemented by comparing sequences based on\n/// first items (which are guaranteed to exist).\n///\n/// The meanings of `PartialOrd` and `Ord` are reversed so as to turn the heap used in\n/// `KMerge` into a min-heap.\n#[derive(Debug)]\nstruct HeadTail<I>\n    where I: Iterator\n{\n    head: I::Item,\n    tail: I,\n}\n\nimpl<I> HeadTail<I>\n    where I: Iterator\n{\n    /// Constructs a `HeadTail` from an `Iterator`. Returns `None` if the `Iterator` is empty.\n    fn new(mut it: I) -> Option<HeadTail<I>> {\n        let head = it.next();\n        head.map(|h| {\n            HeadTail {\n                head: h,\n                tail: it,\n            }\n        })\n    }\n\n    /// Get the next element and update `head`, returning the old head in `Some`.\n    ///\n    /// Returns `None` when the tail is exhausted (only `head` then remains).\n    fn next(&mut self) -> Option<I::Item> {\n        if let Some(next) = self.tail.next() {\n            Some(replace(&mut self.head, next))\n        } else {\n            None\n        }\n    }\n\n    /// Hints at the size of the sequence, same as the `Iterator` method.\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.tail.size_hint(), 1)\n    }\n}\n\nimpl<I> Clone for HeadTail<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    clone_fields!(head, tail);\n}\n\n/// Make `data` a heap (min-heap w.r.t the sorting).\nfn heapify<T, S>(data: &mut [T], mut less_than: S)\n    where S: FnMut(&T, &T) -> bool\n{\n    for i in (0..data.len() / 2).rev() {\n        sift_down(data, i, &mut less_than);\n    }\n}\n\n/// Sift down element at `index` (`heap` is a min-heap wrt the ordering)\nfn sift_down<T, S>(heap: &mut [T], index: usize, mut less_than: S)\n    where S: FnMut(&T, &T) -> bool\n{\n    debug_assert!(index <= heap.len());\n    let mut pos = index;\n    let mut child = 2 * pos + 1;\n    // the `pos` conditional is to avoid a bounds check\n    while pos < heap.len() && child < heap.len() {\n        let right = child + 1;\n\n        // pick the smaller of the two children\n        if right < heap.len() && less_than(&heap[right], &heap[child]) {\n            child = right;\n        }\n\n        // sift down is done if we are already in order\n        if !less_than(&heap[child], &heap[pos]) {\n            return;\n        }\n        heap.swap(pos, child);\n        pos = child;\n        child = 2 * pos + 1;\n    }\n}\n\n/// An iterator adaptor that merges an abitrary number of base iterators in ascending order.\n/// If all base iterators are sorted (ascending), the result is sorted.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.kmerge()`](../trait.Itertools.html#method.kmerge) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub type KMerge<I> = KMergeBy<I, KMergeByLt>;\n\npub trait KMergePredicate<T> {\n    fn kmerge_pred(&mut self, a: &T, b: &T) -> bool;\n}\n\n#[derive(Clone)]\npub struct KMergeByLt;\n\nimpl<T: PartialOrd> KMergePredicate<T> for KMergeByLt {\n    fn kmerge_pred(&mut self, a: &T, b: &T) -> bool {\n        a < b\n    }\n}\n\nimpl<T, F: FnMut(&T, &T)->bool> KMergePredicate<T> for F {\n    fn kmerge_pred(&mut self, a: &T, b: &T) -> bool {\n        self(a, b)\n    }\n}\n\n/// Create an iterator that merges elements of the contained iterators using\n/// the ordering function.\n///\n/// Equivalent to `iterable.into_iter().kmerge()`.\n///\n/// ```\n/// use itertools::kmerge;\n///\n/// for elt in kmerge(vec![vec![0, 2, 4], vec![1, 3, 5], vec![6, 7]]) {\n///     /* loop body */\n/// }\n/// ```\npub fn kmerge<I>(iterable: I) -> KMerge<<I::Item as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          I::Item: IntoIterator,\n          <<I as IntoIterator>::Item as IntoIterator>::Item: PartialOrd\n{\n    kmerge_by(iterable, KMergeByLt)\n}\n\n/// An iterator adaptor that merges an abitrary number of base iterators\n/// according to an ordering function.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.kmerge_by()`](../trait.Itertools.html#method.kmerge_by) for more\n/// information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct KMergeBy<I, F>\n    where I: Iterator,\n{\n    heap: Vec<HeadTail<I>>,\n    less_than: F,\n}\n\nimpl<I, F> fmt::Debug for KMergeBy<I, F>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(KMergeBy, heap);\n}\n\n/// Create an iterator that merges elements of the contained iterators.\n///\n/// Equivalent to `iterable.into_iter().kmerge_by(less_than)`.\npub fn kmerge_by<I, F>(iterable: I, mut less_than: F)\n    -> KMergeBy<<I::Item as IntoIterator>::IntoIter, F>\n    where I: IntoIterator,\n          I::Item: IntoIterator,\n          F: KMergePredicate<<<I as IntoIterator>::Item as IntoIterator>::Item>,\n{\n    let iter = iterable.into_iter();\n    let (lower, _) = iter.size_hint();\n    let mut heap: Vec<_> = Vec::with_capacity(lower);\n    heap.extend(iter.filter_map(|it| HeadTail::new(it.into_iter())));\n    heapify(&mut heap, |a, b| less_than.kmerge_pred(&a.head, &b.head));\n    KMergeBy { heap, less_than }\n}\n\nimpl<I, F> Clone for KMergeBy<I, F>\n    where I: Iterator + Clone,\n          I::Item: Clone,\n          F: Clone,\n{\n    clone_fields!(heap, less_than);\n}\n\nimpl<I, F> Iterator for KMergeBy<I, F>\n    where I: Iterator,\n          F: KMergePredicate<I::Item>\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.heap.is_empty() {\n            return None;\n        }\n        let result = if let Some(next) = self.heap[0].next() {\n            next\n        } else {\n            self.heap.swap_remove(0).head\n        };\n        let less_than = &mut self.less_than;\n        sift_down(&mut self.heap, 0, |a, b| less_than.kmerge_pred(&a.head, &b.head));\n        Some(result)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.heap.iter()\n                 .map(|i| i.size_hint())\n                 .fold1(size_hint::add)\n                 .unwrap_or((0, Some(0)))\n    }\n}\n"],["1051","\n/// An iterator that produces only the `T` values as long as the\n/// inner iterator produces `Ok(T)`.\n///\n/// Used by [`process_results`](../fn.process_results.html), see its docs\n/// for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct ProcessResults<'a, I, E: 'a> {\n    error: &'a mut Result<(), E>,\n    iter: I,\n}\n\nimpl<'a, I, T, E> Iterator for ProcessResults<'a, I, E>\n    where I: Iterator<Item = Result<T, E>>\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.iter.next() {\n            Some(Ok(x)) => Some(x),\n            Some(Err(e)) => {\n                *self.error = Err(e);\n                None\n            }\n            None => None,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, self.iter.size_hint().1)\n    }\n}\n\n/// â€œLiftâ€ a function of the values of an iterator so that it can process\n/// an iterator of `Result` values instead.\n///\n/// `iterable` is an iterator or iterable with `Result<T, E>` elements, where\n/// `T` is the value type and `E` the error type.\n///\n/// `processor` is a closure that receives an adapted version of the iterable\n/// as the only argument â€” the adapted iterator produces elements of type `T`,\n/// as long as the original iterator produces `Ok` values.\n///\n/// If the original iterable produces an error at any point, the adapted\n/// iterator ends and the `process_results` function will return the\n/// error iself.\n///\n/// Otherwise, the return value from the closure is returned wrapped\n/// inside `Ok`.\n///\n/// # Example\n///\n/// ```\n/// use itertools::process_results;\n///\n/// type R = Result<i32, &'static str>;\n///\n/// let first_values: Vec<R> = vec![Ok(1), Ok(0), Ok(3)];\n/// let second_values: Vec<R> = vec![Ok(2), Ok(1), Err(\"overflow\")];\n///\n/// // â€œLiftâ€ the iterator .max() method to work on the values in Results using process_results\n///\n/// let first_max = process_results(first_values, |iter| iter.max().unwrap_or(0));\n/// let second_max = process_results(second_values, |iter| iter.max().unwrap_or(0));\n///\n/// assert_eq!(first_max, Ok(3));\n/// assert!(second_max.is_err());\n/// ```\npub fn process_results<I, F, T, E, R>(iterable: I, processor: F) -> Result<R, E>\n    where I: IntoIterator<Item = Result<T, E>>,\n          F: FnOnce(ProcessResults<I::IntoIter, E>) -> R\n{\n    let iter = iterable.into_iter();\n    let mut error = Ok(());\n\n    let result = processor(ProcessResults { error: &mut error, iter });\n\n    error.map(|_| result)\n}\n"],["1052","#![cfg(feature = \"use_std\")]\n\nuse crate::MinMaxResult;\nuse std::collections::HashMap;\nuse std::cmp::Ordering;\nuse std::hash::Hash;\nuse std::iter::Iterator;\nuse std::ops::{Add, Mul};\n\n/// A wrapper to allow for an easy [`into_grouping_map_by`](../trait.Itertools.html#method.into_grouping_map_by)\n#[derive(Clone, Debug)]\npub struct MapForGrouping<I, F>(I, F);\n\nimpl<I, F> MapForGrouping<I, F> {\n    pub(crate) fn new(iter: I, key_mapper: F) -> Self {\n        Self(iter, key_mapper)\n    }\n}\n\nimpl<K, V, I, F> Iterator for MapForGrouping<I, F>\n    where I: Iterator<Item = V>,\n          K: Hash + Eq,\n          F: FnMut(&V) -> K,\n{\n    type Item = (K, V);\n    fn next(&mut self) -> Option<Self::Item> {\n        self.0.next().map(|val| ((self.1)(&val), val))\n    }\n}\n\n/// Creates a new `GroupingMap` from `iter`\npub fn new<I, K, V>(iter: I) -> GroupingMap<I>\n    where I: Iterator<Item = (K, V)>,\n          K: Hash + Eq,\n{\n    GroupingMap { iter }\n}\n\n/// `GroupingMapBy` is an intermediate struct for efficient group-and-fold operations.\n/// \n/// See [`GroupingMap`](./struct.GroupingMap.html) for more informations.\n#[must_use = \"GroupingMapBy is lazy and do nothing unless consumed\"]\npub type GroupingMapBy<I, F> = GroupingMap<MapForGrouping<I, F>>;\n\n/// `GroupingMap` is an intermediate struct for efficient group-and-fold operations.\n/// It groups elements by their key and at the same time fold each group\n/// using some aggregating operation.\n/// \n/// No method on this struct performs temporary allocations.\n#[derive(Clone, Debug)]\n#[must_use = \"GroupingMap is lazy and do nothing unless consumed\"]\npub struct GroupingMap<I> {\n    iter: I,\n}\n\nimpl<I, K, V> GroupingMap<I>\n    where I: Iterator<Item = (K, V)>,\n          K: Hash + Eq,\n{\n    /// This is the generic way to perform any operation on a `GroupingMap`.\n    /// It's suggested to use this method only to implement custom operations\n    /// when the already provided ones are not enough.\n    /// \n    /// Groups elements from the `GroupingMap` source by key and applies `operation` to the elements\n    /// of each group sequentially, passing the previously accumulated value, a reference to the key\n    /// and the current element as arguments, and stores the results in an `HashMap`.\n    ///\n    /// The `operation` function is invoked on each element with the following parameters:\n    ///  - the current value of the accumulator of the group if there is currently one;\n    ///  - a reference to the key of the group this element belongs to;\n    ///  - the element from the source being aggregated;\n    /// \n    /// If `operation` returns `Some(element)` then the accumulator is updated with `element`,\n    /// otherwise the previous accumulation is discarded.\n    ///\n    /// Return a `HashMap` associating the key of each group with the result of aggregation of\n    /// that group's elements. If the aggregation of the last element of a group discards the\n    /// accumulator then there won't be an entry associated to that group's key.\n    /// \n    /// ```\n    /// use itertools::Itertools;\n    /// \n    /// let data = vec![2, 8, 5, 7, 9, 0, 4, 10];\n    /// let lookup = data.into_iter()\n    ///     .into_grouping_map_by(|&n| n % 4)\n    ///     .aggregate(|acc, _key, val| {\n    ///         if val == 0 || val == 10 {\n    ///             None\n    ///         } else {\n    ///             Some(acc.unwrap_or(0) + val)\n    ///         }\n    ///     });\n    /// \n    /// assert_eq!(lookup[&0], 4);        // 0 resets the accumulator so only 4 is summed\n    /// assert_eq!(lookup[&1], 5 + 9);\n    /// assert_eq!(lookup.get(&2), None); // 10 resets the accumulator and nothing is summed afterward\n    /// assert_eq!(lookup[&3], 7);\n    /// assert_eq!(lookup.len(), 3);      // The final keys are only 0, 1 and 2\n    /// ```\n    pub fn aggregate<FO, R>(self, mut operation: FO) -> HashMap<K, R>\n        where FO: FnMut(Option<R>, &K, V) -> Option<R>,\n    {\n        let mut destination_map = HashMap::new();\n\n        for (key, val) in self.iter {\n            let acc = destination_map.remove(&key);\n            if let Some(op_res) = operation(acc, &key, val) {\n                destination_map.insert(key, op_res);\n            }\n        }\n\n        destination_map\n    }\n\n    /// Groups elements from the `GroupingMap` source by key and applies `operation` to the elements\n    /// of each group sequentially, passing the previously accumulated value, a reference to the key\n    /// and the current element as arguments, and stores the results in a new map.\n    ///\n    /// `init` is the value from which will be cloned the initial value of each accumulator.\n    ///\n    /// `operation` is a function that is invoked on each element with the following parameters:\n    ///  - the current value of the accumulator of the group;\n    ///  - a reference to the key of the group this element belongs to;\n    ///  - the element from the source being accumulated.\n    ///\n    /// Return a `HashMap` associating the key of each group with the result of folding that group's elements.\n    /// \n    /// ```\n    /// use itertools::Itertools;\n    /// \n    /// let lookup = (1..=7)\n    ///     .into_grouping_map_by(|&n| n % 3)\n    ///     .fold(0, |acc, _key, val| acc + val);\n    /// \n    /// assert_eq!(lookup[&0], 3 + 6);\n    /// assert_eq!(lookup[&1], 1 + 4 + 7);\n    /// assert_eq!(lookup[&2], 2 + 5);\n    /// assert_eq!(lookup.len(), 3);\n    /// ```\n    pub fn fold<FO, R>(self, init: R, mut operation: FO) -> HashMap<K, R>\n        where R: Clone,\n              FO: FnMut(R, &K, V) -> R,\n    {\n        self.aggregate(|acc, key, val| {\n            let acc = acc.unwrap_or_else(|| init.clone());\n            Some(operation(acc, key, val))\n        })\n    }\n\n    /// Groups elements from the `GroupingMap` source by key and applies `operation` to the elements\n    /// of each group sequentially, passing the previously accumulated value, a reference to the key\n    /// and the current element as arguments, and stores the results in a new map.\n    ///\n    /// This is similar to [`fold`] but the initial value of the accumulator is the first element of the group.\n    ///\n    /// `operation` is a function that is invoked on each element with the following parameters:\n    ///  - the current value of the accumulator of the group;\n    ///  - a reference to the key of the group this element belongs to;\n    ///  - the element from the source being accumulated.\n    ///\n    /// Return a `HashMap` associating the key of each group with the result of folding that group's elements.\n    /// \n    /// [`fold`]: #tymethod.fold\n    /// \n    /// ```\n    /// use itertools::Itertools;\n    /// \n    /// let lookup = (1..=7)\n    ///     .into_grouping_map_by(|&n| n % 3)\n    ///     .fold_first(|acc, _key, val| acc + val);\n    /// \n    /// assert_eq!(lookup[&0], 3 + 6);\n    /// assert_eq!(lookup[&1], 1 + 4 + 7);\n    /// assert_eq!(lookup[&2], 2 + 5);\n    /// assert_eq!(lookup.len(), 3);\n    /// ```\n    pub fn fold_first<FO>(self, mut operation: FO) -> HashMap<K, V>\n        where FO: FnMut(V, &K, V) -> V,\n    {\n        self.aggregate(|acc, key, val| {\n            Some(match acc {\n                Some(acc) => operation(acc, key, val),\n                None => val,\n            })\n        })\n    }\n\n    /// Groups elements from the `GroupingMap` source by key and collects the elements of each group in\n    /// an instance of `C`. The iteration order is preserved when inserting elements. \n    /// \n    /// Return a `HashMap` associating the key of each group with the collection containing that group's elements.\n    /// \n    /// ```\n    /// use itertools::Itertools;\n    /// use std::collections::HashSet;\n    /// \n    /// let lookup = vec![0, 1, 2, 3, 4, 5, 6, 2, 3, 6].into_iter()\n    ///     .into_grouping_map_by(|&n| n % 3)\n    ///     .collect::<HashSet<_>>();\n    /// \n    /// assert_eq!(lookup[&0], vec![0, 3, 6].into_iter().collect::<HashSet<_>>());\n    /// assert_eq!(lookup[&1], vec![1, 4].into_iter().collect::<HashSet<_>>());\n    /// assert_eq!(lookup[&2], vec![2, 5].into_iter().collect::<HashSet<_>>());\n    /// assert_eq!(lookup.len(), 3);\n    /// ```\n    pub fn collect<C>(self) -> HashMap<K, C>\n        where C: Default + Extend<V>,\n    {\n        let mut destination_map = HashMap::new();\n\n        for (key, val) in self.iter {\n            destination_map.entry(key).or_insert_with(C::default).extend(Some(val));\n        }\n\n        destination_map\n    }\n\n    /// Groups elements from the `GroupingMap` source by key and finds the maximum of each group.\n    /// \n    /// If several elements are equally maximum, the last element is picked.\n    /// \n    /// Returns a `HashMap` associating the key of each group with the maximum of that group's elements.\n    /// \n    /// ```\n    /// use itertools::Itertools;\n    /// \n    /// let lookup = vec![1, 3, 4, 5, 7, 8, 9, 12].into_iter()\n    ///     .into_grouping_map_by(|&n| n % 3)\n    ///     .max();\n    /// \n    /// assert_eq!(lookup[&0], 12);\n    /// assert_eq!(lookup[&1], 7);\n    /// assert_eq!(lookup[&2], 8);\n    /// assert_eq!(lookup.len(), 3);\n    /// ```\n    pub fn max(self) -> HashMap<K, V>\n        where V: Ord,\n    {\n        self.max_by(|_, v1, v2| V::cmp(v1, v2))\n    }\n\n    /// Groups elements from the `GroupingMap` source by key and finds the maximum of each group\n    /// with respect to the specified comparison function.\n    /// \n    /// If several elements are equally maximum, the last element is picked.\n    /// \n    /// Returns a `HashMap` associating the key of each group with the maximum of that group's elements.\n    /// \n    /// ```\n    /// use itertools::Itertools;\n    /// \n    /// let lookup = vec![1, 3, 4, 5, 7, 8, 9, 12].into_iter()\n    ///     .into_grouping_map_by(|&n| n % 3)\n    ///     .max_by(|_key, x, y| y.cmp(x));\n    /// \n    /// assert_eq!(lookup[&0], 3);\n    /// assert_eq!(lookup[&1], 1);\n    /// assert_eq!(lookup[&2], 5);\n    /// assert_eq!(lookup.len(), 3);\n    /// ```\n    pub fn max_by<F>(self, mut compare: F) -> HashMap<K, V>\n        where F: FnMut(&K, &V, &V) -> Ordering,\n    {\n        self.fold_first(|acc, key, val| match compare(key, &acc, &val) {\n            Ordering::Less | Ordering::Equal => val,\n            Ordering::Greater => acc\n        })\n    }\n\n    /// Groups elements from the `GroupingMap` source by key and finds the element of each group\n    /// that gives the maximum from the specified function.\n    /// \n    /// If several elements are equally maximum, the last element is picked.\n    /// \n    /// Returns a `HashMap` associating the key of each group with the maximum of that group's elements.\n    /// \n    /// ```\n    /// use itertools::Itertools;\n    /// \n    /// let lookup = vec![1, 3, 4, 5, 7, 8, 9, 12].into_iter()\n    ///     .into_grouping_map_by(|&n| n % 3)\n    ///     .max_by_key(|_key, &val| val % 4);\n    /// \n    /// assert_eq!(lookup[&0], 3);\n    /// assert_eq!(lookup[&1], 7);\n    /// assert_eq!(lookup[&2], 5);\n    /// assert_eq!(lookup.len(), 3);\n    /// ```\n    pub fn max_by_key<F, CK>(self, mut f: F) -> HashMap<K, V>\n        where F: FnMut(&K, &V) -> CK,\n              CK: Ord,\n    {\n        self.max_by(|key, v1, v2| f(key, &v1).cmp(&f(key, &v2)))\n    }\n\n    /// Groups elements from the `GroupingMap` source by key and finds the minimum of each group.\n    /// \n    /// If several elements are equally minimum, the first element is picked.\n    /// \n    /// Returns a `HashMap` associating the key of each group with the minimum of that group's elements.\n    /// \n    /// ```\n    /// use itertools::Itertools;\n    /// \n    /// let lookup = vec![1, 3, 4, 5, 7, 8, 9, 12].into_iter()\n    ///     .into_grouping_map_by(|&n| n % 3)\n    ///     .min();\n    /// \n    /// assert_eq!(lookup[&0], 3);\n    /// assert_eq!(lookup[&1], 1);\n    /// assert_eq!(lookup[&2], 5);\n    /// assert_eq!(lookup.len(), 3);\n    /// ```\n    pub fn min(self) -> HashMap<K, V>\n        where V: Ord,\n    {\n        self.min_by(|_, v1, v2| V::cmp(v1, v2))\n    }\n\n    /// Groups elements from the `GroupingMap` source by key and finds the minimum of each group\n    /// with respect to the specified comparison function.\n    /// \n    /// If several elements are equally minimum, the first element is picked.\n    /// \n    /// Returns a `HashMap` associating the key of each group with the minimum of that group's elements.\n    /// \n    /// ```\n    /// use itertools::Itertools;\n    /// \n    /// let lookup = vec![1, 3, 4, 5, 7, 8, 9, 12].into_iter()\n    ///     .into_grouping_map_by(|&n| n % 3)\n    ///     .min_by(|_key, x, y| y.cmp(x));\n    /// \n    /// assert_eq!(lookup[&0], 12);\n    /// assert_eq!(lookup[&1], 7);\n    /// assert_eq!(lookup[&2], 8);\n    /// assert_eq!(lookup.len(), 3);\n    /// ```\n    pub fn min_by<F>(self, mut compare: F) -> HashMap<K, V>\n        where F: FnMut(&K, &V, &V) -> Ordering,\n    {\n        self.fold_first(|acc, key, val| match compare(key, &acc, &val) {\n            Ordering::Less | Ordering::Equal => acc,\n            Ordering::Greater => val\n        })\n    }\n\n    /// Groups elements from the `GroupingMap` source by key and finds the element of each group\n    /// that gives the minimum from the specified function.\n    /// \n    /// If several elements are equally minimum, the first element is picked.\n    /// \n    /// Returns a `HashMap` associating the key of each group with the minimum of that group's elements.\n    /// \n    /// ```\n    /// use itertools::Itertools;\n    /// \n    /// let lookup = vec![1, 3, 4, 5, 7, 8, 9, 12].into_iter()\n    ///     .into_grouping_map_by(|&n| n % 3)\n    ///     .min_by_key(|_key, &val| val % 4);\n    /// \n    /// assert_eq!(lookup[&0], 12);\n    /// assert_eq!(lookup[&1], 4);\n    /// assert_eq!(lookup[&2], 8);\n    /// assert_eq!(lookup.len(), 3);\n    /// ```\n    pub fn min_by_key<F, CK>(self, mut f: F) -> HashMap<K, V>\n        where F: FnMut(&K, &V) -> CK,\n              CK: Ord,\n    {\n        self.min_by(|key, v1, v2| f(key, &v1).cmp(&f(key, &v2)))\n    }\n\n    /// Groups elements from the `GroupingMap` source by key and find the maximum and minimum of\n    /// each group.\n    /// \n    /// If several elements are equally maximum, the last element is picked.\n    /// If several elements are equally minimum, the first element is picked.\n    /// \n    /// See [.minmax()](../trait.Itertools.html#method.minmax) for the non-grouping version.\n    /// \n    /// Differences from the non grouping version:\n    /// - It never produces a `MinMaxResult::NoElements`\n    /// - It doesn't have any speedup\n    /// \n    /// Returns a `HashMap` associating the key of each group with the minimum and maximum of that group's elements.\n    /// \n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::MinMaxResult::{OneElement, MinMax};\n    /// \n    /// let lookup = vec![1, 3, 4, 5, 7, 9, 12].into_iter()\n    ///     .into_grouping_map_by(|&n| n % 3)\n    ///     .minmax();\n    /// \n    /// assert_eq!(lookup[&0], MinMax(3, 12));\n    /// assert_eq!(lookup[&1], MinMax(1, 7));\n    /// assert_eq!(lookup[&2], OneElement(5));\n    /// assert_eq!(lookup.len(), 3);\n    /// ```\n    pub fn minmax(self) -> HashMap<K, MinMaxResult<V>>\n        where V: Ord,\n    {\n        self.minmax_by(|_, v1, v2| V::cmp(v1, v2))\n    }\n\n    /// Groups elements from the `GroupingMap` source by key and find the maximum and minimum of\n    /// each group with respect to the specified comparison function.\n    /// \n    /// If several elements are equally maximum, the last element is picked.\n    /// If several elements are equally minimum, the first element is picked.\n    /// \n    /// It has the same differences from the non-grouping version as `minmax`.\n    /// \n    /// Returns a `HashMap` associating the key of each group with the minimum and maximum of that group's elements.\n    /// \n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::MinMaxResult::{OneElement, MinMax};\n    /// \n    /// let lookup = vec![1, 3, 4, 5, 7, 9, 12].into_iter()\n    ///     .into_grouping_map_by(|&n| n % 3)\n    ///     .minmax_by(|_key, x, y| y.cmp(x));\n    /// \n    /// assert_eq!(lookup[&0], MinMax(12, 3));\n    /// assert_eq!(lookup[&1], MinMax(7, 1));\n    /// assert_eq!(lookup[&2], OneElement(5));\n    /// assert_eq!(lookup.len(), 3);\n    /// ```\n    pub fn minmax_by<F>(self, mut compare: F) -> HashMap<K, MinMaxResult<V>>\n        where F: FnMut(&K, &V, &V) -> Ordering,\n    {\n        self.aggregate(|acc, key, val| {\n            Some(match acc {\n                Some(MinMaxResult::OneElement(e)) => {\n                    if compare(key, &val, &e) == Ordering::Less {\n                        MinMaxResult::MinMax(val, e)\n                    } else {\n                        MinMaxResult::MinMax(e, val)\n                    }\n                }\n                Some(MinMaxResult::MinMax(min, max)) => {\n                    if compare(key, &val, &min) == Ordering::Less {\n                        MinMaxResult::MinMax(val, max)\n                    } else if compare(key, &val, &max) != Ordering::Less {\n                        MinMaxResult::MinMax(min, val)\n                    } else {\n                        MinMaxResult::MinMax(min, max)\n                    }\n                }\n                None => MinMaxResult::OneElement(val),\n                Some(MinMaxResult::NoElements) => unreachable!(),\n            })\n        })\n    }\n\n    /// Groups elements from the `GroupingMap` source by key and find the elements of each group\n    /// that gives the minimum and maximum from the specified function.\n    /// \n    /// If several elements are equally maximum, the last element is picked.\n    /// If several elements are equally minimum, the first element is picked.\n    /// \n    /// It has the same differences from the non-grouping version as `minmax`.\n    /// \n    /// Returns a `HashMap` associating the key of each group with the minimum and maximum of that group's elements.\n    /// \n    /// ```\n    /// use itertools::Itertools;\n    /// use itertools::MinMaxResult::{OneElement, MinMax};\n    /// \n    /// let lookup = vec![1, 3, 4, 5, 7, 9, 12].into_iter()\n    ///     .into_grouping_map_by(|&n| n % 3)\n    ///     .minmax_by_key(|_key, &val| val % 4);\n    /// \n    /// assert_eq!(lookup[&0], MinMax(12, 3));\n    /// assert_eq!(lookup[&1], MinMax(4, 7));\n    /// assert_eq!(lookup[&2], OneElement(5));\n    /// assert_eq!(lookup.len(), 3);\n    /// ```\n    pub fn minmax_by_key<F, CK>(self, mut f: F) -> HashMap<K, MinMaxResult<V>>\n        where F: FnMut(&K, &V) -> CK,\n              CK: Ord,\n    {\n        self.minmax_by(|key, v1, v2| f(key, &v1).cmp(&f(key, &v2)))\n    }\n    \n    /// Groups elements from the `GroupingMap` source by key and sums them.\n    /// \n    /// This is just a shorthand for `self.fold_first(|acc, _, val| acc + val)`.\n    /// It is more limited than `Iterator::sum` since it doesn't use the `Sum` trait.\n    /// \n    /// Returns a `HashMap` associating the key of each group with the sum of that group's elements.\n    /// \n    /// ```\n    /// use itertools::Itertools;\n    /// \n    /// let lookup = vec![1, 3, 4, 5, 7, 8, 9, 12].into_iter()\n    ///     .into_grouping_map_by(|&n| n % 3)\n    ///     .sum();\n    /// \n    /// assert_eq!(lookup[&0], 3 + 9 + 12);\n    /// assert_eq!(lookup[&1], 1 + 4 + 7);\n    /// assert_eq!(lookup[&2], 5 + 8);\n    /// assert_eq!(lookup.len(), 3);\n    /// ```\n    pub fn sum(self) -> HashMap<K, V>\n        where V: Add<V, Output = V>\n    {\n        self.fold_first(|acc, _, val| acc + val)\n    }\n\n    /// Groups elements from the `GroupingMap` source by key and multiply them.\n    /// \n    /// This is just a shorthand for `self.fold_first(|acc, _, val| acc * val)`.\n    /// It is more limited than `Iterator::product` since it doesn't use the `Product` trait.\n    /// \n    /// Returns a `HashMap` associating the key of each group with the product of that group's elements.\n    /// \n    /// ```\n    /// use itertools::Itertools;\n    /// \n    /// let lookup = vec![1, 3, 4, 5, 7, 8, 9, 12].into_iter()\n    ///     .into_grouping_map_by(|&n| n % 3)\n    ///     .product();\n    /// \n    /// assert_eq!(lookup[&0], 3 * 9 * 12);\n    /// assert_eq!(lookup[&1], 1 * 4 * 7);\n    /// assert_eq!(lookup[&2], 5 * 8);\n    /// assert_eq!(lookup.len(), 3);\n    /// ```\n    pub fn product(self) -> HashMap<K, V>\n        where V: Mul<V, Output = V>,\n    {\n        self.fold_first(|acc, _, val| acc * val)\n    }\n}\n"],["1053","use crate::EitherOrBoth::*;\n\nuse either::Either;\n\n/// Value that either holds a single A or B, or both.\n#[derive(Clone, PartialEq, Eq, Hash, Debug)]\npub enum EitherOrBoth<A, B> {\n    /// Both values are present.\n    Both(A, B),\n    /// Only the left value of type `A` is present.\n    Left(A),\n    /// Only the right value of type `B` is present.\n    Right(B),\n}\n\nimpl<A, B> EitherOrBoth<A, B> {\n    /// If `Left`, or `Both`, return true, otherwise, return false.\n    pub fn has_left(&self) -> bool {\n        self.as_ref().left().is_some()\n    }\n\n    /// If `Right`, or `Both`, return true, otherwise, return false.\n    pub fn has_right(&self) -> bool {\n        self.as_ref().right().is_some()\n    }\n\n    /// If Left, return true otherwise, return false.\n    /// Exclusive version of [`has_left`].\n    pub fn is_left(&self) -> bool {\n        match *self {\n            Left(_) => true,\n            _ => false,\n        }\n    }\n\n    /// If Right, return true otherwise, return false.\n    /// Exclusive version of [`has_right`].\n    pub fn is_right(&self) -> bool {\n        match *self {\n            Right(_) => true,\n            _ => false,\n        }\n    }\n\n    /// If Right, return true otherwise, return false.\n    /// Equivalent to `self.as_ref().both().is_some()`.\n    pub fn is_both(&self) -> bool {\n        self.as_ref().both().is_some()\n    }\n\n    /// If `Left`, or `Both`, return `Some` with the left value, otherwise, return `None`.\n    pub fn left(self) -> Option<A> {\n        match self {\n            Left(left) | Both(left, _) => Some(left),\n            _ => None,\n        }\n    }\n\n    /// If `Right`, or `Both`, return `Some` with the right value, otherwise, return `None`.\n    pub fn right(self) -> Option<B> {\n        match self {\n            Right(right) | Both(_, right) => Some(right),\n            _ => None,\n        }\n    }\n\n    /// If Both, return `Some` tuple containing left and right.\n    pub fn both(self) -> Option<(A, B)> {\n        match self {\n            Both(a, b) => Some((a, b)),\n            _ => None,\n        }\n    }\n\n    /// Converts from `&EitherOrBoth<A, B>` to `EitherOrBoth<&A, &B>`.\n    pub fn as_ref(&self) -> EitherOrBoth<&A, &B> {\n        match *self {\n            Left(ref left) => Left(left),\n            Right(ref right) => Right(right),\n            Both(ref left, ref right) => Both(left, right),\n        }\n    }\n\n    /// Converts from `&mut EitherOrBoth<A, B>` to `EitherOrBoth<&mut A, &mut B>`.\n    pub fn as_mut(&mut self) -> EitherOrBoth<&mut A, &mut B> {\n        match *self {\n            Left(ref mut left) => Left(left),\n            Right(ref mut right) => Right(right),\n            Both(ref mut left, ref mut right) => Both(left, right),\n        }\n    }\n\n    /// Convert `EitherOrBoth<A, B>` to `EitherOrBoth<B, A>`.\n    pub fn flip(self) -> EitherOrBoth<B, A> {\n        match self {\n            Left(a) => Right(a),\n            Right(b) => Left(b),\n            Both(a, b) => Both(b, a),\n        }\n    }\n\n    /// Apply the function `f` on the value `a` in `Left(a)` or `Both(a, b)` variants. If it is\n    /// present rewrapping the result in `self`'s original variant.\n    pub fn map_left<F, M>(self, f: F) -> EitherOrBoth<M, B>\n    where\n        F: FnOnce(A) -> M,\n    {\n        match self {\n            Both(a, b) => Both(f(a), b),\n            Left(a) => Left(f(a)),\n            Right(b) => Right(b),\n        }\n    }\n\n    /// Apply the function `f` on the value `b` in `Right(b)` or `Both(a, b)` variants.\n    /// If it is present rewrapping the result in `self`'s original variant.\n    pub fn map_right<F, M>(self, f: F) -> EitherOrBoth<A, M>\n    where\n        F: FnOnce(B) -> M,\n    {\n        match self {\n            Left(a) => Left(a),\n            Right(b) => Right(f(b)),\n            Both(a, b) => Both(a, f(b)),\n        }\n    }\n\n    /// Apply the functions `f` and `g` on the value `a` and `b` respectively;\n    /// found in `Left(a)`, `Right(b)`, or `Both(a, b)` variants.\n    /// The Result is rewrapped `self`'s original variant.\n    pub fn map_any<F, L, G, R>(self, f: F, g: G) -> EitherOrBoth<L, R>\n    where\n        F: FnOnce(A) -> L,\n        G: FnOnce(B) -> R,\n    {\n        match self {\n            Left(a) => Left(f(a)),\n            Right(b) => Right(g(b)),\n            Both(a, b) => Both(f(a), g(b)),\n        }\n    }\n\n    /// Apply the function `f` on the value `b` in `Right(b)` or `Both(a, _)` variants if it is\n    /// present.\n    pub fn left_and_then<F, L>(self, f: F) -> EitherOrBoth<L, B>\n    where\n        F: FnOnce(A) -> EitherOrBoth<L, B>,\n    {\n        match self {\n            Left(a) | Both(a, _) => f(a),\n            Right(b) => Right(b),\n        }\n    }\n\n    /// Apply the function `f` on the value `a`\n    /// in `Left(a)` or `Both(a, _)` variants if it is present.\n    pub fn right_and_then<F, R>(self, f: F) -> EitherOrBoth<A, R>\n    where\n        F: FnOnce(B) -> EitherOrBoth<A, R>,\n    {\n        match self {\n            Left(a) => Left(a),\n            Right(b) | Both(_, b) => f(b),\n        }\n    }\n}\n\nimpl<T> EitherOrBoth<T, T> {\n    /// Return either value of left, right, or the product of `f` applied where `Both` are present.\n    pub fn reduce<F>(self, f: F) -> T\n    where\n        F: FnOnce(T, T) -> T,\n    {\n        match self {\n            Left(a) => a,\n            Right(b) => b,\n            Both(a, b) => f(a, b),\n        }\n    }\n}\n\nimpl<A, B> Into<Option<Either<A, B>>> for EitherOrBoth<A, B> {\n    fn into(self) -> Option<Either<A, B>> {\n        match self {\n            EitherOrBoth::Left(l) => Some(Either::Left(l)),\n            EitherOrBoth::Right(r) => Some(Either::Right(r)),\n            _ => None,\n        }\n    }\n}\n"],["1054","use super::size_hint;\n\n/// See [`multizip`](../fn.multizip.html) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Zip<T> {\n    t: T,\n}\n\n/// An iterator that generalizes *.zip()* and allows running multiple iterators in lockstep.\n///\n/// The iterator `Zip<(I, J, ..., M)>` is formed from a tuple of iterators (or values that\n/// implement `IntoIterator`) and yields elements\n/// until any of the subiterators yields `None`.\n///\n/// The iterator element type is a tuple like like `(A, B, ..., E)` where `A` to `E` are the\n/// element types of the subiterator.\n///\n/// **Note:** The result of this macro is a value of a named type (`Zip<(I, J,\n/// ..)>` of each component iterator `I, J, ...`) if each component iterator is\n/// nameable.\n///\n/// Prefer [`izip!()`] over `multizip` for the performance benefits of using the\n/// standard library `.zip()`. Prefer `multizip` if a nameable type is needed.\n///\n/// [`izip!()`]: macro.izip.html\n///\n/// ```\n/// use itertools::multizip;\n///\n/// // iterate over three sequences side-by-side\n/// let mut results = [0, 0, 0, 0];\n/// let inputs = [3, 7, 9, 6];\n///\n/// for (r, index, input) in multizip((&mut results, 0..10, &inputs)) {\n///     *r = index * 10 + input;\n/// }\n///\n/// assert_eq!(results, [0 + 3, 10 + 7, 29, 36]);\n/// ```\npub fn multizip<T, U>(t: U) -> Zip<T>\n    where Zip<T>: From<U>,\n          Zip<T>: Iterator,\n{\n    Zip::from(t)\n}\n\nmacro_rules! impl_zip_iter {\n    ($($B:ident),*) => (\n        #[allow(non_snake_case)]\n        impl<$($B: IntoIterator),*> From<($($B,)*)> for Zip<($($B::IntoIter,)*)> {\n            fn from(t: ($($B,)*)) -> Self {\n                let ($($B,)*) = t;\n                Zip { t: ($($B.into_iter(),)*) }\n            }\n        }\n\n        #[allow(non_snake_case)]\n        #[allow(unused_assignments)]\n        impl<$($B),*> Iterator for Zip<($($B,)*)>\n            where\n            $(\n                $B: Iterator,\n            )*\n        {\n            type Item = ($($B::Item,)*);\n\n            fn next(&mut self) -> Option<Self::Item>\n            {\n                let ($(ref mut $B,)*) = self.t;\n\n                // NOTE: Just like iter::Zip, we check the iterators\n                // for None in order. We may finish unevenly (some\n                // iterators gave n + 1 elements, some only n).\n                $(\n                    let $B = match $B.next() {\n                        None => return None,\n                        Some(elt) => elt\n                    };\n                )*\n                Some(($($B,)*))\n            }\n\n            fn size_hint(&self) -> (usize, Option<usize>)\n            {\n                let sh = (::std::usize::MAX, None);\n                let ($(ref $B,)*) = self.t;\n                $(\n                    let sh = size_hint::min($B.size_hint(), sh);\n                )*\n                sh\n            }\n        }\n\n        #[allow(non_snake_case)]\n        impl<$($B),*> ExactSizeIterator for Zip<($($B,)*)> where\n            $(\n                $B: ExactSizeIterator,\n            )*\n        { }\n\n        #[allow(non_snake_case)]\n        impl<$($B),*> DoubleEndedIterator for Zip<($($B,)*)> where\n            $(\n                $B: DoubleEndedIterator + ExactSizeIterator,\n            )*\n        {\n            #[inline]\n            fn next_back(&mut self) -> Option<Self::Item> {\n                let ($(ref mut $B,)*) = self.t;\n                let size = *[$( $B.len(), )*].iter().min().unwrap();\n\n                $(\n                    if $B.len() != size {\n                        for _ in 0..$B.len() - size { $B.next_back(); }\n                    }\n                )*\n\n                match ($($B.next_back(),)*) {\n                    ($(Some($B),)*) => Some(($($B,)*)),\n                    _ => None,\n                }\n            }\n        }\n    );\n}\n\nimpl_zip_iter!(A);\nimpl_zip_iter!(A, B);\nimpl_zip_iter!(A, B, C);\nimpl_zip_iter!(A, B, C, D);\nimpl_zip_iter!(A, B, C, D, E);\nimpl_zip_iter!(A, B, C, D, E, F);\nimpl_zip_iter!(A, B, C, D, E, F, G);\nimpl_zip_iter!(A, B, C, D, E, F, G, H);\nimpl_zip_iter!(A, B, C, D, E, F, G, H, I);\nimpl_zip_iter!(A, B, C, D, E, F, G, H, I, J);\nimpl_zip_iter!(A, B, C, D, E, F, G, H, I, J, K);\nimpl_zip_iter!(A, B, C, D, E, F, G, H, I, J, K, L);\n"],["1055","use std::iter::{Fuse,Peekable};\n\n/// An iterator adaptor that wraps each element in an [`Position`](../enum.Position.html).\n///\n/// Iterator element type is `Position<I::Item>`.\n///\n/// See [`.with_position()`](../trait.Itertools.html#method.with_position) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct WithPosition<I>\n    where I: Iterator,\n{\n    handled_first: bool,\n    peekable: Peekable<Fuse<I>>,\n}\n\nimpl<I> Clone for WithPosition<I>\n    where I: Clone + Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(handled_first, peekable);\n}\n\n/// Create a new `WithPosition` iterator.\npub fn with_position<I>(iter: I) -> WithPosition<I>\n    where I: Iterator,\n{\n    WithPosition {\n        handled_first: false,\n        peekable: iter.fuse().peekable(),\n    }\n}\n\n/// A value yielded by `WithPosition`.\n/// Indicates the position of this element in the iterator results.\n///\n/// See [`.with_position()`](trait.Itertools.html#method.with_position) for more information.\n#[derive(Copy, Clone, Debug, PartialEq)]\npub enum Position<T> {\n    /// This is the first element.\n    First(T),\n    /// This is neither the first nor the last element.\n    Middle(T),\n    /// This is the last element.\n    Last(T),\n    /// This is the only element.\n    Only(T),\n}\n\nimpl<T> Position<T> {\n    /// Return the inner value.\n    pub fn into_inner(self) -> T {\n        match self {\n            Position::First(x) |\n            Position::Middle(x) |\n            Position::Last(x) |\n            Position::Only(x) => x,\n        }\n    }\n}\n\nimpl<I: Iterator> Iterator for WithPosition<I> {\n    type Item = Position<I::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.peekable.next() {\n            Some(item) => {\n                if !self.handled_first {\n                    // Haven't seen the first item yet, and there is one to give.\n                    self.handled_first = true;\n                    // Peek to see if this is also the last item,\n                    // in which case tag it as `Only`.\n                    match self.peekable.peek() {\n                        Some(_) => Some(Position::First(item)),\n                        None => Some(Position::Only(item)),\n                    }\n                } else {\n                    // Have seen the first item, and there's something left.\n                    // Peek to see if this is the last item.\n                    match self.peekable.peek() {\n                        Some(_) => Some(Position::Middle(item)),\n                        None => Some(Position::Last(item)),\n                    }\n                }\n            }\n            // Iterator is finished.\n            None => None,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.peekable.size_hint()\n    }\n}\n\nimpl<I> ExactSizeIterator for WithPosition<I>\n    where I: ExactSizeIterator,\n{ }\n"],["1056","use alloc::vec::Vec;\nuse std::fmt;\n\nuse super::lazy_buffer::LazyBuffer;\n\n/// An iterator to iterate through all the `n`-length combinations in an iterator, with replacement.\n///\n/// See [`.combinations_with_replacement()`](../trait.Itertools.html#method.combinations_with_replacement) for more information.\n#[derive(Clone)]\npub struct CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    indices: Vec<usize>,\n    pool: LazyBuffer<I>,\n    first: bool,\n}\n\nimpl<I> fmt::Debug for CombinationsWithReplacement<I>\nwhere\n    I: Iterator + fmt::Debug,\n    I::Item: fmt::Debug + Clone,\n{\n    debug_fmt_fields!(Combinations, indices, pool, first);\n}\n\nimpl<I> CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    /// Map the current mask over the pool to get an output combination\n    fn current(&self) -> Vec<I::Item> {\n        self.indices.iter().map(|i| self.pool[*i].clone()).collect()\n    }\n}\n\n/// Create a new `CombinationsWithReplacement` from a clonable iterator.\npub fn combinations_with_replacement<I>(iter: I, k: usize) -> CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    let indices: Vec<usize> = alloc::vec![0; k];\n    let pool: LazyBuffer<I> = LazyBuffer::new(iter);\n\n    CombinationsWithReplacement {\n        indices,\n        pool,\n        first: true,\n    }\n}\n\nimpl<I> Iterator for CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    type Item = Vec<I::Item>;\n    fn next(&mut self) -> Option<Self::Item> {\n        // If this is the first iteration, return early\n        if self.first {\n            // In empty edge cases, stop iterating immediately\n            return if self.indices.len() != 0 && !self.pool.get_next() {\n                None\n            // Otherwise, yield the initial state\n            } else {\n                self.first = false;\n                Some(self.current())\n            };\n        }\n\n        // Check if we need to consume more from the iterator\n        // This will run while we increment our first index digit\n        self.pool.get_next();\n\n        // Work out where we need to update our indices\n        let mut increment: Option<(usize, usize)> = None;\n        for (i, indices_int) in self.indices.iter().enumerate().rev() {\n            if *indices_int < self.pool.len()-1 {\n                increment = Some((i, indices_int + 1));\n                break;\n            }\n        }\n\n        match increment {\n            // If we can update the indices further\n            Some((increment_from, increment_value)) => {\n                // We need to update the rightmost non-max value\n                // and all those to the right\n                for indices_index in increment_from..self.indices.len() {\n                    self.indices[indices_index] = increment_value\n                }\n                Some(self.current())\n            }\n            // Otherwise, we're done\n            None => None,\n        }\n    }\n}\n"],["1057","use std::iter::FromIterator;\nuse std::marker::PhantomData;\n\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MapSpecialCase<I, F> {\n    iter: I,\n    f: F,\n}\n\npub trait MapSpecialCaseFn<T> {\n    type Out;\n    fn call(&mut self, t: T) -> Self::Out;\n}\n\nimpl<I, R> Iterator for MapSpecialCase<I, R>\nwhere\n    I: Iterator,\n    R: MapSpecialCaseFn<I::Item>,\n{\n    type Item = R::Out;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|i| self.f.call(i))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<Acc, Fold>(self, init: Acc, mut fold_f: Fold) -> Acc\n    where\n        Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n        let mut f = self.f;\n        self.iter.fold(init, move |acc, v| fold_f(acc, f.call(v)))\n    }\n\n    fn collect<C>(self) -> C\n    where\n        C: FromIterator<Self::Item>,\n    {\n        let mut f = self.f;\n        self.iter.map(move |v| f.call(v)).collect()\n    }\n}\n\nimpl<I, R> DoubleEndedIterator for MapSpecialCase<I, R>\nwhere\n    I: DoubleEndedIterator,\n    R: MapSpecialCaseFn<I::Item>,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.iter.next_back().map(|i| self.f.call(i))\n    }\n}\n\nimpl<I, R> ExactSizeIterator for MapSpecialCase<I, R>\nwhere\n    I: ExactSizeIterator,\n    R: MapSpecialCaseFn<I::Item>,\n{\n}\n\n/// An iterator adapter to apply a transformation within a nested `Result::Ok`.\n///\n/// See [`.map_ok()`](../trait.Itertools.html#method.map_ok) for more information.\npub type MapOk<I, F> = MapSpecialCase<I, MapSpecialCaseFnOk<F>>;\n\n/// See [`MapOk`](struct.MapOk.html).\n#[deprecated(note = \"Use MapOk instead\", since = \"0.10.0\")]\npub type MapResults<I, F> = MapOk<I, F>;\n\nimpl<F, T, U, E> MapSpecialCaseFn<Result<T, E>> for MapSpecialCaseFnOk<F>\nwhere\n    F: FnMut(T) -> U,\n{\n    type Out = Result<U, E>;\n    fn call(&mut self, t: Result<T, E>) -> Self::Out {\n        t.map(|v| self.0(v))\n    }\n}\n\n#[derive(Clone)]\npub struct MapSpecialCaseFnOk<F>(F);\n\n/// Create a new `MapOk` iterator.\npub fn map_ok<I, F, T, U, E>(iter: I, f: F) -> MapOk<I, F>\nwhere\n    I: Iterator<Item = Result<T, E>>,\n    F: FnMut(T) -> U,\n{\n    MapSpecialCase {\n        iter,\n        f: MapSpecialCaseFnOk(f),\n    }\n}\n\n/// An iterator adapter to apply `Into` conversion to each element.\n///\n/// See [`.map_into()`](../trait.Itertools.html#method.map_into) for more information.\npub type MapInto<I, R> = MapSpecialCase<I, MapSpecialCaseFnInto<R>>;\n\nimpl<T: Into<U>, U> MapSpecialCaseFn<T> for MapSpecialCaseFnInto<U> {\n    type Out = U;\n    fn call(&mut self, t: T) -> Self::Out {\n        t.into()\n    }\n}\n\n#[derive(Clone)]\npub struct MapSpecialCaseFnInto<U>(PhantomData<U>);\n\n/// Create a new [`MapInto`](struct.MapInto.html) iterator.\npub fn map_into<I, R>(iter: I) -> MapInto<I, R> {\n    MapSpecialCase {\n        iter,\n        f: MapSpecialCaseFnInto(PhantomData),\n    }\n}\n"],["1058","//! Licensed under the Apache License, Version 2.0\n//! http://www.apache.org/licenses/LICENSE-2.0 or the MIT license\n//! http://opensource.org/licenses/MIT, at your\n//! option. This file may not be copied, modified, or distributed\n//! except according to those terms.\n\nmod coalesce;\nmod map;\nmod multi_product;\npub use self::coalesce::*;\npub use self::map::{map_into, map_ok, MapInto, MapOk};\n#[allow(deprecated)]\npub use self::map::MapResults;\n#[cfg(feature = \"use_alloc\")]\npub use self::multi_product::*;\n\nuse std::fmt;\nuse std::iter::{Fuse, Peekable, FromIterator};\nuse std::marker::PhantomData;\nuse crate::size_hint;\n\n/// An iterator adaptor that alternates elements from two iterators until both\n/// run out.\n///\n/// This iterator is *fused*.\n///\n/// See [`.interleave()`](../trait.Itertools.html#method.interleave) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Interleave<I, J> {\n    a: Fuse<I>,\n    b: Fuse<J>,\n    flag: bool,\n}\n\n/// Create an iterator that interleaves elements in `i` and `j`.\n///\n/// `IntoIterator` enabled version of `i.interleave(j)`.\n///\n/// See [`.interleave()`](trait.Itertools.html#method.interleave) for more information.\npub fn interleave<I, J>(i: I, j: J) -> Interleave<<I as IntoIterator>::IntoIter, <J as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>\n{\n    Interleave {\n        a: i.into_iter().fuse(),\n        b: j.into_iter().fuse(),\n        flag: false,\n    }\n}\n\nimpl<I, J> Iterator for Interleave<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.flag = !self.flag;\n        if self.flag {\n            match self.a.next() {\n                None => self.b.next(),\n                r => r,\n            }\n        } else {\n            match self.b.next() {\n                None => self.a.next(),\n                r => r,\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\n/// An iterator adaptor that alternates elements from the two iterators until\n/// one of them runs out.\n///\n/// This iterator is *fused*.\n///\n/// See [`.interleave_shortest()`](../trait.Itertools.html#method.interleave_shortest)\n/// for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct InterleaveShortest<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    it0: I,\n    it1: J,\n    phase: bool, // false ==> it0, true ==> it1\n}\n\n/// Create a new `InterleaveShortest` iterator.\npub fn interleave_shortest<I, J>(a: I, b: J) -> InterleaveShortest<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    InterleaveShortest {\n        it0: a,\n        it1: b,\n        phase: false,\n    }\n}\n\nimpl<I, J> Iterator for InterleaveShortest<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    type Item = I::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let e = if self.phase { self.it1.next() } else { self.it0.next() };\n        if e.is_some() {\n            self.phase = !self.phase;\n        }\n        e\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (curr_hint, next_hint) = {\n            let it0_hint = self.it0.size_hint();\n            let it1_hint = self.it1.size_hint();\n            if self.phase {\n                (it1_hint, it0_hint)\n            } else {\n                (it0_hint, it1_hint)\n            }\n        };\n        let (curr_lower, curr_upper) = curr_hint;\n        let (next_lower, next_upper) = next_hint;\n        let (combined_lower, combined_upper) =\n            size_hint::mul_scalar(size_hint::min(curr_hint, next_hint), 2);\n        let lower =\n            if curr_lower > next_lower {\n                combined_lower + 1\n            } else {\n                combined_lower\n            };\n        let upper = {\n            let extra_elem = match (curr_upper, next_upper) {\n                (_, None) => false,\n                (None, Some(_)) => true,\n                (Some(curr_max), Some(next_max)) => curr_max > next_max,\n            };\n            if extra_elem {\n                combined_upper.and_then(|x| x.checked_add(1))\n            } else {\n                combined_upper\n            }\n        };\n        (lower, upper)\n    }\n}\n\n#[derive(Clone, Debug)]\n/// An iterator adaptor that allows putting back a single\n/// item to the front of the iterator.\n///\n/// Iterator element type is `I::Item`.\npub struct PutBack<I>\n    where I: Iterator\n{\n    top: Option<I::Item>,\n    iter: I,\n}\n\n/// Create an iterator where you can put back a single item\npub fn put_back<I>(iterable: I) -> PutBack<I::IntoIter>\n    where I: IntoIterator\n{\n    PutBack {\n        top: None,\n        iter: iterable.into_iter(),\n    }\n}\n\nimpl<I> PutBack<I>\n    where I: Iterator\n{\n    /// put back value `value` (builder method)\n    pub fn with_value(mut self, value: I::Item) -> Self {\n        self.put_back(value);\n        self\n    }\n\n    /// Split the `PutBack` into its parts.\n    #[inline]\n    pub fn into_parts(self) -> (Option<I::Item>, I) {\n        let PutBack{top, iter} = self;\n        (top, iter)\n    }\n\n    /// Put back a single value to the front of the iterator.\n    ///\n    /// If a value is already in the put back slot, it is overwritten.\n    #[inline]\n    pub fn put_back(&mut self, x: I::Item) {\n        self.top = Some(x)\n    }\n}\n\nimpl<I> Iterator for PutBack<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.top {\n            None => self.iter.next(),\n            ref mut some => some.take(),\n        }\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // Not ExactSizeIterator because size may be larger than usize\n        size_hint::add_scalar(self.iter.size_hint(), self.top.is_some() as usize)\n    }\n\n    fn count(self) -> usize {\n        self.iter.count() + (self.top.is_some() as usize)\n    }\n\n    fn last(self) -> Option<Self::Item> {\n        self.iter.last().or(self.top)\n    }\n\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        match self.top {\n            None => self.iter.nth(n),\n            ref mut some => {\n                if n == 0 {\n                    some.take()\n                } else {\n                    *some = None;\n                    self.iter.nth(n - 1)\n                }\n            }\n        }\n    }\n\n    fn all<G>(&mut self, mut f: G) -> bool\n        where G: FnMut(Self::Item) -> bool\n    {\n        if let Some(elt) = self.top.take() {\n            if !f(elt) {\n                return false;\n            }\n        }\n        self.iter.all(f)\n    }\n\n    fn fold<Acc, G>(mut self, init: Acc, mut f: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        let mut accum = init;\n        if let Some(elt) = self.top.take() {\n            accum = f(accum, elt);\n        }\n        self.iter.fold(accum, f)\n    }\n}\n\n#[derive(Debug, Clone)]\n/// An iterator adaptor that iterates over the cartesian product of\n/// the element sets of two iterators `I` and `J`.\n///\n/// Iterator element type is `(I::Item, J::Item)`.\n///\n/// See [`.cartesian_product()`](../trait.Itertools.html#method.cartesian_product) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Product<I, J>\n    where I: Iterator\n{\n    a: I,\n    a_cur: Option<I::Item>,\n    b: J,\n    b_orig: J,\n}\n\n/// Create a new cartesian product iterator\n///\n/// Iterator element type is `(I::Item, J::Item)`.\npub fn cartesian_product<I, J>(mut i: I, j: J) -> Product<I, J>\n    where I: Iterator,\n          J: Clone + Iterator,\n          I::Item: Clone\n{\n    Product {\n        a_cur: i.next(),\n        a: i,\n        b: j.clone(),\n        b_orig: j,\n    }\n}\n\nimpl<I, J> Iterator for Product<I, J>\n    where I: Iterator,\n          J: Clone + Iterator,\n          I::Item: Clone\n{\n    type Item = (I::Item, J::Item);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let elt_b = match self.b.next() {\n            None => {\n                self.b = self.b_orig.clone();\n                match self.b.next() {\n                    None => return None,\n                    Some(x) => {\n                        self.a_cur = self.a.next();\n                        x\n                    }\n                }\n            }\n            Some(x) => x\n        };\n        match self.a_cur {\n            None => None,\n            Some(ref a) => {\n                Some((a.clone(), elt_b))\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let has_cur = self.a_cur.is_some() as usize;\n        // Not ExactSizeIterator because size may be larger than usize\n        let (b_min, b_max) = self.b.size_hint();\n\n        // Compute a * b_orig + b for both lower and upper bound\n        size_hint::add(\n            size_hint::mul(self.a.size_hint(), self.b_orig.size_hint()),\n            (b_min * has_cur, b_max.map(move |x| x * has_cur)))\n    }\n\n    fn fold<Acc, G>(mut self, mut accum: Acc, mut f: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        // use a split loop to handle the loose a_cur as well as avoiding to\n        // clone b_orig at the end.\n        if let Some(mut a) = self.a_cur.take() {\n            let mut b = self.b;\n            loop {\n                accum = b.fold(accum, |acc, elt| f(acc, (a.clone(), elt)));\n\n                // we can only continue iterating a if we had a first element;\n                if let Some(next_a) = self.a.next() {\n                    b = self.b_orig.clone();\n                    a = next_a;\n                } else {\n                    break;\n                }\n            }\n        }\n        accum\n    }\n}\n\n/// A â€œmeta iterator adaptorâ€. Its closure receives a reference to the iterator\n/// and may pick off as many elements as it likes, to produce the next iterator element.\n///\n/// Iterator element type is *X*, if the return type of `F` is *Option\\<X\\>*.\n///\n/// See [`.batching()`](../trait.Itertools.html#method.batching) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Batching<I, F> {\n    f: F,\n    iter: I,\n}\n\nimpl<I, F> fmt::Debug for Batching<I, F> where I: fmt::Debug {\n    debug_fmt_fields!(Batching, iter);\n}\n\n/// Create a new Batching iterator.\npub fn batching<I, F>(iter: I, f: F) -> Batching<I, F> {\n    Batching { f, iter }\n}\n\nimpl<B, F, I> Iterator for Batching<I, F>\n    where I: Iterator,\n          F: FnMut(&mut I) -> Option<B>\n{\n    type Item = B;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        (self.f)(&mut self.iter)\n    }\n}\n\n/// An iterator adaptor that steps a number elements in the base iterator\n/// for each iteration.\n///\n/// The iterator steps by yielding the next element from the base iterator,\n/// then skipping forward *n-1* elements.\n///\n/// See [`.step()`](../trait.Itertools.html#method.step) for more information.\n#[deprecated(note=\"Use std .step_by() instead\", since=\"0.8.0\")]\n#[allow(deprecated)]\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Step<I> {\n    iter: Fuse<I>,\n    skip: usize,\n}\n\n/// Create a `Step` iterator.\n///\n/// **Panics** if the step is 0.\n#[allow(deprecated)]\npub fn step<I>(iter: I, step: usize) -> Step<I>\n    where I: Iterator\n{\n    assert!(step != 0);\n    Step {\n        iter: iter.fuse(),\n        skip: step - 1,\n    }\n}\n\n#[allow(deprecated)]\nimpl<I> Iterator for Step<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let elt = self.iter.next();\n        if self.skip > 0 {\n            self.iter.nth(self.skip - 1);\n        }\n        elt\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, high) = self.iter.size_hint();\n        let div = |x: usize| {\n            if x == 0 {\n                0\n            } else {\n                1 + (x - 1) / (self.skip + 1)\n            }\n        };\n        (div(low), high.map(div))\n    }\n}\n\n// known size\n#[allow(deprecated)]\nimpl<I> ExactSizeIterator for Step<I>\n    where I: ExactSizeIterator\n{}\n\npub trait MergePredicate<T> {\n    fn merge_pred(&mut self, a: &T, b: &T) -> bool;\n}\n\n#[derive(Clone)]\npub struct MergeLte;\n\nimpl<T: PartialOrd> MergePredicate<T> for MergeLte {\n    fn merge_pred(&mut self, a: &T, b: &T) -> bool {\n        a <= b\n    }\n}\n\n/// An iterator adaptor that merges the two base iterators in ascending order.\n/// If both base iterators are sorted (ascending), the result is sorted.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.merge()`](../trait.Itertools.html#method.merge_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub type Merge<I, J> = MergeBy<I, J, MergeLte>;\n\n/// Create an iterator that merges elements in `i` and `j`.\n///\n/// `IntoIterator` enabled version of `i.merge(j)`.\n///\n/// ```\n/// use itertools::merge;\n///\n/// for elt in merge(&[1, 2, 3], &[2, 3, 4]) {\n///     /* loop body */\n/// }\n/// ```\npub fn merge<I, J>(i: I, j: J) -> Merge<<I as IntoIterator>::IntoIter, <J as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>,\n          I::Item: PartialOrd\n{\n    merge_by_new(i, j, MergeLte)\n}\n\n/// An iterator adaptor that merges the two base iterators in ascending order.\n/// If both base iterators are sorted (ascending), the result is sorted.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.merge_by()`](../trait.Itertools.html#method.merge_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MergeBy<I, J, F>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    a: Peekable<I>,\n    b: Peekable<J>,\n    fused: Option<bool>,\n    cmp: F,\n}\n\nimpl<I, J, F> fmt::Debug for MergeBy<I, J, F>\n    where I: Iterator + fmt::Debug, J: Iterator<Item = I::Item> + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(MergeBy, a, b);\n}\n\nimpl<T, F: FnMut(&T, &T)->bool> MergePredicate<T> for F {\n    fn merge_pred(&mut self, a: &T, b: &T) -> bool {\n        self(a, b)\n    }\n}\n\n/// Create a `MergeBy` iterator.\npub fn merge_by_new<I, J, F>(a: I, b: J, cmp: F) -> MergeBy<I::IntoIter, J::IntoIter, F>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>,\n          F: MergePredicate<I::Item>,\n{\n    MergeBy {\n        a: a.into_iter().peekable(),\n        b: b.into_iter().peekable(),\n        fused: None,\n        cmp,\n    }\n}\n\nimpl<I, J, F> Clone for MergeBy<I, J, F>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>,\n          Peekable<I>: Clone,\n          Peekable<J>: Clone,\n          F: Clone\n{\n    clone_fields!(a, b, fused, cmp);\n}\n\nimpl<I, J, F> Iterator for MergeBy<I, J, F>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>,\n          F: MergePredicate<I::Item>\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let less_than = match self.fused {\n            Some(lt) => lt,\n            None => match (self.a.peek(), self.b.peek()) {\n                (Some(a), Some(b)) => self.cmp.merge_pred(a, b),\n                (Some(_), None) => {\n                    self.fused = Some(true);\n                    true\n                }\n                (None, Some(_)) => {\n                    self.fused = Some(false);\n                    false\n                }\n                (None, None) => return None,\n            }\n        };\n        if less_than {\n            self.a.next()\n        } else {\n            self.b.next()\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // Not ExactSizeIterator because size may be larger than usize\n        size_hint::add(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\n/// An iterator adaptor that borrows from a `Clone`-able iterator\n/// to only pick off elements while the predicate returns `true`.\n///\n/// See [`.take_while_ref()`](../trait.Itertools.html#method.take_while_ref) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct TakeWhileRef<'a, I: 'a, F> {\n    iter: &'a mut I,\n    f: F,\n}\n\nimpl<'a, I, F> fmt::Debug for TakeWhileRef<'a, I, F>\n    where I: Iterator + fmt::Debug,\n{\n    debug_fmt_fields!(TakeWhileRef, iter);\n}\n\n/// Create a new `TakeWhileRef` from a reference to clonable iterator.\npub fn take_while_ref<I, F>(iter: &mut I, f: F) -> TakeWhileRef<I, F>\n    where I: Iterator + Clone\n{\n    TakeWhileRef { iter, f }\n}\n\nimpl<'a, I, F> Iterator for TakeWhileRef<'a, I, F>\n    where I: Iterator + Clone,\n          F: FnMut(&I::Item) -> bool\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let old = self.iter.clone();\n        match self.iter.next() {\n            None => None,\n            Some(elt) => {\n                if (self.f)(&elt) {\n                    Some(elt)\n                } else {\n                    *self.iter = old;\n                    None\n                }\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, self.iter.size_hint().1)\n    }\n}\n\n/// An iterator adaptor that filters `Option<A>` iterator elements\n/// and produces `A`. Stops on the first `None` encountered.\n///\n/// See [`.while_some()`](../trait.Itertools.html#method.while_some) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct WhileSome<I> {\n    iter: I,\n}\n\n/// Create a new `WhileSome<I>`.\npub fn while_some<I>(iter: I) -> WhileSome<I> {\n    WhileSome { iter }\n}\n\nimpl<I, A> Iterator for WhileSome<I>\n    where I: Iterator<Item = Option<A>>\n{\n    type Item = A;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.iter.next() {\n            None | Some(None) => None,\n            Some(elt) => elt,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, self.iter.size_hint().1)\n    }\n}\n\n/// An iterator to iterate through all combinations in a `Clone`-able iterator that produces tuples\n/// of a specific size.\n///\n/// See [`.tuple_combinations()`](../trait.Itertools.html#method.tuple_combinations) for more\n/// information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct TupleCombinations<I, T>\n    where I: Iterator,\n          T: HasCombination<I>\n{\n    iter: T::Combination,\n    _mi: PhantomData<I>,\n    _mt: PhantomData<T>\n}\n\npub trait HasCombination<I>: Sized {\n    type Combination: From<I> + Iterator<Item = Self>;\n}\n\n/// Create a new `TupleCombinations` from a clonable iterator.\npub fn tuple_combinations<T, I>(iter: I) -> TupleCombinations<I, T>\n    where I: Iterator + Clone,\n          I::Item: Clone,\n          T: HasCombination<I>,\n{\n    TupleCombinations {\n        iter: T::Combination::from(iter),\n        _mi: PhantomData,\n        _mt: PhantomData,\n    }\n}\n\nimpl<I, T> Iterator for TupleCombinations<I, T>\n    where I: Iterator,\n          T: HasCombination<I>,\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next()\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct Tuple1Combination<I> {\n    iter: I,\n}\n\nimpl<I> From<I> for Tuple1Combination<I> {\n    fn from(iter: I) -> Self {\n        Tuple1Combination { iter }\n    }\n}\n\nimpl<I: Iterator> Iterator for Tuple1Combination<I> {\n    type Item = (I::Item,);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|x| (x,))\n    }\n}\n\nimpl<I: Iterator> HasCombination<I> for (I::Item,) {\n    type Combination = Tuple1Combination<I>;\n}\n\nmacro_rules! impl_tuple_combination {\n    ($C:ident $P:ident ; $A:ident, $($I:ident),* ; $($X:ident)*) => (\n        #[derive(Clone, Debug)]\n        pub struct $C<I: Iterator> {\n            item: Option<I::Item>,\n            iter: I,\n            c: $P<I>,\n        }\n\n        impl<I: Iterator + Clone> From<I> for $C<I> {\n            fn from(mut iter: I) -> Self {\n                $C {\n                    item: iter.next(),\n                    iter: iter.clone(),\n                    c: $P::from(iter),\n                }\n            }\n        }\n\n        impl<I: Iterator + Clone> From<I> for $C<Fuse<I>> {\n            fn from(iter: I) -> Self {\n                let mut iter = iter.fuse();\n                $C {\n                    item: iter.next(),\n                    iter: iter.clone(),\n                    c: $P::from(iter),\n                }\n            }\n        }\n\n        impl<I, $A> Iterator for $C<I>\n            where I: Iterator<Item = $A> + Clone,\n                  I::Item: Clone\n        {\n            type Item = ($($I),*);\n\n            fn next(&mut self) -> Option<Self::Item> {\n                if let Some(($($X),*,)) = self.c.next() {\n                    let z = self.item.clone().unwrap();\n                    Some((z, $($X),*))\n                } else {\n                    self.item = self.iter.next();\n                    self.item.clone().and_then(|z| {\n                        self.c = $P::from(self.iter.clone());\n                        self.c.next().map(|($($X),*,)| (z, $($X),*))\n                    })\n                }\n            }\n        }\n\n        impl<I, $A> HasCombination<I> for ($($I),*)\n            where I: Iterator<Item = $A> + Clone,\n                  I::Item: Clone\n        {\n            type Combination = $C<Fuse<I>>;\n        }\n    )\n}\n\n// This snippet generates the twelve `impl_tuple_combination!` invocations:\n//    use core::iter;\n//    use itertools::Itertools;\n//\n//    for i in 2..=12 {\n//        println!(\"impl_tuple_combination!(Tuple{arity}Combination Tuple{prev}Combination; {tys}; {idents});\",\n//            arity = i,\n//            prev = i - 1,\n//            tys = iter::repeat(\"A\").take(i + 1).join(\", \"),\n//            idents = ('a'..'z').take(i - 1).join(\" \"),\n//        );\n//    }\n// It could probably be replaced by a bit more macro cleverness.\nimpl_tuple_combination!(Tuple2Combination Tuple1Combination; A, A, A; a);\nimpl_tuple_combination!(Tuple3Combination Tuple2Combination; A, A, A, A; a b);\nimpl_tuple_combination!(Tuple4Combination Tuple3Combination; A, A, A, A, A; a b c);\nimpl_tuple_combination!(Tuple5Combination Tuple4Combination; A, A, A, A, A, A; a b c d);\nimpl_tuple_combination!(Tuple6Combination Tuple5Combination; A, A, A, A, A, A, A; a b c d e);\nimpl_tuple_combination!(Tuple7Combination Tuple6Combination; A, A, A, A, A, A, A, A; a b c d e f);\nimpl_tuple_combination!(Tuple8Combination Tuple7Combination; A, A, A, A, A, A, A, A, A; a b c d e f g);\nimpl_tuple_combination!(Tuple9Combination Tuple8Combination; A, A, A, A, A, A, A, A, A, A; a b c d e f g h);\nimpl_tuple_combination!(Tuple10Combination Tuple9Combination; A, A, A, A, A, A, A, A, A, A, A; a b c d e f g h i);\nimpl_tuple_combination!(Tuple11Combination Tuple10Combination; A, A, A, A, A, A, A, A, A, A, A, A; a b c d e f g h i j);\nimpl_tuple_combination!(Tuple12Combination Tuple11Combination; A, A, A, A, A, A, A, A, A, A, A, A, A; a b c d e f g h i j k);\n\n/// An iterator adapter to filter values within a nested `Result::Ok`.\n///\n/// See [`.filter_ok()`](../trait.Itertools.html#method.filter_ok) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct FilterOk<I, F> {\n    iter: I,\n    f: F\n}\n\n/// Create a new `FilterOk` iterator.\npub fn filter_ok<I, F, T, E>(iter: I, f: F) -> FilterOk<I, F>\n    where I: Iterator<Item = Result<T, E>>,\n          F: FnMut(&T) -> bool,\n{\n    FilterOk {\n        iter,\n        f,\n    }\n}\n\nimpl<I, F, T, E> Iterator for FilterOk<I, F>\n    where I: Iterator<Item = Result<T, E>>,\n          F: FnMut(&T) -> bool,\n{\n    type Item = Result<T, E>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            match self.iter.next() {\n                Some(Ok(v)) => {\n                    if (self.f)(&v) {\n                        return Some(Ok(v));\n                    }\n                },\n                Some(Err(e)) => return Some(Err(e)),\n                None => return None,\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, self.iter.size_hint().1)\n    }\n\n    fn fold<Acc, Fold>(self, init: Acc, fold_f: Fold) -> Acc\n        where Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n        let mut f = self.f;\n        self.iter.filter(|v| {\n            v.as_ref().map(&mut f).unwrap_or(true)\n        }).fold(init, fold_f)\n    }\n\n    fn collect<C>(self) -> C\n        where C: FromIterator<Self::Item>\n    {\n        let mut f = self.f;\n        self.iter.filter(|v| {\n            v.as_ref().map(&mut f).unwrap_or(true)\n        }).collect()\n    }\n}\n\n/// An iterator adapter to filter and apply a transformation on values within a nested `Result::Ok`.\n///\n/// See [`.filter_map_ok()`](../trait.Itertools.html#method.filter_map_ok) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct FilterMapOk<I, F> {\n    iter: I,\n    f: F\n}\n\nfn transpose_result<T, E>(result: Result<Option<T>, E>) -> Option<Result<T, E>> {\n    match result {\n        Ok(Some(v)) => Some(Ok(v)),\n        Ok(None) => None,\n        Err(e) => Some(Err(e)),\n    }\n}\n\n/// Create a new `FilterOk` iterator.\npub fn filter_map_ok<I, F, T, U, E>(iter: I, f: F) -> FilterMapOk<I, F>\n    where I: Iterator<Item = Result<T, E>>,\n          F: FnMut(T) -> Option<U>,\n{\n    FilterMapOk {\n        iter,\n        f,\n    }\n}\n\nimpl<I, F, T, U, E> Iterator for FilterMapOk<I, F>\n    where I: Iterator<Item = Result<T, E>>,\n          F: FnMut(T) -> Option<U>,\n{\n    type Item = Result<U, E>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            match self.iter.next() {\n                Some(Ok(v)) => {\n                    if let Some(v) = (self.f)(v) {\n                        return Some(Ok(v));\n                    }\n                },\n                Some(Err(e)) => return Some(Err(e)),\n                None => return None,\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, self.iter.size_hint().1)\n    }\n\n    fn fold<Acc, Fold>(self, init: Acc, fold_f: Fold) -> Acc\n        where Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n        let mut f = self.f;\n        self.iter.filter_map(|v| {\n            transpose_result(v.map(&mut f))\n        }).fold(init, fold_f)\n    }\n\n    fn collect<C>(self) -> C\n        where C: FromIterator<Self::Item>\n    {\n        let mut f = self.f;\n        self.iter.filter_map(|v| {\n            transpose_result(v.map(&mut f))\n        }).collect()\n    }\n}\n\n/// An iterator adapter to get the positions of each element that matches a predicate.\n///\n/// See [`.positions()`](../trait.Itertools.html#method.positions) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Positions<I, F> {\n    iter: I,\n    f: F,\n    count: usize,\n}\n\n/// Create a new `Positions` iterator.\npub fn positions<I, F>(iter: I, f: F) -> Positions<I, F>\n    where I: Iterator,\n          F: FnMut(I::Item) -> bool,\n{\n    Positions {\n        iter,\n        f,\n        count: 0\n    }\n}\n\nimpl<I, F> Iterator for Positions<I, F>\n    where I: Iterator,\n          F: FnMut(I::Item) -> bool,\n{\n    type Item = usize;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.next() {\n            let i = self.count;\n            self.count = i + 1;\n            if (self.f)(v) {\n                return Some(i);\n            }\n        }\n        None\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, self.iter.size_hint().1)\n    }\n}\n\nimpl<I, F> DoubleEndedIterator for Positions<I, F>\n    where I: DoubleEndedIterator + ExactSizeIterator,\n          F: FnMut(I::Item) -> bool,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.next_back() {\n            if (self.f)(v) {\n                return Some(self.count + self.iter.len())\n            }\n        }\n        None\n    }\n}\n\n/// An iterator adapter to apply a mutating function to each element before yielding it.\n///\n/// See [`.update()`](../trait.Itertools.html#method.update) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Update<I, F> {\n    iter: I,\n    f: F,\n}\n\n/// Create a new `Update` iterator.\npub fn update<I, F>(iter: I, f: F) -> Update<I, F>\nwhere\n    I: Iterator,\n    F: FnMut(&mut I::Item),\n{\n    Update { iter, f }\n}\n\nimpl<I, F> Iterator for Update<I, F>\nwhere\n    I: Iterator,\n    F: FnMut(&mut I::Item),\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if let Some(mut v) = self.iter.next() {\n            (self.f)(&mut v);\n            Some(v)\n        } else {\n            None\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        let mut f = self.f;\n        self.iter.fold(init, move |acc, mut v| { f(&mut v); g(acc, v) })\n    }\n\n    // if possible, re-use inner iterator specializations in collect\n    fn collect<C>(self) -> C\n        where C: FromIterator<Self::Item>\n    {\n        let mut f = self.f;\n        self.iter.map(move |mut v| { f(&mut v); v }).collect()\n    }\n}\n\nimpl<I, F> ExactSizeIterator for Update<I, F>\nwhere\n    I: ExactSizeIterator,\n    F: FnMut(&mut I::Item),\n{}\n\nimpl<I, F> DoubleEndedIterator for Update<I, F>\nwhere\n    I: DoubleEndedIterator,\n    F: FnMut(&mut I::Item),\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if let Some(mut v) = self.iter.next_back() {\n            (self.f)(&mut v);\n            Some(v)\n        } else {\n            None\n        }\n    }\n}\n"],["1059","#![cfg(feature = \"use_alloc\")]\n\nuse crate::size_hint;\nuse crate::Itertools;\n\nuse alloc::vec::Vec;\n\n#[derive(Clone)]\n/// An iterator adaptor that iterates over the cartesian product of\n/// multiple iterators of type `I`.\n///\n/// An iterator element type is `Vec<I>`.\n///\n/// See [`.multi_cartesian_product()`](../trait.Itertools.html#method.multi_cartesian_product)\n/// for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MultiProduct<I>(Vec<MultiProductIter<I>>)\n    where I: Iterator + Clone,\n          I::Item: Clone;\n\n/// Create a new cartesian product iterator over an arbitrary number\n/// of iterators of the same type.\n///\n/// Iterator element is of type `Vec<H::Item::Item>`.\npub fn multi_cartesian_product<H>(iters: H) -> MultiProduct<<H::Item as IntoIterator>::IntoIter>\n    where H: Iterator,\n          H::Item: IntoIterator,\n          <H::Item as IntoIterator>::IntoIter: Clone,\n          <H::Item as IntoIterator>::Item: Clone\n{\n    MultiProduct(iters.map(|i| MultiProductIter::new(i.into_iter())).collect())\n}\n\n#[derive(Clone, Debug)]\n/// Holds the state of a single iterator within a MultiProduct.\nstruct MultiProductIter<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    cur: Option<I::Item>,\n    iter: I,\n    iter_orig: I,\n}\n\n/// Holds the current state during an iteration of a MultiProduct.\n#[derive(Debug)]\nenum MultiProductIterState {\n    StartOfIter,\n    MidIter { on_first_iter: bool },\n}\n\nimpl<I> MultiProduct<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    /// Iterates the rightmost iterator, then recursively iterates iterators\n    /// to the left if necessary.\n    ///\n    /// Returns true if the iteration succeeded, else false.\n    fn iterate_last(\n        multi_iters: &mut [MultiProductIter<I>],\n        mut state: MultiProductIterState\n    ) -> bool {\n        use self::MultiProductIterState::*;\n\n        if let Some((last, rest)) = multi_iters.split_last_mut() {\n            let on_first_iter = match state {\n                StartOfIter => {\n                    let on_first_iter = !last.in_progress();\n                    state = MidIter { on_first_iter };\n                    on_first_iter\n                },\n                MidIter { on_first_iter } => on_first_iter\n            };\n\n            if !on_first_iter {\n                last.iterate();\n            }\n\n            if last.in_progress() {\n                true\n            } else if MultiProduct::iterate_last(rest, state) {\n                last.reset();\n                last.iterate();\n                // If iterator is None twice consecutively, then iterator is\n                // empty; whole product is empty.\n                last.in_progress()\n            } else {\n                false\n            }\n        } else {\n            // Reached end of iterator list. On initialisation, return true.\n            // At end of iteration (final iterator finishes), finish.\n            match state {\n                StartOfIter => false,\n                MidIter { on_first_iter } => on_first_iter\n            }\n        }\n    }\n\n    /// Returns the unwrapped value of the next iteration.\n    fn curr_iterator(&self) -> Vec<I::Item> {\n        self.0.iter().map(|multi_iter| {\n            multi_iter.cur.clone().unwrap()\n        }).collect()\n    }\n\n    /// Returns true if iteration has started and has not yet finished; false\n    /// otherwise.\n    fn in_progress(&self) -> bool {\n        if let Some(last) = self.0.last() {\n            last.in_progress()\n        } else {\n            false\n        }\n    }\n}\n\nimpl<I> MultiProductIter<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    fn new(iter: I) -> Self {\n        MultiProductIter {\n            cur: None,\n            iter: iter.clone(),\n            iter_orig: iter\n        }\n    }\n\n    /// Iterate the managed iterator.\n    fn iterate(&mut self) {\n        self.cur = self.iter.next();\n    }\n\n    /// Reset the managed iterator.\n    fn reset(&mut self) {\n        self.iter = self.iter_orig.clone();\n    }\n\n    /// Returns true if the current iterator has been started and has not yet\n    /// finished; false otherwise.\n    fn in_progress(&self) -> bool {\n        self.cur.is_some()\n    }\n}\n\nimpl<I> Iterator for MultiProduct<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    type Item = Vec<I::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if MultiProduct::iterate_last(\n            &mut self.0,\n            MultiProductIterState::StartOfIter\n        ) {\n            Some(self.curr_iterator())\n        } else {\n            None\n        }\n    }\n\n    fn count(self) -> usize {\n        if self.0.is_empty() {\n            return 0;\n        }\n\n        if !self.in_progress() {\n            return self.0.into_iter().fold(1, |acc, multi_iter| {\n                acc * multi_iter.iter.count()\n            });\n        }\n\n        self.0.into_iter().fold(\n            0,\n            |acc, MultiProductIter { iter, iter_orig, cur: _ }| {\n                let total_count = iter_orig.count();\n                let cur_count = iter.count();\n                acc * total_count + cur_count\n            }\n        )\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // Not ExactSizeIterator because size may be larger than usize\n        if self.0.is_empty() {\n            return (0, Some(0));\n        }\n\n        if !self.in_progress() {\n            return self.0.iter().fold((1, Some(1)), |acc, multi_iter| {\n                size_hint::mul(acc, multi_iter.iter.size_hint())\n            });\n        }\n\n        self.0.iter().fold(\n            (0, Some(0)),\n            |acc, &MultiProductIter { ref iter, ref iter_orig, cur: _ }| {\n                let cur_size = iter.size_hint();\n                let total_size = iter_orig.size_hint();\n                size_hint::add(size_hint::mul(acc, total_size), cur_size)\n            }\n        )\n    }\n\n    fn last(self) -> Option<Self::Item> {\n        let iter_count = self.0.len();\n\n        let lasts: Self::Item = self.0.into_iter()\n            .map(|multi_iter| multi_iter.iter.last())\n            .while_some()\n            .collect();\n\n        if lasts.len() == iter_count {\n            Some(lasts)\n        } else {\n            None\n        }\n    }\n}\n"],["1060","use std::fmt;\nuse std::iter::FusedIterator;\n\nuse crate::size_hint;\n\npub struct CoalesceBy<I, F, T>\nwhere\n    I: Iterator,\n{\n    iter: I,\n    last: Option<T>,\n    f: F,\n}\n\nimpl<I: Clone, F: Clone, T: Clone> Clone for CoalesceBy<I, F, T>\nwhere\n    I: Iterator,\n{\n    clone_fields!(last, iter, f);\n}\n\nimpl<I, F, T> fmt::Debug for CoalesceBy<I, F, T>\nwhere\n    I: Iterator + fmt::Debug,\n    T: fmt::Debug,\n{\n    debug_fmt_fields!(CoalesceBy, iter);\n}\n\npub trait CoalescePredicate<Item, T> {\n    fn coalesce_pair(&mut self, t: T, item: Item) -> Result<T, (T, T)>;\n}\n\nimpl<I, F, T> Iterator for CoalesceBy<I, F, T>\nwhere\n    I: Iterator,\n    F: CoalescePredicate<I::Item, T>,\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        // this fuses the iterator\n        let mut last = match self.last.take() {\n            None => return None,\n            Some(x) => x,\n        };\n        for next in &mut self.iter {\n            match self.f.coalesce_pair(last, next) {\n                Ok(joined) => last = joined,\n                Err((last_, next_)) => {\n                    self.last = Some(next_);\n                    return Some(last_);\n                }\n            }\n        }\n        Some(last)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, hi) = size_hint::add_scalar(self.iter.size_hint(), self.last.is_some() as usize);\n        ((low > 0) as usize, hi)\n    }\n\n    fn fold<Acc, FnAcc>(self, acc: Acc, mut fn_acc: FnAcc) -> Acc\n    where\n        FnAcc: FnMut(Acc, Self::Item) -> Acc,\n    {\n        if let Some(last) = self.last {\n            let mut f = self.f;\n            let (last, acc) = self.iter.fold((last, acc), |(last, acc), elt| {\n                match f.coalesce_pair(last, elt) {\n                    Ok(joined) => (joined, acc),\n                    Err((last_, next_)) => (next_, fn_acc(acc, last_)),\n                }\n            });\n            fn_acc(acc, last)\n        } else {\n            acc\n        }\n    }\n}\n\nimpl<I: Iterator, F: CoalescePredicate<I::Item, T>, T> FusedIterator for CoalesceBy<I, F, T> {}\n\n/// An iterator adaptor that may join together adjacent elements.\n///\n/// See [`.coalesce()`](../trait.Itertools.html#method.coalesce) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub type Coalesce<I, F> = CoalesceBy<I, F, <I as Iterator>::Item>;\n\nimpl<F, Item, T> CoalescePredicate<Item, T> for F\nwhere\n    F: FnMut(T, Item) -> Result<T, (T, T)>,\n{\n    fn coalesce_pair(&mut self, t: T, item: Item) -> Result<T, (T, T)> {\n        self(t, item)\n    }\n}\n\n/// Create a new `Coalesce`.\npub fn coalesce<I, F>(mut iter: I, f: F) -> Coalesce<I, F>\nwhere\n    I: Iterator,\n{\n    Coalesce {\n        last: iter.next(),\n        iter,\n        f,\n    }\n}\n\n/// An iterator adaptor that removes repeated duplicates, determining equality using a comparison function.\n///\n/// See [`.dedup_by()`](../trait.Itertools.html#method.dedup_by) or [`.dedup()`](../trait.Itertools.html#method.dedup) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub type DedupBy<I, Pred> = CoalesceBy<I, DedupPred2CoalescePred<Pred>, <I as Iterator>::Item>;\n\n#[derive(Clone)]\npub struct DedupPred2CoalescePred<DP>(DP);\n\npub trait DedupPredicate<T> {\n    // TODO replace by Fn(&T, &T)->bool once Rust supports it\n    fn dedup_pair(&mut self, a: &T, b: &T) -> bool;\n}\n\nimpl<DP, T> CoalescePredicate<T, T> for DedupPred2CoalescePred<DP>\nwhere\n    DP: DedupPredicate<T>,\n{\n    fn coalesce_pair(&mut self, t: T, item: T) -> Result<T, (T, T)> {\n        if self.0.dedup_pair(&t, &item) {\n            Ok(t)\n        } else {\n            Err((t, item))\n        }\n    }\n}\n\n#[derive(Clone)]\npub struct DedupEq;\n\nimpl<T: PartialEq> DedupPredicate<T> for DedupEq {\n    fn dedup_pair(&mut self, a: &T, b: &T) -> bool {\n        a == b\n    }\n}\n\nimpl<T, F: FnMut(&T, &T) -> bool> DedupPredicate<T> for F {\n    fn dedup_pair(&mut self, a: &T, b: &T) -> bool {\n        self(a, b)\n    }\n}\n\n/// Create a new `DedupBy`.\npub fn dedup_by<I, Pred>(mut iter: I, dedup_pred: Pred) -> DedupBy<I, Pred>\nwhere\n    I: Iterator,\n{\n    DedupBy {\n        last: iter.next(),\n        iter,\n        f: DedupPred2CoalescePred(dedup_pred),\n    }\n}\n\n/// An iterator adaptor that removes repeated duplicates.\n///\n/// See [`.dedup()`](../trait.Itertools.html#method.dedup) for more information.\npub type Dedup<I> = DedupBy<I, DedupEq>;\n\n/// Create a new `Dedup`.\npub fn dedup<I>(iter: I) -> Dedup<I>\nwhere\n    I: Iterator,\n{\n    dedup_by(iter, DedupEq)\n}\n\n/// An iterator adaptor that removes repeated duplicates, while keeping a count of how many\n/// repeated elements were present. This will determine equality using a comparison function.\n///\n/// See [`.dedup_by_with_count()`](../trait.Itertools.html#method.dedup_by_with_count) or\n/// [`.dedup_with_count()`](../trait.Itertools.html#method.dedup_with_count) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub type DedupByWithCount<I, Pred> =\n    CoalesceBy<I, DedupPredWithCount2CoalescePred<Pred>, (usize, <I as Iterator>::Item)>;\n\n#[derive(Clone)]\npub struct DedupPredWithCount2CoalescePred<DP>(DP);\n\nimpl<DP, T> CoalescePredicate<T, (usize, T)> for DedupPredWithCount2CoalescePred<DP>\nwhere\n    DP: DedupPredicate<T>,\n{\n    fn coalesce_pair(\n        &mut self,\n        (c, t): (usize, T),\n        item: T,\n    ) -> Result<(usize, T), ((usize, T), (usize, T))> {\n        if self.0.dedup_pair(&t, &item) {\n            Ok((c + 1, t))\n        } else {\n            Err(((c, t), (1, item)))\n        }\n    }\n}\n\n/// An iterator adaptor that removes repeated duplicates, while keeping a count of how many\n/// repeated elements were present.\n///\n/// See [`.dedup_with_count()`](../trait.Itertools.html#method.dedup_with_count) for more information.\npub type DedupWithCount<I> = DedupByWithCount<I, DedupEq>;\n\n/// Create a new `DedupByWithCount`.\npub fn dedup_by_with_count<I, Pred>(mut iter: I, dedup_pred: Pred) -> DedupByWithCount<I, Pred>\nwhere\n    I: Iterator,\n{\n    DedupByWithCount {\n        last: iter.next().map(|v| (1, v)),\n        iter,\n        f: DedupPredWithCount2CoalescePred(dedup_pred),\n    }\n}\n\n/// Create a new `DedupWithCount`.\npub fn dedup_with_count<I>(iter: I) -> DedupWithCount<I>\nwhere\n    I: Iterator,\n{\n    dedup_by_with_count(iter, DedupEq)\n}\n"],["1061","use std::iter::Peekable;\nuse crate::PutBack;\n#[cfg(feature = \"use_alloc\")]\nuse crate::PutBackN;\n\n/// An iterator that allows peeking at an element before deciding to accept it.\n///\n/// See [`.peeking_take_while()`](trait.Itertools.html#method.peeking_take_while)\n/// for more information.\n///\n/// This is implemented by peeking adaptors like peekable and put back,\n/// but also by a few iterators that can be peeked natively, like the sliceâ€™s\n/// by reference iterator (`std::slice::Iter`).\npub trait PeekingNext : Iterator {\n    /// Pass a reference to the next iterator element to the closure `accept`;\n    /// if `accept` returns true, return it as the next element,\n    /// else None.\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool;\n}\n\nimpl<I> PeekingNext for Peekable<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if let Some(r) = self.peek() {\n            if !accept(r) {\n                return None;\n            }\n        }\n        self.next()\n    }\n}\n\nimpl<I> PeekingNext for PutBack<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if let Some(r) = self.next() {\n            if !accept(&r) {\n                self.put_back(r);\n                return None;\n            }\n            Some(r)\n        } else {\n            None\n        }\n    }\n}\n\n#[cfg(feature = \"use_alloc\")]\nimpl<I> PeekingNext for PutBackN<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if let Some(r) = self.next() {\n            if !accept(&r) {\n                self.put_back(r);\n                return None;\n            }\n            Some(r)\n        } else {\n            None\n        }\n    }\n}\n\n/// An iterator adaptor that takes items while a closure returns `true`.\n///\n/// See [`.peeking_take_while()`](../trait.Itertools.html#method.peeking_take_while)\n/// for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct PeekingTakeWhile<'a, I: 'a, F>\n    where I: Iterator,\n{\n    iter: &'a mut I,\n    f: F,\n}\n\n/// Create a PeekingTakeWhile\npub fn peeking_take_while<I, F>(iter: &mut I, f: F) -> PeekingTakeWhile<I, F>\n    where I: Iterator,\n{\n    PeekingTakeWhile {\n        iter,\n        f,\n    }\n}\n\nimpl<'a, I, F> Iterator for PeekingTakeWhile<'a, I, F>\n    where I: PeekingNext,\n          F: FnMut(&I::Item) -> bool,\n\n{\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.peeking_next(&mut self.f)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, self.iter.size_hint().1)\n    }\n}\n\n// Some iterators are so lightweight we can simply clone them to save their\n// state and use that for peeking.\nmacro_rules! peeking_next_by_clone {\n    ([$($typarm:tt)*] $type_:ty) => {\n        impl<$($typarm)*> PeekingNext for $type_ {\n            fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n                where F: FnOnce(&Self::Item) -> bool\n            {\n                let saved_state = self.clone();\n                if let Some(r) = self.next() {\n                    if !accept(&r) {\n                        *self = saved_state;\n                    } else {\n                        return Some(r)\n                    }\n                }\n                None\n            }\n        }\n    }\n}\n\npeeking_next_by_clone! { ['a, T] ::std::slice::Iter<'a, T> }\npeeking_next_by_clone! { ['a] ::std::str::Chars<'a> }\npeeking_next_by_clone! { ['a] ::std::str::CharIndices<'a> }\npeeking_next_by_clone! { ['a] ::std::str::Bytes<'a> }\npeeking_next_by_clone! { ['a, T] ::std::option::Iter<'a, T> }\npeeking_next_by_clone! { ['a, T] ::std::result::Iter<'a, T> }\npeeking_next_by_clone! { [T] ::std::iter::Empty<T> }\n#[cfg(feature = \"use_alloc\")]\npeeking_next_by_clone! { ['a, T] alloc::collections::linked_list::Iter<'a, T> }\n#[cfg(feature = \"use_alloc\")]\npeeking_next_by_clone! { ['a, T] alloc::collections::vec_deque::Iter<'a, T> }\n\n// cloning a Rev has no extra overhead; peekable and put backs are never DEI.\npeeking_next_by_clone! { [I: Clone + PeekingNext + DoubleEndedIterator]\n                         ::std::iter::Rev<I> }\n"],["1062","//! \n//! Implementation's internal macros\n\nmacro_rules! debug_fmt_fields {\n    ($tyname:ident, $($($field:ident).+),*) => {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            f.debug_struct(stringify!($tyname))\n                $(\n              .field(stringify!($($field).+), &self.$($field).+)\n              )*\n              .finish()\n        }\n    }\n}\n\nmacro_rules! clone_fields {\n    ($($field:ident),*) => {\n        fn clone(&self) -> Self {\n            Self {\n                $($field: self.$field.clone(),)*\n            }\n        }\n    }\n}\n"],["1063","use super::size_hint;\n\nuse std::cell::RefCell;\nuse alloc::collections::VecDeque;\nuse alloc::rc::Rc;\n\n/// Common buffer object for the two tee halves\n#[derive(Debug)]\nstruct TeeBuffer<A, I> {\n    backlog: VecDeque<A>,\n    iter: I,\n    /// The owner field indicates which id should read from the backlog\n    owner: bool,\n}\n\n/// One half of an iterator pair where both return the same elements.\n///\n/// See [`.tee()`](../trait.Itertools.html#method.tee) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct Tee<I>\n    where I: Iterator\n{\n    rcbuffer: Rc<RefCell<TeeBuffer<I::Item, I>>>,\n    id: bool,\n}\n\npub fn new<I>(iter: I) -> (Tee<I>, Tee<I>)\n    where I: Iterator\n{\n    let buffer = TeeBuffer{backlog: VecDeque::new(), iter, owner: false};\n    let t1 = Tee{rcbuffer: Rc::new(RefCell::new(buffer)), id: true};\n    let t2 = Tee{rcbuffer: t1.rcbuffer.clone(), id: false};\n    (t1, t2)\n}\n\nimpl<I> Iterator for Tee<I>\n    where I: Iterator,\n          I::Item: Clone\n{\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        // .borrow_mut may fail here -- but only if the user has tied some kind of weird\n        // knot where the iterator refers back to itself.\n        let mut buffer = self.rcbuffer.borrow_mut();\n        if buffer.owner == self.id {\n            match buffer.backlog.pop_front() {\n                None => {}\n                some_elt => return some_elt,\n            }\n        }\n        match buffer.iter.next() {\n            None => None,\n            Some(elt) => {\n                buffer.backlog.push_back(elt.clone());\n                buffer.owner = !self.id;\n                Some(elt)\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let buffer = self.rcbuffer.borrow();\n        let sh = buffer.iter.size_hint();\n\n        if buffer.owner == self.id {\n            let log_len = buffer.backlog.len();\n            size_hint::add_scalar(sh, log_len)\n        } else {\n            sh\n        }\n    }\n}\n\nimpl<I> ExactSizeIterator for Tee<I>\n    where I: ExactSizeIterator,\n          I::Item: Clone\n{}\n"],["1064","\n/// `MinMaxResult` is an enum returned by `minmax`. See `Itertools::minmax()` for\n/// more detail.\n#[derive(Copy, Clone, PartialEq, Debug)]\npub enum MinMaxResult<T> {\n    /// Empty iterator\n    NoElements,\n\n    /// Iterator with one element, so the minimum and maximum are the same\n    OneElement(T),\n\n    /// More than one element in the iterator, the first element is not larger\n    /// than the second\n    MinMax(T, T)\n}\n\nimpl<T: Clone> MinMaxResult<T> {\n    /// `into_option` creates an `Option` of type `(T, T)`. The returned `Option`\n    /// has variant `None` if and only if the `MinMaxResult` has variant\n    /// `NoElements`. Otherwise `Some((x, y))` is returned where `x <= y`.\n    /// If the `MinMaxResult` has variant `OneElement(x)`, performing this\n    /// operation will make one clone of `x`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::MinMaxResult::{self, NoElements, OneElement, MinMax};\n    ///\n    /// let r: MinMaxResult<i32> = NoElements;\n    /// assert_eq!(r.into_option(), None);\n    ///\n    /// let r = OneElement(1);\n    /// assert_eq!(r.into_option(), Some((1, 1)));\n    ///\n    /// let r = MinMax(1, 2);\n    /// assert_eq!(r.into_option(), Some((1, 2)));\n    /// ```\n    pub fn into_option(self) -> Option<(T,T)> {\n        match self {\n            MinMaxResult::NoElements => None,\n            MinMaxResult::OneElement(x) => Some((x.clone(), x)),\n            MinMaxResult::MinMax(x, y) => Some((x, y))\n        }\n    }\n}\n\n/// Implementation guts for `minmax` and `minmax_by_key`.\npub fn minmax_impl<I, K, F, L>(mut it: I, mut key_for: F,\n                               mut lt: L) -> MinMaxResult<I::Item>\n    where I: Iterator,\n          F: FnMut(&I::Item) -> K,\n          L: FnMut(&I::Item, &I::Item, &K, &K) -> bool,\n{\n    let (mut min, mut max, mut min_key, mut max_key) = match it.next() {\n        None => return MinMaxResult::NoElements,\n        Some(x) => {\n            match it.next() {\n                None => return MinMaxResult::OneElement(x),\n                Some(y) => {\n                    let xk = key_for(&x);\n                    let yk = key_for(&y);\n                    if !lt(&y, &x, &yk, &xk) {(x, y, xk, yk)} else {(y, x, yk, xk)}\n                }\n            }\n        }\n    };\n\n    loop {\n        // `first` and `second` are the two next elements we want to look\n        // at.  We first compare `first` and `second` (#1). The smaller one\n        // is then compared to current minimum (#2). The larger one is\n        // compared to current maximum (#3). This way we do 3 comparisons\n        // for 2 elements.\n        let first = match it.next() {\n            None => break,\n            Some(x) => x\n        };\n        let second = match it.next() {\n            None => {\n                let first_key = key_for(&first);\n                if lt(&first, &min, &first_key, &min_key) {\n                    min = first;\n                } else if !lt(&first, &max, &first_key, &max_key) {\n                    max = first;\n                }\n                break;\n            }\n            Some(x) => x\n        };\n        let first_key = key_for(&first);\n        let second_key = key_for(&second);\n        if !lt(&second, &first, &second_key, &first_key) {\n            if lt(&first, &min, &first_key, &min_key) {\n                min = first;\n                min_key = first_key;\n            }\n            if !lt(&second, &max, &second_key, &max_key) {\n                max = second;\n                max_key = second_key;\n            }\n        } else {\n            if lt(&second, &min, &second_key, &min_key) {\n                min = second;\n                min_key = second_key;\n            }\n            if !lt(&first, &max, &first_key, &max_key) {\n                max = first;\n                max_key = first_key;\n            }\n        }\n    }\n\n    MinMaxResult::MinMax(min, max)\n}\n"],["1065","//! Iterators that are sources (produce elements from parameters,\n//! not from another iterator).\n#![allow(deprecated)]\n\nuse std::fmt;\nuse std::mem;\n\n/// See [`repeat_call`](../fn.repeat_call.html) for more information.\n#[derive(Clone)]\n#[deprecated(note=\"Use std repeat_with() instead\", since=\"0.8.0\")]\npub struct RepeatCall<F> {\n    f: F,\n}\n\nimpl<F> fmt::Debug for RepeatCall<F>\n{\n    debug_fmt_fields!(RepeatCall, );\n}\n\n/// An iterator source that produces elements indefinitely by calling\n/// a given closure.\n///\n/// Iterator element type is the return type of the closure.\n///\n/// ```\n/// use itertools::repeat_call;\n/// use itertools::Itertools;\n/// use std::collections::BinaryHeap;\n///\n/// let mut heap = BinaryHeap::from(vec![2, 5, 3, 7, 8]);\n///\n/// // extract each element in sorted order\n/// for element in repeat_call(|| heap.pop()).while_some() {\n///     print!(\"{}\", element);\n/// }\n///\n/// itertools::assert_equal(\n///     repeat_call(|| 1).take(5),\n///     vec![1, 1, 1, 1, 1]\n/// );\n/// ```\n#[deprecated(note=\"Use std repeat_with() instead\", since=\"0.8.0\")]\npub fn repeat_call<F, A>(function: F) -> RepeatCall<F>\n    where F: FnMut() -> A\n{\n    RepeatCall { f: function }\n}\n\nimpl<A, F> Iterator for RepeatCall<F>\n    where F: FnMut() -> A\n{\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        Some((self.f)())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (usize::max_value(), None)\n    }\n}\n\n/// Creates a new unfold source with the specified closure as the \"iterator\n/// function\" and an initial state to eventually pass to the closure\n///\n/// `unfold` is a general iterator builder: it has a mutable state value,\n/// and a closure with access to the state that produces the next value.\n///\n/// This more or less equivalent to a regular struct with an `Iterator`\n/// implementation, and is useful for one-off iterators.\n///\n/// ```\n/// // an iterator that yields sequential Fibonacci numbers,\n/// // and stops at the maximum representable value.\n///\n/// use itertools::unfold;\n///\n/// let mut fibonacci = unfold((1u32, 1u32), |(x1, x2)| {\n///     // Attempt to get the next Fibonacci number\n///     let next = x1.saturating_add(*x2);\n///\n///     // Shift left: ret <- x1 <- x2 <- next\n///     let ret = *x1;\n///     *x1 = *x2;\n///     *x2 = next;\n///\n///     // If addition has saturated at the maximum, we are finished\n///     if ret == *x1 && ret > 1 {\n///         None\n///     } else {\n///         Some(ret)\n///     }\n/// });\n///\n/// itertools::assert_equal(fibonacci.by_ref().take(8),\n///                         vec![1, 1, 2, 3, 5, 8, 13, 21]);\n/// assert_eq!(fibonacci.last(), Some(2_971_215_073))\n/// ```\npub fn unfold<A, St, F>(initial_state: St, f: F) -> Unfold<St, F>\n    where F: FnMut(&mut St) -> Option<A>\n{\n    Unfold {\n        f,\n        state: initial_state,\n    }\n}\n\nimpl<St, F> fmt::Debug for Unfold<St, F>\n    where St: fmt::Debug,\n{\n    debug_fmt_fields!(Unfold, state);\n}\n\n/// See [`unfold`](../fn.unfold.html) for more information.\n#[derive(Clone)]\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\npub struct Unfold<St, F> {\n    f: F,\n    /// Internal state that will be passed to the closure on the next iteration\n    pub state: St,\n}\n\nimpl<A, St, F> Iterator for Unfold<St, F>\n    where F: FnMut(&mut St) -> Option<A>\n{\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        (self.f)(&mut self.state)\n    }\n}\n\n/// An iterator that infinitely applies function to value and yields results.\n///\n/// This `struct` is created by the [`iterate()`] function. See its documentation for more.\n///\n/// [`iterate()`]: ../fn.iterate.html\n#[derive(Clone)]\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\npub struct Iterate<St, F> {\n    state: St,\n    f: F,\n}\n\nimpl<St, F> fmt::Debug for Iterate<St, F>\n    where St: fmt::Debug,\n{\n    debug_fmt_fields!(Iterate, state);\n}\n\nimpl<St, F> Iterator for Iterate<St, F>\n    where F: FnMut(&St) -> St\n{\n    type Item = St;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let next_state = (self.f)(&self.state);\n        Some(mem::replace(&mut self.state, next_state))\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (usize::max_value(), None)\n    }\n}\n\n/// Creates a new iterator that infinitely applies function to value and yields results.\n///\n/// ```\n/// use itertools::iterate;\n///\n/// itertools::assert_equal(iterate(1, |&i| i * 3).take(5), vec![1, 3, 9, 27, 81]);\n/// ```\npub fn iterate<St, F>(initial_value: St, f: F) -> Iterate<St, F>\n    where F: FnMut(&St) -> St\n{\n    Iterate {\n        state: initial_value,\n        f,\n    }\n}\n"],["1066","use std::iter::Fuse;\nuse alloc::collections::VecDeque;\nuse crate::size_hint;\nuse crate::PeekingNext;\n\n/// See [`multipeek()`](../fn.multipeek.html) for more information.\n#[derive(Clone, Debug)]\npub struct MultiPeek<I>\n    where I: Iterator\n{\n    iter: Fuse<I>,\n    buf: VecDeque<I::Item>,\n    index: usize,\n}\n\n/// An iterator adaptor that allows the user to peek at multiple `.next()`\n/// values without advancing the base iterator.\npub fn multipeek<I>(iterable: I) -> MultiPeek<I::IntoIter>\n    where I: IntoIterator\n{\n    MultiPeek {\n        iter: iterable.into_iter().fuse(),\n        buf: VecDeque::new(),\n        index: 0,\n    }\n}\n\nimpl<I> MultiPeek<I>\n    where I: Iterator\n{\n    /// Reset the peeking â€œcursorâ€\n    pub fn reset_peek(&mut self) {\n        self.index = 0;\n    }\n}\n\nimpl<I: Iterator> MultiPeek<I> {\n    /// Works exactly like `.next()` with the only difference that it doesn't\n    /// advance itself. `.peek()` can be called multiple times, to peek\n    /// further ahead.\n    pub fn peek(&mut self) -> Option<&I::Item> {\n        let ret = if self.index < self.buf.len() {\n            Some(&self.buf[self.index])\n        } else {\n            match self.iter.next() {\n                Some(x) => {\n                    self.buf.push_back(x);\n                    Some(&self.buf[self.index])\n                }\n                None => return None,\n            }\n        };\n\n        self.index += 1;\n        ret\n    }\n}\n\nimpl<I> PeekingNext for MultiPeek<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if self.buf.is_empty() {\n            if let Some(r) = self.peek() {\n                if !accept(r) { return None }\n            }\n        } else {\n            if let Some(r) = self.buf.get(0) {\n                if !accept(r) { return None }\n            }\n        }\n        self.next()\n    }\n}\n\nimpl<I> Iterator for MultiPeek<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.index = 0;\n        self.buf.pop_front().or_else(|| self.iter.next())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.iter.size_hint(), self.buf.len())\n    }\n}\n\n// Same size\nimpl<I> ExactSizeIterator for MultiPeek<I>\n    where I: ExactSizeIterator\n{}\n\n\n"],["1067","use std::cmp::Ordering::{Equal, Greater, Less};\nuse super::size_hint;\nuse std::iter::Fuse;\n\nuse crate::either_or_both::EitherOrBoth;\n\n// ZipLongest originally written by SimonSapin,\n// and dedicated to itertools https://github.com/rust-lang/rust/pull/19283\n\n/// An iterator which iterates two other iterators simultaneously\n///\n/// This iterator is *fused*.\n///\n/// See [`.zip_longest()`](../trait.Itertools.html#method.zip_longest) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct ZipLongest<T, U> {\n    a: Fuse<T>,\n    b: Fuse<U>,\n}\n\n/// Create a new `ZipLongest` iterator.\npub fn zip_longest<T, U>(a: T, b: U) -> ZipLongest<T, U> \n    where T: Iterator,\n          U: Iterator\n{\n    ZipLongest {\n        a: a.fuse(),\n        b: b.fuse(),\n    }\n}\n\nimpl<T, U> Iterator for ZipLongest<T, U>\n    where T: Iterator,\n          U: Iterator\n{\n    type Item = EitherOrBoth<T::Item, U::Item>;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        match (self.a.next(), self.b.next()) {\n            (None, None) => None,\n            (Some(a), None) => Some(EitherOrBoth::Left(a)),\n            (None, Some(b)) => Some(EitherOrBoth::Right(b)),\n            (Some(a), Some(b)) => Some(EitherOrBoth::Both(a, b)),\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::max(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\nimpl<T, U> DoubleEndedIterator for ZipLongest<T, U>\n    where T: DoubleEndedIterator + ExactSizeIterator,\n          U: DoubleEndedIterator + ExactSizeIterator\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        match self.a.len().cmp(&self.b.len()) {\n            Equal => match (self.a.next_back(), self.b.next_back()) {\n                (None, None) => None,\n                (Some(a), Some(b)) => Some(EitherOrBoth::Both(a, b)),\n                // These can only happen if .len() is inconsistent with .next_back()\n                (Some(a), None) => Some(EitherOrBoth::Left(a)),\n                (None, Some(b)) => Some(EitherOrBoth::Right(b)),\n            },\n            Greater => self.a.next_back().map(EitherOrBoth::Left),\n            Less => self.b.next_back().map(EitherOrBoth::Right),\n        }\n    }\n}\n\nimpl<T, U> ExactSizeIterator for ZipLongest<T, U>\n    where T: ExactSizeIterator,\n          U: ExactSizeIterator\n{}\n"],["1068","use std::cell::{Cell, RefCell};\nuse alloc::vec::{self, Vec};\n\n/// A trait to unify FnMut for GroupBy with the chunk key in IntoChunks\ntrait KeyFunction<A> {\n    type Key;\n    fn call_mut(&mut self, arg: A) -> Self::Key;\n}\n\nimpl<'a, A, K, F: ?Sized> KeyFunction<A> for F\n    where F: FnMut(A) -> K\n{\n    type Key = K;\n    #[inline]\n    fn call_mut(&mut self, arg: A) -> Self::Key {\n        (*self)(arg)\n    }\n}\n\n\n/// ChunkIndex acts like the grouping key function for IntoChunks\n#[derive(Debug)]\nstruct ChunkIndex {\n    size: usize,\n    index: usize,\n    key: usize,\n}\n\nimpl ChunkIndex {\n    #[inline(always)]\n    fn new(size: usize) -> Self {\n        ChunkIndex {\n            size,\n            index: 0,\n            key: 0,\n        }\n    }\n}\n\nimpl<'a, A> KeyFunction<A> for ChunkIndex {\n    type Key = usize;\n    #[inline(always)]\n    fn call_mut(&mut self, _arg: A) -> Self::Key {\n        if self.index == self.size {\n            self.key += 1;\n            self.index = 0;\n        }\n        self.index += 1;\n        self.key\n    }\n}\n\n\nstruct GroupInner<K, I, F>\n    where I: Iterator\n{\n    key: F,\n    iter: I,\n    current_key: Option<K>,\n    current_elt: Option<I::Item>,\n    /// flag set if iterator is exhausted\n    done: bool,\n    /// Index of group we are currently buffering or visiting\n    top_group: usize,\n    /// Least index for which we still have elements buffered\n    oldest_buffered_group: usize,\n    /// Group index for `buffer[0]` -- the slots\n    /// bottom_group..oldest_buffered_group are unused and will be erased when\n    /// that range is large enough.\n    bottom_group: usize,\n    /// Buffered groups, from `bottom_group` (index 0) to `top_group`.\n    buffer: Vec<vec::IntoIter<I::Item>>,\n    /// index of last group iter that was dropped, usize::MAX == none\n    dropped_group: usize,\n}\n\nimpl<K, I, F> GroupInner<K, I, F>\n    where I: Iterator,\n          F: for<'a> KeyFunction<&'a I::Item, Key=K>,\n          K: PartialEq,\n{\n    /// `client`: Index of group that requests next element\n    #[inline(always)]\n    fn step(&mut self, client: usize) -> Option<I::Item> {\n        /*\n        println!(\"client={}, bottom_group={}, oldest_buffered_group={}, top_group={}, buffers=[{}]\",\n                 client, self.bottom_group, self.oldest_buffered_group,\n                 self.top_group,\n                 self.buffer.iter().map(|elt| elt.len()).format(\", \"));\n        */\n        if client < self.oldest_buffered_group {\n            None\n        } else if client < self.top_group ||\n            (client == self.top_group &&\n             self.buffer.len() > self.top_group - self.bottom_group)\n        {\n            self.lookup_buffer(client)\n        } else if self.done {\n            None\n        } else if self.top_group == client {\n            self.step_current()\n        } else {\n            self.step_buffering(client)\n        }\n    }\n\n    #[inline(never)]\n    fn lookup_buffer(&mut self, client: usize) -> Option<I::Item> {\n        // if `bufidx` doesn't exist in self.buffer, it might be empty\n        let bufidx = client - self.bottom_group;\n        if client < self.oldest_buffered_group {\n            return None;\n        }\n        let elt = self.buffer.get_mut(bufidx).and_then(|queue| queue.next());\n        if elt.is_none() && client == self.oldest_buffered_group {\n            // FIXME: VecDeque is unfortunately not zero allocation when empty,\n            // so we do this job manually.\n            // `bottom_group..oldest_buffered_group` is unused, and if it's large enough, erase it.\n            self.oldest_buffered_group += 1;\n            // skip forward further empty queues too\n            while self.buffer.get(self.oldest_buffered_group - self.bottom_group)\n                             .map_or(false, |buf| buf.len() == 0)\n            {\n                self.oldest_buffered_group += 1;\n            }\n\n            let nclear = self.oldest_buffered_group - self.bottom_group;\n            if nclear > 0 && nclear >= self.buffer.len() / 2 {\n                let mut i = 0;\n                self.buffer.retain(|buf| {\n                    i += 1;\n                    debug_assert!(buf.len() == 0 || i > nclear);\n                    i > nclear\n                });\n                self.bottom_group = self.oldest_buffered_group;\n            }\n        }\n        elt\n    }\n\n    /// Take the next element from the iterator, and set the done\n    /// flag if exhausted. Must not be called after done.\n    #[inline(always)]\n    fn next_element(&mut self) -> Option<I::Item> {\n        debug_assert!(!self.done);\n        match self.iter.next() {\n            None => { self.done = true; None }\n            otherwise => otherwise,\n        }\n    }\n\n\n    #[inline(never)]\n    fn step_buffering(&mut self, client: usize) -> Option<I::Item> {\n        // requested a later group -- walk through the current group up to\n        // the requested group index, and buffer the elements (unless\n        // the group is marked as dropped).\n        // Because the `Groups` iterator is always the first to request\n        // each group index, client is the next index efter top_group.\n        debug_assert!(self.top_group + 1 == client);\n        let mut group = Vec::new();\n\n        if let Some(elt) = self.current_elt.take() {\n            if self.top_group != self.dropped_group {\n                group.push(elt);\n            }\n        }\n        let mut first_elt = None; // first element of the next group\n\n        while let Some(elt) = self.next_element() {\n            let key = self.key.call_mut(&elt);\n            match self.current_key.take() {\n                None => {}\n                Some(old_key) => if old_key != key {\n                    self.current_key = Some(key);\n                    first_elt = Some(elt);\n                    break;\n                },\n            }\n            self.current_key = Some(key);\n            if self.top_group != self.dropped_group {\n                group.push(elt);\n            }\n        }\n\n        if self.top_group != self.dropped_group {\n            self.push_next_group(group);\n        }\n        if first_elt.is_some() {\n            self.top_group += 1;\n            debug_assert!(self.top_group == client);\n        }\n        first_elt\n    }\n\n    fn push_next_group(&mut self, group: Vec<I::Item>) {\n        // When we add a new buffered group, fill up slots between oldest_buffered_group and top_group\n        while self.top_group - self.bottom_group > self.buffer.len() {\n            if self.buffer.is_empty() {\n                self.bottom_group += 1;\n                self.oldest_buffered_group += 1;\n            } else {\n                self.buffer.push(Vec::new().into_iter());\n            }\n        }\n        self.buffer.push(group.into_iter());\n        debug_assert!(self.top_group + 1 - self.bottom_group == self.buffer.len());\n    }\n\n    /// This is the immediate case, where we use no buffering\n    #[inline]\n    fn step_current(&mut self) -> Option<I::Item> {\n        debug_assert!(!self.done);\n        if let elt @ Some(..) = self.current_elt.take() {\n            return elt;\n        }\n        match self.next_element() {\n            None => None,\n            Some(elt) => {\n                let key = self.key.call_mut(&elt);\n                match self.current_key.take() {\n                    None => {}\n                    Some(old_key) => if old_key != key {\n                        self.current_key = Some(key);\n                        self.current_elt = Some(elt);\n                        self.top_group += 1;\n                        return None;\n                    },\n                }\n                self.current_key = Some(key);\n                Some(elt)\n            }\n        }\n    }\n\n    /// Request the just started groups' key.\n    ///\n    /// `client`: Index of group\n    ///\n    /// **Panics** if no group key is available.\n    fn group_key(&mut self, client: usize) -> K {\n        // This can only be called after we have just returned the first\n        // element of a group.\n        // Perform this by simply buffering one more element, grabbing the\n        // next key.\n        debug_assert!(!self.done);\n        debug_assert!(client == self.top_group);\n        debug_assert!(self.current_key.is_some());\n        debug_assert!(self.current_elt.is_none());\n        let old_key = self.current_key.take().unwrap();\n        if let Some(elt) = self.next_element() {\n            let key = self.key.call_mut(&elt);\n            if old_key != key {\n                self.top_group += 1;\n            }\n            self.current_key = Some(key);\n            self.current_elt = Some(elt);\n        }\n        old_key\n    }\n}\n\nimpl<K, I, F> GroupInner<K, I, F>\n    where I: Iterator,\n{\n    /// Called when a group is dropped\n    fn drop_group(&mut self, client: usize) {\n        // It's only useful to track the maximal index\n        if self.dropped_group == !0 || client > self.dropped_group {\n            self.dropped_group = client;\n        }\n    }\n}\n\n/// `GroupBy` is the storage for the lazy grouping operation.\n///\n/// If the groups are consumed in their original order, or if each\n/// group is dropped without keeping it around, then `GroupBy` uses\n/// no allocations. It needs allocations only if several group iterators\n/// are alive at the same time.\n///\n/// This type implements `IntoIterator` (it is **not** an iterator\n/// itself), because the group iterators need to borrow from this\n/// value. It should be stored in a local variable or temporary and\n/// iterated.\n///\n/// See [`.group_by()`](../trait.Itertools.html#method.group_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct GroupBy<K, I, F>\n    where I: Iterator,\n{\n    inner: RefCell<GroupInner<K, I, F>>,\n    // the group iterator's current index. Keep this in the main value\n    // so that simultaneous iterators all use the same state.\n    index: Cell<usize>,\n}\n\n/// Create a new\npub fn new<K, J, F>(iter: J, f: F) -> GroupBy<K, J::IntoIter, F>\n    where J: IntoIterator,\n          F: FnMut(&J::Item) -> K,\n{\n    GroupBy {\n        inner: RefCell::new(GroupInner {\n            key: f,\n            iter: iter.into_iter(),\n            current_key: None,\n            current_elt: None,\n            done: false,\n            top_group: 0,\n            oldest_buffered_group: 0,\n            bottom_group: 0,\n            buffer: Vec::new(),\n            dropped_group: !0,\n        }),\n        index: Cell::new(0),\n    }\n}\n\nimpl<K, I, F> GroupBy<K, I, F>\n    where I: Iterator,\n{\n    /// `client`: Index of group that requests next element\n    fn step(&self, client: usize) -> Option<I::Item>\n        where F: FnMut(&I::Item) -> K,\n              K: PartialEq,\n    {\n        self.inner.borrow_mut().step(client)\n    }\n\n    /// `client`: Index of group\n    fn drop_group(&self, client: usize) {\n        self.inner.borrow_mut().drop_group(client)\n    }\n}\n\nimpl<'a, K, I, F> IntoIterator for &'a GroupBy<K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n          F: FnMut(&I::Item) -> K,\n          K: PartialEq\n{\n    type Item = (K, Group<'a, K, I, F>);\n    type IntoIter = Groups<'a, K, I, F>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        Groups { parent: self }\n    }\n}\n\n\n/// An iterator that yields the Group iterators.\n///\n/// Iterator element type is `(K, Group)`:\n/// the group's key `K` and the group's iterator.\n///\n/// See [`.group_by()`](../trait.Itertools.html#method.group_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Groups<'a, K: 'a, I: 'a, F: 'a>\n    where I: Iterator,\n          I::Item: 'a\n{\n    parent: &'a GroupBy<K, I, F>,\n}\n\nimpl<'a, K, I, F> Iterator for Groups<'a, K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n          F: FnMut(&I::Item) -> K,\n          K: PartialEq\n{\n    type Item = (K, Group<'a, K, I, F>);\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let index = self.parent.index.get();\n        self.parent.index.set(index + 1);\n        let inner = &mut *self.parent.inner.borrow_mut();\n        inner.step(index).map(|elt| {\n            let key = inner.group_key(index);\n            (key, Group {\n                parent: self.parent,\n                index,\n                first: Some(elt),\n            })\n        })\n    }\n}\n\n/// An iterator for the elements in a single group.\n///\n/// Iterator element type is `I::Item`.\npub struct Group<'a, K: 'a, I: 'a, F: 'a>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    parent: &'a GroupBy<K, I, F>,\n    index: usize,\n    first: Option<I::Item>,\n}\n\nimpl<'a, K, I, F> Drop for Group<'a, K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    fn drop(&mut self) {\n        self.parent.drop_group(self.index);\n    }\n}\n\nimpl<'a, K, I, F> Iterator for Group<'a, K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n          F: FnMut(&I::Item) -> K,\n          K: PartialEq,\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if let elt @ Some(..) = self.first.take() {\n            return elt;\n        }\n        self.parent.step(self.index)\n    }\n}\n\n///// IntoChunks /////\n\n/// Create a new\npub fn new_chunks<J>(iter: J, size: usize) -> IntoChunks<J::IntoIter>\n    where J: IntoIterator,\n{\n    IntoChunks {\n        inner: RefCell::new(GroupInner {\n            key: ChunkIndex::new(size),\n            iter: iter.into_iter(),\n            current_key: None,\n            current_elt: None,\n            done: false,\n            top_group: 0,\n            oldest_buffered_group: 0,\n            bottom_group: 0,\n            buffer: Vec::new(),\n            dropped_group: !0,\n        }),\n        index: Cell::new(0),\n    }\n}\n\n\n/// `ChunkLazy` is the storage for a lazy chunking operation.\n///\n/// `IntoChunks` behaves just like `GroupBy`: it is iterable, and\n/// it only buffers if several chunk iterators are alive at the same time.\n///\n/// This type implements `IntoIterator` (it is **not** an iterator\n/// itself), because the chunk iterators need to borrow from this\n/// value. It should be stored in a local variable or temporary and\n/// iterated.\n///\n/// Iterator element type is `Chunk`, each chunk's iterator.\n///\n/// See [`.chunks()`](../trait.Itertools.html#method.chunks) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct IntoChunks<I>\n    where I: Iterator,\n{\n    inner: RefCell<GroupInner<usize, I, ChunkIndex>>,\n    // the chunk iterator's current index. Keep this in the main value\n    // so that simultaneous iterators all use the same state.\n    index: Cell<usize>,\n}\n\n\nimpl<I> IntoChunks<I>\n    where I: Iterator,\n{\n    /// `client`: Index of chunk that requests next element\n    fn step(&self, client: usize) -> Option<I::Item> {\n        self.inner.borrow_mut().step(client)\n    }\n\n    /// `client`: Index of chunk\n    fn drop_group(&self, client: usize) {\n        self.inner.borrow_mut().drop_group(client)\n    }\n}\n\nimpl<'a, I> IntoIterator for &'a IntoChunks<I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    type Item = Chunk<'a, I>;\n    type IntoIter = Chunks<'a, I>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        Chunks {\n            parent: self,\n        }\n    }\n}\n\n\n/// An iterator that yields the Chunk iterators.\n///\n/// Iterator element type is `Chunk`.\n///\n/// See [`.chunks()`](../trait.Itertools.html#method.chunks) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Chunks<'a, I: 'a>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    parent: &'a IntoChunks<I>,\n}\n\nimpl<'a, I> Iterator for Chunks<'a, I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    type Item = Chunk<'a, I>;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let index = self.parent.index.get();\n        self.parent.index.set(index + 1);\n        let inner = &mut *self.parent.inner.borrow_mut();\n        inner.step(index).map(|elt| {\n            Chunk {\n                parent: self.parent,\n                index,\n                first: Some(elt),\n            }\n        })\n    }\n}\n\n/// An iterator for the elements in a single chunk.\n///\n/// Iterator element type is `I::Item`.\npub struct Chunk<'a, I: 'a>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    parent: &'a IntoChunks<I>,\n    index: usize,\n    first: Option<I::Item>,\n}\n\nimpl<'a, I> Drop for Chunk<'a, I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    fn drop(&mut self) {\n        self.parent.drop_group(self.index);\n    }\n}\n\nimpl<'a, I> Iterator for Chunk<'a, I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if let elt @ Some(..) = self.first.take() {\n            return elt;\n        }\n        self.parent.step(self.index)\n    }\n}\n"],["1069","#[cfg(feature = \"use_std\")]\nuse std::error::Error;\nuse std::fmt::{Debug, Display, Formatter, Result as FmtResult};\n\nuse std::iter::ExactSizeIterator;\n\nuse either::Either;\n\nuse crate::size_hint;\n\n/// Iterator returned for the error case of `IterTools::exactly_one()`\n/// This iterator yields exactly the same elements as the input iterator.\n///\n/// During the execution of exactly_one the iterator must be mutated.  This wrapper\n/// effectively \"restores\" the state of the input iterator when it's handed back.\n///\n/// This is very similar to PutBackN except this iterator only supports 0-2 elements and does not\n/// use a `Vec`.\n#[derive(Clone)]\npub struct ExactlyOneError<I>\nwhere\n    I: Iterator,\n{\n    first_two: Option<Either<[I::Item; 2], I::Item>>,\n    inner: I,\n}\n\nimpl<I> ExactlyOneError<I>\nwhere\n    I: Iterator,\n{\n    /// Creates a new `ExactlyOneErr` iterator.\n    pub(crate) fn new(first_two: Option<Either<[I::Item; 2], I::Item>>, inner: I) -> Self {\n        Self { first_two, inner }\n    }\n\n    fn additional_len(&self) -> usize {\n        match self.first_two {\n            Some(Either::Left(_)) => 2,\n            Some(Either::Right(_)) => 1,\n            None => 0,\n        }\n    }\n}\n\nimpl<I> Iterator for ExactlyOneError<I>\nwhere\n    I: Iterator,\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.first_two.take() {\n            Some(Either::Left([first, second])) => {\n                self.first_two = Some(Either::Right(second));\n                Some(first)\n            },\n            Some(Either::Right(second)) => {\n                Some(second)\n            }\n            None => {\n                self.inner.next()\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.inner.size_hint(), self.additional_len())\n    }\n}\n\n\nimpl<I> ExactSizeIterator for ExactlyOneError<I> where I: ExactSizeIterator {}\n\nimpl<I> Display for ExactlyOneError<I> \n    where I: Iterator,\n{\n    fn fmt(&self, f: &mut Formatter) -> FmtResult {\n        let additional = self.additional_len();\n        if additional > 0 {\n            write!(f, \"got at least 2 elements when exactly one was expected\")\n        } else {\n            write!(f, \"got zero elements when exactly one was expected\")\n        }\n    }\n}\n\nimpl<I> Debug for ExactlyOneError<I> \n    where I: Iterator + Debug,\n          I::Item: Debug,\n{\n    fn fmt(&self, f: &mut Formatter) -> FmtResult {\n        match &self.first_two {\n            Some(Either::Left([first, second])) => {\n                write!(f, \"ExactlyOneError[First: {:?}, Second: {:?}, RemainingIter: {:?}]\", first, second, self.inner)\n            },\n            Some(Either::Right(second)) => {\n                write!(f, \"ExactlyOneError[Second: {:?}, RemainingIter: {:?}]\", second, self.inner)\n            }\n            None => {\n                write!(f, \"ExactlyOneError[RemainingIter: {:?}]\", self.inner)\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"use_std\")]\nimpl<I> Error for ExactlyOneError<I>  where I: Iterator + Debug, I::Item: Debug, {}\n\n\n"],["1070","//! Some iterator that produces tuples\n\nuse std::iter::Fuse;\nuse std::iter::Take;\nuse std::iter::Cycle;\nuse std::marker::PhantomData;\n\n// `HomogeneousTuple` is a public facade for `TupleCollect`, allowing\n// tuple-related methods to be used by clients in generic contexts, while\n// hiding the implementation details of `TupleCollect`.\n// See https://github.com/rust-itertools/itertools/issues/387\n\n/// Implemented for homogeneous tuples of size up to 4.\npub trait HomogeneousTuple\n    : TupleCollect\n{}\n\nimpl<T: TupleCollect> HomogeneousTuple for T {}\n\n/// An iterator over a incomplete tuple.\n///\n/// See [`.tuples()`](../trait.Itertools.html#method.tuples) and\n/// [`Tuples::into_buffer()`](struct.Tuples.html#method.into_buffer).\n#[derive(Clone, Debug)]\npub struct TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n    cur: usize,\n    buf: T::Buffer,\n}\n\nimpl<T> TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n    fn new(buf: T::Buffer) -> Self {\n        TupleBuffer {\n            cur: 0,\n            buf,\n        }\n    }\n}\n\nimpl<T> Iterator for TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n    type Item = T::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let s = self.buf.as_mut();\n        if let Some(ref mut item) = s.get_mut(self.cur) {\n            self.cur += 1;\n            item.take()\n        } else {\n            None\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let buffer = &self.buf.as_ref()[self.cur..];\n        let len = if buffer.is_empty() {\n            0\n        } else {\n            buffer.iter()\n                  .position(|x| x.is_none())\n                  .unwrap_or_else(|| buffer.len())\n        };\n        (len, Some(len))\n    }\n}\n\nimpl<T> ExactSizeIterator for TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n}\n\n/// An iterator that groups the items in tuples of a specific size.\n///\n/// See [`.tuples()`](../trait.Itertools.html#method.tuples) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    iter: Fuse<I>,\n    buf: T::Buffer,\n}\n\n/// Create a new tuples iterator.\npub fn tuples<I, T>(iter: I) -> Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    Tuples {\n        iter: iter.fuse(),\n        buf: Default::default(),\n    }\n}\n\nimpl<I, T> Iterator for Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        T::collect_from_iter(&mut self.iter, &mut self.buf)\n    }\n}\n\nimpl<I, T> Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    /// Return a buffer with the produced items that was not enough to be grouped in a tuple.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut iter = (0..5).tuples();\n    /// assert_eq!(Some((0, 1, 2)), iter.next());\n    /// assert_eq!(None, iter.next());\n    /// itertools::assert_equal(vec![3, 4], iter.into_buffer());\n    /// ```\n    pub fn into_buffer(self) -> TupleBuffer<T> {\n        TupleBuffer::new(self.buf)\n    }\n}\n\n\n/// An iterator over all contiguous windows that produces tuples of a specific size.\n///\n/// See [`.tuple_windows()`](../trait.Itertools.html#method.tuple_windows) for more\n/// information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Clone, Debug)]\npub struct TupleWindows<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    iter: I,\n    last: Option<T>,\n}\n\n/// Create a new tuple windows iterator.\npub fn tuple_windows<I, T>(mut iter: I) -> TupleWindows<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple,\n          T::Item: Clone\n{\n    use std::iter::once;\n\n    let mut last = None;\n    if T::num_items() != 1 {\n        // put in a duplicate item in front of the tuple; this simplifies\n        // .next() function.\n        if let Some(item) = iter.next() {\n            let iter = once(item.clone()).chain(once(item)).chain(&mut iter);\n            last = T::collect_from_iter_no_buf(iter);\n        }\n    }\n\n    TupleWindows {\n        last,\n        iter,\n    }\n}\n\nimpl<I, T> Iterator for TupleWindows<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple + Clone,\n          T::Item: Clone\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if T::num_items() == 1 {\n            return T::collect_from_iter_no_buf(&mut self.iter)\n        }\n        if let Some(ref mut last) = self.last {\n            if let Some(new) = self.iter.next() {\n                last.left_shift_push(new);\n                return Some(last.clone());\n            }\n        }\n        None\n    }\n}\n\n/// An iterator over all windows,wrapping back to the first elements when the\n/// window would otherwise exceed the length of the iterator, producing tuples\n/// of a specific size.\n///\n/// See [`.circular_tuple_windows()`](../trait.Itertools.html#method.circular_tuple_windows) for more\n/// information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct CircularTupleWindows<I, T: Clone>\n    where I: Iterator<Item = T::Item> + Clone,\n          T: TupleCollect + Clone\n{\n    iter: Take<TupleWindows<Cycle<I>, T>>,\n    phantom_data: PhantomData<T>\n}\n\npub fn circular_tuple_windows<I, T>(iter: I) -> CircularTupleWindows<I, T>\n    where I: Iterator<Item = T::Item> + Clone + ExactSizeIterator,\n          T: TupleCollect + Clone,\n          T::Item: Clone\n{\n    let len = iter.len();\n    let iter = tuple_windows(iter.cycle()).take(len);\n\n    CircularTupleWindows {\n        iter,\n        phantom_data: PhantomData{}\n    }\n}\n\nimpl<I, T> Iterator for CircularTupleWindows<I, T>\n    where I: Iterator<Item = T::Item> + Clone,\n          T: TupleCollect + Clone,\n          T::Item: Clone\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next()\n    }\n}\n\npub trait TupleCollect: Sized {\n    type Item;\n    type Buffer: Default + AsRef<[Option<Self::Item>]> + AsMut<[Option<Self::Item>]>;\n\n    fn collect_from_iter<I>(iter: I, buf: &mut Self::Buffer) -> Option<Self>\n        where I: IntoIterator<Item = Self::Item>;\n\n    fn collect_from_iter_no_buf<I>(iter: I) -> Option<Self>\n        where I: IntoIterator<Item = Self::Item>;\n\n    fn num_items() -> usize;\n\n    fn left_shift_push(&mut self, item: Self::Item);\n}\n\nmacro_rules! count_ident{\n    () => {0};\n    ($i0:ident, $($i:ident,)*) => {1 + count_ident!($($i,)*)};\n}\nmacro_rules! ignore_ident{\n    ($id:ident, $($t:tt)*) => {$($t)*};\n}\nmacro_rules! rev_for_each_ident{\n    ($m:ident, ) => {};\n    ($m:ident, $i0:ident, $($i:ident,)*) => {\n        rev_for_each_ident!($m, $($i,)*);\n        $m!($i0);\n    };\n}\n\nmacro_rules! impl_tuple_collect {\n    ($dummy:ident,) => {}; // stop\n    ($dummy:ident, $($Y:ident,)*) => (\n        impl_tuple_collect!($($Y,)*);\n        impl<A> TupleCollect for ($(ignore_ident!($Y, A),)*) {\n            type Item = A;\n            type Buffer = [Option<A>; count_ident!($($Y,)*) - 1];\n\n            #[allow(unused_assignments, unused_mut)]\n            fn collect_from_iter<I>(iter: I, buf: &mut Self::Buffer) -> Option<Self>\n                where I: IntoIterator<Item = A>\n            {\n                let mut iter = iter.into_iter();\n                $(\n                    let mut $Y = None;\n                )*\n\n                loop {\n                    $(\n                        $Y = iter.next();\n                        if $Y.is_none() {\n                            break\n                        }\n                    )*\n                    return Some(($($Y.unwrap()),*,))\n                }\n\n                let mut i = 0;\n                let mut s = buf.as_mut();\n                $(\n                    if i < s.len() {\n                        s[i] = $Y;\n                        i += 1;\n                    }\n                )*\n                return None;\n            }\n\n            fn collect_from_iter_no_buf<I>(iter: I) -> Option<Self>\n                where I: IntoIterator<Item = A>\n            {\n                let mut iter = iter.into_iter();\n\n                Some(($(\n                    { let $Y = iter.next()?; $Y },\n                )*))\n            }\n\n            fn num_items() -> usize {\n                count_ident!($($Y,)*)\n            }\n\n            fn left_shift_push(&mut self, mut item: A) {\n                use std::mem::replace;\n\n                let &mut ($(ref mut $Y),*,) = self;\n                macro_rules! replace_item{($i:ident) => {\n                    item = replace($i, item);\n                }};\n                rev_for_each_ident!(replace_item, $($Y,)*);\n                drop(item);\n            }\n        }\n    )\n}\nimpl_tuple_collect!(dummy, a, b, c, d, e, f, g, h, i, j, k, l,);\n"],["1071","use std::iter::Fuse;\nuse super::size_hint;\n\npub trait IntersperseElement<Item> {\n    fn generate(&mut self) -> Item;\n}\n\n#[derive(Debug, Clone)]\npub struct IntersperseElementSimple<Item>(Item);\n\nimpl<Item: Clone> IntersperseElement<Item> for IntersperseElementSimple<Item> {\n    fn generate(&mut self) -> Item {\n        self.0.clone()\n    }\n}\n\n/// An iterator adaptor to insert a particular value\n/// between each element of the adapted iterator.\n///\n/// Iterator element type is `I::Item`\n///\n/// This iterator is *fused*.\n///\n/// See [`.intersperse()`](../trait.Itertools.html#method.intersperse) for more information.\npub type Intersperse<I> = IntersperseWith<I, IntersperseElementSimple<<I as Iterator>::Item>>;\n\n/// Create a new Intersperse iterator\npub fn intersperse<I>(iter: I, elt: I::Item) -> Intersperse<I>\n    where I: Iterator,\n{\n    intersperse_with(iter, IntersperseElementSimple(elt))\n}\n\nimpl<Item, F: FnMut()->Item> IntersperseElement<Item> for F {\n    fn generate(&mut self) -> Item {\n        self()\n    }\n}\n\n/// An iterator adaptor to insert a particular value created by a function\n/// between each element of the adapted iterator.\n///\n/// Iterator element type is `I::Item`\n///\n/// This iterator is *fused*.\n///\n/// See [`.intersperse_with()`](../trait.Itertools.html#method.intersperse_with) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Clone, Debug)]\npub struct IntersperseWith<I, ElemF>\n    where I: Iterator,\n{\n    element: ElemF,\n    iter: Fuse<I>,\n    peek: Option<I::Item>,\n}\n\n/// Create a new IntersperseWith iterator\npub fn intersperse_with<I, ElemF>(iter: I, elt: ElemF) -> IntersperseWith<I, ElemF>\n    where I: Iterator,\n{\n    let mut iter = iter.fuse();\n    IntersperseWith {\n        peek: iter.next(),\n        iter,\n        element: elt,\n    }\n}\n\nimpl<I, ElemF> Iterator for IntersperseWith<I, ElemF>\n    where I: Iterator,\n          ElemF: IntersperseElement<I::Item>\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.peek.is_some() {\n            self.peek.take()\n        } else {\n            self.peek = self.iter.next();\n            if self.peek.is_some() {\n                Some(self.element.generate())\n            } else {\n                None\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // 2 * SH + { 1 or 0 }\n        let has_peek = self.peek.is_some() as usize;\n        let sh = self.iter.size_hint();\n        size_hint::add_scalar(size_hint::add(sh, sh), has_peek)\n    }\n\n    fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n        Self: Sized, F: FnMut(B, Self::Item) -> B,\n    {\n        let mut accum = init;\n\n        if let Some(x) = self.peek.take() {\n            accum = f(accum, x);\n        }\n\n        let element = &mut self.element;\n\n        self.iter.fold(accum,\n            |accum, x| {\n                let accum = f(accum, element.generate());\n                let accum = f(accum, x);\n                accum\n        })\n    }\n}\n"],["1072","use alloc::vec::Vec;\n\nuse crate::size_hint;\n\n/// An iterator adaptor that allows putting multiple\n/// items in front of the iterator.\n///\n/// Iterator element type is `I::Item`.\n#[derive(Debug, Clone)]\npub struct PutBackN<I: Iterator> {\n    top: Vec<I::Item>,\n    iter: I,\n}\n\n/// Create an iterator where you can put back multiple values to the front\n/// of the iteration.\n///\n/// Iterator element type is `I::Item`.\npub fn put_back_n<I>(iterable: I) -> PutBackN<I::IntoIter>\n    where I: IntoIterator\n{\n    PutBackN {\n        top: Vec::new(),\n        iter: iterable.into_iter(),\n    }\n}\n\nimpl<I: Iterator> PutBackN<I> {\n    /// Puts x in front of the iterator.\n    /// The values are yielded in order of the most recently put back\n    /// values first.\n    ///\n    /// ```rust\n    /// use itertools::put_back_n;\n    ///\n    /// let mut it = put_back_n(1..5);\n    /// it.next();\n    /// it.put_back(1);\n    /// it.put_back(0);\n    ///\n    /// assert!(itertools::equal(it, 0..5));\n    /// ```\n    #[inline]\n    pub fn put_back(&mut self, x: I::Item) {\n        self.top.push(x);\n    }\n}\n\nimpl<I: Iterator> Iterator for PutBackN<I> {\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.top.pop().or_else(|| self.iter.next())\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.iter.size_hint(), self.top.len())\n    }\n}\n\n"],["1073","use super::size_hint;\n\n/// An iterator which iterates two other iterators simultaneously\n///\n/// See [`.zip_eq()`](../trait.Itertools.html#method.zip_eq) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct ZipEq<I, J> {\n    a: I,\n    b: J,\n}\n\n/// Iterate `i` and `j` in lock step.\n///\n/// **Panics** if the iterators are not of the same length.\n///\n/// `IntoIterator` enabled version of `i.zip_eq(j)`.\n///\n/// ```\n/// use itertools::zip_eq;\n///\n/// let data = [1, 2, 3, 4, 5];\n/// for (a, b) in zip_eq(&data[..data.len() - 1], &data[1..]) {\n///     /* loop body */\n/// }\n/// ```\npub fn zip_eq<I, J>(i: I, j: J) -> ZipEq<I::IntoIter, J::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator\n{\n    ZipEq {\n        a: i.into_iter(),\n        b: j.into_iter(),\n    }\n}\n\nimpl<I, J> Iterator for ZipEq<I, J>\n    where I: Iterator,\n          J: Iterator\n{\n    type Item = (I::Item, J::Item);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match (self.a.next(), self.b.next()) {\n            (None, None) => None,\n            (Some(a), Some(b)) => Some((a, b)),\n            (None, Some(_)) | (Some(_), None) =>\n            panic!(\"itertools: .zip_eq() reached end of one iterator before the other\")\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::min(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\nimpl<I, J> ExactSizeIterator for ZipEq<I, J>\n    where I: ExactSizeIterator,\n          J: ExactSizeIterator\n{}\n"],["1074","\nuse std::iter::IntoIterator;\nuse alloc::rc::Rc;\nuse std::cell::RefCell;\n\n/// A wrapper for `Rc<RefCell<I>>`, that implements the `Iterator` trait.\n#[derive(Debug)]\npub struct RcIter<I> {\n    /// The boxed iterator.\n    pub rciter: Rc<RefCell<I>>,\n}\n\n/// Return an iterator inside a `Rc<RefCell<_>>` wrapper.\n///\n/// The returned `RcIter` can be cloned, and each clone will refer back to the\n/// same original iterator.\n///\n/// `RcIter` allows doing interesting things like using `.zip()` on an iterator with\n/// itself, at the cost of runtime borrow checking which may have a performance\n/// penalty.\n///\n/// Iterator element type is `Self::Item`.\n///\n/// ```\n/// use itertools::rciter;\n/// use itertools::zip;\n///\n/// // In this example a range iterator is created and we iterate it using\n/// // three separate handles (two of them given to zip).\n/// // We also use the IntoIterator implementation for `&RcIter`.\n///\n/// let mut iter = rciter(0..9);\n/// let mut z = zip(&iter, &iter);\n///\n/// assert_eq!(z.next(), Some((0, 1)));\n/// assert_eq!(z.next(), Some((2, 3)));\n/// assert_eq!(z.next(), Some((4, 5)));\n/// assert_eq!(iter.next(), Some(6));\n/// assert_eq!(z.next(), Some((7, 8)));\n/// assert_eq!(z.next(), None);\n/// ```\n///\n/// **Panics** in iterator methods if a borrow error is encountered in the\n/// iterator methods. It can only happen if the `RcIter` is reentered in\n/// `.next()`, i.e. if it somehow participates in an â€œiterator knotâ€\n/// where it is an adaptor of itself.\npub fn rciter<I>(iterable: I) -> RcIter<I::IntoIter>\n    where I: IntoIterator\n{\n    RcIter { rciter: Rc::new(RefCell::new(iterable.into_iter())) }\n}\n\nimpl<I> Clone for RcIter<I> {\n    #[inline]\n    clone_fields!(rciter);\n}\n\nimpl<A, I> Iterator for RcIter<I>\n    where I: Iterator<Item = A>\n{\n    type Item = A;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.rciter.borrow_mut().next()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // To work sanely with other API that assume they own an iterator,\n        // so it can't change in other places, we can't guarantee as much\n        // in our size_hint. Other clones may drain values under our feet.\n        (0, self.rciter.borrow().size_hint().1)\n    }\n}\n\nimpl<I> DoubleEndedIterator for RcIter<I>\n    where I: DoubleEndedIterator\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.rciter.borrow_mut().next_back()\n    }\n}\n\n/// Return an iterator from `&RcIter<I>` (by simply cloning it).\nimpl<'a, I> IntoIterator for &'a RcIter<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n    type IntoIter = RcIter<I>;\n\n    fn into_iter(self) -> RcIter<I> {\n        self.clone()\n    }\n}\n"],["1075","use std::ops::Index;\n\n#[derive(Debug, Clone)]\npub struct LazyBuffer<I: Iterator> {\n    pub it: I,\n    done: bool,\n    buffer: Vec<I::Item>,\n}\n\nimpl<I> LazyBuffer<I>\nwhere\n    I: Iterator,\n{\n    pub fn new(it: I) -> LazyBuffer<I> {\n        LazyBuffer {\n            it,\n            done: false,\n            buffer: Vec::new(),\n        }\n    }\n\n    pub fn len(&self) -> usize {\n        self.buffer.len()\n    }\n\n    pub fn is_done(&self) -> bool {\n        self.done\n    }\n\n    pub fn get_next(&mut self) -> bool {\n        if self.done {\n            return false;\n        }\n        let next_item = self.it.next();\n        match next_item {\n            Some(x) => {\n                self.buffer.push(x);\n                true\n            }\n            None => {\n                self.done = true;\n                false\n            }\n        }\n    }\n}\n\nimpl<I, J> Index<J> for LazyBuffer<I>\nwhere\n    I: Iterator,\n    I::Item: Sized,\n    Vec<I::Item>: Index<J>\n{\n    type Output = <Vec<I::Item> as Index<J>>::Output;\n\n    fn index(&self, _index: J) -> &Self::Output {\n        self.buffer.index(_index)\n    }\n}\n"],["1076","use crate::Itertools;\n\n/// Combine all an iterator's elements into one element by using `Extend`.\n///\n/// `IntoIterator`-enabled version of `.concat()`\n///\n/// This combinator will extend the first item with each of the rest of the\n/// items of the iterator. If the iterator is empty, the default value of\n/// `I::Item` is returned.\n///\n/// ```rust\n/// use itertools::concat;\n/// \n/// let input = vec![vec![1], vec![2, 3], vec![4, 5, 6]];\n/// assert_eq!(concat(input), vec![1, 2, 3, 4, 5, 6]);\n/// ```\npub fn concat<I>(iterable: I) -> I::Item\n    where I: IntoIterator,\n          I::Item: Extend<<<I as IntoIterator>::Item as IntoIterator>::Item> + IntoIterator + Default\n{\n    iterable.into_iter().fold1(|mut a, b| { a.extend(b); a }).unwrap_or_else(|| <_>::default())\n}\n"],["1077","use std::cmp::Ordering;\nuse std::iter::Fuse;\nuse std::fmt;\n\nuse super::adaptors::{PutBack, put_back};\nuse crate::either_or_both::EitherOrBoth;\n\n/// Return an iterator adaptor that merge-joins items from the two base iterators in ascending order.\n///\n/// See [`.merge_join_by()`](trait.Itertools.html#method.merge_join_by) for more information.\npub fn merge_join_by<I, J, F>(left: I, right: J, cmp_fn: F)\n    -> MergeJoinBy<I::IntoIter, J::IntoIter, F>\n    where I: IntoIterator,\n          J: IntoIterator,\n          F: FnMut(&I::Item, &J::Item) -> Ordering\n{\n    MergeJoinBy {\n        left: put_back(left.into_iter().fuse()),\n        right: put_back(right.into_iter().fuse()),\n        cmp_fn,\n    }\n}\n\n/// An iterator adaptor that merge-joins items from the two base iterators in ascending order.\n///\n/// See [`.merge_join_by()`](../trait.Itertools.html#method.merge_join_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MergeJoinBy<I: Iterator, J: Iterator, F> {\n    left: PutBack<Fuse<I>>,\n    right: PutBack<Fuse<J>>,\n    cmp_fn: F\n}\n\nimpl<I, J, F> Clone for MergeJoinBy<I, J, F>\n    where I: Iterator,\n          J: Iterator,\n          PutBack<Fuse<I>>: Clone,\n          PutBack<Fuse<J>>: Clone,\n          F: Clone,\n{\n    clone_fields!(left, right, cmp_fn);\n}\n\nimpl<I, J, F> fmt::Debug for MergeJoinBy<I, J, F>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n          J: Iterator + fmt::Debug,\n          J::Item: fmt::Debug,\n{\n    debug_fmt_fields!(MergeJoinBy, left, right);\n}\n\nimpl<I, J, F> Iterator for MergeJoinBy<I, J, F>\n    where I: Iterator,\n          J: Iterator,\n          F: FnMut(&I::Item, &J::Item) -> Ordering\n{\n    type Item = EitherOrBoth<I::Item, J::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match (self.left.next(), self.right.next()) {\n            (None, None) => None,\n            (Some(left), None) =>\n                Some(EitherOrBoth::Left(left)),\n            (None, Some(right)) =>\n                Some(EitherOrBoth::Right(right)),\n            (Some(left), Some(right)) => {\n                match (self.cmp_fn)(&left, &right) {\n                    Ordering::Equal =>\n                        Some(EitherOrBoth::Both(left, right)),\n                    Ordering::Less => {\n                        self.right.put_back(right);\n                        Some(EitherOrBoth::Left(left))\n                    },\n                    Ordering::Greater => {\n                        self.left.put_back(left);\n                        Some(EitherOrBoth::Right(right))\n                    }\n                }\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (a_lower, a_upper) = self.left.size_hint();\n        let (b_lower, b_upper) = self.right.size_hint();\n\n        let lower = ::std::cmp::max(a_lower, b_lower);\n\n        let upper = match (a_upper, b_upper) {\n            (Some(x), Some(y)) => x.checked_add(y),\n            _ => None,\n        };\n\n        (lower, upper)\n    }\n\n    fn count(mut self) -> usize {\n        let mut count = 0;\n        loop {\n            match (self.left.next(), self.right.next()) {\n                (None, None) => break count,\n                (Some(_left), None) => break count + 1 + self.left.into_parts().1.count(),\n                (None, Some(_right)) => break count + 1 + self.right.into_parts().1.count(),\n                (Some(left), Some(right)) => {\n                    count += 1;\n                    match (self.cmp_fn)(&left, &right) {\n                        Ordering::Equal => {}\n                        Ordering::Less => self.right.put_back(right),\n                        Ordering::Greater => self.left.put_back(left),\n                    }\n                }\n            }\n        }\n    }\n\n    fn last(mut self) -> Option<Self::Item> {\n        let mut previous_element = None;\n        loop {\n            match (self.left.next(), self.right.next()) {\n                (None, None) => break previous_element,\n                (Some(left), None) => {\n                    break Some(EitherOrBoth::Left(\n                        self.left.into_parts().1.last().unwrap_or(left),\n                    ))\n                }\n                (None, Some(right)) => {\n                    break Some(EitherOrBoth::Right(\n                        self.right.into_parts().1.last().unwrap_or(right),\n                    ))\n                }\n                (Some(left), Some(right)) => {\n                    previous_element = match (self.cmp_fn)(&left, &right) {\n                        Ordering::Equal => Some(EitherOrBoth::Both(left, right)),\n                        Ordering::Less => {\n                            self.right.put_back(right);\n                            Some(EitherOrBoth::Left(left))\n                        }\n                        Ordering::Greater => {\n                            self.left.put_back(left);\n                            Some(EitherOrBoth::Right(right))\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n        loop {\n            if n == 0 {\n                break self.next();\n            }\n            n -= 1;\n            match (self.left.next(), self.right.next()) {\n                (None, None) => break None,\n                (Some(_left), None) => break self.left.nth(n).map(EitherOrBoth::Left),\n                (None, Some(_right)) => break self.right.nth(n).map(EitherOrBoth::Right),\n                (Some(left), Some(right)) => match (self.cmp_fn)(&left, &right) {\n                    Ordering::Equal => {}\n                    Ordering::Less => self.right.put_back(right),\n                    Ordering::Greater => self.left.put_back(left),\n                },\n            }\n        }\n    }\n}\n"],["1078","use std::fmt;\nuse std::iter::once;\n\nuse super::lazy_buffer::LazyBuffer;\n\n/// An iterator adaptor that iterates through all the `k`-permutations of the\n/// elements from an iterator.\n///\n/// See [`.permutations()`](../trait.Itertools.html#method.permutations) for\n/// more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Permutations<I: Iterator> {\n    vals: LazyBuffer<I>,\n    state: PermutationState,\n}\n\nimpl<I> Clone for Permutations<I>\n    where I: Clone + Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(vals, state);\n}\n\n#[derive(Clone, Debug)]\nenum PermutationState {\n    StartUnknownLen {\n        k: usize,\n    },\n    OngoingUnknownLen {\n        k: usize,\n        min_n: usize,\n    },\n    Complete(CompleteState),\n    Empty,\n}\n\n#[derive(Clone, Debug)]\nenum CompleteState {\n    Start {\n        n: usize,\n        k: usize,\n    },\n    Ongoing {\n        indices: Vec<usize>,\n        cycles: Vec<usize>,\n    }\n}\n\nenum CompleteStateRemaining {\n    Known(usize),\n    Overflow,\n}\n\nimpl<I> fmt::Debug for Permutations<I>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Permutations, vals, state);\n}\n\npub fn permutations<I: Iterator>(iter: I, k: usize) -> Permutations<I> {\n    let mut vals = LazyBuffer::new(iter);\n\n    if k == 0 {\n        // Special case, yields single empty vec; `n` is irrelevant\n        let state = PermutationState::Complete(CompleteState::Start { n: 0, k: 0 });\n\n        return Permutations {\n            vals,\n            state\n        };\n    }\n\n    let mut enough_vals = true;\n\n    while vals.len() < k {\n        if !vals.get_next() {\n            enough_vals = false;\n            break;\n        }\n    }\n\n    let state = if enough_vals {\n        PermutationState::StartUnknownLen { k }\n    } else {\n        PermutationState::Empty\n    };\n\n    Permutations {\n        vals,\n        state\n    }\n}\n\nimpl<I> Iterator for Permutations<I>\nwhere\n    I: Iterator,\n    I::Item: Clone\n{\n    type Item = Vec<I::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.advance();\n\n        let &mut Permutations { ref vals, ref state } = self;\n\n        match state {\n            &PermutationState::StartUnknownLen { .. } => panic!(\"unexpected iterator state\"),\n            &PermutationState::OngoingUnknownLen { k, min_n } => {\n                let latest_idx = min_n - 1;\n                let indices = (0..(k - 1)).chain(once(latest_idx));\n\n                Some(indices.map(|i| vals[i].clone()).collect())\n            }\n            &PermutationState::Complete(CompleteState::Start { .. }) => None,\n            &PermutationState::Complete(CompleteState::Ongoing { ref indices, ref cycles }) => {\n                let k = cycles.len();\n\n                Some(indices[0..k].iter().map(|&i| vals[i].clone()).collect())\n            },\n            &PermutationState::Empty => None\n        }\n    }\n\n    fn count(self) -> usize {\n        let Permutations { vals, state } = self;\n\n        fn from_complete(complete_state: CompleteState) -> usize {\n            match complete_state.remaining() {\n                CompleteStateRemaining::Known(count) => count,\n                CompleteStateRemaining::Overflow => {\n                    panic!(\"Iterator count greater than usize::MAX\");\n                }\n            }\n        }\n\n        match state {\n            PermutationState::StartUnknownLen { k } => {\n                let n = vals.len() + vals.it.count();\n                let complete_state = CompleteState::Start { n, k };\n\n                from_complete(complete_state)\n            }\n            PermutationState::OngoingUnknownLen { k, min_n } => {\n                let prev_iteration_count = min_n - k + 1;\n                let n = vals.len() + vals.it.count();\n                let complete_state = CompleteState::Start { n, k };\n\n                from_complete(complete_state) - prev_iteration_count\n            },\n            PermutationState::Complete(state) => from_complete(state),\n            PermutationState::Empty => 0\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        match self.state {\n            PermutationState::StartUnknownLen { .. } |\n            PermutationState::OngoingUnknownLen { .. } => (0, None), // TODO can we improve this lower bound?\n            PermutationState::Complete(ref state) => match state.remaining() {\n                CompleteStateRemaining::Known(count) => (count, Some(count)),\n                CompleteStateRemaining::Overflow => (::std::usize::MAX, None)\n            }\n            PermutationState::Empty => (0, Some(0))\n        }\n    }\n}\n\nimpl<I> Permutations<I>\nwhere\n    I: Iterator,\n    I::Item: Clone\n{\n    fn advance(&mut self) {\n        let &mut Permutations { ref mut vals, ref mut state } = self;\n\n        *state = match state {\n            &mut PermutationState::StartUnknownLen { k } => {\n                PermutationState::OngoingUnknownLen { k, min_n: k }\n            }\n            &mut PermutationState::OngoingUnknownLen { k, min_n } => {\n                if vals.get_next() {\n                    PermutationState::OngoingUnknownLen { k, min_n: min_n + 1 }\n                } else {\n                    let n = min_n;\n                    let prev_iteration_count = n - k + 1;\n                    let mut complete_state = CompleteState::Start { n, k };\n\n                    // Advance the complete-state iterator to the correct point\n                    for _ in 0..(prev_iteration_count + 1) {\n                        complete_state.advance();\n                    }\n\n                    PermutationState::Complete(complete_state)\n                }\n            }\n            &mut PermutationState::Complete(ref mut state) => {\n                state.advance();\n\n                return;\n            }\n            &mut PermutationState::Empty => { return; }\n        };\n    }\n}\n\nimpl CompleteState {\n    fn advance(&mut self) {\n        *self = match self {\n            &mut CompleteState::Start { n, k } => {\n                let indices = (0..n).collect();\n                let cycles = ((n - k)..n).rev().collect();\n\n                CompleteState::Ongoing {\n                    cycles,\n                    indices\n                }\n            },\n            &mut CompleteState::Ongoing { ref mut indices, ref mut cycles } => {\n                let n = indices.len();\n                let k = cycles.len();\n\n                for i in (0..k).rev() {\n                    if cycles[i] == 0 {\n                        cycles[i] = n - i - 1;\n\n                        let to_push = indices.remove(i);\n                        indices.push(to_push);\n                    } else {\n                        let swap_index = n - cycles[i];\n                        indices.swap(i, swap_index);\n\n                        cycles[i] -= 1;\n                        return;\n                    }\n                }\n\n                CompleteState::Start { n, k }\n            }\n        }\n    }\n\n    fn remaining(&self) -> CompleteStateRemaining {\n        use self::CompleteStateRemaining::{Known, Overflow};\n\n        match self {\n            &CompleteState::Start { n, k } => {\n                if n < k {\n                    return Known(0);\n                }\n\n                let count: Option<usize> = (n - k + 1..n + 1).fold(Some(1), |acc, i| {\n                    acc.and_then(|acc| acc.checked_mul(i))\n                });\n\n                match count {\n                    Some(count) => Known(count),\n                    None => Overflow\n                }\n            }\n            &CompleteState::Ongoing { ref indices, ref cycles } => {\n                let mut count: usize = 0;\n\n                for (i, &c) in cycles.iter().enumerate() {\n                    let radix = indices.len() - i;\n                    let next_count = count.checked_mul(radix)\n                        .and_then(|count| count.checked_add(c));\n\n                    count = match next_count {\n                        Some(count) => count,\n                        None => { return Overflow; }\n                    };\n                }\n\n                Known(count)\n            }\n        }\n    }\n}\n"],["1079","use std::iter::Fuse;\nuse crate::size_hint;\n\n/// An iterator adaptor that pads a sequence to a minimum length by filling\n/// missing elements using a closure.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.pad_using()`](../trait.Itertools.html#method.pad_using) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct PadUsing<I, F> {\n    iter: Fuse<I>,\n    min: usize,\n    pos: usize,\n    filler: F,\n}\n\n/// Create a new **PadUsing** iterator.\npub fn pad_using<I, F>(iter: I, min: usize, filler: F) -> PadUsing<I, F>\n    where I: Iterator,\n          F: FnMut(usize) -> I::Item\n{\n    PadUsing {\n        iter: iter.fuse(),\n        min,\n        pos: 0,\n        filler,\n    }\n}\n\nimpl<I, F> Iterator for PadUsing<I, F>\n    where I: Iterator,\n          F: FnMut(usize) -> I::Item\n{\n    type Item = I::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<I::Item> {\n        match self.iter.next() {\n            None => {\n                if self.pos < self.min {\n                    let e = Some((self.filler)(self.pos));\n                    self.pos += 1;\n                    e\n                } else {\n                    None\n                }\n            },\n            e => {\n                self.pos += 1;\n                e\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let tail = self.min.saturating_sub(self.pos);\n        size_hint::max(self.iter.size_hint(), (tail, Some(tail)))\n    }\n}\n\nimpl<I, F> DoubleEndedIterator for PadUsing<I, F>\n    where I: DoubleEndedIterator + ExactSizeIterator,\n          F: FnMut(usize) -> I::Item\n{\n    fn next_back(&mut self) -> Option<I::Item> {\n        if self.min == 0 {\n            self.iter.next_back()\n        } else if self.iter.len() >= self.min {\n            self.min -= 1;\n            self.iter.next_back()\n        } else {\n            self.min -= 1;\n            Some((self.filler)(self.min))\n        }\n    }\n}\n\nimpl<I, F> ExactSizeIterator for PadUsing<I, F>\n    where I: ExactSizeIterator,\n          F: FnMut(usize) -> I::Item\n{}\n"],["1080","\n/// An iterator that produces *n* repetitions of an element.\n///\n/// See [`repeat_n()`](../fn.repeat_n.html) for more information.\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n#[derive(Clone, Debug)]\npub struct RepeatN<A> {\n    elt: Option<A>,\n    n: usize,\n}\n\n/// Create an iterator that produces `n` repetitions of `element`.\npub fn repeat_n<A>(element: A, n: usize) -> RepeatN<A>\n    where A: Clone,\n{\n    if n == 0 {\n        RepeatN { elt: None, n, }\n    } else {\n        RepeatN { elt: Some(element), n, }\n    }\n}\n\nimpl<A> Iterator for RepeatN<A>\n    where A: Clone\n{\n    type Item = A;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.n > 1 {\n            self.n -= 1;\n            self.elt.as_ref().cloned()\n        } else {\n            self.n = 0;\n            self.elt.take()\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (self.n, Some(self.n))\n    }\n}\n\nimpl<A> DoubleEndedIterator for RepeatN<A>\n    where A: Clone\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.next()\n    }\n}\n\nimpl<A> ExactSizeIterator for RepeatN<A>\n    where A: Clone\n{}\n"],["1081","\nuse std::collections::HashMap;\nuse std::collections::hash_map::{Entry};\nuse std::hash::Hash;\nuse std::fmt;\n\n/// An iterator adapter to filter out duplicate elements.\n///\n/// See [`.unique_by()`](../trait.Itertools.html#method.unique) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct UniqueBy<I: Iterator, V, F> {\n    iter: I,\n    // Use a hashmap for the entry API\n    used: HashMap<V, ()>,\n    f: F,\n}\n\nimpl<I, V, F> fmt::Debug for UniqueBy<I, V, F>\n    where I: Iterator + fmt::Debug,\n          V: fmt::Debug + Hash + Eq,\n{\n    debug_fmt_fields!(UniqueBy, iter, used);\n}\n\n/// Create a new `UniqueBy` iterator.\npub fn unique_by<I, V, F>(iter: I, f: F) -> UniqueBy<I, V, F>\n    where V: Eq + Hash,\n          F: FnMut(&I::Item) -> V,\n          I: Iterator,\n{\n    UniqueBy {\n        iter,\n        used: HashMap::new(),\n        f,\n    }\n}\n\n// count the number of new unique keys in iterable (`used` is the set already seen)\nfn count_new_keys<I, K>(mut used: HashMap<K, ()>, iterable: I) -> usize\n    where I: IntoIterator<Item=K>,\n          K: Hash + Eq,\n{\n    let iter = iterable.into_iter();\n    let current_used = used.len();\n    used.extend(iter.map(|key| (key, ())));\n    used.len() - current_used\n}\n\nimpl<I, V, F> Iterator for UniqueBy<I, V, F>\n    where I: Iterator,\n          V: Eq + Hash,\n          F: FnMut(&I::Item) -> V\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<I::Item> {\n        while let Some(v) = self.iter.next() {\n            let key = (self.f)(&v);\n            if self.used.insert(key, ()).is_none() {\n                return Some(v);\n            }\n        }\n        None\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, hi) = self.iter.size_hint();\n        ((low > 0 && self.used.is_empty()) as usize, hi)\n    }\n\n    fn count(self) -> usize {\n        let mut key_f = self.f;\n        count_new_keys(self.used, self.iter.map(move |elt| key_f(&elt)))\n    }\n}\n\nimpl<I> Iterator for Unique<I>\n    where I: Iterator,\n          I::Item: Eq + Hash + Clone\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<I::Item> {\n        while let Some(v) = self.iter.iter.next() {\n            if let Entry::Vacant(entry) = self.iter.used.entry(v) {\n                let elt = entry.key().clone();\n                entry.insert(());\n                return Some(elt);\n            }\n        }\n        None\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, hi) = self.iter.iter.size_hint();\n        ((low > 0 && self.iter.used.is_empty()) as usize, hi)\n    }\n\n    fn count(self) -> usize {\n        count_new_keys(self.iter.used, self.iter.iter)\n    }\n}\n\n/// An iterator adapter to filter out duplicate elements.\n///\n/// See [`.unique()`](../trait.Itertools.html#method.unique) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Unique<I: Iterator> {\n    iter: UniqueBy<I, I::Item, ()>,\n}\n\nimpl<I> fmt::Debug for Unique<I>\n    where I: Iterator + fmt::Debug,\n          I::Item: Hash + Eq + fmt::Debug,\n{\n    debug_fmt_fields!(Unique, iter);\n}\n\npub fn unique<I>(iter: I) -> Unique<I>\n    where I: Iterator,\n          I::Item: Eq + Hash,\n{\n    Unique {\n        iter: UniqueBy {\n            iter,\n            used: HashMap::new(),\n            f: (),\n        }\n    }\n}\n"],["1082","use std::fmt;\n\nuse super::lazy_buffer::LazyBuffer;\n\n/// An iterator to iterate through all the `n`-length combinations in an iterator, with replacement.\n///\n/// See [`.combinations_with_replacement()`](../trait.Itertools.html#method.combinations_with_replacement) for more information.\n#[derive(Clone)]\npub struct CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    k: usize,\n    indices: Vec<usize>,\n    // The current known max index value. This increases as pool grows.\n    max_index: usize,\n    pool: LazyBuffer<I>,\n    first: bool,\n}\n\nimpl<I> fmt::Debug for CombinationsWithReplacement<I>\nwhere\n    I: Iterator + fmt::Debug,\n    I::Item: fmt::Debug + Clone,\n{\n    debug_fmt_fields!(Combinations, k, indices, max_index, pool, first);\n}\n\nimpl<I> CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    /// Map the current mask over the pool to get an output combination\n    fn current(&self) -> Vec<I::Item> {\n        self.indices.iter().map(|i| self.pool[*i].clone()).collect()\n    }\n}\n\n/// Create a new `CombinationsWithReplacement` from a clonable iterator.\npub fn combinations_with_replacement<I>(iter: I, k: usize) -> CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    let indices: Vec<usize> = vec![0; k];\n    let pool: LazyBuffer<I> = LazyBuffer::new(iter);\n\n    CombinationsWithReplacement {\n        k,\n        indices,\n        max_index: 0,\n        pool,\n        first: true,\n    }\n}\n\nimpl<I> Iterator for CombinationsWithReplacement<I>\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    type Item = Vec<I::Item>;\n    fn next(&mut self) -> Option<Self::Item> {\n        // If this is the first iteration, return early\n        if self.first {\n            // In empty edge cases, stop iterating immediately\n            return if self.k != 0 && !self.pool.get_next() {\n                None\n            // Otherwise, yield the initial state\n            } else {\n                self.first = false;\n                Some(self.current())\n            };\n        }\n\n        // Check if we need to consume more from the iterator\n        // This will run while we increment our first index digit\n        if self.pool.get_next() {\n            self.max_index = self.pool.len() - 1;\n        }\n\n        // Work out where we need to update our indices\n        let mut increment: Option<(usize, usize)> = None;\n        for (i, indices_int) in self.indices.iter().enumerate().rev() {\n            if indices_int < &self.max_index {\n                increment = Some((i, indices_int + 1));\n                break;\n            }\n        }\n\n        match increment {\n            // If we can update the indices further\n            Some((increment_from, increment_value)) => {\n                // We need to update the rightmost non-max value\n                // and all those to the right\n                for indices_index in increment_from..self.indices.len() {\n                    self.indices[indices_index] = increment_value\n                }\n                Some(self.current())\n            }\n            // Otherwise, we're done\n            None => None,\n        }\n    }\n}\n"],["1083","\n/// `MinMaxResult` is an enum returned by `minmax`. See `Itertools::minmax()` for\n/// more detail.\n#[derive(Copy, Clone, PartialEq, Debug)]\npub enum MinMaxResult<T> {\n    /// Empty iterator\n    NoElements,\n\n    /// Iterator with one element, so the minimum and maximum are the same\n    OneElement(T),\n\n    /// More than one element in the iterator, the first element is not larger\n    /// than the second\n    MinMax(T, T)\n}\n\nimpl<T: Clone> MinMaxResult<T> {\n    /// `into_option` creates an `Option` of type `(T, T)`. The returned `Option`\n    /// has variant `None` if and only if the `MinMaxResult` has variant\n    /// `NoElements`. Otherwise `Some((x, y))` is returned where `x <= y`.\n    /// If the `MinMaxResult` has variant `OneElement(x)`, performing this\n    /// operation will make one clone of `x`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use itertools::MinMaxResult::{self, NoElements, OneElement, MinMax};\n    ///\n    /// let r: MinMaxResult<i32> = NoElements;\n    /// assert_eq!(r.into_option(), None);\n    ///\n    /// let r = OneElement(1);\n    /// assert_eq!(r.into_option(), Some((1, 1)));\n    ///\n    /// let r = MinMax(1, 2);\n    /// assert_eq!(r.into_option(), Some((1, 2)));\n    /// ```\n    pub fn into_option(self) -> Option<(T,T)> {\n        match self {\n            MinMaxResult::NoElements => None,\n            MinMaxResult::OneElement(x) => Some((x.clone(), x)),\n            MinMaxResult::MinMax(x, y) => Some((x, y))\n        }\n    }\n}\n\n/// Implementation guts for `minmax` and `minmax_by_key`.\npub fn minmax_impl<I, K, F, L>(mut it: I, mut key_for: F,\n                               mut lt: L) -> MinMaxResult<I::Item>\n    where I: Iterator,\n          F: FnMut(&I::Item) -> K,\n          L: FnMut(&I::Item, &I::Item, &K, &K) -> bool,\n{\n    let (mut min, mut max, mut min_key, mut max_key) = match it.next() {\n        None => return MinMaxResult::NoElements,\n        Some(x) => {\n            match it.next() {\n                None => return MinMaxResult::OneElement(x),\n                Some(y) => {\n                    let xk = key_for(&x);\n                    let yk = key_for(&y);\n                    if !lt(&y, &x, &yk, &xk) {(x, y, xk, yk)} else {(y, x, yk, xk)}\n                }\n            }\n        }\n    };\n\n    loop {\n        // `first` and `second` are the two next elements we want to look\n        // at.  We first compare `first` and `second` (#1). The smaller one\n        // is then compared to current minimum (#2). The larger one is\n        // compared to current maximum (#3). This way we do 3 comparisons\n        // for 2 elements.\n        let first = match it.next() {\n            None => break,\n            Some(x) => x\n        };\n        let second = match it.next() {\n            None => {\n                let first_key = key_for(&first);\n                if lt(&first, &min, &first_key, &min_key) {\n                    min = first;\n                } else if !lt(&first, &max, &first_key, &max_key) {\n                    max = first;\n                }\n                break;\n            }\n            Some(x) => x\n        };\n        let first_key = key_for(&first);\n        let second_key = key_for(&second);\n        if !lt(&second, &first, &second_key, &first_key) {\n            if lt(&first, &min, &first_key, &min_key) {\n                min = first;\n                min_key = first_key;\n            }\n            if !lt(&second, &max, &second_key, &max_key) {\n                max = second;\n                max_key = second_key;\n            }\n        } else {\n            if lt(&second, &min, &second_key, &min_key) {\n                min = second;\n                min_key = second_key;\n            }\n            if !lt(&first, &max, &first_key, &max_key) {\n                max = first;\n                max_key = first_key;\n            }\n        }\n    }\n\n    MinMaxResult::MinMax(min, max)\n}\n"],["1084","use std::fmt;\n\nuse super::lazy_buffer::LazyBuffer;\n\n/// An iterator to iterate through all the `k`-length combinations in an iterator.\n///\n/// See [`.combinations()`](../trait.Itertools.html#method.combinations) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Combinations<I: Iterator> {\n    indices: Vec<usize>,\n    pool: LazyBuffer<I>,\n    first: bool,\n}\n\nimpl<I> Clone for Combinations<I>\n    where I: Clone + Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(indices, pool, first);\n}\n\nimpl<I> fmt::Debug for Combinations<I>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Combinations, indices, pool, first);\n}\n\n/// Create a new `Combinations` from a clonable iterator.\npub fn combinations<I>(iter: I, k: usize) -> Combinations<I>\n    where I: Iterator\n{\n    let mut pool: LazyBuffer<I> = LazyBuffer::new(iter);\n\n    for _ in 0..k {\n        if !pool.get_next() {\n            break;\n        }\n    }\n\n    Combinations {\n        indices: (0..k).collect(),\n        pool,\n        first: true,\n    }\n}\n\nimpl<I> Iterator for Combinations<I>\n    where I: Iterator,\n          I::Item: Clone\n{\n    type Item = Vec<I::Item>;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.first {\n            if self.pool.is_done() {\n                return None;\n            }\n            self.first = false;\n        } else if self.indices.len() == 0 {\n            return None;\n        } else {\n            // Scan from the end, looking for an index to increment\n            let mut i: usize = self.indices.len() - 1;\n\n            // Check if we need to consume more from the iterator\n            if self.indices[i] == self.pool.len() - 1 {\n                self.pool.get_next(); // may change pool size\n            }\n\n            while self.indices[i] == i + self.pool.len() - self.indices.len() {\n                if i > 0 {\n                    i -= 1;\n                } else {\n                    // Reached the last combination\n                    return None;\n                }\n            }\n\n            // Increment index, and reset the ones to its right\n            self.indices[i] += 1;\n            for j in i+1..self.indices.len() {\n                self.indices[j] = self.indices[j - 1] + 1;\n            }\n        }\n\n        // Create result vector based on the indices\n        Some(self.indices.iter().map(|i| self.pool[*i].clone()).collect())\n    }\n}\n"],["1085","\n/// An iterator that produces only the `T` values as long as the\n/// inner iterator produces `Ok(T)`.\n///\n/// Used by [`process_results`](../fn.process_results.html), see its docs\n/// for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct ProcessResults<'a, I, E: 'a> {\n    error: &'a mut Result<(), E>,\n    iter: I,\n}\n\nimpl<'a, I, T, E> Iterator for ProcessResults<'a, I, E>\n    where I: Iterator<Item = Result<T, E>>\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.iter.next() {\n            Some(Ok(x)) => Some(x),\n            Some(Err(e)) => {\n                *self.error = Err(e);\n                None\n            }\n            None => None,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, hi) = self.iter.size_hint();\n        (0, hi)\n    }\n}\n\n/// â€œLiftâ€ a function of the values of an iterator so that it can process\n/// an iterator of `Result` values instead.\n///\n/// `iterable` is an iterator or iterable with `Result<T, E>` elements, where\n/// `T` is the value type and `E` the error type.\n///\n/// `processor` is a closure that receives an adapted version of the iterable\n/// as the only argument â€” the adapted iterator produces elements of type `T`,\n/// as long as the original iterator produces `Ok` values.\n///\n/// If the original iterable produces an error at any point, the adapted\n/// iterator ends and the `process_results` function will return the\n/// error iself.\n///\n/// Otherwise, the return value from the closure is returned wrapped\n/// inside `Ok`.\n///\n/// # Example\n///\n/// ```\n/// use itertools::process_results;\n///\n/// type R = Result<i32, &'static str>;\n///\n/// let first_values: Vec<R> = vec![Ok(1), Ok(0), Ok(3)];\n/// let second_values: Vec<R> = vec![Ok(2), Ok(1), Err(\"overflow\")];\n///\n/// // â€œLiftâ€ the iterator .max() method to work on the values in Results using process_results\n///\n/// let first_max = process_results(first_values, |iter| iter.max().unwrap_or(0));\n/// let second_max = process_results(second_values, |iter| iter.max().unwrap_or(0));\n///\n/// assert_eq!(first_max, Ok(3));\n/// assert!(second_max.is_err());\n/// ```\npub fn process_results<I, F, T, E, R>(iterable: I, processor: F) -> Result<R, E>\n    where I: IntoIterator<Item = Result<T, E>>,\n          F: FnOnce(ProcessResults<I::IntoIter, E>) -> R\n{\n    let iter = iterable.into_iter();\n    let mut error = Ok(());\n\n    let result = processor(ProcessResults { error: &mut error, iter });\n\n    error.map(|_| result)\n}\n"],["1086","//! Some iterator that produces tuples\n\nuse std::iter::Fuse;\n\n// `HomogeneousTuple` is a public facade for `TupleCollect`, allowing\n// tuple-related methods to be used by clients in generic contexts, while\n// hiding the implementation details of `TupleCollect`.\n// See https://github.com/rust-itertools/itertools/issues/387\n\n/// Implemented for homogeneous tuples of size up to 4.\npub trait HomogeneousTuple\n    : TupleCollect\n{}\n\nimpl<T: TupleCollect> HomogeneousTuple for T {}\n\n/// An iterator over a incomplete tuple.\n///\n/// See [`.tuples()`](../trait.Itertools.html#method.tuples) and\n/// [`Tuples::into_buffer()`](struct.Tuples.html#method.into_buffer).\n#[derive(Clone, Debug)]\npub struct TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n    cur: usize,\n    buf: T::Buffer,\n}\n\nimpl<T> TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n    fn new(buf: T::Buffer) -> Self {\n        TupleBuffer {\n            cur: 0,\n            buf,\n        }\n    }\n}\n\nimpl<T> Iterator for TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n    type Item = T::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let s = self.buf.as_mut();\n        if let Some(ref mut item) = s.get_mut(self.cur) {\n            self.cur += 1;\n            item.take()\n        } else {\n            None\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let buffer = &self.buf.as_ref()[self.cur..];\n        let len = if buffer.len() == 0 {\n            0\n        } else {\n            buffer.iter()\n                  .position(|x| x.is_none())\n                  .unwrap_or(buffer.len())\n        };\n        (len, Some(len))\n    }\n}\n\nimpl<T> ExactSizeIterator for TupleBuffer<T>\n    where T: HomogeneousTuple\n{\n}\n\n/// An iterator that groups the items in tuples of a specific size.\n///\n/// See [`.tuples()`](../trait.Itertools.html#method.tuples) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    iter: Fuse<I>,\n    buf: T::Buffer,\n}\n\n/// Create a new tuples iterator.\npub fn tuples<I, T>(iter: I) -> Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    Tuples {\n        iter: iter.fuse(),\n        buf: Default::default(),\n    }\n}\n\nimpl<I, T> Iterator for Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<T> {\n        T::collect_from_iter(&mut self.iter, &mut self.buf)\n    }\n}\n\nimpl<I, T> Tuples<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    /// Return a buffer with the produced items that was not enough to be grouped in a tuple.\n    ///\n    /// ```\n    /// use itertools::Itertools;\n    ///\n    /// let mut iter = (0..5).tuples();\n    /// assert_eq!(Some((0, 1, 2)), iter.next());\n    /// assert_eq!(None, iter.next());\n    /// itertools::assert_equal(vec![3, 4], iter.into_buffer());\n    /// ```\n    pub fn into_buffer(self) -> TupleBuffer<T> {\n        TupleBuffer::new(self.buf)\n    }\n}\n\n\n/// An iterator over all contiguous windows that produces tuples of a specific size.\n///\n/// See [`.tuple_windows()`](../trait.Itertools.html#method.tuple_windows) for more\n/// information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Clone, Debug)]\npub struct TupleWindows<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple\n{\n    iter: I,\n    last: Option<T>,\n}\n\n/// Create a new tuple windows iterator.\npub fn tuple_windows<I, T>(mut iter: I) -> TupleWindows<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple,\n          T::Item: Clone\n{\n    use std::iter::once;\n\n    let mut last = None;\n    if T::num_items() != 1 {\n        // put in a duplicate item in front of the tuple; this simplifies\n        // .next() function.\n        if let Some(item) = iter.next() {\n            let iter = once(item.clone()).chain(once(item)).chain(&mut iter);\n            last = T::collect_from_iter_no_buf(iter);\n        }\n    }\n\n    TupleWindows {\n        last,\n        iter,\n    }\n}\n\nimpl<I, T> Iterator for TupleWindows<I, T>\n    where I: Iterator<Item = T::Item>,\n          T: HomogeneousTuple + Clone,\n          T::Item: Clone\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<T> {\n        if T::num_items() == 1 {\n            return T::collect_from_iter_no_buf(&mut self.iter)\n        }\n        if let Some(ref mut last) = self.last {\n            if let Some(new) = self.iter.next() {\n                last.left_shift_push(new);\n                return Some(last.clone());\n            }\n        }\n        None\n    }\n}\n\npub trait TupleCollect: Sized {\n    type Item;\n    type Buffer: Default + AsRef<[Option<Self::Item>]> + AsMut<[Option<Self::Item>]>;\n\n    fn collect_from_iter<I>(iter: I, buf: &mut Self::Buffer) -> Option<Self>\n        where I: IntoIterator<Item = Self::Item>;\n\n    fn collect_from_iter_no_buf<I>(iter: I) -> Option<Self>\n        where I: IntoIterator<Item = Self::Item>;\n\n    fn num_items() -> usize;\n\n    fn left_shift_push(&mut self, item: Self::Item);\n}\n\nmacro_rules! impl_tuple_collect {\n    () => ();\n    ($N:expr; $A:ident ; $($X:ident),* ; $($Y:ident),* ; $($Y_rev:ident),*) => (\n        impl<$A> TupleCollect for ($($X),*,) {\n            type Item = $A;\n            type Buffer = [Option<$A>; $N - 1];\n\n            #[allow(unused_assignments, unused_mut)]\n            fn collect_from_iter<I>(iter: I, buf: &mut Self::Buffer) -> Option<Self>\n                where I: IntoIterator<Item = $A>\n            {\n                let mut iter = iter.into_iter();\n                $(\n                    let mut $Y = None;\n                )*\n\n                loop {\n                    $(\n                        $Y = iter.next();\n                        if $Y.is_none() {\n                            break\n                        }\n                    )*\n                    return Some(($($Y.unwrap()),*,))\n                }\n\n                let mut i = 0;\n                let mut s = buf.as_mut();\n                $(\n                    if i < s.len() {\n                        s[i] = $Y;\n                        i += 1;\n                    }\n                )*\n                return None;\n            }\n\n            #[allow(unused_assignments)]\n            fn collect_from_iter_no_buf<I>(iter: I) -> Option<Self>\n                where I: IntoIterator<Item = $A>\n            {\n                let mut iter = iter.into_iter();\n                loop {\n                    $(\n                        let $Y = if let Some($Y) = iter.next() {\n                            $Y\n                        } else {\n                            break;\n                        };\n                    )*\n                    return Some(($($Y),*,))\n                }\n\n                return None;\n            }\n\n            fn num_items() -> usize {\n                $N\n            }\n\n            fn left_shift_push(&mut self, item: $A) {\n                use std::mem::replace;\n\n                let &mut ($(ref mut $Y),*,) = self;\n                let tmp = item;\n                $(\n                    let tmp = replace($Y_rev, tmp);\n                )*\n                drop(tmp);\n            }\n        }\n    )\n}\n\nimpl_tuple_collect!(1; A; A; a; a);\nimpl_tuple_collect!(2; A; A, A; a, b; b, a);\nimpl_tuple_collect!(3; A; A, A, A; a, b, c; c, b, a);\nimpl_tuple_collect!(4; A; A, A, A, A; a, b, c, d; d, c, b, a);\n"],["1087","use std::iter::Peekable;\nuse crate::PutBack;\n#[cfg(feature = \"use_std\")]\nuse crate::PutBackN;\n\n/// An iterator that allows peeking at an element before deciding to accept it.\n///\n/// See [`.peeking_take_while()`](trait.Itertools.html#method.peeking_take_while)\n/// for more information.\n///\n/// This is implemented by peeking adaptors like peekable and put back,\n/// but also by a few iterators that can be peeked natively, like the sliceâ€™s\n/// by reference iterator (`std::slice::Iter`).\npub trait PeekingNext : Iterator {\n    /// Pass a reference to the next iterator element to the closure `accept`;\n    /// if `accept` returns true, return it as the next element,\n    /// else None.\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool;\n}\n\nimpl<I> PeekingNext for Peekable<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if let Some(r) = self.peek() {\n            if !accept(r) {\n                return None;\n            }\n        }\n        self.next()\n    }\n}\n\nimpl<I> PeekingNext for PutBack<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if let Some(r) = self.next() {\n            if !accept(&r) {\n                self.put_back(r);\n                return None;\n            }\n            Some(r)\n        } else {\n            None\n        }\n    }\n}\n\n#[cfg(feature = \"use_std\")]\nimpl<I> PeekingNext for PutBackN<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if let Some(r) = self.next() {\n            if !accept(&r) {\n                self.put_back(r);\n                return None;\n            }\n            Some(r)\n        } else {\n            None\n        }\n    }\n}\n\n/// An iterator adaptor that takes items while a closure returns `true`.\n///\n/// See [`.peeking_take_while()`](../trait.Itertools.html#method.peeking_take_while)\n/// for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct PeekingTakeWhile<'a, I: 'a, F>\n    where I: Iterator,\n{\n    iter: &'a mut I,\n    f: F,\n}\n\n/// Create a PeekingTakeWhile\npub fn peeking_take_while<I, F>(iter: &mut I, f: F) -> PeekingTakeWhile<I, F>\n    where I: Iterator,\n{\n    PeekingTakeWhile {\n        iter,\n        f,\n    }\n}\n\nimpl<'a, I, F> Iterator for PeekingTakeWhile<'a, I, F>\n    where I: PeekingNext,\n          F: FnMut(&I::Item) -> bool,\n\n{\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.peeking_next(&mut self.f)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, hi) = self.iter.size_hint();\n        (0, hi)\n    }\n}\n\n// Some iterators are so lightweight we can simply clone them to save their\n// state and use that for peeking.\nmacro_rules! peeking_next_by_clone {\n    ([$($typarm:tt)*] $type_:ty) => {\n        impl<$($typarm)*> PeekingNext for $type_ {\n            fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n                where F: FnOnce(&Self::Item) -> bool\n            {\n                let saved_state = self.clone();\n                if let Some(r) = self.next() {\n                    if !accept(&r) {\n                        *self = saved_state;\n                    } else {\n                        return Some(r)\n                    }\n                }\n                None\n            }\n        }\n    }\n}\n\npeeking_next_by_clone! { ['a, T] ::std::slice::Iter<'a, T> }\npeeking_next_by_clone! { ['a] ::std::str::Chars<'a> }\npeeking_next_by_clone! { ['a] ::std::str::CharIndices<'a> }\npeeking_next_by_clone! { ['a] ::std::str::Bytes<'a> }\npeeking_next_by_clone! { ['a, T] ::std::option::Iter<'a, T> }\npeeking_next_by_clone! { ['a, T] ::std::result::Iter<'a, T> }\npeeking_next_by_clone! { [T] ::std::iter::Empty<T> }\n#[cfg(feature = \"use_std\")]\npeeking_next_by_clone! { ['a, T] ::std::collections::linked_list::Iter<'a, T> }\n#[cfg(feature = \"use_std\")]\npeeking_next_by_clone! { ['a, T] ::std::collections::vec_deque::Iter<'a, T> }\n\n// cloning a Rev has no extra overhead; peekable and put backs are never DEI.\npeeking_next_by_clone! { [I: Clone + PeekingNext + DoubleEndedIterator]\n                         ::std::iter::Rev<I> }\n"],["1088","\nuse std::iter::IntoIterator;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n/// A wrapper for `Rc<RefCell<I>>`, that implements the `Iterator` trait.\n#[derive(Debug)]\npub struct RcIter<I> {\n    /// The boxed iterator.\n    pub rciter: Rc<RefCell<I>>,\n}\n\n/// Return an iterator inside a `Rc<RefCell<_>>` wrapper.\n///\n/// The returned `RcIter` can be cloned, and each clone will refer back to the\n/// same original iterator.\n///\n/// `RcIter` allows doing interesting things like using `.zip()` on an iterator with\n/// itself, at the cost of runtime borrow checking which may have a performance\n/// penalty.\n///\n/// Iterator element type is `Self::Item`.\n///\n/// ```\n/// use itertools::rciter;\n/// use itertools::zip;\n///\n/// // In this example a range iterator is created and we iterate it using\n/// // three separate handles (two of them given to zip).\n/// // We also use the IntoIterator implementation for `&RcIter`.\n///\n/// let mut iter = rciter(0..9);\n/// let mut z = zip(&iter, &iter);\n///\n/// assert_eq!(z.next(), Some((0, 1)));\n/// assert_eq!(z.next(), Some((2, 3)));\n/// assert_eq!(z.next(), Some((4, 5)));\n/// assert_eq!(iter.next(), Some(6));\n/// assert_eq!(z.next(), Some((7, 8)));\n/// assert_eq!(z.next(), None);\n/// ```\n///\n/// **Panics** in iterator methods if a borrow error is encountered in the\n/// iterator methods. It can only happen if the `RcIter` is reentered in\n/// `.next()`, i.e. if it somehow participates in an â€œiterator knotâ€\n/// where it is an adaptor of itself.\npub fn rciter<I>(iterable: I) -> RcIter<I::IntoIter>\n    where I: IntoIterator\n{\n    RcIter { rciter: Rc::new(RefCell::new(iterable.into_iter())) }\n}\n\nimpl<I> Clone for RcIter<I> {\n    #[inline]\n    clone_fields!(rciter);\n}\n\nimpl<A, I> Iterator for RcIter<I>\n    where I: Iterator<Item = A>\n{\n    type Item = A;\n    #[inline]\n    fn next(&mut self) -> Option<A> {\n        self.rciter.borrow_mut().next()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // To work sanely with other API that assume they own an iterator,\n        // so it can't change in other places, we can't guarantee as much\n        // in our size_hint. Other clones may drain values under our feet.\n        let (_, hi) = self.rciter.borrow().size_hint();\n        (0, hi)\n    }\n}\n\nimpl<I> DoubleEndedIterator for RcIter<I>\n    where I: DoubleEndedIterator\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<I::Item> {\n        self.rciter.borrow_mut().next_back()\n    }\n}\n\n/// Return an iterator from `&RcIter<I>` (by simply cloning it).\nimpl<'a, I> IntoIterator for &'a RcIter<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n    type IntoIter = RcIter<I>;\n\n    fn into_iter(self) -> RcIter<I> {\n        self.clone()\n    }\n}\n"],["1089","use super::size_hint;\n\n/// An iterator which iterates two other iterators simultaneously\n///\n/// See [`.zip_eq()`](../trait.Itertools.html#method.zip_eq) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct ZipEq<I, J> {\n    a: I,\n    b: J,\n}\n\n/// Iterate `i` and `j` in lock step.\n///\n/// **Panics** if the iterators are not of the same length.\n///\n/// `IntoIterator` enabled version of `i.zip_eq(j)`.\n///\n/// ```\n/// use itertools::zip_eq;\n///\n/// let data = [1, 2, 3, 4, 5];\n/// for (a, b) in zip_eq(&data[..data.len() - 1], &data[1..]) {\n///     /* loop body */\n/// }\n/// ```\npub fn zip_eq<I, J>(i: I, j: J) -> ZipEq<I::IntoIter, J::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator\n{\n    ZipEq {\n        a: i.into_iter(),\n        b: j.into_iter(),\n    }\n}\n\nimpl<I, J> Iterator for ZipEq<I, J>\n    where I: Iterator,\n          J: Iterator\n{\n    type Item = (I::Item, J::Item);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match (self.a.next(), self.b.next()) {\n            (None, None) => None,\n            (Some(a), Some(b)) => Some((a, b)),\n            (None, Some(_)) | (Some(_), None) =>\n            panic!(\"itertools: .zip_eq() reached end of one iterator before the other\")\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::min(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\nimpl<I, J> ExactSizeIterator for ZipEq<I, J>\n    where I: ExactSizeIterator,\n          J: ExactSizeIterator\n{}\n"],["1090","use std::iter::Fuse;\nuse super::size_hint;\n\n#[derive(Clone)]\n/// An iterator adaptor to insert a particular value\n/// between each element of the adapted iterator.\n///\n/// Iterator element type is `I::Item`\n///\n/// This iterator is *fused*.\n///\n/// See [`.intersperse()`](../trait.Itertools.html#method.intersperse) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct Intersperse<I>\n    where I: Iterator\n{\n    element: I::Item,\n    iter: Fuse<I>,\n    peek: Option<I::Item>,\n}\n\n/// Create a new Intersperse iterator\npub fn intersperse<I>(iter: I, elt: I::Item) -> Intersperse<I>\n    where I: Iterator\n{\n    let mut iter = iter.fuse();\n    Intersperse {\n        peek: iter.next(),\n        iter,\n        element: elt,\n    }\n}\n\nimpl<I> Iterator for Intersperse<I>\n    where I: Iterator,\n          I::Item: Clone\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<I::Item> {\n        if self.peek.is_some() {\n            self.peek.take()\n        } else {\n            self.peek = self.iter.next();\n            if self.peek.is_some() {\n                Some(self.element.clone())\n            } else {\n                None\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // 2 * SH + { 1 or 0 }\n        let has_peek = self.peek.is_some() as usize;\n        let sh = self.iter.size_hint();\n        size_hint::add_scalar(size_hint::add(sh, sh), has_peek)\n    }\n\n    fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n        Self: Sized, F: FnMut(B, Self::Item) -> B,\n    {\n        let mut accum = init;\n        \n        if let Some(x) = self.peek.take() {\n            accum = f(accum, x);\n        }\n\n        let element = &self.element;\n\n        self.iter.fold(accum,\n            |accum, x| {\n                let accum = f(accum, element.clone());\n                let accum = f(accum, x);\n                accum\n        })\n    }\n}\n"],["1091","use std::iter::{Fuse,Peekable};\n\n/// An iterator adaptor that wraps each element in an [`Position`](../enum.Position.html).\n///\n/// Iterator element type is `Position<I::Item>`.\n///\n/// See [`.with_position()`](../trait.Itertools.html#method.with_position) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct WithPosition<I>\n    where I: Iterator,\n{\n    handled_first: bool,\n    peekable: Peekable<Fuse<I>>,\n}\n\nimpl<I> Clone for WithPosition<I>\n    where I: Clone + Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(handled_first, peekable);\n}\n\n/// Create a new `WithPosition` iterator.\npub fn with_position<I>(iter: I) -> WithPosition<I>\n    where I: Iterator,\n{\n    WithPosition {\n        handled_first: false,\n        peekable: iter.fuse().peekable(),\n    }\n}\n\n/// A value yielded by `WithPosition`.\n/// Indicates the position of this element in the iterator results.\n///\n/// See [`.with_position()`](trait.Itertools.html#method.with_position) for more information.\n#[derive(Copy, Clone, Debug, PartialEq)]\npub enum Position<T> {\n    /// This is the first element.\n    First(T),\n    /// This is neither the first nor the last element.\n    Middle(T),\n    /// This is the last element.\n    Last(T),\n    /// This is the only element.\n    Only(T),\n}\n\nimpl<T> Position<T> {\n    /// Return the inner value.\n    pub fn into_inner(self) -> T {\n        match self {\n            Position::First(x) |\n            Position::Middle(x) |\n            Position::Last(x) |\n            Position::Only(x) => x,\n        }\n    }\n}\n\nimpl<I: Iterator> Iterator for WithPosition<I> {\n    type Item = Position<I::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.peekable.next() {\n            Some(item) => {\n                if !self.handled_first {\n                    // Haven't seen the first item yet, and there is one to give.\n                    self.handled_first = true;\n                    // Peek to see if this is also the last item,\n                    // in which case tag it as `Only`.\n                    match self.peekable.peek() {\n                        Some(_) => Some(Position::First(item)),\n                        None => Some(Position::Only(item)),\n                    }\n                } else {\n                    // Have seen the first item, and there's something left.\n                    // Peek to see if this is the last item.\n                    match self.peekable.peek() {\n                        Some(_) => Some(Position::Middle(item)),\n                        None => Some(Position::Last(item)),\n                    }\n                }\n            }\n            // Iterator is finished.\n            None => None,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.peekable.size_hint()\n    }\n}\n\nimpl<I> ExactSizeIterator for WithPosition<I>\n    where I: ExactSizeIterator,\n{ }\n"],["1092","use std::cell::{Cell, RefCell};\nuse std::vec;\n\n/// A trait to unify FnMut for GroupBy with the chunk key in IntoChunks\ntrait KeyFunction<A> {\n    type Key;\n    fn call_mut(&mut self, arg: A) -> Self::Key;\n}\n\nimpl<'a, A, K, F: ?Sized> KeyFunction<A> for F\n    where F: FnMut(A) -> K\n{\n    type Key = K;\n    #[inline]\n    fn call_mut(&mut self, arg: A) -> Self::Key {\n        (*self)(arg)\n    }\n}\n\n\n/// ChunkIndex acts like the grouping key function for IntoChunks\n#[derive(Debug)]\nstruct ChunkIndex {\n    size: usize,\n    index: usize,\n    key: usize,\n}\n\nimpl ChunkIndex {\n    #[inline(always)]\n    fn new(size: usize) -> Self {\n        ChunkIndex {\n            size,\n            index: 0,\n            key: 0,\n        }\n    }\n}\n\nimpl<'a, A> KeyFunction<A> for ChunkIndex {\n    type Key = usize;\n    #[inline(always)]\n    fn call_mut(&mut self, _arg: A) -> Self::Key {\n        if self.index == self.size {\n            self.key += 1;\n            self.index = 0;\n        }\n        self.index += 1;\n        self.key\n    }\n}\n\n\nstruct GroupInner<K, I, F>\n    where I: Iterator\n{\n    key: F,\n    iter: I,\n    current_key: Option<K>,\n    current_elt: Option<I::Item>,\n    /// flag set if iterator is exhausted\n    done: bool,\n    /// Index of group we are currently buffering or visiting\n    top_group: usize,\n    /// Least index for which we still have elements buffered\n    oldest_buffered_group: usize,\n    /// Group index for `buffer[0]` -- the slots\n    /// bottom_group..oldest_buffered_group are unused and will be erased when\n    /// that range is large enough.\n    bottom_group: usize,\n    /// Buffered groups, from `bottom_group` (index 0) to `top_group`.\n    buffer: Vec<vec::IntoIter<I::Item>>,\n    /// index of last group iter that was dropped, usize::MAX == none\n    dropped_group: usize,\n}\n\nimpl<K, I, F> GroupInner<K, I, F>\n    where I: Iterator,\n          F: for<'a> KeyFunction<&'a I::Item, Key=K>,\n          K: PartialEq,\n{\n    /// `client`: Index of group that requests next element\n    #[inline(always)]\n    fn step(&mut self, client: usize) -> Option<I::Item> {\n        /*\n        println!(\"client={}, bottom_group={}, oldest_buffered_group={}, top_group={}, buffers=[{}]\",\n                 client, self.bottom_group, self.oldest_buffered_group,\n                 self.top_group,\n                 self.buffer.iter().map(|elt| elt.len()).format(\", \"));\n        */\n        if client < self.oldest_buffered_group {\n            None\n        } else if client < self.top_group ||\n            (client == self.top_group &&\n             self.buffer.len() > self.top_group - self.bottom_group)\n        {\n            self.lookup_buffer(client)\n        } else if self.done {\n            None\n        } else if self.top_group == client {\n            self.step_current()\n        } else {\n            self.step_buffering(client)\n        }\n    }\n\n    #[inline(never)]\n    fn lookup_buffer(&mut self, client: usize) -> Option<I::Item> {\n        // if `bufidx` doesn't exist in self.buffer, it might be empty\n        let bufidx = client - self.bottom_group;\n        if client < self.oldest_buffered_group {\n            return None;\n        }\n        let elt = self.buffer.get_mut(bufidx).and_then(|queue| queue.next());\n        if elt.is_none() && client == self.oldest_buffered_group {\n            // FIXME: VecDeque is unfortunately not zero allocation when empty,\n            // so we do this job manually.\n            // `bottom_group..oldest_buffered_group` is unused, and if it's large enough, erase it.\n            self.oldest_buffered_group += 1;\n            // skip forward further empty queues too\n            while self.buffer.get(self.oldest_buffered_group - self.bottom_group)\n                             .map_or(false, |buf| buf.len() == 0)\n            {\n                self.oldest_buffered_group += 1;\n            }\n\n            let nclear = self.oldest_buffered_group - self.bottom_group;\n            if nclear > 0 && nclear >= self.buffer.len() / 2 {\n                let mut i = 0;\n                self.buffer.retain(|buf| {\n                    i += 1;\n                    debug_assert!(buf.len() == 0 || i > nclear);\n                    i > nclear\n                });\n                self.bottom_group = self.oldest_buffered_group;\n            }\n        }\n        elt\n    }\n\n    /// Take the next element from the iterator, and set the done\n    /// flag if exhausted. Must not be called after done.\n    #[inline(always)]\n    fn next_element(&mut self) -> Option<I::Item> {\n        debug_assert!(!self.done);\n        match self.iter.next() {\n            None => { self.done = true; None }\n            otherwise => otherwise,\n        }\n    }\n\n\n    #[inline(never)]\n    fn step_buffering(&mut self, client: usize) -> Option<I::Item> {\n        // requested a later group -- walk through the current group up to\n        // the requested group index, and buffer the elements (unless\n        // the group is marked as dropped).\n        // Because the `Groups` iterator is always the first to request\n        // each group index, client is the next index efter top_group.\n        debug_assert!(self.top_group + 1 == client);\n        let mut group = Vec::new();\n\n        if let Some(elt) = self.current_elt.take() {\n            if self.top_group != self.dropped_group {\n                group.push(elt);\n            }\n        }\n        let mut first_elt = None; // first element of the next group\n\n        while let Some(elt) = self.next_element() {\n            let key = self.key.call_mut(&elt);\n            match self.current_key.take() {\n                None => {}\n                Some(old_key) => if old_key != key {\n                    self.current_key = Some(key);\n                    first_elt = Some(elt);\n                    break;\n                },\n            }\n            self.current_key = Some(key);\n            if self.top_group != self.dropped_group {\n                group.push(elt);\n            }\n        }\n\n        if self.top_group != self.dropped_group {\n            self.push_next_group(group);\n        }\n        if first_elt.is_some() {\n            self.top_group += 1;\n            debug_assert!(self.top_group == client);\n        }\n        first_elt\n    }\n\n    fn push_next_group(&mut self, group: Vec<I::Item>) {\n        // When we add a new buffered group, fill up slots between oldest_buffered_group and top_group\n        while self.top_group - self.bottom_group > self.buffer.len() {\n            if self.buffer.is_empty() {\n                self.bottom_group += 1;\n                self.oldest_buffered_group += 1;\n            } else {\n                self.buffer.push(Vec::new().into_iter());\n            }\n        }\n        self.buffer.push(group.into_iter());\n        debug_assert!(self.top_group + 1 - self.bottom_group == self.buffer.len());\n    }\n\n    /// This is the immediate case, where we use no buffering\n    #[inline]\n    fn step_current(&mut self) -> Option<I::Item> {\n        debug_assert!(!self.done);\n        if let elt @ Some(..) = self.current_elt.take() {\n            return elt;\n        }\n        match self.next_element() {\n            None => None,\n            Some(elt) => {\n                let key = self.key.call_mut(&elt);\n                match self.current_key.take() {\n                    None => {}\n                    Some(old_key) => if old_key != key {\n                        self.current_key = Some(key);\n                        self.current_elt = Some(elt);\n                        self.top_group += 1;\n                        return None;\n                    },\n                }\n                self.current_key = Some(key);\n                Some(elt)\n            }\n        }\n    }\n\n    /// Request the just started groups' key.\n    ///\n    /// `client`: Index of group\n    ///\n    /// **Panics** if no group key is available.\n    fn group_key(&mut self, client: usize) -> K {\n        // This can only be called after we have just returned the first\n        // element of a group.\n        // Perform this by simply buffering one more element, grabbing the\n        // next key.\n        debug_assert!(!self.done);\n        debug_assert!(client == self.top_group);\n        debug_assert!(self.current_key.is_some());\n        debug_assert!(self.current_elt.is_none());\n        let old_key = self.current_key.take().unwrap();\n        if let Some(elt) = self.next_element() {\n            let key = self.key.call_mut(&elt);\n            if old_key != key {\n                self.top_group += 1;\n            }\n            self.current_key = Some(key);\n            self.current_elt = Some(elt);\n        }\n        old_key\n    }\n}\n\nimpl<K, I, F> GroupInner<K, I, F>\n    where I: Iterator,\n{\n    /// Called when a group is dropped\n    fn drop_group(&mut self, client: usize) {\n        // It's only useful to track the maximal index\n        if self.dropped_group == !0 || client > self.dropped_group {\n            self.dropped_group = client;\n        }\n    }\n}\n\n/// `GroupBy` is the storage for the lazy grouping operation.\n///\n/// If the groups are consumed in their original order, or if each\n/// group is dropped without keeping it around, then `GroupBy` uses\n/// no allocations. It needs allocations only if several group iterators\n/// are alive at the same time.\n///\n/// This type implements `IntoIterator` (it is **not** an iterator\n/// itself), because the group iterators need to borrow from this\n/// value. It should be stored in a local variable or temporary and\n/// iterated.\n///\n/// See [`.group_by()`](../trait.Itertools.html#method.group_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct GroupBy<K, I, F>\n    where I: Iterator,\n{\n    inner: RefCell<GroupInner<K, I, F>>,\n    // the group iterator's current index. Keep this in the main value\n    // so that simultaneous iterators all use the same state.\n    index: Cell<usize>,\n}\n\n/// Create a new\npub fn new<K, J, F>(iter: J, f: F) -> GroupBy<K, J::IntoIter, F>\n    where J: IntoIterator,\n          F: FnMut(&J::Item) -> K,\n{\n    GroupBy {\n        inner: RefCell::new(GroupInner {\n            key: f,\n            iter: iter.into_iter(),\n            current_key: None,\n            current_elt: None,\n            done: false,\n            top_group: 0,\n            oldest_buffered_group: 0,\n            bottom_group: 0,\n            buffer: Vec::new(),\n            dropped_group: !0,\n        }),\n        index: Cell::new(0),\n    }\n}\n\nimpl<K, I, F> GroupBy<K, I, F>\n    where I: Iterator,\n{\n    /// `client`: Index of group that requests next element\n    fn step(&self, client: usize) -> Option<I::Item>\n        where F: FnMut(&I::Item) -> K,\n              K: PartialEq,\n    {\n        self.inner.borrow_mut().step(client)\n    }\n\n    /// `client`: Index of group\n    fn drop_group(&self, client: usize) {\n        self.inner.borrow_mut().drop_group(client)\n    }\n}\n\nimpl<'a, K, I, F> IntoIterator for &'a GroupBy<K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n          F: FnMut(&I::Item) -> K,\n          K: PartialEq\n{\n    type Item = (K, Group<'a, K, I, F>);\n    type IntoIter = Groups<'a, K, I, F>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        Groups { parent: self }\n    }\n}\n\n\n/// An iterator that yields the Group iterators.\n///\n/// Iterator element type is `(K, Group)`:\n/// the group's key `K` and the group's iterator.\n///\n/// See [`.group_by()`](../trait.Itertools.html#method.group_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Groups<'a, K: 'a, I: 'a, F: 'a>\n    where I: Iterator,\n          I::Item: 'a\n{\n    parent: &'a GroupBy<K, I, F>,\n}\n\nimpl<'a, K, I, F> Iterator for Groups<'a, K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n          F: FnMut(&I::Item) -> K,\n          K: PartialEq\n{\n    type Item = (K, Group<'a, K, I, F>);\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let index = self.parent.index.get();\n        self.parent.index.set(index + 1);\n        let inner = &mut *self.parent.inner.borrow_mut();\n        inner.step(index).map(|elt| {\n            let key = inner.group_key(index);\n            (key, Group {\n                parent: self.parent,\n                index,\n                first: Some(elt),\n            })\n        })\n    }\n}\n\n/// An iterator for the elements in a single group.\n///\n/// Iterator element type is `I::Item`.\npub struct Group<'a, K: 'a, I: 'a, F: 'a>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    parent: &'a GroupBy<K, I, F>,\n    index: usize,\n    first: Option<I::Item>,\n}\n\nimpl<'a, K, I, F> Drop for Group<'a, K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    fn drop(&mut self) {\n        self.parent.drop_group(self.index);\n    }\n}\n\nimpl<'a, K, I, F> Iterator for Group<'a, K, I, F>\n    where I: Iterator,\n          I::Item: 'a,\n          F: FnMut(&I::Item) -> K,\n          K: PartialEq,\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if let elt @ Some(..) = self.first.take() {\n            return elt;\n        }\n        self.parent.step(self.index)\n    }\n}\n\n///// IntoChunks /////\n\n/// Create a new\npub fn new_chunks<J>(iter: J, size: usize) -> IntoChunks<J::IntoIter>\n    where J: IntoIterator,\n{\n    IntoChunks {\n        inner: RefCell::new(GroupInner {\n            key: ChunkIndex::new(size),\n            iter: iter.into_iter(),\n            current_key: None,\n            current_elt: None,\n            done: false,\n            top_group: 0,\n            oldest_buffered_group: 0,\n            bottom_group: 0,\n            buffer: Vec::new(),\n            dropped_group: !0,\n        }),\n        index: Cell::new(0),\n    }\n}\n\n\n/// `ChunkLazy` is the storage for a lazy chunking operation.\n///\n/// `IntoChunks` behaves just like `GroupBy`: it is iterable, and\n/// it only buffers if several chunk iterators are alive at the same time.\n///\n/// This type implements `IntoIterator` (it is **not** an iterator\n/// itself), because the chunk iterators need to borrow from this\n/// value. It should be stored in a local variable or temporary and\n/// iterated.\n///\n/// Iterator element type is `Chunk`, each chunk's iterator.\n///\n/// See [`.chunks()`](../trait.Itertools.html#method.chunks) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct IntoChunks<I>\n    where I: Iterator,\n{\n    inner: RefCell<GroupInner<usize, I, ChunkIndex>>,\n    // the chunk iterator's current index. Keep this in the main value\n    // so that simultaneous iterators all use the same state.\n    index: Cell<usize>,\n}\n\n\nimpl<I> IntoChunks<I>\n    where I: Iterator,\n{\n    /// `client`: Index of chunk that requests next element\n    fn step(&self, client: usize) -> Option<I::Item> {\n        self.inner.borrow_mut().step(client)\n    }\n\n    /// `client`: Index of chunk\n    fn drop_group(&self, client: usize) {\n        self.inner.borrow_mut().drop_group(client)\n    }\n}\n\nimpl<'a, I> IntoIterator for &'a IntoChunks<I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    type Item = Chunk<'a, I>;\n    type IntoIter = Chunks<'a, I>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        Chunks {\n            parent: self,\n        }\n    }\n}\n\n\n/// An iterator that yields the Chunk iterators.\n///\n/// Iterator element type is `Chunk`.\n///\n/// See [`.chunks()`](../trait.Itertools.html#method.chunks) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Chunks<'a, I: 'a>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    parent: &'a IntoChunks<I>,\n}\n\nimpl<'a, I> Iterator for Chunks<'a, I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    type Item = Chunk<'a, I>;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let index = self.parent.index.get();\n        self.parent.index.set(index + 1);\n        let inner = &mut *self.parent.inner.borrow_mut();\n        inner.step(index).map(|elt| {\n            Chunk {\n                parent: self.parent,\n                index,\n                first: Some(elt),\n            }\n        })\n    }\n}\n\n/// An iterator for the elements in a single chunk.\n///\n/// Iterator element type is `I::Item`.\npub struct Chunk<'a, I: 'a>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    parent: &'a IntoChunks<I>,\n    index: usize,\n    first: Option<I::Item>,\n}\n\nimpl<'a, I> Drop for Chunk<'a, I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    fn drop(&mut self) {\n        self.parent.drop_group(self.index);\n    }\n}\n\nimpl<'a, I> Iterator for Chunk<'a, I>\n    where I: Iterator,\n          I::Item: 'a,\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if let elt @ Some(..) = self.first.take() {\n            return elt;\n        }\n        self.parent.step(self.index)\n    }\n}\n"],["1093","//! \"Diff\"ing iterators for caching elements to sequential collections without requiring the new\n//! elements' iterator to be `Clone`.\n//!\n//! - [**Diff**](./enum.Diff.html) (produced by the [**diff_with**](./fn.diff_with.html) function)\n//! describes the difference between two non-`Clone` iterators `I` and `J` after breaking ASAP from\n//! a lock-step comparison.\n\nuse crate::free::put_back;\nuse crate::structs::PutBack;\n\n/// A type returned by the [`diff_with`](./fn.diff_with.html) function.\n///\n/// `Diff` represents the way in which the elements yielded by the iterator `I` differ to some\n/// iterator `J`.\npub enum Diff<I, J>\n    where I: Iterator,\n          J: Iterator\n{\n    /// The index of the first non-matching element along with both iterator's remaining elements\n    /// starting with the first mis-match.\n    FirstMismatch(usize, PutBack<I>, PutBack<J>),\n    /// The total number of elements that were in `J` along with the remaining elements of `I`.\n    Shorter(usize, PutBack<I>),\n    /// The total number of elements that were in `I` along with the remaining elements of `J`.\n    Longer(usize, PutBack<J>),\n}\n\n/// Compares every element yielded by both `i` and `j` with the given function in lock-step and\n/// returns a `Diff` which describes how `j` differs from `i`.\n///\n/// If the number of elements yielded by `j` is less than the number of elements yielded by `i`,\n/// the number of `j` elements yielded will be returned along with `i`'s remaining elements as\n/// `Diff::Shorter`.\n///\n/// If the two elements of a step differ, the index of those elements along with the remaining\n/// elements of both `i` and `j` are returned as `Diff::FirstMismatch`.\n///\n/// If `i` becomes exhausted before `j` becomes exhausted, the number of elements in `i` along with\n/// the remaining `j` elements will be returned as `Diff::Longer`.\npub fn diff_with<I, J, F>(i: I, j: J, is_equal: F)\n    -> Option<Diff<I::IntoIter, J::IntoIter>>\n    where I: IntoIterator,\n          J: IntoIterator,\n          F: Fn(&I::Item, &J::Item) -> bool\n{\n    let mut i = i.into_iter();\n    let mut j = j.into_iter();\n    let mut idx = 0;\n    while let Some(i_elem) = i.next() {\n        match j.next() {\n            None => return Some(Diff::Shorter(idx, put_back(i).with_value(i_elem))),\n            Some(j_elem) => if !is_equal(&i_elem, &j_elem) {\n                let remaining_i = put_back(i).with_value(i_elem);\n                let remaining_j = put_back(j).with_value(j_elem);\n                return Some(Diff::FirstMismatch(idx, remaining_i, remaining_j));\n            },\n        }\n        idx += 1;\n    }\n    j.next().map(|j_elem| Diff::Longer(idx, put_back(j).with_value(j_elem)))\n}\n"],["1094","use std::cmp::Ordering::{Equal, Greater, Less};\nuse super::size_hint;\nuse std::iter::Fuse;\n\nuse crate::either_or_both::EitherOrBoth;\n\n// ZipLongest originally written by SimonSapin,\n// and dedicated to itertools https://github.com/rust-lang/rust/pull/19283\n\n/// An iterator which iterates two other iterators simultaneously\n///\n/// This iterator is *fused*.\n///\n/// See [`.zip_longest()`](../trait.Itertools.html#method.zip_longest) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct ZipLongest<T, U> {\n    a: Fuse<T>,\n    b: Fuse<U>,\n}\n\n/// Create a new `ZipLongest` iterator.\npub fn zip_longest<T, U>(a: T, b: U) -> ZipLongest<T, U> \n    where T: Iterator,\n          U: Iterator\n{\n    ZipLongest {\n        a: a.fuse(),\n        b: b.fuse(),\n    }\n}\n\nimpl<T, U> Iterator for ZipLongest<T, U>\n    where T: Iterator,\n          U: Iterator\n{\n    type Item = EitherOrBoth<T::Item, U::Item>;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        match (self.a.next(), self.b.next()) {\n            (None, None) => None,\n            (Some(a), None) => Some(EitherOrBoth::Left(a)),\n            (None, Some(b)) => Some(EitherOrBoth::Right(b)),\n            (Some(a), Some(b)) => Some(EitherOrBoth::Both(a, b)),\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::max(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\nimpl<T, U> DoubleEndedIterator for ZipLongest<T, U>\n    where T: DoubleEndedIterator + ExactSizeIterator,\n          U: DoubleEndedIterator + ExactSizeIterator\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        match self.a.len().cmp(&self.b.len()) {\n            Equal => match (self.a.next_back(), self.b.next_back()) {\n                (None, None) => None,\n                (Some(a), Some(b)) => Some(EitherOrBoth::Both(a, b)),\n                // These can only happen if .len() is inconsistent with .next_back()\n                (Some(a), None) => Some(EitherOrBoth::Left(a)),\n                (None, Some(b)) => Some(EitherOrBoth::Right(b)),\n            },\n            Greater => self.a.next_back().map(EitherOrBoth::Left),\n            Less => self.b.next_back().map(EitherOrBoth::Right),\n        }\n    }\n}\n\nimpl<T, U> ExactSizeIterator for ZipLongest<T, U>\n    where T: ExactSizeIterator,\n          U: ExactSizeIterator\n{}\n"],["1095","use std::fmt;\nuse std::cell::RefCell;\n\n/// Format all iterator elements lazily, separated by `sep`.\n///\n/// The format value can only be formatted once, after that the iterator is\n/// exhausted.\n///\n/// See [`.format_with()`](../trait.Itertools.html#method.format_with) for more information.\n#[derive(Clone)]\npub struct FormatWith<'a, I, F> {\n    sep: &'a str,\n    /// FormatWith uses interior mutability because Display::fmt takes &self.\n    inner: RefCell<Option<(I, F)>>,\n}\n\n/// Format all iterator elements lazily, separated by `sep`.\n///\n/// The format value can only be formatted once, after that the iterator is\n/// exhausted.\n///\n/// See [`.format()`](../trait.Itertools.html#method.format)\n/// for more information.\n#[derive(Clone)]\npub struct Format<'a, I> {\n    sep: &'a str,\n    /// Format uses interior mutability because Display::fmt takes &self.\n    inner: RefCell<Option<I>>,\n}\n\npub fn new_format<'a, I, F>(iter: I, separator: &'a str, f: F) -> FormatWith<'a, I, F>\n    where I: Iterator,\n          F: FnMut(I::Item, &mut dyn FnMut(&dyn fmt::Display) -> fmt::Result) -> fmt::Result\n{\n    FormatWith {\n        sep: separator,\n        inner: RefCell::new(Some((iter, f))),\n    }\n}\n\npub fn new_format_default<'a, I>(iter: I, separator: &'a str) -> Format<'a, I>\n    where I: Iterator,\n{\n    Format {\n        sep: separator,\n        inner: RefCell::new(Some(iter)),\n    }\n}\n\nimpl<'a, I, F> fmt::Display for FormatWith<'a, I, F>\n    where I: Iterator,\n          F: FnMut(I::Item, &mut dyn  FnMut(&dyn fmt::Display) -> fmt::Result) -> fmt::Result\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let (mut iter, mut format) = match self.inner.borrow_mut().take() {\n            Some(t) => t,\n            None => panic!(\"FormatWith: was already formatted once\"),\n        };\n\n        if let Some(fst) = iter.next() {\n            format(fst, &mut |disp: &dyn fmt::Display| disp.fmt(f))?;\n            for elt in iter {\n                if self.sep.len() > 0 {\n\n                    f.write_str(self.sep)?;\n                }\n                format(elt, &mut |disp: &dyn fmt::Display| disp.fmt(f))?;\n            }\n        }\n        Ok(())\n    }\n}\n\nimpl<'a, I> Format<'a, I>\n    where I: Iterator,\n{\n    fn format<F>(&self, f: &mut fmt::Formatter, mut cb: F) -> fmt::Result\n        where F: FnMut(&I::Item, &mut fmt::Formatter) -> fmt::Result,\n    {\n        let mut iter = match self.inner.borrow_mut().take() {\n            Some(t) => t,\n            None => panic!(\"Format: was already formatted once\"),\n        };\n\n        if let Some(fst) = iter.next() {\n            cb(&fst, f)?;\n            for elt in iter {\n                if self.sep.len() > 0 {\n                    f.write_str(self.sep)?;\n                }\n                cb(&elt, f)?;\n            }\n        }\n        Ok(())\n    }\n}\n\nmacro_rules! impl_format {\n    ($($fmt_trait:ident)*) => {\n        $(\n            impl<'a, I> fmt::$fmt_trait for Format<'a, I>\n                where I: Iterator,\n                      I::Item: fmt::$fmt_trait,\n            {\n                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                    self.format(f, fmt::$fmt_trait::fmt)\n                }\n            }\n        )*\n    }\n}\n\nimpl_format!{Display Debug\n             UpperExp LowerExp UpperHex LowerHex Octal Binary Pointer}\n"],["1096","use std::iter::Fuse;\nuse std::collections::VecDeque;\nuse crate::size_hint;\nuse crate::PeekingNext;\n\n/// See [`multipeek()`](../fn.multipeek.html) for more information.\n#[derive(Clone, Debug)]\npub struct MultiPeek<I>\n    where I: Iterator\n{\n    iter: Fuse<I>,\n    buf: VecDeque<I::Item>,\n    index: usize,\n}\n\n/// An iterator adaptor that allows the user to peek at multiple `.next()`\n/// values without advancing the base iterator.\npub fn multipeek<I>(iterable: I) -> MultiPeek<I::IntoIter>\n    where I: IntoIterator\n{\n    MultiPeek {\n        iter: iterable.into_iter().fuse(),\n        buf: VecDeque::new(),\n        index: 0,\n    }\n}\n\nimpl<I> MultiPeek<I>\n    where I: Iterator\n{\n    /// Reset the peeking â€œcursorâ€\n    pub fn reset_peek(&mut self) {\n        self.index = 0;\n    }\n}\n\nimpl<I: Iterator> MultiPeek<I> {\n    /// Works exactly like `.next()` with the only difference that it doesn't\n    /// advance itself. `.peek()` can be called multiple times, to peek\n    /// further ahead.\n    pub fn peek(&mut self) -> Option<&I::Item> {\n        let ret = if self.index < self.buf.len() {\n            Some(&self.buf[self.index])\n        } else {\n            match self.iter.next() {\n                Some(x) => {\n                    self.buf.push_back(x);\n                    Some(&self.buf[self.index])\n                }\n                None => return None,\n            }\n        };\n\n        self.index += 1;\n        ret\n    }\n}\n\nimpl<I> PeekingNext for MultiPeek<I>\n    where I: Iterator,\n{\n    fn peeking_next<F>(&mut self, accept: F) -> Option<Self::Item>\n        where F: FnOnce(&Self::Item) -> bool\n    {\n        if self.buf.is_empty() {\n            if let Some(r) = self.peek() {\n                if !accept(r) { return None }\n            }\n        } else {\n            if let Some(r) = self.buf.get(0) {\n                if !accept(r) { return None }\n            }\n        }\n        self.next()\n    }\n}\n\nimpl<I> Iterator for MultiPeek<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<I::Item> {\n        self.index = 0;\n        if self.buf.is_empty() {\n            self.iter.next()\n        } else {\n            self.buf.pop_front()\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.iter.size_hint(), self.buf.len())\n    }\n}\n\n// Same size\nimpl<I> ExactSizeIterator for MultiPeek<I>\n    where I: ExactSizeIterator\n{}\n\n\n"],["1097","//! Arithmetic on **Iterator** *.size_hint()* values.\n//!\n\nuse std::usize;\nuse std::cmp;\n\n/// **SizeHint** is the return type of **Iterator::size_hint()**.\npub type SizeHint = (usize, Option<usize>);\n\n/// Add **SizeHint** correctly.\n#[inline]\npub fn add(a: SizeHint, b: SizeHint) -> SizeHint {\n    let min = a.0.checked_add(b.0).unwrap_or(usize::MAX);\n    let max = match (a.1, b.1) {\n        (Some(x), Some(y)) => x.checked_add(y),\n        _ => None,\n    };\n\n    (min, max)\n}\n\n/// Add **x** correctly to a **SizeHint**.\n#[inline]\npub fn add_scalar(sh: SizeHint, x: usize) -> SizeHint {\n    let (mut low, mut hi) = sh;\n    low = low.saturating_add(x);\n    hi = hi.and_then(|elt| elt.checked_add(x));\n    (low, hi)\n}\n\n/// Sbb **x** correctly to a **SizeHint**.\n#[inline]\n#[allow(dead_code)]\npub fn sub_scalar(sh: SizeHint, x: usize) -> SizeHint {\n    let (mut low, mut hi) = sh;\n    low = low.saturating_sub(x);\n    hi = hi.map(|elt| elt.saturating_sub(x));\n    (low, hi)\n}\n\n\n/// Multiply **SizeHint** correctly\n///\n/// ```ignore\n/// use std::usize;\n/// use itertools::size_hint;\n///\n/// assert_eq!(size_hint::mul((3, Some(4)), (3, Some(4))),\n///            (9, Some(16)));\n///\n/// assert_eq!(size_hint::mul((3, Some(4)), (usize::MAX, None)),\n///            (usize::MAX, None));\n///\n/// assert_eq!(size_hint::mul((3, None), (0, Some(0))),\n///            (0, Some(0)));\n/// ```\n#[inline]\npub fn mul(a: SizeHint, b: SizeHint) -> SizeHint {\n    let low = a.0.checked_mul(b.0).unwrap_or(usize::MAX);\n    let hi = match (a.1, b.1) {\n        (Some(x), Some(y)) => x.checked_mul(y),\n        (Some(0), None) | (None, Some(0)) => Some(0),\n        _ => None,\n    };\n    (low, hi)\n}\n\n/// Multiply **x** correctly with a **SizeHint**.\n#[inline]\npub fn mul_scalar(sh: SizeHint, x: usize) -> SizeHint {\n    let (mut low, mut hi) = sh;\n    low = low.saturating_mul(x);\n    hi = hi.and_then(|elt| elt.checked_mul(x));\n    (low, hi)\n}\n\n/// Return the maximum\n#[inline]\npub fn max(a: SizeHint, b: SizeHint) -> SizeHint {\n    let (a_lower, a_upper) = a;\n    let (b_lower, b_upper) = b;\n\n    let lower = cmp::max(a_lower, b_lower);\n\n    let upper = match (a_upper, b_upper) {\n        (Some(x), Some(y)) => Some(cmp::max(x, y)),\n        _ => None,\n    };\n\n    (lower, upper)\n}\n\n/// Return the minimum\n#[inline]\npub fn min(a: SizeHint, b: SizeHint) -> SizeHint {\n    let (a_lower, a_upper) = a;\n    let (b_lower, b_upper) = b;\n    let lower = cmp::min(a_lower, b_lower);\n    let upper = match (a_upper, b_upper) {\n        (Some(u1), Some(u2)) => Some(cmp::min(u1, u2)),\n        _ => a_upper.or(b_upper),\n    };\n    (lower, upper)\n}\n"],["1098","use super::size_hint;\n\nuse std::cell::RefCell;\nuse std::collections::VecDeque;\nuse std::rc::Rc;\n\n/// Common buffer object for the two tee halves\n#[derive(Debug)]\nstruct TeeBuffer<A, I> {\n    backlog: VecDeque<A>,\n    iter: I,\n    /// The owner field indicates which id should read from the backlog\n    owner: bool,\n}\n\n/// One half of an iterator pair where both return the same elements.\n///\n/// See [`.tee()`](../trait.Itertools.html#method.tee) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct Tee<I>\n    where I: Iterator\n{\n    rcbuffer: Rc<RefCell<TeeBuffer<I::Item, I>>>,\n    id: bool,\n}\n\npub fn new<I>(iter: I) -> (Tee<I>, Tee<I>)\n    where I: Iterator\n{\n    let buffer = TeeBuffer{backlog: VecDeque::new(), iter, owner: false};\n    let t1 = Tee{rcbuffer: Rc::new(RefCell::new(buffer)), id: true};\n    let t2 = Tee{rcbuffer: t1.rcbuffer.clone(), id: false};\n    (t1, t2)\n}\n\nimpl<I> Iterator for Tee<I>\n    where I: Iterator,\n          I::Item: Clone\n{\n    type Item = I::Item;\n    fn next(&mut self) -> Option<I::Item> {\n        // .borrow_mut may fail here -- but only if the user has tied some kind of weird\n        // knot where the iterator refers back to itself.\n        let mut buffer = self.rcbuffer.borrow_mut();\n        if buffer.owner == self.id {\n            match buffer.backlog.pop_front() {\n                None => {}\n                some_elt => return some_elt,\n            }\n        }\n        match buffer.iter.next() {\n            None => None,\n            Some(elt) => {\n                buffer.backlog.push_back(elt.clone());\n                buffer.owner = !self.id;\n                Some(elt)\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let buffer = self.rcbuffer.borrow();\n        let sh = buffer.iter.size_hint();\n\n        if buffer.owner == self.id {\n            let log_len = buffer.backlog.len();\n            size_hint::add_scalar(sh, log_len)\n        } else {\n            sh\n        }\n    }\n}\n\nimpl<I> ExactSizeIterator for Tee<I>\n    where I: ExactSizeIterator,\n          I::Item: Clone\n{}\n"],["1099","use super::size_hint;\n\n/// See [`multizip`](../fn.multizip.html) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Zip<T> {\n    t: T,\n}\n\n/// An iterator that generalizes *.zip()* and allows running multiple iterators in lockstep.\n///\n/// The iterator `Zip<(I, J, ..., M)>` is formed from a tuple of iterators (or values that\n/// implement `IntoIterator`) and yields elements\n/// until any of the subiterators yields `None`.\n///\n/// The iterator element type is a tuple like like `(A, B, ..., E)` where `A` to `E` are the\n/// element types of the subiterator.\n///\n/// **Note:** The result of this macro is a value of a named type (`Zip<(I, J,\n/// ..)>` of each component iterator `I, J, ...`) if each component iterator is\n/// nameable.\n///\n/// Prefer [`izip!()`] over `multizip` for the performance benefits of using the\n/// standard library `.zip()`. Prefer `multizip` if a nameable type is needed.\n///\n/// [`izip!()`]: macro.izip.html\n///\n/// ```\n/// use itertools::multizip;\n///\n/// // iterate over three sequences side-by-side\n/// let mut results = [0, 0, 0, 0];\n/// let inputs = [3, 7, 9, 6];\n///\n/// for (r, index, input) in multizip((&mut results, 0..10, &inputs)) {\n///     *r = index * 10 + input;\n/// }\n///\n/// assert_eq!(results, [0 + 3, 10 + 7, 29, 36]);\n/// ```\npub fn multizip<T, U>(t: U) -> Zip<T>\n    where Zip<T>: From<U>,\n          Zip<T>: Iterator,\n{\n    Zip::from(t)\n}\n\nmacro_rules! impl_zip_iter {\n    ($($B:ident),*) => (\n        #[allow(non_snake_case)]\n        impl<$($B: IntoIterator),*> From<($($B,)*)> for Zip<($($B::IntoIter,)*)> {\n            fn from(t: ($($B,)*)) -> Self {\n                let ($($B,)*) = t;\n                Zip { t: ($($B.into_iter(),)*) }\n            }\n        }\n\n        #[allow(non_snake_case)]\n        #[allow(unused_assignments)]\n        impl<$($B),*> Iterator for Zip<($($B,)*)>\n            where\n            $(\n                $B: Iterator,\n            )*\n        {\n            type Item = ($($B::Item,)*);\n\n            fn next(&mut self) -> Option<Self::Item>\n            {\n                let ($(ref mut $B,)*) = self.t;\n\n                // NOTE: Just like iter::Zip, we check the iterators\n                // for None in order. We may finish unevenly (some\n                // iterators gave n + 1 elements, some only n).\n                $(\n                    let $B = match $B.next() {\n                        None => return None,\n                        Some(elt) => elt\n                    };\n                )*\n                Some(($($B,)*))\n            }\n\n            fn size_hint(&self) -> (usize, Option<usize>)\n            {\n                let sh = (::std::usize::MAX, None);\n                let ($(ref $B,)*) = self.t;\n                $(\n                    let sh = size_hint::min($B.size_hint(), sh);\n                )*\n                sh\n            }\n        }\n\n        #[allow(non_snake_case)]\n        impl<$($B),*> ExactSizeIterator for Zip<($($B,)*)> where\n            $(\n                $B: ExactSizeIterator,\n            )*\n        { }\n    );\n}\n\nimpl_zip_iter!(A);\nimpl_zip_iter!(A, B);\nimpl_zip_iter!(A, B, C);\nimpl_zip_iter!(A, B, C, D);\nimpl_zip_iter!(A, B, C, D, E);\nimpl_zip_iter!(A, B, C, D, E, F);\nimpl_zip_iter!(A, B, C, D, E, F, G);\nimpl_zip_iter!(A, B, C, D, E, F, G, H);\n"],["1100","//! Iterators that are sources (produce elements from parameters,\n//! not from another iterator).\n#![allow(deprecated)]\n\nuse std::fmt;\nuse std::mem;\n\n/// See [`repeat_call`](../fn.repeat_call.html) for more information.\n#[derive(Clone)]\n#[deprecated(note=\"Use std repeat_with() instead\", since=\"0.8\")]\npub struct RepeatCall<F> {\n    f: F,\n}\n\nimpl<F> fmt::Debug for RepeatCall<F>\n{\n    debug_fmt_fields!(RepeatCall, );\n}\n\n/// An iterator source that produces elements indefinitely by calling\n/// a given closure.\n///\n/// Iterator element type is the return type of the closure.\n///\n/// ```\n/// use itertools::repeat_call;\n/// use itertools::Itertools;\n/// use std::collections::BinaryHeap;\n///\n/// let mut heap = BinaryHeap::from(vec![2, 5, 3, 7, 8]);\n///\n/// // extract each element in sorted order\n/// for element in repeat_call(|| heap.pop()).while_some() {\n///     print!(\"{}\", element);\n/// }\n///\n/// itertools::assert_equal(\n///     repeat_call(|| 1).take(5),\n///     vec![1, 1, 1, 1, 1]\n/// );\n/// ```\n#[deprecated(note=\"Use std repeat_with() instead\", since=\"0.8\")]\npub fn repeat_call<F, A>(function: F) -> RepeatCall<F>\n    where F: FnMut() -> A\n{\n    RepeatCall { f: function }\n}\n\nimpl<A, F> Iterator for RepeatCall<F>\n    where F: FnMut() -> A\n{\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<A> {\n        Some((self.f)())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (usize::max_value(), None)\n    }\n}\n\n/// Creates a new unfold source with the specified closure as the \"iterator\n/// function\" and an initial state to eventually pass to the closure\n///\n/// `unfold` is a general iterator builder: it has a mutable state value,\n/// and a closure with access to the state that produces the next value.\n///\n/// This more or less equivalent to a regular struct with an `Iterator`\n/// implementation, and is useful for one-off iterators.\n///\n/// ```\n/// // an iterator that yields sequential Fibonacci numbers,\n/// // and stops at the maximum representable value.\n///\n/// use itertools::unfold;\n///\n/// let (mut x1, mut x2) = (1u32, 1u32);\n/// let mut fibonacci = unfold((), move |_| {\n///     // Attempt to get the next Fibonacci number\n///     let next = x1.saturating_add(x2);\n///\n///     // Shift left: ret <- x1 <- x2 <- next\n///     let ret = x1;\n///     x1 = x2;\n///     x2 = next;\n///\n///     // If addition has saturated at the maximum, we are finished\n///     if ret == x1 && ret > 1 {\n///         return None;\n///     }\n///\n///     Some(ret)\n/// });\n///\n/// itertools::assert_equal(fibonacci.by_ref().take(8),\n///                         vec![1, 1, 2, 3, 5, 8, 13, 21]);\n/// assert_eq!(fibonacci.last(), Some(2_971_215_073))\n/// ```\npub fn unfold<A, St, F>(initial_state: St, f: F) -> Unfold<St, F>\n    where F: FnMut(&mut St) -> Option<A>\n{\n    Unfold {\n        f,\n        state: initial_state,\n    }\n}\n\nimpl<St, F> fmt::Debug for Unfold<St, F>\n    where St: fmt::Debug,\n{\n    debug_fmt_fields!(Unfold, state);\n}\n\n/// See [`unfold`](../fn.unfold.html) for more information.\n#[derive(Clone)]\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\npub struct Unfold<St, F> {\n    f: F,\n    /// Internal state that will be passed to the closure on the next iteration\n    pub state: St,\n}\n\nimpl<A, St, F> Iterator for Unfold<St, F>\n    where F: FnMut(&mut St) -> Option<A>\n{\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<A> {\n        (self.f)(&mut self.state)\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // no possible known bounds at this point\n        (0, None)\n    }\n}\n\n/// An iterator that infinitely applies function to value and yields results.\n///\n/// This `struct` is created by the [`iterate()`] function. See its documentation for more.\n///\n/// [`iterate()`]: ../fn.iterate.html\n#[derive(Clone)]\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\npub struct Iterate<St, F> {\n    state: St,\n    f: F,\n}\n\nimpl<St, F> fmt::Debug for Iterate<St, F>\n    where St: fmt::Debug,\n{\n    debug_fmt_fields!(Iterate, state);\n}\n\nimpl<St, F> Iterator for Iterate<St, F>\n    where F: FnMut(&St) -> St\n{\n    type Item = St;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let next_state = (self.f)(&self.state);\n        Some(mem::replace(&mut self.state, next_state))\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (usize::max_value(), None)\n    }\n}\n\n/// Creates a new iterator that infinitely applies function to value and yields results.\n///\n/// ```\n/// use itertools::iterate;\n///\n/// itertools::assert_equal(iterate(1, |&i| i * 3).take(5), vec![1, 3, 9, 27, 81]);\n/// ```\npub fn iterate<St, F>(initial_value: St, f: F) -> Iterate<St, F>\n    where F: FnMut(&St) -> St\n{\n    Iterate {\n        state: initial_value,\n        f,\n    }\n}\n"],["1101","//! \n//! Implementation's internal macros\n\nmacro_rules! debug_fmt_fields {\n    ($tyname:ident, $($($field:ident).+),*) => {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            f.debug_struct(stringify!($tyname))\n                $(\n              .field(stringify!($($field).+), &self.$($field).+)\n              )*\n              .finish()\n        }\n    }\n}\n\nmacro_rules! clone_fields {\n    ($($field:ident),*) => {\n        fn clone(&self) -> Self {\n            Self {\n                $($field: self.$field.clone(),)*\n            }\n        }\n    }\n}\n"],["1102","#![cfg(feature = \"use_std\")]\n\nuse std::collections::HashMap;\nuse std::hash::Hash;\nuse std::iter::Iterator;\n\n/// Return a `HashMap` of keys mapped to a list of their corresponding values.\n///\n/// See [`.into_group_map()`](../trait.Itertools.html#method.into_group_map)\n/// for more information.\npub fn into_group_map<I, K, V>(iter: I) -> HashMap<K, Vec<V>>\n    where I: Iterator<Item=(K, V)>,\n          K: Hash + Eq,\n{\n    let mut lookup = HashMap::new();\n\n    for (key, val) in iter {\n        lookup.entry(key).or_insert(Vec::new()).push(val);\n    }\n\n    lookup\n}"],["1103","use crate::EitherOrBoth::*;\n\nuse either::Either;\n\n/// Value that either holds a single A or B, or both.\n#[derive(Clone, PartialEq, Eq, Hash, Debug)]\npub enum EitherOrBoth<A, B> {\n    /// Both values are present.\n    Both(A, B),\n    /// Only the left value of type `A` is present.\n    Left(A),\n    /// Only the right value of type `B` is present.\n    Right(B),\n}\n\nimpl<A, B> EitherOrBoth<A, B> {\n    /// If `Left`, or `Both`, return true, otherwise, return false.\n    pub fn has_left(&self) -> bool {\n        self.as_ref().left().is_some()\n    }\n\n    /// If `Right`, or `Both`, return true, otherwise, return false.\n    pub fn has_right(&self) -> bool {\n        self.as_ref().right().is_some()\n    }\n\n    /// If Left, return true otherwise, return false.\n    /// Exclusive version of [`has_left`].\n    pub fn is_left(&self) -> bool {\n        match *self {\n            Left(_) => true,\n            _ => false,\n        }\n    }\n\n    /// If Right, return true otherwise, return false.\n    /// Exclusive version of [`has_right`].\n    pub fn is_right(&self) -> bool {\n        match *self {\n            Right(_) => true,\n            _ => false,\n        }\n    }\n\n    /// If Right, return true otherwise, return false.\n    /// Equivalent to `self.as_ref().both().is_some()`.\n    pub fn is_both(&self) -> bool {\n        self.as_ref().both().is_some()\n    }\n\n    /// If `Left`, or `Both`, return `Some` with the left value, otherwise, return `None`.\n    pub fn left(self) -> Option<A> {\n        match self {\n            Left(left) | Both(left, _) => Some(left),\n            _ => None,\n        }\n    }\n\n    /// If `Right`, or `Both`, return `Some` with the right value, otherwise, return `None`.\n    pub fn right(self) -> Option<B> {\n        match self {\n            Right(right) | Both(_, right) => Some(right),\n            _ => None,\n        }\n    }\n\n    /// If Both, return `Some` tuple containing left and right.\n    pub fn both(self) -> Option<(A, B)> {\n        match self {\n            Both(a, b) => Some((a, b)),\n            _ => None,\n        }\n    }\n\n    /// Converts from `&EitherOrBoth<A, B>` to `EitherOrBoth<&A, &B>`.\n    pub fn as_ref(&self) -> EitherOrBoth<&A, &B> {\n        match *self {\n            Left(ref left) => Left(left),\n            Right(ref right) => Right(right),\n            Both(ref left, ref right) => Both(left, right),\n        }\n    }\n\n    /// Converts from `&mut EitherOrBoth<A, B>` to `EitherOrBoth<&mut A, &mut B>`.\n    pub fn as_mut(&mut self) -> EitherOrBoth<&mut A, &mut B> {\n        match *self {\n            Left(ref mut left) => Left(left),\n            Right(ref mut right) => Right(right),\n            Both(ref mut left, ref mut right) => Both(left, right),\n        }\n    }\n\n    /// Convert `EitherOrBoth<A, B>` to `EitherOrBoth<B, A>`.\n    pub fn flip(self) -> EitherOrBoth<B, A> {\n        match self {\n            Left(a) => Right(a),\n            Right(b) => Left(b),\n            Both(a, b) => Both(b, a),\n        }\n    }\n\n    /// Apply the function `f` on the value `a` in `Left(a)` or `Both(a, b)` variants. If it is\n    /// present rewrapping the result in `self`'s original variant.\n    pub fn map_left<F, M>(self, f: F) -> EitherOrBoth<M, B>\n    where\n        F: FnOnce(A) -> M,\n    {\n        match self {\n            Both(a, b) => Both(f(a), b),\n            Left(a) => Left(f(a)),\n            Right(b) => Right(b),\n        }\n    }\n\n    /// Apply the function `f` on the value `b` in `Right(b)` or `Both(a, b)` variants.\n    /// If it is present rewrapping the result in `self`'s original variant.\n    pub fn map_right<F, M>(self, f: F) -> EitherOrBoth<A, M>\n    where\n        F: FnOnce(B) -> M,\n    {\n        match self {\n            Left(a) => Left(a),\n            Right(b) => Right(f(b)),\n            Both(a, b) => Both(a, f(b)),\n        }\n    }\n\n    /// Apply the functions `f` and `g` on the value `a` and `b` respectively;\n    /// found in `Left(a)`, `Right(b)`, or `Both(a, b)` variants.\n    /// The Result is rewrapped `self`'s original variant.\n    pub fn map_any<F, L, G, R>(self, f: F, g: G) -> EitherOrBoth<L, R>\n    where\n        F: FnOnce(A) -> L,\n        G: FnOnce(B) -> R,\n    {\n        match self {\n            Left(a) => Left(f(a)),\n            Right(b) => Right(g(b)),\n            Both(a, b) => Both(f(a), g(b)),\n        }\n    }\n\n    /// Apply the function `f` on the value `b` in `Right(b)` or `Both(a, _)` variants if it is\n    /// present.\n    pub fn left_and_then<F, L>(self, f: F) -> EitherOrBoth<L, B>\n    where\n        F: FnOnce(A) -> EitherOrBoth<L, B>,\n    {\n        match self {\n            Left(a) | Both(a, _) => f(a),\n            Right(b) => Right(b),\n        }\n    }\n\n    /// Apply the function `f` on the value `a`\n    /// in `Left(a)` or `Both(a, _)` variants if it is present.\n    pub fn right_and_then<F, R>(self, f: F) -> EitherOrBoth<A, R>\n    where\n        F: FnOnce(B) -> EitherOrBoth<A, R>,\n    {\n        match self {\n            Left(a) => Left(a),\n            Right(b) | Both(_, b) => f(b),\n        }\n    }\n}\n\nimpl<T> EitherOrBoth<T, T> {\n    /// Return either value of left, right, or the product of `f` applied where `Both` are present.\n    pub fn reduce<F>(self, f: F) -> T\n    where\n        F: FnOnce(T, T) -> T,\n    {\n        match self {\n            Left(a) => a,\n            Right(b) => b,\n            Both(a, b) => f(a, b),\n        }\n    }\n}\n\nimpl<A, B> Into<Option<Either<A, B>>> for EitherOrBoth<A, B> {\n    fn into(self) -> Option<Either<A, B>> {\n        match self {\n            EitherOrBoth::Left(l) => Some(Either::Left(l)),\n            EitherOrBoth::Right(r) => Some(Either::Right(r)),\n            _ => None,\n        }\n    }\n}\n"],["1104","\nmacro_rules! impl_cons_iter(\n    ($_A:ident, $_B:ident, ) => (); // stop\n\n    ($A:ident, $($B:ident,)*) => (\n        impl_cons_iter!($($B,)*);\n        #[allow(non_snake_case)]\n        impl<X, Iter, $($B),*> Iterator for ConsTuples<Iter, (($($B,)*), X)>\n            where Iter: Iterator<Item = (($($B,)*), X)>,\n        {\n            type Item = ($($B,)* X, );\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next().map(|(($($B,)*), x)| ($($B,)* x, ))\n            }\n\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n            fn fold<Acc, Fold>(self, accum: Acc, mut f: Fold) -> Acc\n                where Fold: FnMut(Acc, Self::Item) -> Acc,\n            {\n                self.iter.fold(accum, move |acc, (($($B,)*), x)| f(acc, ($($B,)* x, )))\n            }\n        }\n\n        #[allow(non_snake_case)]\n        impl<X, Iter, $($B),*> DoubleEndedIterator for ConsTuples<Iter, (($($B,)*), X)>\n            where Iter: DoubleEndedIterator<Item = (($($B,)*), X)>,\n        {\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next().map(|(($($B,)*), x)| ($($B,)* x, ))\n            }\n        }\n\n    );\n);\n\nimpl_cons_iter!(A, B, C, D, E, F, G, H,);\n\n/// An iterator that maps an iterator of tuples like\n/// `((A, B), C)` to an iterator of `(A, B, C)`.\n///\n/// Used by the `iproduct!()` macro.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Debug)]\npub struct ConsTuples<I, J>\n    where I: Iterator<Item=J>,\n{\n    iter: I,\n}\n\nimpl<I, J> Clone for ConsTuples<I, J>\n    where I: Clone + Iterator<Item=J>,\n{\n    clone_fields!(iter);\n}\n\n/// Create an iterator that maps for example iterators of\n/// `((A, B), C)` to `(A, B, C)`.\npub fn cons_tuples<I, J>(iterable: I) -> ConsTuples<I, J>\n    where I: Iterator<Item=J>\n{\n    ConsTuples { iter: iterable.into_iter() }\n}\n"],["1105","use std::iter::ExactSizeIterator;\n\nuse crate::size_hint;\n\n/// Iterator returned for the error case of `IterTools::exactly_one()`\n/// This iterator yields exactly the same elements as the input iterator.\n///\n/// During the execution of exactly_one the iterator must be mutated.  This wrapper\n/// effectively \"restores\" the state of the input iterator when it's handed back.\n///\n/// This is very similar to PutBackN except this iterator only supports 0-2 elements and does not\n/// use a `Vec`.\n#[derive(Debug, Clone)]\npub struct ExactlyOneError<I>\nwhere\n    I: Iterator,\n{\n    first_two: (Option<I::Item>, Option<I::Item>),\n    inner: I,\n}\n\nimpl<I> ExactlyOneError<I>\nwhere\n    I: Iterator,\n{\n    /// Creates a new `ExactlyOneErr` iterator.\n    pub(crate) fn new(first_two: (Option<I::Item>, Option<I::Item>), inner: I) -> Self {\n        Self { first_two, inner }\n    }\n}\n\nimpl<I> Iterator for ExactlyOneError<I>\nwhere\n    I: Iterator,\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.first_two\n            .0\n            .take()\n            .or_else(|| self.first_two.1.take())\n            .or_else(|| self.inner.next())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let mut additional_len = 0;\n        if self.first_two.0.is_some() {\n            additional_len += 1;\n        }\n        if self.first_two.1.is_some() {\n            additional_len += 1;\n        }\n        size_hint::add_scalar(self.inner.size_hint(), additional_len)\n    }\n}\n\nimpl<I> ExactSizeIterator for ExactlyOneError<I> where I: ExactSizeIterator {}\n"],["1106","//! Licensed under the Apache License, Version 2.0\n//! http://www.apache.org/licenses/LICENSE-2.0 or the MIT license\n//! http://opensource.org/licenses/MIT, at your\n//! option. This file may not be copied, modified, or distributed\n//! except according to those terms.\n\nmod multi_product;\n#[cfg(feature = \"use_std\")]\npub use self::multi_product::*;\n\nuse std::fmt;\nuse std::mem::replace;\nuse std::iter::{Fuse, Peekable, FromIterator};\nuse std::marker::PhantomData;\nuse crate::size_hint;\n\n/// An iterator adaptor that alternates elements from two iterators until both\n/// run out.\n///\n/// This iterator is *fused*.\n///\n/// See [`.interleave()`](../trait.Itertools.html#method.interleave) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Interleave<I, J> {\n    a: Fuse<I>,\n    b: Fuse<J>,\n    flag: bool,\n}\n\n/// Create an iterator that interleaves elements in `i` and `j`.\n///\n/// `IntoIterator` enabled version of `i.interleave(j)`.\n///\n/// ```\n/// use itertools::interleave;\n///\n/// for elt in interleave(&[1, 2, 3], &[2, 3, 4]) {\n///     /* loop body */\n/// }\n/// ```\npub fn interleave<I, J>(i: I, j: J) -> Interleave<<I as IntoIterator>::IntoIter, <J as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>\n{\n    Interleave {\n        a: i.into_iter().fuse(),\n        b: j.into_iter().fuse(),\n        flag: false,\n    }\n}\n\nimpl<I, J> Iterator for Interleave<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<I::Item> {\n        self.flag = !self.flag;\n        if self.flag {\n            match self.a.next() {\n                None => self.b.next(),\n                r => r,\n            }\n        } else {\n            match self.b.next() {\n                None => self.a.next(),\n                r => r,\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\n/// An iterator adaptor that alternates elements from the two iterators until\n/// one of them runs out.\n///\n/// This iterator is *fused*.\n///\n/// See [`.interleave_shortest()`](../trait.Itertools.html#method.interleave_shortest)\n/// for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct InterleaveShortest<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    it0: I,\n    it1: J,\n    phase: bool, // false ==> it0, true ==> it1\n}\n\n/// Create a new `InterleaveShortest` iterator.\npub fn interleave_shortest<I, J>(a: I, b: J) -> InterleaveShortest<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    InterleaveShortest {\n        it0: a,\n        it1: b,\n        phase: false,\n    }\n}\n\nimpl<I, J> Iterator for InterleaveShortest<I, J>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    type Item = I::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<I::Item> {\n        match self.phase {\n            false => match self.it0.next() {\n                None => None,\n                e => {\n                    self.phase = true;\n                    e\n                }\n            },\n            true => match self.it1.next() {\n                None => None,\n                e => {\n                    self.phase = false;\n                    e\n                }\n            },\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (curr_hint, next_hint) = {\n            let it0_hint = self.it0.size_hint();\n            let it1_hint = self.it1.size_hint();\n            if self.phase {\n                (it1_hint, it0_hint)\n            } else {\n                (it0_hint, it1_hint)\n            }\n        };\n        let (curr_lower, curr_upper) = curr_hint;\n        let (next_lower, next_upper) = next_hint;\n        let (combined_lower, combined_upper) =\n            size_hint::mul_scalar(size_hint::min(curr_hint, next_hint), 2);\n        let lower =\n            if curr_lower > next_lower {\n                combined_lower + 1\n            } else {\n                combined_lower\n            };\n        let upper = {\n            let extra_elem = match (curr_upper, next_upper) {\n                (_, None) => false,\n                (None, Some(_)) => true,\n                (Some(curr_max), Some(next_max)) => curr_max > next_max,\n            };\n            if extra_elem {\n                combined_upper.and_then(|x| x.checked_add(1))\n            } else {\n                combined_upper\n            }\n        };\n        (lower, upper)\n    }\n}\n\n#[derive(Clone, Debug)]\n/// An iterator adaptor that allows putting back a single\n/// item to the front of the iterator.\n///\n/// Iterator element type is `I::Item`.\npub struct PutBack<I>\n    where I: Iterator\n{\n    top: Option<I::Item>,\n    iter: I,\n}\n\n/// Create an iterator where you can put back a single item\npub fn put_back<I>(iterable: I) -> PutBack<I::IntoIter>\n    where I: IntoIterator\n{\n    PutBack {\n        top: None,\n        iter: iterable.into_iter(),\n    }\n}\n\nimpl<I> PutBack<I>\n    where I: Iterator\n{\n    /// put back value `value` (builder method)\n    pub fn with_value(mut self, value: I::Item) -> Self {\n        self.put_back(value);\n        self\n    }\n\n    /// Split the `PutBack` into its parts.\n    #[inline]\n    pub fn into_parts(self) -> (Option<I::Item>, I) {\n        let PutBack{top, iter} = self;\n        (top, iter)\n    }\n\n    /// Put back a single value to the front of the iterator.\n    ///\n    /// If a value is already in the put back slot, it is overwritten.\n    #[inline]\n    pub fn put_back(&mut self, x: I::Item) {\n        self.top = Some(x)\n    }\n}\n\nimpl<I> Iterator for PutBack<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<I::Item> {\n        match self.top {\n            None => self.iter.next(),\n            ref mut some => some.take(),\n        }\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // Not ExactSizeIterator because size may be larger than usize\n        size_hint::add_scalar(self.iter.size_hint(), self.top.is_some() as usize)\n    }\n\n    fn count(self) -> usize {\n        self.iter.count() + (self.top.is_some() as usize)\n    }\n\n    fn last(self) -> Option<Self::Item> {\n        self.iter.last().or(self.top)\n    }\n\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        match self.top {\n            None => self.iter.nth(n),\n            ref mut some => {\n                if n == 0 {\n                    some.take()\n                } else {\n                    *some = None;\n                    self.iter.nth(n - 1)\n                }\n            }\n        }\n    }\n\n    fn all<G>(&mut self, mut f: G) -> bool\n        where G: FnMut(Self::Item) -> bool\n    {\n        if let Some(elt) = self.top.take() {\n            if !f(elt) {\n                return false;\n            }\n        }\n        self.iter.all(f)\n    }\n\n    fn fold<Acc, G>(mut self, init: Acc, mut f: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        let mut accum = init;\n        if let Some(elt) = self.top.take() {\n            accum = f(accum, elt);\n        }\n        self.iter.fold(accum, f)\n    }\n}\n\n#[derive(Debug, Clone)]\n/// An iterator adaptor that iterates over the cartesian product of\n/// the element sets of two iterators `I` and `J`.\n///\n/// Iterator element type is `(I::Item, J::Item)`.\n///\n/// See [`.cartesian_product()`](../trait.Itertools.html#method.cartesian_product) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Product<I, J>\n    where I: Iterator\n{\n    a: I,\n    a_cur: Option<I::Item>,\n    b: J,\n    b_orig: J,\n}\n\n/// Create a new cartesian product iterator\n///\n/// Iterator element type is `(I::Item, J::Item)`.\npub fn cartesian_product<I, J>(mut i: I, j: J) -> Product<I, J>\n    where I: Iterator,\n          J: Clone + Iterator,\n          I::Item: Clone\n{\n    Product {\n        a_cur: i.next(),\n        a: i,\n        b: j.clone(),\n        b_orig: j,\n    }\n}\n\n\nimpl<I, J> Iterator for Product<I, J>\n    where I: Iterator,\n          J: Clone + Iterator,\n          I::Item: Clone\n{\n    type Item = (I::Item, J::Item);\n    fn next(&mut self) -> Option<(I::Item, J::Item)> {\n        let elt_b = match self.b.next() {\n            None => {\n                self.b = self.b_orig.clone();\n                match self.b.next() {\n                    None => return None,\n                    Some(x) => {\n                        self.a_cur = self.a.next();\n                        x\n                    }\n                }\n            }\n            Some(x) => x\n        };\n        match self.a_cur {\n            None => None,\n            Some(ref a) => {\n                Some((a.clone(), elt_b))\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let has_cur = self.a_cur.is_some() as usize;\n        // Not ExactSizeIterator because size may be larger than usize\n        let (b_min, b_max) = self.b.size_hint();\n\n        // Compute a * b_orig + b for both lower and upper bound\n        size_hint::add(\n            size_hint::mul(self.a.size_hint(), self.b_orig.size_hint()),\n            (b_min * has_cur, b_max.map(move |x| x * has_cur)))\n    }\n\n    fn fold<Acc, G>(mut self, mut accum: Acc, mut f: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        // use a split loop to handle the loose a_cur as well as avoiding to\n        // clone b_orig at the end.\n        if let Some(mut a) = self.a_cur.take() {\n            let mut b = self.b;\n            loop {\n                accum = b.fold(accum, |acc, elt| f(acc, (a.clone(), elt)));\n\n                // we can only continue iterating a if we had a first element;\n                if let Some(next_a) = self.a.next() {\n                    b = self.b_orig.clone();\n                    a = next_a;\n                } else {\n                    break;\n                }\n            }\n        }\n        accum\n    }\n}\n\n/// A â€œmeta iterator adaptorâ€. Its closure receives a reference to the iterator\n/// and may pick off as many elements as it likes, to produce the next iterator element.\n///\n/// Iterator element type is *X*, if the return type of `F` is *Option\\<X\\>*.\n///\n/// See [`.batching()`](../trait.Itertools.html#method.batching) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Batching<I, F> {\n    f: F,\n    iter: I,\n}\n\nimpl<I, F> fmt::Debug for Batching<I, F> where I: fmt::Debug {\n    debug_fmt_fields!(Batching, iter);\n}\n\n/// Create a new Batching iterator.\npub fn batching<I, F>(iter: I, f: F) -> Batching<I, F> {\n    Batching { f, iter }\n}\n\nimpl<B, F, I> Iterator for Batching<I, F>\n    where I: Iterator,\n          F: FnMut(&mut I) -> Option<B>\n{\n    type Item = B;\n    #[inline]\n    fn next(&mut self) -> Option<B> {\n        (self.f)(&mut self.iter)\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // No information about closue behavior\n        (0, None)\n    }\n}\n\n/// An iterator adaptor that steps a number elements in the base iterator\n/// for each iteration.\n///\n/// The iterator steps by yielding the next element from the base iterator,\n/// then skipping forward *n-1* elements.\n///\n/// See [`.step()`](../trait.Itertools.html#method.step) for more information.\n#[deprecated(note=\"Use std .step_by() instead\", since=\"0.8\")]\n#[allow(deprecated)]\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Step<I> {\n    iter: Fuse<I>,\n    skip: usize,\n}\n\n/// Create a `Step` iterator.\n///\n/// **Panics** if the step is 0.\n#[allow(deprecated)]\npub fn step<I>(iter: I, step: usize) -> Step<I>\n    where I: Iterator\n{\n    assert!(step != 0);\n    Step {\n        iter: iter.fuse(),\n        skip: step - 1,\n    }\n}\n\n#[allow(deprecated)]\nimpl<I> Iterator for Step<I>\n    where I: Iterator\n{\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<I::Item> {\n        let elt = self.iter.next();\n        if self.skip > 0 {\n            self.iter.nth(self.skip - 1);\n        }\n        elt\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, high) = self.iter.size_hint();\n        let div = |x: usize| {\n            if x == 0 {\n                0\n            } else {\n                1 + (x - 1) / (self.skip + 1)\n            }\n        };\n        (div(low), high.map(div))\n    }\n}\n\n// known size\n#[allow(deprecated)]\nimpl<I> ExactSizeIterator for Step<I>\n    where I: ExactSizeIterator\n{}\n\npub trait MergePredicate<T> {\n    fn merge_pred(&mut self, a: &T, b: &T) -> bool;\n}\n\n#[derive(Clone)]\npub struct MergeLte;\n\nimpl<T: PartialOrd> MergePredicate<T> for MergeLte {\n    fn merge_pred(&mut self, a: &T, b: &T) -> bool {\n        a <= b\n    }\n}\n\n/// An iterator adaptor that merges the two base iterators in ascending order.\n/// If both base iterators are sorted (ascending), the result is sorted.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.merge()`](../trait.Itertools.html#method.merge_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub type Merge<I, J> = MergeBy<I, J, MergeLte>;\n\n/// Create an iterator that merges elements in `i` and `j`.\n///\n/// `IntoIterator` enabled version of `i.merge(j)`.\n///\n/// ```\n/// use itertools::merge;\n///\n/// for elt in merge(&[1, 2, 3], &[2, 3, 4]) {\n///     /* loop body */\n/// }\n/// ```\npub fn merge<I, J>(i: I, j: J) -> Merge<<I as IntoIterator>::IntoIter, <J as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>,\n          I::Item: PartialOrd\n{\n    merge_by_new(i, j, MergeLte)\n}\n\n/// An iterator adaptor that merges the two base iterators in ascending order.\n/// If both base iterators are sorted (ascending), the result is sorted.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.merge_by()`](../trait.Itertools.html#method.merge_by) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MergeBy<I, J, F>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>\n{\n    a: Peekable<I>,\n    b: Peekable<J>,\n    fused: Option<bool>,\n    cmp: F,\n}\n\nimpl<I, J, F> fmt::Debug for MergeBy<I, J, F>\n    where I: Iterator + fmt::Debug, J: Iterator<Item = I::Item> + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(MergeBy, a, b);\n}\n\nimpl<T, F: FnMut(&T, &T)->bool> MergePredicate<T> for F {\n    fn merge_pred(&mut self, a: &T, b: &T) -> bool {\n        self(a, b)\n    }\n}\n\n/// Create a `MergeBy` iterator.\npub fn merge_by_new<I, J, F>(a: I, b: J, cmp: F) -> MergeBy<I::IntoIter, J::IntoIter, F>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>,\n          F: MergePredicate<I::Item>,\n{\n    MergeBy {\n        a: a.into_iter().peekable(),\n        b: b.into_iter().peekable(),\n        fused: None,\n        cmp,\n    }\n}\n\nimpl<I, J, F> Clone for MergeBy<I, J, F>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>,\n          Peekable<I>: Clone,\n          Peekable<J>: Clone,\n          F: Clone\n{\n    clone_fields!(a, b, fused, cmp);\n}\n\nimpl<I, J, F> Iterator for MergeBy<I, J, F>\n    where I: Iterator,\n          J: Iterator<Item = I::Item>,\n          F: MergePredicate<I::Item>\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<I::Item> {\n        let less_than = match self.fused {\n            Some(lt) => lt,\n            None => match (self.a.peek(), self.b.peek()) {\n                (Some(a), Some(b)) => self.cmp.merge_pred(a, b),\n                (Some(_), None) => {\n                    self.fused = Some(true);\n                    true\n                }\n                (None, Some(_)) => {\n                    self.fused = Some(false);\n                    false\n                }\n                (None, None) => return None,\n            }\n        };\n        if less_than {\n            self.a.next()\n        } else {\n            self.b.next()\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // Not ExactSizeIterator because size may be larger than usize\n        size_hint::add(self.a.size_hint(), self.b.size_hint())\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct CoalesceCore<I>\n    where I: Iterator\n{\n    iter: I,\n    last: Option<I::Item>,\n}\n\nimpl<I> CoalesceCore<I>\n    where I: Iterator\n{\n    fn next_with<F>(&mut self, mut f: F) -> Option<I::Item>\n        where F: FnMut(I::Item, I::Item) -> Result<I::Item, (I::Item, I::Item)>\n    {\n        // this fuses the iterator\n        let mut last = match self.last.take() {\n            None => return None,\n            Some(x) => x,\n        };\n        for next in &mut self.iter {\n            match f(last, next) {\n                Ok(joined) => last = joined,\n                Err((last_, next_)) => {\n                    self.last = Some(next_);\n                    return Some(last_);\n                }\n            }\n        }\n\n        Some(last)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, hi) = size_hint::add_scalar(self.iter.size_hint(),\n                                              self.last.is_some() as usize);\n        ((low > 0) as usize, hi)\n    }\n}\n\n/// An iterator adaptor that may join together adjacent elements.\n///\n/// See [`.coalesce()`](../trait.Itertools.html#method.coalesce) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Coalesce<I, F>\n    where I: Iterator\n{\n    iter: CoalesceCore<I>,\n    f: F,\n}\n\nimpl<I: Clone, F: Clone> Clone for Coalesce<I, F>\n    where I: Iterator,\n          I::Item: Clone\n{\n    clone_fields!(iter, f);\n}\n\nimpl<I, F> fmt::Debug for Coalesce<I, F>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Coalesce, iter);\n}\n\n/// Create a new `Coalesce`.\npub fn coalesce<I, F>(mut iter: I, f: F) -> Coalesce<I, F>\n    where I: Iterator\n{\n    Coalesce {\n        iter: CoalesceCore {\n            last: iter.next(),\n            iter,\n        },\n        f,\n    }\n}\n\nimpl<I, F> Iterator for Coalesce<I, F>\n    where I: Iterator,\n          F: FnMut(I::Item, I::Item) -> Result<I::Item, (I::Item, I::Item)>\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<I::Item> {\n        self.iter.next_with(&mut self.f)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n/// An iterator adaptor that removes repeated duplicates, determining equality using a comparison function.\n///\n/// See [`.dedup_by()`](../trait.Itertools.html#method.dedup_by) or [`.dedup()`](../trait.Itertools.html#method.dedup) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct DedupBy<I, Pred>\n    where I: Iterator\n{\n    iter: CoalesceCore<I>,\n    dedup_pred: Pred,\n}\n\npub trait DedupPredicate<T> { // TODO replace by Fn(&T, &T)->bool once Rust supports it\n    fn dedup_pair(&mut self, a: &T, b: &T) -> bool;\n}\n\n#[derive(Clone)]\npub struct DedupEq;\n\nimpl<T: PartialEq> DedupPredicate<T> for DedupEq {\n    fn dedup_pair(&mut self, a: &T, b: &T) -> bool {\n        a==b\n    }\n}\n\nimpl<T, F: FnMut(&T, &T)->bool> DedupPredicate<T> for F {\n    fn dedup_pair(&mut self, a: &T, b: &T) -> bool {\n        self(a, b)\n    }\n}\n\n/// An iterator adaptor that removes repeated duplicates.\n///\n/// See [`.dedup()`](../trait.Itertools.html#method.dedup) for more information.\npub type Dedup<I>=DedupBy<I, DedupEq>;\n\nimpl<I: Clone, Pred: Clone> Clone for DedupBy<I, Pred>\n    where I: Iterator,\n          I::Item: Clone,\n{\n    clone_fields!(iter, dedup_pred);\n}\n\n/// Create a new `DedupBy`.\npub fn dedup_by<I, Pred>(mut iter: I, dedup_pred: Pred) -> DedupBy<I, Pred>\n    where I: Iterator,\n{\n    DedupBy {\n        iter: CoalesceCore {\n            last: iter.next(),\n            iter,\n        },\n        dedup_pred,\n    }\n}\n\n/// Create a new `Dedup`.\npub fn dedup<I>(iter: I) -> Dedup<I>\n    where I: Iterator\n{\n    dedup_by(iter, DedupEq)\n}\n\nimpl<I, Pred> fmt::Debug for DedupBy<I, Pred>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(Dedup, iter);\n}\n\nimpl<I, Pred> Iterator for DedupBy<I, Pred>\n    where I: Iterator,\n          Pred: DedupPredicate<I::Item>,\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<I::Item> {\n        let ref mut dedup_pred = self.dedup_pred;\n        self.iter.next_with(|x, y| {\n            if dedup_pred.dedup_pair(&x, &y) { Ok(x) } else { Err((x, y)) }\n        })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<Acc, G>(self, mut accum: Acc, mut f: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        if let Some(mut last) = self.iter.last {\n            let mut dedup_pred = self.dedup_pred;\n            accum = self.iter.iter.fold(accum, |acc, elt| {\n                if dedup_pred.dedup_pair(&elt, &last) {\n                    acc\n                } else {\n                    f(acc, replace(&mut last, elt))\n                }\n            });\n            f(accum, last)\n        } else {\n            accum\n        }\n    }\n}\n\n/// An iterator adaptor that borrows from a `Clone`-able iterator\n/// to only pick off elements while the predicate returns `true`.\n///\n/// See [`.take_while_ref()`](../trait.Itertools.html#method.take_while_ref) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct TakeWhileRef<'a, I: 'a, F> {\n    iter: &'a mut I,\n    f: F,\n}\n\nimpl<'a, I, F> fmt::Debug for TakeWhileRef<'a, I, F>\n    where I: Iterator + fmt::Debug,\n{\n    debug_fmt_fields!(TakeWhileRef, iter);\n}\n\n/// Create a new `TakeWhileRef` from a reference to clonable iterator.\npub fn take_while_ref<I, F>(iter: &mut I, f: F) -> TakeWhileRef<I, F>\n    where I: Iterator + Clone\n{\n    TakeWhileRef { iter, f }\n}\n\nimpl<'a, I, F> Iterator for TakeWhileRef<'a, I, F>\n    where I: Iterator + Clone,\n          F: FnMut(&I::Item) -> bool\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<I::Item> {\n        let old = self.iter.clone();\n        match self.iter.next() {\n            None => None,\n            Some(elt) => {\n                if (self.f)(&elt) {\n                    Some(elt)\n                } else {\n                    *self.iter = old;\n                    None\n                }\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, hi) = self.iter.size_hint();\n        (0, hi)\n    }\n}\n\n/// An iterator adaptor that filters `Option<A>` iterator elements\n/// and produces `A`. Stops on the first `None` encountered.\n///\n/// See [`.while_some()`](../trait.Itertools.html#method.while_some) for more information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct WhileSome<I> {\n    iter: I,\n}\n\n/// Create a new `WhileSome<I>`.\npub fn while_some<I>(iter: I) -> WhileSome<I> {\n    WhileSome { iter }\n}\n\nimpl<I, A> Iterator for WhileSome<I>\n    where I: Iterator<Item = Option<A>>\n{\n    type Item = A;\n\n    fn next(&mut self) -> Option<A> {\n        match self.iter.next() {\n            None | Some(None) => None,\n            Some(elt) => elt,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let sh = self.iter.size_hint();\n        (0, sh.1)\n    }\n}\n\n/// An iterator to iterate through all combinations in a `Clone`-able iterator that produces tuples\n/// of a specific size.\n///\n/// See [`.tuple_combinations()`](../trait.Itertools.html#method.tuple_combinations) for more\n/// information.\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct TupleCombinations<I, T>\n    where I: Iterator,\n          T: HasCombination<I>\n{\n    iter: T::Combination,\n    _mi: PhantomData<I>,\n    _mt: PhantomData<T>\n}\n\npub trait HasCombination<I>: Sized {\n    type Combination: From<I> + Iterator<Item = Self>;\n}\n\n/// Create a new `TupleCombinations` from a clonable iterator.\npub fn tuple_combinations<T, I>(iter: I) -> TupleCombinations<I, T>\n    where I: Iterator + Clone,\n          I::Item: Clone,\n          T: HasCombination<I>,\n{\n    TupleCombinations {\n        iter: T::Combination::from(iter),\n        _mi: PhantomData,\n        _mt: PhantomData,\n    }\n}\n\nimpl<I, T> Iterator for TupleCombinations<I, T>\n    where I: Iterator,\n          T: HasCombination<I>,\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next()\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct Tuple1Combination<I> {\n    iter: I,\n}\n\nimpl<I> From<I> for Tuple1Combination<I> {\n    fn from(iter: I) -> Self {\n        Tuple1Combination { iter }\n    }\n}\n\nimpl<I: Iterator> Iterator for Tuple1Combination<I> {\n    type Item = (I::Item,);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|x| (x,))\n    }\n}\n\nimpl<I: Iterator> HasCombination<I> for (I::Item,) {\n    type Combination = Tuple1Combination<I>;\n}\n\nmacro_rules! impl_tuple_combination {\n    ($C:ident $P:ident ; $A:ident, $($I:ident),* ; $($X:ident)*) => (\n        #[derive(Clone, Debug)]\n        pub struct $C<I: Iterator> {\n            item: Option<I::Item>,\n            iter: I,\n            c: $P<I>,\n        }\n\n        impl<I: Iterator + Clone> From<I> for $C<I> {\n            fn from(mut iter: I) -> Self {\n                $C {\n                    item: iter.next(),\n                    iter: iter.clone(),\n                    c: $P::from(iter),\n                }\n            }\n        }\n\n        impl<I: Iterator + Clone> From<I> for $C<Fuse<I>> {\n            fn from(iter: I) -> Self {\n                let mut iter = iter.fuse();\n                $C {\n                    item: iter.next(),\n                    iter: iter.clone(),\n                    c: $P::from(iter),\n                }\n            }\n        }\n\n        impl<I, $A> Iterator for $C<I>\n            where I: Iterator<Item = $A> + Clone,\n                  I::Item: Clone\n        {\n            type Item = ($($I),*);\n\n            fn next(&mut self) -> Option<Self::Item> {\n                if let Some(($($X),*,)) = self.c.next() {\n                    let z = self.item.clone().unwrap();\n                    Some((z, $($X),*))\n                } else {\n                    self.item = self.iter.next();\n                    self.item.clone().and_then(|z| {\n                        self.c = $P::from(self.iter.clone());\n                        self.c.next().map(|($($X),*,)| (z, $($X),*))\n                    })\n                }\n            }\n        }\n\n        impl<I, $A> HasCombination<I> for ($($I),*)\n            where I: Iterator<Item = $A> + Clone,\n                  I::Item: Clone\n        {\n            type Combination = $C<Fuse<I>>;\n        }\n    )\n}\n\nimpl_tuple_combination!(Tuple2Combination Tuple1Combination ; A, A, A ; a);\nimpl_tuple_combination!(Tuple3Combination Tuple2Combination ; A, A, A, A ; a b);\nimpl_tuple_combination!(Tuple4Combination Tuple3Combination ; A, A, A, A, A; a b c);\n\n/// An iterator adapter to apply `Into` conversion to each element.\n///\n/// See [`.map_into()`](../trait.Itertools.html#method.map_into) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MapInto<I, R> {\n    iter: I,\n    _res: PhantomData<fn() -> R>,\n}\n\n/// Create a new [`MapInto`](struct.MapInto.html) iterator.\npub fn map_into<I, R>(iter: I) -> MapInto<I, R> {\n    MapInto {\n        iter,\n        _res: PhantomData,\n    }\n}\n\nimpl<I, R> Iterator for MapInto<I, R>\n    where I: Iterator,\n          I::Item: Into<R>,\n{\n    type Item = R;\n\n    fn next(&mut self) -> Option<R> {\n        self.iter\n            .next()\n            .map(|i| i.into())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<Acc, Fold>(self, init: Acc, mut fold_f: Fold) -> Acc\n        where Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n        self.iter.fold(init, move |acc, v| fold_f(acc, v.into()))\n    }\n}\n\nimpl<I, R> DoubleEndedIterator for MapInto<I, R>\n    where I: DoubleEndedIterator,\n          I::Item: Into<R>,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.iter\n            .next_back()\n            .map(|i| i.into())\n    }\n}\n\nimpl<I, R> ExactSizeIterator for MapInto<I, R>\nwhere\n    I: ExactSizeIterator,\n    I::Item: Into<R>,\n{}\n\n/// An iterator adapter to apply a transformation within a nested `Result`.\n///\n/// See [`.map_results()`](../trait.Itertools.html#method.map_results) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MapResults<I, F> {\n    iter: I,\n    f: F\n}\n\n/// Create a new `MapResults` iterator.\npub fn map_results<I, F, T, U, E>(iter: I, f: F) -> MapResults<I, F>\n    where I: Iterator<Item = Result<T, E>>,\n          F: FnMut(T) -> U,\n{\n    MapResults {\n        iter,\n        f,\n    }\n}\n\nimpl<I, F, T, U, E> Iterator for MapResults<I, F>\n    where I: Iterator<Item = Result<T, E>>,\n          F: FnMut(T) -> U,\n{\n    type Item = Result<U, E>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|v| v.map(&mut self.f))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<Acc, Fold>(self, init: Acc, mut fold_f: Fold) -> Acc\n        where Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n        let mut f = self.f;\n        self.iter.fold(init, move |acc, v| fold_f(acc, v.map(&mut f)))\n    }\n\n    fn collect<C>(self) -> C\n        where C: FromIterator<Self::Item>\n    {\n        let mut f = self.f;\n        self.iter.map(move |v| v.map(&mut f)).collect()\n    }\n}\n\n/// An iterator adapter to get the positions of each element that matches a predicate.\n///\n/// See [`.positions()`](../trait.Itertools.html#method.positions) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Positions<I, F> {\n    iter: I,\n    f: F,\n    count: usize,\n}\n\n/// Create a new `Positions` iterator.\npub fn positions<I, F>(iter: I, f: F) -> Positions<I, F>\n    where I: Iterator,\n          F: FnMut(I::Item) -> bool,\n{\n    Positions {\n        iter,\n        f,\n        count: 0\n    }\n}\n\nimpl<I, F> Iterator for Positions<I, F>\n    where I: Iterator,\n          F: FnMut(I::Item) -> bool,\n{\n    type Item = usize;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.next() {\n            let i = self.count;\n            self.count = i + 1;\n            if (self.f)(v) {\n                return Some(i);\n            }\n        }\n        None\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, self.iter.size_hint().1)\n    }\n}\n\nimpl<I, F> DoubleEndedIterator for Positions<I, F>\n    where I: DoubleEndedIterator + ExactSizeIterator,\n          F: FnMut(I::Item) -> bool,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        while let Some(v) = self.iter.next_back() {\n            if (self.f)(v) {\n                return Some(self.count + self.iter.len())\n            }\n        }\n        None\n    }\n}\n\n/// An iterator adapter to apply a mutating function to each element before yielding it.\n///\n/// See [`.update()`](../trait.Itertools.html#method.update) for more information.\n#[derive(Clone)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct Update<I, F> {\n    iter: I,\n    f: F,\n}\n\n/// Create a new `Update` iterator.\npub fn update<I, F>(iter: I, f: F) -> Update<I, F>\nwhere\n    I: Iterator,\n    F: FnMut(&mut I::Item),\n{\n    Update { iter, f }\n}\n\nimpl<I, F> Iterator for Update<I, F>\nwhere\n    I: Iterator,\n    F: FnMut(&mut I::Item),\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if let Some(mut v) = self.iter.next() {\n            (self.f)(&mut v);\n            Some(v)\n        } else {\n            None\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        let mut f = self.f;\n        self.iter.fold(init, move |acc, mut v| { f(&mut v); g(acc, v) })\n    }\n\n    // if possible, re-use inner iterator specializations in collect\n    fn collect<C>(self) -> C\n        where C: FromIterator<Self::Item>\n    {\n        let mut f = self.f;\n        self.iter.map(move |mut v| { f(&mut v); v }).collect()\n    }\n}\n\nimpl<I, F> ExactSizeIterator for Update<I, F>\nwhere\n    I: ExactSizeIterator,\n    F: FnMut(&mut I::Item),\n{}\n\nimpl<I, F> DoubleEndedIterator for Update<I, F>\nwhere\n    I: DoubleEndedIterator,\n    F: FnMut(&mut I::Item),\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if let Some(mut v) = self.iter.next_back() {\n            (self.f)(&mut v);\n            Some(v)\n        } else {\n            None\n        }\n    }\n}\n"],["1107","#![cfg(feature = \"use_std\")]\n\nuse crate::size_hint;\nuse crate::Itertools;\n\n#[derive(Clone)]\n/// An iterator adaptor that iterates over the cartesian product of\n/// multiple iterators of type `I`.\n///\n/// An iterator element type is `Vec<I>`.\n///\n/// See [`.multi_cartesian_product()`](../trait.Itertools.html#method.multi_cartesian_product)\n/// for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct MultiProduct<I>(Vec<MultiProductIter<I>>)\n    where I: Iterator + Clone,\n          I::Item: Clone;\n\n/// Create a new cartesian product iterator over an arbitrary number\n/// of iterators of the same type.\n///\n/// Iterator element is of type `Vec<H::Item::Item>`.\npub fn multi_cartesian_product<H>(iters: H) -> MultiProduct<<H::Item as IntoIterator>::IntoIter>\n    where H: Iterator,\n          H::Item: IntoIterator,\n          <H::Item as IntoIterator>::IntoIter: Clone,\n          <H::Item as IntoIterator>::Item: Clone\n{\n    MultiProduct(iters.map(|i| MultiProductIter::new(i.into_iter())).collect())\n}\n\n#[derive(Clone, Debug)]\n/// Holds the state of a single iterator within a MultiProduct.\nstruct MultiProductIter<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    cur: Option<I::Item>,\n    iter: I,\n    iter_orig: I,\n}\n\n/// Holds the current state during an iteration of a MultiProduct.\n#[derive(Debug)]\nenum MultiProductIterState {\n    StartOfIter,\n    MidIter { on_first_iter: bool },\n}\n\nimpl<I> MultiProduct<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    /// Iterates the rightmost iterator, then recursively iterates iterators\n    /// to the left if necessary.\n    ///\n    /// Returns true if the iteration succeeded, else false.\n    fn iterate_last(\n        multi_iters: &mut [MultiProductIter<I>],\n        mut state: MultiProductIterState\n    ) -> bool {\n        use self::MultiProductIterState::*;\n\n        if let Some((last, rest)) = multi_iters.split_last_mut() {\n            let on_first_iter = match state {\n                StartOfIter => {\n                    let on_first_iter = !last.in_progress();\n                    state = MidIter { on_first_iter };\n                    on_first_iter\n                },\n                MidIter { on_first_iter } => on_first_iter\n            };\n\n            if !on_first_iter {\n                last.iterate();\n            }\n\n            if last.in_progress() {\n                true\n            } else if MultiProduct::iterate_last(rest, state) {\n                last.reset();\n                last.iterate();\n                // If iterator is None twice consecutively, then iterator is\n                // empty; whole product is empty.\n                last.in_progress()\n            } else {\n                false\n            }\n        } else {\n            // Reached end of iterator list. On initialisation, return true.\n            // At end of iteration (final iterator finishes), finish.\n            match state {\n                StartOfIter => false,\n                MidIter { on_first_iter } => on_first_iter\n            }\n        }\n    }\n\n    /// Returns the unwrapped value of the next iteration.\n    fn curr_iterator(&self) -> Vec<I::Item> {\n        self.0.iter().map(|multi_iter| {\n            multi_iter.cur.clone().unwrap()\n        }).collect()\n    }\n\n    /// Returns true if iteration has started and has not yet finished; false\n    /// otherwise.\n    fn in_progress(&self) -> bool {\n        if let Some(last) = self.0.last() {\n            last.in_progress()\n        } else {\n            false\n        }\n    }\n}\n\nimpl<I> MultiProductIter<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    fn new(iter: I) -> Self {\n        MultiProductIter {\n            cur: None,\n            iter: iter.clone(),\n            iter_orig: iter\n        }\n    }\n\n    /// Iterate the managed iterator.\n    fn iterate(&mut self) {\n        self.cur = self.iter.next();\n    }\n\n    /// Reset the managed iterator.\n    fn reset(&mut self) {\n        self.iter = self.iter_orig.clone();\n    }\n\n    /// Returns true if the current iterator has been started and has not yet\n    /// finished; false otherwise.\n    fn in_progress(&self) -> bool {\n        self.cur.is_some()\n    }\n}\n\nimpl<I> Iterator for MultiProduct<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    type Item = Vec<I::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if MultiProduct::iterate_last(\n            &mut self.0,\n            MultiProductIterState::StartOfIter\n        ) {\n            Some(self.curr_iterator())\n        } else {\n            None\n        }\n    }\n\n    fn count(self) -> usize {\n        if self.0.len() == 0 {\n            return 0;\n        }\n\n        if !self.in_progress() {\n            return self.0.into_iter().fold(1, |acc, multi_iter| {\n                acc * multi_iter.iter.count()\n            });\n        }\n\n        self.0.into_iter().fold(\n            0,\n            |acc, MultiProductIter { iter, iter_orig, cur: _ }| {\n                let total_count = iter_orig.count();\n                let cur_count = iter.count();\n                acc * total_count + cur_count\n            }\n        )\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // Not ExactSizeIterator because size may be larger than usize\n        if self.0.len() == 0 {\n            return (0, Some(0));\n        }\n\n        if !self.in_progress() {\n            return self.0.iter().fold((1, Some(1)), |acc, multi_iter| {\n                size_hint::mul(acc, multi_iter.iter.size_hint())\n            });\n        }\n\n        self.0.iter().fold(\n            (0, Some(0)),\n            |acc, &MultiProductIter { ref iter, ref iter_orig, cur: _ }| {\n                let cur_size = iter.size_hint();\n                let total_size = iter_orig.size_hint();\n                size_hint::add(size_hint::mul(acc, total_size), cur_size)\n            }\n        )\n    }\n\n    fn last(self) -> Option<Self::Item> {\n        let iter_count = self.0.len();\n\n        let lasts: Self::Item = self.0.into_iter()\n            .map(|multi_iter| multi_iter.iter.last())\n            .while_some()\n            .collect();\n\n        if lasts.len() == iter_count {\n            Some(lasts)\n        } else {\n            None\n        }\n    }\n}\n"],["1108","use crate::size_hint;\nuse crate::Itertools;\n\nuse std::mem::replace;\nuse std::fmt;\n\n/// Head element and Tail iterator pair\n///\n/// `PartialEq`, `Eq`, `PartialOrd` and `Ord` are implemented by comparing sequences based on\n/// first items (which are guaranteed to exist).\n///\n/// The meanings of `PartialOrd` and `Ord` are reversed so as to turn the heap used in\n/// `KMerge` into a min-heap.\n#[derive(Debug)]\nstruct HeadTail<I>\n    where I: Iterator\n{\n    head: I::Item,\n    tail: I,\n}\n\nimpl<I> HeadTail<I>\n    where I: Iterator\n{\n    /// Constructs a `HeadTail` from an `Iterator`. Returns `None` if the `Iterator` is empty.\n    fn new(mut it: I) -> Option<HeadTail<I>> {\n        let head = it.next();\n        head.map(|h| {\n            HeadTail {\n                head: h,\n                tail: it,\n            }\n        })\n    }\n\n    /// Get the next element and update `head`, returning the old head in `Some`.\n    ///\n    /// Returns `None` when the tail is exhausted (only `head` then remains).\n    fn next(&mut self) -> Option<I::Item> {\n        if let Some(next) = self.tail.next() {\n            Some(replace(&mut self.head, next))\n        } else {\n            None\n        }\n    }\n\n    /// Hints at the size of the sequence, same as the `Iterator` method.\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.tail.size_hint(), 1)\n    }\n}\n\nimpl<I> Clone for HeadTail<I>\n    where I: Iterator + Clone,\n          I::Item: Clone\n{\n    clone_fields!(head, tail);\n}\n\n/// Make `data` a heap (min-heap w.r.t the sorting).\nfn heapify<T, S>(data: &mut [T], mut less_than: S)\n    where S: FnMut(&T, &T) -> bool\n{\n    for i in (0..data.len() / 2).rev() {\n        sift_down(data, i, &mut less_than);\n    }\n}\n\n/// Sift down element at `index` (`heap` is a min-heap wrt the ordering)\nfn sift_down<T, S>(heap: &mut [T], index: usize, mut less_than: S)\n    where S: FnMut(&T, &T) -> bool\n{\n    debug_assert!(index <= heap.len());\n    let mut pos = index;\n    let mut child = 2 * pos + 1;\n    // the `pos` conditional is to avoid a bounds check\n    while pos < heap.len() && child < heap.len() {\n        let right = child + 1;\n\n        // pick the smaller of the two children\n        if right < heap.len() && less_than(&heap[right], &heap[child]) {\n            child = right;\n        }\n\n        // sift down is done if we are already in order\n        if !less_than(&heap[child], &heap[pos]) {\n            return;\n        }\n        heap.swap(pos, child);\n        pos = child;\n        child = 2 * pos + 1;\n    }\n}\n\n/// An iterator adaptor that merges an abitrary number of base iterators in ascending order.\n/// If all base iterators are sorted (ascending), the result is sorted.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.kmerge()`](../trait.Itertools.html#method.kmerge) for more information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub type KMerge<I> = KMergeBy<I, KMergeByLt>;\n\npub trait KMergePredicate<T> {\n    fn kmerge_pred(&mut self, a: &T, b: &T) -> bool;\n}\n\n#[derive(Clone)]\npub struct KMergeByLt;\n\nimpl<T: PartialOrd> KMergePredicate<T> for KMergeByLt {\n    fn kmerge_pred(&mut self, a: &T, b: &T) -> bool {\n        a < b\n    }\n}\n\nimpl<T, F: FnMut(&T, &T)->bool> KMergePredicate<T> for F {\n    fn kmerge_pred(&mut self, a: &T, b: &T) -> bool {\n        self(a, b)\n    }\n}\n\n/// Create an iterator that merges elements of the contained iterators using\n/// the ordering function.\n///\n/// Equivalent to `iterable.into_iter().kmerge()`.\n///\n/// ```\n/// use itertools::kmerge;\n///\n/// for elt in kmerge(vec![vec![0, 2, 4], vec![1, 3, 5], vec![6, 7]]) {\n///     /* loop body */\n/// }\n/// ```\npub fn kmerge<I>(iterable: I) -> KMerge<<I::Item as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          I::Item: IntoIterator,\n          <<I as IntoIterator>::Item as IntoIterator>::Item: PartialOrd\n{\n    kmerge_by(iterable, KMergeByLt)\n}\n\n/// An iterator adaptor that merges an abitrary number of base iterators\n/// according to an ordering function.\n///\n/// Iterator element type is `I::Item`.\n///\n/// See [`.kmerge_by()`](../trait.Itertools.html#method.kmerge_by) for more\n/// information.\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\npub struct KMergeBy<I, F>\n    where I: Iterator,\n{\n    heap: Vec<HeadTail<I>>,\n    less_than: F,\n}\n\nimpl<I, F> fmt::Debug for KMergeBy<I, F>\n    where I: Iterator + fmt::Debug,\n          I::Item: fmt::Debug,\n{\n    debug_fmt_fields!(KMergeBy, heap);\n}\n\n/// Create an iterator that merges elements of the contained iterators.\n///\n/// Equivalent to `iterable.into_iter().kmerge_by(less_than)`.\npub fn kmerge_by<I, F>(iterable: I, mut less_than: F)\n    -> KMergeBy<<I::Item as IntoIterator>::IntoIter, F>\n    where I: IntoIterator,\n          I::Item: IntoIterator,\n          F: KMergePredicate<<<I as IntoIterator>::Item as IntoIterator>::Item>,\n{\n    let iter = iterable.into_iter();\n    let (lower, _) = iter.size_hint();\n    let mut heap: Vec<_> = Vec::with_capacity(lower);\n    heap.extend(iter.filter_map(|it| HeadTail::new(it.into_iter())));\n    heapify(&mut heap, |a, b| less_than.kmerge_pred(&a.head, &b.head));\n    KMergeBy { heap, less_than }\n}\n\nimpl<I, F> Clone for KMergeBy<I, F>\n    where I: Iterator + Clone,\n          I::Item: Clone,\n          F: Clone,\n{\n    clone_fields!(heap, less_than);\n}\n\nimpl<I, F> Iterator for KMergeBy<I, F>\n    where I: Iterator,\n          F: KMergePredicate<I::Item>\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.heap.is_empty() {\n            return None;\n        }\n        let result = if let Some(next) = self.heap[0].next() {\n            next\n        } else {\n            self.heap.swap_remove(0).head\n        };\n        let less_than = &mut self.less_than;\n        sift_down(&mut self.heap, 0, |a, b| less_than.kmerge_pred(&a.head, &b.head));\n        Some(result)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.heap.iter()\n                 .map(|i| i.size_hint())\n                 .fold1(size_hint::add)\n                 .unwrap_or((0, Some(0)))\n    }\n}\n"],["1109","use crate::size_hint;\n\n/// An iterator adaptor that allows putting multiple\n/// items in front of the iterator.\n///\n/// Iterator element type is `I::Item`.\n#[derive(Debug, Clone)]\npub struct PutBackN<I: Iterator> {\n    top: Vec<I::Item>,\n    iter: I,\n}\n\n/// Create an iterator where you can put back multiple values to the front\n/// of the iteration.\n///\n/// Iterator element type is `I::Item`.\npub fn put_back_n<I>(iterable: I) -> PutBackN<I::IntoIter>\n    where I: IntoIterator\n{\n    PutBackN {\n        top: Vec::new(),\n        iter: iterable.into_iter(),\n    }\n}\n\nimpl<I: Iterator> PutBackN<I> {\n    /// Puts x in front of the iterator.\n    /// The values are yielded in order of the most recently put back\n    /// values first.\n    ///\n    /// ```rust\n    /// use itertools::put_back_n;\n    ///\n    /// let mut it = put_back_n(1..5);\n    /// it.next();\n    /// it.put_back(1);\n    /// it.put_back(0);\n    ///\n    /// assert!(itertools::equal(it, 0..5));\n    /// ```\n    #[inline]\n    pub fn put_back(&mut self, x: I::Item) {\n        self.top.push(x);\n    }\n}\n\nimpl<I: Iterator> Iterator for PutBackN<I> {\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<I::Item> {\n        if self.top.is_empty() {\n            self.iter.next()\n        } else {\n            self.top.pop()\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        size_hint::add_scalar(self.iter.size_hint(), self.top.len())\n    }\n}\n\n"],["1110","//! Free functions that create iterator adaptors or call iterator methods.\n//!\n//! The benefit of free functions is that they accept any `IntoIterator` as\n//! argument, so the resulting code may be easier to read.\n\n#[cfg(feature = \"use_std\")]\nuse std::fmt::Display;\nuse std::iter::{self, Zip};\n#[cfg(feature = \"use_std\")]\ntype VecIntoIter<T> = ::std::vec::IntoIter<T>;\n\n#[cfg(feature = \"use_std\")]\nuse crate::Itertools;\n\npub use crate::adaptors::{\n    interleave,\n    merge,\n    put_back,\n};\n#[cfg(feature = \"use_std\")]\npub use crate::put_back_n_impl::put_back_n;\n#[cfg(feature = \"use_std\")]\npub use crate::multipeek_impl::multipeek;\n#[cfg(feature = \"use_std\")]\npub use crate::kmerge_impl::kmerge;\npub use crate::zip_eq_impl::zip_eq;\npub use crate::merge_join::merge_join_by;\n#[cfg(feature = \"use_std\")]\npub use crate::rciter_impl::rciter;\n\n/// Iterate `iterable` with a running index.\n///\n/// `IntoIterator` enabled version of `.enumerate()`.\n///\n/// ```\n/// use itertools::enumerate;\n///\n/// for (i, elt) in enumerate(&[1, 2, 3]) {\n///     /* loop body */\n/// }\n/// ```\npub fn enumerate<I>(iterable: I) -> iter::Enumerate<I::IntoIter>\n    where I: IntoIterator\n{\n    iterable.into_iter().enumerate()\n}\n\n/// Iterate `iterable` in reverse.\n///\n/// `IntoIterator` enabled version of `.rev()`.\n///\n/// ```\n/// use itertools::rev;\n///\n/// for elt in rev(&[1, 2, 3]) {\n///     /* loop body */\n/// }\n/// ```\npub fn rev<I>(iterable: I) -> iter::Rev<I::IntoIter>\n    where I: IntoIterator,\n          I::IntoIter: DoubleEndedIterator\n{\n    iterable.into_iter().rev()\n}\n\n/// Iterate `i` and `j` in lock step.\n///\n/// `IntoIterator` enabled version of `i.zip(j)`.\n///\n/// ```\n/// use itertools::zip;\n///\n/// let data = [1, 2, 3, 4, 5];\n/// for (a, b) in zip(&data, &data[1..]) {\n///     /* loop body */\n/// }\n/// ```\npub fn zip<I, J>(i: I, j: J) -> Zip<I::IntoIter, J::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator\n{\n    i.into_iter().zip(j)\n}\n\n/// Create an iterator that first iterates `i` and then `j`.\n///\n/// `IntoIterator` enabled version of `i.chain(j)`.\n///\n/// ```\n/// use itertools::chain;\n///\n/// for elt in chain(&[1, 2, 3], &[4]) {\n///     /* loop body */\n/// }\n/// ```\npub fn chain<I, J>(i: I, j: J) -> iter::Chain<<I as IntoIterator>::IntoIter, <J as IntoIterator>::IntoIter>\n    where I: IntoIterator,\n          J: IntoIterator<Item = I::Item>\n{\n    i.into_iter().chain(j)\n}\n\n/// Create an iterator that clones each element from &T to T\n///\n/// `IntoIterator` enabled version of `i.cloned()`.\n///\n/// ```\n/// use itertools::cloned;\n///\n/// assert_eq!(cloned(b\"abc\").next(), Some(b'a'));\n/// ```\npub fn cloned<'a, I, T: 'a>(iterable: I) -> iter::Cloned<I::IntoIter>\n    where I: IntoIterator<Item=&'a T>,\n          T: Clone,\n{\n    iterable.into_iter().cloned()\n}\n\n/// Perform a fold operation over the iterable.\n///\n/// `IntoIterator` enabled version of `i.fold(init, f)`\n///\n/// ```\n/// use itertools::fold;\n///\n/// assert_eq!(fold(&[1., 2., 3.], 0., |a, &b| f32::max(a, b)), 3.);\n/// ```\npub fn fold<I, B, F>(iterable: I, init: B, f: F) -> B\n    where I: IntoIterator,\n          F: FnMut(B, I::Item) -> B\n{\n    iterable.into_iter().fold(init, f)\n}\n\n/// Test whether the predicate holds for all elements in the iterable.\n///\n/// `IntoIterator` enabled version of `i.all(f)`\n///\n/// ```\n/// use itertools::all;\n///\n/// assert!(all(&[1, 2, 3], |elt| *elt > 0));\n/// ```\npub fn all<I, F>(iterable: I, f: F) -> bool\n    where I: IntoIterator,\n          F: FnMut(I::Item) -> bool\n{\n    iterable.into_iter().all(f)\n}\n\n/// Test whether the predicate holds for any elements in the iterable.\n///\n/// `IntoIterator` enabled version of `i.any(f)`\n///\n/// ```\n/// use itertools::any;\n///\n/// assert!(any(&[0, -1, 2], |elt| *elt > 0));\n/// ```\npub fn any<I, F>(iterable: I, f: F) -> bool\n    where I: IntoIterator,\n          F: FnMut(I::Item) -> bool\n{\n    iterable.into_iter().any(f)\n}\n\n/// Return the maximum value of the iterable.\n///\n/// `IntoIterator` enabled version of `i.max()`.\n///\n/// ```\n/// use itertools::max;\n///\n/// assert_eq!(max(0..10), Some(9));\n/// ```\npub fn max<I>(iterable: I) -> Option<I::Item>\n    where I: IntoIterator,\n          I::Item: Ord\n{\n    iterable.into_iter().max()\n}\n\n/// Return the minimum value of the iterable.\n///\n/// `IntoIterator` enabled version of `i.min()`.\n///\n/// ```\n/// use itertools::min;\n///\n/// assert_eq!(min(0..10), Some(0));\n/// ```\npub fn min<I>(iterable: I) -> Option<I::Item>\n    where I: IntoIterator,\n          I::Item: Ord\n{\n    iterable.into_iter().min()\n}\n\n\n/// Combine all iterator elements into one String, seperated by `sep`.\n///\n/// `IntoIterator` enabled version of `iterable.join(sep)`.\n///\n/// ```\n/// use itertools::join;\n///\n/// assert_eq!(join(&[1, 2, 3], \", \"), \"1, 2, 3\");\n/// ```\n#[cfg(feature = \"use_std\")]\npub fn join<I>(iterable: I, sep: &str) -> String\n    where I: IntoIterator,\n          I::Item: Display\n{\n    iterable.into_iter().join(sep)\n}\n\n/// Sort all iterator elements into a new iterator in ascending order.\n///\n/// `IntoIterator` enabled version of [`iterable.sorted()`][1].\n///\n/// [1]: trait.Itertools.html#method.sorted\n///\n/// ```\n/// use itertools::sorted;\n/// use itertools::assert_equal;\n///\n/// assert_equal(sorted(\"rust\".chars()), \"rstu\".chars());\n/// ```\n#[cfg(feature = \"use_std\")]\npub fn sorted<I>(iterable: I) -> VecIntoIter<I::Item>\n    where I: IntoIterator,\n          I::Item: Ord\n{\n    iterable.into_iter().sorted()\n}\n\n"],["1111","// The code in this file is based on Rust's compiler-builtins crate. The Rust\n// compiler automatically links programs against this crate for target-specific\n// runtime support. We have copied the implementation of `__udivmodti4()` which\n// is an intrinsic implementing division with remainder for architectures\n// without 128-bit integers. This implementation works around some poor codegen\n// by LLVM (https://github.com/rust-lang/rust/issues/44545) and allows for\n// inlining which does not happen with the intrinsic.\n//\n// The compiler-builtins crate carries the following license, which is available\n// in full at:\n// https://github.com/rust-lang-nursery/compiler-builtins/blob/master/LICENSE.TXT\n//\n// ---\n//\n// Copyright 2009-2016 compiler-builtins Developers\n//\n// The compiler-builtins crate is dual licensed under both the University of\n// Illinois \"BSD-Like\" license and the MIT license. As a user of this code you\n// may choose to use it under either license. As a contributor, you agree to\n// allow your code to be used under both.\n\n#[inline]\npub fn udivmod_1e19(n: u128) -> (u128, u64) {\n    let d = 10_000_000_000_000_000_000_u64; // 10^19\n\n    let high = (n >> 64) as u64;\n    if high == 0 {\n        let low = n as u64;\n        return ((low / d) as u128, low % d);\n    }\n\n    let sr = 65 - high.leading_zeros();\n\n    // 2 <= sr <= 65\n    let mut q: u128 = n << (128 - sr);\n    let mut r: u128 = n >> sr;\n    let mut carry: u64 = 0;\n\n    // Don't use a range because they may generate references to memcpy in unoptimized code\n    //\n    // Loop invariants:  r < d; carry is 0 or 1\n    let mut i = 0;\n    while i < sr {\n        i += 1;\n\n        // r:q = ((r:q) << 1) | carry\n        r = (r << 1) | (q >> 127);\n        q = (q << 1) | carry as u128;\n\n        // carry = 0\n        // if r >= d {\n        //     r -= d;\n        //     carry = 1;\n        // }\n        let s = (d as u128).wrapping_sub(r).wrapping_sub(1) as i128 >> 127;\n        carry = (s & 1) as u64;\n        r -= (d as u128) & s as u128;\n    }\n\n    ((q << 1) | carry as u128, r as u64)\n}\n"],["1112","// Copyright 2016 lazy-static.rs Developers\n//\n// Licensed under the Apache License, Version 2.0, <LICENSE-APACHE or\n// http://apache.org/licenses/LICENSE-2.0> or the MIT license <LICENSE-MIT or\n// http://opensource.org/licenses/MIT>, at your option. This file may not be\n// copied, modified, or distributed except according to those terms.\n\nextern crate spin;\n\nuse self::spin::Once;\n\npub struct Lazy<T: Sync>(Once<T>);\n\nimpl<T: Sync> Lazy<T> {\n    pub const INIT: Self = Lazy(Once::INIT);\n\n    #[inline(always)]\n    pub fn get<F>(&'static self, builder: F) -> &T\n        where F: FnOnce() -> T\n    {\n        self.0.call_once(builder)\n    }\n}\n\n#[macro_export]\n#[doc(hidden)]\nmacro_rules! __lazy_static_create {\n    ($NAME:ident, $T:ty) => {\n        static $NAME: $crate::lazy::Lazy<$T> = $crate::lazy::Lazy::INIT;\n    }\n}\n"],["1113","// Copyright 2016 lazy-static.rs Developers\n//\n// Licensed under the Apache License, Version 2.0, <LICENSE-APACHE or\n// http://apache.org/licenses/LICENSE-2.0> or the MIT license <LICENSE-MIT or\n// http://opensource.org/licenses/MIT>, at your option. This file may not be\n// copied, modified, or distributed except according to those terms.\n\nextern crate core;\nextern crate std;\n\nuse self::std::prelude::v1::*;\nuse self::std::cell::Cell;\nuse self::std::hint::unreachable_unchecked;\nuse self::std::sync::Once;\n#[allow(deprecated)]\npub use self::std::sync::ONCE_INIT;\n\n// FIXME: Replace Option<T> with MaybeUninit<T> (stable since 1.36.0)\npub struct Lazy<T: Sync>(Cell<Option<T>>, Once);\n\nimpl<T: Sync> Lazy<T> {\n    #[allow(deprecated)]\n    pub const INIT: Self = Lazy(Cell::new(None), ONCE_INIT);\n\n    #[inline(always)]\n    pub fn get<F>(&'static self, f: F) -> &T\n    where\n        F: FnOnce() -> T,\n    {\n        self.1.call_once(|| {\n            self.0.set(Some(f()));\n        });\n\n        // `self.0` is guaranteed to be `Some` by this point\n        // The `Once` will catch and propagate panics\n        unsafe {\n            match *self.0.as_ptr() {\n                Some(ref x) => x,\n                None => {\n                    debug_assert!(false, \"attempted to derefence an uninitialized lazy static. This is a bug\");\n\n                    unreachable_unchecked()\n                },\n            }\n        }\n    }\n}\n\nunsafe impl<T: Sync> Sync for Lazy<T> {}\n\n#[macro_export]\n#[doc(hidden)]\nmacro_rules! __lazy_static_create {\n    ($NAME:ident, $T:ty) => {\n        static $NAME: $crate::lazy::Lazy<$T> = $crate::lazy::Lazy::INIT;\n    };\n}\n"],["1114","pub type c_char = u8;\npub type wchar_t = u32;\npub type c_long = i32;\npub type c_ulong = u32;\n"],["1115","pub type c_char = u8;\npub type wchar_t = u32;\npub type c_long = i64;\npub type c_ulong = u64;\n"],["1116","pub type c_char = u8;\npub type wchar_t = u32;\npub type c_long = i64;\npub type c_ulong = u64;\n"],["1117","//! Interface to VxWorks C library\n\nuse core::mem::size_of;\nuse core::ptr::null_mut;\n\n#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\npub enum DIR {}\nimpl ::Copy for DIR {}\nimpl ::Clone for DIR {\n    fn clone(&self) -> DIR {\n        *self\n    }\n}\n\npub type c_schar = i8;\npub type c_uchar = u8;\npub type c_short = i16;\npub type c_ushort = u16;\npub type c_int = i32;\npub type c_uint = u32;\npub type c_float = f32;\npub type c_double = f64;\npub type c_longlong = i64;\npub type c_ulonglong = u64;\npub type intmax_t = i64;\npub type uintmax_t = u64;\n\npub type uintptr_t = usize;\npub type intptr_t = isize;\npub type ptrdiff_t = isize;\npub type size_t = ::uintptr_t;\npub type ssize_t = ::intptr_t;\n\npub type pid_t = ::c_int;\npub type in_addr_t = u32;\npub type sighandler_t = ::size_t;\npub type cpuset_t = u32;\n\npub type blkcnt_t = ::c_long;\npub type blksize_t = ::c_long;\npub type ino_t = ::c_ulong;\n\npub type rlim_t = ::c_ulong;\npub type suseconds_t = ::c_long;\npub type time_t = ::c_long;\n\npub type errno_t = ::c_int;\n\npub type useconds_t = ::c_ulong;\n\npub type socklen_t = ::c_uint;\n\npub type pthread_t = ::c_ulong;\n\npub type clockid_t = ::c_int;\n\n//defined for the structs\npub type dev_t = ::c_ulong;\npub type mode_t = ::c_int;\npub type nlink_t = ::c_ulong;\npub type uid_t = ::c_ushort;\npub type gid_t = ::c_ushort;\npub type sigset_t = ::c_ulonglong;\npub type key_t = ::c_long;\n\npub type nfds_t = ::c_uint;\npub type stat64 = ::stat;\n\npub type pthread_key_t = ::c_ulong;\n\n// From b_off_t.h\npub type off_t = ::c_longlong;\npub type off64_t = off_t;\n\n// From b_BOOL.h\npub type BOOL = ::c_int;\n\n// From vxWind.h ..\npub type _Vx_OBJ_HANDLE = ::c_int;\npub type _Vx_TASK_ID = ::_Vx_OBJ_HANDLE;\npub type _Vx_MSG_Q_ID = ::_Vx_OBJ_HANDLE;\npub type _Vx_SEM_ID_KERNEL = ::_Vx_OBJ_HANDLE;\npub type _Vx_RTP_ID = ::_Vx_OBJ_HANDLE;\npub type _Vx_SD_ID = ::_Vx_OBJ_HANDLE;\npub type _Vx_CONDVAR_ID = ::_Vx_OBJ_HANDLE;\npub type _Vx_SEM_ID = *mut ::_Vx_semaphore;\npub type OBJ_HANDLE = ::_Vx_OBJ_HANDLE;\npub type TASK_ID = ::OBJ_HANDLE;\npub type MSG_Q_ID = ::OBJ_HANDLE;\npub type SEM_ID_KERNEL = ::OBJ_HANDLE;\npub type RTP_ID = ::OBJ_HANDLE;\npub type SD_ID = ::OBJ_HANDLE;\npub type CONDVAR_ID = ::OBJ_HANDLE;\n\n// From vxTypes.h\npub type _Vx_usr_arg_t = isize;\npub type _Vx_exit_code_t = isize;\npub type _Vx_ticks_t = ::c_uint;\npub type _Vx_ticks64_t = ::c_ulonglong;\n\npub type sa_family_t = ::c_uchar;\n\n// mqueue.h\npub type mqd_t = ::c_int;\n\n#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\npub enum _Vx_semaphore {}\nimpl ::Copy for _Vx_semaphore {}\nimpl ::Clone for _Vx_semaphore {\n    fn clone(&self) -> _Vx_semaphore {\n        *self\n    }\n}\n\nimpl siginfo_t {\n    pub unsafe fn si_addr(&self) -> *mut ::c_void {\n        self.si_addr\n    }\n\n    pub unsafe fn si_value(&self) -> ::sigval {\n        self.si_value\n    }\n\n    pub unsafe fn si_pid(&self) -> ::pid_t {\n        self.si_pid\n    }\n\n    pub unsafe fn si_uid(&self) -> ::uid_t {\n        self.si_uid\n    }\n\n    pub unsafe fn si_status(&self) -> ::c_int {\n        self.si_status\n    }\n}\n\ns! {\n    // b_pthread_condattr_t.h\n    pub struct pthread_condattr_t {\n        pub condAttrStatus: ::c_int,\n        pub condAttrPshared: ::c_int,\n        pub condAttrClockId: ::clockid_t,\n    }\n\n    // b_pthread_cond_t.h\n    pub struct pthread_cond_t{\n        pub condSemId: ::_Vx_SEM_ID,\n        pub condValid: ::c_int,\n        pub condInitted: ::c_int,\n        pub condRefCount: ::c_int,\n        pub condMutex: *mut ::pthread_mutex_t,\n        pub condAttr: ::pthread_condattr_t,\n        pub condSemName: [::c_char; _PTHREAD_SHARED_SEM_NAME_MAX]\n    }\n\n    // b_pthread_rwlockattr_t.h\n    pub struct pthread_rwlockattr_t {\n        pub rwlockAttrStatus: ::c_int,\n        pub rwlockAttrPshared: ::c_int,\n        pub rwlockAttrMaxReaders: ::c_uint,\n        pub rwlockAttrConformOpt: ::c_uint,\n    }\n\n    // b_pthread_rwlock_t.h\n    pub struct pthread_rwlock_t {\n        pub rwlockSemId: :: _Vx_SEM_ID,\n        pub rwlockReadersRefCount: ::c_uint,\n        pub rwlockValid: ::c_int,\n        pub rwlockInitted: ::c_int,\n        pub rwlockAttr: ::pthread_rwlockattr_t,\n        pub rwlockSemName: [::c_char; _PTHREAD_SHARED_SEM_NAME_MAX]\n    }\n\n    // b_struct_timeval.h\n    pub struct timeval {\n        pub tv_sec: ::time_t,\n        pub tv_usec: ::suseconds_t,\n    }\n\n    // socket.h\n    pub struct linger {\n        pub l_onoff: ::c_int,\n        pub l_linger: ::c_int,\n    }\n\n    pub struct sockaddr {\n        pub sa_len    : ::c_uchar,\n        pub sa_family : sa_family_t,\n        pub sa_data   : [::c_char; 14],\n    }\n\n    pub struct iovec {\n        pub iov_base: *mut ::c_void,\n        pub iov_len: ::size_t,\n    }\n\n    pub struct msghdr {\n        pub msg_name: *mut c_void,\n        pub msg_namelen: socklen_t,\n        pub msg_iov: *mut iovec,\n        pub msg_iovlen: ::c_int,\n        pub msg_control: *mut c_void,\n        pub msg_controllen: socklen_t,\n        pub msg_flags: ::c_int,\n    }\n\n    pub struct cmsghdr {\n        pub cmsg_len: socklen_t,\n        pub cmsg_level: ::c_int,\n        pub cmsg_type: ::c_int,\n    }\n\n    // poll.h\n    pub struct pollfd {\n        pub fd      : ::c_int,\n        pub events  : ::c_short,\n        pub revents : ::c_short,\n    }\n\n    // resource.h\n    pub struct rlimit {\n                           pub rlim_cur : ::rlim_t,\n                           pub rlim_max : ::rlim_t,\n    }\n\n    // stat.h\n    pub struct stat {\n                         pub st_dev       : ::dev_t,\n                         pub st_ino       : ::ino_t,\n                         pub st_mode      : ::mode_t,\n                         pub st_nlink     : ::nlink_t,\n                         pub st_uid       : ::uid_t,\n                         pub st_gid       : ::gid_t,\n                         pub st_rdev      : ::dev_t,\n                         pub st_size      : ::off_t,\n                         pub st_atime     : ::time_t,\n                         pub st_mtime     : ::time_t,\n                         pub st_ctime     : ::time_t,\n                         pub st_blksize   : ::blksize_t,\n                         pub st_blocks    : ::blkcnt_t,\n                         pub st_attrib    : ::c_uchar,\n                         pub st_reserved1 : ::c_int,\n                         pub st_reserved2 : ::c_int,\n                         pub st_reserved3 : ::c_int,\n                         pub st_reserved4 : ::c_int,\n    }\n\n    //b_struct__Timespec.h\n    pub struct _Timespec {\n        pub tv_sec  : ::time_t,\n        pub tv_nsec : ::c_long,\n    }\n\n    // b_struct__Sched_param.h\n    pub struct _Sched_param {\n        pub sched_priority: ::c_int, /* scheduling priority */\n        pub sched_ss_low_priority: ::c_int,    /* low scheduling priority */\n        pub sched_ss_repl_period: ::_Timespec, /* replenishment period */\n        pub sched_ss_init_budget: ::_Timespec, /* initial budget */\n        pub sched_ss_max_repl: ::c_int,        /* max pending replenishment */\n\n    }\n\n    // b_pthread_attr_t.h\n    pub struct pthread_attr_t {\n        pub threadAttrStatus          : ::c_int,\n        pub threadAttrStacksize       : ::size_t,\n        pub threadAttrStackaddr       : *mut ::c_void,\n        pub threadAttrGuardsize       : ::size_t,\n        pub threadAttrDetachstate     : ::c_int,\n        pub threadAttrContentionscope : ::c_int,\n        pub threadAttrInheritsched    : ::c_int,\n        pub threadAttrSchedpolicy     : ::c_int,\n        pub threadAttrName            : *mut ::c_char,\n        pub threadAttrOptions         : ::c_int,\n        pub threadAttrSchedparam      : ::_Sched_param,\n    }\n\n    // signal.h\n\n    pub struct sigaction {\n        pub sa_u     : ::sa_u_t,\n        pub sa_mask  : ::sigset_t,\n        pub sa_flags : ::c_int,\n    }\n\n    // b_stack_t.h\n    pub struct stack_t {\n        pub ss_sp    : *mut ::c_void,\n        pub ss_size  : ::size_t,\n        pub ss_flags : ::c_int,\n    }\n\n    // signal.h\n    pub struct siginfo_t {\n        pub si_signo : ::c_int,\n        pub si_code  : ::c_int,\n        pub si_value : ::sigval,\n        pub si_errno : ::c_int,\n        pub si_status: ::c_int,\n        pub si_addr: *mut ::c_void,\n        pub si_uid: ::uid_t,\n        pub si_pid: ::pid_t,\n    }\n\n    // pthread.h (krnl)\n    // b_pthread_mutexattr_t.h (usr)\n    pub struct pthread_mutexattr_t {\n        mutexAttrStatus      : ::c_int,\n        mutexAttrPshared     : ::c_int,\n        mutexAttrProtocol    : ::c_int,\n        mutexAttrPrioceiling : ::c_int,\n        mutexAttrType        : ::c_int,\n    }\n\n    // pthread.h (krnl)\n    // b_pthread_mutex_t.h (usr)\n    pub struct pthread_mutex_t  {\n        pub mutexSemId: ::_Vx_SEM_ID, /*_Vx_SEM_ID ..*/\n        pub mutexValid: ::c_int,\n        pub mutexInitted: ::c_int,\n        pub mutexCondRefCount: ::c_int,\n        pub mutexSavPriority: ::c_int,\n        pub mutexAttr: ::pthread_mutexattr_t,\n        pub mutexSemName: [::c_char; _PTHREAD_SHARED_SEM_NAME_MAX],\n    }\n\n    // b_struct_timespec.h\n    pub struct timespec {\n        pub tv_sec: ::time_t,\n        pub tv_nsec: ::c_long,\n    }\n\n    // time.h\n    pub struct tm {\n        pub tm_sec: ::c_int,\n        pub tm_min: ::c_int,\n        pub tm_hour: ::c_int,\n        pub tm_mday: ::c_int,\n        pub tm_mon: ::c_int,\n        pub tm_year: ::c_int,\n        pub tm_wday: ::c_int,\n        pub tm_yday: ::c_int,\n        pub tm_isdst: ::c_int,\n    }\n\n    // in.h\n    pub struct in_addr {\n        pub s_addr: in_addr_t,\n    }\n\n    // in.h\n    pub struct ip_mreq {\n        pub imr_multiaddr: in_addr,\n        pub imr_interface: in_addr,\n    }\n\n    // in6.h\n    #[repr(align(4))]\n    pub struct in6_addr {\n        pub s6_addr: [u8; 16],\n    }\n\n    // in6.h\n    pub struct ipv6_mreq {\n        pub ipv6mr_multiaddr: in6_addr,\n        pub ipv6mr_interface: ::c_uint,\n    }\n\n    // netdb.h\n    pub struct addrinfo {\n        pub ai_flags    : ::c_int,\n        pub ai_family   : ::c_int,\n        pub ai_socktype : ::c_int,\n        pub ai_protocol : ::c_int,\n        pub ai_addrlen  : ::size_t,\n        pub ai_canonname: *mut ::c_char,\n        pub ai_addr     : *mut ::sockaddr,\n        pub ai_next     : *mut ::addrinfo,\n    }\n\n    // in.h\n    pub struct sockaddr_in {\n        pub sin_len   : u8,\n        pub sin_family: u8,\n        pub sin_port  : u16,\n        pub sin_addr  : ::in_addr,\n        pub sin_zero  : [::c_char; 8],\n    }\n\n    // in6.h\n    pub struct sockaddr_in6 {\n        pub sin6_len     : u8,\n        pub sin6_family  : u8,\n        pub sin6_port    : u16,\n        pub sin6_flowinfo: u32,\n        pub sin6_addr    : ::in6_addr,\n        pub sin6_scope_id: u32,\n    }\n\n    pub struct Dl_info {\n        pub dli_fname: *const ::c_char,\n        pub dli_fbase: *mut ::c_void,\n        pub dli_sname: *const ::c_char,\n        pub dli_saddr: *mut ::c_void,\n    }\n\n    pub struct mq_attr {\n        pub mq_maxmsg:  ::c_long,\n        pub mq_msgsize: ::c_long,\n        pub mq_flags:   ::c_long,\n        pub mq_curmsgs: ::c_long,\n    }\n}\n\ns_no_extra_traits! {\n    // dirent.h\n    pub struct dirent {\n        pub d_ino  : ::ino_t,\n        pub d_name : [::c_char; _PARM_NAME_MAX as usize + 1],\n    }\n\n    pub struct sockaddr_un {\n        pub sun_len: u8,\n        pub sun_family: sa_family_t,\n        pub sun_path: [::c_char; 104]\n    }\n\n    // rtpLibCommon.h\n    pub struct RTP_DESC {\n        pub status    : ::c_int,\n        pub options   : u32,\n        pub entrAddr  : *mut ::c_void,\n        pub initTaskId: ::TASK_ID,\n        pub parentId  : ::RTP_ID,\n        pub pathName  : [::c_char; VX_RTP_NAME_LENGTH as usize + 1],\n        pub taskCnt   : ::c_int,\n        pub textStart : *mut ::c_void,\n        pub textEnd   : *mut ::c_void,\n    }\n    // socket.h\n    pub struct sockaddr_storage {\n        pub ss_len     : ::c_uchar,\n        pub ss_family  : ::sa_family_t,\n        pub __ss_pad1  : [::c_char; _SS_PAD1SIZE],\n        pub __ss_align : i32,\n        pub __ss_pad2  : [::c_char; _SS_PAD2SIZE],\n    }\n\n    pub union sa_u_t {\n        pub sa_handler : ::Option<unsafe extern \"C\" fn(::c_int) -> !>,\n        pub sa_sigaction: ::Option<unsafe extern \"C\" fn(::c_int,\n                                                        *mut ::siginfo_t,\n                                                        *mut ::c_void) -> !>,\n    }\n\n    pub union sigval {\n        pub sival_int : ::c_int,\n        pub sival_ptr : *mut ::c_void,\n    }\n}\n\ncfg_if! {\n    if #[cfg(feature = \"extra_traits\")] {\n        impl ::fmt::Debug for dirent {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"dirent\")\n                    .field(\"d_ino\", &self.d_ino)\n                    .field(\"d_name\", &&self.d_name[..])\n                    .finish()\n            }\n        }\n\n        impl ::fmt::Debug for sockaddr_un {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"sockaddr_un\")\n                    .field(\"sun_len\", &self.sun_len)\n                    .field(\"sun_family\", &self.sun_family)\n                    .field(\"sun_path\", &&self.sun_path[..])\n                    .finish()\n            }\n        }\n\n        impl ::fmt::Debug for RTP_DESC {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"RTP_DESC\")\n                    .field(\"status\", &self.status)\n                    .field(\"options\", &self.options)\n                    .field(\"entrAddr\", &self.entrAddr)\n                    .field(\"initTaskId\", &self.initTaskId)\n                    .field(\"parentId\", &self.parentId)\n                    .field(\"pathName\", &&self.pathName[..])\n                    .field(\"taskCnt\", &self.taskCnt)\n                    .field(\"textStart\", &self.textStart)\n                    .field(\"textEnd\", &self.textEnd)\n                    .finish()\n            }\n        }\n        impl ::fmt::Debug for sockaddr_storage {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"sockaddr_storage\")\n                    .field(\"ss_len\", &self.ss_len)\n                    .field(\"ss_family\", &self.ss_family)\n                    .field(\"__ss_pad1\", &&self.__ss_pad1[..])\n                    .field(\"__ss_align\", &self.__ss_align)\n                    .field(\"__ss_pad2\", &&self.__ss_pad2[..])\n                    .finish()\n            }\n        }\n\n        impl PartialEq for sa_u_t {\n            fn eq(&self, other: &sa_u_t) -> bool {\n                unsafe {\n                    let h1 = match self.sa_handler {\n                        Some(handler) => handler as usize,\n                        None => 0 as usize,\n                    };\n                    let h2 = match other.sa_handler {\n                        Some(handler) => handler as usize,\n                        None => 0 as usize,\n                    };\n                    h1 == h2\n                }\n            }\n        }\n        impl Eq for sa_u_t {}\n        impl ::fmt::Debug for sa_u_t {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                unsafe {\n                    let h = match self.sa_handler {\n                        Some(handler) => handler as usize,\n                        None => 0 as usize,\n                    };\n\n                    f.debug_struct(\"sa_u_t\")\n                        .field(\"sa_handler\", &h)\n                        .finish()\n                }\n            }\n        }\n        impl ::hash::Hash for sa_u_t {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                unsafe {\n                    let h = match self.sa_handler {\n                        Some(handler) => handler as usize,\n                        None => 0 as usize,\n                    };\n                    h.hash(state)\n                }\n            }\n        }\n\n        impl PartialEq for sigval {\n            fn eq(&self, other: &sigval) -> bool {\n                unsafe { self.sival_ptr as usize == other.sival_ptr as usize }\n            }\n        }\n        impl Eq for sigval {}\n        impl ::fmt::Debug for sigval {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"sigval\")\n                    .field(\"sival_ptr\", unsafe { &(self.sival_ptr as usize) })\n                    .finish()\n            }\n        }\n        impl ::hash::Hash for sigval {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                unsafe { (self.sival_ptr as usize).hash(state) };\n            }\n        }\n    }\n}\n\npub const STDIN_FILENO: ::c_int = 0;\npub const STDOUT_FILENO: ::c_int = 1;\npub const STDERR_FILENO: ::c_int = 2;\n\npub const EXIT_SUCCESS: ::c_int = 0;\npub const EXIT_FAILURE: ::c_int = 1;\n\npub const EAI_SERVICE: ::c_int = 9;\npub const EAI_SOCKTYPE: ::c_int = 10;\npub const EAI_SYSTEM: ::c_int = 11;\n\n// This is not defined in vxWorks, but we have to define it here\n// to make the building pass for getrandom and libstd, FIXME\npub const RTLD_DEFAULT: *mut ::c_void = 0i64 as *mut ::c_void;\n\n//Clock Lib Stuff\npub const CLOCK_REALTIME: ::c_int = 0x0;\npub const CLOCK_MONOTONIC: ::c_int = 0x1;\npub const CLOCK_PROCESS_CPUTIME_ID: ::c_int = 0x2;\npub const CLOCK_THREAD_CPUTIME_ID: ::c_int = 0x3;\npub const TIMER_ABSTIME: ::c_int = 0x1;\npub const TIMER_RELTIME: ::c_int = 0x0;\n\n// PTHREAD STUFF\npub const PTHREAD_INITIALIZED_OBJ: ::c_int = 0xF70990EF;\npub const PTHREAD_DESTROYED_OBJ: ::c_int = -1;\npub const PTHREAD_VALID_OBJ: ::c_int = 0xEC542A37;\npub const PTHREAD_INVALID_OBJ: ::c_int = -1;\npub const PTHREAD_UNUSED_YET_OBJ: ::c_int = -1;\n\npub const PTHREAD_PRIO_NONE: ::c_int = 0;\npub const PTHREAD_PRIO_INHERIT: ::c_int = 1;\npub const PTHREAD_PRIO_PROTECT: ::c_int = 2;\n\npub const PTHREAD_MUTEX_NORMAL: ::c_int = 0;\npub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = 1;\npub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 2;\npub const PTHREAD_MUTEX_DEFAULT: ::c_int = PTHREAD_MUTEX_NORMAL;\npub const PTHREAD_STACK_MIN: usize = 4096;\npub const _PTHREAD_SHARED_SEM_NAME_MAX: usize = 30;\n\n// ERRNO STUFF\npub const OK: ::c_int = 0;\npub const EPERM: ::c_int = 1; /* Not owner */\npub const ENOENT: ::c_int = 2; /* No such file or directory */\npub const ESRCH: ::c_int = 3; /* No such process */\npub const EINTR: ::c_int = 4; /* Interrupted system call */\npub const EIO: ::c_int = 5; /* I/O error */\npub const ENXIO: ::c_int = 6; /* No such device or address */\npub const E2BIG: ::c_int = 7; /* Arg list too long */\npub const ENOEXEC: ::c_int = 8; /* Exec format error */\npub const EBADF: ::c_int = 9; /* Bad file number */\npub const ECHILD: ::c_int = 10; /* No children */\npub const EAGAIN: ::c_int = 11; /* No more processes */\npub const ENOMEM: ::c_int = 12; /* Not enough core */\npub const EACCES: ::c_int = 13; /* Permission denied */\npub const EFAULT: ::c_int = 14;\npub const ENOTEMPTY: ::c_int = 15;\npub const EBUSY: ::c_int = 16;\npub const EEXIST: ::c_int = 17;\npub const ENODEV: ::c_int = 19;\npub const ENOTDIR: ::c_int = 20;\npub const EISDIR: ::c_int = 21;\npub const EINVAL: ::c_int = 22;\npub const ENAMETOOLONG: ::c_int = 26;\npub const EFBIG: ::c_int = 27;\npub const ENOSPC: ::c_int = 28;\npub const EROFS: ::c_int = 30;\npub const EPIPE: ::c_int = 32;\npub const EDEADLK: ::c_int = 33;\npub const ERANGE: ::c_int = 38;\npub const EDESTADDRREQ: ::c_int = 40;\npub const EPROTOTYPE: ::c_int = 41;\npub const ENOPROTOOPT: ::c_int = 42;\npub const EPROTONOSUPPORT: ::c_int = 43;\npub const ESOCKTNOSUPPORT: ::c_int = 44;\npub const EOPNOTSUPP: ::c_int = 45;\npub const EPFNOSUPPORT: ::c_int = 46;\npub const EAFNOSUPPORT: ::c_int = 47;\npub const EADDRINUSE: ::c_int = 48;\npub const EADDRNOTAVAIL: ::c_int = 49;\npub const ENOTSOCK: ::c_int = 50;\npub const ENETUNREACH: ::c_int = 51;\npub const ENETRESET: ::c_int = 52;\npub const ECONNABORTED: ::c_int = 53;\npub const ECONNRESET: ::c_int = 54;\npub const ENOBUFS: ::c_int = 55;\npub const EISCONN: ::c_int = 56;\npub const ENOTCONN: ::c_int = 57;\npub const ESHUTDOWN: ::c_int = 58;\npub const ETOOMANYREFS: ::c_int = 59;\npub const ETIMEDOUT: ::c_int = 60;\npub const ECONNREFUSED: ::c_int = 61;\npub const EINPROGRESS: ::c_int = 68;\npub const EALREADY: ::c_int = 69;\npub const EWOULDBLOCK: ::c_int = 70;\npub const ENOSYS: ::c_int = 71;\npub const EDQUOT: ::c_int = 83;\npub const ESTALE: ::c_int = 88;\n\n// NFS errnos: Refer to pkgs_v2/storage/fs/nfs/h/nfs/nfsCommon.h\nconst M_nfsStat: ::c_int = 48 << 16;\nenum nfsstat {\n    NFSERR_REMOTE = 71,\n    NFSERR_WFLUSH = 99,\n    NFSERR_BADHANDLE = 10001,\n    NFSERR_NOT_SYNC = 10002,\n    NFSERR_BAD_COOKIE = 10003,\n    NFSERR_TOOSMALL = 10005,\n    NFSERR_BADTYPE = 10007,\n    NFSERR_JUKEBOX = 10008,\n}\n\npub const S_nfsLib_NFS_OK: ::c_int = OK;\npub const S_nfsLib_NFSERR_PERM: ::c_int = EPERM;\npub const S_nfsLib_NFSERR_NOENT: ::c_int = ENOENT;\npub const S_nfsLib_NFSERR_IO: ::c_int = EIO;\npub const S_nfsLib_NFSERR_NXIO: ::c_int = ENXIO;\npub const S_nfsLib_NFSERR_ACCESS: ::c_int = EACCES;\npub const S_nfsLib_NFSERR_EXIST: ::c_int = EEXIST;\npub const S_nfsLib_NFSERR_ENODEV: ::c_int = ENODEV;\npub const S_nfsLib_NFSERR_NOTDIR: ::c_int = ENOTDIR;\npub const S_nfsLib_NFSERR_ISDIR: ::c_int = EISDIR;\npub const S_nfsLib_NFSERR_INVAL: ::c_int = EINVAL;\npub const S_nfsLib_NFSERR_FBIG: ::c_int = EFBIG;\npub const S_nfsLib_NFSERR_NOSPC: ::c_int = ENOSPC;\npub const S_nfsLib_NFSERR_ROFS: ::c_int = EROFS;\npub const S_nfsLib_NFSERR_NAMETOOLONG: ::c_int = ENAMETOOLONG;\npub const S_nfsLib_NFSERR_NOTEMPTY: ::c_int = ENOTEMPTY;\npub const S_nfsLib_NFSERR_DQUOT: ::c_int = EDQUOT;\npub const S_nfsLib_NFSERR_STALE: ::c_int = ESTALE;\npub const S_nfsLib_NFSERR_WFLUSH: ::c_int = M_nfsStat | nfsstat::NFSERR_WFLUSH as ::c_int;\npub const S_nfsLib_NFSERR_REMOTE: ::c_int = M_nfsStat | nfsstat::NFSERR_REMOTE as ::c_int;\npub const S_nfsLib_NFSERR_BADHANDLE: ::c_int = M_nfsStat | nfsstat::NFSERR_BADHANDLE as ::c_int;\npub const S_nfsLib_NFSERR_NOT_SYNC: ::c_int = M_nfsStat | nfsstat::NFSERR_NOT_SYNC as ::c_int;\npub const S_nfsLib_NFSERR_BAD_COOKIE: ::c_int = M_nfsStat | nfsstat::NFSERR_BAD_COOKIE as ::c_int;\npub const S_nfsLib_NFSERR_NOTSUPP: ::c_int = EOPNOTSUPP;\npub const S_nfsLib_NFSERR_TOOSMALL: ::c_int = M_nfsStat | nfsstat::NFSERR_TOOSMALL as ::c_int;\npub const S_nfsLib_NFSERR_SERVERFAULT: ::c_int = EIO;\npub const S_nfsLib_NFSERR_BADTYPE: ::c_int = M_nfsStat | nfsstat::NFSERR_BADTYPE as ::c_int;\npub const S_nfsLib_NFSERR_JUKEBOX: ::c_int = M_nfsStat | nfsstat::NFSERR_JUKEBOX as ::c_int;\n\n// in.h\npub const IPPROTO_IP: ::c_int = 0;\npub const IPPROTO_IPV6: ::c_int = 41;\n\npub const IP_TTL: ::c_int = 4;\npub const IP_MULTICAST_IF: ::c_int = 9;\npub const IP_MULTICAST_TTL: ::c_int = 10;\npub const IP_MULTICAST_LOOP: ::c_int = 11;\npub const IP_ADD_MEMBERSHIP: ::c_int = 12;\npub const IP_DROP_MEMBERSHIP: ::c_int = 13;\n\n// in6.h\npub const IPV6_V6ONLY: ::c_int = 1;\npub const IPV6_UNICAST_HOPS: ::c_int = 4;\npub const IPV6_MULTICAST_IF: ::c_int = 9;\npub const IPV6_MULTICAST_HOPS: ::c_int = 10;\npub const IPV6_MULTICAST_LOOP: ::c_int = 11;\npub const IPV6_ADD_MEMBERSHIP: ::c_int = 12;\npub const IPV6_DROP_MEMBERSHIP: ::c_int = 13;\n\n// STAT Stuff\npub const S_IFMT: ::c_int = 0xf000;\npub const S_IFIFO: ::c_int = 0x1000;\npub const S_IFCHR: ::c_int = 0x2000;\npub const S_IFDIR: ::c_int = 0x4000;\npub const S_IFBLK: ::c_int = 0x6000;\npub const S_IFREG: ::c_int = 0x8000;\npub const S_IFLNK: ::c_int = 0xa000;\npub const S_IFSHM: ::c_int = 0xb000;\npub const S_IFSOCK: ::c_int = 0xc000;\npub const S_ISUID: ::c_int = 0x0800;\npub const S_ISGID: ::c_int = 0x0400;\npub const S_ISTXT: ::c_int = 0x0200;\npub const S_IRUSR: ::c_int = 0x0100;\npub const S_IWUSR: ::c_int = 0x0080;\npub const S_IXUSR: ::c_int = 0x0040;\npub const S_IRWXU: ::c_int = 0x01c0;\npub const S_IRGRP: ::c_int = 0x0020;\npub const S_IWGRP: ::c_int = 0x0010;\npub const S_IXGRP: ::c_int = 0x0008;\npub const S_IRWXG: ::c_int = 0x0038;\npub const S_IROTH: ::c_int = 0x0004;\npub const S_IWOTH: ::c_int = 0x0002;\npub const S_IXOTH: ::c_int = 0x0001;\npub const S_IRWXO: ::c_int = 0x0007;\n\n// socket.h\npub const SOL_SOCKET: ::c_int = 0xffff;\n\npub const SO_DEBUG: ::c_int = 0x0001;\npub const SO_REUSEADDR: ::c_int = 0x0004;\npub const SO_KEEPALIVE: ::c_int = 0x0008;\npub const SO_DONTROUTE: ::c_int = 0x0010;\npub const SO_RCVLOWAT: ::c_int = 0x0012;\npub const SO_SNDLOWAT: ::c_int = 0x0013;\npub const SO_SNDTIMEO: ::c_int = 0x1005;\npub const SO_ACCEPTCONN: ::c_int = 0x001e;\npub const SO_BROADCAST: ::c_int = 0x0020;\npub const SO_USELOOPBACK: ::c_int = 0x0040;\npub const SO_LINGER: ::c_int = 0x0080;\npub const SO_REUSEPORT: ::c_int = 0x0200;\n\npub const SO_VLAN: ::c_int = 0x8000;\n\npub const SO_SNDBUF: ::c_int = 0x1001;\npub const SO_RCVBUF: ::c_int = 0x1002;\npub const SO_RCVTIMEO: ::c_int = 0x1006;\npub const SO_ERROR: ::c_int = 0x1007;\npub const SO_TYPE: ::c_int = 0x1008;\npub const SO_BINDTODEVICE: ::c_int = 0x1010;\npub const SO_OOBINLINE: ::c_int = 0x1011;\npub const SO_CONNTIMEO: ::c_int = 0x100a;\n\npub const SOCK_STREAM: ::c_int = 1;\npub const SOCK_DGRAM: ::c_int = 2;\npub const SOCK_RAW: ::c_int = 3;\npub const SOCK_RDM: ::c_int = 4;\npub const SOCK_SEQPACKET: ::c_int = 5;\npub const SOCK_PACKET: ::c_int = 10;\n\npub const _SS_MAXSIZE: usize = 128;\npub const _SS_ALIGNSIZE: usize = size_of::<u32>();\npub const _SS_PAD1SIZE: usize = _SS_ALIGNSIZE - size_of::<::c_uchar>() - size_of::<::sa_family_t>();\npub const _SS_PAD2SIZE: usize = _SS_MAXSIZE\n    - size_of::<::c_uchar>()\n    - size_of::<::sa_family_t>()\n    - _SS_PAD1SIZE\n    - _SS_ALIGNSIZE;\n\npub const MSG_OOB: ::c_int = 0x0001;\npub const MSG_PEEK: ::c_int = 0x0002;\npub const MSG_DONTROUTE: ::c_int = 0x0004;\npub const MSG_EOR: ::c_int = 0x0008;\npub const MSG_TRUNC: ::c_int = 0x0010;\npub const MSG_CTRUNC: ::c_int = 0x0020;\npub const MSG_WAITALL: ::c_int = 0x0040;\npub const MSG_DONTWAIT: ::c_int = 0x0080;\npub const MSG_EOF: ::c_int = 0x0100;\npub const MSG_EXP: ::c_int = 0x0200;\npub const MSG_MBUF: ::c_int = 0x0400;\npub const MSG_NOTIFICATION: ::c_int = 0x0800;\npub const MSG_COMPAT: ::c_int = 0x8000;\n\npub const AF_UNSPEC: ::c_int = 0;\npub const AF_LOCAL: ::c_int = 1;\npub const AF_UNIX: ::c_int = AF_LOCAL;\npub const AF_INET: ::c_int = 2;\npub const AF_NETLINK: ::c_int = 16;\npub const AF_ROUTE: ::c_int = 17;\npub const AF_LINK: ::c_int = 18;\npub const AF_PACKET: ::c_int = 19;\npub const pseudo_AF_KEY: ::c_int = 27;\npub const AF_KEY: ::c_int = pseudo_AF_KEY;\npub const AF_INET6: ::c_int = 28;\npub const AF_SOCKDEV: ::c_int = 31;\npub const AF_TIPC: ::c_int = 33;\npub const AF_MIPC: ::c_int = 34;\npub const AF_MIPC_SAFE: ::c_int = 35;\npub const AF_MAX: ::c_int = 37;\n\npub const SHUT_RD: ::c_int = 0;\npub const SHUT_WR: ::c_int = 1;\npub const SHUT_RDWR: ::c_int = 2;\n\npub const IPPROTO_TCP: ::c_int = 6;\npub const TCP_NODELAY: ::c_int = 1;\npub const TCP_MAXSEG: ::c_int = 2;\npub const TCP_NOPUSH: ::c_int = 3;\npub const TCP_KEEPIDLE: ::c_int = 4;\npub const TCP_KEEPINTVL: ::c_int = 5;\npub const TCP_KEEPCNT: ::c_int = 6;\n\n// ioLib.h\npub const FIONREAD: ::c_int = 0x40040001;\npub const FIOFLUSH: ::c_int = 2;\npub const FIOOPTIONS: ::c_int = 3;\npub const FIOBAUDRATE: ::c_int = 4;\npub const FIODISKFORMAT: ::c_int = 5;\npub const FIODISKINIT: ::c_int = 6;\npub const FIOSEEK: ::c_int = 7;\npub const FIOWHERE: ::c_int = 8;\npub const FIODIRENTRY: ::c_int = 9;\npub const FIORENAME: ::c_int = 10;\npub const FIOREADYCHANGE: ::c_int = 11;\npub const FIODISKCHANGE: ::c_int = 13;\npub const FIOCANCEL: ::c_int = 14;\npub const FIOSQUEEZE: ::c_int = 15;\npub const FIOGETNAME: ::c_int = 18;\npub const FIONBIO: ::c_int = 0x90040010;\n\n// limits.h\npub const PATH_MAX: ::c_int = _PARM_PATH_MAX;\npub const _POSIX_PATH_MAX: ::c_int = 256;\n\n// Some poll stuff\npub const POLLIN: ::c_short = 0x0001;\npub const POLLPRI: ::c_short = 0x0002;\npub const POLLOUT: ::c_short = 0x0004;\npub const POLLRDNORM: ::c_short = 0x0040;\npub const POLLWRNORM: ::c_short = POLLOUT;\npub const POLLRDBAND: ::c_short = 0x0080;\npub const POLLWRBAND: ::c_short = 0x0100;\npub const POLLERR: ::c_short = 0x0008;\npub const POLLHUP: ::c_short = 0x0010;\npub const POLLNVAL: ::c_short = 0x0020;\n\n// fnctlcom.h\npub const FD_CLOEXEC: ::c_int = 1;\npub const F_DUPFD: ::c_int = 0;\npub const F_GETFD: ::c_int = 1;\npub const F_SETFD: ::c_int = 2;\npub const F_GETFL: ::c_int = 3;\npub const F_SETFL: ::c_int = 4;\npub const F_GETOWN: ::c_int = 5;\npub const F_SETOWN: ::c_int = 6;\npub const F_GETLK: ::c_int = 7;\npub const F_SETLK: ::c_int = 8;\npub const F_SETLKW: ::c_int = 9;\npub const F_DUPFD_CLOEXEC: ::c_int = 14;\n\n// signal.h\npub const SIG_DFL: sighandler_t = 0 as sighandler_t;\npub const SIG_IGN: sighandler_t = 1 as sighandler_t;\npub const SIG_ERR: sighandler_t = -1 as isize as sighandler_t;\n\npub const SIGHUP: ::c_int = 1;\npub const SIGINT: ::c_int = 2;\npub const SIGQUIT: ::c_int = 3;\npub const SIGILL: ::c_int = 4;\npub const SIGTRAP: ::c_int = 5;\npub const SIGABRT: ::c_int = 6;\npub const SIGEMT: ::c_int = 7;\npub const SIGFPE: ::c_int = 8;\npub const SIGKILL: ::c_int = 9;\npub const SIGBUS: ::c_int = 10;\npub const SIGSEGV: ::c_int = 11;\npub const SIGFMT: ::c_int = 12;\npub const SIGPIPE: ::c_int = 13;\npub const SIGALRM: ::c_int = 14;\npub const SIGTERM: ::c_int = 15;\npub const SIGCNCL: ::c_int = 16;\npub const SIGSTOP: ::c_int = 17;\npub const SIGTSTP: ::c_int = 18;\npub const SIGCONT: ::c_int = 19;\npub const SIGCHLD: ::c_int = 20;\npub const SIGTTIN: ::c_int = 21;\npub const SIGTTOU: ::c_int = 22;\n\npub const SIG_BLOCK: ::c_int = 1;\npub const SIG_UNBLOCK: ::c_int = 2;\npub const SIG_SETMASK: ::c_int = 3;\n\npub const SI_SYNC: ::c_int = 0;\npub const SI_USER: ::c_int = -1;\npub const SI_QUEUE: ::c_int = -2;\npub const SI_TIMER: ::c_int = -3;\npub const SI_ASYNCIO: ::c_int = -4;\npub const SI_MESGQ: ::c_int = -5;\npub const SI_CHILD: ::c_int = -6;\npub const SI_KILL: ::c_int = SI_USER;\n\n// vxParams.h definitions\npub const _PARM_NAME_MAX: ::c_int = 255;\npub const _PARM_PATH_MAX: ::c_int = 1024;\n\n// WAIT STUFF\npub const WNOHANG: ::c_int = 0x01;\npub const WUNTRACED: ::c_int = 0x02;\n\nconst PTHREAD_MUTEXATTR_INITIALIZER: pthread_mutexattr_t = pthread_mutexattr_t {\n    mutexAttrStatus: PTHREAD_INITIALIZED_OBJ,\n    mutexAttrProtocol: PTHREAD_PRIO_NONE,\n    mutexAttrPrioceiling: 0,\n    mutexAttrType: PTHREAD_MUTEX_DEFAULT,\n    mutexAttrPshared: 1,\n};\npub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n    mutexSemId: null_mut(),\n    mutexValid: PTHREAD_VALID_OBJ,\n    mutexInitted: PTHREAD_UNUSED_YET_OBJ,\n    mutexCondRefCount: 0,\n    mutexSavPriority: -1,\n    mutexAttr: PTHREAD_MUTEXATTR_INITIALIZER,\n    mutexSemName: [0; _PTHREAD_SHARED_SEM_NAME_MAX],\n};\n\nconst PTHREAD_CONDATTR_INITIALIZER: pthread_condattr_t = pthread_condattr_t {\n    condAttrStatus: 0xf70990ef,\n    condAttrPshared: 1,\n    condAttrClockId: CLOCK_REALTIME,\n};\npub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n    condSemId: null_mut(),\n    condValid: PTHREAD_VALID_OBJ,\n    condInitted: PTHREAD_UNUSED_YET_OBJ,\n    condRefCount: 0,\n    condMutex: null_mut(),\n    condAttr: PTHREAD_CONDATTR_INITIALIZER,\n    condSemName: [0; _PTHREAD_SHARED_SEM_NAME_MAX],\n};\n\nconst PTHREAD_RWLOCKATTR_INITIALIZER: pthread_rwlockattr_t = pthread_rwlockattr_t {\n    rwlockAttrStatus: PTHREAD_INITIALIZED_OBJ,\n    rwlockAttrPshared: 1,\n    rwlockAttrMaxReaders: 0,\n    rwlockAttrConformOpt: 1,\n};\npub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {\n    rwlockSemId: null_mut(),\n    rwlockReadersRefCount: 0,\n    rwlockValid: PTHREAD_VALID_OBJ,\n    rwlockInitted: PTHREAD_UNUSED_YET_OBJ,\n    rwlockAttr: PTHREAD_RWLOCKATTR_INITIALIZER,\n    rwlockSemName: [0; _PTHREAD_SHARED_SEM_NAME_MAX],\n};\n\npub const SEEK_SET: ::c_int = 0;\npub const SEEK_CUR: ::c_int = 1;\npub const SEEK_END: ::c_int = 2;\n\n// rtpLibCommon.h\npub const VX_RTP_NAME_LENGTH: ::c_int = 255;\npub const RTP_ID_ERROR: ::RTP_ID = -1;\n\n// h/public/unistd.h\npub const _SC_GETPW_R_SIZE_MAX: ::c_int = 21; // Via unistd.h\npub const _SC_PAGESIZE: ::c_int = 39;\npub const O_ACCMODE: ::c_int = 3;\npub const O_CLOEXEC: ::c_int = 0x100000; // fcntlcom\npub const O_EXCL: ::c_int = 0x0800;\npub const O_CREAT: ::c_int = 0x0200;\npub const O_TRUNC: ::c_int = 0x0400;\npub const O_APPEND: ::c_int = 0x0008;\npub const O_RDWR: ::c_int = 0x0002;\npub const O_WRONLY: ::c_int = 0x0001;\npub const O_RDONLY: ::c_int = 0;\npub const O_NONBLOCK: ::c_int = 0x4000;\n\n#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\npub enum FILE {}\nimpl ::Copy for FILE {}\nimpl ::Clone for FILE {\n    fn clone(&self) -> FILE {\n        *self\n    }\n}\n#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\npub enum fpos_t {} // FIXME: fill this out with a struct\nimpl ::Copy for fpos_t {}\nimpl ::Clone for fpos_t {\n    fn clone(&self) -> fpos_t {\n        *self\n    }\n}\n\nf! {\n    pub {const} fn CMSG_ALIGN(len: usize) -> usize {\n        len + ::mem::size_of::<usize>() - 1 & !(::mem::size_of::<usize>() - 1)\n    }\n\n    pub fn CMSG_NXTHDR(mhdr: *const msghdr,\n                       cmsg: *const cmsghdr) -> *mut cmsghdr {\n        let next = cmsg as usize + CMSG_ALIGN((*cmsg).cmsg_len as usize)\n            + CMSG_ALIGN(::mem::size_of::<::cmsghdr>());\n        let max = (*mhdr).msg_control as usize\n            + (*mhdr).msg_controllen as usize;\n        if next <= max {\n            (cmsg as usize + CMSG_ALIGN((*cmsg).cmsg_len as usize))\n                as *mut ::cmsghdr\n        } else {\n            0 as *mut ::cmsghdr\n        }\n    }\n\n    pub fn CMSG_FIRSTHDR(mhdr: *const msghdr) -> *mut cmsghdr {\n        if (*mhdr).msg_controllen as usize > 0  {\n            (*mhdr).msg_control as *mut cmsghdr\n        } else {\n            0 as *mut cmsghdr\n        }\n    }\n\n    pub fn CMSG_DATA(cmsg: *const cmsghdr) -> *mut ::c_uchar {\n        (cmsg as *mut ::c_uchar)\n            .offset(CMSG_ALIGN(::mem::size_of::<::cmsghdr>()) as isize)\n    }\n\n    pub {const} fn CMSG_SPACE(length: ::c_uint) -> ::c_uint {\n        (CMSG_ALIGN(length as usize) + CMSG_ALIGN(::mem::size_of::<cmsghdr>()))\n            as ::c_uint\n    }\n\n    pub fn CMSG_LEN(length: ::c_uint) -> ::c_uint {\n        CMSG_ALIGN(::mem::size_of::<cmsghdr>()) as ::c_uint + length\n    }\n}\n\nextern \"C\" {\n    pub fn isalnum(c: c_int) -> c_int;\n    pub fn isalpha(c: c_int) -> c_int;\n    pub fn iscntrl(c: c_int) -> c_int;\n    pub fn isdigit(c: c_int) -> c_int;\n    pub fn isgraph(c: c_int) -> c_int;\n    pub fn islower(c: c_int) -> c_int;\n    pub fn isprint(c: c_int) -> c_int;\n    pub fn ispunct(c: c_int) -> c_int;\n    pub fn isspace(c: c_int) -> c_int;\n    pub fn isupper(c: c_int) -> c_int;\n    pub fn isxdigit(c: c_int) -> c_int;\n    pub fn isblank(c: c_int) -> c_int;\n    pub fn tolower(c: c_int) -> c_int;\n    pub fn toupper(c: c_int) -> c_int;\n    pub fn fopen(filename: *const c_char, mode: *const c_char) -> *mut FILE;\n    pub fn freopen(filename: *const c_char, mode: *const c_char, file: *mut FILE) -> *mut FILE;\n    pub fn fflush(file: *mut FILE) -> c_int;\n    pub fn fclose(file: *mut FILE) -> c_int;\n    pub fn remove(filename: *const c_char) -> c_int;\n    pub fn rename(oldname: *const c_char, newname: *const c_char) -> c_int;\n    pub fn tmpfile() -> *mut FILE;\n    pub fn setvbuf(stream: *mut FILE, buffer: *mut c_char, mode: c_int, size: size_t) -> c_int;\n    pub fn setbuf(stream: *mut FILE, buf: *mut c_char);\n    pub fn getchar() -> c_int;\n    pub fn putchar(c: c_int) -> c_int;\n    pub fn fgetc(stream: *mut FILE) -> c_int;\n    pub fn fgets(buf: *mut c_char, n: c_int, stream: *mut FILE) -> *mut c_char;\n    pub fn fputc(c: c_int, stream: *mut FILE) -> c_int;\n    pub fn fputs(s: *const c_char, stream: *mut FILE) -> c_int;\n    pub fn puts(s: *const c_char) -> c_int;\n    pub fn ungetc(c: c_int, stream: *mut FILE) -> c_int;\n    pub fn fread(ptr: *mut c_void, size: size_t, nobj: size_t, stream: *mut FILE) -> size_t;\n    pub fn fwrite(ptr: *const c_void, size: size_t, nobj: size_t, stream: *mut FILE) -> size_t;\n    pub fn fseek(stream: *mut FILE, offset: c_long, whence: c_int) -> c_int;\n    pub fn ftell(stream: *mut FILE) -> c_long;\n    pub fn rewind(stream: *mut FILE);\n    pub fn fgetpos(stream: *mut FILE, ptr: *mut fpos_t) -> c_int;\n    pub fn fsetpos(stream: *mut FILE, ptr: *const fpos_t) -> c_int;\n    pub fn feof(stream: *mut FILE) -> c_int;\n    pub fn ferror(stream: *mut FILE) -> c_int;\n    pub fn perror(s: *const c_char);\n    pub fn atoi(s: *const c_char) -> c_int;\n    pub fn strtod(s: *const c_char, endp: *mut *mut c_char) -> c_double;\n    pub fn strtol(s: *const c_char, endp: *mut *mut c_char, base: c_int) -> c_long;\n    pub fn strtoul(s: *const c_char, endp: *mut *mut c_char, base: c_int) -> c_ulong;\n    pub fn calloc(nobj: size_t, size: size_t) -> *mut c_void;\n    pub fn malloc(size: size_t) -> *mut c_void;\n    pub fn realloc(p: *mut c_void, size: size_t) -> *mut c_void;\n    pub fn free(p: *mut c_void);\n    pub fn abort() -> !;\n    pub fn exit(status: c_int) -> !;\n    pub fn atexit(cb: extern \"C\" fn()) -> c_int;\n    pub fn system(s: *const c_char) -> c_int;\n    pub fn getenv(s: *const c_char) -> *mut c_char;\n\n    pub fn strcpy(dst: *mut c_char, src: *const c_char) -> *mut c_char;\n    pub fn strncpy(dst: *mut c_char, src: *const c_char, n: size_t) -> *mut c_char;\n    pub fn strcat(s: *mut c_char, ct: *const c_char) -> *mut c_char;\n    pub fn strncat(s: *mut c_char, ct: *const c_char, n: size_t) -> *mut c_char;\n    pub fn strcmp(cs: *const c_char, ct: *const c_char) -> c_int;\n    pub fn strncmp(cs: *const c_char, ct: *const c_char, n: size_t) -> c_int;\n    pub fn strcoll(cs: *const c_char, ct: *const c_char) -> c_int;\n    pub fn strchr(cs: *const c_char, c: c_int) -> *mut c_char;\n    pub fn strrchr(cs: *const c_char, c: c_int) -> *mut c_char;\n    pub fn strspn(cs: *const c_char, ct: *const c_char) -> size_t;\n    pub fn strcspn(cs: *const c_char, ct: *const c_char) -> size_t;\n    pub fn strdup(cs: *const c_char) -> *mut c_char;\n    pub fn strpbrk(cs: *const c_char, ct: *const c_char) -> *mut c_char;\n    pub fn strstr(cs: *const c_char, ct: *const c_char) -> *mut c_char;\n    pub fn strcasecmp(s1: *const c_char, s2: *const c_char) -> c_int;\n    pub fn strncasecmp(s1: *const c_char, s2: *const c_char, n: size_t) -> c_int;\n    pub fn strlen(cs: *const c_char) -> size_t;\n    pub fn strerror(n: c_int) -> *mut c_char;\n    pub fn strtok(s: *mut c_char, t: *const c_char) -> *mut c_char;\n    pub fn strxfrm(s: *mut c_char, ct: *const c_char, n: size_t) -> size_t;\n    pub fn wcslen(buf: *const wchar_t) -> size_t;\n    pub fn wcstombs(dest: *mut c_char, src: *const wchar_t, n: size_t) -> ::size_t;\n\n    pub fn memchr(cx: *const c_void, c: c_int, n: size_t) -> *mut c_void;\n    pub fn wmemchr(cx: *const wchar_t, c: wchar_t, n: size_t) -> *mut wchar_t;\n    pub fn memcmp(cx: *const c_void, ct: *const c_void, n: size_t) -> c_int;\n    pub fn memcpy(dest: *mut c_void, src: *const c_void, n: size_t) -> *mut c_void;\n    pub fn memmove(dest: *mut c_void, src: *const c_void, n: size_t) -> *mut c_void;\n    pub fn memset(dest: *mut c_void, c: c_int, n: size_t) -> *mut c_void;\n}\n\nextern \"C\" {\n    pub fn fprintf(stream: *mut ::FILE, format: *const ::c_char, ...) -> ::c_int;\n    pub fn printf(format: *const ::c_char, ...) -> ::c_int;\n    pub fn snprintf(s: *mut ::c_char, n: ::size_t, format: *const ::c_char, ...) -> ::c_int;\n    pub fn sprintf(s: *mut ::c_char, format: *const ::c_char, ...) -> ::c_int;\n    pub fn fscanf(stream: *mut ::FILE, format: *const ::c_char, ...) -> ::c_int;\n    pub fn scanf(format: *const ::c_char, ...) -> ::c_int;\n    pub fn sscanf(s: *const ::c_char, format: *const ::c_char, ...) -> ::c_int;\n    pub fn getchar_unlocked() -> ::c_int;\n    pub fn putchar_unlocked(c: ::c_int) -> ::c_int;\n    pub fn stat(path: *const c_char, buf: *mut stat) -> ::c_int;\n    pub fn fdopen(fd: ::c_int, mode: *const c_char) -> *mut ::FILE;\n    pub fn fileno(stream: *mut ::FILE) -> ::c_int;\n    pub fn creat(path: *const c_char, mode: mode_t) -> ::c_int;\n    pub fn rewinddir(dirp: *mut ::DIR);\n    pub fn fchown(fd: ::c_int, owner: ::uid_t, group: ::gid_t) -> ::c_int;\n    pub fn access(path: *const c_char, amode: ::c_int) -> ::c_int;\n    pub fn alarm(seconds: ::c_uint) -> ::c_uint;\n    pub fn fchdir(dirfd: ::c_int) -> ::c_int;\n    pub fn chown(path: *const c_char, uid: uid_t, gid: gid_t) -> ::c_int;\n    pub fn fpathconf(filedes: ::c_int, name: ::c_int) -> c_long;\n    pub fn getegid() -> gid_t;\n    pub fn geteuid() -> uid_t;\n    pub fn getgroups(ngroups_max: ::c_int, groups: *mut gid_t) -> ::c_int;\n    pub fn getlogin() -> *mut c_char;\n    pub fn getopt(argc: ::c_int, argv: *const *mut c_char, optstr: *const c_char) -> ::c_int;\n    pub fn pathconf(path: *const c_char, name: ::c_int) -> c_long;\n    pub fn pause() -> ::c_int;\n    pub fn seteuid(uid: uid_t) -> ::c_int;\n    pub fn setegid(gid: gid_t) -> ::c_int;\n    pub fn sleep(secs: ::c_uint) -> ::c_uint;\n    pub fn ttyname(fd: ::c_int) -> *mut c_char;\n    pub fn wait(status: *mut ::c_int) -> pid_t;\n    pub fn umask(mask: mode_t) -> mode_t;\n    pub fn mlock(addr: *const ::c_void, len: ::size_t) -> ::c_int;\n    pub fn mlockall(flags: ::c_int) -> ::c_int;\n    pub fn munlockall() -> ::c_int;\n\n    pub fn mmap(\n        addr: *mut ::c_void,\n        len: ::size_t,\n        prot: ::c_int,\n        flags: ::c_int,\n        fd: ::c_int,\n        offset: off_t,\n    ) -> *mut ::c_void;\n    pub fn munmap(addr: *mut ::c_void, len: ::size_t) -> ::c_int;\n    pub fn truncate(path: *const c_char, length: off_t) -> ::c_int;\n\n    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::c_void) -> ::c_int;\n    pub fn pthread_exit(value: *mut ::c_void) -> !;\n    pub fn pthread_attr_setdetachstate(attr: *mut ::pthread_attr_t, state: ::c_int) -> ::c_int;\n\n    pub fn strerror_r(errnum: ::c_int, buf: *mut c_char, buflen: ::size_t) -> ::c_int;\n\n    pub fn sigaction(signum: ::c_int, act: *const sigaction, oldact: *mut sigaction) -> ::c_int;\n\n    pub fn utimes(filename: *const ::c_char, times: *const ::timeval) -> ::c_int;\n\n    #[link_name = \"_rtld_dlopen\"]\n    pub fn dlopen(filename: *const ::c_char, flag: ::c_int) -> *mut ::c_void;\n\n    #[link_name = \"_rtld_dlerror\"]\n    pub fn dlerror() -> *mut ::c_char;\n\n    #[link_name = \"_rtld_dlsym\"]\n    pub fn dlsym(handle: *mut ::c_void, symbol: *const ::c_char) -> *mut ::c_void;\n\n    #[link_name = \"_rtld_dlclose\"]\n    pub fn dlclose(handle: *mut ::c_void) -> ::c_int;\n\n    #[link_name = \"_rtld_dladdr\"]\n    pub fn dladdr(addr: *mut ::c_void, info: *mut Dl_info) -> ::c_int;\n\n    // time.h\n    pub fn gmtime_r(time_p: *const time_t, result: *mut tm) -> *mut tm;\n    pub fn localtime_r(time_p: *const time_t, result: *mut tm) -> *mut tm;\n    pub fn mktime(tm: *mut tm) -> time_t;\n    pub fn time(time: *mut time_t) -> time_t;\n    pub fn gmtime(time_p: *const time_t) -> *mut tm;\n    pub fn localtime(time_p: *const time_t) -> *mut tm;\n    pub fn timegm(tm: *mut tm) -> time_t;\n    pub fn difftime(time1: time_t, time0: time_t) -> ::c_double;\n    pub fn gethostname(name: *mut ::c_char, len: ::size_t) -> ::c_int;\n    pub fn usleep(secs: ::useconds_t) -> ::c_int;\n    pub fn putenv(string: *mut c_char) -> ::c_int;\n    pub fn setlocale(category: ::c_int, locale: *const ::c_char) -> *mut ::c_char;\n\n    pub fn sigprocmask(how: ::c_int, set: *const sigset_t, oldset: *mut sigset_t) -> ::c_int;\n    pub fn sigpending(set: *mut sigset_t) -> ::c_int;\n\n    pub fn mkfifo(path: *const c_char, mode: mode_t) -> ::c_int;\n\n    pub fn fseeko(stream: *mut ::FILE, offset: ::off_t, whence: ::c_int) -> ::c_int;\n    pub fn ftello(stream: *mut ::FILE) -> ::off_t;\n    pub fn mkstemp(template: *mut ::c_char) -> ::c_int;\n\n    pub fn tmpnam(ptr: *mut ::c_char) -> *mut ::c_char;\n\n    pub fn openlog(ident: *const ::c_char, logopt: ::c_int, facility: ::c_int);\n    pub fn closelog();\n    pub fn setlogmask(maskpri: ::c_int) -> ::c_int;\n    pub fn syslog(priority: ::c_int, message: *const ::c_char, ...);\n    pub fn getline(lineptr: *mut *mut c_char, n: *mut size_t, stream: *mut FILE) -> ssize_t;\n\n}\n\nextern \"C\" {\n    // stdlib.h\n    pub fn memalign(block_size: ::size_t, size_arg: ::size_t) -> *mut ::c_void;\n\n    // ioLib.h\n    pub fn getcwd(buf: *mut ::c_char, size: ::size_t) -> *mut ::c_char;\n\n    // ioLib.h\n    pub fn chdir(attr: *const ::c_char) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_mutexattr_init(attr: *mut pthread_mutexattr_t) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_mutexattr_destroy(attr: *mut pthread_mutexattr_t) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_mutexattr_settype(pAttr: *mut ::pthread_mutexattr_t, pType: ::c_int) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_mutex_init(\n        mutex: *mut pthread_mutex_t,\n        attr: *const pthread_mutexattr_t,\n    ) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_mutex_destroy(mutex: *mut pthread_mutex_t) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_mutex_lock(mutex: *mut pthread_mutex_t) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_mutex_trylock(mutex: *mut pthread_mutex_t) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_mutex_timedlock(attr: *mut pthread_mutex_t, spec: *const timespec) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_mutex_unlock(mutex: *mut pthread_mutex_t) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_attr_setname(pAttr: *mut ::pthread_attr_t, name: *mut ::c_char) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_attr_setstacksize(attr: *mut ::pthread_attr_t, stacksize: ::size_t) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_attr_getstacksize(attr: *const ::pthread_attr_t, size: *mut ::size_t)\n        -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_attr_init(attr: *mut ::pthread_attr_t) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_create(\n        pThread: *mut ::pthread_t,\n        pAttr: *const ::pthread_attr_t,\n        start_routine: extern \"C\" fn(*mut ::c_void) -> *mut ::c_void,\n        value: *mut ::c_void,\n    ) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_attr_destroy(thread: *mut ::pthread_attr_t) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_detach(thread: ::pthread_t) -> ::c_int;\n\n    // int pthread_atfork (void (*)(void), void (*)(void), void (*)(void));\n    pub fn pthread_atfork(\n        prepare: ::Option<unsafe extern \"C\" fn()>,\n        parent: ::Option<unsafe extern \"C\" fn()>,\n        child: ::Option<unsafe extern \"C\" fn()>,\n    ) -> ::c_int;\n    // stat.h\n    pub fn fstat(fildes: ::c_int, buf: *mut stat) -> ::c_int;\n\n    // stat.h\n    pub fn lstat(path: *const ::c_char, buf: *mut stat) -> ::c_int;\n\n    // unistd.h\n    pub fn ftruncate(fd: ::c_int, length: off_t) -> ::c_int;\n\n    // dirent.h\n    pub fn readdir_r(pDir: *mut ::DIR, entry: *mut ::dirent, result: *mut *mut ::dirent)\n        -> ::c_int;\n\n    // dirent.h\n    pub fn readdir(pDir: *mut ::DIR) -> *mut ::dirent;\n\n    // fcntl.h or\n    // ioLib.h\n    pub fn open(path: *const ::c_char, oflag: ::c_int, ...) -> ::c_int;\n\n    // poll.h\n    pub fn poll(fds: *mut pollfd, nfds: nfds_t, timeout: ::c_int) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_condattr_init(attr: *mut ::pthread_condattr_t) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_condattr_destroy(attr: *mut ::pthread_condattr_t) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_condattr_getclock(\n        pAttr: *const ::pthread_condattr_t,\n        pClockId: *mut ::clockid_t,\n    ) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_condattr_setclock(\n        pAttr: *mut ::pthread_condattr_t,\n        clockId: ::clockid_t,\n    ) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_cond_init(\n        cond: *mut ::pthread_cond_t,\n        attr: *const ::pthread_condattr_t,\n    ) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_cond_destroy(cond: *mut pthread_cond_t) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_cond_signal(cond: *mut ::pthread_cond_t) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_cond_broadcast(cond: *mut ::pthread_cond_t) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_cond_wait(cond: *mut ::pthread_cond_t, mutex: *mut ::pthread_mutex_t)\n        -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_rwlockattr_init(attr: *mut ::pthread_rwlockattr_t) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_rwlockattr_destroy(attr: *mut ::pthread_rwlockattr_t) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_rwlockattr_setmaxreaders(\n        attr: *mut ::pthread_rwlockattr_t,\n        attr2: ::c_uint,\n    ) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_rwlock_init(\n        attr: *mut ::pthread_rwlock_t,\n        host: *const ::pthread_rwlockattr_t,\n    ) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_rwlock_destroy(attr: *mut ::pthread_rwlock_t) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_rwlock_rdlock(attr: *mut ::pthread_rwlock_t) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_rwlock_tryrdlock(attr: *mut ::pthread_rwlock_t) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_rwlock_timedrdlock(\n        attr: *mut ::pthread_rwlock_t,\n        host: *const ::timespec,\n    ) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_rwlock_wrlock(attr: *mut ::pthread_rwlock_t) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_rwlock_trywrlock(attr: *mut ::pthread_rwlock_t) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_rwlock_timedwrlock(\n        attr: *mut ::pthread_rwlock_t,\n        host: *const ::timespec,\n    ) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_rwlock_unlock(attr: *mut ::pthread_rwlock_t) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_key_create(\n        key: *mut ::pthread_key_t,\n        dtor: ::Option<unsafe extern \"C\" fn(*mut ::c_void)>,\n    ) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_key_delete(key: ::pthread_key_t) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_setspecific(key: ::pthread_key_t, value: *const ::c_void) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_getspecific(key: ::pthread_key_t) -> *mut ::c_void;\n\n    // pthread.h\n    pub fn pthread_cond_timedwait(\n        cond: *mut ::pthread_cond_t,\n        mutex: *mut ::pthread_mutex_t,\n        abstime: *const ::timespec,\n    ) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_attr_getname(attr: *mut ::pthread_attr_t, name: *mut *mut ::c_char) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_join(thread: ::pthread_t, status: *mut *mut ::c_void) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_self() -> ::pthread_t;\n\n    // clockLib.h\n    pub fn clock_gettime(clock_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;\n\n    // clockLib.h\n    pub fn clock_settime(clock_id: ::clockid_t, tp: *const ::timespec) -> ::c_int;\n\n    // clockLib.h\n    pub fn clock_getres(clock_id: ::clockid_t, res: *mut ::timespec) -> ::c_int;\n\n    // clockLib.h\n    pub fn clock_nanosleep(\n        clock_id: ::clockid_t,\n        flags: ::c_int,\n        rqtp: *const ::timespec,\n        rmtp: *mut ::timespec,\n    ) -> ::c_int;\n\n    // timerLib.h\n    pub fn nanosleep(rqtp: *const ::timespec, rmtp: *mut ::timespec) -> ::c_int;\n\n    // socket.h\n    pub fn accept(s: ::c_int, addr: *mut ::sockaddr, addrlen: *mut ::socklen_t) -> ::c_int;\n\n    // socket.h\n    pub fn bind(fd: ::c_int, addr: *const sockaddr, len: socklen_t) -> ::c_int;\n\n    // socket.h\n    pub fn connect(s: ::c_int, name: *const ::sockaddr, namelen: ::socklen_t) -> ::c_int;\n\n    // socket.h\n    pub fn getpeername(s: ::c_int, name: *mut ::sockaddr, namelen: *mut ::socklen_t) -> ::c_int;\n\n    // socket.h\n    pub fn getsockname(\n        socket: ::c_int,\n        address: *mut sockaddr,\n        address_len: *mut socklen_t,\n    ) -> ::c_int;\n\n    // socket.h\n    pub fn getsockopt(\n        sockfd: ::c_int,\n        level: ::c_int,\n        optname: ::c_int,\n        optval: *mut ::c_void,\n        optlen: *mut ::socklen_t,\n    ) -> ::c_int;\n\n    // socket.h\n    pub fn listen(socket: ::c_int, backlog: ::c_int) -> ::c_int;\n\n    // socket.h\n    pub fn recv(s: ::c_int, buf: *mut ::c_void, bufLen: ::size_t, flags: ::c_int) -> ::ssize_t;\n\n    // socket.h\n    pub fn recvfrom(\n        s: ::c_int,\n        buf: *mut ::c_void,\n        bufLen: ::size_t,\n        flags: ::c_int,\n        from: *mut ::sockaddr,\n        pFromLen: *mut ::socklen_t,\n    ) -> ::ssize_t;\n\n    pub fn recvmsg(socket: ::c_int, mp: *mut ::msghdr, flags: ::c_int) -> ::ssize_t;\n\n    // socket.h\n    pub fn send(socket: ::c_int, buf: *const ::c_void, len: ::size_t, flags: ::c_int) -> ::ssize_t;\n\n    pub fn sendmsg(socket: ::c_int, mp: *const ::msghdr, flags: ::c_int) -> ::ssize_t;\n\n    // socket.h\n    pub fn sendto(\n        socket: ::c_int,\n        buf: *const ::c_void,\n        len: ::size_t,\n        flags: ::c_int,\n        addr: *const sockaddr,\n        addrlen: socklen_t,\n    ) -> ::ssize_t;\n\n    // socket.h\n    pub fn setsockopt(\n        socket: ::c_int,\n        level: ::c_int,\n        name: ::c_int,\n        value: *const ::c_void,\n        option_len: socklen_t,\n    ) -> ::c_int;\n\n    // socket.h\n    pub fn shutdown(s: ::c_int, how: ::c_int) -> ::c_int;\n\n    // socket.h\n    pub fn socket(domain: ::c_int, _type: ::c_int, protocol: ::c_int) -> ::c_int;\n\n    // icotl.h\n    pub fn ioctl(fd: ::c_int, request: ::c_int, ...) -> ::c_int;\n\n    // fcntl.h\n    pub fn fcntl(fd: ::c_int, cmd: ::c_int, ...) -> ::c_int;\n\n    // ntp_rfc2553.h for kernel\n    // netdb.h for user\n    pub fn gai_strerror(errcode: ::c_int) -> *mut ::c_char;\n\n    // ioLib.h or\n    // unistd.h\n    pub fn close(fd: ::c_int) -> ::c_int;\n\n    // ioLib.h or\n    // unistd.h\n    pub fn read(fd: ::c_int, buf: *mut ::c_void, count: ::size_t) -> ::ssize_t;\n\n    // ioLib.h or\n    // unistd.h\n    pub fn write(fd: ::c_int, buf: *const ::c_void, count: ::size_t) -> ::ssize_t;\n\n    // ioLib.h or\n    // unistd.h\n    pub fn isatty(fd: ::c_int) -> ::c_int;\n\n    // ioLib.h or\n    // unistd.h\n    pub fn dup(src: ::c_int) -> ::c_int;\n\n    // ioLib.h or\n    // unistd.h\n    pub fn dup2(src: ::c_int, dst: ::c_int) -> ::c_int;\n\n    // ioLib.h or\n    // unistd.h\n    pub fn pipe(fds: *mut ::c_int) -> ::c_int;\n\n    // ioLib.h or\n    // unistd.h\n    pub fn unlink(pathname: *const ::c_char) -> ::c_int;\n\n    // unistd.h and\n    // ioLib.h\n    pub fn lseek(fd: ::c_int, offset: off_t, whence: ::c_int) -> off_t;\n\n    // netdb.h\n    pub fn getaddrinfo(\n        node: *const ::c_char,\n        service: *const ::c_char,\n        hints: *const addrinfo,\n        res: *mut *mut addrinfo,\n    ) -> ::c_int;\n\n    // netdb.h\n    pub fn freeaddrinfo(res: *mut addrinfo);\n\n    // signal.h\n    pub fn signal(signum: ::c_int, handler: sighandler_t) -> sighandler_t;\n\n    // unistd.h\n    pub fn getpid() -> pid_t;\n\n    // unistd.h\n    pub fn getppid() -> pid_t;\n\n    // wait.h\n    pub fn waitpid(pid: pid_t, status: *mut ::c_int, optons: ::c_int) -> pid_t;\n\n    // unistd.h\n    pub fn sysconf(attr: ::c_int) -> ::c_long;\n\n    // stdlib.h\n    pub fn setenv(\n        // setenv.c\n        envVarName: *const ::c_char,\n        envVarValue: *const ::c_char,\n        overwrite: ::c_int,\n    ) -> ::c_int;\n\n    // stdlib.h\n    pub fn unsetenv(\n        // setenv.c\n        envVarName: *const ::c_char,\n    ) -> ::c_int;\n\n    // stdlib.h\n    pub fn realpath(fileName: *const ::c_char, resolvedName: *mut ::c_char) -> *mut ::c_char;\n\n    // unistd.h\n    pub fn link(src: *const ::c_char, dst: *const ::c_char) -> ::c_int;\n\n    // unistd.h\n    pub fn readlink(path: *const ::c_char, buf: *mut ::c_char, bufsize: ::size_t) -> ::ssize_t;\n\n    // unistd.h\n    pub fn symlink(path1: *const ::c_char, path2: *const ::c_char) -> ::c_int;\n\n    // dirent.h\n    pub fn opendir(name: *const ::c_char) -> *mut ::DIR;\n\n    // unistd.h\n    pub fn rmdir(path: *const ::c_char) -> ::c_int;\n\n    // stat.h\n    pub fn mkdir(dirName: *const ::c_char, mode: ::mode_t) -> ::c_int;\n\n    // stat.h\n    pub fn chmod(path: *const ::c_char, mode: ::mode_t) -> ::c_int;\n\n    // stat.h\n    pub fn fchmod(attr1: ::c_int, attr2: ::mode_t) -> ::c_int;\n\n    // unistd.h\n    pub fn fsync(fd: ::c_int) -> ::c_int;\n\n    // dirent.h\n    pub fn closedir(ptr: *mut ::DIR) -> ::c_int;\n\n    // sched.h\n    pub fn sched_yield() -> ::c_int;\n\n    // errnoLib.h\n    pub fn errnoSet(err: ::c_int) -> ::c_int;\n\n    // errnoLib.h\n    pub fn errnoGet() -> ::c_int;\n\n    // unistd.h\n    pub fn _exit(status: ::c_int) -> !;\n\n    // unistd.h\n    pub fn setgid(gid: ::gid_t) -> ::c_int;\n\n    // unistd.h\n    pub fn getgid() -> ::gid_t;\n\n    // unistd.h\n    pub fn setuid(uid: ::uid_t) -> ::c_int;\n\n    // unistd.h\n    pub fn getuid() -> ::uid_t;\n\n    // signal.h\n    pub fn sigemptyset(__set: *mut sigset_t) -> ::c_int;\n\n    // pthread.h for kernel\n    // signal.h for user\n    pub fn pthread_sigmask(\n        __how: ::c_int,\n        __set: *const sigset_t,\n        __oset: *mut sigset_t,\n    ) -> ::c_int;\n\n    // signal.h for user\n    pub fn kill(__pid: pid_t, __signo: ::c_int) -> ::c_int;\n\n    // signal.h for user\n    pub fn sigqueue(__pid: pid_t, __signo: ::c_int, __value: ::sigval) -> ::c_int;\n\n    // signal.h for user\n    pub fn _sigqueue(\n        rtpId: ::RTP_ID,\n        signo: ::c_int,\n        pValue: *const ::sigval,\n        sigCode: ::c_int,\n    ) -> ::c_int;\n\n    // signal.h\n    pub fn taskKill(taskId: ::TASK_ID, signo: ::c_int) -> ::c_int;\n\n    // signal.h\n    pub fn raise(__signo: ::c_int) -> ::c_int;\n\n    // taskLibCommon.h\n    pub fn taskIdSelf() -> ::TASK_ID;\n    pub fn taskDelay(ticks: ::_Vx_ticks_t) -> ::c_int;\n\n    // rtpLibCommon.h\n    pub fn rtpInfoGet(rtpId: ::RTP_ID, rtpStruct: *mut ::RTP_DESC) -> ::c_int;\n    pub fn rtpSpawn(\n        pubrtpFileName: *const ::c_char,\n        argv: *mut *const ::c_char,\n        envp: *mut *const ::c_char,\n        priority: ::c_int,\n        uStackSize: ::size_t,\n        options: ::c_int,\n        taskOptions: ::c_int,\n    ) -> RTP_ID;\n\n    // ioLib.h\n    pub fn _realpath(fileName: *const ::c_char, resolvedName: *mut ::c_char) -> *mut ::c_char;\n\n    // pathLib.h\n    pub fn _pathIsAbsolute(filepath: *const ::c_char, pNameTail: *mut *const ::c_char) -> BOOL;\n\n    pub fn writev(fd: ::c_int, iov: *const ::iovec, iovcnt: ::c_int) -> ::ssize_t;\n    pub fn readv(fd: ::c_int, iov: *const ::iovec, iovcnt: ::c_int) -> ::ssize_t;\n\n    // randomNumGen.h\n    pub fn randBytes(buf: *mut c_uchar, length: c_int) -> c_int;\n    pub fn randABytes(buf: *mut c_uchar, length: c_int) -> c_int;\n    pub fn randUBytes(buf: *mut c_uchar, length: c_int) -> c_int;\n    pub fn randSecure() -> c_int;\n\n    // mqueue.h\n    pub fn mq_open(name: *const ::c_char, oflag: ::c_int, ...) -> ::mqd_t;\n    pub fn mq_close(mqd: ::mqd_t) -> ::c_int;\n    pub fn mq_unlink(name: *const ::c_char) -> ::c_int;\n    pub fn mq_receive(\n        mqd: ::mqd_t,\n        msg_ptr: *mut ::c_char,\n        msg_len: ::size_t,\n        msg_prio: *mut ::c_uint,\n    ) -> ::ssize_t;\n    pub fn mq_timedreceive(\n        mqd: ::mqd_t,\n        msg_ptr: *mut ::c_char,\n        msg_len: ::size_t,\n        msg_prio: *mut ::c_uint,\n        abs_timeout: *const ::timespec,\n    ) -> ::ssize_t;\n    pub fn mq_send(\n        mqd: ::mqd_t,\n        msg_ptr: *const ::c_char,\n        msg_len: ::size_t,\n        msg_prio: ::c_uint,\n    ) -> ::c_int;\n    pub fn mq_timedsend(\n        mqd: ::mqd_t,\n        msg_ptr: *const ::c_char,\n        msg_len: ::size_t,\n        msg_prio: ::c_uint,\n        abs_timeout: *const ::timespec,\n    ) -> ::c_int;\n    pub fn mq_getattr(mqd: ::mqd_t, attr: *mut ::mq_attr) -> ::c_int;\n    pub fn mq_setattr(mqd: ::mqd_t, newattr: *const ::mq_attr, oldattr: *mut ::mq_attr) -> ::c_int;\n}\n\n//Dummy functions, these don't really exist in VxWorks.\n\n// wait.h macros\nsafe_f! {\n    pub {const} fn WIFEXITED(status: ::c_int) -> bool {\n        (status & 0xFF00) == 0\n    }\n    pub {const} fn WIFSIGNALED(status: ::c_int) -> bool {\n        (status & 0xFF00) != 0\n    }\n    pub {const} fn WIFSTOPPED(status: ::c_int) -> bool {\n        (status & 0xFF0000) != 0\n    }\n    pub {const} fn WEXITSTATUS(status: ::c_int) -> ::c_int {\n        status & 0xFF\n    }\n    pub {const} fn WTERMSIG(status: ::c_int) -> ::c_int {\n        (status >> 8) & 0xFF\n    }\n    pub {const} fn WSTOPSIG(status: ::c_int) -> ::c_int {\n        (status >> 16) & 0xFF\n    }\n}\n\npub fn pread(_fd: ::c_int, _buf: *mut ::c_void, _count: ::size_t, _offset: off64_t) -> ::ssize_t {\n    -1\n}\n\npub fn pwrite(\n    _fd: ::c_int,\n    _buf: *const ::c_void,\n    _count: ::size_t,\n    _offset: off64_t,\n) -> ::ssize_t {\n    -1\n}\npub fn posix_memalign(memptr: *mut *mut ::c_void, align: ::size_t, size: ::size_t) -> ::c_int {\n    // check to see if align is a power of 2 and if align is a multiple\n    //  of sizeof(void *)\n    if (align & align - 1 != 0) || (align as usize % size_of::<::size_t>() != 0) {\n        return ::EINVAL;\n    }\n\n    unsafe {\n        // posix_memalign should not set errno\n        let e = ::errnoGet();\n\n        let temp = memalign(align, size);\n        ::errnoSet(e as ::c_int);\n\n        if temp.is_null() {\n            ::ENOMEM\n        } else {\n            *memptr = temp;\n            0\n        }\n    }\n}\n\ncfg_if! {\n    if #[cfg(libc_core_cvoid)] {\n        pub use ::ffi::c_void;\n    } else {\n        // Use repr(u8) as LLVM expects `void*` to be the same as `i8*` to help\n        // enable more optimization opportunities around it recognizing things\n        // like malloc/free.\n        #[repr(u8)]\n        #[allow(missing_copy_implementations)]\n        #[allow(missing_debug_implementations)]\n        pub enum c_void {\n            // Two dummy variants so the #[repr] attribute can be used.\n            #[doc(hidden)]\n            __variant1,\n            #[doc(hidden)]\n            __variant2,\n        }\n    }\n}\n\ncfg_if! {\n    if #[cfg(target_arch = \"aarch64\")] {\n        mod aarch64;\n        pub use self::aarch64::*;\n    } else if #[cfg(any(target_arch = \"arm\"))] {\n        mod arm;\n        pub use self::arm::*;\n    }  else if #[cfg(any(target_arch = \"x86\"))] {\n        mod x86;\n        pub use self::x86::*;\n    } else if #[cfg(any(target_arch = \"x86_64\"))] {\n        mod x86_64;\n        pub use self::x86_64::*;\n    } else if #[cfg(any(target_arch = \"powerpc\"))] {\n        mod powerpc;\n        pub use self::powerpc::*;\n    } else if #[cfg(any(target_arch = \"powerpc64\"))] {\n        mod powerpc64;\n        pub use self::powerpc64::*;\n    } else {\n        // Unknown target_arch\n    }\n}\n"],["1118","pub type c_char = u8;\npub type wchar_t = u32;\npub type c_long = i32;\npub type c_ulong = u32;\n"],["1119","pub type c_char = i8;\npub type wchar_t = i32;\npub type c_long = i32;\npub type c_ulong = u32;\n"],["1120","pub type c_char = i8;\npub type wchar_t = i32;\npub type c_long = i64;\npub type c_ulong = u64;\n"],["1121","//! Windows CRT definitions\n\npub type c_schar = i8;\npub type c_uchar = u8;\npub type c_short = i16;\npub type c_ushort = u16;\npub type c_int = i32;\npub type c_uint = u32;\npub type c_float = f32;\npub type c_double = f64;\npub type c_longlong = i64;\npub type c_ulonglong = u64;\npub type intmax_t = i64;\npub type uintmax_t = u64;\n\npub type size_t = usize;\npub type ptrdiff_t = isize;\npub type intptr_t = isize;\npub type uintptr_t = usize;\npub type ssize_t = isize;\npub type sighandler_t = usize;\n\npub type c_char = i8;\npub type c_long = i32;\npub type c_ulong = u32;\npub type wchar_t = u16;\n\npub type clock_t = i32;\n\ncfg_if! {\n    if #[cfg(all(target_arch = \"x86\", target_env = \"gnu\"))] {\n        pub type time_t = i32;\n    } else {\n        pub type time_t = i64;\n    }\n}\n\npub type off_t = i32;\npub type dev_t = u32;\npub type ino_t = u16;\n#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\npub enum timezone {}\nimpl ::Copy for timezone {}\nimpl ::Clone for timezone {\n    fn clone(&self) -> timezone {\n        *self\n    }\n}\npub type time64_t = i64;\n\npub type SOCKET = ::uintptr_t;\n\ns! {\n    // note this is the struct called stat64 in Windows. Not stat, nor stati64.\n    pub struct stat {\n        pub st_dev: dev_t,\n        pub st_ino: ino_t,\n        pub st_mode: u16,\n        pub st_nlink: ::c_short,\n        pub st_uid: ::c_short,\n        pub st_gid: ::c_short,\n        pub st_rdev: dev_t,\n        pub st_size: i64,\n        pub st_atime: time64_t,\n        pub st_mtime: time64_t,\n        pub st_ctime: time64_t,\n    }\n\n    // note that this is called utimbuf64 in Windows\n    pub struct utimbuf {\n        pub actime: time64_t,\n        pub modtime: time64_t,\n    }\n\n    pub struct tm {\n        pub tm_sec: ::c_int,\n        pub tm_min: ::c_int,\n        pub tm_hour: ::c_int,\n        pub tm_mday: ::c_int,\n        pub tm_mon: ::c_int,\n        pub tm_year: ::c_int,\n        pub tm_wday: ::c_int,\n        pub tm_yday: ::c_int,\n        pub tm_isdst: ::c_int,\n    }\n\n    pub struct timeval {\n        pub tv_sec: c_long,\n        pub tv_usec: c_long,\n    }\n\n    pub struct timespec {\n        pub tv_sec: time_t,\n        pub tv_nsec: c_long,\n    }\n\n    pub struct sockaddr {\n        pub sa_family: c_ushort,\n        pub sa_data: [c_char; 14],\n    }\n}\n\npub const INT_MIN: c_int = -2147483648;\npub const INT_MAX: c_int = 2147483647;\n\npub const EXIT_FAILURE: ::c_int = 1;\npub const EXIT_SUCCESS: ::c_int = 0;\npub const RAND_MAX: ::c_int = 32767;\npub const EOF: ::c_int = -1;\npub const SEEK_SET: ::c_int = 0;\npub const SEEK_CUR: ::c_int = 1;\npub const SEEK_END: ::c_int = 2;\npub const _IOFBF: ::c_int = 0;\npub const _IONBF: ::c_int = 4;\npub const _IOLBF: ::c_int = 64;\npub const BUFSIZ: ::c_uint = 512;\npub const FOPEN_MAX: ::c_uint = 20;\npub const FILENAME_MAX: ::c_uint = 260;\n\n// fcntl.h\npub const O_RDONLY: ::c_int = 0x0000;\npub const O_WRONLY: ::c_int = 0x0001;\npub const O_RDWR: ::c_int = 0x0002;\npub const O_APPEND: ::c_int = 0x0008;\npub const O_CREAT: ::c_int = 0x0100;\npub const O_TRUNC: ::c_int = 0x0200;\npub const O_EXCL: ::c_int = 0x0400;\npub const O_TEXT: ::c_int = 0x4000;\npub const O_BINARY: ::c_int = 0x8000;\npub const _O_WTEXT: ::c_int = 0x10000;\npub const _O_U16TEXT: ::c_int = 0x20000;\npub const _O_U8TEXT: ::c_int = 0x40000;\npub const O_RAW: ::c_int = O_BINARY;\npub const O_NOINHERIT: ::c_int = 0x0080;\npub const O_TEMPORARY: ::c_int = 0x0040;\npub const _O_SHORT_LIVED: ::c_int = 0x1000;\npub const _O_OBTAIN_DIR: ::c_int = 0x2000;\npub const O_SEQUENTIAL: ::c_int = 0x0020;\npub const O_RANDOM: ::c_int = 0x0010;\n\npub const S_IFCHR: ::c_int = 8192;\npub const S_IFDIR: ::c_int = 16384;\npub const S_IFREG: ::c_int = 32768;\npub const S_IFMT: ::c_int = 61440;\npub const S_IEXEC: ::c_int = 64;\npub const S_IWRITE: ::c_int = 128;\npub const S_IREAD: ::c_int = 256;\n\npub const LC_ALL: ::c_int = 0;\npub const LC_COLLATE: ::c_int = 1;\npub const LC_CTYPE: ::c_int = 2;\npub const LC_MONETARY: ::c_int = 3;\npub const LC_NUMERIC: ::c_int = 4;\npub const LC_TIME: ::c_int = 5;\n\npub const EPERM: ::c_int = 1;\npub const ENOENT: ::c_int = 2;\npub const ESRCH: ::c_int = 3;\npub const EINTR: ::c_int = 4;\npub const EIO: ::c_int = 5;\npub const ENXIO: ::c_int = 6;\npub const E2BIG: ::c_int = 7;\npub const ENOEXEC: ::c_int = 8;\npub const EBADF: ::c_int = 9;\npub const ECHILD: ::c_int = 10;\npub const EAGAIN: ::c_int = 11;\npub const ENOMEM: ::c_int = 12;\npub const EACCES: ::c_int = 13;\npub const EFAULT: ::c_int = 14;\npub const EBUSY: ::c_int = 16;\npub const EEXIST: ::c_int = 17;\npub const EXDEV: ::c_int = 18;\npub const ENODEV: ::c_int = 19;\npub const ENOTDIR: ::c_int = 20;\npub const EISDIR: ::c_int = 21;\npub const EINVAL: ::c_int = 22;\npub const ENFILE: ::c_int = 23;\npub const EMFILE: ::c_int = 24;\npub const ENOTTY: ::c_int = 25;\npub const EFBIG: ::c_int = 27;\npub const ENOSPC: ::c_int = 28;\npub const ESPIPE: ::c_int = 29;\npub const EROFS: ::c_int = 30;\npub const EMLINK: ::c_int = 31;\npub const EPIPE: ::c_int = 32;\npub const EDOM: ::c_int = 33;\npub const ERANGE: ::c_int = 34;\npub const EDEADLK: ::c_int = 36;\npub const EDEADLOCK: ::c_int = 36;\npub const ENAMETOOLONG: ::c_int = 38;\npub const ENOLCK: ::c_int = 39;\npub const ENOSYS: ::c_int = 40;\npub const ENOTEMPTY: ::c_int = 41;\npub const EILSEQ: ::c_int = 42;\npub const STRUNCATE: ::c_int = 80;\n\n// POSIX Supplement (from errno.h)\npub const EADDRINUSE: ::c_int = 100;\npub const EADDRNOTAVAIL: ::c_int = 101;\npub const EAFNOSUPPORT: ::c_int = 102;\npub const EALREADY: ::c_int = 103;\npub const EBADMSG: ::c_int = 104;\npub const ECANCELED: ::c_int = 105;\npub const ECONNABORTED: ::c_int = 106;\npub const ECONNREFUSED: ::c_int = 107;\npub const ECONNRESET: ::c_int = 108;\npub const EDESTADDRREQ: ::c_int = 109;\npub const EHOSTUNREACH: ::c_int = 110;\npub const EIDRM: ::c_int = 111;\npub const EINPROGRESS: ::c_int = 112;\npub const EISCONN: ::c_int = 113;\npub const ELOOP: ::c_int = 114;\npub const EMSGSIZE: ::c_int = 115;\npub const ENETDOWN: ::c_int = 116;\npub const ENETRESET: ::c_int = 117;\npub const ENETUNREACH: ::c_int = 118;\npub const ENOBUFS: ::c_int = 119;\npub const ENODATA: ::c_int = 120;\npub const ENOLINK: ::c_int = 121;\npub const ENOMSG: ::c_int = 122;\npub const ENOPROTOOPT: ::c_int = 123;\npub const ENOSR: ::c_int = 124;\npub const ENOSTR: ::c_int = 125;\npub const ENOTCONN: ::c_int = 126;\npub const ENOTRECOVERABLE: ::c_int = 127;\npub const ENOTSOCK: ::c_int = 128;\npub const ENOTSUP: ::c_int = 129;\npub const EOPNOTSUPP: ::c_int = 130;\npub const EOVERFLOW: ::c_int = 132;\npub const EOWNERDEAD: ::c_int = 133;\npub const EPROTO: ::c_int = 134;\npub const EPROTONOSUPPORT: ::c_int = 135;\npub const EPROTOTYPE: ::c_int = 136;\npub const ETIME: ::c_int = 137;\npub const ETIMEDOUT: ::c_int = 138;\npub const ETXTBSY: ::c_int = 139;\npub const EWOULDBLOCK: ::c_int = 140;\n\n// signal codes\npub const SIGINT: ::c_int = 2;\npub const SIGILL: ::c_int = 4;\npub const SIGFPE: ::c_int = 8;\npub const SIGSEGV: ::c_int = 11;\npub const SIGTERM: ::c_int = 15;\npub const SIGABRT: ::c_int = 22;\npub const NSIG: ::c_int = 23;\npub const SIG_ERR: ::c_int = -1;\n\n// inline comment below appeases style checker\n#[cfg(all(target_env = \"msvc\", feature = \"rustc-dep-of-std\"))] // \" if \"\n#[link(name = \"msvcrt\", cfg(not(target_feature = \"crt-static\")))]\n#[link(name = \"libcmt\", cfg(target_feature = \"crt-static\"))]\nextern \"C\" {}\n\n#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\npub enum FILE {}\nimpl ::Copy for FILE {}\nimpl ::Clone for FILE {\n    fn clone(&self) -> FILE {\n        *self\n    }\n}\n#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\npub enum fpos_t {} // FIXME: fill this out with a struct\nimpl ::Copy for fpos_t {}\nimpl ::Clone for fpos_t {\n    fn clone(&self) -> fpos_t {\n        *self\n    }\n}\n\nextern \"C\" {\n    pub fn isalnum(c: c_int) -> c_int;\n    pub fn isalpha(c: c_int) -> c_int;\n    pub fn iscntrl(c: c_int) -> c_int;\n    pub fn isdigit(c: c_int) -> c_int;\n    pub fn isgraph(c: c_int) -> c_int;\n    pub fn islower(c: c_int) -> c_int;\n    pub fn isprint(c: c_int) -> c_int;\n    pub fn ispunct(c: c_int) -> c_int;\n    pub fn isspace(c: c_int) -> c_int;\n    pub fn isupper(c: c_int) -> c_int;\n    pub fn isxdigit(c: c_int) -> c_int;\n    pub fn isblank(c: c_int) -> c_int;\n    pub fn tolower(c: c_int) -> c_int;\n    pub fn toupper(c: c_int) -> c_int;\n    pub fn fopen(filename: *const c_char, mode: *const c_char) -> *mut FILE;\n    pub fn freopen(filename: *const c_char, mode: *const c_char, file: *mut FILE) -> *mut FILE;\n    pub fn fflush(file: *mut FILE) -> c_int;\n    pub fn fclose(file: *mut FILE) -> c_int;\n    pub fn remove(filename: *const c_char) -> c_int;\n    pub fn rename(oldname: *const c_char, newname: *const c_char) -> c_int;\n    pub fn tmpfile() -> *mut FILE;\n    pub fn setvbuf(stream: *mut FILE, buffer: *mut c_char, mode: c_int, size: size_t) -> c_int;\n    pub fn setbuf(stream: *mut FILE, buf: *mut c_char);\n    pub fn getchar() -> c_int;\n    pub fn putchar(c: c_int) -> c_int;\n    pub fn fgetc(stream: *mut FILE) -> c_int;\n    pub fn fgets(buf: *mut c_char, n: c_int, stream: *mut FILE) -> *mut c_char;\n    pub fn fputc(c: c_int, stream: *mut FILE) -> c_int;\n    pub fn fputs(s: *const c_char, stream: *mut FILE) -> c_int;\n    pub fn puts(s: *const c_char) -> c_int;\n    pub fn ungetc(c: c_int, stream: *mut FILE) -> c_int;\n    pub fn fread(ptr: *mut c_void, size: size_t, nobj: size_t, stream: *mut FILE) -> size_t;\n    pub fn fwrite(ptr: *const c_void, size: size_t, nobj: size_t, stream: *mut FILE) -> size_t;\n    pub fn fseek(stream: *mut FILE, offset: c_long, whence: c_int) -> c_int;\n    pub fn ftell(stream: *mut FILE) -> c_long;\n    pub fn rewind(stream: *mut FILE);\n    pub fn fgetpos(stream: *mut FILE, ptr: *mut fpos_t) -> c_int;\n    pub fn fsetpos(stream: *mut FILE, ptr: *const fpos_t) -> c_int;\n    pub fn feof(stream: *mut FILE) -> c_int;\n    pub fn ferror(stream: *mut FILE) -> c_int;\n    pub fn perror(s: *const c_char);\n    pub fn atoi(s: *const c_char) -> c_int;\n    pub fn strtod(s: *const c_char, endp: *mut *mut c_char) -> c_double;\n    pub fn strtol(s: *const c_char, endp: *mut *mut c_char, base: c_int) -> c_long;\n    pub fn strtoul(s: *const c_char, endp: *mut *mut c_char, base: c_int) -> c_ulong;\n    pub fn calloc(nobj: size_t, size: size_t) -> *mut c_void;\n    pub fn malloc(size: size_t) -> *mut c_void;\n    pub fn realloc(p: *mut c_void, size: size_t) -> *mut c_void;\n    pub fn free(p: *mut c_void);\n    pub fn abort() -> !;\n    pub fn exit(status: c_int) -> !;\n    pub fn _exit(status: c_int) -> !;\n    pub fn atexit(cb: extern \"C\" fn()) -> c_int;\n    pub fn system(s: *const c_char) -> c_int;\n    pub fn getenv(s: *const c_char) -> *mut c_char;\n\n    pub fn strcpy(dst: *mut c_char, src: *const c_char) -> *mut c_char;\n    pub fn strncpy(dst: *mut c_char, src: *const c_char, n: size_t) -> *mut c_char;\n    pub fn strcat(s: *mut c_char, ct: *const c_char) -> *mut c_char;\n    pub fn strncat(s: *mut c_char, ct: *const c_char, n: size_t) -> *mut c_char;\n    pub fn strcmp(cs: *const c_char, ct: *const c_char) -> c_int;\n    pub fn strncmp(cs: *const c_char, ct: *const c_char, n: size_t) -> c_int;\n    pub fn strcoll(cs: *const c_char, ct: *const c_char) -> c_int;\n    pub fn strchr(cs: *const c_char, c: c_int) -> *mut c_char;\n    pub fn strrchr(cs: *const c_char, c: c_int) -> *mut c_char;\n    pub fn strspn(cs: *const c_char, ct: *const c_char) -> size_t;\n    pub fn strcspn(cs: *const c_char, ct: *const c_char) -> size_t;\n    pub fn strdup(cs: *const c_char) -> *mut c_char;\n    pub fn strpbrk(cs: *const c_char, ct: *const c_char) -> *mut c_char;\n    pub fn strstr(cs: *const c_char, ct: *const c_char) -> *mut c_char;\n    pub fn strlen(cs: *const c_char) -> size_t;\n    pub fn strnlen(cs: *const c_char, maxlen: size_t) -> size_t;\n    pub fn strerror(n: c_int) -> *mut c_char;\n    pub fn strtok(s: *mut c_char, t: *const c_char) -> *mut c_char;\n    pub fn strxfrm(s: *mut c_char, ct: *const c_char, n: size_t) -> size_t;\n    pub fn wcslen(buf: *const wchar_t) -> size_t;\n    pub fn wcstombs(dest: *mut c_char, src: *const wchar_t, n: size_t) -> ::size_t;\n\n    pub fn memchr(cx: *const c_void, c: c_int, n: size_t) -> *mut c_void;\n    pub fn memcmp(cx: *const c_void, ct: *const c_void, n: size_t) -> c_int;\n    pub fn memcpy(dest: *mut c_void, src: *const c_void, n: size_t) -> *mut c_void;\n    pub fn memmove(dest: *mut c_void, src: *const c_void, n: size_t) -> *mut c_void;\n    pub fn memset(dest: *mut c_void, c: c_int, n: size_t) -> *mut c_void;\n\n    pub fn abs(i: c_int) -> c_int;\n    pub fn atof(s: *const c_char) -> c_double;\n    pub fn labs(i: c_long) -> c_long;\n    pub fn rand() -> c_int;\n    pub fn srand(seed: c_uint);\n\n    pub fn signal(signum: c_int, handler: sighandler_t) -> sighandler_t;\n    pub fn raise(signum: c_int) -> c_int;\n\n    #[link_name = \"_gmtime64_s\"]\n    pub fn gmtime_s(destTime: *mut tm, srcTime: *const time_t) -> ::c_int;\n    #[link_name = \"_time64\"]\n    pub fn time(destTime: *mut time_t) -> time_t;\n    #[link_name = \"_chmod\"]\n    pub fn chmod(path: *const c_char, mode: ::c_int) -> ::c_int;\n    #[link_name = \"_wchmod\"]\n    pub fn wchmod(path: *const wchar_t, mode: ::c_int) -> ::c_int;\n    #[link_name = \"_mkdir\"]\n    pub fn mkdir(path: *const c_char) -> ::c_int;\n    #[link_name = \"_wrmdir\"]\n    pub fn wrmdir(path: *const wchar_t) -> ::c_int;\n    #[link_name = \"_fstat64\"]\n    pub fn fstat(fildes: ::c_int, buf: *mut stat) -> ::c_int;\n    #[link_name = \"_stat64\"]\n    pub fn stat(path: *const c_char, buf: *mut stat) -> ::c_int;\n    #[link_name = \"_wstat64\"]\n    pub fn wstat(path: *const wchar_t, buf: *mut stat) -> ::c_int;\n    #[link_name = \"_wutime64\"]\n    pub fn wutime(file: *const wchar_t, buf: *mut utimbuf) -> ::c_int;\n    #[link_name = \"_popen\"]\n    pub fn popen(command: *const c_char, mode: *const c_char) -> *mut ::FILE;\n    #[link_name = \"_pclose\"]\n    pub fn pclose(stream: *mut ::FILE) -> ::c_int;\n    #[link_name = \"_fdopen\"]\n    pub fn fdopen(fd: ::c_int, mode: *const c_char) -> *mut ::FILE;\n    #[link_name = \"_fileno\"]\n    pub fn fileno(stream: *mut ::FILE) -> ::c_int;\n    #[link_name = \"_open\"]\n    pub fn open(path: *const c_char, oflag: ::c_int, ...) -> ::c_int;\n    #[link_name = \"_wopen\"]\n    pub fn wopen(path: *const wchar_t, oflag: ::c_int, ...) -> ::c_int;\n    #[link_name = \"_creat\"]\n    pub fn creat(path: *const c_char, mode: ::c_int) -> ::c_int;\n    #[link_name = \"_access\"]\n    pub fn access(path: *const c_char, amode: ::c_int) -> ::c_int;\n    #[link_name = \"_chdir\"]\n    pub fn chdir(dir: *const c_char) -> ::c_int;\n    #[link_name = \"_close\"]\n    pub fn close(fd: ::c_int) -> ::c_int;\n    #[link_name = \"_dup\"]\n    pub fn dup(fd: ::c_int) -> ::c_int;\n    #[link_name = \"_dup2\"]\n    pub fn dup2(src: ::c_int, dst: ::c_int) -> ::c_int;\n    #[link_name = \"_execl\"]\n    pub fn execl(path: *const c_char, arg0: *const c_char, ...) -> intptr_t;\n    #[link_name = \"_wexecl\"]\n    pub fn wexecl(path: *const wchar_t, arg0: *const wchar_t, ...) -> intptr_t;\n    #[link_name = \"_execle\"]\n    pub fn execle(path: *const c_char, arg0: *const c_char, ...) -> intptr_t;\n    #[link_name = \"_wexecle\"]\n    pub fn wexecle(path: *const wchar_t, arg0: *const wchar_t, ...) -> intptr_t;\n    #[link_name = \"_execlp\"]\n    pub fn execlp(path: *const c_char, arg0: *const c_char, ...) -> intptr_t;\n    #[link_name = \"_wexeclp\"]\n    pub fn wexeclp(path: *const wchar_t, arg0: *const wchar_t, ...) -> intptr_t;\n    #[link_name = \"_execlpe\"]\n    pub fn execlpe(path: *const c_char, arg0: *const c_char, ...) -> intptr_t;\n    #[link_name = \"_wexeclpe\"]\n    pub fn wexeclpe(path: *const wchar_t, arg0: *const wchar_t, ...) -> intptr_t;\n    #[link_name = \"_execv\"]\n    pub fn execv(prog: *const c_char, argv: *const *const c_char) -> ::intptr_t;\n    #[link_name = \"_execve\"]\n    pub fn execve(\n        prog: *const c_char,\n        argv: *const *const c_char,\n        envp: *const *const c_char,\n    ) -> ::c_int;\n    #[link_name = \"_execvp\"]\n    pub fn execvp(c: *const c_char, argv: *const *const c_char) -> ::c_int;\n    #[link_name = \"_execvpe\"]\n    pub fn execvpe(\n        c: *const c_char,\n        argv: *const *const c_char,\n        envp: *const *const c_char,\n    ) -> ::c_int;\n    #[link_name = \"_wexecv\"]\n    pub fn wexecv(prog: *const wchar_t, argv: *const *const wchar_t) -> ::intptr_t;\n    #[link_name = \"_wexecve\"]\n    pub fn wexecve(\n        prog: *const wchar_t,\n        argv: *const *const wchar_t,\n        envp: *const *const wchar_t,\n    ) -> ::intptr_t;\n    #[link_name = \"_wexecvp\"]\n    pub fn wexecvp(c: *const wchar_t, argv: *const *const wchar_t) -> ::intptr_t;\n    #[link_name = \"_wexecvpe\"]\n    pub fn wexecvpe(\n        c: *const wchar_t,\n        argv: *const *const wchar_t,\n        envp: *const *const wchar_t,\n    ) -> ::intptr_t;\n    #[link_name = \"_getcwd\"]\n    pub fn getcwd(buf: *mut c_char, size: ::c_int) -> *mut c_char;\n    #[link_name = \"_getpid\"]\n    pub fn getpid() -> ::c_int;\n    #[link_name = \"_isatty\"]\n    pub fn isatty(fd: ::c_int) -> ::c_int;\n    #[link_name = \"_lseek\"]\n    pub fn lseek(fd: ::c_int, offset: c_long, origin: ::c_int) -> c_long;\n    #[link_name = \"_lseeki64\"]\n    pub fn lseek64(fd: ::c_int, offset: c_longlong, origin: ::c_int) -> c_longlong;\n    #[link_name = \"_pipe\"]\n    pub fn pipe(fds: *mut ::c_int, psize: ::c_uint, textmode: ::c_int) -> ::c_int;\n    #[link_name = \"_read\"]\n    pub fn read(fd: ::c_int, buf: *mut ::c_void, count: ::c_uint) -> ::c_int;\n    #[link_name = \"_rmdir\"]\n    pub fn rmdir(path: *const c_char) -> ::c_int;\n    #[link_name = \"_unlink\"]\n    pub fn unlink(c: *const c_char) -> ::c_int;\n    #[link_name = \"_write\"]\n    pub fn write(fd: ::c_int, buf: *const ::c_void, count: ::c_uint) -> ::c_int;\n    #[link_name = \"_commit\"]\n    pub fn commit(fd: ::c_int) -> ::c_int;\n    #[link_name = \"_get_osfhandle\"]\n    pub fn get_osfhandle(fd: ::c_int) -> ::intptr_t;\n    #[link_name = \"_open_osfhandle\"]\n    pub fn open_osfhandle(osfhandle: ::intptr_t, flags: ::c_int) -> ::c_int;\n    pub fn setlocale(category: ::c_int, locale: *const c_char) -> *mut c_char;\n    #[link_name = \"_wsetlocale\"]\n    pub fn wsetlocale(category: ::c_int, locale: *const wchar_t) -> *mut wchar_t;\n    #[link_name = \"_aligned_malloc\"]\n    pub fn aligned_malloc(size: size_t, alignment: size_t) -> *mut c_void;\n}\n\nextern \"system\" {\n    pub fn listen(s: SOCKET, backlog: ::c_int) -> ::c_int;\n    pub fn accept(s: SOCKET, addr: *mut ::sockaddr, addrlen: *mut ::c_int) -> SOCKET;\n    pub fn bind(s: SOCKET, name: *const ::sockaddr, namelen: ::c_int) -> ::c_int;\n    pub fn connect(s: SOCKET, name: *const ::sockaddr, namelen: ::c_int) -> ::c_int;\n    pub fn getpeername(s: SOCKET, name: *mut ::sockaddr, nameln: *mut ::c_int) -> ::c_int;\n    pub fn getsockname(s: SOCKET, name: *mut ::sockaddr, nameln: *mut ::c_int) -> ::c_int;\n    pub fn getsockopt(\n        s: SOCKET,\n        level: ::c_int,\n        optname: ::c_int,\n        optval: *mut ::c_char,\n        optlen: *mut ::c_int,\n    ) -> ::c_int;\n    pub fn recvfrom(\n        s: SOCKET,\n        buf: *mut ::c_char,\n        len: ::c_int,\n        flags: ::c_int,\n        from: *mut ::sockaddr,\n        fromlen: *mut ::c_int,\n    ) -> ::c_int;\n    pub fn sendto(\n        s: SOCKET,\n        buf: *const ::c_char,\n        len: ::c_int,\n        flags: ::c_int,\n        to: *const ::sockaddr,\n        tolen: ::c_int,\n    ) -> ::c_int;\n    pub fn setsockopt(\n        s: SOCKET,\n        level: ::c_int,\n        optname: ::c_int,\n        optval: *const ::c_char,\n        optlen: ::c_int,\n    ) -> ::c_int;\n    pub fn socket(af: ::c_int, socket_type: ::c_int, protocol: ::c_int) -> SOCKET;\n}\n\ncfg_if! {\n    if #[cfg(libc_core_cvoid)] {\n        pub use ::ffi::c_void;\n    } else {\n        // Use repr(u8) as LLVM expects `void*` to be the same as `i8*` to help\n        // enable more optimization opportunities around it recognizing things\n        // like malloc/free.\n        #[repr(u8)]\n        #[allow(missing_copy_implementations)]\n        #[allow(missing_debug_implementations)]\n        pub enum c_void {\n            // Two dummy variants so the #[repr] attribute can be used.\n            #[doc(hidden)]\n            __variant1,\n            #[doc(hidden)]\n            __variant2,\n        }\n    }\n}\n\ncfg_if! {\n    if #[cfg(all(target_env = \"gnu\"))] {\n        mod gnu;\n        pub use self::gnu::*;\n    } else if #[cfg(all(target_env = \"msvc\"))] {\n        mod msvc;\n        pub use self::msvc::*;\n    } else {\n        // Unknown target_env\n    }\n}\n"],["1122","pub const L_tmpnam: ::c_uint = 260;\npub const TMP_MAX: ::c_uint = 0x7fff_ffff;\n\n// POSIX Supplement (from errno.h)\n// This particular error code is only currently available in msvc toolchain\npub const EOTHER: ::c_int = 131;\n\nextern \"C\" {\n    #[link_name = \"_stricmp\"]\n    pub fn stricmp(s1: *const ::c_char, s2: *const ::c_char) -> ::c_int;\n    #[link_name = \"_strnicmp\"]\n    pub fn strnicmp(s1: *const ::c_char, s2: *const ::c_char, n: ::size_t) -> ::c_int;\n}\n"],["1123","cfg_if! {\n    if #[cfg(target_pointer_width = \"64\")] {\n        s_no_extra_traits! {\n            #[allow(missing_debug_implementations)]\n            #[repr(align(16))]\n            pub struct max_align_t {\n                priv_: [f64; 4]\n            }\n        }\n    } else if #[cfg(target_pointer_width = \"32\")] {\n        s_no_extra_traits! {\n            #[allow(missing_debug_implementations)]\n            #[repr(align(16))]\n            pub struct max_align_t {\n                priv_: [i64; 6]\n            }\n        }\n    }\n}\n"],["1124","pub const L_tmpnam: ::c_uint = 14;\npub const TMP_MAX: ::c_uint = 0x7fff;\n\n// stdio file descriptor numbers\npub const STDIN_FILENO: ::c_int = 0;\npub const STDOUT_FILENO: ::c_int = 1;\npub const STDERR_FILENO: ::c_int = 2;\n\nextern \"C\" {\n    pub fn strcasecmp(s1: *const ::c_char, s2: *const ::c_char) -> ::c_int;\n    pub fn strncasecmp(s1: *const ::c_char, s2: *const ::c_char, n: ::size_t) -> ::c_int;\n\n    // NOTE: For MSVC target, `wmemchr` is only a inline function in `<wchar.h>`\n    //      header file. We cannot find a way to link to that symbol from Rust.\n    pub fn wmemchr(cx: *const ::wchar_t, c: ::wchar_t, n: ::size_t) -> *mut ::wchar_t;\n}\n\ncfg_if! {\n    if #[cfg(libc_align)] {\n        mod align;\n        pub use self::align::*;\n    }\n}\n"],["1125","//! Definitions found commonly among almost all Unix derivatives\n//!\n//! More functions and definitions can be found in the more specific modules\n//! according to the platform in question.\n\n// PUB_TYPE\n\npub type c_schar = i8;\npub type c_uchar = u8;\npub type c_short = i16;\npub type c_ushort = u16;\npub type c_int = i32;\npub type c_uint = u32;\npub type c_float = f32;\npub type c_double = f64;\npub type c_longlong = i64;\npub type c_ulonglong = u64;\npub type intmax_t = i64;\npub type uintmax_t = u64;\n\npub type locale_t = *mut ::c_void;\n\npub type size_t = usize;\npub type ptrdiff_t = isize;\npub type intptr_t = isize;\npub type uintptr_t = usize;\npub type ssize_t = isize;\n\npub type pid_t = i32;\npub type uid_t = u32;\npub type gid_t = u32;\npub type in_addr_t = u32;\npub type in_port_t = u16;\npub type sighandler_t = ::size_t;\npub type cc_t = ::c_uchar;\npub type sa_family_t = u16;\npub type pthread_key_t = ::c_uint;\npub type speed_t = ::c_uint;\npub type tcflag_t = ::c_uint;\npub type clockid_t = ::c_int;\npub type key_t = ::c_int;\npub type id_t = ::c_uint;\npub type useconds_t = u32;\npub type dev_t = u64;\npub type socklen_t = u32;\npub type pthread_t = c_ulong;\npub type mode_t = u32;\npub type ino64_t = u64;\npub type off64_t = i64;\npub type blkcnt64_t = i64;\npub type rlim64_t = u64;\npub type mqd_t = ::c_int;\npub type nfds_t = ::c_ulong;\npub type nl_item = ::c_int;\npub type idtype_t = ::c_uint;\npub type loff_t = ::c_longlong;\n\npub type __u8 = ::c_uchar;\npub type __u16 = ::c_ushort;\npub type __s16 = ::c_short;\npub type __u32 = ::c_uint;\npub type __s32 = ::c_int;\n\npub type Elf32_Half = u16;\npub type Elf32_Word = u32;\npub type Elf32_Off = u32;\npub type Elf32_Addr = u32;\n\npub type Elf64_Half = u16;\npub type Elf64_Word = u32;\npub type Elf64_Off = u64;\npub type Elf64_Addr = u64;\npub type Elf64_Xword = u64;\n\npub type clock_t = c_long;\npub type time_t = c_long;\npub type suseconds_t = c_long;\npub type ino_t = u64;\npub type off_t = i64;\npub type blkcnt_t = i64;\n\npub type shmatt_t = ::c_ulong;\npub type msgqnum_t = ::c_ulong;\npub type msglen_t = ::c_ulong;\npub type fsblkcnt_t = ::c_ulonglong;\npub type fsfilcnt_t = ::c_ulonglong;\npub type rlim_t = ::c_ulonglong;\n\npub type c_long = i64;\npub type c_ulong = u64;\n\n// FIXME: why are these uninhabited types? that seems... wrong?\n// Presumably these should be `()` or an `extern type` (when that stabilizes).\n#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\npub enum timezone {}\nimpl ::Copy for timezone {}\nimpl ::Clone for timezone {\n    fn clone(&self) -> timezone {\n        *self\n    }\n}\n#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\npub enum DIR {}\nimpl ::Copy for DIR {}\nimpl ::Clone for DIR {\n    fn clone(&self) -> DIR {\n        *self\n    }\n}\n\n#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\npub enum fpos64_t {} // FIXME: fill this out with a struct\nimpl ::Copy for fpos64_t {}\nimpl ::Clone for fpos64_t {\n    fn clone(&self) -> fpos64_t {\n        *self\n    }\n}\n\n// PUB_STRUCT\n\ns! {\n    pub struct group {\n        pub gr_name: *mut ::c_char,\n        pub gr_passwd: *mut ::c_char,\n        pub gr_gid: ::gid_t,\n        pub gr_mem: *mut *mut ::c_char,\n    }\n\n    pub struct utimbuf {\n        pub actime: time_t,\n        pub modtime: time_t,\n    }\n\n    pub struct timeval {\n        pub tv_sec: time_t,\n        pub tv_usec: suseconds_t,\n    }\n\n    pub struct timespec {\n        pub tv_sec: time_t,\n        pub tv_nsec: ::c_long,\n    }\n\n    // FIXME: the rlimit and rusage related functions and types don't exist\n    // within zircon. Are there reasons for keeping them around?\n    pub struct rlimit {\n        pub rlim_cur: rlim_t,\n        pub rlim_max: rlim_t,\n    }\n\n    pub struct rusage {\n        pub ru_utime: timeval,\n        pub ru_stime: timeval,\n        pub ru_maxrss: c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        __pad1: u32,\n        pub ru_ixrss: c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        __pad2: u32,\n        pub ru_idrss: c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        __pad3: u32,\n        pub ru_isrss: c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        __pad4: u32,\n        pub ru_minflt: c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        __pad5: u32,\n        pub ru_majflt: c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        __pad6: u32,\n        pub ru_nswap: c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        __pad7: u32,\n        pub ru_inblock: c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        __pad8: u32,\n        pub ru_oublock: c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        __pad9: u32,\n        pub ru_msgsnd: c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        __pad10: u32,\n        pub ru_msgrcv: c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        __pad11: u32,\n        pub ru_nsignals: c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        __pad12: u32,\n        pub ru_nvcsw: c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        __pad13: u32,\n        pub ru_nivcsw: c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        __pad14: u32,\n    }\n\n    pub struct in_addr {\n        pub s_addr: in_addr_t,\n    }\n\n    pub struct in6_addr {\n        pub s6_addr: [u8; 16],\n    }\n\n    pub struct ip_mreq {\n        pub imr_multiaddr: in_addr,\n        pub imr_interface: in_addr,\n    }\n\n    pub struct ip_mreqn {\n        pub imr_multiaddr: in_addr,\n        pub imr_address: in_addr,\n        pub imr_ifindex: ::c_int,\n    }\n\n    pub struct ipv6_mreq {\n        pub ipv6mr_multiaddr: in6_addr,\n        pub ipv6mr_interface: ::c_uint,\n    }\n\n    pub struct hostent {\n        pub h_name: *mut ::c_char,\n        pub h_aliases: *mut *mut ::c_char,\n        pub h_addrtype: ::c_int,\n        pub h_length: ::c_int,\n        pub h_addr_list: *mut *mut ::c_char,\n    }\n\n    pub struct iovec {\n        pub iov_base: *mut ::c_void,\n        pub iov_len: ::size_t,\n    }\n\n    pub struct pollfd {\n        pub fd: ::c_int,\n        pub events: ::c_short,\n        pub revents: ::c_short,\n    }\n\n    pub struct winsize {\n        pub ws_row: ::c_ushort,\n        pub ws_col: ::c_ushort,\n        pub ws_xpixel: ::c_ushort,\n        pub ws_ypixel: ::c_ushort,\n    }\n\n    pub struct linger {\n        pub l_onoff: ::c_int,\n        pub l_linger: ::c_int,\n    }\n\n    pub struct sigval {\n        // Actually a union of an int and a void*\n        pub sival_ptr: *mut ::c_void\n    }\n\n    // <sys/time.h>\n    pub struct itimerval {\n        pub it_interval: ::timeval,\n        pub it_value: ::timeval,\n    }\n\n    // <sys/times.h>\n    pub struct tms {\n        pub tms_utime: ::clock_t,\n        pub tms_stime: ::clock_t,\n        pub tms_cutime: ::clock_t,\n        pub tms_cstime: ::clock_t,\n    }\n\n    pub struct servent {\n        pub s_name: *mut ::c_char,\n        pub s_aliases: *mut *mut ::c_char,\n        pub s_port: ::c_int,\n        pub s_proto: *mut ::c_char,\n    }\n\n    pub struct protoent {\n        pub p_name: *mut ::c_char,\n        pub p_aliases: *mut *mut ::c_char,\n        pub p_proto: ::c_int,\n    }\n\n    pub struct aiocb {\n        pub aio_fildes: ::c_int,\n        pub aio_lio_opcode: ::c_int,\n        pub aio_reqprio: ::c_int,\n        pub aio_buf: *mut ::c_void,\n        pub aio_nbytes: ::size_t,\n        pub aio_sigevent: ::sigevent,\n        __td: *mut ::c_void,\n        __lock: [::c_int; 2],\n        __err: ::c_int,\n        __ret: ::ssize_t,\n        pub aio_offset: off_t,\n        __next: *mut ::c_void,\n        __prev: *mut ::c_void,\n        #[cfg(target_pointer_width = \"32\")]\n        __dummy4: [::c_char; 24],\n        #[cfg(target_pointer_width = \"64\")]\n        __dummy4: [::c_char; 16],\n    }\n\n    pub struct sigaction {\n        pub sa_sigaction: ::sighandler_t,\n        pub sa_mask: ::sigset_t,\n        pub sa_flags: ::c_int,\n        pub sa_restorer: ::Option<extern fn()>,\n    }\n\n    pub struct termios {\n        pub c_iflag: ::tcflag_t,\n        pub c_oflag: ::tcflag_t,\n        pub c_cflag: ::tcflag_t,\n        pub c_lflag: ::tcflag_t,\n        pub c_line: ::cc_t,\n        pub c_cc: [::cc_t; ::NCCS],\n        pub __c_ispeed: ::speed_t,\n        pub __c_ospeed: ::speed_t,\n    }\n\n    pub struct flock {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off_t,\n        pub l_len: ::off_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct ucred {\n        pub pid: ::pid_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n    }\n\n    pub struct sockaddr {\n        pub sa_family: sa_family_t,\n        pub sa_data: [::c_char; 14],\n    }\n\n    pub struct sockaddr_in {\n        pub sin_family: sa_family_t,\n        pub sin_port: ::in_port_t,\n        pub sin_addr: ::in_addr,\n        pub sin_zero: [u8; 8],\n    }\n\n    pub struct sockaddr_in6 {\n        pub sin6_family: sa_family_t,\n        pub sin6_port: ::in_port_t,\n        pub sin6_flowinfo: u32,\n        pub sin6_addr: ::in6_addr,\n        pub sin6_scope_id: u32,\n    }\n\n    pub struct addrinfo {\n        pub ai_flags: ::c_int,\n        pub ai_family: ::c_int,\n        pub ai_socktype: ::c_int,\n        pub ai_protocol: ::c_int,\n        pub ai_addrlen: socklen_t,\n\n        pub ai_addr: *mut ::sockaddr,\n\n        pub ai_canonname: *mut c_char,\n\n        pub ai_next: *mut addrinfo,\n    }\n\n    pub struct sockaddr_ll {\n        pub sll_family: ::c_ushort,\n        pub sll_protocol: ::c_ushort,\n        pub sll_ifindex: ::c_int,\n        pub sll_hatype: ::c_ushort,\n        pub sll_pkttype: ::c_uchar,\n        pub sll_halen: ::c_uchar,\n        pub sll_addr: [::c_uchar; 8]\n    }\n\n    pub struct fd_set {\n        fds_bits: [::c_ulong; FD_SETSIZE / ULONG_SIZE],\n    }\n\n    pub struct tm {\n        pub tm_sec: ::c_int,\n        pub tm_min: ::c_int,\n        pub tm_hour: ::c_int,\n        pub tm_mday: ::c_int,\n        pub tm_mon: ::c_int,\n        pub tm_year: ::c_int,\n        pub tm_wday: ::c_int,\n        pub tm_yday: ::c_int,\n        pub tm_isdst: ::c_int,\n        pub tm_gmtoff: ::c_long,\n        pub tm_zone: *const ::c_char,\n    }\n\n    pub struct sched_param {\n        pub sched_priority: ::c_int,\n        pub sched_ss_low_priority: ::c_int,\n        pub sched_ss_repl_period: ::timespec,\n        pub sched_ss_init_budget: ::timespec,\n        pub sched_ss_max_repl: ::c_int,\n    }\n\n    pub struct Dl_info {\n        pub dli_fname: *const ::c_char,\n        pub dli_fbase: *mut ::c_void,\n        pub dli_sname: *const ::c_char,\n        pub dli_saddr: *mut ::c_void,\n    }\n\n    pub struct epoll_event {\n        pub events: u32,\n        pub u64: u64,\n    }\n\n    pub struct lconv {\n        pub decimal_point: *mut ::c_char,\n        pub thousands_sep: *mut ::c_char,\n        pub grouping: *mut ::c_char,\n        pub int_curr_symbol: *mut ::c_char,\n        pub currency_symbol: *mut ::c_char,\n        pub mon_decimal_point: *mut ::c_char,\n        pub mon_thousands_sep: *mut ::c_char,\n        pub mon_grouping: *mut ::c_char,\n        pub positive_sign: *mut ::c_char,\n        pub negative_sign: *mut ::c_char,\n        pub int_frac_digits: ::c_char,\n        pub frac_digits: ::c_char,\n        pub p_cs_precedes: ::c_char,\n        pub p_sep_by_space: ::c_char,\n        pub n_cs_precedes: ::c_char,\n        pub n_sep_by_space: ::c_char,\n        pub p_sign_posn: ::c_char,\n        pub n_sign_posn: ::c_char,\n        pub int_p_cs_precedes: ::c_char,\n        pub int_p_sep_by_space: ::c_char,\n        pub int_n_cs_precedes: ::c_char,\n        pub int_n_sep_by_space: ::c_char,\n        pub int_p_sign_posn: ::c_char,\n        pub int_n_sign_posn: ::c_char,\n    }\n\n    pub struct rlimit64 {\n        pub rlim_cur: rlim64_t,\n        pub rlim_max: rlim64_t,\n    }\n\n    pub struct glob_t {\n        pub gl_pathc: ::size_t,\n        pub gl_pathv: *mut *mut c_char,\n        pub gl_offs: ::size_t,\n        pub gl_flags: ::c_int,\n\n        __unused1: *mut ::c_void,\n        __unused2: *mut ::c_void,\n        __unused3: *mut ::c_void,\n        __unused4: *mut ::c_void,\n        __unused5: *mut ::c_void,\n    }\n\n    pub struct ifaddrs {\n        pub ifa_next: *mut ifaddrs,\n        pub ifa_name: *mut c_char,\n        pub ifa_flags: ::c_uint,\n        pub ifa_addr: *mut ::sockaddr,\n        pub ifa_netmask: *mut ::sockaddr,\n        pub ifa_ifu: *mut ::sockaddr, // FIXME This should be a union\n        pub ifa_data: *mut ::c_void\n    }\n\n    pub struct passwd {\n        pub pw_name: *mut ::c_char,\n        pub pw_passwd: *mut ::c_char,\n        pub pw_uid: ::uid_t,\n        pub pw_gid: ::gid_t,\n        pub pw_gecos: *mut ::c_char,\n        pub pw_dir: *mut ::c_char,\n        pub pw_shell: *mut ::c_char,\n    }\n\n    pub struct spwd {\n        pub sp_namp: *mut ::c_char,\n        pub sp_pwdp: *mut ::c_char,\n        pub sp_lstchg: ::c_long,\n        pub sp_min: ::c_long,\n        pub sp_max: ::c_long,\n        pub sp_warn: ::c_long,\n        pub sp_inact: ::c_long,\n        pub sp_expire: ::c_long,\n        pub sp_flag: ::c_ulong,\n    }\n\n    pub struct statvfs {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_favail: ::fsfilcnt_t,\n        #[cfg(target_endian = \"little\")]\n        pub f_fsid: ::c_ulong,\n        #[cfg(all(target_pointer_width = \"32\", not(target_arch = \"x86_64\")))]\n        __f_unused: ::c_int,\n        #[cfg(target_endian = \"big\")]\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct dqblk {\n        pub dqb_bhardlimit: u64,\n        pub dqb_bsoftlimit: u64,\n        pub dqb_curspace: u64,\n        pub dqb_ihardlimit: u64,\n        pub dqb_isoftlimit: u64,\n        pub dqb_curinodes: u64,\n        pub dqb_btime: u64,\n        pub dqb_itime: u64,\n        pub dqb_valid: u32,\n    }\n\n    pub struct signalfd_siginfo {\n        pub ssi_signo: u32,\n        pub ssi_errno: i32,\n        pub ssi_code: i32,\n        pub ssi_pid: u32,\n        pub ssi_uid: u32,\n        pub ssi_fd: i32,\n        pub ssi_tid: u32,\n        pub ssi_band: u32,\n        pub ssi_overrun: u32,\n        pub ssi_trapno: u32,\n        pub ssi_status: i32,\n        pub ssi_int: i32,\n        pub ssi_ptr: u64,\n        pub ssi_utime: u64,\n        pub ssi_stime: u64,\n        pub ssi_addr: u64,\n        pub ssi_addr_lsb: u16,\n        _pad2: u16,\n        pub ssi_syscall: i32,\n        pub ssi_call_addr: u64,\n        pub ssi_arch: u32,\n        _pad: [u8; 28],\n    }\n\n    pub struct itimerspec {\n        pub it_interval: ::timespec,\n        pub it_value: ::timespec,\n    }\n\n    pub struct fsid_t {\n        __val: [::c_int; 2],\n    }\n\n    pub struct cpu_set_t {\n        #[cfg(all(target_pointer_width = \"32\",\n                  not(target_arch = \"x86_64\")))]\n        bits: [u32; 32],\n        #[cfg(not(all(target_pointer_width = \"32\",\n                      not(target_arch = \"x86_64\"))))]\n        bits: [u64; 16],\n    }\n\n    pub struct if_nameindex {\n        pub if_index: ::c_uint,\n        pub if_name: *mut ::c_char,\n    }\n\n    // System V IPC\n    pub struct msginfo {\n        pub msgpool: ::c_int,\n        pub msgmap: ::c_int,\n        pub msgmax: ::c_int,\n        pub msgmnb: ::c_int,\n        pub msgmni: ::c_int,\n        pub msgssz: ::c_int,\n        pub msgtql: ::c_int,\n        pub msgseg: ::c_ushort,\n    }\n\n    pub struct mmsghdr {\n        pub msg_hdr: ::msghdr,\n        pub msg_len: ::c_uint,\n    }\n\n    pub struct sembuf {\n        pub sem_num: ::c_ushort,\n        pub sem_op: ::c_short,\n        pub sem_flg: ::c_short,\n    }\n\n    pub struct input_event {\n        pub time: ::timeval,\n        pub type_: ::__u16,\n        pub code: ::__u16,\n        pub value: ::__s32,\n    }\n\n    pub struct input_id {\n        pub bustype: ::__u16,\n        pub vendor: ::__u16,\n        pub product: ::__u16,\n        pub version: ::__u16,\n    }\n\n    pub struct input_absinfo {\n        pub value: ::__s32,\n        pub minimum: ::__s32,\n        pub maximum: ::__s32,\n        pub fuzz: ::__s32,\n        pub flat: ::__s32,\n        pub resolution: ::__s32,\n    }\n\n    pub struct input_keymap_entry {\n        pub flags: ::__u8,\n        pub len: ::__u8,\n        pub index: ::__u16,\n        pub keycode: ::__u32,\n        pub scancode: [::__u8; 32],\n    }\n\n    pub struct input_mask {\n        pub type_: ::__u32,\n        pub codes_size: ::__u32,\n        pub codes_ptr: ::__u64,\n    }\n\n    pub struct ff_replay {\n        pub length: ::__u16,\n        pub delay: ::__u16,\n    }\n\n    pub struct ff_trigger {\n        pub button: ::__u16,\n        pub interval: ::__u16,\n    }\n\n    pub struct ff_envelope {\n        pub attack_length: ::__u16,\n        pub attack_level: ::__u16,\n        pub fade_length: ::__u16,\n        pub fade_level: ::__u16,\n    }\n\n    pub struct ff_constant_effect {\n        pub level: ::__s16,\n        pub envelope: ff_envelope,\n    }\n\n    pub struct ff_ramp_effect {\n        pub start_level: ::__s16,\n        pub end_level: ::__s16,\n        pub envelope: ff_envelope,\n    }\n\n    pub struct ff_condition_effect {\n        pub right_saturation: ::__u16,\n        pub left_saturation: ::__u16,\n\n        pub right_coeff: ::__s16,\n        pub left_coeff: ::__s16,\n\n        pub deadband: ::__u16,\n        pub center: ::__s16,\n    }\n\n    pub struct ff_periodic_effect {\n        pub waveform: ::__u16,\n        pub period: ::__u16,\n        pub magnitude: ::__s16,\n        pub offset: ::__s16,\n        pub phase: ::__u16,\n\n        pub envelope: ff_envelope,\n\n        pub custom_len: ::__u32,\n        pub custom_data: *mut ::__s16,\n    }\n\n    pub struct ff_rumble_effect {\n        pub strong_magnitude: ::__u16,\n        pub weak_magnitude: ::__u16,\n    }\n\n    pub struct ff_effect {\n        pub type_: ::__u16,\n        pub id: ::__s16,\n        pub direction: ::__u16,\n        pub trigger: ff_trigger,\n        pub replay: ff_replay,\n        // FIXME this is actually a union\n        #[cfg(target_pointer_width = \"64\")]\n        pub u: [u64; 4],\n        #[cfg(target_pointer_width = \"32\")]\n        pub u: [u32; 7],\n    }\n\n    pub struct dl_phdr_info {\n        #[cfg(target_pointer_width = \"64\")]\n        pub dlpi_addr: Elf64_Addr,\n        #[cfg(target_pointer_width = \"32\")]\n        pub dlpi_addr: Elf32_Addr,\n\n        pub dlpi_name: *const ::c_char,\n\n        #[cfg(target_pointer_width = \"64\")]\n        pub dlpi_phdr: *const Elf64_Phdr,\n        #[cfg(target_pointer_width = \"32\")]\n        pub dlpi_phdr: *const Elf32_Phdr,\n\n        #[cfg(target_pointer_width = \"64\")]\n        pub dlpi_phnum: Elf64_Half,\n        #[cfg(target_pointer_width = \"32\")]\n        pub dlpi_phnum: Elf32_Half,\n\n        pub dlpi_adds: ::c_ulonglong,\n        pub dlpi_subs: ::c_ulonglong,\n        pub dlpi_tls_modid: ::size_t,\n        pub dlpi_tls_data: *mut ::c_void,\n    }\n\n    pub struct Elf32_Phdr {\n        pub p_type: Elf32_Word,\n        pub p_offset: Elf32_Off,\n        pub p_vaddr: Elf32_Addr,\n        pub p_paddr: Elf32_Addr,\n        pub p_filesz: Elf32_Word,\n        pub p_memsz: Elf32_Word,\n        pub p_flags: Elf32_Word,\n        pub p_align: Elf32_Word,\n    }\n\n    pub struct Elf64_Phdr {\n        pub p_type: Elf64_Word,\n        pub p_flags: Elf64_Word,\n        pub p_offset: Elf64_Off,\n        pub p_vaddr: Elf64_Addr,\n        pub p_paddr: Elf64_Addr,\n        pub p_filesz: Elf64_Xword,\n        pub p_memsz: Elf64_Xword,\n        pub p_align: Elf64_Xword,\n    }\n\n    pub struct statfs64 {\n        pub f_type: ::c_ulong,\n        pub f_bsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_flags: ::c_ulong,\n        pub f_spare: [::c_ulong; 4],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_favail: u64,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_flags: ::c_int,\n        pub ss_size: ::size_t\n    }\n\n    pub struct pthread_attr_t {\n        __size: [u64; 7]\n    }\n\n    pub struct sigset_t {\n        __val: [::c_ulong; 16],\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        pub shm_segsz: ::size_t,\n        pub shm_atime: ::time_t,\n        pub shm_dtime: ::time_t,\n        pub shm_ctime: ::time_t,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::c_ulong,\n        __pad1: ::c_ulong,\n        __pad2: ::c_ulong,\n    }\n\n    pub struct msqid_ds {\n        pub msg_perm: ::ipc_perm,\n        pub msg_stime: ::time_t,\n        pub msg_rtime: ::time_t,\n        pub msg_ctime: ::time_t,\n        __msg_cbytes: ::c_ulong,\n        pub msg_qnum: ::msgqnum_t,\n        pub msg_qbytes: ::msglen_t,\n        pub msg_lspid: ::pid_t,\n        pub msg_lrpid: ::pid_t,\n        __pad1: ::c_ulong,\n        __pad2: ::c_ulong,\n    }\n\n    pub struct statfs {\n        pub f_type: ::c_ulong,\n        pub f_bsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_flags: ::c_ulong,\n        pub f_spare: [::c_ulong; 4],\n    }\n\n    pub struct msghdr {\n        pub msg_name: *mut ::c_void,\n        pub msg_namelen: ::socklen_t,\n        pub msg_iov: *mut ::iovec,\n        pub msg_iovlen: ::c_int,\n        __pad1: ::c_int,\n        pub msg_control: *mut ::c_void,\n        pub msg_controllen: ::socklen_t,\n        __pad2: ::socklen_t,\n        pub msg_flags: ::c_int,\n    }\n\n    pub struct cmsghdr {\n        pub cmsg_len: ::socklen_t,\n        pub __pad1: ::c_int,\n        pub cmsg_level: ::c_int,\n        pub cmsg_type: ::c_int,\n    }\n\n    pub struct sem_t {\n        __val: [::c_int; 8],\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_errno: ::c_int,\n        pub si_code: ::c_int,\n        pub _pad: [::c_int; 29],\n        _align: [usize; 0],\n    }\n\n    pub struct termios2 {\n        pub c_iflag: ::tcflag_t,\n        pub c_oflag: ::tcflag_t,\n        pub c_cflag: ::tcflag_t,\n        pub c_lflag: ::tcflag_t,\n        pub c_line: ::cc_t,\n        pub c_cc: [::cc_t; 19],\n        pub c_ispeed: ::speed_t,\n        pub c_ospeed: ::speed_t,\n    }\n}\n\ns_no_extra_traits! {\n    pub struct sysinfo {\n        pub uptime: ::c_ulong,\n        pub loads: [::c_ulong; 3],\n        pub totalram: ::c_ulong,\n        pub freeram: ::c_ulong,\n        pub sharedram: ::c_ulong,\n        pub bufferram: ::c_ulong,\n        pub totalswap: ::c_ulong,\n        pub freeswap: ::c_ulong,\n        pub procs: ::c_ushort,\n        pub pad: ::c_ushort,\n        pub totalhigh: ::c_ulong,\n        pub freehigh: ::c_ulong,\n        pub mem_unit: ::c_uint,\n        pub __reserved: [::c_char; 256],\n    }\n\n    pub struct sockaddr_un {\n        pub sun_family: sa_family_t,\n        pub sun_path: [::c_char; 108]\n    }\n\n    pub struct sockaddr_storage {\n        pub ss_family: sa_family_t,\n        __ss_align: ::size_t,\n        __ss_pad2: [u8; 128 - 2 * 8],\n    }\n\n    pub struct utsname {\n        pub sysname: [::c_char; 65],\n        pub nodename: [::c_char; 65],\n        pub release: [::c_char; 65],\n        pub version: [::c_char; 65],\n        pub machine: [::c_char; 65],\n        pub domainname: [::c_char; 65]\n    }\n\n    pub struct dirent {\n        pub d_ino: ::ino_t,\n        pub d_off: ::off_t,\n        pub d_reclen: ::c_ushort,\n        pub d_type: ::c_uchar,\n        pub d_name: [::c_char; 256],\n    }\n\n    pub struct dirent64 {\n        pub d_ino: ::ino64_t,\n        pub d_off: ::off64_t,\n        pub d_reclen: ::c_ushort,\n        pub d_type: ::c_uchar,\n        pub d_name: [::c_char; 256],\n    }\n\n    // x32 compatibility\n    // See https://sourceware.org/bugzilla/show_bug.cgi?id=21279\n    pub struct mq_attr {\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        pub mq_flags: i64,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        pub mq_maxmsg: i64,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        pub mq_msgsize: i64,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        pub mq_curmsgs: i64,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        pad: [i64; 4],\n\n        #[cfg(not(all(target_arch = \"x86_64\", target_pointer_width = \"32\")))]\n        pub mq_flags: ::c_long,\n        #[cfg(not(all(target_arch = \"x86_64\", target_pointer_width = \"32\")))]\n        pub mq_maxmsg: ::c_long,\n        #[cfg(not(all(target_arch = \"x86_64\", target_pointer_width = \"32\")))]\n        pub mq_msgsize: ::c_long,\n        #[cfg(not(all(target_arch = \"x86_64\", target_pointer_width = \"32\")))]\n        pub mq_curmsgs: ::c_long,\n        #[cfg(not(all(target_arch = \"x86_64\", target_pointer_width = \"32\")))]\n        pad: [::c_long; 4],\n    }\n\n    pub struct sockaddr_nl {\n        pub nl_family: ::sa_family_t,\n        nl_pad: ::c_ushort,\n        pub nl_pid: u32,\n        pub nl_groups: u32\n    }\n\n    pub struct sigevent {\n        pub sigev_value: ::sigval,\n        pub sigev_signo: ::c_int,\n        pub sigev_notify: ::c_int,\n        pub sigev_notify_function: fn(::sigval),\n        pub sigev_notify_attributes: *mut pthread_attr_t,\n        pub __pad: [::c_char; 56 - 3 * 8 /* 8 == sizeof(long) */],\n    }\n}\n\ncfg_if! {\n    if #[cfg(feature = \"extra_traits\")] {\n        impl PartialEq for sysinfo {\n            fn eq(&self, other: &sysinfo) -> bool {\n                self.uptime == other.uptime\n                    && self.loads == other.loads\n                    && self.totalram == other.totalram\n                    && self.freeram == other.freeram\n                    && self.sharedram == other.sharedram\n                    && self.bufferram == other.bufferram\n                    && self.totalswap == other.totalswap\n                    && self.freeswap == other.freeswap\n                    && self.procs == other.procs\n                    && self.pad == other.pad\n                    && self.totalhigh == other.totalhigh\n                    && self.freehigh == other.freehigh\n                    && self.mem_unit == other.mem_unit\n                    && self\n                        .__reserved\n                        .iter()\n                        .zip(other.__reserved.iter())\n                        .all(|(a,b)| a == b)\n            }\n        }\n        impl Eq for sysinfo {}\n        impl ::fmt::Debug for sysinfo {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"sysinfo\")\n                    .field(\"uptime\", &self.uptime)\n                    .field(\"loads\", &self.loads)\n                    .field(\"totalram\", &self.totalram)\n                    .field(\"freeram\", &self.freeram)\n                    .field(\"sharedram\", &self.sharedram)\n                    .field(\"bufferram\", &self.bufferram)\n                    .field(\"totalswap\", &self.totalswap)\n                    .field(\"freeswap\", &self.freeswap)\n                    .field(\"procs\", &self.procs)\n                    .field(\"pad\", &self.pad)\n                    .field(\"totalhigh\", &self.totalhigh)\n                    .field(\"freehigh\", &self.freehigh)\n                    .field(\"mem_unit\", &self.mem_unit)\n                    // FIXME: .field(\"__reserved\", &self.__reserved)\n                    .finish()\n            }\n        }\n        impl ::hash::Hash for sysinfo {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.uptime.hash(state);\n                self.loads.hash(state);\n                self.totalram.hash(state);\n                self.freeram.hash(state);\n                self.sharedram.hash(state);\n                self.bufferram.hash(state);\n                self.totalswap.hash(state);\n                self.freeswap.hash(state);\n                self.procs.hash(state);\n                self.pad.hash(state);\n                self.totalhigh.hash(state);\n                self.freehigh.hash(state);\n                self.mem_unit.hash(state);\n                self.__reserved.hash(state);\n            }\n        }\n\n        impl PartialEq for sockaddr_un {\n            fn eq(&self, other: &sockaddr_un) -> bool {\n                self.sun_family == other.sun_family\n                    && self\n                    .sun_path\n                    .iter()\n                    .zip(other.sun_path.iter())\n                    .all(|(a,b)| a == b)\n            }\n        }\n        impl Eq for sockaddr_un {}\n        impl ::fmt::Debug for sockaddr_un {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"sockaddr_un\")\n                    .field(\"sun_family\", &self.sun_family)\n                    // FIXME: .field(\"sun_path\", &self.sun_path)\n                    .finish()\n            }\n        }\n        impl ::hash::Hash for sockaddr_un {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.sun_family.hash(state);\n                self.sun_path.hash(state);\n            }\n        }\n\n        impl PartialEq for sockaddr_storage {\n            fn eq(&self, other: &sockaddr_storage) -> bool {\n                self.ss_family == other.ss_family\n                    && self.__ss_align == other.__ss_align\n                    && self\n                    .__ss_pad2\n                    .iter()\n                    .zip(other.__ss_pad2.iter())\n                    .all(|(a, b)| a == b)\n            }\n        }\n        impl Eq for sockaddr_storage {}\n        impl ::fmt::Debug for sockaddr_storage {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"sockaddr_storage\")\n                    .field(\"ss_family\", &self.ss_family)\n                    .field(\"__ss_align\", &self.__ss_align)\n                    // FIXME: .field(\"__ss_pad2\", &self.__ss_pad2)\n                    .finish()\n            }\n        }\n        impl ::hash::Hash for sockaddr_storage {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.ss_family.hash(state);\n                self.__ss_align.hash(state);\n                self.__ss_pad2.hash(state);\n            }\n        }\n\n        impl PartialEq for utsname {\n            fn eq(&self, other: &utsname) -> bool {\n                self.sysname\n                    .iter()\n                    .zip(other.sysname.iter())\n                    .all(|(a,b)| a == b)\n                    && self\n                    .nodename\n                    .iter()\n                    .zip(other.nodename.iter())\n                    .all(|(a,b)| a == b)\n                    && self\n                    .release\n                    .iter()\n                    .zip(other.release.iter())\n                    .all(|(a,b)| a == b)\n                    && self\n                    .version\n                    .iter()\n                    .zip(other.version.iter())\n                    .all(|(a,b)| a == b)\n                    && self\n                    .machine\n                    .iter()\n                    .zip(other.machine.iter())\n                    .all(|(a,b)| a == b)\n            }\n        }\n        impl Eq for utsname {}\n        impl ::fmt::Debug for utsname {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"utsname\")\n                    // FIXME: .field(\"sysname\", &self.sysname)\n                    // FIXME: .field(\"nodename\", &self.nodename)\n                    // FIXME: .field(\"release\", &self.release)\n                    // FIXME: .field(\"version\", &self.version)\n                    // FIXME: .field(\"machine\", &self.machine)\n                    .finish()\n            }\n        }\n        impl ::hash::Hash for utsname {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.sysname.hash(state);\n                self.nodename.hash(state);\n                self.release.hash(state);\n                self.version.hash(state);\n                self.machine.hash(state);\n            }\n        }\n\n        impl PartialEq for dirent {\n            fn eq(&self, other: &dirent) -> bool {\n                self.d_ino == other.d_ino\n                    && self.d_off == other.d_off\n                    && self.d_reclen == other.d_reclen\n                    && self.d_type == other.d_type\n                    && self\n                    .d_name\n                    .iter()\n                    .zip(other.d_name.iter())\n                    .all(|(a,b)| a == b)\n            }\n        }\n        impl Eq for dirent {}\n        impl ::fmt::Debug for dirent {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"dirent\")\n                    .field(\"d_ino\", &self.d_ino)\n                    .field(\"d_off\", &self.d_off)\n                    .field(\"d_reclen\", &self.d_reclen)\n                    .field(\"d_type\", &self.d_type)\n                    // FIXME: .field(\"d_name\", &self.d_name)\n                    .finish()\n            }\n        }\n        impl ::hash::Hash for dirent {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.d_ino.hash(state);\n                self.d_off.hash(state);\n                self.d_reclen.hash(state);\n                self.d_type.hash(state);\n                self.d_name.hash(state);\n            }\n        }\n\n        impl PartialEq for dirent64 {\n            fn eq(&self, other: &dirent64) -> bool {\n                self.d_ino == other.d_ino\n                    && self.d_off == other.d_off\n                    && self.d_reclen == other.d_reclen\n                    && self.d_type == other.d_type\n                    && self\n                    .d_name\n                    .iter()\n                    .zip(other.d_name.iter())\n                    .all(|(a,b)| a == b)\n            }\n        }\n        impl Eq for dirent64 {}\n        impl ::fmt::Debug for dirent64 {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"dirent64\")\n                    .field(\"d_ino\", &self.d_ino)\n                    .field(\"d_off\", &self.d_off)\n                    .field(\"d_reclen\", &self.d_reclen)\n                    .field(\"d_type\", &self.d_type)\n                    // FIXME: .field(\"d_name\", &self.d_name)\n                    .finish()\n            }\n        }\n        impl ::hash::Hash for dirent64 {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.d_ino.hash(state);\n                self.d_off.hash(state);\n                self.d_reclen.hash(state);\n                self.d_type.hash(state);\n                self.d_name.hash(state);\n            }\n        }\n\n        impl PartialEq for mq_attr {\n            fn eq(&self, other: &mq_attr) -> bool {\n                self.mq_flags == other.mq_flags &&\n                self.mq_maxmsg == other.mq_maxmsg &&\n                self.mq_msgsize == other.mq_msgsize &&\n                self.mq_curmsgs == other.mq_curmsgs\n            }\n        }\n        impl Eq for mq_attr {}\n        impl ::fmt::Debug for mq_attr {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"mq_attr\")\n                    .field(\"mq_flags\", &self.mq_flags)\n                    .field(\"mq_maxmsg\", &self.mq_maxmsg)\n                    .field(\"mq_msgsize\", &self.mq_msgsize)\n                    .field(\"mq_curmsgs\", &self.mq_curmsgs)\n                    .finish()\n            }\n        }\n        impl ::hash::Hash for mq_attr {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.mq_flags.hash(state);\n                self.mq_maxmsg.hash(state);\n                self.mq_msgsize.hash(state);\n                self.mq_curmsgs.hash(state);\n            }\n        }\n\n        impl PartialEq for sockaddr_nl {\n            fn eq(&self, other: &sockaddr_nl) -> bool {\n                self.nl_family == other.nl_family &&\n                self.nl_pid == other.nl_pid &&\n                self.nl_groups == other.nl_groups\n            }\n        }\n        impl Eq for sockaddr_nl {}\n        impl ::fmt::Debug for sockaddr_nl {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"sockaddr_nl\")\n                    .field(\"nl_family\", &self.nl_family)\n                    .field(\"nl_pid\", &self.nl_pid)\n                    .field(\"nl_groups\", &self.nl_groups)\n                    .finish()\n            }\n        }\n        impl ::hash::Hash for sockaddr_nl {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.nl_family.hash(state);\n                self.nl_pid.hash(state);\n                self.nl_groups.hash(state);\n            }\n        }\n\n        impl PartialEq for sigevent {\n            fn eq(&self, other: &sigevent) -> bool {\n                self.sigev_value == other.sigev_value\n                    && self.sigev_signo == other.sigev_signo\n                    && self.sigev_notify == other.sigev_notify\n                    && self.sigev_notify_function\n                        == other.sigev_notify_function\n                    && self.sigev_notify_attributes\n                        == other.sigev_notify_attributes\n            }\n        }\n        impl Eq for sigevent {}\n        impl ::fmt::Debug for sigevent {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"sigevent\")\n                    .field(\"sigev_value\", &self.sigev_value)\n                    .field(\"sigev_signo\", &self.sigev_signo)\n                    .field(\"sigev_notify\", &self.sigev_notify)\n                    .field(\"sigev_notify_function\", &self.sigev_notify_function)\n                    .field(\"sigev_notify_attributes\",\n                           &self.sigev_notify_attributes)\n                    .finish()\n            }\n        }\n        impl ::hash::Hash for sigevent {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.sigev_value.hash(state);\n                self.sigev_signo.hash(state);\n                self.sigev_notify.hash(state);\n                self.sigev_notify_function.hash(state);\n                self.sigev_notify_attributes.hash(state);\n            }\n        }\n    }\n}\n\n// PUB_CONST\n\npub const INT_MIN: c_int = -2147483648;\npub const INT_MAX: c_int = 2147483647;\n\npub const SIG_DFL: sighandler_t = 0 as sighandler_t;\npub const SIG_IGN: sighandler_t = 1 as sighandler_t;\npub const SIG_ERR: sighandler_t = !0 as sighandler_t;\n\npub const DT_FIFO: u8 = 1;\npub const DT_CHR: u8 = 2;\npub const DT_DIR: u8 = 4;\npub const DT_BLK: u8 = 6;\npub const DT_REG: u8 = 8;\npub const DT_LNK: u8 = 10;\npub const DT_SOCK: u8 = 12;\n\npub const FD_CLOEXEC: ::c_int = 0x1;\n\npub const USRQUOTA: ::c_int = 0;\npub const GRPQUOTA: ::c_int = 1;\n\npub const SIGIOT: ::c_int = 6;\n\npub const S_ISUID: ::c_int = 0x800;\npub const S_ISGID: ::c_int = 0x400;\npub const S_ISVTX: ::c_int = 0x200;\n\npub const IF_NAMESIZE: ::size_t = 16;\npub const IFNAMSIZ: ::size_t = IF_NAMESIZE;\n\npub const LOG_EMERG: ::c_int = 0;\npub const LOG_ALERT: ::c_int = 1;\npub const LOG_CRIT: ::c_int = 2;\npub const LOG_ERR: ::c_int = 3;\npub const LOG_WARNING: ::c_int = 4;\npub const LOG_NOTICE: ::c_int = 5;\npub const LOG_INFO: ::c_int = 6;\npub const LOG_DEBUG: ::c_int = 7;\n\npub const LOG_KERN: ::c_int = 0;\npub const LOG_USER: ::c_int = 1 << 3;\npub const LOG_MAIL: ::c_int = 2 << 3;\npub const LOG_DAEMON: ::c_int = 3 << 3;\npub const LOG_AUTH: ::c_int = 4 << 3;\npub const LOG_SYSLOG: ::c_int = 5 << 3;\npub const LOG_LPR: ::c_int = 6 << 3;\npub const LOG_NEWS: ::c_int = 7 << 3;\npub const LOG_UUCP: ::c_int = 8 << 3;\npub const LOG_LOCAL0: ::c_int = 16 << 3;\npub const LOG_LOCAL1: ::c_int = 17 << 3;\npub const LOG_LOCAL2: ::c_int = 18 << 3;\npub const LOG_LOCAL3: ::c_int = 19 << 3;\npub const LOG_LOCAL4: ::c_int = 20 << 3;\npub const LOG_LOCAL5: ::c_int = 21 << 3;\npub const LOG_LOCAL6: ::c_int = 22 << 3;\npub const LOG_LOCAL7: ::c_int = 23 << 3;\n\npub const LOG_PID: ::c_int = 0x01;\npub const LOG_CONS: ::c_int = 0x02;\npub const LOG_ODELAY: ::c_int = 0x04;\npub const LOG_NDELAY: ::c_int = 0x08;\npub const LOG_NOWAIT: ::c_int = 0x10;\n\npub const LOG_PRIMASK: ::c_int = 7;\npub const LOG_FACMASK: ::c_int = 0x3f8;\n\npub const PRIO_PROCESS: ::c_int = 0;\npub const PRIO_PGRP: ::c_int = 1;\npub const PRIO_USER: ::c_int = 2;\n\npub const PRIO_MIN: ::c_int = -20;\npub const PRIO_MAX: ::c_int = 20;\n\npub const IPPROTO_ICMP: ::c_int = 1;\npub const IPPROTO_ICMPV6: ::c_int = 58;\npub const IPPROTO_TCP: ::c_int = 6;\npub const IPPROTO_UDP: ::c_int = 17;\npub const IPPROTO_IP: ::c_int = 0;\npub const IPPROTO_IPV6: ::c_int = 41;\n\npub const INADDR_LOOPBACK: in_addr_t = 2130706433;\npub const INADDR_ANY: in_addr_t = 0;\npub const INADDR_BROADCAST: in_addr_t = 4294967295;\npub const INADDR_NONE: in_addr_t = 4294967295;\n\npub const EXIT_FAILURE: ::c_int = 1;\npub const EXIT_SUCCESS: ::c_int = 0;\npub const RAND_MAX: ::c_int = 2147483647;\npub const EOF: ::c_int = -1;\npub const SEEK_SET: ::c_int = 0;\npub const SEEK_CUR: ::c_int = 1;\npub const SEEK_END: ::c_int = 2;\npub const _IOFBF: ::c_int = 0;\npub const _IONBF: ::c_int = 2;\npub const _IOLBF: ::c_int = 1;\n\npub const F_DUPFD: ::c_int = 0;\npub const F_GETFD: ::c_int = 1;\npub const F_SETFD: ::c_int = 2;\npub const F_GETFL: ::c_int = 3;\npub const F_SETFL: ::c_int = 4;\n\n// Linux-specific fcntls\npub const F_SETLEASE: ::c_int = 1024;\npub const F_GETLEASE: ::c_int = 1025;\npub const F_NOTIFY: ::c_int = 1026;\npub const F_CANCELLK: ::c_int = 1029;\npub const F_DUPFD_CLOEXEC: ::c_int = 1030;\npub const F_SETPIPE_SZ: ::c_int = 1031;\npub const F_GETPIPE_SZ: ::c_int = 1032;\npub const F_ADD_SEALS: ::c_int = 1033;\npub const F_GET_SEALS: ::c_int = 1034;\n\npub const F_SEAL_SEAL: ::c_int = 0x0001;\npub const F_SEAL_SHRINK: ::c_int = 0x0002;\npub const F_SEAL_GROW: ::c_int = 0x0004;\npub const F_SEAL_WRITE: ::c_int = 0x0008;\n\n// FIXME(#235): Include file sealing fcntls once we have a way to verify them.\n\npub const SIGTRAP: ::c_int = 5;\n\npub const PTHREAD_CREATE_JOINABLE: ::c_int = 0;\npub const PTHREAD_CREATE_DETACHED: ::c_int = 1;\n\npub const CLOCK_REALTIME: ::clockid_t = 0;\npub const CLOCK_MONOTONIC: ::clockid_t = 1;\npub const CLOCK_PROCESS_CPUTIME_ID: ::clockid_t = 2;\npub const CLOCK_THREAD_CPUTIME_ID: ::clockid_t = 3;\npub const CLOCK_MONOTONIC_RAW: ::clockid_t = 4;\npub const CLOCK_REALTIME_COARSE: ::clockid_t = 5;\npub const CLOCK_MONOTONIC_COARSE: ::clockid_t = 6;\npub const CLOCK_BOOTTIME: ::clockid_t = 7;\npub const CLOCK_REALTIME_ALARM: ::clockid_t = 8;\npub const CLOCK_BOOTTIME_ALARM: ::clockid_t = 9;\npub const CLOCK_SGI_CYCLE: ::clockid_t = 10;\npub const CLOCK_TAI: ::clockid_t = 11;\npub const TIMER_ABSTIME: ::c_int = 1;\n\npub const RLIMIT_CPU: ::c_int = 0;\npub const RLIMIT_FSIZE: ::c_int = 1;\npub const RLIMIT_DATA: ::c_int = 2;\npub const RLIMIT_STACK: ::c_int = 3;\npub const RLIMIT_CORE: ::c_int = 4;\npub const RLIMIT_LOCKS: ::c_int = 10;\npub const RLIMIT_SIGPENDING: ::c_int = 11;\npub const RLIMIT_MSGQUEUE: ::c_int = 12;\npub const RLIMIT_NICE: ::c_int = 13;\npub const RLIMIT_RTPRIO: ::c_int = 14;\n\npub const RUSAGE_SELF: ::c_int = 0;\n\npub const O_RDONLY: ::c_int = 0;\npub const O_WRONLY: ::c_int = 1;\npub const O_RDWR: ::c_int = 2;\n\npub const S_IFIFO: ::mode_t = 4096;\npub const S_IFCHR: ::mode_t = 8192;\npub const S_IFBLK: ::mode_t = 24576;\npub const S_IFDIR: ::mode_t = 16384;\npub const S_IFREG: ::mode_t = 32768;\npub const S_IFLNK: ::mode_t = 40960;\npub const S_IFSOCK: ::mode_t = 49152;\npub const S_IFMT: ::mode_t = 61440;\npub const S_IRWXU: ::mode_t = 448;\npub const S_IXUSR: ::mode_t = 64;\npub const S_IWUSR: ::mode_t = 128;\npub const S_IRUSR: ::mode_t = 256;\npub const S_IRWXG: ::mode_t = 56;\npub const S_IXGRP: ::mode_t = 8;\npub const S_IWGRP: ::mode_t = 16;\npub const S_IRGRP: ::mode_t = 32;\npub const S_IRWXO: ::mode_t = 7;\npub const S_IXOTH: ::mode_t = 1;\npub const S_IWOTH: ::mode_t = 2;\npub const S_IROTH: ::mode_t = 4;\npub const F_OK: ::c_int = 0;\npub const R_OK: ::c_int = 4;\npub const W_OK: ::c_int = 2;\npub const X_OK: ::c_int = 1;\npub const STDIN_FILENO: ::c_int = 0;\npub const STDOUT_FILENO: ::c_int = 1;\npub const STDERR_FILENO: ::c_int = 2;\npub const SIGHUP: ::c_int = 1;\npub const SIGINT: ::c_int = 2;\npub const SIGQUIT: ::c_int = 3;\npub const SIGILL: ::c_int = 4;\npub const SIGABRT: ::c_int = 6;\npub const SIGFPE: ::c_int = 8;\npub const SIGKILL: ::c_int = 9;\npub const SIGSEGV: ::c_int = 11;\npub const SIGPIPE: ::c_int = 13;\npub const SIGALRM: ::c_int = 14;\npub const SIGTERM: ::c_int = 15;\n\npub const PROT_NONE: ::c_int = 0;\npub const PROT_READ: ::c_int = 1;\npub const PROT_WRITE: ::c_int = 2;\npub const PROT_EXEC: ::c_int = 4;\n\npub const LC_CTYPE: ::c_int = 0;\npub const LC_NUMERIC: ::c_int = 1;\npub const LC_TIME: ::c_int = 2;\npub const LC_COLLATE: ::c_int = 3;\npub const LC_MONETARY: ::c_int = 4;\npub const LC_MESSAGES: ::c_int = 5;\npub const LC_ALL: ::c_int = 6;\npub const LC_CTYPE_MASK: ::c_int = 1 << LC_CTYPE;\npub const LC_NUMERIC_MASK: ::c_int = 1 << LC_NUMERIC;\npub const LC_TIME_MASK: ::c_int = 1 << LC_TIME;\npub const LC_COLLATE_MASK: ::c_int = 1 << LC_COLLATE;\npub const LC_MONETARY_MASK: ::c_int = 1 << LC_MONETARY;\npub const LC_MESSAGES_MASK: ::c_int = 1 << LC_MESSAGES;\n// LC_ALL_MASK defined per platform\n\npub const MAP_FILE: ::c_int = 0x0000;\npub const MAP_SHARED: ::c_int = 0x0001;\npub const MAP_PRIVATE: ::c_int = 0x0002;\npub const MAP_FIXED: ::c_int = 0x0010;\n\npub const MAP_FAILED: *mut ::c_void = !0 as *mut ::c_void;\n\n// MS_ flags for msync(2)\npub const MS_ASYNC: ::c_int = 0x0001;\npub const MS_INVALIDATE: ::c_int = 0x0002;\npub const MS_SYNC: ::c_int = 0x0004;\n\n// MS_ flags for mount(2)\npub const MS_RDONLY: ::c_ulong = 0x01;\npub const MS_NOSUID: ::c_ulong = 0x02;\npub const MS_NODEV: ::c_ulong = 0x04;\npub const MS_NOEXEC: ::c_ulong = 0x08;\npub const MS_SYNCHRONOUS: ::c_ulong = 0x10;\npub const MS_REMOUNT: ::c_ulong = 0x20;\npub const MS_MANDLOCK: ::c_ulong = 0x40;\npub const MS_DIRSYNC: ::c_ulong = 0x80;\npub const MS_NOATIME: ::c_ulong = 0x0400;\npub const MS_NODIRATIME: ::c_ulong = 0x0800;\npub const MS_BIND: ::c_ulong = 0x1000;\npub const MS_MOVE: ::c_ulong = 0x2000;\npub const MS_REC: ::c_ulong = 0x4000;\npub const MS_SILENT: ::c_ulong = 0x8000;\npub const MS_POSIXACL: ::c_ulong = 0x010000;\npub const MS_UNBINDABLE: ::c_ulong = 0x020000;\npub const MS_PRIVATE: ::c_ulong = 0x040000;\npub const MS_SLAVE: ::c_ulong = 0x080000;\npub const MS_SHARED: ::c_ulong = 0x100000;\npub const MS_RELATIME: ::c_ulong = 0x200000;\npub const MS_KERNMOUNT: ::c_ulong = 0x400000;\npub const MS_I_VERSION: ::c_ulong = 0x800000;\npub const MS_STRICTATIME: ::c_ulong = 0x1000000;\npub const MS_ACTIVE: ::c_ulong = 0x40000000;\npub const MS_NOUSER: ::c_ulong = 0x80000000;\npub const MS_MGC_VAL: ::c_ulong = 0xc0ed0000;\npub const MS_MGC_MSK: ::c_ulong = 0xffff0000;\npub const MS_RMT_MASK: ::c_ulong = 0x800051;\n\npub const EPERM: ::c_int = 1;\npub const ENOENT: ::c_int = 2;\npub const ESRCH: ::c_int = 3;\npub const EINTR: ::c_int = 4;\npub const EIO: ::c_int = 5;\npub const ENXIO: ::c_int = 6;\npub const E2BIG: ::c_int = 7;\npub const ENOEXEC: ::c_int = 8;\npub const EBADF: ::c_int = 9;\npub const ECHILD: ::c_int = 10;\npub const EAGAIN: ::c_int = 11;\npub const ENOMEM: ::c_int = 12;\npub const EACCES: ::c_int = 13;\npub const EFAULT: ::c_int = 14;\npub const ENOTBLK: ::c_int = 15;\npub const EBUSY: ::c_int = 16;\npub const EEXIST: ::c_int = 17;\npub const EXDEV: ::c_int = 18;\npub const ENODEV: ::c_int = 19;\npub const ENOTDIR: ::c_int = 20;\npub const EISDIR: ::c_int = 21;\npub const EINVAL: ::c_int = 22;\npub const ENFILE: ::c_int = 23;\npub const EMFILE: ::c_int = 24;\npub const ENOTTY: ::c_int = 25;\npub const ETXTBSY: ::c_int = 26;\npub const EFBIG: ::c_int = 27;\npub const ENOSPC: ::c_int = 28;\npub const ESPIPE: ::c_int = 29;\npub const EROFS: ::c_int = 30;\npub const EMLINK: ::c_int = 31;\npub const EPIPE: ::c_int = 32;\npub const EDOM: ::c_int = 33;\npub const ERANGE: ::c_int = 34;\npub const EWOULDBLOCK: ::c_int = EAGAIN;\n\npub const SCM_RIGHTS: ::c_int = 0x01;\npub const SCM_CREDENTIALS: ::c_int = 0x02;\n\npub const PROT_GROWSDOWN: ::c_int = 0x1000000;\npub const PROT_GROWSUP: ::c_int = 0x2000000;\n\npub const MAP_TYPE: ::c_int = 0x000f;\n\npub const MADV_NORMAL: ::c_int = 0;\npub const MADV_RANDOM: ::c_int = 1;\npub const MADV_SEQUENTIAL: ::c_int = 2;\npub const MADV_WILLNEED: ::c_int = 3;\npub const MADV_DONTNEED: ::c_int = 4;\npub const MADV_FREE: ::c_int = 8;\npub const MADV_REMOVE: ::c_int = 9;\npub const MADV_DONTFORK: ::c_int = 10;\npub const MADV_DOFORK: ::c_int = 11;\npub const MADV_MERGEABLE: ::c_int = 12;\npub const MADV_UNMERGEABLE: ::c_int = 13;\npub const MADV_HUGEPAGE: ::c_int = 14;\npub const MADV_NOHUGEPAGE: ::c_int = 15;\npub const MADV_DONTDUMP: ::c_int = 16;\npub const MADV_DODUMP: ::c_int = 17;\npub const MADV_HWPOISON: ::c_int = 100;\npub const MADV_SOFT_OFFLINE: ::c_int = 101;\n\npub const IFF_UP: ::c_int = 0x1;\npub const IFF_BROADCAST: ::c_int = 0x2;\npub const IFF_DEBUG: ::c_int = 0x4;\npub const IFF_LOOPBACK: ::c_int = 0x8;\npub const IFF_POINTOPOINT: ::c_int = 0x10;\npub const IFF_NOTRAILERS: ::c_int = 0x20;\npub const IFF_RUNNING: ::c_int = 0x40;\npub const IFF_NOARP: ::c_int = 0x80;\npub const IFF_PROMISC: ::c_int = 0x100;\npub const IFF_ALLMULTI: ::c_int = 0x200;\npub const IFF_MASTER: ::c_int = 0x400;\npub const IFF_SLAVE: ::c_int = 0x800;\npub const IFF_MULTICAST: ::c_int = 0x1000;\npub const IFF_PORTSEL: ::c_int = 0x2000;\npub const IFF_AUTOMEDIA: ::c_int = 0x4000;\npub const IFF_DYNAMIC: ::c_int = 0x8000;\npub const IFF_TUN: ::c_int = 0x0001;\npub const IFF_TAP: ::c_int = 0x0002;\npub const IFF_NO_PI: ::c_int = 0x1000;\n\npub const SOL_IP: ::c_int = 0;\npub const SOL_TCP: ::c_int = 6;\npub const SOL_UDP: ::c_int = 17;\npub const SOL_IPV6: ::c_int = 41;\npub const SOL_ICMPV6: ::c_int = 58;\npub const SOL_RAW: ::c_int = 255;\npub const SOL_DECNET: ::c_int = 261;\npub const SOL_X25: ::c_int = 262;\npub const SOL_PACKET: ::c_int = 263;\npub const SOL_ATM: ::c_int = 264;\npub const SOL_AAL: ::c_int = 265;\npub const SOL_IRDA: ::c_int = 266;\npub const SOL_NETBEUI: ::c_int = 267;\npub const SOL_LLC: ::c_int = 268;\npub const SOL_DCCP: ::c_int = 269;\npub const SOL_NETLINK: ::c_int = 270;\npub const SOL_TIPC: ::c_int = 271;\n\npub const AF_UNSPEC: ::c_int = 0;\npub const AF_UNIX: ::c_int = 1;\npub const AF_LOCAL: ::c_int = 1;\npub const AF_INET: ::c_int = 2;\npub const AF_AX25: ::c_int = 3;\npub const AF_IPX: ::c_int = 4;\npub const AF_APPLETALK: ::c_int = 5;\npub const AF_NETROM: ::c_int = 6;\npub const AF_BRIDGE: ::c_int = 7;\npub const AF_ATMPVC: ::c_int = 8;\npub const AF_X25: ::c_int = 9;\npub const AF_INET6: ::c_int = 10;\npub const AF_ROSE: ::c_int = 11;\npub const AF_DECnet: ::c_int = 12;\npub const AF_NETBEUI: ::c_int = 13;\npub const AF_SECURITY: ::c_int = 14;\npub const AF_KEY: ::c_int = 15;\npub const AF_NETLINK: ::c_int = 16;\npub const AF_ROUTE: ::c_int = AF_NETLINK;\npub const AF_PACKET: ::c_int = 17;\npub const AF_ASH: ::c_int = 18;\npub const AF_ECONET: ::c_int = 19;\npub const AF_ATMSVC: ::c_int = 20;\npub const AF_RDS: ::c_int = 21;\npub const AF_SNA: ::c_int = 22;\npub const AF_IRDA: ::c_int = 23;\npub const AF_PPPOX: ::c_int = 24;\npub const AF_WANPIPE: ::c_int = 25;\npub const AF_LLC: ::c_int = 26;\npub const AF_CAN: ::c_int = 29;\npub const AF_TIPC: ::c_int = 30;\npub const AF_BLUETOOTH: ::c_int = 31;\npub const AF_IUCV: ::c_int = 32;\npub const AF_RXRPC: ::c_int = 33;\npub const AF_ISDN: ::c_int = 34;\npub const AF_PHONET: ::c_int = 35;\npub const AF_IEEE802154: ::c_int = 36;\npub const AF_CAIF: ::c_int = 37;\npub const AF_ALG: ::c_int = 38;\n\npub const PF_UNSPEC: ::c_int = AF_UNSPEC;\npub const PF_UNIX: ::c_int = AF_UNIX;\npub const PF_LOCAL: ::c_int = AF_LOCAL;\npub const PF_INET: ::c_int = AF_INET;\npub const PF_AX25: ::c_int = AF_AX25;\npub const PF_IPX: ::c_int = AF_IPX;\npub const PF_APPLETALK: ::c_int = AF_APPLETALK;\npub const PF_NETROM: ::c_int = AF_NETROM;\npub const PF_BRIDGE: ::c_int = AF_BRIDGE;\npub const PF_ATMPVC: ::c_int = AF_ATMPVC;\npub const PF_X25: ::c_int = AF_X25;\npub const PF_INET6: ::c_int = AF_INET6;\npub const PF_ROSE: ::c_int = AF_ROSE;\npub const PF_DECnet: ::c_int = AF_DECnet;\npub const PF_NETBEUI: ::c_int = AF_NETBEUI;\npub const PF_SECURITY: ::c_int = AF_SECURITY;\npub const PF_KEY: ::c_int = AF_KEY;\npub const PF_NETLINK: ::c_int = AF_NETLINK;\npub const PF_ROUTE: ::c_int = AF_ROUTE;\npub const PF_PACKET: ::c_int = AF_PACKET;\npub const PF_ASH: ::c_int = AF_ASH;\npub const PF_ECONET: ::c_int = AF_ECONET;\npub const PF_ATMSVC: ::c_int = AF_ATMSVC;\npub const PF_RDS: ::c_int = AF_RDS;\npub const PF_SNA: ::c_int = AF_SNA;\npub const PF_IRDA: ::c_int = AF_IRDA;\npub const PF_PPPOX: ::c_int = AF_PPPOX;\npub const PF_WANPIPE: ::c_int = AF_WANPIPE;\npub const PF_LLC: ::c_int = AF_LLC;\npub const PF_CAN: ::c_int = AF_CAN;\npub const PF_TIPC: ::c_int = AF_TIPC;\npub const PF_BLUETOOTH: ::c_int = AF_BLUETOOTH;\npub const PF_IUCV: ::c_int = AF_IUCV;\npub const PF_RXRPC: ::c_int = AF_RXRPC;\npub const PF_ISDN: ::c_int = AF_ISDN;\npub const PF_PHONET: ::c_int = AF_PHONET;\npub const PF_IEEE802154: ::c_int = AF_IEEE802154;\npub const PF_CAIF: ::c_int = AF_CAIF;\npub const PF_ALG: ::c_int = AF_ALG;\n\npub const SOMAXCONN: ::c_int = 128;\n\npub const MSG_OOB: ::c_int = 1;\npub const MSG_PEEK: ::c_int = 2;\npub const MSG_DONTROUTE: ::c_int = 4;\npub const MSG_CTRUNC: ::c_int = 8;\npub const MSG_TRUNC: ::c_int = 0x20;\npub const MSG_DONTWAIT: ::c_int = 0x40;\npub const MSG_EOR: ::c_int = 0x80;\npub const MSG_WAITALL: ::c_int = 0x100;\npub const MSG_FIN: ::c_int = 0x200;\npub const MSG_SYN: ::c_int = 0x400;\npub const MSG_CONFIRM: ::c_int = 0x800;\npub const MSG_RST: ::c_int = 0x1000;\npub const MSG_ERRQUEUE: ::c_int = 0x2000;\npub const MSG_NOSIGNAL: ::c_int = 0x4000;\npub const MSG_MORE: ::c_int = 0x8000;\npub const MSG_WAITFORONE: ::c_int = 0x10000;\npub const MSG_FASTOPEN: ::c_int = 0x20000000;\npub const MSG_CMSG_CLOEXEC: ::c_int = 0x40000000;\n\npub const SCM_TIMESTAMP: ::c_int = SO_TIMESTAMP;\n\npub const SOCK_RAW: ::c_int = 3;\npub const SOCK_RDM: ::c_int = 4;\n\npub const IP_TTL: ::c_int = 2;\npub const IP_HDRINCL: ::c_int = 3;\npub const IP_FREEBIND: ::c_int = 15;\npub const IP_TRANSPARENT: ::c_int = 19;\npub const IP_MULTICAST_IF: ::c_int = 32;\npub const IP_MULTICAST_TTL: ::c_int = 33;\npub const IP_MULTICAST_LOOP: ::c_int = 34;\npub const IP_ADD_MEMBERSHIP: ::c_int = 35;\npub const IP_DROP_MEMBERSHIP: ::c_int = 36;\n\npub const IPV6_UNICAST_HOPS: ::c_int = 16;\npub const IPV6_MULTICAST_IF: ::c_int = 17;\npub const IPV6_MULTICAST_HOPS: ::c_int = 18;\npub const IPV6_MULTICAST_LOOP: ::c_int = 19;\npub const IPV6_ADD_MEMBERSHIP: ::c_int = 20;\npub const IPV6_DROP_MEMBERSHIP: ::c_int = 21;\npub const IPV6_V6ONLY: ::c_int = 26;\n\npub const TCP_NODELAY: ::c_int = 1;\npub const TCP_MAXSEG: ::c_int = 2;\npub const TCP_CORK: ::c_int = 3;\npub const TCP_KEEPIDLE: ::c_int = 4;\npub const TCP_KEEPINTVL: ::c_int = 5;\npub const TCP_KEEPCNT: ::c_int = 6;\npub const TCP_SYNCNT: ::c_int = 7;\npub const TCP_LINGER2: ::c_int = 8;\npub const TCP_DEFER_ACCEPT: ::c_int = 9;\npub const TCP_WINDOW_CLAMP: ::c_int = 10;\npub const TCP_INFO: ::c_int = 11;\npub const TCP_QUICKACK: ::c_int = 12;\npub const TCP_CONGESTION: ::c_int = 13;\n\npub const SO_DEBUG: ::c_int = 1;\n\npub const SHUT_RD: ::c_int = 0;\npub const SHUT_WR: ::c_int = 1;\npub const SHUT_RDWR: ::c_int = 2;\n\npub const LOCK_SH: ::c_int = 1;\npub const LOCK_EX: ::c_int = 2;\npub const LOCK_NB: ::c_int = 4;\npub const LOCK_UN: ::c_int = 8;\n\npub const SS_ONSTACK: ::c_int = 1;\npub const SS_DISABLE: ::c_int = 2;\n\npub const PATH_MAX: ::c_int = 4096;\n\npub const FD_SETSIZE: usize = 1024;\n\npub const EPOLLIN: ::c_int = 0x1;\npub const EPOLLPRI: ::c_int = 0x2;\npub const EPOLLOUT: ::c_int = 0x4;\npub const EPOLLRDNORM: ::c_int = 0x40;\npub const EPOLLRDBAND: ::c_int = 0x80;\npub const EPOLLWRNORM: ::c_int = 0x100;\npub const EPOLLWRBAND: ::c_int = 0x200;\npub const EPOLLMSG: ::c_int = 0x400;\npub const EPOLLERR: ::c_int = 0x8;\npub const EPOLLHUP: ::c_int = 0x10;\npub const EPOLLET: ::c_int = 0x80000000;\n\npub const EPOLL_CTL_ADD: ::c_int = 1;\npub const EPOLL_CTL_MOD: ::c_int = 3;\npub const EPOLL_CTL_DEL: ::c_int = 2;\n\npub const MNT_DETACH: ::c_int = 0x2;\npub const MNT_EXPIRE: ::c_int = 0x4;\n\npub const Q_GETFMT: ::c_int = 0x800004;\npub const Q_GETINFO: ::c_int = 0x800005;\npub const Q_SETINFO: ::c_int = 0x800006;\npub const QIF_BLIMITS: u32 = 1;\npub const QIF_SPACE: u32 = 2;\npub const QIF_ILIMITS: u32 = 4;\npub const QIF_INODES: u32 = 8;\npub const QIF_BTIME: u32 = 16;\npub const QIF_ITIME: u32 = 32;\npub const QIF_LIMITS: u32 = 5;\npub const QIF_USAGE: u32 = 10;\npub const QIF_TIMES: u32 = 48;\npub const QIF_ALL: u32 = 63;\n\npub const MNT_FORCE: ::c_int = 0x1;\n\npub const Q_SYNC: ::c_int = 0x800001;\npub const Q_QUOTAON: ::c_int = 0x800002;\npub const Q_QUOTAOFF: ::c_int = 0x800003;\npub const Q_GETQUOTA: ::c_int = 0x800007;\npub const Q_SETQUOTA: ::c_int = 0x800008;\n\npub const TCIOFF: ::c_int = 2;\npub const TCION: ::c_int = 3;\npub const TCOOFF: ::c_int = 0;\npub const TCOON: ::c_int = 1;\npub const TCIFLUSH: ::c_int = 0;\npub const TCOFLUSH: ::c_int = 1;\npub const TCIOFLUSH: ::c_int = 2;\npub const NL0: ::c_int = 0x00000000;\npub const NL1: ::c_int = 0x00000100;\npub const TAB0: ::c_int = 0x00000000;\npub const CR0: ::c_int = 0x00000000;\npub const FF0: ::c_int = 0x00000000;\npub const BS0: ::c_int = 0x00000000;\npub const VT0: ::c_int = 0x00000000;\npub const VERASE: usize = 2;\npub const VKILL: usize = 3;\npub const VINTR: usize = 0;\npub const VQUIT: usize = 1;\npub const VLNEXT: usize = 15;\npub const IGNBRK: ::tcflag_t = 0x00000001;\npub const BRKINT: ::tcflag_t = 0x00000002;\npub const IGNPAR: ::tcflag_t = 0x00000004;\npub const PARMRK: ::tcflag_t = 0x00000008;\npub const INPCK: ::tcflag_t = 0x00000010;\npub const ISTRIP: ::tcflag_t = 0x00000020;\npub const INLCR: ::tcflag_t = 0x00000040;\npub const IGNCR: ::tcflag_t = 0x00000080;\npub const ICRNL: ::tcflag_t = 0x00000100;\npub const IXANY: ::tcflag_t = 0x00000800;\npub const IMAXBEL: ::tcflag_t = 0x00002000;\npub const OPOST: ::tcflag_t = 0x1;\npub const CS5: ::tcflag_t = 0x00000000;\npub const CRTSCTS: ::tcflag_t = 0x80000000;\npub const ECHO: ::tcflag_t = 0x00000008;\npub const OCRNL: ::tcflag_t = 0o000010;\npub const ONOCR: ::tcflag_t = 0o000020;\npub const ONLRET: ::tcflag_t = 0o000040;\npub const OFILL: ::tcflag_t = 0o000100;\npub const OFDEL: ::tcflag_t = 0o000200;\n\npub const CLONE_VM: ::c_int = 0x100;\npub const CLONE_FS: ::c_int = 0x200;\npub const CLONE_FILES: ::c_int = 0x400;\npub const CLONE_SIGHAND: ::c_int = 0x800;\npub const CLONE_PTRACE: ::c_int = 0x2000;\npub const CLONE_VFORK: ::c_int = 0x4000;\npub const CLONE_PARENT: ::c_int = 0x8000;\npub const CLONE_THREAD: ::c_int = 0x10000;\npub const CLONE_NEWNS: ::c_int = 0x20000;\npub const CLONE_SYSVSEM: ::c_int = 0x40000;\npub const CLONE_SETTLS: ::c_int = 0x80000;\npub const CLONE_PARENT_SETTID: ::c_int = 0x100000;\npub const CLONE_CHILD_CLEARTID: ::c_int = 0x200000;\npub const CLONE_DETACHED: ::c_int = 0x400000;\npub const CLONE_UNTRACED: ::c_int = 0x800000;\npub const CLONE_CHILD_SETTID: ::c_int = 0x01000000;\npub const CLONE_NEWUTS: ::c_int = 0x04000000;\npub const CLONE_NEWIPC: ::c_int = 0x08000000;\npub const CLONE_NEWUSER: ::c_int = 0x10000000;\npub const CLONE_NEWPID: ::c_int = 0x20000000;\npub const CLONE_NEWNET: ::c_int = 0x40000000;\npub const CLONE_IO: ::c_int = 0x80000000;\npub const CLONE_NEWCGROUP: ::c_int = 0x02000000;\n\npub const WNOHANG: ::c_int = 0x00000001;\npub const WUNTRACED: ::c_int = 0x00000002;\npub const WSTOPPED: ::c_int = WUNTRACED;\npub const WEXITED: ::c_int = 0x00000004;\npub const WCONTINUED: ::c_int = 0x00000008;\npub const WNOWAIT: ::c_int = 0x01000000;\n\n// ::Options set using PTRACE_SETOPTIONS.\npub const PTRACE_O_TRACESYSGOOD: ::c_int = 0x00000001;\npub const PTRACE_O_TRACEFORK: ::c_int = 0x00000002;\npub const PTRACE_O_TRACEVFORK: ::c_int = 0x00000004;\npub const PTRACE_O_TRACECLONE: ::c_int = 0x00000008;\npub const PTRACE_O_TRACEEXEC: ::c_int = 0x00000010;\npub const PTRACE_O_TRACEVFORKDONE: ::c_int = 0x00000020;\npub const PTRACE_O_TRACEEXIT: ::c_int = 0x00000040;\npub const PTRACE_O_TRACESECCOMP: ::c_int = 0x00000080;\npub const PTRACE_O_EXITKILL: ::c_int = 0x00100000;\npub const PTRACE_O_SUSPEND_SECCOMP: ::c_int = 0x00200000;\npub const PTRACE_O_MASK: ::c_int = 0x003000ff;\n\n// Wait extended result codes for the above trace options.\npub const PTRACE_EVENT_FORK: ::c_int = 1;\npub const PTRACE_EVENT_VFORK: ::c_int = 2;\npub const PTRACE_EVENT_CLONE: ::c_int = 3;\npub const PTRACE_EVENT_EXEC: ::c_int = 4;\npub const PTRACE_EVENT_VFORK_DONE: ::c_int = 5;\npub const PTRACE_EVENT_EXIT: ::c_int = 6;\npub const PTRACE_EVENT_SECCOMP: ::c_int = 7;\n// PTRACE_EVENT_STOP was added to glibc in 2.26\n// pub const PTRACE_EVENT_STOP: ::c_int = 128;\n\npub const __WNOTHREAD: ::c_int = 0x20000000;\npub const __WALL: ::c_int = 0x40000000;\npub const __WCLONE: ::c_int = 0x80000000;\n\npub const SPLICE_F_MOVE: ::c_uint = 0x01;\npub const SPLICE_F_NONBLOCK: ::c_uint = 0x02;\npub const SPLICE_F_MORE: ::c_uint = 0x04;\npub const SPLICE_F_GIFT: ::c_uint = 0x08;\n\npub const RTLD_LOCAL: ::c_int = 0;\npub const RTLD_LAZY: ::c_int = 1;\n\npub const POSIX_FADV_NORMAL: ::c_int = 0;\npub const POSIX_FADV_RANDOM: ::c_int = 1;\npub const POSIX_FADV_SEQUENTIAL: ::c_int = 2;\npub const POSIX_FADV_WILLNEED: ::c_int = 3;\n\npub const AT_FDCWD: ::c_int = -100;\npub const AT_SYMLINK_NOFOLLOW: ::c_int = 0x100;\npub const AT_REMOVEDIR: ::c_int = 0x200;\npub const AT_EACCESS: ::c_int = 0x200;\npub const AT_SYMLINK_FOLLOW: ::c_int = 0x400;\npub const AT_NO_AUTOMOUNT: ::c_int = 0x800;\npub const AT_EMPTY_PATH: ::c_int = 0x1000;\n\npub const LOG_CRON: ::c_int = 9 << 3;\npub const LOG_AUTHPRIV: ::c_int = 10 << 3;\npub const LOG_FTP: ::c_int = 11 << 3;\npub const LOG_PERROR: ::c_int = 0x20;\n\npub const PIPE_BUF: usize = 4096;\n\npub const SI_LOAD_SHIFT: ::c_uint = 16;\n\npub const CLD_EXITED: ::c_int = 1;\npub const CLD_KILLED: ::c_int = 2;\npub const CLD_DUMPED: ::c_int = 3;\npub const CLD_TRAPPED: ::c_int = 4;\npub const CLD_STOPPED: ::c_int = 5;\npub const CLD_CONTINUED: ::c_int = 6;\n\npub const SIGEV_SIGNAL: ::c_int = 0;\npub const SIGEV_NONE: ::c_int = 1;\npub const SIGEV_THREAD: ::c_int = 2;\n\npub const P_ALL: idtype_t = 0;\npub const P_PID: idtype_t = 1;\npub const P_PGID: idtype_t = 2;\n\npub const UTIME_OMIT: c_long = 1073741822;\npub const UTIME_NOW: c_long = 1073741823;\n\npub const POLLIN: ::c_short = 0x1;\npub const POLLPRI: ::c_short = 0x2;\npub const POLLOUT: ::c_short = 0x4;\npub const POLLERR: ::c_short = 0x8;\npub const POLLHUP: ::c_short = 0x10;\npub const POLLNVAL: ::c_short = 0x20;\npub const POLLRDNORM: ::c_short = 0x040;\npub const POLLRDBAND: ::c_short = 0x080;\n\npub const ABDAY_1: ::nl_item = 0x20000;\npub const ABDAY_2: ::nl_item = 0x20001;\npub const ABDAY_3: ::nl_item = 0x20002;\npub const ABDAY_4: ::nl_item = 0x20003;\npub const ABDAY_5: ::nl_item = 0x20004;\npub const ABDAY_6: ::nl_item = 0x20005;\npub const ABDAY_7: ::nl_item = 0x20006;\n\npub const DAY_1: ::nl_item = 0x20007;\npub const DAY_2: ::nl_item = 0x20008;\npub const DAY_3: ::nl_item = 0x20009;\npub const DAY_4: ::nl_item = 0x2000A;\npub const DAY_5: ::nl_item = 0x2000B;\npub const DAY_6: ::nl_item = 0x2000C;\npub const DAY_7: ::nl_item = 0x2000D;\n\npub const ABMON_1: ::nl_item = 0x2000E;\npub const ABMON_2: ::nl_item = 0x2000F;\npub const ABMON_3: ::nl_item = 0x20010;\npub const ABMON_4: ::nl_item = 0x20011;\npub const ABMON_5: ::nl_item = 0x20012;\npub const ABMON_6: ::nl_item = 0x20013;\npub const ABMON_7: ::nl_item = 0x20014;\npub const ABMON_8: ::nl_item = 0x20015;\npub const ABMON_9: ::nl_item = 0x20016;\npub const ABMON_10: ::nl_item = 0x20017;\npub const ABMON_11: ::nl_item = 0x20018;\npub const ABMON_12: ::nl_item = 0x20019;\n\npub const MON_1: ::nl_item = 0x2001A;\npub const MON_2: ::nl_item = 0x2001B;\npub const MON_3: ::nl_item = 0x2001C;\npub const MON_4: ::nl_item = 0x2001D;\npub const MON_5: ::nl_item = 0x2001E;\npub const MON_6: ::nl_item = 0x2001F;\npub const MON_7: ::nl_item = 0x20020;\npub const MON_8: ::nl_item = 0x20021;\npub const MON_9: ::nl_item = 0x20022;\npub const MON_10: ::nl_item = 0x20023;\npub const MON_11: ::nl_item = 0x20024;\npub const MON_12: ::nl_item = 0x20025;\n\npub const AM_STR: ::nl_item = 0x20026;\npub const PM_STR: ::nl_item = 0x20027;\n\npub const D_T_FMT: ::nl_item = 0x20028;\npub const D_FMT: ::nl_item = 0x20029;\npub const T_FMT: ::nl_item = 0x2002A;\npub const T_FMT_AMPM: ::nl_item = 0x2002B;\n\npub const ERA: ::nl_item = 0x2002C;\npub const ERA_D_FMT: ::nl_item = 0x2002E;\npub const ALT_DIGITS: ::nl_item = 0x2002F;\npub const ERA_D_T_FMT: ::nl_item = 0x20030;\npub const ERA_T_FMT: ::nl_item = 0x20031;\n\npub const CODESET: ::nl_item = 14;\n\npub const CRNCYSTR: ::nl_item = 0x4000F;\n\npub const RUSAGE_THREAD: ::c_int = 1;\npub const RUSAGE_CHILDREN: ::c_int = -1;\n\npub const RADIXCHAR: ::nl_item = 0x10000;\npub const THOUSEP: ::nl_item = 0x10001;\n\npub const YESEXPR: ::nl_item = 0x50000;\npub const NOEXPR: ::nl_item = 0x50001;\npub const YESSTR: ::nl_item = 0x50002;\npub const NOSTR: ::nl_item = 0x50003;\n\npub const FILENAME_MAX: ::c_uint = 4096;\npub const L_tmpnam: ::c_uint = 20;\npub const _PC_LINK_MAX: ::c_int = 0;\npub const _PC_MAX_CANON: ::c_int = 1;\npub const _PC_MAX_INPUT: ::c_int = 2;\npub const _PC_NAME_MAX: ::c_int = 3;\npub const _PC_PATH_MAX: ::c_int = 4;\npub const _PC_PIPE_BUF: ::c_int = 5;\npub const _PC_CHOWN_RESTRICTED: ::c_int = 6;\npub const _PC_NO_TRUNC: ::c_int = 7;\npub const _PC_VDISABLE: ::c_int = 8;\npub const _PC_SYNC_IO: ::c_int = 9;\npub const _PC_ASYNC_IO: ::c_int = 10;\npub const _PC_PRIO_IO: ::c_int = 11;\npub const _PC_SOCK_MAXBUF: ::c_int = 12;\npub const _PC_FILESIZEBITS: ::c_int = 13;\npub const _PC_REC_INCR_XFER_SIZE: ::c_int = 14;\npub const _PC_REC_MAX_XFER_SIZE: ::c_int = 15;\npub const _PC_REC_MIN_XFER_SIZE: ::c_int = 16;\npub const _PC_REC_XFER_ALIGN: ::c_int = 17;\npub const _PC_ALLOC_SIZE_MIN: ::c_int = 18;\npub const _PC_SYMLINK_MAX: ::c_int = 19;\npub const _PC_2_SYMLINKS: ::c_int = 20;\n\npub const _SC_ARG_MAX: ::c_int = 0;\npub const _SC_CHILD_MAX: ::c_int = 1;\npub const _SC_CLK_TCK: ::c_int = 2;\npub const _SC_NGROUPS_MAX: ::c_int = 3;\npub const _SC_OPEN_MAX: ::c_int = 4;\npub const _SC_STREAM_MAX: ::c_int = 5;\npub const _SC_TZNAME_MAX: ::c_int = 6;\npub const _SC_JOB_CONTROL: ::c_int = 7;\npub const _SC_SAVED_IDS: ::c_int = 8;\npub const _SC_REALTIME_SIGNALS: ::c_int = 9;\npub const _SC_PRIORITY_SCHEDULING: ::c_int = 10;\npub const _SC_TIMERS: ::c_int = 11;\npub const _SC_ASYNCHRONOUS_IO: ::c_int = 12;\npub const _SC_PRIORITIZED_IO: ::c_int = 13;\npub const _SC_SYNCHRONIZED_IO: ::c_int = 14;\npub const _SC_FSYNC: ::c_int = 15;\npub const _SC_MAPPED_FILES: ::c_int = 16;\npub const _SC_MEMLOCK: ::c_int = 17;\npub const _SC_MEMLOCK_RANGE: ::c_int = 18;\npub const _SC_MEMORY_PROTECTION: ::c_int = 19;\npub const _SC_MESSAGE_PASSING: ::c_int = 20;\npub const _SC_SEMAPHORES: ::c_int = 21;\npub const _SC_SHARED_MEMORY_OBJECTS: ::c_int = 22;\npub const _SC_AIO_LISTIO_MAX: ::c_int = 23;\npub const _SC_AIO_MAX: ::c_int = 24;\npub const _SC_AIO_PRIO_DELTA_MAX: ::c_int = 25;\npub const _SC_DELAYTIMER_MAX: ::c_int = 26;\npub const _SC_MQ_OPEN_MAX: ::c_int = 27;\npub const _SC_MQ_PRIO_MAX: ::c_int = 28;\npub const _SC_VERSION: ::c_int = 29;\npub const _SC_PAGESIZE: ::c_int = 30;\npub const _SC_PAGE_SIZE: ::c_int = _SC_PAGESIZE;\npub const _SC_RTSIG_MAX: ::c_int = 31;\npub const _SC_SEM_NSEMS_MAX: ::c_int = 32;\npub const _SC_SEM_VALUE_MAX: ::c_int = 33;\npub const _SC_SIGQUEUE_MAX: ::c_int = 34;\npub const _SC_TIMER_MAX: ::c_int = 35;\npub const _SC_BC_BASE_MAX: ::c_int = 36;\npub const _SC_BC_DIM_MAX: ::c_int = 37;\npub const _SC_BC_SCALE_MAX: ::c_int = 38;\npub const _SC_BC_STRING_MAX: ::c_int = 39;\npub const _SC_COLL_WEIGHTS_MAX: ::c_int = 40;\npub const _SC_EXPR_NEST_MAX: ::c_int = 42;\npub const _SC_LINE_MAX: ::c_int = 43;\npub const _SC_RE_DUP_MAX: ::c_int = 44;\npub const _SC_2_VERSION: ::c_int = 46;\npub const _SC_2_C_BIND: ::c_int = 47;\npub const _SC_2_C_DEV: ::c_int = 48;\npub const _SC_2_FORT_DEV: ::c_int = 49;\npub const _SC_2_FORT_RUN: ::c_int = 50;\npub const _SC_2_SW_DEV: ::c_int = 51;\npub const _SC_2_LOCALEDEF: ::c_int = 52;\npub const _SC_UIO_MAXIOV: ::c_int = 60;\npub const _SC_IOV_MAX: ::c_int = 60;\npub const _SC_THREADS: ::c_int = 67;\npub const _SC_THREAD_SAFE_FUNCTIONS: ::c_int = 68;\npub const _SC_GETGR_R_SIZE_MAX: ::c_int = 69;\npub const _SC_GETPW_R_SIZE_MAX: ::c_int = 70;\npub const _SC_LOGIN_NAME_MAX: ::c_int = 71;\npub const _SC_TTY_NAME_MAX: ::c_int = 72;\npub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::c_int = 73;\npub const _SC_THREAD_KEYS_MAX: ::c_int = 74;\npub const _SC_THREAD_STACK_MIN: ::c_int = 75;\npub const _SC_THREAD_THREADS_MAX: ::c_int = 76;\npub const _SC_THREAD_ATTR_STACKADDR: ::c_int = 77;\npub const _SC_THREAD_ATTR_STACKSIZE: ::c_int = 78;\npub const _SC_THREAD_PRIORITY_SCHEDULING: ::c_int = 79;\npub const _SC_THREAD_PRIO_INHERIT: ::c_int = 80;\npub const _SC_THREAD_PRIO_PROTECT: ::c_int = 81;\npub const _SC_THREAD_PROCESS_SHARED: ::c_int = 82;\npub const _SC_NPROCESSORS_CONF: ::c_int = 83;\npub const _SC_NPROCESSORS_ONLN: ::c_int = 84;\npub const _SC_PHYS_PAGES: ::c_int = 85;\npub const _SC_AVPHYS_PAGES: ::c_int = 86;\npub const _SC_ATEXIT_MAX: ::c_int = 87;\npub const _SC_PASS_MAX: ::c_int = 88;\npub const _SC_XOPEN_VERSION: ::c_int = 89;\npub const _SC_XOPEN_XCU_VERSION: ::c_int = 90;\npub const _SC_XOPEN_UNIX: ::c_int = 91;\npub const _SC_XOPEN_CRYPT: ::c_int = 92;\npub const _SC_XOPEN_ENH_I18N: ::c_int = 93;\npub const _SC_XOPEN_SHM: ::c_int = 94;\npub const _SC_2_CHAR_TERM: ::c_int = 95;\npub const _SC_2_UPE: ::c_int = 97;\npub const _SC_XOPEN_XPG2: ::c_int = 98;\npub const _SC_XOPEN_XPG3: ::c_int = 99;\npub const _SC_XOPEN_XPG4: ::c_int = 100;\npub const _SC_NZERO: ::c_int = 109;\npub const _SC_XBS5_ILP32_OFF32: ::c_int = 125;\npub const _SC_XBS5_ILP32_OFFBIG: ::c_int = 126;\npub const _SC_XBS5_LP64_OFF64: ::c_int = 127;\npub const _SC_XBS5_LPBIG_OFFBIG: ::c_int = 128;\npub const _SC_XOPEN_LEGACY: ::c_int = 129;\npub const _SC_XOPEN_REALTIME: ::c_int = 130;\npub const _SC_XOPEN_REALTIME_THREADS: ::c_int = 131;\npub const _SC_ADVISORY_INFO: ::c_int = 132;\npub const _SC_BARRIERS: ::c_int = 133;\npub const _SC_CLOCK_SELECTION: ::c_int = 137;\npub const _SC_CPUTIME: ::c_int = 138;\npub const _SC_THREAD_CPUTIME: ::c_int = 139;\npub const _SC_MONOTONIC_CLOCK: ::c_int = 149;\npub const _SC_READER_WRITER_LOCKS: ::c_int = 153;\npub const _SC_SPIN_LOCKS: ::c_int = 154;\npub const _SC_REGEXP: ::c_int = 155;\npub const _SC_SHELL: ::c_int = 157;\npub const _SC_SPAWN: ::c_int = 159;\npub const _SC_SPORADIC_SERVER: ::c_int = 160;\npub const _SC_THREAD_SPORADIC_SERVER: ::c_int = 161;\npub const _SC_TIMEOUTS: ::c_int = 164;\npub const _SC_TYPED_MEMORY_OBJECTS: ::c_int = 165;\npub const _SC_2_PBS: ::c_int = 168;\npub const _SC_2_PBS_ACCOUNTING: ::c_int = 169;\npub const _SC_2_PBS_LOCATE: ::c_int = 170;\npub const _SC_2_PBS_MESSAGE: ::c_int = 171;\npub const _SC_2_PBS_TRACK: ::c_int = 172;\npub const _SC_SYMLOOP_MAX: ::c_int = 173;\npub const _SC_STREAMS: ::c_int = 174;\npub const _SC_2_PBS_CHECKPOINT: ::c_int = 175;\npub const _SC_V6_ILP32_OFF32: ::c_int = 176;\npub const _SC_V6_ILP32_OFFBIG: ::c_int = 177;\npub const _SC_V6_LP64_OFF64: ::c_int = 178;\npub const _SC_V6_LPBIG_OFFBIG: ::c_int = 179;\npub const _SC_HOST_NAME_MAX: ::c_int = 180;\npub const _SC_TRACE: ::c_int = 181;\npub const _SC_TRACE_EVENT_FILTER: ::c_int = 182;\npub const _SC_TRACE_INHERIT: ::c_int = 183;\npub const _SC_TRACE_LOG: ::c_int = 184;\npub const _SC_IPV6: ::c_int = 235;\npub const _SC_RAW_SOCKETS: ::c_int = 236;\npub const _SC_V7_ILP32_OFF32: ::c_int = 237;\npub const _SC_V7_ILP32_OFFBIG: ::c_int = 238;\npub const _SC_V7_LP64_OFF64: ::c_int = 239;\npub const _SC_V7_LPBIG_OFFBIG: ::c_int = 240;\npub const _SC_SS_REPL_MAX: ::c_int = 241;\npub const _SC_TRACE_EVENT_NAME_MAX: ::c_int = 242;\npub const _SC_TRACE_NAME_MAX: ::c_int = 243;\npub const _SC_TRACE_SYS_MAX: ::c_int = 244;\npub const _SC_TRACE_USER_EVENT_MAX: ::c_int = 245;\npub const _SC_XOPEN_STREAMS: ::c_int = 246;\npub const _SC_THREAD_ROBUST_PRIO_INHERIT: ::c_int = 247;\npub const _SC_THREAD_ROBUST_PRIO_PROTECT: ::c_int = 248;\n\npub const RLIM_SAVED_MAX: ::rlim_t = RLIM_INFINITY;\npub const RLIM_SAVED_CUR: ::rlim_t = RLIM_INFINITY;\n\npub const GLOB_ERR: ::c_int = 1 << 0;\npub const GLOB_MARK: ::c_int = 1 << 1;\npub const GLOB_NOSORT: ::c_int = 1 << 2;\npub const GLOB_DOOFFS: ::c_int = 1 << 3;\npub const GLOB_NOCHECK: ::c_int = 1 << 4;\npub const GLOB_APPEND: ::c_int = 1 << 5;\npub const GLOB_NOESCAPE: ::c_int = 1 << 6;\n\npub const GLOB_NOSPACE: ::c_int = 1;\npub const GLOB_ABORTED: ::c_int = 2;\npub const GLOB_NOMATCH: ::c_int = 3;\n\npub const POSIX_MADV_NORMAL: ::c_int = 0;\npub const POSIX_MADV_RANDOM: ::c_int = 1;\npub const POSIX_MADV_SEQUENTIAL: ::c_int = 2;\npub const POSIX_MADV_WILLNEED: ::c_int = 3;\n\npub const S_IEXEC: mode_t = 64;\npub const S_IWRITE: mode_t = 128;\npub const S_IREAD: mode_t = 256;\n\npub const F_LOCK: ::c_int = 1;\npub const F_TEST: ::c_int = 3;\npub const F_TLOCK: ::c_int = 2;\npub const F_ULOCK: ::c_int = 0;\n\npub const IFF_LOWER_UP: ::c_int = 0x10000;\npub const IFF_DORMANT: ::c_int = 0x20000;\npub const IFF_ECHO: ::c_int = 0x40000;\n\npub const ST_RDONLY: ::c_ulong = 1;\npub const ST_NOSUID: ::c_ulong = 2;\npub const ST_NODEV: ::c_ulong = 4;\npub const ST_NOEXEC: ::c_ulong = 8;\npub const ST_SYNCHRONOUS: ::c_ulong = 16;\npub const ST_MANDLOCK: ::c_ulong = 64;\npub const ST_WRITE: ::c_ulong = 128;\npub const ST_APPEND: ::c_ulong = 256;\npub const ST_IMMUTABLE: ::c_ulong = 512;\npub const ST_NOATIME: ::c_ulong = 1024;\npub const ST_NODIRATIME: ::c_ulong = 2048;\n\npub const RTLD_NEXT: *mut ::c_void = -1i64 as *mut ::c_void;\npub const RTLD_DEFAULT: *mut ::c_void = 0i64 as *mut ::c_void;\npub const RTLD_NODELETE: ::c_int = 0x1000;\npub const RTLD_NOW: ::c_int = 0x2;\n\npub const TCP_MD5SIG: ::c_int = 14;\n\nalign_const! {\n    pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n        size: [0; __SIZEOF_PTHREAD_MUTEX_T],\n    };\n    pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n        size: [0; __SIZEOF_PTHREAD_COND_T],\n    };\n    pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {\n        size: [0; __SIZEOF_PTHREAD_RWLOCK_T],\n    };\n}\npub const PTHREAD_MUTEX_NORMAL: ::c_int = 0;\npub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 1;\npub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = 2;\npub const PTHREAD_MUTEX_DEFAULT: ::c_int = PTHREAD_MUTEX_NORMAL;\npub const PTHREAD_PROCESS_PRIVATE: ::c_int = 0;\npub const PTHREAD_PROCESS_SHARED: ::c_int = 1;\npub const __SIZEOF_PTHREAD_COND_T: usize = 48;\n\npub const RENAME_NOREPLACE: ::c_int = 1;\npub const RENAME_EXCHANGE: ::c_int = 2;\npub const RENAME_WHITEOUT: ::c_int = 4;\n\npub const SCHED_OTHER: ::c_int = 0;\npub const SCHED_FIFO: ::c_int = 1;\npub const SCHED_RR: ::c_int = 2;\npub const SCHED_BATCH: ::c_int = 3;\npub const SCHED_IDLE: ::c_int = 5;\n\n// netinet/in.h\n// NOTE: These are in addition to the constants defined in src/unix/mod.rs\n\n// IPPROTO_IP defined in src/unix/mod.rs\n/// Hop-by-hop option header\npub const IPPROTO_HOPOPTS: ::c_int = 0;\n// IPPROTO_ICMP defined in src/unix/mod.rs\n/// group mgmt protocol\npub const IPPROTO_IGMP: ::c_int = 2;\n/// for compatibility\npub const IPPROTO_IPIP: ::c_int = 4;\n// IPPROTO_TCP defined in src/unix/mod.rs\n/// exterior gateway protocol\npub const IPPROTO_EGP: ::c_int = 8;\n/// pup\npub const IPPROTO_PUP: ::c_int = 12;\n// IPPROTO_UDP defined in src/unix/mod.rs\n/// xns idp\npub const IPPROTO_IDP: ::c_int = 22;\n/// tp-4 w/ class negotiation\npub const IPPROTO_TP: ::c_int = 29;\n/// DCCP\npub const IPPROTO_DCCP: ::c_int = 33;\n// IPPROTO_IPV6 defined in src/unix/mod.rs\n/// IP6 routing header\npub const IPPROTO_ROUTING: ::c_int = 43;\n/// IP6 fragmentation header\npub const IPPROTO_FRAGMENT: ::c_int = 44;\n/// resource reservation\npub const IPPROTO_RSVP: ::c_int = 46;\n/// General Routing Encap.\npub const IPPROTO_GRE: ::c_int = 47;\n/// IP6 Encap Sec. Payload\npub const IPPROTO_ESP: ::c_int = 50;\n/// IP6 Auth Header\npub const IPPROTO_AH: ::c_int = 51;\n// IPPROTO_ICMPV6 defined in src/unix/mod.rs\n/// IP6 no next header\npub const IPPROTO_NONE: ::c_int = 59;\n/// IP6 destination option\npub const IPPROTO_DSTOPTS: ::c_int = 60;\npub const IPPROTO_MTP: ::c_int = 92;\npub const IPPROTO_BEETPH: ::c_int = 94;\n/// encapsulation header\npub const IPPROTO_ENCAP: ::c_int = 98;\n/// Protocol indep. multicast\npub const IPPROTO_PIM: ::c_int = 103;\n/// IP Payload Comp. Protocol\npub const IPPROTO_COMP: ::c_int = 108;\n/// SCTP\npub const IPPROTO_SCTP: ::c_int = 132;\npub const IPPROTO_MH: ::c_int = 135;\npub const IPPROTO_UDPLITE: ::c_int = 136;\npub const IPPROTO_MPLS: ::c_int = 137;\n/// raw IP packet\npub const IPPROTO_RAW: ::c_int = 255;\npub const IPPROTO_MAX: ::c_int = 256;\n\npub const AF_IB: ::c_int = 27;\npub const AF_MPLS: ::c_int = 28;\npub const AF_NFC: ::c_int = 39;\npub const AF_VSOCK: ::c_int = 40;\npub const PF_IB: ::c_int = AF_IB;\npub const PF_MPLS: ::c_int = AF_MPLS;\npub const PF_NFC: ::c_int = AF_NFC;\npub const PF_VSOCK: ::c_int = AF_VSOCK;\n\n// System V IPC\npub const IPC_PRIVATE: ::key_t = 0;\n\npub const IPC_CREAT: ::c_int = 0o1000;\npub const IPC_EXCL: ::c_int = 0o2000;\npub const IPC_NOWAIT: ::c_int = 0o4000;\n\npub const IPC_RMID: ::c_int = 0;\npub const IPC_SET: ::c_int = 1;\npub const IPC_STAT: ::c_int = 2;\npub const IPC_INFO: ::c_int = 3;\npub const MSG_STAT: ::c_int = 11;\npub const MSG_INFO: ::c_int = 12;\n\npub const MSG_NOERROR: ::c_int = 0o10000;\npub const MSG_EXCEPT: ::c_int = 0o20000;\npub const MSG_COPY: ::c_int = 0o40000;\n\npub const SHM_R: ::c_int = 0o400;\npub const SHM_W: ::c_int = 0o200;\n\npub const SHM_RDONLY: ::c_int = 0o10000;\npub const SHM_RND: ::c_int = 0o20000;\npub const SHM_REMAP: ::c_int = 0o40000;\npub const SHM_EXEC: ::c_int = 0o100000;\n\npub const SHM_LOCK: ::c_int = 11;\npub const SHM_UNLOCK: ::c_int = 12;\n\npub const SHM_HUGETLB: ::c_int = 0o4000;\npub const SHM_NORESERVE: ::c_int = 0o10000;\n\npub const EPOLLRDHUP: ::c_int = 0x2000;\npub const EPOLLEXCLUSIVE: ::c_int = 0x10000000;\npub const EPOLLONESHOT: ::c_int = 0x40000000;\n\npub const QFMT_VFS_OLD: ::c_int = 1;\npub const QFMT_VFS_V0: ::c_int = 2;\npub const QFMT_VFS_V1: ::c_int = 4;\n\npub const EFD_SEMAPHORE: ::c_int = 0x1;\n\npub const LOG_NFACILITIES: ::c_int = 24;\n\npub const SEM_FAILED: *mut ::sem_t = 0 as *mut sem_t;\n\npub const RB_AUTOBOOT: ::c_int = 0x01234567u32 as i32;\npub const RB_HALT_SYSTEM: ::c_int = 0xcdef0123u32 as i32;\npub const RB_ENABLE_CAD: ::c_int = 0x89abcdefu32 as i32;\npub const RB_DISABLE_CAD: ::c_int = 0x00000000u32 as i32;\npub const RB_POWER_OFF: ::c_int = 0x4321fedcu32 as i32;\npub const RB_SW_SUSPEND: ::c_int = 0xd000fce2u32 as i32;\npub const RB_KEXEC: ::c_int = 0x45584543u32 as i32;\n\npub const AI_PASSIVE: ::c_int = 0x0001;\npub const AI_CANONNAME: ::c_int = 0x0002;\npub const AI_NUMERICHOST: ::c_int = 0x0004;\npub const AI_V4MAPPED: ::c_int = 0x0008;\npub const AI_ALL: ::c_int = 0x0010;\npub const AI_ADDRCONFIG: ::c_int = 0x0020;\n\npub const AI_NUMERICSERV: ::c_int = 0x0400;\n\npub const EAI_BADFLAGS: ::c_int = -1;\npub const EAI_NONAME: ::c_int = -2;\npub const EAI_AGAIN: ::c_int = -3;\npub const EAI_FAIL: ::c_int = -4;\npub const EAI_FAMILY: ::c_int = -6;\npub const EAI_SOCKTYPE: ::c_int = -7;\npub const EAI_SERVICE: ::c_int = -8;\npub const EAI_MEMORY: ::c_int = -10;\npub const EAI_OVERFLOW: ::c_int = -12;\n\npub const NI_NUMERICHOST: ::c_int = 1;\npub const NI_NUMERICSERV: ::c_int = 2;\npub const NI_NOFQDN: ::c_int = 4;\npub const NI_NAMEREQD: ::c_int = 8;\npub const NI_DGRAM: ::c_int = 16;\n\npub const SYNC_FILE_RANGE_WAIT_BEFORE: ::c_uint = 1;\npub const SYNC_FILE_RANGE_WRITE: ::c_uint = 2;\npub const SYNC_FILE_RANGE_WAIT_AFTER: ::c_uint = 4;\n\npub const EAI_SYSTEM: ::c_int = -11;\n\npub const AIO_CANCELED: ::c_int = 0;\npub const AIO_NOTCANCELED: ::c_int = 1;\npub const AIO_ALLDONE: ::c_int = 2;\npub const LIO_READ: ::c_int = 0;\npub const LIO_WRITE: ::c_int = 1;\npub const LIO_NOP: ::c_int = 2;\npub const LIO_WAIT: ::c_int = 0;\npub const LIO_NOWAIT: ::c_int = 1;\n\npub const MREMAP_MAYMOVE: ::c_int = 1;\npub const MREMAP_FIXED: ::c_int = 2;\n\npub const PR_SET_PDEATHSIG: ::c_int = 1;\npub const PR_GET_PDEATHSIG: ::c_int = 2;\n\npub const PR_GET_DUMPABLE: ::c_int = 3;\npub const PR_SET_DUMPABLE: ::c_int = 4;\n\npub const PR_GET_UNALIGN: ::c_int = 5;\npub const PR_SET_UNALIGN: ::c_int = 6;\npub const PR_UNALIGN_NOPRINT: ::c_int = 1;\npub const PR_UNALIGN_SIGBUS: ::c_int = 2;\n\npub const PR_GET_KEEPCAPS: ::c_int = 7;\npub const PR_SET_KEEPCAPS: ::c_int = 8;\n\npub const PR_GET_FPEMU: ::c_int = 9;\npub const PR_SET_FPEMU: ::c_int = 10;\npub const PR_FPEMU_NOPRINT: ::c_int = 1;\npub const PR_FPEMU_SIGFPE: ::c_int = 2;\n\npub const PR_GET_FPEXC: ::c_int = 11;\npub const PR_SET_FPEXC: ::c_int = 12;\npub const PR_FP_EXC_SW_ENABLE: ::c_int = 0x80;\npub const PR_FP_EXC_DIV: ::c_int = 0x010000;\npub const PR_FP_EXC_OVF: ::c_int = 0x020000;\npub const PR_FP_EXC_UND: ::c_int = 0x040000;\npub const PR_FP_EXC_RES: ::c_int = 0x080000;\npub const PR_FP_EXC_INV: ::c_int = 0x100000;\npub const PR_FP_EXC_DISABLED: ::c_int = 0;\npub const PR_FP_EXC_NONRECOV: ::c_int = 1;\npub const PR_FP_EXC_ASYNC: ::c_int = 2;\npub const PR_FP_EXC_PRECISE: ::c_int = 3;\n\npub const PR_GET_TIMING: ::c_int = 13;\npub const PR_SET_TIMING: ::c_int = 14;\npub const PR_TIMING_STATISTICAL: ::c_int = 0;\npub const PR_TIMING_TIMESTAMP: ::c_int = 1;\n\npub const PR_SET_NAME: ::c_int = 15;\npub const PR_GET_NAME: ::c_int = 16;\n\npub const PR_GET_ENDIAN: ::c_int = 19;\npub const PR_SET_ENDIAN: ::c_int = 20;\npub const PR_ENDIAN_BIG: ::c_int = 0;\npub const PR_ENDIAN_LITTLE: ::c_int = 1;\npub const PR_ENDIAN_PPC_LITTLE: ::c_int = 2;\n\npub const PR_GET_SECCOMP: ::c_int = 21;\npub const PR_SET_SECCOMP: ::c_int = 22;\n\npub const PR_CAPBSET_READ: ::c_int = 23;\npub const PR_CAPBSET_DROP: ::c_int = 24;\n\npub const PR_GET_TSC: ::c_int = 25;\npub const PR_SET_TSC: ::c_int = 26;\npub const PR_TSC_ENABLE: ::c_int = 1;\npub const PR_TSC_SIGSEGV: ::c_int = 2;\n\npub const PR_GET_SECUREBITS: ::c_int = 27;\npub const PR_SET_SECUREBITS: ::c_int = 28;\n\npub const PR_SET_TIMERSLACK: ::c_int = 29;\npub const PR_GET_TIMERSLACK: ::c_int = 30;\n\npub const PR_TASK_PERF_EVENTS_DISABLE: ::c_int = 31;\npub const PR_TASK_PERF_EVENTS_ENABLE: ::c_int = 32;\n\npub const PR_MCE_KILL: ::c_int = 33;\npub const PR_MCE_KILL_CLEAR: ::c_int = 0;\npub const PR_MCE_KILL_SET: ::c_int = 1;\n\npub const PR_MCE_KILL_LATE: ::c_int = 0;\npub const PR_MCE_KILL_EARLY: ::c_int = 1;\npub const PR_MCE_KILL_DEFAULT: ::c_int = 2;\n\npub const PR_MCE_KILL_GET: ::c_int = 34;\n\npub const PR_SET_MM: ::c_int = 35;\npub const PR_SET_MM_START_CODE: ::c_int = 1;\npub const PR_SET_MM_END_CODE: ::c_int = 2;\npub const PR_SET_MM_START_DATA: ::c_int = 3;\npub const PR_SET_MM_END_DATA: ::c_int = 4;\npub const PR_SET_MM_START_STACK: ::c_int = 5;\npub const PR_SET_MM_START_BRK: ::c_int = 6;\npub const PR_SET_MM_BRK: ::c_int = 7;\npub const PR_SET_MM_ARG_START: ::c_int = 8;\npub const PR_SET_MM_ARG_END: ::c_int = 9;\npub const PR_SET_MM_ENV_START: ::c_int = 10;\npub const PR_SET_MM_ENV_END: ::c_int = 11;\npub const PR_SET_MM_AUXV: ::c_int = 12;\npub const PR_SET_MM_EXE_FILE: ::c_int = 13;\npub const PR_SET_MM_MAP: ::c_int = 14;\npub const PR_SET_MM_MAP_SIZE: ::c_int = 15;\n\npub const PR_SET_PTRACER: ::c_int = 0x59616d61;\n\npub const PR_SET_CHILD_SUBREAPER: ::c_int = 36;\npub const PR_GET_CHILD_SUBREAPER: ::c_int = 37;\n\npub const PR_SET_NO_NEW_PRIVS: ::c_int = 38;\npub const PR_GET_NO_NEW_PRIVS: ::c_int = 39;\n\npub const PR_GET_TID_ADDRESS: ::c_int = 40;\n\npub const PR_SET_THP_DISABLE: ::c_int = 41;\npub const PR_GET_THP_DISABLE: ::c_int = 42;\n\npub const PR_MPX_ENABLE_MANAGEMENT: ::c_int = 43;\npub const PR_MPX_DISABLE_MANAGEMENT: ::c_int = 44;\n\npub const PR_SET_FP_MODE: ::c_int = 45;\npub const PR_GET_FP_MODE: ::c_int = 46;\npub const PR_FP_MODE_FR: ::c_int = 1 << 0;\npub const PR_FP_MODE_FRE: ::c_int = 1 << 1;\n\npub const PR_CAP_AMBIENT: ::c_int = 47;\npub const PR_CAP_AMBIENT_IS_SET: ::c_int = 1;\npub const PR_CAP_AMBIENT_RAISE: ::c_int = 2;\npub const PR_CAP_AMBIENT_LOWER: ::c_int = 3;\npub const PR_CAP_AMBIENT_CLEAR_ALL: ::c_int = 4;\n\npub const ITIMER_REAL: ::c_int = 0;\npub const ITIMER_VIRTUAL: ::c_int = 1;\npub const ITIMER_PROF: ::c_int = 2;\n\npub const TFD_CLOEXEC: ::c_int = O_CLOEXEC;\npub const TFD_NONBLOCK: ::c_int = O_NONBLOCK;\npub const TFD_TIMER_ABSTIME: ::c_int = 1;\n\npub const XATTR_CREATE: ::c_int = 0x1;\npub const XATTR_REPLACE: ::c_int = 0x2;\n\npub const _POSIX_VDISABLE: ::cc_t = 0;\n\npub const FALLOC_FL_KEEP_SIZE: ::c_int = 0x01;\npub const FALLOC_FL_PUNCH_HOLE: ::c_int = 0x02;\npub const FALLOC_FL_COLLAPSE_RANGE: ::c_int = 0x08;\npub const FALLOC_FL_ZERO_RANGE: ::c_int = 0x10;\npub const FALLOC_FL_INSERT_RANGE: ::c_int = 0x20;\npub const FALLOC_FL_UNSHARE_RANGE: ::c_int = 0x40;\n\n// On Linux, libc doesn't define this constant, libattr does instead.\n// We still define it for Linux as it's defined by libc on other platforms,\n// and it's mentioned in the man pages for getxattr and setxattr.\npub const ENOATTR: ::c_int = ::ENODATA;\n\npub const SO_ORIGINAL_DST: ::c_int = 80;\npub const IUTF8: ::tcflag_t = 0x00004000;\npub const CMSPAR: ::tcflag_t = 0o10000000000;\n\npub const MFD_CLOEXEC: ::c_uint = 0x0001;\npub const MFD_ALLOW_SEALING: ::c_uint = 0x0002;\n\n// these are used in the p_type field of Elf32_Phdr and Elf64_Phdr, which has\n// the type Elf32Word and Elf64Word respectively. Luckily, both of those are u32\n// so we can use that type here to avoid having to cast.\npub const PT_NULL: u32 = 0;\npub const PT_LOAD: u32 = 1;\npub const PT_DYNAMIC: u32 = 2;\npub const PT_INTERP: u32 = 3;\npub const PT_NOTE: u32 = 4;\npub const PT_SHLIB: u32 = 5;\npub const PT_PHDR: u32 = 6;\npub const PT_TLS: u32 = 7;\npub const PT_NUM: u32 = 8;\npub const PT_LOOS: u32 = 0x60000000;\npub const PT_GNU_EH_FRAME: u32 = 0x6474e550;\npub const PT_GNU_STACK: u32 = 0x6474e551;\npub const PT_GNU_RELRO: u32 = 0x6474e552;\n\npub const SFD_CLOEXEC: ::c_int = 0x080000;\n\npub const NCCS: usize = 32;\n\npub const O_TRUNC: ::c_int = 0x00040000;\npub const O_NOATIME: ::c_int = 0x00002000;\npub const O_CLOEXEC: ::c_int = 0x00000100;\npub const O_TMPFILE: ::c_int = 0x00004000;\n\npub const EBFONT: ::c_int = 59;\npub const ENOSTR: ::c_int = 60;\npub const ENODATA: ::c_int = 61;\npub const ETIME: ::c_int = 62;\npub const ENOSR: ::c_int = 63;\npub const ENONET: ::c_int = 64;\npub const ENOPKG: ::c_int = 65;\npub const EREMOTE: ::c_int = 66;\npub const ENOLINK: ::c_int = 67;\npub const EADV: ::c_int = 68;\npub const ESRMNT: ::c_int = 69;\npub const ECOMM: ::c_int = 70;\npub const EPROTO: ::c_int = 71;\npub const EDOTDOT: ::c_int = 73;\n\npub const SA_NODEFER: ::c_int = 0x40000000;\npub const SA_RESETHAND: ::c_int = 0x80000000;\npub const SA_RESTART: ::c_int = 0x10000000;\npub const SA_NOCLDSTOP: ::c_int = 0x00000001;\n\npub const EPOLL_CLOEXEC: ::c_int = 0x80000;\n\npub const EFD_CLOEXEC: ::c_int = 0x80000;\n\npub const BUFSIZ: ::c_uint = 1024;\npub const TMP_MAX: ::c_uint = 10000;\npub const FOPEN_MAX: ::c_uint = 1000;\npub const O_PATH: ::c_int = 0x00400000;\npub const O_EXEC: ::c_int = O_PATH;\npub const O_SEARCH: ::c_int = O_PATH;\npub const O_ACCMODE: ::c_int = 03 | O_SEARCH;\npub const O_NDELAY: ::c_int = O_NONBLOCK;\npub const NI_MAXHOST: ::socklen_t = 255;\npub const PTHREAD_STACK_MIN: ::size_t = 2048;\npub const POSIX_FADV_DONTNEED: ::c_int = 4;\npub const POSIX_FADV_NOREUSE: ::c_int = 5;\n\npub const POSIX_MADV_DONTNEED: ::c_int = 4;\n\npub const RLIM_INFINITY: ::rlim_t = !0;\npub const RLIMIT_RTTIME: ::c_int = 15;\npub const RLIMIT_NLIMITS: ::c_int = 16;\npub const RLIM_NLIMITS: ::c_int = RLIMIT_NLIMITS;\n\npub const MAP_ANONYMOUS: ::c_int = MAP_ANON;\n\npub const SOCK_DCCP: ::c_int = 6;\npub const SOCK_PACKET: ::c_int = 10;\n\npub const TCP_COOKIE_TRANSACTIONS: ::c_int = 15;\npub const TCP_THIN_LINEAR_TIMEOUTS: ::c_int = 16;\npub const TCP_THIN_DUPACK: ::c_int = 17;\npub const TCP_USER_TIMEOUT: ::c_int = 18;\npub const TCP_REPAIR: ::c_int = 19;\npub const TCP_REPAIR_QUEUE: ::c_int = 20;\npub const TCP_QUEUE_SEQ: ::c_int = 21;\npub const TCP_REPAIR_OPTIONS: ::c_int = 22;\npub const TCP_FASTOPEN: ::c_int = 23;\npub const TCP_TIMESTAMP: ::c_int = 24;\n\npub const SIGUNUSED: ::c_int = ::SIGSYS;\n\npub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;\npub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;\npub const __SIZEOF_PTHREAD_RWLOCKATTR_T: usize = 8;\n\npub const CPU_SETSIZE: ::c_int = 128;\n\npub const PTRACE_TRACEME: ::c_int = 0;\npub const PTRACE_PEEKTEXT: ::c_int = 1;\npub const PTRACE_PEEKDATA: ::c_int = 2;\npub const PTRACE_PEEKUSER: ::c_int = 3;\npub const PTRACE_POKETEXT: ::c_int = 4;\npub const PTRACE_POKEDATA: ::c_int = 5;\npub const PTRACE_POKEUSER: ::c_int = 6;\npub const PTRACE_CONT: ::c_int = 7;\npub const PTRACE_KILL: ::c_int = 8;\npub const PTRACE_SINGLESTEP: ::c_int = 9;\npub const PTRACE_GETREGS: ::c_int = 12;\npub const PTRACE_SETREGS: ::c_int = 13;\npub const PTRACE_GETFPREGS: ::c_int = 14;\npub const PTRACE_SETFPREGS: ::c_int = 15;\npub const PTRACE_ATTACH: ::c_int = 16;\npub const PTRACE_DETACH: ::c_int = 17;\npub const PTRACE_GETFPXREGS: ::c_int = 18;\npub const PTRACE_SETFPXREGS: ::c_int = 19;\npub const PTRACE_SYSCALL: ::c_int = 24;\npub const PTRACE_SETOPTIONS: ::c_int = 0x4200;\npub const PTRACE_GETEVENTMSG: ::c_int = 0x4201;\npub const PTRACE_GETSIGINFO: ::c_int = 0x4202;\npub const PTRACE_SETSIGINFO: ::c_int = 0x4203;\npub const PTRACE_GETREGSET: ::c_int = 0x4204;\npub const PTRACE_SETREGSET: ::c_int = 0x4205;\npub const PTRACE_SEIZE: ::c_int = 0x4206;\npub const PTRACE_INTERRUPT: ::c_int = 0x4207;\npub const PTRACE_LISTEN: ::c_int = 0x4208;\npub const PTRACE_PEEKSIGINFO: ::c_int = 0x4209;\n\npub const EPOLLWAKEUP: ::c_int = 0x20000000;\n\npub const EFD_NONBLOCK: ::c_int = ::O_NONBLOCK;\n\npub const SFD_NONBLOCK: ::c_int = ::O_NONBLOCK;\n\npub const TCSANOW: ::c_int = 0;\npub const TCSADRAIN: ::c_int = 1;\npub const TCSAFLUSH: ::c_int = 2;\n\npub const TIOCINQ: ::c_int = ::FIONREAD;\n\npub const RTLD_GLOBAL: ::c_int = 0x100;\npub const RTLD_NOLOAD: ::c_int = 0x4;\n\npub const MCL_CURRENT: ::c_int = 0x0001;\npub const MCL_FUTURE: ::c_int = 0x0002;\n\npub const CBAUD: ::tcflag_t = 0o0010017;\npub const TAB1: ::c_int = 0x00000800;\npub const TAB2: ::c_int = 0x00001000;\npub const TAB3: ::c_int = 0x00001800;\npub const CR1: ::c_int = 0x00000200;\npub const CR2: ::c_int = 0x00000400;\npub const CR3: ::c_int = 0x00000600;\npub const FF1: ::c_int = 0x00008000;\npub const BS1: ::c_int = 0x00002000;\npub const VT1: ::c_int = 0x00004000;\npub const VWERASE: usize = 14;\npub const VREPRINT: usize = 12;\npub const VSUSP: usize = 10;\npub const VSTART: usize = 8;\npub const VSTOP: usize = 9;\npub const VDISCARD: usize = 13;\npub const VTIME: usize = 5;\npub const IXON: ::tcflag_t = 0x00000400;\npub const IXOFF: ::tcflag_t = 0x00001000;\npub const ONLCR: ::tcflag_t = 0x4;\npub const CSIZE: ::tcflag_t = 0x00000030;\npub const CS6: ::tcflag_t = 0x00000010;\npub const CS7: ::tcflag_t = 0x00000020;\npub const CS8: ::tcflag_t = 0x00000030;\npub const CSTOPB: ::tcflag_t = 0x00000040;\npub const CREAD: ::tcflag_t = 0x00000080;\npub const PARENB: ::tcflag_t = 0x00000100;\npub const PARODD: ::tcflag_t = 0x00000200;\npub const HUPCL: ::tcflag_t = 0x00000400;\npub const CLOCAL: ::tcflag_t = 0x00000800;\npub const ECHOKE: ::tcflag_t = 0x00000800;\npub const ECHOE: ::tcflag_t = 0x00000010;\npub const ECHOK: ::tcflag_t = 0x00000020;\npub const ECHONL: ::tcflag_t = 0x00000040;\npub const ECHOPRT: ::tcflag_t = 0x00000400;\npub const ECHOCTL: ::tcflag_t = 0x00000200;\npub const ISIG: ::tcflag_t = 0x00000001;\npub const ICANON: ::tcflag_t = 0x00000002;\npub const PENDIN: ::tcflag_t = 0x00004000;\npub const NOFLSH: ::tcflag_t = 0x00000080;\npub const CIBAUD: ::tcflag_t = 0o02003600000;\npub const CBAUDEX: ::tcflag_t = 0o010000;\npub const VSWTC: usize = 7;\npub const OLCUC: ::tcflag_t = 0o000002;\npub const NLDLY: ::tcflag_t = 0o000400;\npub const CRDLY: ::tcflag_t = 0o003000;\npub const TABDLY: ::tcflag_t = 0o014000;\npub const BSDLY: ::tcflag_t = 0o020000;\npub const FFDLY: ::tcflag_t = 0o100000;\npub const VTDLY: ::tcflag_t = 0o040000;\npub const XTABS: ::tcflag_t = 0o014000;\n\npub const B0: ::speed_t = 0o000000;\npub const B50: ::speed_t = 0o000001;\npub const B75: ::speed_t = 0o000002;\npub const B110: ::speed_t = 0o000003;\npub const B134: ::speed_t = 0o000004;\npub const B150: ::speed_t = 0o000005;\npub const B200: ::speed_t = 0o000006;\npub const B300: ::speed_t = 0o000007;\npub const B600: ::speed_t = 0o000010;\npub const B1200: ::speed_t = 0o000011;\npub const B1800: ::speed_t = 0o000012;\npub const B2400: ::speed_t = 0o000013;\npub const B4800: ::speed_t = 0o000014;\npub const B9600: ::speed_t = 0o000015;\npub const B19200: ::speed_t = 0o000016;\npub const B38400: ::speed_t = 0o000017;\npub const EXTA: ::speed_t = B19200;\npub const EXTB: ::speed_t = B38400;\npub const B57600: ::speed_t = 0o010001;\npub const B115200: ::speed_t = 0o010002;\npub const B230400: ::speed_t = 0o010003;\npub const B460800: ::speed_t = 0o010004;\npub const B500000: ::speed_t = 0o010005;\npub const B576000: ::speed_t = 0o010006;\npub const B921600: ::speed_t = 0o010007;\npub const B1000000: ::speed_t = 0o010010;\npub const B1152000: ::speed_t = 0o010011;\npub const B1500000: ::speed_t = 0o010012;\npub const B2000000: ::speed_t = 0o010013;\npub const B2500000: ::speed_t = 0o010014;\npub const B3000000: ::speed_t = 0o010015;\npub const B3500000: ::speed_t = 0o010016;\npub const B4000000: ::speed_t = 0o010017;\n\npub const SO_BINDTODEVICE: ::c_int = 25;\npub const SO_TIMESTAMP: ::c_int = 29;\npub const SO_MARK: ::c_int = 36;\npub const SO_RXQ_OVFL: ::c_int = 40;\npub const SO_PEEK_OFF: ::c_int = 42;\npub const SO_BUSY_POLL: ::c_int = 46;\n\npub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;\npub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;\n\npub const O_ASYNC: ::c_int = 0x00000400;\n\npub const FIOCLEX: ::c_int = 0x5451;\npub const FIONBIO: ::c_int = 0x5421;\n\npub const RLIMIT_RSS: ::c_int = 5;\npub const RLIMIT_NOFILE: ::c_int = 7;\npub const RLIMIT_AS: ::c_int = 9;\npub const RLIMIT_NPROC: ::c_int = 6;\npub const RLIMIT_MEMLOCK: ::c_int = 8;\n\npub const O_APPEND: ::c_int = 0x00100000;\npub const O_CREAT: ::c_int = 0x00010000;\npub const O_EXCL: ::c_int = 0x00020000;\npub const O_NOCTTY: ::c_int = 0x00000200;\npub const O_NONBLOCK: ::c_int = 0x00000010;\npub const O_SYNC: ::c_int = 0x00000040 | O_DSYNC;\npub const O_RSYNC: ::c_int = O_SYNC;\npub const O_DSYNC: ::c_int = 0x00000020;\n\npub const SOCK_CLOEXEC: ::c_int = 0o2000000;\npub const SOCK_NONBLOCK: ::c_int = 0o4000;\n\npub const MAP_ANON: ::c_int = 0x0020;\npub const MAP_GROWSDOWN: ::c_int = 0x0100;\npub const MAP_DENYWRITE: ::c_int = 0x0800;\npub const MAP_EXECUTABLE: ::c_int = 0x01000;\npub const MAP_LOCKED: ::c_int = 0x02000;\npub const MAP_NORESERVE: ::c_int = 0x04000;\npub const MAP_POPULATE: ::c_int = 0x08000;\npub const MAP_NONBLOCK: ::c_int = 0x010000;\npub const MAP_STACK: ::c_int = 0x020000;\n\npub const SOCK_STREAM: ::c_int = 1;\npub const SOCK_DGRAM: ::c_int = 2;\npub const SOCK_SEQPACKET: ::c_int = 5;\n\npub const SOL_SOCKET: ::c_int = 1;\n\npub const EDEADLK: ::c_int = 35;\npub const ENAMETOOLONG: ::c_int = 36;\npub const ENOLCK: ::c_int = 37;\npub const ENOSYS: ::c_int = 38;\npub const ENOTEMPTY: ::c_int = 39;\npub const ELOOP: ::c_int = 40;\npub const ENOMSG: ::c_int = 42;\npub const EIDRM: ::c_int = 43;\npub const ECHRNG: ::c_int = 44;\npub const EL2NSYNC: ::c_int = 45;\npub const EL3HLT: ::c_int = 46;\npub const EL3RST: ::c_int = 47;\npub const ELNRNG: ::c_int = 48;\npub const EUNATCH: ::c_int = 49;\npub const ENOCSI: ::c_int = 50;\npub const EL2HLT: ::c_int = 51;\npub const EBADE: ::c_int = 52;\npub const EBADR: ::c_int = 53;\npub const EXFULL: ::c_int = 54;\npub const ENOANO: ::c_int = 55;\npub const EBADRQC: ::c_int = 56;\npub const EBADSLT: ::c_int = 57;\npub const EDEADLOCK: ::c_int = EDEADLK;\npub const EMULTIHOP: ::c_int = 72;\npub const EBADMSG: ::c_int = 74;\npub const EOVERFLOW: ::c_int = 75;\npub const ENOTUNIQ: ::c_int = 76;\npub const EBADFD: ::c_int = 77;\npub const EREMCHG: ::c_int = 78;\npub const ELIBACC: ::c_int = 79;\npub const ELIBBAD: ::c_int = 80;\npub const ELIBSCN: ::c_int = 81;\npub const ELIBMAX: ::c_int = 82;\npub const ELIBEXEC: ::c_int = 83;\npub const EILSEQ: ::c_int = 84;\npub const ERESTART: ::c_int = 85;\npub const ESTRPIPE: ::c_int = 86;\npub const EUSERS: ::c_int = 87;\npub const ENOTSOCK: ::c_int = 88;\npub const EDESTADDRREQ: ::c_int = 89;\npub const EMSGSIZE: ::c_int = 90;\npub const EPROTOTYPE: ::c_int = 91;\npub const ENOPROTOOPT: ::c_int = 92;\npub const EPROTONOSUPPORT: ::c_int = 93;\npub const ESOCKTNOSUPPORT: ::c_int = 94;\npub const EOPNOTSUPP: ::c_int = 95;\npub const ENOTSUP: ::c_int = EOPNOTSUPP;\npub const EPFNOSUPPORT: ::c_int = 96;\npub const EAFNOSUPPORT: ::c_int = 97;\npub const EADDRINUSE: ::c_int = 98;\npub const EADDRNOTAVAIL: ::c_int = 99;\npub const ENETDOWN: ::c_int = 100;\npub const ENETUNREACH: ::c_int = 101;\npub const ENETRESET: ::c_int = 102;\npub const ECONNABORTED: ::c_int = 103;\npub const ECONNRESET: ::c_int = 104;\npub const ENOBUFS: ::c_int = 105;\npub const EISCONN: ::c_int = 106;\npub const ENOTCONN: ::c_int = 107;\npub const ESHUTDOWN: ::c_int = 108;\npub const ETOOMANYREFS: ::c_int = 109;\npub const ETIMEDOUT: ::c_int = 110;\npub const ECONNREFUSED: ::c_int = 111;\npub const EHOSTDOWN: ::c_int = 112;\npub const EHOSTUNREACH: ::c_int = 113;\npub const EALREADY: ::c_int = 114;\npub const EINPROGRESS: ::c_int = 115;\npub const ESTALE: ::c_int = 116;\npub const EUCLEAN: ::c_int = 117;\npub const ENOTNAM: ::c_int = 118;\npub const ENAVAIL: ::c_int = 119;\npub const EISNAM: ::c_int = 120;\npub const EREMOTEIO: ::c_int = 121;\npub const EDQUOT: ::c_int = 122;\npub const ENOMEDIUM: ::c_int = 123;\npub const EMEDIUMTYPE: ::c_int = 124;\npub const ECANCELED: ::c_int = 125;\npub const ENOKEY: ::c_int = 126;\npub const EKEYEXPIRED: ::c_int = 127;\npub const EKEYREVOKED: ::c_int = 128;\npub const EKEYREJECTED: ::c_int = 129;\npub const EOWNERDEAD: ::c_int = 130;\npub const ENOTRECOVERABLE: ::c_int = 131;\npub const ERFKILL: ::c_int = 132;\npub const EHWPOISON: ::c_int = 133;\n\npub const SO_REUSEADDR: ::c_int = 2;\npub const SO_TYPE: ::c_int = 3;\npub const SO_ERROR: ::c_int = 4;\npub const SO_DONTROUTE: ::c_int = 5;\npub const SO_BROADCAST: ::c_int = 6;\npub const SO_SNDBUF: ::c_int = 7;\npub const SO_RCVBUF: ::c_int = 8;\npub const SO_KEEPALIVE: ::c_int = 9;\npub const SO_OOBINLINE: ::c_int = 10;\npub const SO_NO_CHECK: ::c_int = 11;\npub const SO_PRIORITY: ::c_int = 12;\npub const SO_LINGER: ::c_int = 13;\npub const SO_BSDCOMPAT: ::c_int = 14;\npub const SO_REUSEPORT: ::c_int = 15;\npub const SO_PASSCRED: ::c_int = 16;\npub const SO_PEERCRED: ::c_int = 17;\npub const SO_RCVLOWAT: ::c_int = 18;\npub const SO_SNDLOWAT: ::c_int = 19;\npub const SO_RCVTIMEO: ::c_int = 20;\npub const SO_SNDTIMEO: ::c_int = 21;\npub const SO_ACCEPTCONN: ::c_int = 30;\npub const SO_SNDBUFFORCE: ::c_int = 32;\npub const SO_RCVBUFFORCE: ::c_int = 33;\npub const SO_PROTOCOL: ::c_int = 38;\npub const SO_DOMAIN: ::c_int = 39;\n\npub const SA_ONSTACK: ::c_int = 0x08000000;\npub const SA_SIGINFO: ::c_int = 0x00000004;\npub const SA_NOCLDWAIT: ::c_int = 0x00000002;\n\npub const SIGCHLD: ::c_int = 17;\npub const SIGBUS: ::c_int = 7;\npub const SIGTTIN: ::c_int = 21;\npub const SIGTTOU: ::c_int = 22;\npub const SIGXCPU: ::c_int = 24;\npub const SIGXFSZ: ::c_int = 25;\npub const SIGVTALRM: ::c_int = 26;\npub const SIGPROF: ::c_int = 27;\npub const SIGWINCH: ::c_int = 28;\npub const SIGUSR1: ::c_int = 10;\npub const SIGUSR2: ::c_int = 12;\npub const SIGCONT: ::c_int = 18;\npub const SIGSTOP: ::c_int = 19;\npub const SIGTSTP: ::c_int = 20;\npub const SIGURG: ::c_int = 23;\npub const SIGIO: ::c_int = 29;\npub const SIGSYS: ::c_int = 31;\npub const SIGSTKFLT: ::c_int = 16;\npub const SIGPOLL: ::c_int = 29;\npub const SIGPWR: ::c_int = 30;\npub const SIG_SETMASK: ::c_int = 2;\npub const SIG_BLOCK: ::c_int = 0x000000;\npub const SIG_UNBLOCK: ::c_int = 0x01;\n\npub const EXTPROC: ::tcflag_t = 0x00010000;\n\npub const MAP_HUGETLB: ::c_int = 0x040000;\n\npub const F_GETLK: ::c_int = 5;\npub const F_GETOWN: ::c_int = 9;\npub const F_SETLK: ::c_int = 6;\npub const F_SETLKW: ::c_int = 7;\npub const F_SETOWN: ::c_int = 8;\n\npub const VEOF: usize = 4;\npub const VEOL: usize = 11;\npub const VEOL2: usize = 16;\npub const VMIN: usize = 6;\npub const IEXTEN: ::tcflag_t = 0x00008000;\npub const TOSTOP: ::tcflag_t = 0x00000100;\npub const FLUSHO: ::tcflag_t = 0x00001000;\n\npub const TCGETS: ::c_int = 0x5401;\npub const TCSETS: ::c_int = 0x5402;\npub const TCSETSW: ::c_int = 0x5403;\npub const TCSETSF: ::c_int = 0x5404;\npub const TCGETA: ::c_int = 0x5405;\npub const TCSETA: ::c_int = 0x5406;\npub const TCSETAW: ::c_int = 0x5407;\npub const TCSETAF: ::c_int = 0x5408;\npub const TCSBRK: ::c_int = 0x5409;\npub const TCXONC: ::c_int = 0x540A;\npub const TCFLSH: ::c_int = 0x540B;\npub const TIOCGSOFTCAR: ::c_int = 0x5419;\npub const TIOCSSOFTCAR: ::c_int = 0x541A;\npub const TIOCLINUX: ::c_int = 0x541C;\npub const TIOCGSERIAL: ::c_int = 0x541E;\npub const TIOCEXCL: ::c_int = 0x540C;\npub const TIOCNXCL: ::c_int = 0x540D;\npub const TIOCSCTTY: ::c_int = 0x540E;\npub const TIOCGPGRP: ::c_int = 0x540F;\npub const TIOCSPGRP: ::c_int = 0x5410;\npub const TIOCOUTQ: ::c_int = 0x5411;\npub const TIOCSTI: ::c_int = 0x5412;\npub const TIOCGWINSZ: ::c_int = 0x5413;\npub const TIOCSWINSZ: ::c_int = 0x5414;\npub const TIOCMGET: ::c_int = 0x5415;\npub const TIOCMBIS: ::c_int = 0x5416;\npub const TIOCMBIC: ::c_int = 0x5417;\npub const TIOCMSET: ::c_int = 0x5418;\npub const FIONREAD: ::c_int = 0x541B;\npub const TIOCCONS: ::c_int = 0x541D;\n\npub const POLLWRNORM: ::c_short = 0x100;\npub const POLLWRBAND: ::c_short = 0x200;\n\npub const TIOCM_LE: ::c_int = 0x001;\npub const TIOCM_DTR: ::c_int = 0x002;\npub const TIOCM_RTS: ::c_int = 0x004;\npub const TIOCM_ST: ::c_int = 0x008;\npub const TIOCM_SR: ::c_int = 0x010;\npub const TIOCM_CTS: ::c_int = 0x020;\npub const TIOCM_CAR: ::c_int = 0x040;\npub const TIOCM_RNG: ::c_int = 0x080;\npub const TIOCM_DSR: ::c_int = 0x100;\npub const TIOCM_CD: ::c_int = TIOCM_CAR;\npub const TIOCM_RI: ::c_int = TIOCM_RNG;\n\npub const O_DIRECTORY: ::c_int = 0x00080000;\npub const O_DIRECT: ::c_int = 0x00000800;\npub const O_LARGEFILE: ::c_int = 0x00001000;\npub const O_NOFOLLOW: ::c_int = 0x00000080;\n\n// intentionally not public, only used for fd_set\ncfg_if! {\n    if #[cfg(target_pointer_width = \"32\")] {\n        const ULONG_SIZE: usize = 32;\n    } else if #[cfg(target_pointer_width = \"64\")] {\n        const ULONG_SIZE: usize = 64;\n    } else {\n        // Unknown target_pointer_width\n    }\n}\n\n// END_PUB_CONST\n\nf! {\n    pub fn FD_CLR(fd: ::c_int, set: *mut fd_set) -> () {\n        let fd = fd as usize;\n        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;\n        (*set).fds_bits[fd / size] &= !(1 << (fd % size));\n        return\n    }\n\n    pub fn FD_ISSET(fd: ::c_int, set: *mut fd_set) -> bool {\n        let fd = fd as usize;\n        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;\n        return ((*set).fds_bits[fd / size] & (1 << (fd % size))) != 0\n    }\n\n    pub fn FD_SET(fd: ::c_int, set: *mut fd_set) -> () {\n        let fd = fd as usize;\n        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;\n        (*set).fds_bits[fd / size] |= 1 << (fd % size);\n        return\n    }\n\n    pub fn FD_ZERO(set: *mut fd_set) -> () {\n        for slot in (*set).fds_bits.iter_mut() {\n            *slot = 0;\n        }\n    }\n\n    pub fn CPU_ZERO(cpuset: &mut cpu_set_t) -> () {\n        for slot in cpuset.bits.iter_mut() {\n            *slot = 0;\n        }\n    }\n\n    pub fn CPU_SET(cpu: usize, cpuset: &mut cpu_set_t) -> () {\n        let size_in_bits\n            = 8 * ::mem::size_of_val(&cpuset.bits[0]); // 32, 64 etc\n        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);\n        cpuset.bits[idx] |= 1 << offset;\n        ()\n    }\n\n    pub fn CPU_CLR(cpu: usize, cpuset: &mut cpu_set_t) -> () {\n        let size_in_bits\n            = 8 * ::mem::size_of_val(&cpuset.bits[0]); // 32, 64 etc\n        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);\n        cpuset.bits[idx] &= !(1 << offset);\n        ()\n    }\n\n    pub fn CPU_ISSET(cpu: usize, cpuset: &cpu_set_t) -> bool {\n        let size_in_bits = 8 * ::mem::size_of_val(&cpuset.bits[0]);\n        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);\n        0 != (cpuset.bits[idx] & (1 << offset))\n    }\n\n    pub fn CPU_EQUAL(set1: &cpu_set_t, set2: &cpu_set_t) -> bool {\n        set1.bits == set2.bits\n    }\n\n    pub fn major(dev: ::dev_t) -> ::c_uint {\n        let mut major = 0;\n        major |= (dev & 0x00000000000fff00) >> 8;\n        major |= (dev & 0xfffff00000000000) >> 32;\n        major as ::c_uint\n    }\n\n    pub fn minor(dev: ::dev_t) -> ::c_uint {\n        let mut minor = 0;\n        minor |= (dev & 0x00000000000000ff) >> 0;\n        minor |= (dev & 0x00000ffffff00000) >> 12;\n        minor as ::c_uint\n    }\n\n    pub fn makedev(major: ::c_uint, minor: ::c_uint) -> ::dev_t {\n        let major = major as ::dev_t;\n        let minor = minor as ::dev_t;\n        let mut dev = 0;\n        dev |= (major & 0x00000fff) << 8;\n        dev |= (major & 0xfffff000) << 32;\n        dev |= (minor & 0x000000ff) << 0;\n        dev |= (minor & 0xffffff00) << 12;\n        dev\n    }\n\n    pub fn CMSG_DATA(cmsg: *const cmsghdr) -> *mut c_uchar {\n        cmsg.offset(1) as *mut c_uchar\n    }\n\n    pub fn CMSG_NXTHDR(mhdr: *const msghdr, cmsg: *const cmsghdr)\n        -> *mut cmsghdr\n    {\n        if ((*cmsg).cmsg_len as ::size_t) < ::mem::size_of::<cmsghdr>() {\n            0 as *mut cmsghdr\n        } else if __CMSG_NEXT(cmsg).add(::mem::size_of::<cmsghdr>())\n            >= __MHDR_END(mhdr) {\n            0 as *mut cmsghdr\n        } else {\n            __CMSG_NEXT(cmsg).cast()\n        }\n    }\n\n    pub fn CMSG_FIRSTHDR(mhdr: *const msghdr) -> *mut cmsghdr {\n        if (*mhdr).msg_controllen as ::size_t >= ::mem::size_of::<cmsghdr>() {\n            (*mhdr).msg_control.cast()\n        } else {\n            0 as *mut cmsghdr\n        }\n    }\n\n    pub {const} fn CMSG_ALIGN(len: ::size_t) -> ::size_t {\n        (len + ::mem::size_of::<::size_t>() - 1)\n            & !(::mem::size_of::<::size_t>() - 1)\n    }\n\n    pub {const} fn CMSG_SPACE(len: ::c_uint) -> ::c_uint {\n        (CMSG_ALIGN(len as ::size_t) + CMSG_ALIGN(::mem::size_of::<cmsghdr>()))\n            as ::c_uint\n    }\n\n    pub fn CMSG_LEN(len: ::c_uint) -> ::c_uint {\n        (CMSG_ALIGN(::mem::size_of::<cmsghdr>()) + len as ::size_t) as ::c_uint\n    }\n}\n\nsafe_f! {\n    pub {const} fn WIFSTOPPED(status: ::c_int) -> bool {\n        (status & 0xff) == 0x7f\n    }\n\n    pub {const} fn WSTOPSIG(status: ::c_int) -> ::c_int {\n        (status >> 8) & 0xff\n    }\n\n    pub {const} fn WIFCONTINUED(status: ::c_int) -> bool {\n        status == 0xffff\n    }\n\n    pub {const} fn WIFSIGNALED(status: ::c_int) -> bool {\n        ((status & 0x7f) + 1) as i8 >= 2\n    }\n\n    pub {const} fn WTERMSIG(status: ::c_int) -> ::c_int {\n        status & 0x7f\n    }\n\n    pub {const} fn WIFEXITED(status: ::c_int) -> bool {\n        (status & 0x7f) == 0\n    }\n\n    pub {const} fn WEXITSTATUS(status: ::c_int) -> ::c_int {\n        (status >> 8) & 0xff\n    }\n\n    pub {const} fn WCOREDUMP(status: ::c_int) -> bool {\n        (status & 0x80) != 0\n    }\n\n    pub {const} fn QCMD(cmd: ::c_int, type_: ::c_int) -> ::c_int {\n        (cmd << 8) | (type_ & 0x00ff)\n    }\n}\n\nfn __CMSG_LEN(cmsg: *const cmsghdr) -> ::ssize_t {\n    ((unsafe { (*cmsg).cmsg_len as ::size_t } + ::mem::size_of::<::c_long>() - 1)\n        & !(::mem::size_of::<::c_long>() - 1)) as ::ssize_t\n}\n\nfn __CMSG_NEXT(cmsg: *const cmsghdr) -> *mut c_uchar {\n    (unsafe { cmsg.offset(__CMSG_LEN(cmsg)) }) as *mut c_uchar\n}\n\nfn __MHDR_END(mhdr: *const msghdr) -> *mut c_uchar {\n    unsafe { (*mhdr).msg_control.offset((*mhdr).msg_controllen as isize) }.cast()\n}\n\n// EXTERN_FN\n\n#[link(name = \"c\")]\n#[link(name = \"fdio\")]\nextern \"C\" {}\n\n#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\npub enum FILE {}\nimpl ::Copy for FILE {}\nimpl ::Clone for FILE {\n    fn clone(&self) -> FILE {\n        *self\n    }\n}\n#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\npub enum fpos_t {} // FIXME: fill this out with a struct\nimpl ::Copy for fpos_t {}\nimpl ::Clone for fpos_t {\n    fn clone(&self) -> fpos_t {\n        *self\n    }\n}\n\nextern \"C\" {\n    pub fn isalnum(c: c_int) -> c_int;\n    pub fn isalpha(c: c_int) -> c_int;\n    pub fn iscntrl(c: c_int) -> c_int;\n    pub fn isdigit(c: c_int) -> c_int;\n    pub fn isgraph(c: c_int) -> c_int;\n    pub fn islower(c: c_int) -> c_int;\n    pub fn isprint(c: c_int) -> c_int;\n    pub fn ispunct(c: c_int) -> c_int;\n    pub fn isspace(c: c_int) -> c_int;\n    pub fn isupper(c: c_int) -> c_int;\n    pub fn isxdigit(c: c_int) -> c_int;\n    pub fn isblank(c: c_int) -> c_int;\n    pub fn tolower(c: c_int) -> c_int;\n    pub fn toupper(c: c_int) -> c_int;\n    pub fn fopen(filename: *const c_char, mode: *const c_char) -> *mut FILE;\n    pub fn freopen(filename: *const c_char, mode: *const c_char, file: *mut FILE) -> *mut FILE;\n    pub fn fflush(file: *mut FILE) -> c_int;\n    pub fn fclose(file: *mut FILE) -> c_int;\n    pub fn remove(filename: *const c_char) -> c_int;\n    pub fn rename(oldname: *const c_char, newname: *const c_char) -> c_int;\n    pub fn tmpfile() -> *mut FILE;\n    pub fn setvbuf(stream: *mut FILE, buffer: *mut c_char, mode: c_int, size: size_t) -> c_int;\n    pub fn setbuf(stream: *mut FILE, buf: *mut c_char);\n    pub fn getchar() -> c_int;\n    pub fn putchar(c: c_int) -> c_int;\n    pub fn fgetc(stream: *mut FILE) -> c_int;\n    pub fn fgets(buf: *mut c_char, n: c_int, stream: *mut FILE) -> *mut c_char;\n    pub fn fputc(c: c_int, stream: *mut FILE) -> c_int;\n    pub fn fputs(s: *const c_char, stream: *mut FILE) -> c_int;\n    pub fn puts(s: *const c_char) -> c_int;\n    pub fn ungetc(c: c_int, stream: *mut FILE) -> c_int;\n    pub fn fread(ptr: *mut c_void, size: size_t, nobj: size_t, stream: *mut FILE) -> size_t;\n    pub fn fwrite(ptr: *const c_void, size: size_t, nobj: size_t, stream: *mut FILE) -> size_t;\n    pub fn fseek(stream: *mut FILE, offset: c_long, whence: c_int) -> c_int;\n    pub fn ftell(stream: *mut FILE) -> c_long;\n    pub fn rewind(stream: *mut FILE);\n    pub fn fgetpos(stream: *mut FILE, ptr: *mut fpos_t) -> c_int;\n    pub fn fsetpos(stream: *mut FILE, ptr: *const fpos_t) -> c_int;\n    pub fn feof(stream: *mut FILE) -> c_int;\n    pub fn ferror(stream: *mut FILE) -> c_int;\n    pub fn perror(s: *const c_char);\n    pub fn atoi(s: *const c_char) -> c_int;\n    pub fn strtod(s: *const c_char, endp: *mut *mut c_char) -> c_double;\n    pub fn strtol(s: *const c_char, endp: *mut *mut c_char, base: c_int) -> c_long;\n    pub fn strtoul(s: *const c_char, endp: *mut *mut c_char, base: c_int) -> c_ulong;\n    pub fn calloc(nobj: size_t, size: size_t) -> *mut c_void;\n    pub fn malloc(size: size_t) -> *mut c_void;\n    pub fn realloc(p: *mut c_void, size: size_t) -> *mut c_void;\n    pub fn free(p: *mut c_void);\n    pub fn abort() -> !;\n    pub fn exit(status: c_int) -> !;\n    pub fn _exit(status: c_int) -> !;\n    pub fn atexit(cb: extern \"C\" fn()) -> c_int;\n    pub fn system(s: *const c_char) -> c_int;\n    pub fn getenv(s: *const c_char) -> *mut c_char;\n\n    pub fn strcpy(dst: *mut c_char, src: *const c_char) -> *mut c_char;\n    pub fn strncpy(dst: *mut c_char, src: *const c_char, n: size_t) -> *mut c_char;\n    pub fn strcat(s: *mut c_char, ct: *const c_char) -> *mut c_char;\n    pub fn strncat(s: *mut c_char, ct: *const c_char, n: size_t) -> *mut c_char;\n    pub fn strcmp(cs: *const c_char, ct: *const c_char) -> c_int;\n    pub fn strncmp(cs: *const c_char, ct: *const c_char, n: size_t) -> c_int;\n    pub fn strcoll(cs: *const c_char, ct: *const c_char) -> c_int;\n    pub fn strchr(cs: *const c_char, c: c_int) -> *mut c_char;\n    pub fn strrchr(cs: *const c_char, c: c_int) -> *mut c_char;\n    pub fn strspn(cs: *const c_char, ct: *const c_char) -> size_t;\n    pub fn strcspn(cs: *const c_char, ct: *const c_char) -> size_t;\n    pub fn strdup(cs: *const c_char) -> *mut c_char;\n    pub fn strpbrk(cs: *const c_char, ct: *const c_char) -> *mut c_char;\n    pub fn strstr(cs: *const c_char, ct: *const c_char) -> *mut c_char;\n    pub fn strlen(cs: *const c_char) -> size_t;\n    pub fn strnlen(cs: *const c_char, maxlen: size_t) -> size_t;\n    pub fn strerror(n: c_int) -> *mut c_char;\n    pub fn strtok(s: *mut c_char, t: *const c_char) -> *mut c_char;\n    pub fn strxfrm(s: *mut c_char, ct: *const c_char, n: size_t) -> size_t;\n    pub fn wcslen(buf: *const wchar_t) -> size_t;\n    pub fn wcstombs(dest: *mut c_char, src: *const wchar_t, n: size_t) -> ::size_t;\n\n    pub fn memchr(cx: *const c_void, c: c_int, n: size_t) -> *mut c_void;\n    pub fn wmemchr(cx: *const wchar_t, c: wchar_t, n: size_t) -> *mut wchar_t;\n    pub fn memcmp(cx: *const c_void, ct: *const c_void, n: size_t) -> c_int;\n    pub fn memcpy(dest: *mut c_void, src: *const c_void, n: size_t) -> *mut c_void;\n    pub fn memmove(dest: *mut c_void, src: *const c_void, n: size_t) -> *mut c_void;\n    pub fn memset(dest: *mut c_void, c: c_int, n: size_t) -> *mut c_void;\n\n    pub fn abs(i: c_int) -> c_int;\n    pub fn atof(s: *const c_char) -> c_double;\n    pub fn labs(i: c_long) -> c_long;\n    pub fn rand() -> c_int;\n    pub fn srand(seed: c_uint);\n\n    pub fn getpwnam(name: *const ::c_char) -> *mut passwd;\n    pub fn getpwuid(uid: ::uid_t) -> *mut passwd;\n\n    pub fn fprintf(stream: *mut ::FILE, format: *const ::c_char, ...) -> ::c_int;\n    pub fn printf(format: *const ::c_char, ...) -> ::c_int;\n    pub fn snprintf(s: *mut ::c_char, n: ::size_t, format: *const ::c_char, ...) -> ::c_int;\n    pub fn sprintf(s: *mut ::c_char, format: *const ::c_char, ...) -> ::c_int;\n    pub fn fscanf(stream: *mut ::FILE, format: *const ::c_char, ...) -> ::c_int;\n    pub fn scanf(format: *const ::c_char, ...) -> ::c_int;\n    pub fn sscanf(s: *const ::c_char, format: *const ::c_char, ...) -> ::c_int;\n    pub fn getchar_unlocked() -> ::c_int;\n    pub fn putchar_unlocked(c: ::c_int) -> ::c_int;\n\n    pub fn socket(domain: ::c_int, ty: ::c_int, protocol: ::c_int) -> ::c_int;\n    pub fn connect(socket: ::c_int, address: *const sockaddr, len: socklen_t) -> ::c_int;\n    pub fn listen(socket: ::c_int, backlog: ::c_int) -> ::c_int;\n    pub fn accept(socket: ::c_int, address: *mut sockaddr, address_len: *mut socklen_t) -> ::c_int;\n    pub fn getpeername(\n        socket: ::c_int,\n        address: *mut sockaddr,\n        address_len: *mut socklen_t,\n    ) -> ::c_int;\n    pub fn getsockname(\n        socket: ::c_int,\n        address: *mut sockaddr,\n        address_len: *mut socklen_t,\n    ) -> ::c_int;\n    pub fn setsockopt(\n        socket: ::c_int,\n        level: ::c_int,\n        name: ::c_int,\n        value: *const ::c_void,\n        option_len: socklen_t,\n    ) -> ::c_int;\n    pub fn socketpair(\n        domain: ::c_int,\n        type_: ::c_int,\n        protocol: ::c_int,\n        socket_vector: *mut ::c_int,\n    ) -> ::c_int;\n    pub fn sendto(\n        socket: ::c_int,\n        buf: *const ::c_void,\n        len: ::size_t,\n        flags: ::c_int,\n        addr: *const sockaddr,\n        addrlen: socklen_t,\n    ) -> ::ssize_t;\n    pub fn shutdown(socket: ::c_int, how: ::c_int) -> ::c_int;\n\n    pub fn chmod(path: *const c_char, mode: mode_t) -> ::c_int;\n    pub fn fchmod(fd: ::c_int, mode: mode_t) -> ::c_int;\n\n    pub fn fstat(fildes: ::c_int, buf: *mut stat) -> ::c_int;\n\n    pub fn mkdir(path: *const c_char, mode: mode_t) -> ::c_int;\n\n    pub fn stat(path: *const c_char, buf: *mut stat) -> ::c_int;\n\n    pub fn pclose(stream: *mut ::FILE) -> ::c_int;\n    pub fn fdopen(fd: ::c_int, mode: *const c_char) -> *mut ::FILE;\n    pub fn fileno(stream: *mut ::FILE) -> ::c_int;\n\n    pub fn open(path: *const c_char, oflag: ::c_int, ...) -> ::c_int;\n    pub fn creat(path: *const c_char, mode: mode_t) -> ::c_int;\n    pub fn fcntl(fd: ::c_int, cmd: ::c_int, ...) -> ::c_int;\n\n    pub fn opendir(dirname: *const c_char) -> *mut ::DIR;\n    pub fn readdir(dirp: *mut ::DIR) -> *mut ::dirent;\n    pub fn readdir_r(dirp: *mut ::DIR, entry: *mut ::dirent, result: *mut *mut ::dirent)\n        -> ::c_int;\n    pub fn closedir(dirp: *mut ::DIR) -> ::c_int;\n    pub fn rewinddir(dirp: *mut ::DIR);\n\n    pub fn openat(dirfd: ::c_int, pathname: *const ::c_char, flags: ::c_int, ...) -> ::c_int;\n    pub fn fchmodat(\n        dirfd: ::c_int,\n        pathname: *const ::c_char,\n        mode: ::mode_t,\n        flags: ::c_int,\n    ) -> ::c_int;\n    pub fn fchown(fd: ::c_int, owner: ::uid_t, group: ::gid_t) -> ::c_int;\n    pub fn fchownat(\n        dirfd: ::c_int,\n        pathname: *const ::c_char,\n        owner: ::uid_t,\n        group: ::gid_t,\n        flags: ::c_int,\n    ) -> ::c_int;\n    pub fn fstatat(\n        dirfd: ::c_int,\n        pathname: *const ::c_char,\n        buf: *mut stat,\n        flags: ::c_int,\n    ) -> ::c_int;\n    pub fn linkat(\n        olddirfd: ::c_int,\n        oldpath: *const ::c_char,\n        newdirfd: ::c_int,\n        newpath: *const ::c_char,\n        flags: ::c_int,\n    ) -> ::c_int;\n    pub fn mkdirat(dirfd: ::c_int, pathname: *const ::c_char, mode: ::mode_t) -> ::c_int;\n    pub fn readlinkat(\n        dirfd: ::c_int,\n        pathname: *const ::c_char,\n        buf: *mut ::c_char,\n        bufsiz: ::size_t,\n    ) -> ::ssize_t;\n    pub fn renameat(\n        olddirfd: ::c_int,\n        oldpath: *const ::c_char,\n        newdirfd: ::c_int,\n        newpath: *const ::c_char,\n    ) -> ::c_int;\n    pub fn symlinkat(\n        target: *const ::c_char,\n        newdirfd: ::c_int,\n        linkpath: *const ::c_char,\n    ) -> ::c_int;\n    pub fn unlinkat(dirfd: ::c_int, pathname: *const ::c_char, flags: ::c_int) -> ::c_int;\n\n    pub fn access(path: *const c_char, amode: ::c_int) -> ::c_int;\n    pub fn alarm(seconds: ::c_uint) -> ::c_uint;\n    pub fn chdir(dir: *const c_char) -> ::c_int;\n    pub fn chown(path: *const c_char, uid: uid_t, gid: gid_t) -> ::c_int;\n    pub fn lchown(path: *const c_char, uid: uid_t, gid: gid_t) -> ::c_int;\n    pub fn close(fd: ::c_int) -> ::c_int;\n    pub fn dup(fd: ::c_int) -> ::c_int;\n    pub fn dup2(src: ::c_int, dst: ::c_int) -> ::c_int;\n    pub fn execl(path: *const c_char, arg0: *const c_char, ...) -> ::c_int;\n    pub fn execle(path: *const ::c_char, arg0: *const ::c_char, ...) -> ::c_int;\n    pub fn execlp(file: *const ::c_char, arg0: *const ::c_char, ...) -> ::c_int;\n    pub fn execv(prog: *const c_char, argv: *const *const c_char) -> ::c_int;\n    pub fn execve(\n        prog: *const c_char,\n        argv: *const *const c_char,\n        envp: *const *const c_char,\n    ) -> ::c_int;\n    pub fn execvp(c: *const c_char, argv: *const *const c_char) -> ::c_int;\n    pub fn fork() -> pid_t;\n    pub fn fpathconf(filedes: ::c_int, name: ::c_int) -> c_long;\n    pub fn getcwd(buf: *mut c_char, size: ::size_t) -> *mut c_char;\n    pub fn getegid() -> gid_t;\n    pub fn geteuid() -> uid_t;\n    pub fn getgid() -> gid_t;\n    pub fn getgroups(ngroups_max: ::c_int, groups: *mut gid_t) -> ::c_int;\n    pub fn getlogin() -> *mut c_char;\n    pub fn getopt(argc: ::c_int, argv: *const *mut c_char, optstr: *const c_char) -> ::c_int;\n    pub fn getpgid(pid: pid_t) -> pid_t;\n    pub fn getpgrp() -> pid_t;\n    pub fn getpid() -> pid_t;\n    pub fn getppid() -> pid_t;\n    pub fn getuid() -> uid_t;\n    pub fn isatty(fd: ::c_int) -> ::c_int;\n    pub fn link(src: *const c_char, dst: *const c_char) -> ::c_int;\n    pub fn lseek(fd: ::c_int, offset: off_t, whence: ::c_int) -> off_t;\n    pub fn pathconf(path: *const c_char, name: ::c_int) -> c_long;\n    pub fn pause() -> ::c_int;\n    pub fn pipe(fds: *mut ::c_int) -> ::c_int;\n    pub fn posix_memalign(memptr: *mut *mut ::c_void, align: ::size_t, size: ::size_t) -> ::c_int;\n    pub fn read(fd: ::c_int, buf: *mut ::c_void, count: ::size_t) -> ::ssize_t;\n    pub fn rmdir(path: *const c_char) -> ::c_int;\n    pub fn seteuid(uid: uid_t) -> ::c_int;\n    pub fn setegid(gid: gid_t) -> ::c_int;\n    pub fn setgid(gid: gid_t) -> ::c_int;\n    pub fn setpgid(pid: pid_t, pgid: pid_t) -> ::c_int;\n    pub fn setsid() -> pid_t;\n    pub fn setuid(uid: uid_t) -> ::c_int;\n    pub fn sleep(secs: ::c_uint) -> ::c_uint;\n    pub fn nanosleep(rqtp: *const timespec, rmtp: *mut timespec) -> ::c_int;\n    pub fn tcgetpgrp(fd: ::c_int) -> pid_t;\n    pub fn tcsetpgrp(fd: ::c_int, pgrp: ::pid_t) -> ::c_int;\n    pub fn ttyname(fd: ::c_int) -> *mut c_char;\n    pub fn unlink(c: *const c_char) -> ::c_int;\n    pub fn wait(status: *mut ::c_int) -> pid_t;\n    pub fn waitpid(pid: pid_t, status: *mut ::c_int, options: ::c_int) -> pid_t;\n    pub fn write(fd: ::c_int, buf: *const ::c_void, count: ::size_t) -> ::ssize_t;\n    pub fn pread(fd: ::c_int, buf: *mut ::c_void, count: ::size_t, offset: off_t) -> ::ssize_t;\n    pub fn pwrite(fd: ::c_int, buf: *const ::c_void, count: ::size_t, offset: off_t) -> ::ssize_t;\n    pub fn umask(mask: mode_t) -> mode_t;\n\n    pub fn utime(file: *const c_char, buf: *const utimbuf) -> ::c_int;\n\n    pub fn kill(pid: pid_t, sig: ::c_int) -> ::c_int;\n\n    pub fn mlock(addr: *const ::c_void, len: ::size_t) -> ::c_int;\n    pub fn munlock(addr: *const ::c_void, len: ::size_t) -> ::c_int;\n    pub fn mlockall(flags: ::c_int) -> ::c_int;\n    pub fn munlockall() -> ::c_int;\n\n    pub fn mmap(\n        addr: *mut ::c_void,\n        len: ::size_t,\n        prot: ::c_int,\n        flags: ::c_int,\n        fd: ::c_int,\n        offset: off_t,\n    ) -> *mut ::c_void;\n    pub fn munmap(addr: *mut ::c_void, len: ::size_t) -> ::c_int;\n\n    pub fn if_nametoindex(ifname: *const c_char) -> ::c_uint;\n    pub fn if_indextoname(ifindex: ::c_uint, ifname: *mut ::c_char) -> *mut ::c_char;\n\n    pub fn lstat(path: *const c_char, buf: *mut stat) -> ::c_int;\n\n    pub fn fsync(fd: ::c_int) -> ::c_int;\n\n    pub fn setenv(name: *const c_char, val: *const c_char, overwrite: ::c_int) -> ::c_int;\n    pub fn unsetenv(name: *const c_char) -> ::c_int;\n\n    pub fn symlink(path1: *const c_char, path2: *const c_char) -> ::c_int;\n\n    pub fn ftruncate(fd: ::c_int, length: off_t) -> ::c_int;\n\n    pub fn signal(signum: ::c_int, handler: sighandler_t) -> sighandler_t;\n\n    pub fn realpath(pathname: *const ::c_char, resolved: *mut ::c_char) -> *mut ::c_char;\n\n    pub fn flock(fd: ::c_int, operation: ::c_int) -> ::c_int;\n\n    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::c_void) -> ::c_int;\n    pub fn times(buf: *mut ::tms) -> ::clock_t;\n\n    pub fn pthread_self() -> ::pthread_t;\n    pub fn pthread_join(native: ::pthread_t, value: *mut *mut ::c_void) -> ::c_int;\n    pub fn pthread_exit(value: *mut ::c_void) -> !;\n    pub fn pthread_attr_init(attr: *mut ::pthread_attr_t) -> ::c_int;\n    pub fn pthread_attr_destroy(attr: *mut ::pthread_attr_t) -> ::c_int;\n    pub fn pthread_attr_setstacksize(attr: *mut ::pthread_attr_t, stack_size: ::size_t) -> ::c_int;\n    pub fn pthread_attr_setdetachstate(attr: *mut ::pthread_attr_t, state: ::c_int) -> ::c_int;\n    pub fn pthread_detach(thread: ::pthread_t) -> ::c_int;\n    pub fn sched_yield() -> ::c_int;\n    pub fn pthread_key_create(\n        key: *mut pthread_key_t,\n        dtor: ::Option<unsafe extern \"C\" fn(*mut ::c_void)>,\n    ) -> ::c_int;\n    pub fn pthread_key_delete(key: pthread_key_t) -> ::c_int;\n    pub fn pthread_getspecific(key: pthread_key_t) -> *mut ::c_void;\n    pub fn pthread_setspecific(key: pthread_key_t, value: *const ::c_void) -> ::c_int;\n    pub fn pthread_mutex_init(\n        lock: *mut pthread_mutex_t,\n        attr: *const pthread_mutexattr_t,\n    ) -> ::c_int;\n    pub fn pthread_mutex_destroy(lock: *mut pthread_mutex_t) -> ::c_int;\n    pub fn pthread_mutex_lock(lock: *mut pthread_mutex_t) -> ::c_int;\n    pub fn pthread_mutex_trylock(lock: *mut pthread_mutex_t) -> ::c_int;\n    pub fn pthread_mutex_unlock(lock: *mut pthread_mutex_t) -> ::c_int;\n\n    pub fn pthread_mutexattr_init(attr: *mut pthread_mutexattr_t) -> ::c_int;\n    pub fn pthread_mutexattr_destroy(attr: *mut pthread_mutexattr_t) -> ::c_int;\n    pub fn pthread_mutexattr_settype(attr: *mut pthread_mutexattr_t, _type: ::c_int) -> ::c_int;\n\n    pub fn pthread_cond_init(cond: *mut pthread_cond_t, attr: *const pthread_condattr_t)\n        -> ::c_int;\n    pub fn pthread_cond_wait(cond: *mut pthread_cond_t, lock: *mut pthread_mutex_t) -> ::c_int;\n    pub fn pthread_cond_timedwait(\n        cond: *mut pthread_cond_t,\n        lock: *mut pthread_mutex_t,\n        abstime: *const ::timespec,\n    ) -> ::c_int;\n    pub fn pthread_cond_signal(cond: *mut pthread_cond_t) -> ::c_int;\n    pub fn pthread_cond_broadcast(cond: *mut pthread_cond_t) -> ::c_int;\n    pub fn pthread_cond_destroy(cond: *mut pthread_cond_t) -> ::c_int;\n    pub fn pthread_condattr_init(attr: *mut pthread_condattr_t) -> ::c_int;\n    pub fn pthread_condattr_destroy(attr: *mut pthread_condattr_t) -> ::c_int;\n    pub fn pthread_rwlock_init(\n        lock: *mut pthread_rwlock_t,\n        attr: *const pthread_rwlockattr_t,\n    ) -> ::c_int;\n    pub fn pthread_rwlock_destroy(lock: *mut pthread_rwlock_t) -> ::c_int;\n    pub fn pthread_rwlock_rdlock(lock: *mut pthread_rwlock_t) -> ::c_int;\n    pub fn pthread_rwlock_tryrdlock(lock: *mut pthread_rwlock_t) -> ::c_int;\n    pub fn pthread_rwlock_wrlock(lock: *mut pthread_rwlock_t) -> ::c_int;\n    pub fn pthread_rwlock_trywrlock(lock: *mut pthread_rwlock_t) -> ::c_int;\n    pub fn pthread_rwlock_unlock(lock: *mut pthread_rwlock_t) -> ::c_int;\n    pub fn pthread_rwlockattr_init(attr: *mut pthread_rwlockattr_t) -> ::c_int;\n    pub fn pthread_rwlockattr_destroy(attr: *mut pthread_rwlockattr_t) -> ::c_int;\n    pub fn strerror_r(errnum: ::c_int, buf: *mut c_char, buflen: ::size_t) -> ::c_int;\n\n    pub fn getsockopt(\n        sockfd: ::c_int,\n        level: ::c_int,\n        optname: ::c_int,\n        optval: *mut ::c_void,\n        optlen: *mut ::socklen_t,\n    ) -> ::c_int;\n    pub fn raise(signum: ::c_int) -> ::c_int;\n    pub fn sigaction(signum: ::c_int, act: *const sigaction, oldact: *mut sigaction) -> ::c_int;\n\n    pub fn utimes(filename: *const ::c_char, times: *const ::timeval) -> ::c_int;\n    pub fn dlopen(filename: *const ::c_char, flag: ::c_int) -> *mut ::c_void;\n    pub fn dlerror() -> *mut ::c_char;\n    pub fn dlsym(handle: *mut ::c_void, symbol: *const ::c_char) -> *mut ::c_void;\n    pub fn dlclose(handle: *mut ::c_void) -> ::c_int;\n    pub fn dladdr(addr: *const ::c_void, info: *mut Dl_info) -> ::c_int;\n\n    pub fn getaddrinfo(\n        node: *const c_char,\n        service: *const c_char,\n        hints: *const addrinfo,\n        res: *mut *mut addrinfo,\n    ) -> ::c_int;\n    pub fn freeaddrinfo(res: *mut addrinfo);\n    pub fn gai_strerror(errcode: ::c_int) -> *const ::c_char;\n    pub fn res_init() -> ::c_int;\n\n    pub fn gmtime_r(time_p: *const time_t, result: *mut tm) -> *mut tm;\n    pub fn localtime_r(time_p: *const time_t, result: *mut tm) -> *mut tm;\n    pub fn mktime(tm: *mut tm) -> time_t;\n    pub fn time(time: *mut time_t) -> time_t;\n    pub fn gmtime(time_p: *const time_t) -> *mut tm;\n    pub fn localtime(time_p: *const time_t) -> *mut tm;\n\n    pub fn mknod(pathname: *const ::c_char, mode: ::mode_t, dev: ::dev_t) -> ::c_int;\n    pub fn uname(buf: *mut ::utsname) -> ::c_int;\n    pub fn gethostname(name: *mut ::c_char, len: ::size_t) -> ::c_int;\n    pub fn getservbyname(name: *const ::c_char, proto: *const ::c_char) -> *mut servent;\n    pub fn getprotobyname(name: *const ::c_char) -> *mut protoent;\n    pub fn getprotobynumber(proto: ::c_int) -> *mut protoent;\n    pub fn usleep(secs: ::c_uint) -> ::c_int;\n    pub fn send(socket: ::c_int, buf: *const ::c_void, len: ::size_t, flags: ::c_int) -> ::ssize_t;\n    pub fn recv(socket: ::c_int, buf: *mut ::c_void, len: ::size_t, flags: ::c_int) -> ::ssize_t;\n    pub fn putenv(string: *mut c_char) -> ::c_int;\n    pub fn poll(fds: *mut pollfd, nfds: nfds_t, timeout: ::c_int) -> ::c_int;\n    pub fn select(\n        nfds: ::c_int,\n        readfs: *mut fd_set,\n        writefds: *mut fd_set,\n        errorfds: *mut fd_set,\n        timeout: *mut timeval,\n    ) -> ::c_int;\n    pub fn setlocale(category: ::c_int, locale: *const ::c_char) -> *mut ::c_char;\n    pub fn localeconv() -> *mut lconv;\n\n    pub fn sem_destroy(sem: *mut sem_t) -> ::c_int;\n    pub fn sem_wait(sem: *mut sem_t) -> ::c_int;\n    pub fn sem_trywait(sem: *mut sem_t) -> ::c_int;\n    pub fn sem_post(sem: *mut sem_t) -> ::c_int;\n    pub fn sem_init(sem: *mut sem_t, pshared: ::c_int, value: ::c_uint) -> ::c_int;\n    pub fn statvfs(path: *const c_char, buf: *mut statvfs) -> ::c_int;\n    pub fn fstatvfs(fd: ::c_int, buf: *mut statvfs) -> ::c_int;\n\n    pub fn readlink(path: *const c_char, buf: *mut c_char, bufsz: ::size_t) -> ::ssize_t;\n\n    pub fn sigemptyset(set: *mut sigset_t) -> ::c_int;\n    pub fn sigaddset(set: *mut sigset_t, signum: ::c_int) -> ::c_int;\n    pub fn sigfillset(set: *mut sigset_t) -> ::c_int;\n    pub fn sigdelset(set: *mut sigset_t, signum: ::c_int) -> ::c_int;\n    pub fn sigismember(set: *const sigset_t, signum: ::c_int) -> ::c_int;\n\n    pub fn sigprocmask(how: ::c_int, set: *const sigset_t, oldset: *mut sigset_t) -> ::c_int;\n    pub fn sigpending(set: *mut sigset_t) -> ::c_int;\n\n    pub fn timegm(tm: *mut ::tm) -> time_t;\n\n    pub fn getsid(pid: pid_t) -> pid_t;\n\n    pub fn sysconf(name: ::c_int) -> ::c_long;\n\n    pub fn mkfifo(path: *const c_char, mode: mode_t) -> ::c_int;\n\n    pub fn pselect(\n        nfds: ::c_int,\n        readfs: *mut fd_set,\n        writefds: *mut fd_set,\n        errorfds: *mut fd_set,\n        timeout: *const timespec,\n        sigmask: *const sigset_t,\n    ) -> ::c_int;\n    pub fn fseeko(stream: *mut ::FILE, offset: ::off_t, whence: ::c_int) -> ::c_int;\n    pub fn ftello(stream: *mut ::FILE) -> ::off_t;\n    pub fn tcdrain(fd: ::c_int) -> ::c_int;\n    pub fn cfgetispeed(termios: *const ::termios) -> ::speed_t;\n    pub fn cfgetospeed(termios: *const ::termios) -> ::speed_t;\n    pub fn cfmakeraw(termios: *mut ::termios);\n    pub fn cfsetispeed(termios: *mut ::termios, speed: ::speed_t) -> ::c_int;\n    pub fn cfsetospeed(termios: *mut ::termios, speed: ::speed_t) -> ::c_int;\n    pub fn cfsetspeed(termios: *mut ::termios, speed: ::speed_t) -> ::c_int;\n    pub fn tcgetattr(fd: ::c_int, termios: *mut ::termios) -> ::c_int;\n    pub fn tcsetattr(fd: ::c_int, optional_actions: ::c_int, termios: *const ::termios) -> ::c_int;\n    pub fn tcflow(fd: ::c_int, action: ::c_int) -> ::c_int;\n    pub fn tcflush(fd: ::c_int, action: ::c_int) -> ::c_int;\n    pub fn tcgetsid(fd: ::c_int) -> ::pid_t;\n    pub fn tcsendbreak(fd: ::c_int, duration: ::c_int) -> ::c_int;\n    pub fn mkstemp(template: *mut ::c_char) -> ::c_int;\n    pub fn mkdtemp(template: *mut ::c_char) -> *mut ::c_char;\n\n    pub fn tmpnam(ptr: *mut ::c_char) -> *mut ::c_char;\n\n    pub fn openlog(ident: *const ::c_char, logopt: ::c_int, facility: ::c_int);\n    pub fn closelog();\n    pub fn setlogmask(maskpri: ::c_int) -> ::c_int;\n    pub fn syslog(priority: ::c_int, message: *const ::c_char, ...);\n\n    pub fn grantpt(fd: ::c_int) -> ::c_int;\n    pub fn posix_openpt(flags: ::c_int) -> ::c_int;\n    pub fn ptsname(fd: ::c_int) -> *mut ::c_char;\n    pub fn unlockpt(fd: ::c_int) -> ::c_int;\n\n    pub fn fdatasync(fd: ::c_int) -> ::c_int;\n    pub fn clock_getres(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;\n    pub fn clock_gettime(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;\n    pub fn clock_settime(clk_id: ::clockid_t, tp: *const ::timespec) -> ::c_int;\n    pub fn dirfd(dirp: *mut ::DIR) -> ::c_int;\n\n    pub fn pthread_getattr_np(native: ::pthread_t, attr: *mut ::pthread_attr_t) -> ::c_int;\n    pub fn pthread_attr_getstack(\n        attr: *const ::pthread_attr_t,\n        stackaddr: *mut *mut ::c_void,\n        stacksize: *mut ::size_t,\n    ) -> ::c_int;\n    pub fn memalign(align: ::size_t, size: ::size_t) -> *mut ::c_void;\n    pub fn setgroups(ngroups: ::size_t, ptr: *const ::gid_t) -> ::c_int;\n    pub fn pipe2(fds: *mut ::c_int, flags: ::c_int) -> ::c_int;\n    pub fn statfs(path: *const ::c_char, buf: *mut statfs) -> ::c_int;\n    pub fn fstatfs(fd: ::c_int, buf: *mut statfs) -> ::c_int;\n    pub fn memrchr(cx: *const ::c_void, c: ::c_int, n: ::size_t) -> *mut ::c_void;\n\n    pub fn posix_fadvise(fd: ::c_int, offset: ::off_t, len: ::off_t, advise: ::c_int) -> ::c_int;\n    pub fn futimens(fd: ::c_int, times: *const ::timespec) -> ::c_int;\n    pub fn utimensat(\n        dirfd: ::c_int,\n        path: *const ::c_char,\n        times: *const ::timespec,\n        flag: ::c_int,\n    ) -> ::c_int;\n    pub fn duplocale(base: ::locale_t) -> ::locale_t;\n    pub fn freelocale(loc: ::locale_t);\n    pub fn newlocale(mask: ::c_int, locale: *const ::c_char, base: ::locale_t) -> ::locale_t;\n    pub fn uselocale(loc: ::locale_t) -> ::locale_t;\n\n    pub fn fdopendir(fd: ::c_int) -> *mut ::DIR;\n\n    pub fn mknodat(\n        dirfd: ::c_int,\n        pathname: *const ::c_char,\n        mode: ::mode_t,\n        dev: dev_t,\n    ) -> ::c_int;\n    pub fn pthread_condattr_getclock(\n        attr: *const pthread_condattr_t,\n        clock_id: *mut clockid_t,\n    ) -> ::c_int;\n    pub fn pthread_condattr_setclock(\n        attr: *mut pthread_condattr_t,\n        clock_id: ::clockid_t,\n    ) -> ::c_int;\n    pub fn accept4(\n        fd: ::c_int,\n        addr: *mut ::sockaddr,\n        len: *mut ::socklen_t,\n        flg: ::c_int,\n    ) -> ::c_int;\n    pub fn ptsname_r(fd: ::c_int, buf: *mut ::c_char, buflen: ::size_t) -> ::c_int;\n    pub fn clearenv() -> ::c_int;\n    pub fn waitid(idtype: idtype_t, id: id_t, infop: *mut ::siginfo_t, options: ::c_int)\n        -> ::c_int;\n    pub fn setreuid(ruid: ::uid_t, euid: ::uid_t) -> ::c_int;\n    pub fn setregid(rgid: ::gid_t, egid: ::gid_t) -> ::c_int;\n    pub fn getresuid(ruid: *mut ::uid_t, euid: *mut ::uid_t, suid: *mut ::uid_t) -> ::c_int;\n    pub fn getresgid(rgid: *mut ::gid_t, egid: *mut ::gid_t, sgid: *mut ::gid_t) -> ::c_int;\n    pub fn acct(filename: *const ::c_char) -> ::c_int;\n    pub fn brk(addr: *mut ::c_void) -> ::c_int;\n    pub fn setresgid(rgid: ::gid_t, egid: ::gid_t, sgid: ::gid_t) -> ::c_int;\n    pub fn setresuid(ruid: ::uid_t, euid: ::uid_t, suid: ::uid_t) -> ::c_int;\n    pub fn openpty(\n        amaster: *mut ::c_int,\n        aslave: *mut ::c_int,\n        name: *mut ::c_char,\n        termp: *const termios,\n        winp: *const ::winsize,\n    ) -> ::c_int;\n    pub fn execvpe(\n        file: *const ::c_char,\n        argv: *const *const ::c_char,\n        envp: *const *const ::c_char,\n    ) -> ::c_int;\n    pub fn fexecve(\n        fd: ::c_int,\n        argv: *const *const ::c_char,\n        envp: *const *const ::c_char,\n    ) -> ::c_int;\n\n    pub fn ioctl(fd: ::c_int, request: ::c_int, ...) -> ::c_int;\n\n    pub fn lutimes(file: *const ::c_char, times: *const ::timeval) -> ::c_int;\n\n    pub fn setpwent();\n    pub fn endpwent();\n    pub fn getpwent() -> *mut passwd;\n\n    pub fn shm_open(name: *const c_char, oflag: ::c_int, mode: mode_t) -> ::c_int;\n\n    // System V IPC\n    pub fn shmget(key: ::key_t, size: ::size_t, shmflg: ::c_int) -> ::c_int;\n    pub fn shmat(shmid: ::c_int, shmaddr: *const ::c_void, shmflg: ::c_int) -> *mut ::c_void;\n    pub fn shmdt(shmaddr: *const ::c_void) -> ::c_int;\n    pub fn shmctl(shmid: ::c_int, cmd: ::c_int, buf: *mut ::shmid_ds) -> ::c_int;\n    pub fn ftok(pathname: *const ::c_char, proj_id: ::c_int) -> ::key_t;\n    pub fn semget(key: ::key_t, nsems: ::c_int, semflag: ::c_int) -> ::c_int;\n    pub fn semop(semid: ::c_int, sops: *mut ::sembuf, nsops: ::size_t) -> ::c_int;\n    pub fn semctl(semid: ::c_int, semnum: ::c_int, cmd: ::c_int, ...) -> ::c_int;\n    pub fn msgctl(msqid: ::c_int, cmd: ::c_int, buf: *mut msqid_ds) -> ::c_int;\n    pub fn msgget(key: ::key_t, msgflg: ::c_int) -> ::c_int;\n    pub fn msgrcv(\n        msqid: ::c_int,\n        msgp: *mut ::c_void,\n        msgsz: ::size_t,\n        msgtyp: ::c_long,\n        msgflg: ::c_int,\n    ) -> ::ssize_t;\n    pub fn msgsnd(\n        msqid: ::c_int,\n        msgp: *const ::c_void,\n        msgsz: ::size_t,\n        msgflg: ::c_int,\n    ) -> ::c_int;\n\n    pub fn mprotect(addr: *mut ::c_void, len: ::size_t, prot: ::c_int) -> ::c_int;\n    pub fn __errno_location() -> *mut ::c_int;\n\n    pub fn fallocate(fd: ::c_int, mode: ::c_int, offset: ::off_t, len: ::off_t) -> ::c_int;\n    pub fn posix_fallocate(fd: ::c_int, offset: ::off_t, len: ::off_t) -> ::c_int;\n    pub fn readahead(fd: ::c_int, offset: ::off64_t, count: ::size_t) -> ::ssize_t;\n    pub fn signalfd(fd: ::c_int, mask: *const ::sigset_t, flags: ::c_int) -> ::c_int;\n    pub fn timerfd_create(clockid: ::c_int, flags: ::c_int) -> ::c_int;\n    pub fn timerfd_gettime(fd: ::c_int, curr_value: *mut itimerspec) -> ::c_int;\n    pub fn timerfd_settime(\n        fd: ::c_int,\n        flags: ::c_int,\n        new_value: *const itimerspec,\n        old_value: *mut itimerspec,\n    ) -> ::c_int;\n    pub fn pwritev(fd: ::c_int, iov: *const ::iovec, iovcnt: ::c_int, offset: ::off_t)\n        -> ::ssize_t;\n    pub fn preadv(fd: ::c_int, iov: *const ::iovec, iovcnt: ::c_int, offset: ::off_t) -> ::ssize_t;\n    pub fn quotactl(\n        cmd: ::c_int,\n        special: *const ::c_char,\n        id: ::c_int,\n        data: *mut ::c_char,\n    ) -> ::c_int;\n    pub fn dup3(oldfd: ::c_int, newfd: ::c_int, flags: ::c_int) -> ::c_int;\n    pub fn mkostemp(template: *mut ::c_char, flags: ::c_int) -> ::c_int;\n    pub fn mkostemps(template: *mut ::c_char, suffixlen: ::c_int, flags: ::c_int) -> ::c_int;\n    pub fn sigtimedwait(\n        set: *const sigset_t,\n        info: *mut siginfo_t,\n        timeout: *const ::timespec,\n    ) -> ::c_int;\n    pub fn sigwaitinfo(set: *const sigset_t, info: *mut siginfo_t) -> ::c_int;\n    pub fn nl_langinfo_l(item: ::nl_item, locale: ::locale_t) -> *mut ::c_char;\n    pub fn getnameinfo(\n        sa: *const ::sockaddr,\n        salen: ::socklen_t,\n        host: *mut ::c_char,\n        hostlen: ::socklen_t,\n        serv: *mut ::c_char,\n        sevlen: ::socklen_t,\n        flags: ::c_int,\n    ) -> ::c_int;\n    pub fn reboot(how_to: ::c_int) -> ::c_int;\n    pub fn setfsgid(gid: ::gid_t) -> ::c_int;\n    pub fn setfsuid(uid: ::uid_t) -> ::c_int;\n\n    // Not available now on Android\n    pub fn mkfifoat(dirfd: ::c_int, pathname: *const ::c_char, mode: ::mode_t) -> ::c_int;\n    pub fn if_nameindex() -> *mut if_nameindex;\n    pub fn if_freenameindex(ptr: *mut if_nameindex);\n    pub fn sync_file_range(\n        fd: ::c_int,\n        offset: ::off64_t,\n        nbytes: ::off64_t,\n        flags: ::c_uint,\n    ) -> ::c_int;\n    pub fn getifaddrs(ifap: *mut *mut ::ifaddrs) -> ::c_int;\n    pub fn freeifaddrs(ifa: *mut ::ifaddrs);\n\n    pub fn glob(\n        pattern: *const c_char,\n        flags: ::c_int,\n        errfunc: ::Option<extern \"C\" fn(epath: *const c_char, errno: ::c_int) -> ::c_int>,\n        pglob: *mut ::glob_t,\n    ) -> ::c_int;\n    pub fn globfree(pglob: *mut ::glob_t);\n\n    pub fn posix_madvise(addr: *mut ::c_void, len: ::size_t, advice: ::c_int) -> ::c_int;\n\n    pub fn shm_unlink(name: *const ::c_char) -> ::c_int;\n\n    pub fn seekdir(dirp: *mut ::DIR, loc: ::c_long);\n\n    pub fn telldir(dirp: *mut ::DIR) -> ::c_long;\n    pub fn madvise(addr: *mut ::c_void, len: ::size_t, advice: ::c_int) -> ::c_int;\n\n    pub fn msync(addr: *mut ::c_void, len: ::size_t, flags: ::c_int) -> ::c_int;\n\n    pub fn recvfrom(\n        socket: ::c_int,\n        buf: *mut ::c_void,\n        len: ::size_t,\n        flags: ::c_int,\n        addr: *mut ::sockaddr,\n        addrlen: *mut ::socklen_t,\n    ) -> ::ssize_t;\n    pub fn mkstemps(template: *mut ::c_char, suffixlen: ::c_int) -> ::c_int;\n    pub fn futimes(fd: ::c_int, times: *const ::timeval) -> ::c_int;\n    pub fn nl_langinfo(item: ::nl_item) -> *mut ::c_char;\n\n    pub fn bind(socket: ::c_int, address: *const ::sockaddr, address_len: ::socklen_t) -> ::c_int;\n\n    pub fn writev(fd: ::c_int, iov: *const ::iovec, iovcnt: ::c_int) -> ::ssize_t;\n    pub fn readv(fd: ::c_int, iov: *const ::iovec, iovcnt: ::c_int) -> ::ssize_t;\n\n    pub fn sendmsg(fd: ::c_int, msg: *const ::msghdr, flags: ::c_int) -> ::ssize_t;\n    pub fn recvmsg(fd: ::c_int, msg: *mut ::msghdr, flags: ::c_int) -> ::ssize_t;\n    pub fn getdomainname(name: *mut ::c_char, len: ::size_t) -> ::c_int;\n    pub fn setdomainname(name: *const ::c_char, len: ::size_t) -> ::c_int;\n    pub fn vhangup() -> ::c_int;\n    pub fn sendmmsg(\n        sockfd: ::c_int,\n        msgvec: *mut mmsghdr,\n        vlen: ::c_uint,\n        flags: ::c_int,\n    ) -> ::c_int;\n    pub fn recvmmsg(\n        sockfd: ::c_int,\n        msgvec: *mut mmsghdr,\n        vlen: ::c_uint,\n        flags: ::c_int,\n        timeout: *mut ::timespec,\n    ) -> ::c_int;\n    pub fn sync();\n    pub fn syscall(num: ::c_long, ...) -> ::c_long;\n    pub fn sched_getaffinity(pid: ::pid_t, cpusetsize: ::size_t, cpuset: *mut cpu_set_t)\n        -> ::c_int;\n    pub fn sched_setaffinity(\n        pid: ::pid_t,\n        cpusetsize: ::size_t,\n        cpuset: *const cpu_set_t,\n    ) -> ::c_int;\n    pub fn umount(target: *const ::c_char) -> ::c_int;\n    pub fn sched_get_priority_max(policy: ::c_int) -> ::c_int;\n    pub fn tee(fd_in: ::c_int, fd_out: ::c_int, len: ::size_t, flags: ::c_uint) -> ::ssize_t;\n    pub fn settimeofday(tv: *const ::timeval, tz: *const ::timezone) -> ::c_int;\n    pub fn splice(\n        fd_in: ::c_int,\n        off_in: *mut ::loff_t,\n        fd_out: ::c_int,\n        off_out: *mut ::loff_t,\n        len: ::size_t,\n        flags: ::c_uint,\n    ) -> ::ssize_t;\n    pub fn eventfd(init: ::c_uint, flags: ::c_int) -> ::c_int;\n    pub fn sched_rr_get_interval(pid: ::pid_t, tp: *mut ::timespec) -> ::c_int;\n    pub fn sem_timedwait(sem: *mut sem_t, abstime: *const ::timespec) -> ::c_int;\n    pub fn sem_getvalue(sem: *mut sem_t, sval: *mut ::c_int) -> ::c_int;\n    pub fn sched_setparam(pid: ::pid_t, param: *const ::sched_param) -> ::c_int;\n    pub fn swapoff(puath: *const ::c_char) -> ::c_int;\n    pub fn vmsplice(\n        fd: ::c_int,\n        iov: *const ::iovec,\n        nr_segs: ::size_t,\n        flags: ::c_uint,\n    ) -> ::ssize_t;\n    pub fn mount(\n        src: *const ::c_char,\n        target: *const ::c_char,\n        fstype: *const ::c_char,\n        flags: ::c_ulong,\n        data: *const ::c_void,\n    ) -> ::c_int;\n    pub fn personality(persona: ::c_ulong) -> ::c_int;\n    pub fn sched_getparam(pid: ::pid_t, param: *mut ::sched_param) -> ::c_int;\n    pub fn ppoll(\n        fds: *mut ::pollfd,\n        nfds: nfds_t,\n        timeout: *const ::timespec,\n        sigmask: *const sigset_t,\n    ) -> ::c_int;\n    pub fn pthread_mutex_timedlock(\n        lock: *mut pthread_mutex_t,\n        abstime: *const ::timespec,\n    ) -> ::c_int;\n    pub fn clone(\n        cb: extern \"C\" fn(*mut ::c_void) -> ::c_int,\n        child_stack: *mut ::c_void,\n        flags: ::c_int,\n        arg: *mut ::c_void,\n        ...\n    ) -> ::c_int;\n    pub fn sched_getscheduler(pid: ::pid_t) -> ::c_int;\n    pub fn clock_nanosleep(\n        clk_id: ::clockid_t,\n        flags: ::c_int,\n        rqtp: *const ::timespec,\n        rmtp: *mut ::timespec,\n    ) -> ::c_int;\n    pub fn pthread_attr_getguardsize(\n        attr: *const ::pthread_attr_t,\n        guardsize: *mut ::size_t,\n    ) -> ::c_int;\n    pub fn sethostname(name: *const ::c_char, len: ::size_t) -> ::c_int;\n    pub fn sched_get_priority_min(policy: ::c_int) -> ::c_int;\n    pub fn umount2(target: *const ::c_char, flags: ::c_int) -> ::c_int;\n    pub fn swapon(path: *const ::c_char, swapflags: ::c_int) -> ::c_int;\n    pub fn sched_setscheduler(\n        pid: ::pid_t,\n        policy: ::c_int,\n        param: *const ::sched_param,\n    ) -> ::c_int;\n    pub fn sigsuspend(mask: *const ::sigset_t) -> ::c_int;\n    pub fn getgrgid_r(\n        gid: ::gid_t,\n        grp: *mut ::group,\n        buf: *mut ::c_char,\n        buflen: ::size_t,\n        result: *mut *mut ::group,\n    ) -> ::c_int;\n    pub fn sigaltstack(ss: *const stack_t, oss: *mut stack_t) -> ::c_int;\n    pub fn sem_close(sem: *mut sem_t) -> ::c_int;\n    pub fn getdtablesize() -> ::c_int;\n    pub fn getgrnam_r(\n        name: *const ::c_char,\n        grp: *mut ::group,\n        buf: *mut ::c_char,\n        buflen: ::size_t,\n        result: *mut *mut ::group,\n    ) -> ::c_int;\n    pub fn initgroups(user: *const ::c_char, group: ::gid_t) -> ::c_int;\n    pub fn pthread_sigmask(how: ::c_int, set: *const sigset_t, oldset: *mut sigset_t) -> ::c_int;\n    pub fn sem_open(name: *const ::c_char, oflag: ::c_int, ...) -> *mut sem_t;\n    pub fn getgrnam(name: *const ::c_char) -> *mut ::group;\n    pub fn pthread_cancel(thread: ::pthread_t) -> ::c_int;\n    pub fn pthread_kill(thread: ::pthread_t, sig: ::c_int) -> ::c_int;\n    pub fn sem_unlink(name: *const ::c_char) -> ::c_int;\n    pub fn daemon(nochdir: ::c_int, noclose: ::c_int) -> ::c_int;\n    pub fn getpwnam_r(\n        name: *const ::c_char,\n        pwd: *mut passwd,\n        buf: *mut ::c_char,\n        buflen: ::size_t,\n        result: *mut *mut passwd,\n    ) -> ::c_int;\n    pub fn getpwuid_r(\n        uid: ::uid_t,\n        pwd: *mut passwd,\n        buf: *mut ::c_char,\n        buflen: ::size_t,\n        result: *mut *mut passwd,\n    ) -> ::c_int;\n    pub fn sigwait(set: *const sigset_t, sig: *mut ::c_int) -> ::c_int;\n    pub fn pthread_atfork(\n        prepare: ::Option<unsafe extern \"C\" fn()>,\n        parent: ::Option<unsafe extern \"C\" fn()>,\n        child: ::Option<unsafe extern \"C\" fn()>,\n    ) -> ::c_int;\n    pub fn getgrgid(gid: ::gid_t) -> *mut ::group;\n    pub fn getgrouplist(\n        user: *const ::c_char,\n        group: ::gid_t,\n        groups: *mut ::gid_t,\n        ngroups: *mut ::c_int,\n    ) -> ::c_int;\n    pub fn popen(command: *const c_char, mode: *const c_char) -> *mut ::FILE;\n    pub fn faccessat(\n        dirfd: ::c_int,\n        pathname: *const ::c_char,\n        mode: ::c_int,\n        flags: ::c_int,\n    ) -> ::c_int;\n    pub fn pthread_create(\n        native: *mut ::pthread_t,\n        attr: *const ::pthread_attr_t,\n        f: extern \"C\" fn(*mut ::c_void) -> *mut ::c_void,\n        value: *mut ::c_void,\n    ) -> ::c_int;\n    pub fn dl_iterate_phdr(\n        callback: ::Option<\n            unsafe extern \"C\" fn(\n                info: *mut ::dl_phdr_info,\n                size: ::size_t,\n                data: *mut ::c_void,\n            ) -> ::c_int,\n        >,\n        data: *mut ::c_void,\n    ) -> ::c_int;\n}\n\ncfg_if! {\n    if #[cfg(target_arch = \"aarch64\")] {\n        mod aarch64;\n        pub use self::aarch64::*;\n    } else if #[cfg(any(target_arch = \"x86_64\"))] {\n        mod x86_64;\n        pub use self::x86_64::*;\n    } else {\n        // Unknown target_arch\n    }\n}\n\ncfg_if! {\n    if #[cfg(libc_align)] {\n        #[macro_use]\n        mod align;\n    } else {\n        #[macro_use]\n        mod no_align;\n    }\n}\nexpand_align!();\n\ncfg_if! {\n    if #[cfg(libc_core_cvoid)] {\n        pub use ::ffi::c_void;\n    } else {\n        // Use repr(u8) as LLVM expects `void*` to be the same as `i8*` to help\n        // enable more optimization opportunities around it recognizing things\n        // like malloc/free.\n        #[repr(u8)]\n        #[allow(missing_copy_implementations)]\n        #[allow(missing_debug_implementations)]\n        pub enum c_void {\n            // Two dummy variants so the #[repr] attribute can be used.\n            #[doc(hidden)]\n            __variant1,\n            #[doc(hidden)]\n            __variant2,\n        }\n    }\n}\n"],["1126","macro_rules! expand_align {\n    () => {\n        s! {\n            pub struct pthread_mutexattr_t {\n                #[cfg(target_arch = \"x86_64\")]\n                __align: [::c_int; 0],\n                #[cfg(not(target_arch = \"x86_64\"))]\n                __align: [::c_long; 0],\n                size: [u8; ::__SIZEOF_PTHREAD_MUTEXATTR_T],\n            }\n\n            pub struct pthread_rwlockattr_t {\n                __align: [::c_long; 0],\n                size: [u8; ::__SIZEOF_PTHREAD_RWLOCKATTR_T],\n            }\n\n            pub struct pthread_condattr_t {\n                __align: [::c_int; 0],\n                size: [u8; ::__SIZEOF_PTHREAD_CONDATTR_T],\n            }\n        }\n\n        s_no_extra_traits! {\n            pub struct pthread_mutex_t {\n                #[cfg(any(target_arch = \"arm\",\n                          all(target_arch = \"x86_64\",\n                              target_pointer_width = \"32\")))]\n                __align: [::c_long; 0],\n                #[cfg(not(any(target_arch = \"arm\",\n                              all(target_arch = \"x86_64\",\n                                  target_pointer_width = \"32\"))))]\n                __align: [::c_longlong; 0],\n                size: [u8; ::__SIZEOF_PTHREAD_MUTEX_T],\n            }\n\n            pub struct pthread_rwlock_t {\n                __align: [::c_long; 0],\n                __align: [::c_longlong; 0],\n                size: [u8; ::__SIZEOF_PTHREAD_RWLOCK_T],\n            }\n\n            pub struct pthread_cond_t {\n                __align: [*const ::c_void; 0],\n                #[cfg(not(target_env = \"musl\"))]\n                __align: [::c_longlong; 0],\n                size: [u8; ::__SIZEOF_PTHREAD_COND_T],\n            }\n        }\n\n        cfg_if! {\n            if #[cfg(feature = \"extra_traits\")] {\n                impl PartialEq for pthread_cond_t {\n                    fn eq(&self, other: &pthread_cond_t) -> bool {\n                        // Ignore __align field\n                        self.size\n                            .iter()\n                            .zip(other.size.iter())\n                            .all(|(a,b)| a == b)\n                    }\n                }\n                impl Eq for pthread_cond_t {}\n                impl ::fmt::Debug for pthread_cond_t {\n                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                        f.debug_struct(\"pthread_cond_t\")\n                            // Ignore __align field\n                            // FIXME: .field(\"size\", &self.size)\n                            .finish()\n                    }\n                }\n                impl ::hash::Hash for pthread_cond_t {\n                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                        // Ignore __align field\n                        self.size.hash(state);\n                    }\n                }\n\n                impl PartialEq for pthread_mutex_t {\n                    fn eq(&self, other: &pthread_mutex_t) -> bool {\n                        // Ignore __align field\n                        self.size\n                            .iter()\n                            .zip(other.size.iter())\n                            .all(|(a,b)| a == b)\n                    }\n                }\n                impl Eq for pthread_mutex_t {}\n                impl ::fmt::Debug for pthread_mutex_t {\n                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                        f.debug_struct(\"pthread_mutex_t\")\n                            // Ignore __align field\n                            // FIXME: .field(\"size\", &self.size)\n                            .finish()\n                    }\n                }\n                impl ::hash::Hash for pthread_mutex_t {\n                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                        // Ignore __align field\n                        self.size.hash(state);\n                    }\n                }\n\n                impl PartialEq for pthread_rwlock_t {\n                    fn eq(&self, other: &pthread_rwlock_t) -> bool {\n                        // Ignore __align field\n                        self.size\n                            .iter()\n                            .zip(other.size.iter())\n                            .all(|(a,b)| a == b)\n                    }\n                }\n                impl Eq for pthread_rwlock_t {}\n                impl ::fmt::Debug for pthread_rwlock_t {\n                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                        f.debug_struct(\"pthread_rwlock_t\")\n                            // Ignore __align field\n                            // FIXME: .field(\"size\", &self.size)\n                            .finish()\n                    }\n                }\n                impl ::hash::Hash for pthread_rwlock_t {\n                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                        // Ignore __align field\n                        self.size.hash(state);\n                    }\n                }\n            }\n        }\n    };\n}\n"],["1127","pub type c_char = u8;\npub type __u64 = ::c_ulonglong;\npub type wchar_t = u32;\npub type nlink_t = ::c_ulong;\npub type blksize_t = ::c_long;\n\ns! {\n    pub struct stat {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        __pad0: ::c_ulong,\n        pub st_size: ::off_t,\n        pub st_blksize: ::blksize_t,\n        __pad1: ::c_int,\n        pub st_blocks: ::blkcnt_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __unused: [::c_uint; 2],\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        __pad0: ::c_ulong,\n        pub st_size: ::off_t,\n        pub st_blksize: ::blksize_t,\n        __pad1: ::c_int,\n        pub st_blocks: ::blkcnt_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __unused: [::c_uint; 2],\n    }\n\n    pub struct ipc_perm {\n        pub __ipc_perm_key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::mode_t,\n        pub __seq: ::c_ushort,\n        __unused1: ::c_ulong,\n        __unused2: ::c_ulong,\n    }\n}\n\npub const MINSIGSTKSZ: ::size_t = 6144;\npub const SIGSTKSZ: ::size_t = 12288;\n"],["1128","pub type c_char = i8;\npub type wchar_t = i32;\npub type nlink_t = u64;\npub type blksize_t = ::c_long;\npub type __u64 = ::c_ulonglong;\n\ns! {\n    pub struct stat {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino_t,\n        pub st_nlink: ::nlink_t,\n        pub st_mode: ::mode_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        __pad0: ::c_int,\n        pub st_rdev: ::dev_t,\n        pub st_size: ::off_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __unused: [::c_long; 3],\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino64_t,\n        pub st_nlink: ::nlink_t,\n        pub st_mode: ::mode_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        __pad0: ::c_int,\n        pub st_rdev: ::dev_t,\n        pub st_size: ::off_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt64_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __reserved: [::c_long; 3],\n    }\n\n    pub struct mcontext_t {\n        __private: [u64; 32],\n    }\n\n    pub struct ipc_perm {\n        pub __ipc_perm_key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::mode_t,\n        pub __seq: ::c_int,\n        __unused1: ::c_long,\n        __unused2: ::c_long\n    }\n}\n\ns_no_extra_traits! {\n    pub struct ucontext_t {\n        pub uc_flags: ::c_ulong,\n        pub uc_link: *mut ucontext_t,\n        pub uc_stack: ::stack_t,\n        pub uc_mcontext: mcontext_t,\n        pub uc_sigmask: ::sigset_t,\n        __private: [u8; 512],\n    }\n}\n\ncfg_if! {\n    if #[cfg(feature = \"extra_traits\")] {\n        impl PartialEq for ucontext_t {\n            fn eq(&self, other: &ucontext_t) -> bool {\n                self.uc_flags == other.uc_flags\n                    && self.uc_link == other.uc_link\n                    && self.uc_stack == other.uc_stack\n                    && self.uc_mcontext == other.uc_mcontext\n                    && self.uc_sigmask == other.uc_sigmask\n                    && self\n                    .__private\n                    .iter()\n                    .zip(other.__private.iter())\n                    .all(|(a,b)| a == b)\n            }\n        }\n        impl Eq for ucontext_t {}\n        impl ::fmt::Debug for ucontext_t {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"ucontext_t\")\n                    .field(\"uc_flags\", &self.uc_flags)\n                    .field(\"uc_link\", &self.uc_link)\n                    .field(\"uc_stack\", &self.uc_stack)\n                    .field(\"uc_mcontext\", &self.uc_mcontext)\n                    .field(\"uc_sigmask\", &self.uc_sigmask)\n                    // FIXME: .field(\"__private\", &self.__private)\n                    .finish()\n            }\n        }\n        impl ::hash::Hash for ucontext_t {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.uc_flags.hash(state);\n                self.uc_link.hash(state);\n                self.uc_stack.hash(state);\n                self.uc_mcontext.hash(state);\n                self.uc_sigmask.hash(state);\n                self.__private.hash(state);\n            }\n        }\n    }\n}\n\n// offsets in user_regs_structs, from sys/reg.h\npub const R15: ::c_int = 0;\npub const R14: ::c_int = 1;\npub const R13: ::c_int = 2;\npub const R12: ::c_int = 3;\npub const RBP: ::c_int = 4;\npub const RBX: ::c_int = 5;\npub const R11: ::c_int = 6;\npub const R10: ::c_int = 7;\npub const R9: ::c_int = 8;\npub const R8: ::c_int = 9;\npub const RAX: ::c_int = 10;\npub const RCX: ::c_int = 11;\npub const RDX: ::c_int = 12;\npub const RSI: ::c_int = 13;\npub const RDI: ::c_int = 14;\npub const ORIG_RAX: ::c_int = 15;\npub const RIP: ::c_int = 16;\npub const CS: ::c_int = 17;\npub const EFLAGS: ::c_int = 18;\npub const RSP: ::c_int = 19;\npub const SS: ::c_int = 20;\npub const FS_BASE: ::c_int = 21;\npub const GS_BASE: ::c_int = 22;\npub const DS: ::c_int = 23;\npub const ES: ::c_int = 24;\npub const FS: ::c_int = 25;\npub const GS: ::c_int = 26;\n\npub const MAP_32BIT: ::c_int = 0x0040;\n\npub const SIGSTKSZ: ::size_t = 8192;\npub const MINSIGSTKSZ: ::size_t = 2048;\n"],["1129","macro_rules! expand_align {\n    () => {\n        s! {\n            #[cfg_attr(\n                any(\n                    target_pointer_width = \"32\",\n                    target_arch = \"x86_64\"\n                ),\n                repr(align(4)))]\n            #[cfg_attr(\n                not(any(\n                    target_pointer_width = \"32\",\n                    target_arch = \"x86_64\"\n                )),\n                repr(align(8)))]\n            pub struct pthread_mutexattr_t {\n                size: [u8; ::__SIZEOF_PTHREAD_MUTEXATTR_T],\n            }\n\n            #[cfg_attr(target_pointer_width = \"32\",\n                       repr(align(4)))]\n            #[cfg_attr(target_pointer_width = \"64\",\n                       repr(align(8)))]\n            pub struct pthread_rwlockattr_t {\n                size: [u8; ::__SIZEOF_PTHREAD_RWLOCKATTR_T],\n            }\n\n            #[repr(align(4))]\n            pub struct pthread_condattr_t {\n                size: [u8; ::__SIZEOF_PTHREAD_CONDATTR_T],\n            }\n        }\n\n        s_no_extra_traits! {\n            #[cfg_attr(all(target_pointer_width = \"32\",\n                           any(target_arch = \"arm\",\n                               target_arch = \"x86_64\")),\n                       repr(align(4)))]\n            #[cfg_attr(any(target_pointer_width = \"64\",\n                           not(any(target_arch = \"arm\",\n                                   target_arch = \"x86_64\"))),\n                       repr(align(8)))]\n            pub struct pthread_mutex_t {\n                size: [u8; ::__SIZEOF_PTHREAD_MUTEX_T],\n            }\n\n            #[cfg_attr(all(target_pointer_width = \"32\",\n                           any(target_arch = \"arm\",\n                               target_arch = \"x86_64\")),\n                       repr(align(4)))]\n            #[cfg_attr(any(target_pointer_width = \"64\",\n                           not(any(target_arch = \"arm\",\n                                   target_arch = \"x86_64\"))),\n                       repr(align(8)))]\n            pub struct pthread_rwlock_t {\n                size: [u8; ::__SIZEOF_PTHREAD_RWLOCK_T],\n            }\n\n            #[cfg_attr(target_pointer_width = \"32\",\n                       repr(align(4)))]\n            #[cfg_attr(target_pointer_width = \"64\",\n                       repr(align(8)))]\n            #[cfg_attr(target_arch = \"x86\",\n                       repr(align(4)))]\n            #[cfg_attr(not(target_arch = \"x86\"),\n                       repr(align(8)))]\n            pub struct pthread_cond_t {\n                size: [u8; ::__SIZEOF_PTHREAD_COND_T],\n            }\n        }\n\n        cfg_if! {\n            if #[cfg(feature = \"extra_traits\")] {\n                impl PartialEq for pthread_cond_t {\n                    fn eq(&self, other: &pthread_cond_t) -> bool {\n                        self.size\n                            .iter()\n                            .zip(other.size.iter())\n                            .all(|(a,b)| a == b)\n                    }\n                }\n                impl Eq for pthread_cond_t {}\n                impl ::fmt::Debug for pthread_cond_t {\n                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                        f.debug_struct(\"pthread_cond_t\")\n                            // FIXME: .field(\"size\", &self.size)\n                            .finish()\n                    }\n                }\n                impl ::hash::Hash for pthread_cond_t {\n                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                        self.size.hash(state);\n                    }\n                }\n\n                impl PartialEq for pthread_mutex_t {\n                    fn eq(&self, other: &pthread_mutex_t) -> bool {\n                        self.size\n                            .iter()\n                            .zip(other.size.iter())\n                            .all(|(a,b)| a == b)\n                    }\n                }\n                impl Eq for pthread_mutex_t {}\n                impl ::fmt::Debug for pthread_mutex_t {\n                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                        f.debug_struct(\"pthread_mutex_t\")\n                            // FIXME: .field(\"size\", &self.size)\n                            .finish()\n                    }\n                }\n                impl ::hash::Hash for pthread_mutex_t {\n                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                        self.size.hash(state);\n                    }\n                }\n\n                impl PartialEq for pthread_rwlock_t {\n                    fn eq(&self, other: &pthread_rwlock_t) -> bool {\n                        self.size\n                            .iter()\n                            .zip(other.size.iter())\n                            .all(|(a,b)| a == b)\n                    }\n                }\n                impl Eq for pthread_rwlock_t {}\n                impl ::fmt::Debug for pthread_rwlock_t {\n                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                        f.debug_struct(\"pthread_rwlock_t\")\n                            // FIXME: .field(\"size\", &self.size)\n                            .finish()\n                    }\n                }\n                impl ::hash::Hash for pthread_rwlock_t {\n                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                        self.size.hash(state);\n                    }\n                }\n            }\n        }\n    };\n}\n"],["1130","//! SGX C types definition\n\npub type c_schar = i8;\npub type c_uchar = u8;\npub type c_short = i16;\npub type c_ushort = u16;\npub type c_int = i32;\npub type c_uint = u32;\npub type c_float = f32;\npub type c_double = f64;\npub type c_longlong = i64;\npub type c_ulonglong = u64;\npub type intmax_t = i64;\npub type uintmax_t = u64;\n\npub type size_t = usize;\npub type ptrdiff_t = isize;\npub type intptr_t = isize;\npub type uintptr_t = usize;\npub type ssize_t = isize;\n\npub type c_char = i8;\npub type c_long = i64;\npub type c_ulong = u64;\n\npub const INT_MIN: c_int = -2147483648;\npub const INT_MAX: c_int = 2147483647;\n\ncfg_if! {\n    if #[cfg(libc_core_cvoid)] {\n        pub use ::ffi::c_void;\n    } else {\n        // Use repr(u8) as LLVM expects `void*` to be the same as `i8*` to help\n        // enable more optimization opportunities around it recognizing things\n        // like malloc/free.\n        #[repr(u8)]\n        #[allow(missing_copy_implementations)]\n        #[allow(missing_debug_implementations)]\n        pub enum c_void {\n            // Two dummy variants so the #[repr] attribute can be used.\n            #[doc(hidden)]\n            __variant1,\n            #[doc(hidden)]\n            __variant2,\n        }\n    }\n}\n"],["1131","pub use ffi::c_void;\n\npub type c_char = i8;\npub type c_uchar = u8;\npub type c_schar = i8;\npub type c_int = i32;\npub type c_uint = u32;\npub type c_short = i16;\npub type c_ushort = u16;\npub type c_long = i32;\npub type c_ulong = u32;\npub type c_longlong = i64;\npub type c_ulonglong = u64;\npub type intmax_t = i64;\npub type uintmax_t = u64;\npub type size_t = usize;\npub type ssize_t = isize;\npub type ptrdiff_t = isize;\npub type intptr_t = isize;\npub type uintptr_t = usize;\npub type off_t = i64;\npub type pid_t = i32;\npub type clock_t = c_longlong;\npub type time_t = c_longlong;\npub type c_double = f64;\npub type c_float = f32;\npub type ino_t = u64;\npub type sigset_t = c_uchar;\npub type suseconds_t = c_longlong;\npub type mode_t = u32;\npub type dev_t = u64;\npub type uid_t = u32;\npub type gid_t = u32;\npub type nlink_t = u64;\npub type blksize_t = c_long;\npub type blkcnt_t = i64;\npub type nfds_t = c_ulong;\npub type wchar_t = i32;\n\npub type __wasi_rights_t = u64;\n\n#[allow(missing_copy_implementations)]\n#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\npub enum FILE {}\n#[allow(missing_copy_implementations)]\n#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\npub enum DIR {}\n#[allow(missing_copy_implementations)]\n#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\npub enum __locale_struct {}\n\npub type locale_t = *mut __locale_struct;\n\ns! {\n    #[repr(align(8))]\n    pub struct fpos_t {\n        data: [u8; 16],\n    }\n\n    pub struct tm {\n        pub tm_sec: c_int,\n        pub tm_min: c_int,\n        pub tm_hour: c_int,\n        pub tm_mday: c_int,\n        pub tm_mon: c_int,\n        pub tm_year: c_int,\n        pub tm_wday: c_int,\n        pub tm_yday: c_int,\n        pub tm_isdst: c_int,\n        pub __tm_gmtoff: c_int,\n        pub __tm_zone: *const c_char,\n        pub __tm_nsec: c_int,\n    }\n\n    pub struct timeval {\n        pub tv_sec: time_t,\n        pub tv_usec: suseconds_t,\n    }\n\n    pub struct timespec {\n        pub tv_sec: time_t,\n        pub tv_nsec: c_long,\n    }\n\n    pub struct tms {\n        pub tms_utime: clock_t,\n        pub tms_stime: clock_t,\n        pub tms_cutime: clock_t,\n        pub tms_cstime: clock_t,\n    }\n\n    pub struct itimerspec {\n        pub it_interval: timespec,\n        pub it_value: timespec,\n    }\n\n    pub struct iovec {\n        pub iov_base: *mut c_void,\n        pub iov_len: size_t,\n    }\n\n    pub struct lconv {\n        pub decimal_point: *mut c_char,\n        pub thousands_sep: *mut c_char,\n        pub grouping: *mut c_char,\n        pub int_curr_symbol: *mut c_char,\n        pub currency_symbol: *mut c_char,\n        pub mon_decimal_point: *mut c_char,\n        pub mon_thousands_sep: *mut c_char,\n        pub mon_grouping: *mut c_char,\n        pub positive_sign: *mut c_char,\n        pub negative_sign: *mut c_char,\n        pub int_frac_digits: c_char,\n        pub frac_digits: c_char,\n        pub p_cs_precedes: c_char,\n        pub p_sep_by_space: c_char,\n        pub n_cs_precedes: c_char,\n        pub n_sep_by_space: c_char,\n        pub p_sign_posn: c_char,\n        pub n_sign_posn: c_char,\n        pub int_p_cs_precedes: c_char,\n        pub int_p_sep_by_space: c_char,\n        pub int_n_cs_precedes: c_char,\n        pub int_n_sep_by_space: c_char,\n        pub int_p_sign_posn: c_char,\n        pub int_n_sign_posn: c_char,\n    }\n\n    pub struct pollfd {\n        pub fd: c_int,\n        pub events: c_short,\n        pub revents: c_short,\n    }\n\n    pub struct rusage {\n        pub ru_utime: timeval,\n        pub ru_stime: timeval,\n    }\n\n    pub struct stat {\n        pub st_dev: dev_t,\n        pub st_ino: ino_t,\n        pub st_nlink: nlink_t,\n        pub st_mode: mode_t,\n        pub st_uid: uid_t,\n        pub st_gid: gid_t,\n        __pad0: c_uint,\n        pub st_rdev: dev_t,\n        pub st_size: off_t,\n        pub st_blksize: blksize_t,\n        pub st_blocks: blkcnt_t,\n        pub st_atim: timespec,\n        pub st_mtim: timespec,\n        pub st_ctim: timespec,\n        __reserved: [c_longlong; 3],\n    }\n}\n\n// Declare dirent outside of s! so that it doesn't implement Copy, Eq, Hash,\n// etc., since it contains a flexible array member with a dynamic size.\n#[repr(C)]\n#[allow(missing_copy_implementations)]\n#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\npub struct dirent {\n    pub d_ino: ino_t,\n    pub d_type: c_uchar,\n    /// d_name is declared in WASI libc as a flexible array member, which\n    /// can't be directly expressed in Rust. As an imperfect workaround,\n    /// declare it as a zero-length array instead.\n    pub d_name: [c_char; 0],\n}\n\npub const EXIT_SUCCESS: c_int = 0;\npub const EXIT_FAILURE: c_int = 1;\npub const STDIN_FILENO: c_int = 0;\npub const STDOUT_FILENO: c_int = 1;\npub const STDERR_FILENO: c_int = 2;\npub const SEEK_SET: c_int = 0;\npub const SEEK_CUR: c_int = 1;\npub const SEEK_END: c_int = 2;\npub const _IOFBF: c_int = 0;\npub const _IONBF: c_int = 2;\npub const _IOLBF: c_int = 1;\npub const F_GETFD: c_int = 1;\npub const F_SETFD: c_int = 2;\npub const F_GETFL: c_int = 3;\npub const F_SETFL: c_int = 4;\npub const FD_CLOEXEC: c_int = 1;\npub const FD_SETSIZE: size_t = 1024;\npub const O_APPEND: c_int = 0x0001;\npub const O_DSYNC: c_int = 0x0002;\npub const O_NONBLOCK: c_int = 0x0004;\npub const O_RSYNC: c_int = 0x0008;\npub const O_SYNC: c_int = 0x0010;\npub const O_CREAT: c_int = 0x0001 << 12;\npub const O_DIRECTORY: c_int = 0x0002 << 12;\npub const O_EXCL: c_int = 0x0004 << 12;\npub const O_TRUNC: c_int = 0x0008 << 12;\npub const O_NOFOLLOW: c_int = 0x01000000;\npub const O_EXEC: c_int = 0x02000000;\npub const O_RDONLY: c_int = 0x04000000;\npub const O_SEARCH: c_int = 0x08000000;\npub const O_WRONLY: c_int = 0x10000000;\npub const O_RDWR: c_int = O_WRONLY | O_RDONLY;\npub const O_ACCMODE: c_int = O_EXEC | O_RDWR | O_SEARCH;\npub const O_NOCTTY: c_int = 0x0;\npub const POSIX_FADV_DONTNEED: c_int = 4;\npub const POSIX_FADV_NOREUSE: c_int = 5;\npub const POSIX_FADV_NORMAL: c_int = 0;\npub const POSIX_FADV_RANDOM: c_int = 2;\npub const POSIX_FADV_SEQUENTIAL: c_int = 1;\npub const POSIX_FADV_WILLNEED: c_int = 3;\npub const AT_FDCWD: ::c_int = -2;\npub const AT_EACCESS: c_int = 0x0;\npub const AT_SYMLINK_NOFOLLOW: c_int = 0x1;\npub const AT_SYMLINK_FOLLOW: c_int = 0x2;\npub const AT_REMOVEDIR: c_int = 0x4;\npub const UTIME_OMIT: c_long = 0xfffffffe;\npub const UTIME_NOW: c_long = 0xffffffff;\npub const S_IFIFO: mode_t = 49152;\npub const S_IFCHR: mode_t = 8192;\npub const S_IFBLK: mode_t = 24576;\npub const S_IFDIR: mode_t = 16384;\npub const S_IFREG: mode_t = 32768;\npub const S_IFLNK: mode_t = 40960;\npub const S_IFSOCK: mode_t = 49152;\npub const S_IFMT: mode_t = 57344;\npub const DT_UNKNOWN: u8 = 0;\npub const DT_BLK: u8 = 1;\npub const DT_CHR: u8 = 2;\npub const DT_DIR: u8 = 3;\npub const DT_REG: u8 = 4;\npub const DT_LNK: u8 = 7;\npub const FIONREAD: c_int = 1;\npub const FIONBIO: c_int = 2;\npub const F_OK: ::c_int = 0;\npub const R_OK: ::c_int = 4;\npub const W_OK: ::c_int = 2;\npub const X_OK: ::c_int = 1;\npub const POLLIN: ::c_short = 0x1;\npub const POLLOUT: ::c_short = 0x2;\npub const POLLERR: ::c_short = 0x1000;\npub const POLLHUP: ::c_short = 0x2000;\npub const POLLNVAL: ::c_short = 0x4000;\npub const POLLRDNORM: ::c_short = 0x1;\npub const POLLWRNORM: ::c_short = 0x2;\n\npub const E2BIG: c_int = 1;\npub const EACCES: c_int = 2;\npub const EADDRINUSE: c_int = 3;\npub const EADDRNOTAVAIL: c_int = 4;\npub const EAFNOSUPPORT: c_int = 5;\npub const EAGAIN: c_int = 6;\npub const EALREADY: c_int = 7;\npub const EBADF: c_int = 8;\npub const EBADMSG: c_int = 9;\npub const EBUSY: c_int = 10;\npub const ECANCELED: c_int = 11;\npub const ECHILD: c_int = 12;\npub const ECONNABORTED: c_int = 13;\npub const ECONNREFUSED: c_int = 14;\npub const ECONNRESET: c_int = 15;\npub const EDEADLK: c_int = 16;\npub const EDESTADDRREQ: c_int = 17;\npub const EDOM: c_int = 18;\npub const EDQUOT: c_int = 19;\npub const EEXIST: c_int = 20;\npub const EFAULT: c_int = 21;\npub const EFBIG: c_int = 22;\npub const EHOSTUNREACH: c_int = 23;\npub const EIDRM: c_int = 24;\npub const EILSEQ: c_int = 25;\npub const EINPROGRESS: c_int = 26;\npub const EINTR: c_int = 27;\npub const EINVAL: c_int = 28;\npub const EIO: c_int = 29;\npub const EISCONN: c_int = 30;\npub const EISDIR: c_int = 31;\npub const ELOOP: c_int = 32;\npub const EMFILE: c_int = 33;\npub const EMLINK: c_int = 34;\npub const EMSGSIZE: c_int = 35;\npub const EMULTIHOP: c_int = 36;\npub const ENAMETOOLONG: c_int = 37;\npub const ENETDOWN: c_int = 38;\npub const ENETRESET: c_int = 39;\npub const ENETUNREACH: c_int = 40;\npub const ENFILE: c_int = 41;\npub const ENOBUFS: c_int = 42;\npub const ENODEV: c_int = 43;\npub const ENOENT: c_int = 44;\npub const ENOEXEC: c_int = 45;\npub const ENOLCK: c_int = 46;\npub const ENOLINK: c_int = 47;\npub const ENOMEM: c_int = 48;\npub const ENOMSG: c_int = 49;\npub const ENOPROTOOPT: c_int = 50;\npub const ENOSPC: c_int = 51;\npub const ENOSYS: c_int = 52;\npub const ENOTCONN: c_int = 53;\npub const ENOTDIR: c_int = 54;\npub const ENOTEMPTY: c_int = 55;\npub const ENOTRECOVERABLE: c_int = 56;\npub const ENOTSOCK: c_int = 57;\npub const ENOTSUP: c_int = 58;\npub const ENOTTY: c_int = 59;\npub const ENXIO: c_int = 60;\npub const EOVERFLOW: c_int = 61;\npub const EOWNERDEAD: c_int = 62;\npub const EPERM: c_int = 63;\npub const EPIPE: c_int = 64;\npub const EPROTO: c_int = 65;\npub const EPROTONOSUPPORT: c_int = 66;\npub const EPROTOTYPE: c_int = 67;\npub const ERANGE: c_int = 68;\npub const EROFS: c_int = 69;\npub const ESPIPE: c_int = 70;\npub const ESRCH: c_int = 71;\npub const ESTALE: c_int = 72;\npub const ETIMEDOUT: c_int = 73;\npub const ETXTBSY: c_int = 74;\npub const EXDEV: c_int = 75;\npub const ENOTCAPABLE: c_int = 76;\npub const EOPNOTSUPP: c_int = ENOTSUP;\npub const EWOULDBLOCK: c_int = EAGAIN;\n\npub const _SC_PAGESIZE: c_int = 30;\npub const _SC_PAGE_SIZE: ::c_int = _SC_PAGESIZE;\npub const _SC_IOV_MAX: c_int = 60;\npub const _SC_SYMLOOP_MAX: c_int = 173;\n\n#[cfg_attr(\n    feature = \"rustc-dep-of-std\",\n    link(name = \"c\", kind = \"static\", cfg(target_feature = \"crt-static\"))\n)]\n#[cfg_attr(\n    feature = \"rustc-dep-of-std\",\n    link(name = \"c\", cfg(not(target_feature = \"crt-static\")))\n)]\nextern \"C\" {\n    pub fn _Exit(code: c_int) -> !;\n    pub fn _exit(code: c_int) -> !;\n    pub fn abort() -> !;\n    pub fn aligned_alloc(a: size_t, b: size_t) -> *mut c_void;\n    pub fn calloc(amt: size_t, amt2: size_t) -> *mut c_void;\n    pub fn exit(code: c_int) -> !;\n    pub fn free(ptr: *mut c_void);\n    pub fn getenv(s: *const c_char) -> *mut c_char;\n    pub fn malloc(amt: size_t) -> *mut c_void;\n    pub fn malloc_usable_size(ptr: *mut c_void) -> size_t;\n    pub fn sbrk(increment: ::intptr_t) -> *mut ::c_void;\n    pub fn rand() -> c_int;\n    pub fn read(fd: c_int, ptr: *mut c_void, size: size_t) -> ssize_t;\n    pub fn realloc(ptr: *mut c_void, amt: size_t) -> *mut c_void;\n    pub fn setenv(k: *const c_char, v: *const c_char, a: c_int) -> c_int;\n    pub fn unsetenv(k: *const c_char) -> c_int;\n    pub fn clearenv() -> ::c_int;\n    pub fn write(fd: c_int, ptr: *const c_void, size: size_t) -> ssize_t;\n    pub static mut environ: *mut *mut c_char;\n    pub fn fopen(a: *const c_char, b: *const c_char) -> *mut FILE;\n    pub fn freopen(a: *const c_char, b: *const c_char, f: *mut FILE) -> *mut FILE;\n    pub fn fclose(f: *mut FILE) -> c_int;\n    pub fn remove(a: *const c_char) -> c_int;\n    pub fn rename(a: *const c_char, b: *const c_char) -> c_int;\n    pub fn feof(f: *mut FILE) -> c_int;\n    pub fn ferror(f: *mut FILE) -> c_int;\n    pub fn fflush(f: *mut FILE) -> c_int;\n    pub fn clearerr(f: *mut FILE);\n    pub fn fseek(f: *mut FILE, b: c_long, c: c_int) -> c_int;\n    pub fn ftell(f: *mut FILE) -> c_long;\n    pub fn rewind(f: *mut FILE);\n    pub fn fgetpos(f: *mut FILE, pos: *mut fpos_t) -> c_int;\n    pub fn fsetpos(f: *mut FILE, pos: *const fpos_t) -> c_int;\n    pub fn fread(buf: *mut c_void, a: size_t, b: size_t, f: *mut FILE) -> size_t;\n    pub fn fwrite(buf: *const c_void, a: size_t, b: size_t, f: *mut FILE) -> size_t;\n    pub fn fgetc(f: *mut FILE) -> c_int;\n    pub fn getc(f: *mut FILE) -> c_int;\n    pub fn getchar() -> c_int;\n    pub fn ungetc(a: c_int, f: *mut FILE) -> c_int;\n    pub fn fputc(a: c_int, f: *mut FILE) -> c_int;\n    pub fn putc(a: c_int, f: *mut FILE) -> c_int;\n    pub fn putchar(a: c_int) -> c_int;\n    pub fn fputs(a: *const c_char, f: *mut FILE) -> c_int;\n    pub fn puts(a: *const c_char) -> c_int;\n    pub fn perror(a: *const c_char);\n    pub fn srand(a: c_uint);\n    pub fn atexit(a: extern \"C\" fn()) -> c_int;\n    pub fn at_quick_exit(a: extern \"C\" fn()) -> c_int;\n    pub fn quick_exit(a: c_int) -> !;\n    pub fn posix_memalign(a: *mut *mut c_void, b: size_t, c: size_t) -> c_int;\n    pub fn rand_r(a: *mut c_uint) -> c_int;\n    pub fn random() -> c_long;\n    pub fn srandom(a: c_uint);\n    pub fn putenv(a: *mut c_char) -> c_int;\n    pub fn clock() -> clock_t;\n    pub fn time(a: *mut time_t) -> time_t;\n    pub fn difftime(a: time_t, b: time_t) -> c_double;\n    pub fn mktime(a: *mut tm) -> time_t;\n    pub fn strftime(a: *mut c_char, b: size_t, c: *const c_char, d: *const tm) -> size_t;\n    pub fn gmtime(a: *const time_t) -> *mut tm;\n    pub fn gmtime_r(a: *const time_t, b: *mut tm) -> *mut tm;\n    pub fn localtime(a: *const time_t) -> *mut tm;\n    pub fn localtime_r(a: *const time_t, b: *mut tm) -> *mut tm;\n    pub fn asctime_r(a: *const tm, b: *mut c_char) -> *mut c_char;\n    pub fn ctime_r(a: *const time_t, b: *mut c_char) -> *mut c_char;\n\n    pub fn nanosleep(a: *const timespec, b: *mut timespec) -> c_int;\n    // pub fn clock_getres(a: clockid_t, b: *mut timespec) -> c_int;\n    // pub fn clock_gettime(a: clockid_t, b: *mut timespec) -> c_int;\n    // pub fn clock_nanosleep(\n    //     a: clockid_t,\n    //     a2: c_int,\n    //     b: *const timespec,\n    //     c: *mut timespec,\n    // ) -> c_int;\n\n    pub fn isalnum(c: c_int) -> c_int;\n    pub fn isalpha(c: c_int) -> c_int;\n    pub fn iscntrl(c: c_int) -> c_int;\n    pub fn isdigit(c: c_int) -> c_int;\n    pub fn isgraph(c: c_int) -> c_int;\n    pub fn islower(c: c_int) -> c_int;\n    pub fn isprint(c: c_int) -> c_int;\n    pub fn ispunct(c: c_int) -> c_int;\n    pub fn isspace(c: c_int) -> c_int;\n    pub fn isupper(c: c_int) -> c_int;\n    pub fn isxdigit(c: c_int) -> c_int;\n    pub fn isblank(c: c_int) -> c_int;\n    pub fn tolower(c: c_int) -> c_int;\n    pub fn toupper(c: c_int) -> c_int;\n    pub fn setvbuf(stream: *mut FILE, buffer: *mut c_char, mode: c_int, size: size_t) -> c_int;\n    pub fn setbuf(stream: *mut FILE, buf: *mut c_char);\n    pub fn fgets(buf: *mut c_char, n: c_int, stream: *mut FILE) -> *mut c_char;\n    pub fn atoi(s: *const c_char) -> c_int;\n    pub fn atof(s: *const c_char) -> c_double;\n    pub fn strtod(s: *const c_char, endp: *mut *mut c_char) -> c_double;\n    pub fn strtol(s: *const c_char, endp: *mut *mut c_char, base: c_int) -> c_long;\n    pub fn strtoul(s: *const c_char, endp: *mut *mut c_char, base: c_int) -> c_ulong;\n\n    pub fn strcpy(dst: *mut c_char, src: *const c_char) -> *mut c_char;\n    pub fn strncpy(dst: *mut c_char, src: *const c_char, n: size_t) -> *mut c_char;\n    pub fn strcat(s: *mut c_char, ct: *const c_char) -> *mut c_char;\n    pub fn strncat(s: *mut c_char, ct: *const c_char, n: size_t) -> *mut c_char;\n    pub fn strcmp(cs: *const c_char, ct: *const c_char) -> c_int;\n    pub fn strncmp(cs: *const c_char, ct: *const c_char, n: size_t) -> c_int;\n    pub fn strcoll(cs: *const c_char, ct: *const c_char) -> c_int;\n    pub fn strchr(cs: *const c_char, c: c_int) -> *mut c_char;\n    pub fn strrchr(cs: *const c_char, c: c_int) -> *mut c_char;\n    pub fn strspn(cs: *const c_char, ct: *const c_char) -> size_t;\n    pub fn strcspn(cs: *const c_char, ct: *const c_char) -> size_t;\n    pub fn strdup(cs: *const c_char) -> *mut c_char;\n    pub fn strndup(cs: *const c_char, n: size_t) -> *mut c_char;\n    pub fn strpbrk(cs: *const c_char, ct: *const c_char) -> *mut c_char;\n    pub fn strstr(cs: *const c_char, ct: *const c_char) -> *mut c_char;\n    pub fn strcasecmp(s1: *const c_char, s2: *const c_char) -> c_int;\n    pub fn strncasecmp(s1: *const c_char, s2: *const c_char, n: size_t) -> c_int;\n    pub fn strlen(cs: *const c_char) -> size_t;\n    pub fn strnlen(cs: *const c_char, maxlen: size_t) -> size_t;\n    pub fn strerror(n: c_int) -> *mut c_char;\n    pub fn strtok(s: *mut c_char, t: *const c_char) -> *mut c_char;\n    pub fn strxfrm(s: *mut c_char, ct: *const c_char, n: size_t) -> size_t;\n\n    pub fn memchr(cx: *const c_void, c: c_int, n: size_t) -> *mut c_void;\n    pub fn memcmp(cx: *const c_void, ct: *const c_void, n: size_t) -> c_int;\n    pub fn memcpy(dest: *mut c_void, src: *const c_void, n: size_t) -> *mut c_void;\n    pub fn memmove(dest: *mut c_void, src: *const c_void, n: size_t) -> *mut c_void;\n    pub fn memset(dest: *mut c_void, c: c_int, n: size_t) -> *mut c_void;\n\n    pub fn fprintf(stream: *mut ::FILE, format: *const ::c_char, ...) -> ::c_int;\n    pub fn printf(format: *const ::c_char, ...) -> ::c_int;\n    pub fn snprintf(s: *mut ::c_char, n: ::size_t, format: *const ::c_char, ...) -> ::c_int;\n    pub fn sprintf(s: *mut ::c_char, format: *const ::c_char, ...) -> ::c_int;\n    pub fn fscanf(stream: *mut ::FILE, format: *const ::c_char, ...) -> ::c_int;\n    pub fn scanf(format: *const ::c_char, ...) -> ::c_int;\n    pub fn sscanf(s: *const ::c_char, format: *const ::c_char, ...) -> ::c_int;\n    pub fn getchar_unlocked() -> ::c_int;\n    pub fn putchar_unlocked(c: ::c_int) -> ::c_int;\n\n    pub fn shutdown(socket: ::c_int, how: ::c_int) -> ::c_int;\n    pub fn fstat(fildes: ::c_int, buf: *mut stat) -> ::c_int;\n    pub fn mkdir(path: *const c_char, mode: mode_t) -> ::c_int;\n    pub fn stat(path: *const c_char, buf: *mut stat) -> ::c_int;\n    pub fn fdopen(fd: ::c_int, mode: *const c_char) -> *mut ::FILE;\n    pub fn fileno(stream: *mut ::FILE) -> ::c_int;\n    pub fn open(path: *const c_char, oflag: ::c_int, ...) -> ::c_int;\n    pub fn creat(path: *const c_char, mode: mode_t) -> ::c_int;\n    pub fn fcntl(fd: ::c_int, cmd: ::c_int, ...) -> ::c_int;\n    pub fn opendir(dirname: *const c_char) -> *mut ::DIR;\n    pub fn fdopendir(fd: ::c_int) -> *mut ::DIR;\n    pub fn readdir(dirp: *mut ::DIR) -> *mut ::dirent;\n    pub fn closedir(dirp: *mut ::DIR) -> ::c_int;\n    pub fn rewinddir(dirp: *mut ::DIR);\n    pub fn dirfd(dirp: *mut ::DIR) -> ::c_int;\n    pub fn seekdir(dirp: *mut ::DIR, loc: ::c_long);\n    pub fn telldir(dirp: *mut ::DIR) -> ::c_long;\n\n    pub fn openat(dirfd: ::c_int, pathname: *const ::c_char, flags: ::c_int, ...) -> ::c_int;\n    pub fn fstatat(\n        dirfd: ::c_int,\n        pathname: *const ::c_char,\n        buf: *mut stat,\n        flags: ::c_int,\n    ) -> ::c_int;\n    pub fn linkat(\n        olddirfd: ::c_int,\n        oldpath: *const ::c_char,\n        newdirfd: ::c_int,\n        newpath: *const ::c_char,\n        flags: ::c_int,\n    ) -> ::c_int;\n    pub fn mkdirat(dirfd: ::c_int, pathname: *const ::c_char, mode: ::mode_t) -> ::c_int;\n    pub fn readlinkat(\n        dirfd: ::c_int,\n        pathname: *const ::c_char,\n        buf: *mut ::c_char,\n        bufsiz: ::size_t,\n    ) -> ::ssize_t;\n    pub fn renameat(\n        olddirfd: ::c_int,\n        oldpath: *const ::c_char,\n        newdirfd: ::c_int,\n        newpath: *const ::c_char,\n    ) -> ::c_int;\n    pub fn symlinkat(\n        target: *const ::c_char,\n        newdirfd: ::c_int,\n        linkpath: *const ::c_char,\n    ) -> ::c_int;\n    pub fn unlinkat(dirfd: ::c_int, pathname: *const ::c_char, flags: ::c_int) -> ::c_int;\n\n    pub fn access(path: *const c_char, amode: ::c_int) -> ::c_int;\n    pub fn close(fd: ::c_int) -> ::c_int;\n    pub fn fpathconf(filedes: ::c_int, name: ::c_int) -> c_long;\n    pub fn getopt(argc: ::c_int, argv: *const *mut c_char, optstr: *const c_char) -> ::c_int;\n    pub fn isatty(fd: ::c_int) -> ::c_int;\n    pub fn link(src: *const c_char, dst: *const c_char) -> ::c_int;\n    pub fn lseek(fd: ::c_int, offset: off_t, whence: ::c_int) -> off_t;\n    pub fn pathconf(path: *const c_char, name: ::c_int) -> c_long;\n    pub fn rmdir(path: *const c_char) -> ::c_int;\n    pub fn sleep(secs: ::c_uint) -> ::c_uint;\n    pub fn unlink(c: *const c_char) -> ::c_int;\n    pub fn pread(fd: ::c_int, buf: *mut ::c_void, count: ::size_t, offset: off_t) -> ::ssize_t;\n    pub fn pwrite(fd: ::c_int, buf: *const ::c_void, count: ::size_t, offset: off_t) -> ::ssize_t;\n\n    pub fn lstat(path: *const c_char, buf: *mut stat) -> ::c_int;\n\n    pub fn fsync(fd: ::c_int) -> ::c_int;\n    pub fn fdatasync(fd: ::c_int) -> ::c_int;\n\n    pub fn symlink(path1: *const c_char, path2: *const c_char) -> ::c_int;\n\n    pub fn truncate(path: *const c_char, length: off_t) -> ::c_int;\n    pub fn ftruncate(fd: ::c_int, length: off_t) -> ::c_int;\n\n    pub fn getrusage(resource: ::c_int, usage: *mut rusage) -> ::c_int;\n\n    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::c_void) -> ::c_int;\n    pub fn times(buf: *mut ::tms) -> ::clock_t;\n\n    pub fn strerror_r(errnum: ::c_int, buf: *mut c_char, buflen: ::size_t) -> ::c_int;\n\n    pub fn usleep(secs: ::c_uint) -> ::c_int;\n    pub fn send(socket: ::c_int, buf: *const ::c_void, len: ::size_t, flags: ::c_int) -> ::ssize_t;\n    pub fn recv(socket: ::c_int, buf: *mut ::c_void, len: ::size_t, flags: ::c_int) -> ::ssize_t;\n    pub fn poll(fds: *mut pollfd, nfds: nfds_t, timeout: ::c_int) -> ::c_int;\n    pub fn setlocale(category: ::c_int, locale: *const ::c_char) -> *mut ::c_char;\n    pub fn localeconv() -> *mut lconv;\n\n    pub fn readlink(path: *const c_char, buf: *mut c_char, bufsz: ::size_t) -> ::ssize_t;\n\n    pub fn timegm(tm: *mut ::tm) -> time_t;\n\n    pub fn sysconf(name: ::c_int) -> ::c_long;\n\n    pub fn ioctl(fd: ::c_int, request: ::c_int, ...) -> ::c_int;\n\n    pub fn fseeko(stream: *mut ::FILE, offset: ::off_t, whence: ::c_int) -> ::c_int;\n    pub fn ftello(stream: *mut ::FILE) -> ::off_t;\n    pub fn posix_fallocate(fd: ::c_int, offset: ::off_t, len: ::off_t) -> ::c_int;\n\n    pub fn strcasestr(cs: *const c_char, ct: *const c_char) -> *mut c_char;\n    pub fn getline(lineptr: *mut *mut c_char, n: *mut size_t, stream: *mut FILE) -> ssize_t;\n\n    pub fn faccessat(\n        dirfd: ::c_int,\n        pathname: *const ::c_char,\n        mode: ::c_int,\n        flags: ::c_int,\n    ) -> ::c_int;\n    pub fn writev(fd: ::c_int, iov: *const ::iovec, iovcnt: ::c_int) -> ::ssize_t;\n    pub fn readv(fd: ::c_int, iov: *const ::iovec, iovcnt: ::c_int) -> ::ssize_t;\n    pub fn pwritev(fd: ::c_int, iov: *const ::iovec, iovcnt: ::c_int, offset: ::off_t)\n        -> ::ssize_t;\n    pub fn preadv(fd: ::c_int, iov: *const ::iovec, iovcnt: ::c_int, offset: ::off_t) -> ::ssize_t;\n    pub fn posix_fadvise(fd: ::c_int, offset: ::off_t, len: ::off_t, advise: ::c_int) -> ::c_int;\n    pub fn futimens(fd: ::c_int, times: *const ::timespec) -> ::c_int;\n    pub fn utimensat(\n        dirfd: ::c_int,\n        path: *const ::c_char,\n        times: *const ::timespec,\n        flag: ::c_int,\n    ) -> ::c_int;\n    pub fn getentropy(buf: *mut ::c_void, buflen: ::size_t) -> ::c_int;\n    pub fn memrchr(cx: *const ::c_void, c: ::c_int, n: ::size_t) -> *mut ::c_void;\n    pub fn abs(i: c_int) -> c_int;\n    pub fn labs(i: c_long) -> c_long;\n    pub fn duplocale(base: ::locale_t) -> ::locale_t;\n    pub fn freelocale(loc: ::locale_t);\n    pub fn newlocale(mask: ::c_int, locale: *const ::c_char, base: ::locale_t) -> ::locale_t;\n    pub fn uselocale(loc: ::locale_t) -> ::locale_t;\n    pub fn sched_yield() -> ::c_int;\n\n    pub fn __wasilibc_register_preopened_fd(fd: c_int, path: *const c_char) -> c_int;\n    pub fn __wasilibc_fd_renumber(fd: c_int, newfd: c_int) -> c_int;\n    pub fn __wasilibc_unlinkat(fd: c_int, path: *const c_char) -> c_int;\n    pub fn __wasilibc_rmdirat(fd: c_int, path: *const c_char) -> c_int;\n    pub fn __wasilibc_find_relpath(\n        path: *const c_char,\n        abs_prefix: *mut *const c_char,\n        relative_path: *mut *mut c_char,\n        relative_path_len: usize,\n    ) -> c_int;\n    pub fn __wasilibc_tell(fd: c_int) -> ::off_t;\n    pub fn __wasilibc_nocwd___wasilibc_unlinkat(dirfd: c_int, path: *const c_char) -> c_int;\n    pub fn __wasilibc_nocwd___wasilibc_rmdirat(dirfd: c_int, path: *const c_char) -> c_int;\n    pub fn __wasilibc_nocwd_linkat(\n        olddirfd: c_int,\n        oldpath: *const c_char,\n        newdirfd: c_int,\n        newpath: *const c_char,\n        flags: c_int,\n    ) -> c_int;\n    pub fn __wasilibc_nocwd_symlinkat(\n        target: *const c_char,\n        dirfd: c_int,\n        path: *const c_char,\n    ) -> c_int;\n    pub fn __wasilibc_nocwd_readlinkat(\n        dirfd: c_int,\n        path: *const c_char,\n        buf: *mut c_char,\n        bufsize: usize,\n    ) -> isize;\n    pub fn __wasilibc_nocwd_faccessat(\n        dirfd: c_int,\n        path: *const c_char,\n        mode: c_int,\n        flags: c_int,\n    ) -> c_int;\n    pub fn __wasilibc_nocwd_renameat(\n        olddirfd: c_int,\n        oldpath: *const c_char,\n        newdirfd: c_int,\n        newpath: *const c_char,\n    ) -> c_int;\n    pub fn __wasilibc_nocwd_openat_nomode(dirfd: c_int, path: *const c_char, flags: c_int)\n        -> c_int;\n    pub fn __wasilibc_nocwd_fstatat(\n        dirfd: c_int,\n        path: *const c_char,\n        buf: *mut stat,\n        flags: c_int,\n    ) -> c_int;\n    pub fn __wasilibc_nocwd_mkdirat_nomode(dirfd: c_int, path: *const c_char) -> c_int;\n    pub fn __wasilibc_nocwd_utimensat(\n        dirfd: c_int,\n        path: *const c_char,\n        times: *const ::timespec,\n        flags: c_int,\n    ) -> c_int;\n    pub fn __wasilibc_nocwd_opendirat(dirfd: c_int, path: *const c_char) -> *mut ::DIR;\n    pub fn __wasilibc_access(pathname: *const c_char, mode: c_int, flags: c_int) -> c_int;\n    pub fn __wasilibc_stat(pathname: *const c_char, buf: *mut stat, flags: c_int) -> c_int;\n    pub fn __wasilibc_utimens(\n        pathname: *const c_char,\n        times: *const ::timespec,\n        flags: c_int,\n    ) -> c_int;\n    pub fn __wasilibc_link(oldpath: *const c_char, newpath: *const c_char, flags: c_int) -> c_int;\n    pub fn __wasilibc_link_oldat(\n        olddirfd: c_int,\n        oldpath: *const c_char,\n        newpath: *const c_char,\n        flags: c_int,\n    ) -> c_int;\n    pub fn __wasilibc_link_newat(\n        oldpath: *const c_char,\n        newdirfd: c_int,\n        newpath: *const c_char,\n        flags: c_int,\n    ) -> c_int;\n    pub fn __wasilibc_rename_oldat(\n        olddirfd: c_int,\n        oldpath: *const c_char,\n        newpath: *const c_char,\n    ) -> c_int;\n    pub fn __wasilibc_rename_newat(\n        oldpath: *const c_char,\n        newdirfd: c_int,\n        newpath: *const c_char,\n    ) -> c_int;\n\n    pub fn arc4random() -> u32;\n    pub fn arc4random_buf(a: *mut c_void, b: size_t);\n    pub fn arc4random_uniform(a: u32) -> u32;\n}\n"],["1132","//! PSP C type definitions\n//!\n//! These type declarations are not enough, as they must be ultimately resolved\n//! by the linker. Crates that use these definitions must, somewhere in the\n//! crate graph, include a stub provider crate such as the `psp` crate.\n\npub type c_schar = i8;\npub type c_uchar = u8;\npub type c_short = i16;\npub type c_ushort = u16;\npub type c_int = i32;\npub type c_uint = u32;\npub type c_float = f32;\npub type c_double = f64;\npub type c_longlong = i64;\npub type c_ulonglong = u64;\npub type intmax_t = i64;\npub type uintmax_t = u64;\n\npub type size_t = usize;\npub type ptrdiff_t = isize;\npub type intptr_t = isize;\npub type uintptr_t = usize;\npub type ssize_t = isize;\n\npub type c_char = u8;\npub type c_long = i64;\npub type c_ulong = u64;\n\ncfg_if! {\n    if #[cfg(libc_core_cvoid)] {\n        pub use ::ffi::c_void;\n    } else {\n        // Use repr(u8) as LLVM expects `void*` to be the same as `i8*` to help\n        // enable more optimization opportunities around it recognizing things\n        // like malloc/free.\n        #[repr(u8)]\n        #[allow(missing_copy_implementations)]\n        #[allow(missing_debug_implementations)]\n        pub enum c_void {\n            // Two dummy variants so the #[repr] attribute can be used.\n            #[doc(hidden)]\n            __variant1,\n            #[doc(hidden)]\n            __variant2,\n        }\n    }\n}\n\npub type SceKernelVTimerHandler = unsafe extern \"C\" fn(\n    uid: SceUid,\n    arg1: *mut SceKernelSysClock,\n    arg2: *mut SceKernelSysClock,\n    arg3: *mut c_void,\n) -> u32;\n\npub type SceKernelVTimerHandlerWide =\n    unsafe extern \"C\" fn(uid: SceUid, arg1: i64, arg2: i64, arg3: *mut c_void) -> u32;\n\npub type SceKernelThreadEventHandler =\n    unsafe extern \"C\" fn(mask: i32, thid: SceUid, common: *mut c_void) -> i32;\n\npub type SceKernelAlarmHandler = unsafe extern \"C\" fn(common: *mut c_void) -> u32;\n\npub type SceKernelCallbackFunction =\n    unsafe extern \"C\" fn(arg1: i32, arg2: i32, arg: *mut c_void) -> i32;\n\npub type SceKernelThreadEntry = unsafe extern \"C\" fn(args: usize, argp: *mut c_void) -> i32;\n\npub type PowerCallback = extern \"C\" fn(unknown: i32, power_info: i32);\n\npub type IoPermissions = i32;\n\npub type UmdCallback = fn(unknown: i32, event: i32) -> i32;\n\npub type SceMpegRingbufferCb =\n    ::Option<unsafe extern \"C\" fn(data: *mut c_void, num_packets: i32, param: *mut c_void) -> i32>;\n\npub type GuCallback = ::Option<extern \"C\" fn(id: i32, arg: *mut c_void)>;\npub type GuSwapBuffersCallback =\n    ::Option<extern \"C\" fn(display: *mut *mut c_void, render: *mut *mut c_void)>;\n\npub type SceNetAdhocctlHandler =\n    ::Option<unsafe extern \"C\" fn(flag: i32, error: i32, unknown: *mut c_void)>;\n\npub type AdhocMatchingCallback = ::Option<\n    unsafe extern \"C\" fn(\n        matching_id: i32,\n        event: i32,\n        mac: *mut u8,\n        opt_len: i32,\n        opt_data: *mut c_void,\n    ),\n>;\n\npub type SceNetApctlHandler = ::Option<\n    unsafe extern \"C\" fn(oldState: i32, newState: i32, event: i32, error: i32, pArg: *mut c_void),\n>;\n\npub type HttpMallocFunction = ::Option<unsafe extern \"C\" fn(size: usize) -> *mut c_void>;\npub type HttpReallocFunction =\n    ::Option<unsafe extern \"C\" fn(p: *mut c_void, size: usize) -> *mut c_void>;\npub type HttpFreeFunction = ::Option<unsafe extern \"C\" fn(p: *mut c_void)>;\npub type HttpPasswordCB = ::Option<\n    unsafe extern \"C\" fn(\n        request: i32,\n        auth_type: HttpAuthType,\n        realm: *const u8,\n        username: *mut u8,\n        password: *mut u8,\n        need_entity: i32,\n        entity_body: *mut *mut u8,\n        entity_size: *mut usize,\n        save: *mut i32,\n    ) -> i32,\n>;\n\npub type socklen_t = u32;\n\ne! {\n    #[repr(u32)]\n    pub enum AudioFormat {\n        Stereo = 0,\n        Mono = 0x10,\n    }\n\n    #[repr(u32)]\n    pub enum DisplayMode {\n        Lcd = 0,\n    }\n\n    #[repr(u32)]\n    pub enum DisplayPixelFormat {\n        Psm5650 = 0,\n        Psm5551 = 1,\n        Psm4444 = 2,\n        Psm8888 = 3,\n    }\n\n    #[repr(u32)]\n    pub enum DisplaySetBufSync {\n        Immediate = 0,\n        NextFrame = 1,\n    }\n\n    #[repr(i32)]\n    pub enum AudioOutputFrequency {\n        Khz48 = 48000,\n        Khz44_1 = 44100,\n        Khz32 = 32000,\n        Khz24 = 24000,\n        Khz22_05 = 22050,\n        Khz16 = 16000,\n        Khz12 = 12000,\n        Khz11_025 = 11025,\n        Khz8 = 8000,\n    }\n\n    #[repr(i32)]\n    pub enum AudioInputFrequency {\n        Khz44_1 = 44100,\n        Khz22_05 = 22050,\n        Khz11_025 = 11025,\n    }\n\n    #[repr(u32)]\n    pub enum CtrlMode {\n        Digital = 0,\n        Analog,\n    }\n\n    #[repr(i32)]\n    pub enum GeMatrixType {\n        Bone0 = 0,\n        Bone1,\n        Bone2,\n        Bone3,\n        Bone4,\n        Bone5,\n        Bone6,\n        Bone7,\n        World,\n        View,\n        Projection,\n        TexGen,\n    }\n\n    #[repr(i32)]\n    pub enum GeListState {\n        Done = 0,\n        Queued,\n        DrawingDone,\n        StallReached,\n        CancelDone,\n    }\n\n    #[repr(u8)]\n    pub enum GeCommand {\n        Nop = 0,\n        Vaddr = 0x1,\n        Iaddr = 0x2,\n        Prim = 0x4,\n        Bezier = 0x5,\n        Spline = 0x6,\n        BoundingBox = 0x7,\n        Jump = 0x8,\n        BJump = 0x9,\n        Call = 0xa,\n        Ret = 0xb,\n        End = 0xc,\n        Signal = 0xe,\n        Finish = 0xf,\n        Base = 0x10,\n        VertexType = 0x12,\n        OffsetAddr = 0x13,\n        Origin = 0x14,\n        Region1 = 0x15,\n        Region2 = 0x16,\n        LightingEnable = 0x17,\n        LightEnable0 = 0x18,\n        LightEnable1 = 0x19,\n        LightEnable2 = 0x1a,\n        LightEnable3 = 0x1b,\n        DepthClampEnable = 0x1c,\n        CullFaceEnable = 0x1d,\n        TextureMapEnable = 0x1e,\n        FogEnable = 0x1f,\n        DitherEnable = 0x20,\n        AlphaBlendEnable = 0x21,\n        AlphaTestEnable = 0x22,\n        ZTestEnable = 0x23,\n        StencilTestEnable = 0x24,\n        AntiAliasEnable = 0x25,\n        PatchCullEnable = 0x26,\n        ColorTestEnable = 0x27,\n        LogicOpEnable = 0x28,\n        BoneMatrixNumber = 0x2a,\n        BoneMatrixData = 0x2b,\n        MorphWeight0 = 0x2c,\n        MorphWeight1 = 0x2d,\n        MorphWeight2 = 0x2e,\n        MorphWeight3 = 0x2f,\n        MorphWeight4 = 0x30,\n        MorphWeight5 = 0x31,\n        MorphWeight6 = 0x32,\n        MorphWeight7 = 0x33,\n        PatchDivision = 0x36,\n        PatchPrimitive = 0x37,\n        PatchFacing = 0x38,\n        WorldMatrixNumber = 0x3a,\n        WorldMatrixData = 0x3b,\n        ViewMatrixNumber = 0x3c,\n        ViewMatrixData = 0x3d,\n        ProjMatrixNumber = 0x3e,\n        ProjMatrixData = 0x3f,\n        TGenMatrixNumber = 0x40,\n        TGenMatrixData = 0x41,\n        ViewportXScale = 0x42,\n        ViewportYScale = 0x43,\n        ViewportZScale = 0x44,\n        ViewportXCenter = 0x45,\n        ViewportYCenter = 0x46,\n        ViewportZCenter = 0x47,\n        TexScaleU = 0x48,\n        TexScaleV = 0x49,\n        TexOffsetU = 0x4a,\n        TexOffsetV = 0x4b,\n        OffsetX = 0x4c,\n        OffsetY = 0x4d,\n        ShadeMode = 0x50,\n        ReverseNormal = 0x51,\n        MaterialUpdate = 0x53,\n        MaterialEmissive = 0x54,\n        MaterialAmbient = 0x55,\n        MaterialDiffuse = 0x56,\n        MaterialSpecular = 0x57,\n        MaterialAlpha = 0x58,\n        MaterialSpecularCoef = 0x5b,\n        AmbientColor = 0x5c,\n        AmbientAlpha = 0x5d,\n        LightMode = 0x5e,\n        LightType0 = 0x5f,\n        LightType1 = 0x60,\n        LightType2 = 0x61,\n        LightType3 = 0x62,\n        Light0X = 0x63,\n        Light0Y,\n        Light0Z,\n        Light1X,\n        Light1Y,\n        Light1Z,\n        Light2X,\n        Light2Y,\n        Light2Z,\n        Light3X,\n        Light3Y,\n        Light3Z,\n        Light0DirectionX = 0x6f,\n        Light0DirectionY,\n        Light0DirectionZ,\n        Light1DirectionX,\n        Light1DirectionY,\n        Light1DirectionZ,\n        Light2DirectionX,\n        Light2DirectionY,\n        Light2DirectionZ,\n        Light3DirectionX,\n        Light3DirectionY,\n        Light3DirectionZ,\n        Light0ConstantAtten = 0x7b,\n        Light0LinearAtten,\n        Light0QuadtraticAtten,\n        Light1ConstantAtten,\n        Light1LinearAtten,\n        Light1QuadtraticAtten,\n        Light2ConstantAtten,\n        Light2LinearAtten,\n        Light2QuadtraticAtten,\n        Light3ConstantAtten,\n        Light3LinearAtten,\n        Light3QuadtraticAtten,\n        Light0ExponentAtten = 0x87,\n        Light1ExponentAtten,\n        Light2ExponentAtten,\n        Light3ExponentAtten,\n        Light0CutoffAtten = 0x8b,\n        Light1CutoffAtten,\n        Light2CutoffAtten,\n        Light3CutoffAtten,\n        Light0Ambient = 0x8f,\n        Light0Diffuse,\n        Light0Specular,\n        Light1Ambient,\n        Light1Diffuse,\n        Light1Specular,\n        Light2Ambient,\n        Light2Diffuse,\n        Light2Specular,\n        Light3Ambient,\n        Light3Diffuse,\n        Light3Specular,\n        Cull = 0x9b,\n        FrameBufPtr = 0x9c,\n        FrameBufWidth = 0x9d,\n        ZBufPtr = 0x9e,\n        ZBufWidth = 0x9f,\n        TexAddr0 = 0xa0,\n        TexAddr1,\n        TexAddr2,\n        TexAddr3,\n        TexAddr4,\n        TexAddr5,\n        TexAddr6,\n        TexAddr7,\n        TexBufWidth0 = 0xa8,\n        TexBufWidth1,\n        TexBufWidth2,\n        TexBufWidth3,\n        TexBufWidth4,\n        TexBufWidth5,\n        TexBufWidth6,\n        TexBufWidth7,\n        ClutAddr = 0xb0,\n        ClutAddrUpper = 0xb1,\n        TransferSrc,\n        TransferSrcW,\n        TransferDst,\n        TransferDstW,\n        TexSize0 = 0xb8,\n        TexSize1,\n        TexSize2,\n        TexSize3,\n        TexSize4,\n        TexSize5,\n        TexSize6,\n        TexSize7,\n        TexMapMode = 0xc0,\n        TexShadeLs = 0xc1,\n        TexMode = 0xc2,\n        TexFormat = 0xc3,\n        LoadClut = 0xc4,\n        ClutFormat = 0xc5,\n        TexFilter = 0xc6,\n        TexWrap = 0xc7,\n        TexLevel = 0xc8,\n        TexFunc = 0xc9,\n        TexEnvColor = 0xca,\n        TexFlush = 0xcb,\n        TexSync = 0xcc,\n        Fog1 = 0xcd,\n        Fog2 = 0xce,\n        FogColor = 0xcf,\n        TexLodSlope = 0xd0,\n        FramebufPixFormat = 0xd2,\n        ClearMode = 0xd3,\n        Scissor1 = 0xd4,\n        Scissor2 = 0xd5,\n        MinZ = 0xd6,\n        MaxZ = 0xd7,\n        ColorTest = 0xd8,\n        ColorRef = 0xd9,\n        ColorTestmask = 0xda,\n        AlphaTest = 0xdb,\n        StencilTest = 0xdc,\n        StencilOp = 0xdd,\n        ZTest = 0xde,\n        BlendMode = 0xdf,\n        BlendFixedA = 0xe0,\n        BlendFixedB = 0xe1,\n        Dith0 = 0xe2,\n        Dith1,\n        Dith2,\n        Dith3,\n        LogicOp = 0xe6,\n        ZWriteDisable = 0xe7,\n        MaskRgb = 0xe8,\n        MaskAlpha = 0xe9,\n        TransferStart = 0xea,\n        TransferSrcPos = 0xeb,\n        TransferDstPos = 0xec,\n        TransferSize = 0xee,\n        Vscx = 0xf0,\n        Vscy = 0xf1,\n        Vscz = 0xf2,\n        Vtcs = 0xf3,\n        Vtct = 0xf4,\n        Vtcq = 0xf5,\n        Vcv = 0xf6,\n        Vap = 0xf7,\n        Vfc = 0xf8,\n        Vscv = 0xf9,\n\n        Unknown03 = 0x03,\n        Unknown0D = 0x0d,\n        Unknown11 = 0x11,\n        Unknown29 = 0x29,\n        Unknown34 = 0x34,\n        Unknown35 = 0x35,\n        Unknown39 = 0x39,\n        Unknown4E = 0x4e,\n        Unknown4F = 0x4f,\n        Unknown52 = 0x52,\n        Unknown59 = 0x59,\n        Unknown5A = 0x5a,\n        UnknownB6 = 0xb6,\n        UnknownB7 = 0xb7,\n        UnknownD1 = 0xd1,\n        UnknownED = 0xed,\n        UnknownEF = 0xef,\n        UnknownFA = 0xfa,\n        UnknownFB = 0xfb,\n        UnknownFC = 0xfc,\n        UnknownFD = 0xfd,\n        UnknownFE = 0xfe,\n        NopFF = 0xff,\n    }\n\n    #[repr(i32)]\n    pub enum SceSysMemPartitionId {\n        SceKernelUnknownPartition = 0,\n        SceKernelPrimaryKernelPartition = 1,\n        SceKernelPrimaryUserPartition = 2,\n        SceKernelOtherKernelPartition1 = 3,\n        SceKernelOtherKernelPartition2 = 4,\n        SceKernelVshellPARTITION = 5,\n        SceKernelScUserPartition = 6,\n        SceKernelMeUserPartition = 7,\n        SceKernelExtendedScKernelPartition = 8,\n        SceKernelExtendedSc2KernelPartition = 9,\n        SceKernelExtendedMeKernelPartition = 10,\n        SceKernelVshellKernelPartition = 11,\n        SceKernelExtendedKernelPartition = 12,\n    }\n\n    #[repr(i32)]\n    pub enum SceSysMemBlockTypes {\n        Low = 0,\n        High,\n        Addr,\n    }\n\n    #[repr(u32)]\n    pub enum Interrupt {\n        Gpio = 4,\n        Ata = 5,\n        Umd = 6,\n        Mscm0 = 7,\n        Wlan = 8,\n        Audio = 10,\n        I2c = 12,\n        Sircs = 14,\n        Systimer0 = 15,\n        Systimer1 = 16,\n        Systimer2 = 17,\n        Systimer3 = 18,\n        Thread0 = 19,\n        Nand = 20,\n        Dmacplus = 21,\n        Dma0 = 22,\n        Dma1 = 23,\n        Memlmd = 24,\n        Ge = 25,\n        Vblank = 30,\n        Mecodec = 31,\n        Hpremote = 36,\n        Mscm1 = 60,\n        Mscm2 = 61,\n        Thread1 = 65,\n        Interrupt = 66,\n    }\n\n    #[repr(u32)]\n    pub enum SubInterrupt {\n        Gpio = Interrupt::Gpio as u32,\n        Ata = Interrupt::Ata as u32,\n        Umd = Interrupt::Umd as u32,\n        Dmacplus = Interrupt::Dmacplus as u32,\n        Ge = Interrupt::Ge as u32,\n        Display = Interrupt::Vblank as u32,\n    }\n\n    #[repr(u32)]\n    pub enum SceKernelIdListType {\n        Thread = 1,\n        Semaphore = 2,\n        EventFlag = 3,\n        Mbox = 4,\n        Vpl = 5,\n        Fpl = 6,\n        Mpipe = 7,\n        Callback = 8,\n        ThreadEventHandler = 9,\n        Alarm = 10,\n        VTimer = 11,\n        SleepThread = 64,\n        DelayThread = 65,\n        SuspendThread = 66,\n        DormantThread = 67,\n    }\n\n    #[repr(i32)]\n    pub enum UsbCamResolution {\n        Px160_120 = 0,\n        Px176_144 = 1,\n        Px320_240 = 2,\n        Px352_288 = 3,\n        Px640_480 = 4,\n        Px1024_768 = 5,\n        Px1280_960 = 6,\n        Px480_272 = 7,\n        Px360_272 = 8,\n    }\n\n    #[repr(i32)]\n    pub enum UsbCamResolutionEx {\n        Px160_120 = 0,\n        Px176_144 = 1,\n        Px320_240 = 2,\n        Px352_288 = 3,\n        Px360_272 = 4,\n        Px480_272 = 5,\n        Px640_480 = 6,\n        Px1024_768 = 7,\n        Px1280_960 = 8,\n    }\n\n    #[repr(i32)]\n    pub enum UsbCamDelay {\n        NoDelay = 0,\n        Delay10Sec = 1,\n        Delay20Sec = 2,\n        Delay30Sec = 3,\n    }\n\n    #[repr(i32)]\n    pub enum UsbCamFrameRate {\n        Fps3_75 = 0,\n        Fps5 = 1,\n        Fps7_5 = 2,\n        Fps10 = 3,\n        Fps15 = 4,\n        Fps20 = 5,\n        Fps30 = 6,\n        Fps60 = 7,\n    }\n\n    #[repr(i32)]\n    pub enum UsbCamWb {\n        Auto = 0,\n        Daylight = 1,\n        Fluorescent = 2,\n        Incadescent = 3,\n    }\n\n    #[repr(i32)]\n    pub enum UsbCamEffectMode {\n        Normal = 0,\n        Negative = 1,\n        Blackwhite = 2,\n        Sepia = 3,\n        Blue = 4,\n        Red = 5,\n        Green = 6,\n    }\n\n    #[repr(i32)]\n    pub enum UsbCamEvLevel {\n        Pos2_0 = 0,\n        Pos1_7 = 1,\n        Pos1_5 = 2,\n        Pos1_3 = 3,\n        Pos1_0 = 4,\n        Pos0_7 = 5,\n        Pos0_5 = 6,\n        Pos0_3 = 7,\n        Zero = 8,\n        Neg0_3,\n        Neg0_5,\n        Neg0_7,\n        Neg1_0,\n        Neg1_3,\n        Neg1_5,\n        Neg1_7,\n        Neg2_0,\n    }\n\n    #[repr(i32)]\n    pub enum RtcCheckValidError {\n        InvalidYear = -1,\n        InvalidMonth = -2,\n        InvalidDay = -3,\n        InvalidHour = -4,\n        InvalidMinutes = -5,\n        InvalidSeconds = -6,\n        InvalidMicroseconds = -7,\n    }\n\n    #[repr(u32)]\n    pub enum PowerTick {\n        All = 0,\n        Suspend = 1,\n        Display = 6,\n    }\n\n    #[repr(u32)]\n    pub enum IoAssignPerms {\n        RdWr = 0,\n        RdOnly = 1,\n    }\n\n    #[repr(u32)]\n    pub enum IoWhence {\n        Set = 0,\n        Cur = 1,\n        End = 2,\n    }\n\n    #[repr(u32)]\n    pub enum UmdType {\n        Game = 0x10,\n        Video = 0x20,\n        Audio = 0x40,\n    }\n\n    #[repr(u32)]\n    pub enum GuPrimitive {\n        Points = 0,\n        Lines = 1,\n        LineStrip = 2,\n        Triangles = 3,\n        TriangleStrip = 4,\n        TriangleFan = 5,\n        Sprites = 6,\n    }\n\n    #[repr(u32)]\n    pub enum PatchPrimitive {\n        Points = 0,\n        LineStrip = 2,\n        TriangleStrip = 4,\n    }\n\n    #[repr(u32)]\n    pub enum GuState {\n        AlphaTest = 0,\n        DepthTest = 1,\n        ScissorTest = 2,\n        StencilTest = 3,\n        Blend = 4,\n        CullFace = 5,\n        Dither = 6,\n        Fog = 7,\n        ClipPlanes = 8,\n        Texture2D = 9,\n        Lighting = 10,\n        Light0 = 11,\n        Light1 = 12,\n        Light2 = 13,\n        Light3 = 14,\n        LineSmooth = 15,\n        PatchCullFace = 16,\n        ColorTest = 17,\n        ColorLogicOp = 18,\n        FaceNormalReverse = 19,\n        PatchFace = 20,\n        Fragment2X = 21,\n    }\n\n    #[repr(u32)]\n    pub enum MatrixMode {\n        Projection = 0,\n        View = 1,\n        Model = 2,\n        Texture = 3,\n    }\n\n    #[repr(u32)]\n    pub enum TexturePixelFormat {\n        Psm5650 = 0,\n        Psm5551 = 1,\n        Psm4444 = 2,\n        Psm8888 = 3,\n        PsmT4 = 4,\n        PsmT8 = 5,\n        PsmT16 = 6,\n        PsmT32 = 7,\n        PsmDxt1 = 8,\n        PsmDxt3 = 9,\n        PsmDxt5 = 10,\n    }\n\n    #[repr(u32)]\n    pub enum SplineMode {\n        FillFill = 0,\n        OpenFill = 1,\n        FillOpen = 2,\n        OpenOpen = 3,\n    }\n\n    #[repr(u32)]\n    pub enum ShadingModel {\n        Flat = 0,\n        Smooth = 1,\n    }\n\n    #[repr(u32)]\n    pub enum LogicalOperation {\n        Clear = 0,\n        And = 1,\n        AndReverse = 2,\n        Copy = 3,\n        AndInverted = 4,\n        Noop = 5,\n        Xor = 6,\n        Or = 7,\n        Nor = 8,\n        Equiv = 9,\n        Inverted = 10,\n        OrReverse = 11,\n        CopyInverted = 12,\n        OrInverted = 13,\n        Nand = 14,\n        Set = 15,\n    }\n\n    #[repr(u32)]\n    pub enum TextureFilter {\n        Nearest = 0,\n        Linear = 1,\n        NearestMipmapNearest = 4,\n        LinearMipmapNearest = 5,\n        NearestMipmapLinear = 6,\n        LinearMipmapLinear = 7,\n    }\n\n    #[repr(u32)]\n    pub enum TextureMapMode {\n        TextureCoords = 0,\n        TextureMatrix = 1,\n        EnvironmentMap = 2,\n    }\n\n    #[repr(u32)]\n    pub enum TextureLevelMode {\n        Auto = 0,\n        Const = 1,\n        Slope = 2,\n    }\n\n    #[repr(u32)]\n    pub enum TextureProjectionMapMode {\n        Position = 0,\n        Uv = 1,\n        NormalizedNormal = 2,\n        Normal = 3,\n    }\n\n    #[repr(u32)]\n    pub enum GuTexWrapMode {\n        Repeat = 0,\n        Clamp = 1,\n    }\n\n    #[repr(u32)]\n    pub enum FrontFaceDirection {\n        Clockwise = 0,\n        CounterClockwise = 1,\n    }\n\n    #[repr(u32)]\n    pub enum AlphaFunc {\n        Never = 0,\n        Always,\n        Equal,\n        NotEqual,\n        Less,\n        LessOrEqual,\n        Greater,\n        GreaterOrEqual,\n    }\n\n    #[repr(u32)]\n    pub enum StencilFunc {\n        Never = 0,\n        Always,\n        Equal,\n        NotEqual,\n        Less,\n        LessOrEqual,\n        Greater,\n        GreaterOrEqual,\n    }\n\n    #[repr(u32)]\n    pub enum ColorFunc {\n        Never = 0,\n        Always,\n        Equal,\n        NotEqual,\n    }\n\n    #[repr(u32)]\n    pub enum DepthFunc {\n        Never = 0,\n        Always,\n        Equal,\n        NotEqual,\n        Less,\n        LessOrEqual,\n        Greater,\n        GreaterOrEqual,\n    }\n\n    #[repr(u32)]\n    pub enum TextureEffect {\n        Modulate = 0,\n        Decal = 1,\n        Blend = 2,\n        Replace = 3,\n        Add = 4,\n    }\n\n    #[repr(u32)]\n    pub enum TextureColorComponent {\n        Rgb = 0,\n        Rgba = 1,\n    }\n\n    #[repr(u32)]\n    pub enum MipmapLevel {\n        None = 0,\n        Level1,\n        Level2,\n        Level3,\n        Level4,\n        Level5,\n        Level6,\n        Level7,\n    }\n\n    #[repr(u32)]\n    pub enum BlendOp {\n        Add = 0,\n        Subtract = 1,\n        ReverseSubtract = 2,\n        Min = 3,\n        Max = 4,\n        Abs = 5,\n    }\n\n    #[repr(u32)]\n    pub enum BlendSrc {\n        SrcColor = 0,\n        OneMinusSrcColor = 1,\n        SrcAlpha = 2,\n        OneMinusSrcAlpha = 3,\n        Fix = 10,\n    }\n\n    #[repr(u32)]\n    pub enum BlendDst {\n        DstColor = 0,\n        OneMinusDstColor = 1,\n        DstAlpha = 4,\n        OneMinusDstAlpha = 5,\n        Fix = 10,\n    }\n\n    #[repr(u32)]\n    pub enum StencilOperation {\n        Keep = 0,\n        Zero = 1,\n        Replace = 2,\n        Invert = 3,\n        Incr = 4,\n        Decr = 5,\n    }\n\n    #[repr(u32)]\n    pub enum LightMode {\n        SingleColor = 0,\n        SeparateSpecularColor = 1,\n    }\n\n    #[repr(u32)]\n    pub enum LightType {\n        Directional = 0,\n        Pointlight = 1,\n        Spotlight = 2,\n    }\n\n    #[repr(u32)]\n    pub enum GuContextType {\n        Direct = 0,\n        Call = 1,\n        Send = 2,\n    }\n\n    #[repr(u32)]\n    pub enum GuQueueMode {\n        Tail = 0,\n        Head = 1,\n    }\n\n    #[repr(u32)]\n    pub enum GuSyncMode {\n        Finish = 0,\n        Signal = 1,\n        Done = 2,\n        List = 3,\n        Send = 4,\n    }\n\n    #[repr(u32)]\n    pub enum GuSyncBehavior {\n        Wait = 0,\n        NoWait = 1,\n    }\n\n    #[repr(u32)]\n    pub enum GuCallbackId {\n        Signal = 1,\n        Finish = 4,\n    }\n\n    #[repr(u32)]\n    pub enum SignalBehavior {\n        Suspend = 1,\n        Continue = 2,\n    }\n\n    #[repr(u32)]\n    pub enum ClutPixelFormat {\n        Psm5650 = 0,\n        Psm5551 = 1,\n        Psm4444 = 2,\n        Psm8888 = 3,\n    }\n\n    #[repr(C)]\n    pub enum KeyType {\n        Directory = 1,\n        Integer = 2,\n        String = 3,\n        Bytes = 4,\n    }\n\n    #[repr(u32)]\n    pub enum UtilityMsgDialogMode {\n        Error,\n        Text,\n    }\n\n    #[repr(u32)]\n    pub enum UtilityMsgDialogPressed {\n        Unknown1,\n        Yes,\n        No,\n        Back,\n    }\n\n    #[repr(u32)]\n    pub enum UtilityDialogButtonAccept {\n        Circle,\n        Cross,\n    }\n\n    #[repr(u32)]\n    pub enum SceUtilityOskInputLanguage {\n        Default,\n        Japanese,\n        English,\n        French,\n        Spanish,\n        German,\n        Italian,\n        Dutch,\n        Portugese,\n        Russian,\n        Korean,\n    }\n\n    #[repr(u32)]\n    pub enum SceUtilityOskInputType {\n        All,\n        LatinDigit,\n        LatinSymbol,\n        LatinLowercase = 4,\n        LatinUppercase = 8,\n        JapaneseDigit = 0x100,\n        JapaneseSymbol = 0x200,\n        JapaneseLowercase = 0x400,\n        JapaneseUppercase = 0x800,\n        JapaneseHiragana = 0x1000,\n        JapaneseHalfWidthKatakana = 0x2000,\n        JapaneseKatakana = 0x4000,\n        JapaneseKanji = 0x8000,\n        RussianLowercase = 0x10000,\n        RussianUppercase = 0x20000,\n        Korean = 0x40000,\n        Url = 0x80000,\n    }\n\n    #[repr(u32)]\n    pub enum SceUtilityOskState {\n        None,\n        Initializing,\n        Initialized,\n        Visible,\n        Quit,\n        Finished,\n    }\n\n    #[repr(u32)]\n    pub enum SceUtilityOskResult {\n        Unchanged,\n        Cancelled,\n        Changed,\n    }\n\n    #[repr(u32)]\n    pub enum SystemParamLanguage {\n        Japanese,\n        English,\n        French,\n        Spanish,\n        German,\n        Italian,\n        Dutch,\n        Portugese,\n        Russian,\n        Korean,\n        ChineseTraditional,\n        ChineseSimplified,\n    }\n\n    #[repr(u32)]\n    pub enum SystemParamId {\n        StringNickname = 1,\n        AdhocChannel,\n        WlanPowerSave,\n        DateFormat,\n        TimeFormat,\n        Timezone,\n        DaylightSavings,\n        Language,\n        Unknown,\n    }\n\n    #[repr(u32)]\n    pub enum SystemParamAdhocChannel {\n        ChannelAutomatic = 0,\n        Channel1 = 1,\n        Channel6 = 6,\n        Channel11 = 11,\n    }\n\n    #[repr(u32)]\n    pub enum SystemParamWlanPowerSaveState {\n        Off,\n        On,\n    }\n\n    #[repr(u32)]\n    pub enum SystemParamDateFormat {\n        YYYYMMDD,\n        MMDDYYYY,\n        DDMMYYYY,\n    }\n\n    #[repr(u32)]\n    pub enum SystemParamTimeFormat {\n        Hour24,\n        Hour12,\n    }\n\n    #[repr(u32)]\n    pub enum SystemParamDaylightSavings {\n        Std,\n        Dst,\n    }\n\n    #[repr(u32)]\n    pub enum AvModule {\n        AvCodec,\n        SasCore,\n        Atrac3Plus,\n        MpegBase,\n        Mp3,\n        Vaudio,\n        Aac,\n        G729,\n    }\n\n    #[repr(u32)]\n    pub enum Module {\n        NetCommon = 0x100,\n        NetAdhoc,\n        NetInet,\n        NetParseUri,\n        NetHttp,\n        NetSsl,\n\n        UsbPspCm = 0x200,\n        UsbMic,\n        UsbCam,\n        UsbGps,\n\n        AvCodec = 0x300,\n        AvSascore,\n        AvAtrac3Plus,\n        AvMpegBase,\n        AvMp3,\n        AvVaudio,\n        AvAac,\n        AvG729,\n\n        NpCommon = 0x400,\n        NpService,\n        NpMatching2,\n        NpDrm = 0x500,\n\n        Irda = 0x600,\n    }\n\n    #[repr(u32)]\n    pub enum NetModule {\n        NetCommon = 1,\n        NetAdhoc,\n        NetInet,\n        NetParseUri,\n        NetHttp,\n        NetSsl,\n    }\n\n    #[repr(u32)]\n    pub enum UsbModule {\n        UsbPspCm = 1,\n        UsbAcc,\n        UsbMic,\n        UsbCam,\n        UsbGps,\n    }\n\n    #[repr(u32)]\n    pub enum NetParam {\n        Name,\n        Ssid,\n        Secure,\n        WepKey,\n        IsStaticIp,\n        Ip,\n        NetMask,\n        Route,\n        ManualDns,\n        PrimaryDns,\n        SecondaryDns,\n        ProxyUser,\n        ProxyPass,\n        UseProxy,\n        ProxyServer,\n        ProxyPort,\n        Unknown1,\n        Unknown2,\n    }\n\n    #[repr(u32)]\n    pub enum UtilityNetconfAction {\n        ConnectAP,\n        DisplayStatus,\n        ConnectAdhoc,\n    }\n\n    #[repr(u32)]\n    pub enum UtilitySavedataMode {\n        AutoLoad,\n        AutoSave,\n        Load,\n        Save,\n        ListLoad,\n        ListSave,\n        ListDelete,\n        Delete,\n    }\n\n    #[repr(u32)]\n    pub enum UtilitySavedataFocus {\n        Unknown1,\n        FirstList,\n        LastList,\n        Latest,\n        Oldest,\n        Unknown2,\n        Unknown3,\n        FirstEmpty,\n        LastEmpty,\n    }\n\n    #[repr(u32)]\n    pub enum UtilityGameSharingMode {\n        Single = 1,\n        Multiple,\n    }\n\n    #[repr(u32)]\n    pub enum UtilityGameSharingDataType {\n        File = 1,\n        Memory,\n    }\n\n    #[repr(u32)]\n    pub enum UtilityHtmlViewerInterfaceMode {\n        Full,\n        Limited,\n        None,\n    }\n\n    #[repr(u32)]\n    pub enum UtilityHtmlViewerCookieMode {\n        Disabled = 0,\n        Enabled,\n        Confirm,\n        Default,\n    }\n\n    #[repr(u32)]\n    pub enum UtilityHtmlViewerTextSize {\n        Large,\n        Normal,\n        Small,\n    }\n\n    #[repr(u32)]\n    pub enum UtilityHtmlViewerDisplayMode {\n        Normal,\n        Fit,\n        SmartFit,\n    }\n\n    #[repr(u32)]\n    pub enum UtilityHtmlViewerConnectMode {\n        Last,\n        ManualOnce,\n        ManualAll,\n    }\n\n    #[repr(u32)]\n    pub enum UtilityHtmlViewerDisconnectMode {\n        Enable,\n        Disable,\n        Confirm,\n    }\n\n    #[repr(u32)]\n    pub enum ScePspnetAdhocPtpState {\n        Closed,\n        Listen,\n        SynSent,\n        SynReceived,\n        Established,\n    }\n\n    #[repr(u32)]\n    pub enum AdhocMatchingMode {\n        Host = 1,\n        Client,\n        Ptp,\n    }\n\n    #[repr(u32)]\n    pub enum ApctlState {\n        Disconnected,\n        Scanning,\n        Joining,\n        GettingIp,\n        GotIp,\n        EapAuth,\n        KeyExchange,\n    }\n\n    #[repr(u32)]\n    pub enum ApctlEvent {\n        ConnectRequest,\n        ScanRequest,\n        ScanComplete,\n        Established,\n        GetIp,\n        DisconnectRequest,\n        Error,\n        Info,\n        EapAuth,\n        KeyExchange,\n        Reconnect,\n    }\n\n    #[repr(u32)]\n    pub enum ApctlInfo {\n        ProfileName,\n        Bssid,\n        Ssid,\n        SsidLength,\n        SecurityType,\n        Strength,\n        Channel,\n        PowerSave,\n        Ip,\n        SubnetMask,\n        Gateway,\n        PrimaryDns,\n        SecondaryDns,\n        UseProxy,\n        ProxyUrl,\n        ProxyPort,\n        EapType,\n        StartBrowser,\n        Wifisp,\n    }\n\n    #[repr(u32)]\n    pub enum ApctlInfoSecurityType {\n        None,\n        Wep,\n        Wpa,\n    }\n\n    #[repr(u32)]\n    pub enum HttpMethod {\n        Get,\n        Post,\n        Head,\n    }\n\n    #[repr(u32)]\n    pub enum HttpAuthType {\n        Basic,\n        Digest,\n    }\n}\n\ns_paren! {\n    #[repr(transparent)]\n    pub struct SceUid(pub i32);\n\n    #[repr(transparent)]\n    pub struct SceMpeg(*mut *mut c_void);\n\n    #[repr(transparent)]\n    pub struct SceMpegStream(*mut c_void);\n\n    #[repr(transparent)]\n    pub struct Mp3Handle(pub i32);\n\n    #[repr(transparent)]\n    pub struct RegHandle(u32);\n}\n\ns! {\n    pub struct sockaddr {\n        pub sa_len: u8,\n        pub sa_family: u8,\n        pub sa_data: [u8;14],\n    }\n\n    pub struct in_addr {\n        pub s_addr: u32,\n    }\n\n    pub struct AudioInputParams {\n        pub unknown1: i32,\n        pub gain: i32,\n        pub unknown2: i32,\n        pub unknown3: i32,\n        pub unknown4: i32,\n        pub unknown5: i32,\n    }\n\n    pub struct Atrac3BufferInfo {\n        pub puc_write_position_first_buf: *mut u8,\n        pub ui_writable_byte_first_buf: u32,\n        pub ui_min_write_byte_first_buf: u32,\n        pub ui_read_position_first_buf: u32,\n        pub puc_write_position_second_buf: *mut u8,\n        pub ui_writable_byte_second_buf: u32,\n        pub ui_min_write_byte_second_buf: u32,\n        pub ui_read_position_second_buf: u32,\n    }\n\n    pub struct SceCtrlData {\n        pub timestamp: u32,\n        pub buttons: i32,\n        pub lx: u8,\n        pub ly: u8,\n        pub rsrv: [u8; 6],\n    }\n\n    pub struct SceCtrlLatch {\n        pub ui_make: u32,\n        pub ui_break: u32,\n        pub ui_press: u32,\n        pub ui_release: u32,\n    }\n\n    pub struct GeStack {\n        pub stack: [u32; 8],\n    }\n\n    pub struct GeCallbackData {\n        pub signal_func: ::Option<extern \"C\" fn(id: i32, arg: *mut c_void)>,\n        pub signal_arg: *mut c_void,\n        pub finish_func: ::Option<extern \"C\" fn(id: i32, arg: *mut c_void)>,\n        pub finish_arg: *mut c_void,\n    }\n\n    pub struct GeListArgs {\n        pub size: u32,\n        pub context: *mut GeContext,\n        pub num_stacks: u32,\n        pub stacks: *mut GeStack,\n    }\n\n    pub struct GeBreakParam {\n        pub buf: [u32; 4],\n    }\n\n    pub struct SceKernelLoadExecParam {\n        pub size: usize,\n        pub args: usize,\n        pub argp: *mut c_void,\n        pub key: *const u8,\n    }\n\n    pub struct timeval {\n        pub tv_sec: i32,\n        pub tv_usec: i32,\n    }\n\n    pub struct timezone {\n        pub tz_minutes_west: i32,\n        pub tz_dst_time: i32,\n    }\n\n    pub struct IntrHandlerOptionParam {\n        size: i32,\n        entry: u32,\n        common: u32,\n        gp: u32,\n        intr_code: u16,\n        sub_count: u16,\n        intr_level: u16,\n        enabled: u16,\n        calls: u32,\n        field_1c: u32,\n        total_clock_lo: u32,\n        total_clock_hi: u32,\n        min_clock_lo: u32,\n        min_clock_hi: u32,\n        max_clock_lo: u32,\n        max_clock_hi: u32,\n    }\n\n    pub struct SceKernelLMOption {\n        pub size: usize,\n        pub m_pid_text: SceUid,\n        pub m_pid_data: SceUid,\n        pub flags: u32,\n        pub position: u8,\n        pub access: u8,\n        pub c_reserved: [u8; 2usize],\n    }\n\n    pub struct SceKernelSMOption {\n        pub size: usize,\n        pub m_pid_stack: SceUid,\n        pub stack_size: usize,\n        pub priority: i32,\n        pub attribute: u32,\n    }\n\n    pub struct SceKernelModuleInfo {\n        pub size: usize,\n        pub n_segment: u8,\n        pub reserved: [u8; 3usize],\n        pub segment_addr: [i32; 4usize],\n        pub segment_size: [i32; 4usize],\n        pub entry_addr: u32,\n        pub gp_value: u32,\n        pub text_addr: u32,\n        pub text_size: u32,\n        pub data_size: u32,\n        pub bss_size: u32,\n        pub attribute: u16,\n        pub version: [u8; 2usize],\n        pub name: [u8; 28usize],\n    }\n\n    pub struct DebugProfilerRegs {\n        pub enable: u32,\n        pub systemck: u32,\n        pub cpuck: u32,\n        pub internal: u32,\n        pub memory: u32,\n        pub copz: u32,\n        pub vfpu: u32,\n        pub sleep: u32,\n        pub bus_access: u32,\n        pub uncached_load: u32,\n        pub uncached_store: u32,\n        pub cached_load: u32,\n        pub cached_store: u32,\n        pub i_miss: u32,\n        pub d_miss: u32,\n        pub d_writeback: u32,\n        pub cop0_inst: u32,\n        pub fpu_inst: u32,\n        pub vfpu_inst: u32,\n        pub local_bus: u32,\n    }\n\n    pub struct SceKernelSysClock {\n        pub low: u32,\n        pub hi: u32,\n    }\n\n    pub struct SceKernelThreadOptParam {\n        pub size: usize,\n        pub stack_mpid: SceUid,\n    }\n\n    pub struct SceKernelThreadInfo {\n        pub size: usize,\n        pub name: [u8; 32],\n        pub attr: u32,\n        pub status: i32,\n        pub entry: SceKernelThreadEntry,\n        pub stack: *mut c_void,\n        pub stack_size: i32,\n        pub gp_reg: *mut c_void,\n        pub init_priority: i32,\n        pub current_priority: i32,\n        pub wait_type: i32,\n        pub wait_id: SceUid,\n        pub wakeup_count: i32,\n        pub exit_status: i32,\n        pub run_clocks: SceKernelSysClock,\n        pub intr_preempt_count: u32,\n        pub thread_preempt_count: u32,\n        pub release_count: u32,\n    }\n\n    pub struct SceKernelThreadRunStatus {\n        pub size: usize,\n        pub status: i32,\n        pub current_priority: i32,\n        pub wait_type: i32,\n        pub wait_id: i32,\n        pub wakeup_count: i32,\n        pub run_clocks: SceKernelSysClock,\n        pub intr_preempt_count: u32,\n        pub thread_preempt_count: u32,\n        pub release_count: u32,\n    }\n\n    pub struct SceKernelSemaOptParam {\n        pub size: usize,\n    }\n\n    pub struct SceKernelSemaInfo {\n        pub size: usize,\n        pub name: [u8; 32],\n        pub attr: u32,\n        pub init_count: i32,\n        pub current_count: i32,\n        pub max_count: i32,\n        pub num_wait_threads: i32,\n    }\n\n    pub struct SceKernelEventFlagInfo {\n        pub size: usize,\n        pub name: [u8; 32],\n        pub attr: u32,\n        pub init_pattern: u32,\n        pub current_pattern: u32,\n        pub num_wait_threads: i32,\n    }\n\n    pub struct SceKernelEventFlagOptParam {\n        pub size: usize,\n    }\n\n    pub struct SceKernelMbxOptParam {\n        pub size: usize,\n    }\n\n    pub struct SceKernelMbxInfo {\n        pub size: usize,\n        pub name: [u8; 32usize],\n        pub attr: u32,\n        pub num_wait_threads: i32,\n        pub num_messages: i32,\n        pub first_message: *mut c_void,\n    }\n\n    pub struct SceKernelVTimerInfo {\n        pub size: usize,\n        pub name: [u8; 32],\n        pub active: i32,\n        pub base: SceKernelSysClock,\n        pub current: SceKernelSysClock,\n        pub schedule: SceKernelSysClock,\n        pub handler: SceKernelVTimerHandler,\n        pub common: *mut c_void,\n    }\n\n    pub struct SceKernelThreadEventHandlerInfo {\n        pub size: usize,\n        pub name: [u8; 32],\n        pub thread_id: SceUid,\n        pub mask: i32,\n        pub handler: SceKernelThreadEventHandler,\n        pub common: *mut c_void,\n    }\n\n    pub struct SceKernelAlarmInfo {\n        pub size: usize,\n        pub schedule: SceKernelSysClock,\n        pub handler: SceKernelAlarmHandler,\n        pub common: *mut c_void,\n    }\n\n    pub struct SceKernelSystemStatus {\n        pub size: usize,\n        pub status: u32,\n        pub idle_clocks: SceKernelSysClock,\n        pub comes_out_of_idle_count: u32,\n        pub thread_switch_count: u32,\n        pub vfpu_switch_count: u32,\n    }\n\n    pub struct SceKernelMppInfo {\n        pub size: usize,\n        pub name: [u8; 32],\n        pub attr: u32,\n        pub buf_size: i32,\n        pub free_size: i32,\n        pub num_send_wait_threads: i32,\n        pub num_receive_wait_threads: i32,\n    }\n\n    pub struct SceKernelVplOptParam {\n        pub size: usize,\n    }\n\n    pub struct SceKernelVplInfo {\n        pub size: usize,\n        pub name: [u8; 32],\n        pub attr: u32,\n        pub pool_size: i32,\n        pub free_size: i32,\n        pub num_wait_threads: i32,\n    }\n\n    pub struct SceKernelFplOptParam {\n        pub size: usize,\n    }\n\n    pub struct SceKernelFplInfo {\n        pub size: usize,\n        pub name: [u8; 32usize],\n        pub attr: u32,\n        pub block_size: i32,\n        pub num_blocks: i32,\n        pub free_blocks: i32,\n        pub num_wait_threads: i32,\n    }\n\n    pub struct SceKernelVTimerOptParam {\n        pub size: usize,\n    }\n\n    pub struct SceKernelCallbackInfo {\n        pub size: usize,\n        pub name: [u8; 32usize],\n        pub thread_id: SceUid,\n        pub callback: SceKernelCallbackFunction,\n        pub common: *mut c_void,\n        pub notify_count: i32,\n        pub notify_arg: i32,\n    }\n\n    pub struct UsbCamSetupStillParam {\n        pub size: i32,\n        pub resolution: UsbCamResolution,\n        pub jpeg_size: i32,\n        pub reverse_flags: i32,\n        pub delay: UsbCamDelay,\n        pub comp_level: i32,\n    }\n\n    pub struct UsbCamSetupStillExParam {\n        pub size: i32,\n        pub unk: u32,\n        pub resolution: UsbCamResolutionEx,\n        pub jpeg_size: i32,\n        pub comp_level: i32,\n        pub unk2: u32,\n        pub unk3: u32,\n        pub flip: i32,\n        pub mirror: i32,\n        pub delay: UsbCamDelay,\n        pub unk4: [u32; 5usize],\n    }\n\n    pub struct UsbCamSetupVideoParam {\n        pub size: i32,\n        pub resolution: UsbCamResolution,\n        pub framerate: UsbCamFrameRate,\n        pub white_balance: UsbCamWb,\n        pub saturation: i32,\n        pub brightness: i32,\n        pub contrast: i32,\n        pub sharpness: i32,\n        pub effect_mode: UsbCamEffectMode,\n        pub frame_size: i32,\n        pub unk: u32,\n        pub evl_evel: UsbCamEvLevel,\n    }\n\n    pub struct UsbCamSetupVideoExParam {\n        pub size: i32,\n        pub unk: u32,\n        pub resolution: UsbCamResolutionEx,\n        pub framerate: UsbCamFrameRate,\n        pub unk2: u32,\n        pub unk3: u32,\n        pub white_balance: UsbCamWb,\n        pub saturation: i32,\n        pub brightness: i32,\n        pub contrast: i32,\n        pub sharpness: i32,\n        pub unk4: u32,\n        pub unk5: u32,\n        pub unk6: [u32; 3usize],\n        pub effect_mode: UsbCamEffectMode,\n        pub unk7: u32,\n        pub unk8: u32,\n        pub unk9: u32,\n        pub unk10: u32,\n        pub unk11: u32,\n        pub frame_size: i32,\n        pub unk12: u32,\n        pub ev_level: UsbCamEvLevel,\n    }\n\n    pub struct ScePspDateTime {\n        pub year: u16,\n        pub month: u16,\n        pub day: u16,\n        pub hour: u16,\n        pub minutes: u16,\n        pub seconds: u16,\n        pub microseconds: u32,\n    }\n\n    pub struct SceIoStat {\n        pub st_mode: i32,\n        pub st_attr: i32,\n        pub st_size: i64,\n        pub st_ctime: ScePspDateTime,\n        pub st_atime: ScePspDateTime,\n        pub st_mtime: ScePspDateTime,\n        pub st_private: [u32; 6usize],\n    }\n\n    pub struct UmdInfo {\n        pub size: u32,\n        pub type_: UmdType,\n    }\n\n    pub struct SceMpegRingbuffer {\n        pub packets: i32,\n        pub unk0: u32,\n        pub unk1: u32,\n        pub unk2: u32,\n        pub unk3: u32,\n        pub data: *mut c_void,\n        pub callback: SceMpegRingbufferCb,\n        pub cb_param: *mut c_void,\n        pub unk4: u32,\n        pub unk5: u32,\n        pub sce_mpeg: *mut c_void,\n    }\n\n    pub struct SceMpegAu {\n        pub pts_msb: u32,\n        pub pts: u32,\n        pub dts_msb: u32,\n        pub dts: u32,\n        pub es_buffer: u32,\n        pub au_size: u32,\n    }\n\n    pub struct SceMpegAvcMode {\n        pub unk0: i32,\n        pub pixel_format: super::DisplayPixelFormat,\n    }\n\n    #[repr(align(64))]\n    pub struct SceMpegLLI {\n        pub src: *mut c_void,\n        pub dst: *mut c_void,\n        pub next: *mut c_void,\n        pub size: i32,\n    }\n\n    #[repr(align(64))]\n    pub struct SceMpegYCrCbBuffer {\n        pub frame_buffer_height16: i32,\n        pub frame_buffer_width16: i32,\n        pub unknown: i32,\n        pub unknown2: i32,\n        pub y_buffer: *mut c_void,\n        pub y_buffer2: *mut c_void,\n        pub cr_buffer: *mut c_void,\n        pub cb_buffer: *mut c_void,\n        pub cr_buffer2: *mut c_void,\n        pub cb_buffer2: *mut c_void,\n\n        pub frame_height: i32,\n        pub frame_width: i32,\n        pub frame_buffer_width: i32,\n        pub unknown3: [i32; 11usize],\n    }\n\n    pub struct ScePspSRect {\n        pub x: i16,\n        pub y: i16,\n        pub w: i16,\n        pub h: i16,\n    }\n\n    pub struct ScePspIRect {\n        pub x: i32,\n        pub y: i32,\n        pub w: i32,\n        pub h: i32,\n    }\n\n    pub struct ScePspL64Rect {\n        pub x: u64,\n        pub y: u64,\n        pub w: u64,\n        pub h: u64,\n    }\n\n    pub struct ScePspSVector2 {\n        pub x: i16,\n        pub y: i16,\n    }\n\n    pub struct ScePspIVector2 {\n        pub x: i32,\n        pub y: i32,\n    }\n\n    pub struct ScePspL64Vector2 {\n        pub x: u64,\n        pub y: u64,\n    }\n\n    pub struct ScePspSVector3 {\n        pub x: i16,\n        pub y: i16,\n        pub z: i16,\n    }\n\n    pub struct ScePspIVector3 {\n        pub x: i32,\n        pub y: i32,\n        pub z: i32,\n    }\n\n    pub struct ScePspL64Vector3 {\n        pub x: u64,\n        pub y: u64,\n        pub z: u64,\n    }\n\n    pub struct ScePspSVector4 {\n        pub x: i16,\n        pub y: i16,\n        pub z: i16,\n        pub w: i16,\n    }\n\n    pub struct ScePspIVector4 {\n        pub x: i32,\n        pub y: i32,\n        pub z: i32,\n        pub w: i32,\n    }\n\n    pub struct ScePspL64Vector4 {\n        pub x: u64,\n        pub y: u64,\n        pub z: u64,\n        pub w: u64,\n    }\n\n    pub struct ScePspIMatrix2 {\n        pub x: ScePspIVector2,\n        pub y: ScePspIVector2,\n    }\n\n    pub struct ScePspIMatrix3 {\n        pub x: ScePspIVector3,\n        pub y: ScePspIVector3,\n        pub z: ScePspIVector3,\n    }\n\n    #[repr(align(16))]\n    pub struct ScePspIMatrix4 {\n        pub x: ScePspIVector4,\n        pub y: ScePspIVector4,\n        pub z: ScePspIVector4,\n        pub w: ScePspIVector4,\n    }\n\n    pub struct ScePspIMatrix4Unaligned {\n        pub x: ScePspIVector4,\n        pub y: ScePspIVector4,\n        pub z: ScePspIVector4,\n        pub w: ScePspIVector4,\n    }\n\n    pub struct SceMp3InitArg {\n        pub mp3_stream_start: u32,\n        pub unk1: u32,\n        pub mp3_stream_end: u32,\n        pub unk2: u32,\n        pub mp3_buf: *mut c_void,\n        pub mp3_buf_size: i32,\n        pub pcm_buf: *mut c_void,\n        pub pcm_buf_size: i32,\n    }\n\n    pub struct OpenPSID {\n        pub data: [u8; 16usize],\n    }\n\n    pub struct UtilityDialogCommon {\n        pub size: u32,\n        pub language: SystemParamLanguage,\n        pub button_accept: UtilityDialogButtonAccept,\n        pub graphics_thread: i32,\n        pub access_thread: i32,\n        pub font_thread: i32,\n        pub sound_thread: i32,\n        pub result: i32,\n        pub reserved: [i32; 4usize],\n    }\n\n    pub struct UtilityNetconfAdhoc {\n        pub name: [u8; 8usize],\n        pub timeout: u32,\n    }\n\n    pub struct UtilityNetconfData {\n        pub base: UtilityDialogCommon,\n        pub action: UtilityNetconfAction,\n        pub adhocparam: *mut UtilityNetconfAdhoc,\n        pub hotspot: i32,\n        pub hotspot_connected: i32,\n        pub wifisp: i32,\n    }\n\n    pub struct UtilitySavedataFileData {\n        pub buf: *mut c_void,\n        pub buf_size: usize,\n        pub size: usize,\n        pub unknown: i32,\n    }\n\n    pub struct UtilitySavedataListSaveNewData {\n        pub icon0: UtilitySavedataFileData,\n        pub title: *mut u8,\n    }\n\n    pub struct UtilityGameSharingParams {\n        pub base: UtilityDialogCommon,\n        pub unknown1: i32,\n        pub unknown2: i32,\n        pub name: [u8; 8usize],\n        pub unknown3: i32,\n        pub unknown4: i32,\n        pub unknown5: i32,\n        pub result: i32,\n        pub filepath: *mut u8,\n        pub mode: UtilityGameSharingMode,\n        pub datatype: UtilityGameSharingDataType,\n        pub data: *mut c_void,\n        pub datasize: u32,\n    }\n\n    pub struct UtilityHtmlViewerParam {\n        pub base: UtilityDialogCommon,\n        pub memaddr: *mut c_void,\n        pub memsize: u32,\n        pub unknown1: i32,\n        pub unknown2: i32,\n        pub initialurl: *mut u8,\n        pub numtabs: u32,\n        pub interfacemode: UtilityHtmlViewerInterfaceMode,\n        pub options: i32,\n        pub dldirname: *mut u8,\n        pub dlfilename: *mut u8,\n        pub uldirname: *mut u8,\n        pub ulfilename: *mut u8,\n        pub cookiemode: UtilityHtmlViewerCookieMode,\n        pub unknown3: u32,\n        pub homeurl: *mut u8,\n        pub textsize: UtilityHtmlViewerTextSize,\n        pub displaymode: UtilityHtmlViewerDisplayMode,\n        pub connectmode: UtilityHtmlViewerConnectMode,\n        pub disconnectmode: UtilityHtmlViewerDisconnectMode,\n        pub memused: u32,\n        pub unknown4: [i32; 10usize],\n    }\n\n    pub struct SceUtilityOskData {\n        pub unk_00: i32,\n        pub unk_04: i32,\n        pub language: SceUtilityOskInputLanguage,\n        pub unk_12: i32,\n        pub inputtype: SceUtilityOskInputType,\n        pub lines: i32,\n        pub unk_24: i32,\n        pub desc: *mut u16,\n        pub intext: *mut u16,\n        pub outtextlength: i32,\n        pub outtext: *mut u16,\n        pub result: SceUtilityOskResult,\n        pub outtextlimit: i32,\n    }\n\n    pub struct SceUtilityOskParams {\n        pub base: UtilityDialogCommon,\n        pub datacount: i32,\n        pub data: *mut SceUtilityOskData,\n        pub state: SceUtilityOskState,\n        pub unk_60: i32,\n    }\n\n    pub struct SceNetMallocStat {\n        pub pool: i32,\n        pub maximum: i32,\n        pub free: i32,\n    }\n\n    pub struct SceNetAdhocctlAdhocId {\n        pub unknown: i32,\n        pub adhoc_id: [u8; 9usize],\n        pub unk: [u8; 3usize],\n    }\n\n    pub struct SceNetAdhocctlScanInfo {\n        pub next: *mut SceNetAdhocctlScanInfo,\n        pub channel: i32,\n        pub name: [u8; 8usize],\n        pub bssid: [u8; 6usize],\n        pub unknown: [u8; 2usize],\n        pub unknown2: i32,\n    }\n\n    pub struct SceNetAdhocctlGameModeInfo {\n        pub count: i32,\n        pub macs: [[u8; 6usize]; 16usize],\n    }\n\n    pub struct SceNetAdhocPtpStat {\n        pub next: *mut SceNetAdhocPtpStat,\n        pub ptp_id: i32,\n        pub mac: [u8; 6usize],\n        pub peermac: [u8; 6usize],\n        pub port: u16,\n        pub peerport: u16,\n        pub sent_data: u32,\n        pub rcvd_data: u32,\n        pub state: ScePspnetAdhocPtpState,\n    }\n\n    pub struct SceNetAdhocPdpStat {\n        pub next: *mut SceNetAdhocPdpStat,\n        pub pdp_id: i32,\n        pub mac: [u8; 6usize],\n        pub port: u16,\n        pub rcvd_data: u32,\n    }\n\n    pub struct AdhocPoolStat {\n        pub size: i32,\n        pub maxsize: i32,\n        pub freesize: i32,\n    }\n}\n\ns_no_extra_traits! {\n    #[allow(missing_debug_implementations)]\n    pub struct GeContext {\n        pub context: [u32; 512],\n    }\n\n    #[allow(missing_debug_implementations)]\n    pub struct SceKernelUtilsSha1Context {\n        pub h: [u32; 5usize],\n        pub us_remains: u16,\n        pub us_computed: u16,\n        pub ull_total_len: u64,\n        pub buf: [u8; 64usize],\n    }\n\n    #[allow(missing_debug_implementations)]\n    pub struct SceKernelUtilsMt19937Context {\n        pub count: u32,\n        pub state: [u32; 624usize],\n    }\n\n    #[allow(missing_debug_implementations)]\n    pub struct SceKernelUtilsMd5Context {\n        pub h: [u32; 4usize],\n        pub pad: u32,\n        pub us_remains: u16,\n        pub us_computed: u16,\n        pub ull_total_len: u64,\n        pub buf: [u8; 64usize],\n    }\n\n    #[allow(missing_debug_implementations)]\n    pub struct SceIoDirent {\n        pub d_stat: SceIoStat,\n        pub d_name: [u8; 256usize],\n        pub d_private: *mut c_void,\n        pub dummy: i32,\n    }\n\n    #[cfg_attr(feature = \"extra_traits\", derive(Debug))]\n    pub struct ScePspFRect {\n        pub x: f32,\n        pub y: f32,\n        pub w: f32,\n        pub h: f32,\n    }\n\n    #[repr(align(16))]\n    #[cfg_attr(feature = \"extra_traits\", derive(Debug))]\n    pub struct ScePspFVector3 {\n        pub x: f32,\n        pub y: f32,\n        pub z: f32,\n    }\n\n    #[repr(align(16))]\n    #[cfg_attr(feature = \"extra_traits\", derive(Debug))]\n    pub struct ScePspFVector4 {\n        pub x: f32,\n        pub y: f32,\n        pub z: f32,\n        pub w: f32,\n    }\n\n    #[cfg_attr(feature = \"extra_traits\", derive(Debug))]\n    pub struct ScePspFVector4Unaligned {\n        pub x: f32,\n        pub y: f32,\n        pub z: f32,\n        pub w: f32,\n    }\n\n    #[cfg_attr(feature = \"extra_traits\", derive(Debug))]\n    pub struct ScePspFVector2 {\n        pub x: f32,\n        pub y: f32,\n    }\n\n    #[cfg_attr(feature = \"extra_traits\", derive(Debug))]\n    pub struct ScePspFMatrix2 {\n        pub x: ScePspFVector2,\n        pub y: ScePspFVector2,\n    }\n\n    #[cfg_attr(feature = \"extra_traits\", derive(Debug))]\n    pub struct ScePspFMatrix3 {\n        pub x: ScePspFVector3,\n        pub y: ScePspFVector3,\n        pub z: ScePspFVector3,\n    }\n\n    #[cfg_attr(feature = \"extra_traits\", derive(Debug))]\n    #[repr(align(16))]\n    pub struct ScePspFMatrix4 {\n        pub x: ScePspFVector4,\n        pub y: ScePspFVector4,\n        pub z: ScePspFVector4,\n        pub w: ScePspFVector4,\n    }\n\n    #[allow(missing_debug_implementations)]\n    pub struct ScePspFMatrix4Unaligned {\n        pub x: ScePspFVector4,\n        pub y: ScePspFVector4,\n        pub z: ScePspFVector4,\n        pub w: ScePspFVector4,\n    }\n\n    #[allow(missing_debug_implementations)]\n    pub union ScePspVector3 {\n        pub fv: ScePspFVector3,\n        pub iv: ScePspIVector3,\n        pub f: [f32; 3usize],\n        pub i: [i32; 3usize],\n    }\n\n    #[allow(missing_debug_implementations)]\n    pub union ScePspVector4 {\n        pub fv: ScePspFVector4,\n        pub iv: ScePspIVector4,\n        pub qw: u128,\n        pub f: [f32; 4usize],\n        pub i: [i32; 4usize],\n    }\n\n    #[allow(missing_debug_implementations)]\n    pub union ScePspMatrix2 {\n        pub fm: ScePspFMatrix2,\n        pub im: ScePspIMatrix2,\n        pub fv: [ScePspFVector2; 2usize],\n        pub iv: [ScePspIVector2; 2usize],\n        pub v: [ScePspVector2; 2usize],\n        pub f: [[f32; 2usize]; 2usize],\n        pub i: [[i32; 2usize]; 2usize],\n    }\n\n    #[allow(missing_debug_implementations)]\n    pub union ScePspMatrix3 {\n        pub fm: ScePspFMatrix3,\n        pub im: ScePspIMatrix3,\n        pub fv: [ScePspFVector3; 3usize],\n        pub iv: [ScePspIVector3; 3usize],\n        pub v: [ScePspVector3; 3usize],\n        pub f: [[f32; 3usize]; 3usize],\n        pub i: [[i32; 3usize]; 3usize],\n    }\n\n    #[allow(missing_debug_implementations)]\n    pub union ScePspVector2 {\n        pub fv: ScePspFVector2,\n        pub iv: ScePspIVector2,\n        pub f: [f32; 2usize],\n        pub i: [i32; 2usize],\n    }\n\n    #[allow(missing_debug_implementations)]\n    pub union ScePspMatrix4 {\n        pub fm: ScePspFMatrix4,\n        pub im: ScePspIMatrix4,\n        pub fv: [ScePspFVector4; 4usize],\n        pub iv: [ScePspIVector4; 4usize],\n        pub v: [ScePspVector4; 4usize],\n        pub f: [[f32; 4usize]; 4usize],\n        pub i: [[i32; 4usize]; 4usize],\n    }\n\n    #[allow(missing_debug_implementations)]\n    pub struct Key {\n        pub key_type: KeyType,\n        pub name: [u8; 256usize],\n        pub name_len: u32,\n        pub unk2: u32,\n        pub unk3: u32,\n    }\n\n    #[allow(missing_debug_implementations)]\n    pub struct UtilityMsgDialogParams {\n        pub base: UtilityDialogCommon,\n        pub unknown: i32,\n        pub mode: UtilityMsgDialogMode,\n        pub error_value: u32,\n        pub message: [u8; 512usize],\n        pub options: i32,\n        pub button_pressed: UtilityMsgDialogPressed,\n    }\n\n    #[allow(missing_debug_implementations)]\n    pub union UtilityNetData {\n        pub as_uint: u32,\n        pub as_string: [u8; 128usize],\n    }\n\n    #[allow(missing_debug_implementations)]\n    pub struct UtilitySavedataSFOParam {\n        pub title: [u8; 128usize],\n        pub savedata_title: [u8; 128usize],\n        pub detail: [u8; 1024usize],\n        pub parental_level: u8,\n        pub unknown: [u8; 3usize],\n    }\n\n    #[allow(missing_debug_implementations)]\n    pub struct SceUtilitySavedataParam {\n        pub base: UtilityDialogCommon,\n        pub mode: UtilitySavedataMode,\n        pub unknown1: i32,\n        pub overwrite: i32,\n        pub game_name: [u8; 13usize],\n        pub reserved: [u8; 3usize],\n        pub save_name: [u8; 20usize],\n        pub save_name_list: *mut [u8; 20usize],\n        pub file_name: [u8; 13usize],\n        pub reserved1: [u8; 3usize],\n        pub data_buf: *mut c_void,\n        pub data_buf_size: usize,\n        pub data_size: usize,\n        pub sfo_param: UtilitySavedataSFOParam,\n        pub icon0_file_data: UtilitySavedataFileData,\n        pub icon1_file_data: UtilitySavedataFileData,\n        pub pic1_file_data: UtilitySavedataFileData,\n        pub snd0_file_data: UtilitySavedataFileData,\n        pub new_data: *mut UtilitySavedataListSaveNewData,\n        pub focus: UtilitySavedataFocus,\n        pub unknown2: [i32; 4usize],\n        pub key: [u8; 16],\n        pub unknown3: [u8; 20],\n    }\n\n    #[allow(missing_debug_implementations)]\n    pub struct SceNetAdhocctlPeerInfo {\n        pub next: *mut SceNetAdhocctlPeerInfo,\n        pub nickname: [u8; 128usize],\n        pub mac: [u8; 6usize],\n        pub unknown: [u8; 6usize],\n        pub timestamp: u32,\n    }\n\n    #[allow(missing_debug_implementations)]\n    pub struct SceNetAdhocctlParams {\n        pub channel: i32,\n        pub name: [u8; 8usize],\n        pub bssid: [u8; 6usize],\n        pub nickname: [u8; 128usize],\n    }\n\n    #[cfg_attr(feature = \"extra_traits\", allow(missing_debug_implementations))]\n    pub union SceNetApctlInfo {\n        pub name: [u8; 64usize],\n        pub bssid: [u8; 6usize],\n        pub ssid: [u8; 32usize],\n        pub ssid_length: u32,\n        pub security_type: u32,\n        pub strength: u8,\n        pub channel: u8,\n        pub power_save: u8,\n        pub ip: [u8; 16usize],\n        pub sub_net_mask: [u8; 16usize],\n        pub gateway: [u8; 16usize],\n        pub primary_dns: [u8; 16usize],\n        pub secondary_dns: [u8; 16usize],\n        pub use_proxy: u32,\n        pub proxy_url: [u8; 128usize],\n        pub proxy_port: u16,\n        pub eap_type: u32,\n        pub start_browser: u32,\n        pub wifisp: u32,\n    }\n}\n\npub const INT_MIN: c_int = -2147483648;\npub const INT_MAX: c_int = 2147483647;\n\npub const AUDIO_VOLUME_MAX: u32 = 0x8000;\npub const AUDIO_CHANNEL_MAX: u32 = 8;\npub const AUDIO_NEXT_CHANNEL: i32 = -1;\npub const AUDIO_SAMPLE_MIN: u32 = 64;\npub const AUDIO_SAMPLE_MAX: u32 = 65472;\n\npub const PSP_CTRL_SELECT: i32 = 0x000001;\npub const PSP_CTRL_START: i32 = 0x000008;\npub const PSP_CTRL_UP: i32 = 0x000010;\npub const PSP_CTRL_RIGHT: i32 = 0x000020;\npub const PSP_CTRL_DOWN: i32 = 0x000040;\npub const PSP_CTRL_LEFT: i32 = 0x000080;\npub const PSP_CTRL_LTRIGGER: i32 = 0x000100;\npub const PSP_CTRL_RTRIGGER: i32 = 0x000200;\npub const PSP_CTRL_TRIANGLE: i32 = 0x001000;\npub const PSP_CTRL_CIRCLE: i32 = 0x002000;\npub const PSP_CTRL_CROSS: i32 = 0x004000;\npub const PSP_CTRL_SQUARE: i32 = 0x008000;\npub const PSP_CTRL_HOME: i32 = 0x010000;\npub const PSP_CTRL_HOLD: i32 = 0x020000;\npub const PSP_CTRL_NOTE: i32 = 0x800000;\npub const PSP_CTRL_SCREEN: i32 = 0x400000;\npub const PSP_CTRL_VOLUP: i32 = 0x100000;\npub const PSP_CTRL_VOLDOWN: i32 = 0x200000;\npub const PSP_CTRL_WLAN_UP: i32 = 0x040000;\npub const PSP_CTRL_REMOTE: i32 = 0x080000;\npub const PSP_CTRL_DISC: i32 = 0x1000000;\npub const PSP_CTRL_MS: i32 = 0x2000000;\n\npub const USB_CAM_PID: i32 = 0x282;\npub const USB_BUS_DRIVER_NAME: &str = \"USBBusDriver\";\npub const USB_CAM_DRIVER_NAME: &str = \"USBCamDriver\";\npub const USB_CAM_MIC_DRIVER_NAME: &str = \"USBCamMicDriver\";\npub const USB_STOR_DRIVER_NAME: &str = \"USBStor_Driver\";\n\npub const ACTIVATED: i32 = 0x200;\npub const CONNECTED: i32 = 0x020;\npub const ESTABLISHED: i32 = 0x002;\n\npub const USB_CAM_FLIP: i32 = 1;\npub const USB_CAM_MIRROR: i32 = 0x100;\n\npub const THREAD_ATTR_VFPU: i32 = 0x00004000;\npub const THREAD_ATTR_USER: i32 = 0x80000000;\npub const THREAD_ATTR_USBWLAN: i32 = 0xa0000000;\npub const THREAD_ATTR_VSH: i32 = 0xc0000000;\npub const THREAD_ATTR_SCRATCH_SRAM: i32 = 0x00008000;\npub const THREAD_ATTR_NO_FILLSTACK: i32 = 0x00100000;\npub const THREAD_ATTR_CLEAR_STACK: i32 = 0x00200000;\n\npub const EVENT_WAIT_MULTIPLE: i32 = 0x200;\n\npub const EVENT_WAIT_AND: i32 = 0;\npub const EVENT_WAIT_OR: i32 = 1;\npub const EVENT_WAIT_CLEAR: i32 = 0x20;\n\npub const POWER_INFO_POWER_SWITCH: i32 = 0x80000000;\npub const POWER_INFO_HOLD_SWITCH: i32 = 0x40000000;\npub const POWER_INFO_STANDBY: i32 = 0x00080000;\npub const POWER_INFO_RESUME_COMPLETE: i32 = 0x00040000;\npub const POWER_INFO_RESUMING: i32 = 0x00020000;\npub const POWER_INFO_SUSPENDING: i32 = 0x00010000;\npub const POWER_INFO_AC_POWER: i32 = 0x00001000;\npub const POWER_INFO_BATTERY_LOW: i32 = 0x00000100;\npub const POWER_INFO_BATTERY_EXIST: i32 = 0x00000080;\npub const POWER_INFO_BATTERY_POWER: i32 = 0x0000007;\n\npub const FIO_S_IFLNK: i32 = 0x4000;\npub const FIO_S_IFDIR: i32 = 0x1000;\npub const FIO_S_IFREG: i32 = 0x2000;\npub const FIO_S_ISUID: i32 = 0x0800;\npub const FIO_S_ISGID: i32 = 0x0400;\npub const FIO_S_ISVTX: i32 = 0x0200;\npub const FIO_S_IRUSR: i32 = 0x0100;\npub const FIO_S_IWUSR: i32 = 0x0080;\npub const FIO_S_IXUSR: i32 = 0x0040;\npub const FIO_S_IRGRP: i32 = 0x0020;\npub const FIO_S_IWGRP: i32 = 0x0010;\npub const FIO_S_IXGRP: i32 = 0x0008;\npub const FIO_S_IROTH: i32 = 0x0004;\npub const FIO_S_IWOTH: i32 = 0x0002;\npub const FIO_S_IXOTH: i32 = 0x0001;\n\npub const FIO_SO_IFLNK: i32 = 0x0008;\npub const FIO_SO_IFDIR: i32 = 0x0010;\npub const FIO_SO_IFREG: i32 = 0x0020;\npub const FIO_SO_IROTH: i32 = 0x0004;\npub const FIO_SO_IWOTH: i32 = 0x0002;\npub const FIO_SO_IXOTH: i32 = 0x0001;\n\npub const PSP_O_RD_ONLY: i32 = 0x0001;\npub const PSP_O_WR_ONLY: i32 = 0x0002;\npub const PSP_O_RD_WR: i32 = 0x0003;\npub const PSP_O_NBLOCK: i32 = 0x0004;\npub const PSP_O_DIR: i32 = 0x0008;\npub const PSP_O_APPEND: i32 = 0x0100;\npub const PSP_O_CREAT: i32 = 0x0200;\npub const PSP_O_TRUNC: i32 = 0x0400;\npub const PSP_O_EXCL: i32 = 0x0800;\npub const PSP_O_NO_WAIT: i32 = 0x8000;\n\npub const UMD_NOT_PRESENT: i32 = 0x01;\npub const UMD_PRESENT: i32 = 0x02;\npub const UMD_CHANGED: i32 = 0x04;\npub const UMD_INITING: i32 = 0x08;\npub const UMD_INITED: i32 = 0x10;\npub const UMD_READY: i32 = 0x20;\n\npub const PLAY_PAUSE: i32 = 0x1;\npub const FORWARD: i32 = 0x4;\npub const BACK: i32 = 0x8;\npub const VOL_UP: i32 = 0x10;\npub const VOL_DOWN: i32 = 0x20;\npub const HOLD: i32 = 0x80;\n\npub const GU_PI: f32 = 3.141593;\n\npub const GU_TEXTURE_8BIT: i32 = 1;\npub const GU_TEXTURE_16BIT: i32 = 2;\npub const GU_TEXTURE_32BITF: i32 = 3;\npub const GU_COLOR_5650: i32 = 4 << 2;\npub const GU_COLOR_5551: i32 = 5 << 2;\npub const GU_COLOR_4444: i32 = 6 << 2;\npub const GU_COLOR_8888: i32 = 7 << 2;\npub const GU_NORMAL_8BIT: i32 = 1 << 5;\npub const GU_NORMAL_16BIT: i32 = 2 << 5;\npub const GU_NORMAL_32BITF: i32 = 3 << 5;\npub const GU_VERTEX_8BIT: i32 = 1 << 7;\npub const GU_VERTEX_16BIT: i32 = 2 << 7;\npub const GU_VERTEX_32BITF: i32 = 3 << 7;\npub const GU_WEIGHT_8BIT: i32 = 1 << 9;\npub const GU_WEIGHT_16BIT: i32 = 2 << 9;\npub const GU_WEIGHT_32BITF: i32 = 3 << 9;\npub const GU_INDEX_8BIT: i32 = 1 << 11;\npub const GU_INDEX_16BIT: i32 = 2 << 11;\npub const GU_WEIGHTS1: i32 = (((1 - 1) & 7) << 14) as i32;\npub const GU_WEIGHTS2: i32 = (((2 - 1) & 7) << 14) as i32;\npub const GU_WEIGHTS3: i32 = (((3 - 1) & 7) << 14) as i32;\npub const GU_WEIGHTS4: i32 = (((4 - 1) & 7) << 14) as i32;\npub const GU_WEIGHTS5: i32 = (((5 - 1) & 7) << 14) as i32;\npub const GU_WEIGHTS6: i32 = (((6 - 1) & 7) << 14) as i32;\npub const GU_WEIGHTS7: i32 = (((7 - 1) & 7) << 14) as i32;\npub const GU_WEIGHTS8: i32 = (((8 - 1) & 7) << 14) as i32;\npub const GU_VERTICES1: i32 = (((1 - 1) & 7) << 18) as i32;\npub const GU_VERTICES2: i32 = (((2 - 1) & 7) << 18) as i32;\npub const GU_VERTICES3: i32 = (((3 - 1) & 7) << 18) as i32;\npub const GU_VERTICES4: i32 = (((4 - 1) & 7) << 18) as i32;\npub const GU_VERTICES5: i32 = (((5 - 1) & 7) << 18) as i32;\npub const GU_VERTICES6: i32 = (((6 - 1) & 7) << 18) as i32;\npub const GU_VERTICES7: i32 = (((7 - 1) & 7) << 18) as i32;\npub const GU_VERTICES8: i32 = (((8 - 1) & 7) << 18) as i32;\npub const GU_TRANSFORM_2D: i32 = 1 << 23;\npub const GU_TRANSFORM_3D: i32 = 0;\n\npub const GU_COLOR_BUFFER_BIT: i32 = 1;\npub const GU_STENCIL_BUFFER_BIT: i32 = 2;\npub const GU_DEPTH_BUFFER_BIT: i32 = 4;\npub const GU_FAST_CLEAR_BIT: i32 = 16;\n\npub const GU_AMBIENT: i32 = 1;\npub const GU_DIFFUSE: i32 = 2;\npub const GU_SPECULAR: i32 = 4;\npub const GU_UNKNOWN_LIGHT_COMPONENT: i32 = 8;\n\npub const SYSTEM_REGISTRY: [u8; 7] = *b\"/system\";\npub const REG_KEYNAME_SIZE: u32 = 27;\n\npub const UTILITY_MSGDIALOG_ERROR: i32 = 0;\npub const UTILITY_MSGDIALOG_TEXT: i32 = 1;\npub const UTILITY_MSGDIALOG_YES_NO_BUTTONS: i32 = 0x10;\npub const UTILITY_MSGDIALOG_DEFAULT_NO: i32 = 0x100;\n\npub const UTILITY_HTMLVIEWER_OPEN_SCE_START_PAGE: i32 = 0x000001;\npub const UTILITY_HTMLVIEWER_DISABLE_STARTUP_LIMITS: i32 = 0x000002;\npub const UTILITY_HTMLVIEWER_DISABLE_EXIT_DIALOG: i32 = 0x000004;\npub const UTILITY_HTMLVIEWER_DISABLE_CURSOR: i32 = 0x000008;\npub const UTILITY_HTMLVIEWER_DISABLE_DOWNLOAD_COMPLETE_DIALOG: i32 = 0x000010;\npub const UTILITY_HTMLVIEWER_DISABLE_DOWNLOAD_START_DIALOG: i32 = 0x000020;\npub const UTILITY_HTMLVIEWER_DISABLE_DOWNLOAD_DESTINATION_DIALOG: i32 = 0x000040;\npub const UTILITY_HTMLVIEWER_LOCK_DOWNLOAD_DESTINATION_DIALOG: i32 = 0x000080;\npub const UTILITY_HTMLVIEWER_DISABLE_TAB_DISPLAY: i32 = 0x000100;\npub const UTILITY_HTMLVIEWER_ENABLE_ANALOG_HOLD: i32 = 0x000200;\npub const UTILITY_HTMLVIEWER_ENABLE_FLASH: i32 = 0x000400;\npub const UTILITY_HTMLVIEWER_DISABLE_LRTRIGGER: i32 = 0x000800;\n\nextern \"C\" {\n    pub fn sceAudioChReserve(channel: i32, sample_count: i32, format: AudioFormat) -> i32;\n    pub fn sceAudioChRelease(channel: i32) -> i32;\n    pub fn sceAudioOutput(channel: i32, vol: i32, buf: *mut c_void) -> i32;\n    pub fn sceAudioOutputBlocking(channel: i32, vol: i32, buf: *mut c_void) -> i32;\n    pub fn sceAudioOutputPanned(\n        channel: i32,\n        left_vol: i32,\n        right_vol: i32,\n        buf: *mut c_void,\n    ) -> i32;\n    pub fn sceAudioOutputPannedBlocking(\n        channel: i32,\n        left_vol: i32,\n        right_vol: i32,\n        buf: *mut c_void,\n    ) -> i32;\n    pub fn sceAudioGetChannelRestLen(channel: i32) -> i32;\n    pub fn sceAudioGetChannelRestLength(channel: i32) -> i32;\n    pub fn sceAudioSetChannelDataLen(channel: i32, sample_count: i32) -> i32;\n    pub fn sceAudioChangeChannelConfig(channel: i32, format: AudioFormat) -> i32;\n    pub fn sceAudioChangeChannelVolume(channel: i32, left_vol: i32, right_vol: i32) -> i32;\n    pub fn sceAudioOutput2Reserve(sample_count: i32) -> i32;\n    pub fn sceAudioOutput2Release() -> i32;\n    pub fn sceAudioOutput2ChangeLength(sample_count: i32) -> i32;\n    pub fn sceAudioOutput2OutputBlocking(vol: i32, buf: *mut c_void) -> i32;\n    pub fn sceAudioOutput2GetRestSample() -> i32;\n    pub fn sceAudioSRCChReserve(\n        sample_count: i32,\n        freq: AudioOutputFrequency,\n        channels: i32,\n    ) -> i32;\n    pub fn sceAudioSRCChRelease() -> i32;\n    pub fn sceAudioSRCOutputBlocking(vol: i32, buf: *mut c_void) -> i32;\n    pub fn sceAudioInputInit(unknown1: i32, gain: i32, unknown2: i32) -> i32;\n    pub fn sceAudioInputInitEx(params: *mut AudioInputParams) -> i32;\n    pub fn sceAudioInputBlocking(sample_count: i32, freq: AudioInputFrequency, buf: *mut c_void);\n    pub fn sceAudioInput(sample_count: i32, freq: AudioInputFrequency, buf: *mut c_void);\n    pub fn sceAudioGetInputLength() -> i32;\n    pub fn sceAudioWaitInputEnd() -> i32;\n    pub fn sceAudioPollInputEnd() -> i32;\n\n    pub fn sceAtracGetAtracID(ui_codec_type: u32) -> i32;\n    pub fn sceAtracSetDataAndGetID(buf: *mut c_void, bufsize: usize) -> i32;\n    pub fn sceAtracDecodeData(\n        atrac_id: i32,\n        out_samples: *mut u16,\n        out_n: *mut i32,\n        out_end: *mut i32,\n        out_remain_frame: *mut i32,\n    ) -> i32;\n    pub fn sceAtracGetRemainFrame(atrac_id: i32, out_remain_frame: *mut i32) -> i32;\n    pub fn sceAtracGetStreamDataInfo(\n        atrac_id: i32,\n        write_pointer: *mut *mut u8,\n        available_bytes: *mut u32,\n        read_offset: *mut u32,\n    ) -> i32;\n    pub fn sceAtracAddStreamData(atrac_id: i32, bytes_to_add: u32) -> i32;\n    pub fn sceAtracGetBitrate(atrac_id: i32, out_bitrate: *mut i32) -> i32;\n    pub fn sceAtracSetLoopNum(atrac_id: i32, nloops: i32) -> i32;\n    pub fn sceAtracReleaseAtracID(atrac_id: i32) -> i32;\n    pub fn sceAtracGetNextSample(atrac_id: i32, out_n: *mut i32) -> i32;\n    pub fn sceAtracGetMaxSample(atrac_id: i32, out_max: *mut i32) -> i32;\n    pub fn sceAtracGetBufferInfoForReseting(\n        atrac_id: i32,\n        ui_sample: u32,\n        pbuffer_info: *mut Atrac3BufferInfo,\n    ) -> i32;\n    pub fn sceAtracGetChannel(atrac_id: i32, pui_channel: *mut u32) -> i32;\n    pub fn sceAtracGetInternalErrorInfo(atrac_id: i32, pi_result: *mut i32) -> i32;\n    pub fn sceAtracGetLoopStatus(\n        atrac_id: i32,\n        pi_loop_num: *mut i32,\n        pui_loop_status: *mut u32,\n    ) -> i32;\n    pub fn sceAtracGetNextDecodePosition(atrac_id: i32, pui_sample_position: *mut u32) -> i32;\n    pub fn sceAtracGetSecondBufferInfo(\n        atrac_id: i32,\n        pui_position: *mut u32,\n        pui_data_byte: *mut u32,\n    ) -> i32;\n    pub fn sceAtracGetSoundSample(\n        atrac_id: i32,\n        pi_end_sample: *mut i32,\n        pi_loop_start_sample: *mut i32,\n        pi_loop_end_sample: *mut i32,\n    ) -> i32;\n    pub fn sceAtracResetPlayPosition(\n        atrac_id: i32,\n        ui_sample: u32,\n        ui_write_byte_first_buf: u32,\n        ui_write_byte_second_buf: u32,\n    ) -> i32;\n    pub fn sceAtracSetData(atrac_id: i32, puc_buffer_addr: *mut u8, ui_buffer_byte: u32) -> i32;\n    pub fn sceAtracSetHalfwayBuffer(\n        atrac_id: i32,\n        puc_buffer_addr: *mut u8,\n        ui_read_byte: u32,\n        ui_buffer_byte: u32,\n    ) -> i32;\n    pub fn sceAtracSetHalfwayBufferAndGetID(\n        puc_buffer_addr: *mut u8,\n        ui_read_byte: u32,\n        ui_buffer_byte: u32,\n    ) -> i32;\n    pub fn sceAtracSetSecondBuffer(\n        atrac_id: i32,\n        puc_second_buffer_addr: *mut u8,\n        ui_second_buffer_byte: u32,\n    ) -> i32;\n\n    pub fn sceCtrlSetSamplingCycle(cycle: i32) -> i32;\n    pub fn sceCtrlGetSamplingCycle(pcycle: *mut i32) -> i32;\n    pub fn sceCtrlSetSamplingMode(mode: CtrlMode) -> i32;\n    pub fn sceCtrlGetSamplingMode(pmode: *mut i32) -> i32;\n    pub fn sceCtrlPeekBufferPositive(pad_data: *mut SceCtrlData, count: i32) -> i32;\n    pub fn sceCtrlPeekBufferNegative(pad_data: *mut SceCtrlData, count: i32) -> i32;\n    pub fn sceCtrlReadBufferPositive(pad_data: *mut SceCtrlData, count: i32) -> i32;\n    pub fn sceCtrlReadBufferNegative(pad_data: *mut SceCtrlData, count: i32) -> i32;\n    pub fn sceCtrlPeekLatch(latch_data: *mut SceCtrlLatch) -> i32;\n    pub fn sceCtrlReadLatch(latch_data: *mut SceCtrlLatch) -> i32;\n    pub fn sceCtrlSetIdleCancelThreshold(idlereset: i32, idleback: i32) -> i32;\n    pub fn sceCtrlGetIdleCancelThreshold(idlereset: *mut i32, idleback: *mut i32) -> i32;\n\n    pub fn sceDisplaySetMode(mode: DisplayMode, width: usize, height: usize) -> u32;\n    pub fn sceDisplayGetMode(pmode: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> i32;\n    pub fn sceDisplaySetFrameBuf(\n        top_addr: *const u8,\n        buffer_width: usize,\n        pixel_format: DisplayPixelFormat,\n        sync: DisplaySetBufSync,\n    ) -> u32;\n    pub fn sceDisplayGetFrameBuf(\n        top_addr: *mut *mut c_void,\n        buffer_width: *mut usize,\n        pixel_format: *mut DisplayPixelFormat,\n        sync: DisplaySetBufSync,\n    ) -> i32;\n    pub fn sceDisplayGetVcount() -> u32;\n    pub fn sceDisplayWaitVblank() -> i32;\n    pub fn sceDisplayWaitVblankCB() -> i32;\n    pub fn sceDisplayWaitVblankStart() -> i32;\n    pub fn sceDisplayWaitVblankStartCB() -> i32;\n    pub fn sceDisplayGetAccumulatedHcount() -> i32;\n    pub fn sceDisplayGetCurrentHcount() -> i32;\n    pub fn sceDisplayGetFramePerSec() -> f32;\n    pub fn sceDisplayIsForeground() -> i32;\n    pub fn sceDisplayIsVblank() -> i32;\n\n    pub fn sceGeEdramGetSize() -> u32;\n    pub fn sceGeEdramGetAddr() -> *mut u8;\n    pub fn sceGeEdramSetAddrTranslation(width: i32) -> i32;\n    pub fn sceGeGetCmd(cmd: i32) -> u32;\n    pub fn sceGeGetMtx(type_: GeMatrixType, matrix: *mut c_void) -> i32;\n    pub fn sceGeGetStack(stack_id: i32, stack: *mut GeStack) -> i32;\n    pub fn sceGeSaveContext(context: *mut GeContext) -> i32;\n    pub fn sceGeRestoreContext(context: *const GeContext) -> i32;\n    pub fn sceGeListEnQueue(\n        list: *const c_void,\n        stall: *mut c_void,\n        cbid: i32,\n        arg: *mut GeListArgs,\n    ) -> i32;\n    pub fn sceGeListEnQueueHead(\n        list: *const c_void,\n        stall: *mut c_void,\n        cbid: i32,\n        arg: *mut GeListArgs,\n    ) -> i32;\n    pub fn sceGeListDeQueue(qid: i32) -> i32;\n    pub fn sceGeListUpdateStallAddr(qid: i32, stall: *mut c_void) -> i32;\n    pub fn sceGeListSync(qid: i32, sync_type: i32) -> GeListState;\n    pub fn sceGeDrawSync(sync_type: i32) -> GeListState;\n    pub fn sceGeBreak(mode: i32, p_param: *mut GeBreakParam) -> i32;\n    pub fn sceGeContinue() -> i32;\n    pub fn sceGeSetCallback(cb: *mut GeCallbackData) -> i32;\n    pub fn sceGeUnsetCallback(cbid: i32) -> i32;\n\n    pub fn sceKernelExitGame();\n    pub fn sceKernelRegisterExitCallback(id: SceUid) -> i32;\n    pub fn sceKernelLoadExec(file: *const u8, param: *mut SceKernelLoadExecParam) -> i32;\n\n    pub fn sceKernelAllocPartitionMemory(\n        partition: SceSysMemPartitionId,\n        name: *const u8,\n        type_: SceSysMemBlockTypes,\n        size: u32,\n        addr: *mut c_void,\n    ) -> SceUid;\n    pub fn sceKernelGetBlockHeadAddr(blockid: SceUid) -> *mut c_void;\n    pub fn sceKernelFreePartitionMemory(blockid: SceUid) -> i32;\n    pub fn sceKernelTotalFreeMemSize() -> usize;\n    pub fn sceKernelMaxFreeMemSize() -> usize;\n    pub fn sceKernelDevkitVersion() -> u32;\n    pub fn sceKernelSetCompiledSdkVersion(version: u32) -> i32;\n    pub fn sceKernelGetCompiledSdkVersion() -> u32;\n\n    pub fn sceKernelLibcTime(t: *mut i32) -> i32;\n    pub fn sceKernelLibcClock() -> u32;\n    pub fn sceKernelLibcGettimeofday(tp: *mut timeval, tzp: *mut timezone) -> i32;\n    pub fn sceKernelDcacheWritebackAll();\n    pub fn sceKernelDcacheWritebackInvalidateAll();\n    pub fn sceKernelDcacheWritebackRange(p: *const c_void, size: u32);\n    pub fn sceKernelDcacheWritebackInvalidateRange(p: *const c_void, size: u32);\n    pub fn sceKernelDcacheInvalidateRange(p: *const c_void, size: u32);\n    pub fn sceKernelIcacheInvalidateAll();\n    pub fn sceKernelIcacheInvalidateRange(p: *const c_void, size: u32);\n    pub fn sceKernelUtilsMt19937Init(ctx: *mut SceKernelUtilsMt19937Context, seed: u32) -> i32;\n    pub fn sceKernelUtilsMt19937UInt(ctx: *mut SceKernelUtilsMt19937Context) -> u32;\n    pub fn sceKernelUtilsMd5Digest(data: *mut u8, size: u32, digest: *mut u8) -> i32;\n    pub fn sceKernelUtilsMd5BlockInit(ctx: *mut SceKernelUtilsMd5Context) -> i32;\n    pub fn sceKernelUtilsMd5BlockUpdate(\n        ctx: *mut SceKernelUtilsMd5Context,\n        data: *mut u8,\n        size: u32,\n    ) -> i32;\n    pub fn sceKernelUtilsMd5BlockResult(ctx: *mut SceKernelUtilsMd5Context, digest: *mut u8)\n        -> i32;\n    pub fn sceKernelUtilsSha1Digest(data: *mut u8, size: u32, digest: *mut u8) -> i32;\n    pub fn sceKernelUtilsSha1BlockInit(ctx: *mut SceKernelUtilsSha1Context) -> i32;\n    pub fn sceKernelUtilsSha1BlockUpdate(\n        ctx: *mut SceKernelUtilsSha1Context,\n        data: *mut u8,\n        size: u32,\n    ) -> i32;\n    pub fn sceKernelUtilsSha1BlockResult(\n        ctx: *mut SceKernelUtilsSha1Context,\n        digest: *mut u8,\n    ) -> i32;\n\n    pub fn sceKernelRegisterSubIntrHandler(\n        int_no: i32,\n        no: i32,\n        handler: *mut c_void,\n        arg: *mut c_void,\n    ) -> i32;\n    pub fn sceKernelReleaseSubIntrHandler(int_no: i32, no: i32) -> i32;\n    pub fn sceKernelEnableSubIntr(int_no: i32, no: i32) -> i32;\n    pub fn sceKernelDisableSubIntr(int_no: i32, no: i32) -> i32;\n    pub fn QueryIntrHandlerInfo(\n        intr_code: SceUid,\n        sub_intr_code: SceUid,\n        data: *mut IntrHandlerOptionParam,\n    ) -> i32;\n\n    pub fn sceKernelCpuSuspendIntr() -> u32;\n    pub fn sceKernelCpuResumeIntr(flags: u32);\n    pub fn sceKernelCpuResumeIntrWithSync(flags: u32);\n    pub fn sceKernelIsCpuIntrSuspended(flags: u32) -> i32;\n    pub fn sceKernelIsCpuIntrEnable() -> i32;\n\n    pub fn sceKernelLoadModule(\n        path: *const u8,\n        flags: i32,\n        option: *mut SceKernelLMOption,\n    ) -> SceUid;\n    pub fn sceKernelLoadModuleMs(\n        path: *const u8,\n        flags: i32,\n        option: *mut SceKernelLMOption,\n    ) -> SceUid;\n    pub fn sceKernelLoadModuleByID(\n        fid: SceUid,\n        flags: i32,\n        option: *mut SceKernelLMOption,\n    ) -> SceUid;\n    pub fn sceKernelLoadModuleBufferUsbWlan(\n        buf_size: usize,\n        buf: *mut c_void,\n        flags: i32,\n        option: *mut SceKernelLMOption,\n    ) -> SceUid;\n    pub fn sceKernelStartModule(\n        mod_id: SceUid,\n        arg_size: usize,\n        argp: *mut c_void,\n        status: *mut i32,\n        option: *mut SceKernelSMOption,\n    ) -> i32;\n    pub fn sceKernelStopModule(\n        mod_id: SceUid,\n        arg_size: usize,\n        argp: *mut c_void,\n        status: *mut i32,\n        option: *mut SceKernelSMOption,\n    ) -> i32;\n    pub fn sceKernelUnloadModule(mod_id: SceUid) -> i32;\n    pub fn sceKernelSelfStopUnloadModule(unknown: i32, arg_size: usize, argp: *mut c_void) -> i32;\n    pub fn sceKernelStopUnloadSelfModule(\n        arg_size: usize,\n        argp: *mut c_void,\n        status: *mut i32,\n        option: *mut SceKernelSMOption,\n    ) -> i32;\n    pub fn sceKernelQueryModuleInfo(mod_id: SceUid, info: *mut SceKernelModuleInfo) -> i32;\n    pub fn sceKernelGetModuleIdList(\n        read_buf: *mut SceUid,\n        read_buf_size: i32,\n        id_count: *mut i32,\n    ) -> i32;\n\n    pub fn sceKernelVolatileMemLock(unk: i32, ptr: *mut *mut c_void, size: *mut i32) -> i32;\n    pub fn sceKernelVolatileMemTryLock(unk: i32, ptr: *mut *mut c_void, size: *mut i32) -> i32;\n    pub fn sceKernelVolatileMemUnlock(unk: i32) -> i32;\n\n    pub fn sceKernelStdin() -> SceUid;\n    pub fn sceKernelStdout() -> SceUid;\n    pub fn sceKernelStderr() -> SceUid;\n\n    pub fn sceKernelGetThreadmanIdType(uid: SceUid) -> SceKernelIdListType;\n    pub fn sceKernelCreateThread(\n        name: *const u8,\n        entry: SceKernelThreadEntry,\n        init_priority: i32,\n        stack_size: i32,\n        attr: i32,\n        option: *mut SceKernelThreadOptParam,\n    ) -> SceUid;\n    pub fn sceKernelDeleteThread(thid: SceUid) -> i32;\n    pub fn sceKernelStartThread(id: SceUid, arg_len: usize, arg_p: *mut c_void) -> i32;\n    pub fn sceKernelExitThread(status: i32) -> i32;\n    pub fn sceKernelExitDeleteThread(status: i32) -> i32;\n    pub fn sceKernelTerminateThread(thid: SceUid) -> i32;\n    pub fn sceKernelTerminateDeleteThread(thid: SceUid) -> i32;\n    pub fn sceKernelSuspendDispatchThread() -> i32;\n    pub fn sceKernelResumeDispatchThread(state: i32) -> i32;\n    pub fn sceKernelSleepThread() -> i32;\n    pub fn sceKernelSleepThreadCB() -> i32;\n    pub fn sceKernelWakeupThread(thid: SceUid) -> i32;\n    pub fn sceKernelCancelWakeupThread(thid: SceUid) -> i32;\n    pub fn sceKernelSuspendThread(thid: SceUid) -> i32;\n    pub fn sceKernelResumeThread(thid: SceUid) -> i32;\n    pub fn sceKernelWaitThreadEnd(thid: SceUid, timeout: *mut u32) -> i32;\n    pub fn sceKernelWaitThreadEndCB(thid: SceUid, timeout: *mut u32) -> i32;\n    pub fn sceKernelDelayThread(delay: u32) -> i32;\n    pub fn sceKernelDelayThreadCB(delay: u32) -> i32;\n    pub fn sceKernelDelaySysClockThread(delay: *mut SceKernelSysClock) -> i32;\n    pub fn sceKernelDelaySysClockThreadCB(delay: *mut SceKernelSysClock) -> i32;\n    pub fn sceKernelChangeCurrentThreadAttr(unknown: i32, attr: i32) -> i32;\n    pub fn sceKernelChangeThreadPriority(thid: SceUid, priority: i32) -> i32;\n    pub fn sceKernelRotateThreadReadyQueue(priority: i32) -> i32;\n    pub fn sceKernelReleaseWaitThread(thid: SceUid) -> i32;\n    pub fn sceKernelGetThreadId() -> i32;\n    pub fn sceKernelGetThreadCurrentPriority() -> i32;\n    pub fn sceKernelGetThreadExitStatus(thid: SceUid) -> i32;\n    pub fn sceKernelCheckThreadStack() -> i32;\n    pub fn sceKernelGetThreadStackFreeSize(thid: SceUid) -> i32;\n    pub fn sceKernelReferThreadStatus(thid: SceUid, info: *mut SceKernelThreadInfo) -> i32;\n    pub fn sceKernelReferThreadRunStatus(\n        thid: SceUid,\n        status: *mut SceKernelThreadRunStatus,\n    ) -> i32;\n    pub fn sceKernelCreateSema(\n        name: *const u8,\n        attr: u32,\n        init_val: i32,\n        max_val: i32,\n        option: *mut SceKernelSemaOptParam,\n    ) -> SceUid;\n    pub fn sceKernelDeleteSema(sema_id: SceUid) -> i32;\n    pub fn sceKernelSignalSema(sema_id: SceUid, signal: i32) -> i32;\n    pub fn sceKernelWaitSema(sema_id: SceUid, signal: i32, timeout: *mut u32) -> i32;\n    pub fn sceKernelWaitSemaCB(sema_id: SceUid, signal: i32, timeout: *mut u32) -> i32;\n    pub fn sceKernelPollSema(sema_id: SceUid, signal: i32) -> i32;\n    pub fn sceKernelReferSemaStatus(sema_id: SceUid, info: *mut SceKernelSemaInfo) -> i32;\n    pub fn sceKernelCreateEventFlag(\n        name: *const u8,\n        attr: i32,\n        bits: i32,\n        opt: *mut SceKernelEventFlagOptParam,\n    ) -> SceUid;\n    pub fn sceKernelSetEventFlag(ev_id: SceUid, bits: u32) -> i32;\n    pub fn sceKernelClearEventFlag(ev_id: SceUid, bits: u32) -> i32;\n    pub fn sceKernelPollEventFlag(ev_id: SceUid, bits: u32, wait: i32, out_bits: *mut u32) -> i32;\n    pub fn sceKernelWaitEventFlag(\n        ev_id: SceUid,\n        bits: u32,\n        wait: i32,\n        out_bits: *mut u32,\n        timeout: *mut u32,\n    ) -> i32;\n    pub fn sceKernelWaitEventFlagCB(\n        ev_id: SceUid,\n        bits: u32,\n        wait: i32,\n        out_bits: *mut u32,\n        timeout: *mut u32,\n    ) -> i32;\n    pub fn sceKernelDeleteEventFlag(ev_id: SceUid) -> i32;\n    pub fn sceKernelReferEventFlagStatus(event: SceUid, status: *mut SceKernelEventFlagInfo)\n        -> i32;\n    pub fn sceKernelCreateMbx(\n        name: *const u8,\n        attr: u32,\n        option: *mut SceKernelMbxOptParam,\n    ) -> SceUid;\n    pub fn sceKernelDeleteMbx(mbx_id: SceUid) -> i32;\n    pub fn sceKernelSendMbx(mbx_id: SceUid, message: *mut c_void) -> i32;\n    pub fn sceKernelReceiveMbx(mbx_id: SceUid, message: *mut *mut c_void, timeout: *mut u32)\n        -> i32;\n    pub fn sceKernelReceiveMbxCB(\n        mbx_id: SceUid,\n        message: *mut *mut c_void,\n        timeout: *mut u32,\n    ) -> i32;\n    pub fn sceKernelPollMbx(mbx_id: SceUid, pmessage: *mut *mut c_void) -> i32;\n    pub fn sceKernelCancelReceiveMbx(mbx_id: SceUid, num: *mut i32) -> i32;\n    pub fn sceKernelReferMbxStatus(mbx_id: SceUid, info: *mut SceKernelMbxInfo) -> i32;\n    pub fn sceKernelSetAlarm(\n        clock: u32,\n        handler: SceKernelAlarmHandler,\n        common: *mut c_void,\n    ) -> SceUid;\n    pub fn sceKernelSetSysClockAlarm(\n        clock: *mut SceKernelSysClock,\n        handler: *mut SceKernelAlarmHandler,\n        common: *mut c_void,\n    ) -> SceUid;\n    pub fn sceKernelCancelAlarm(alarm_id: SceUid) -> i32;\n    pub fn sceKernelReferAlarmStatus(alarm_id: SceUid, info: *mut SceKernelAlarmInfo) -> i32;\n    pub fn sceKernelCreateCallback(\n        name: *const u8,\n        func: SceKernelCallbackFunction,\n        arg: *mut c_void,\n    ) -> SceUid;\n    pub fn sceKernelReferCallbackStatus(cb: SceUid, status: *mut SceKernelCallbackInfo) -> i32;\n    pub fn sceKernelDeleteCallback(cb: SceUid) -> i32;\n    pub fn sceKernelNotifyCallback(cb: SceUid, arg2: i32) -> i32;\n    pub fn sceKernelCancelCallback(cb: SceUid) -> i32;\n    pub fn sceKernelGetCallbackCount(cb: SceUid) -> i32;\n    pub fn sceKernelCheckCallback() -> i32;\n    pub fn sceKernelGetThreadmanIdList(\n        type_: SceKernelIdListType,\n        read_buf: *mut SceUid,\n        read_buf_size: i32,\n        id_count: *mut i32,\n    ) -> i32;\n    pub fn sceKernelReferSystemStatus(status: *mut SceKernelSystemStatus) -> i32;\n    pub fn sceKernelCreateMsgPipe(\n        name: *const u8,\n        part: i32,\n        attr: i32,\n        unk1: *mut c_void,\n        opt: *mut c_void,\n    ) -> SceUid;\n    pub fn sceKernelDeleteMsgPipe(uid: SceUid) -> i32;\n    pub fn sceKernelSendMsgPipe(\n        uid: SceUid,\n        message: *mut c_void,\n        size: u32,\n        unk1: i32,\n        unk2: *mut c_void,\n        timeout: *mut u32,\n    ) -> i32;\n    pub fn sceKernelSendMsgPipeCB(\n        uid: SceUid,\n        message: *mut c_void,\n        size: u32,\n        unk1: i32,\n        unk2: *mut c_void,\n        timeout: *mut u32,\n    ) -> i32;\n    pub fn sceKernelTrySendMsgPipe(\n        uid: SceUid,\n        message: *mut c_void,\n        size: u32,\n        unk1: i32,\n        unk2: *mut c_void,\n    ) -> i32;\n    pub fn sceKernelReceiveMsgPipe(\n        uid: SceUid,\n        message: *mut c_void,\n        size: u32,\n        unk1: i32,\n        unk2: *mut c_void,\n        timeout: *mut u32,\n    ) -> i32;\n    pub fn sceKernelReceiveMsgPipeCB(\n        uid: SceUid,\n        message: *mut c_void,\n        size: u32,\n        unk1: i32,\n        unk2: *mut c_void,\n        timeout: *mut u32,\n    ) -> i32;\n    pub fn sceKernelTryReceiveMsgPipe(\n        uid: SceUid,\n        message: *mut c_void,\n        size: u32,\n        unk1: i32,\n        unk2: *mut c_void,\n    ) -> i32;\n    pub fn sceKernelCancelMsgPipe(uid: SceUid, send: *mut i32, recv: *mut i32) -> i32;\n    pub fn sceKernelReferMsgPipeStatus(uid: SceUid, info: *mut SceKernelMppInfo) -> i32;\n    pub fn sceKernelCreateVpl(\n        name: *const u8,\n        part: i32,\n        attr: i32,\n        size: u32,\n        opt: *mut SceKernelVplOptParam,\n    ) -> SceUid;\n    pub fn sceKernelDeleteVpl(uid: SceUid) -> i32;\n    pub fn sceKernelAllocateVpl(\n        uid: SceUid,\n        size: u32,\n        data: *mut *mut c_void,\n        timeout: *mut u32,\n    ) -> i32;\n    pub fn sceKernelAllocateVplCB(\n        uid: SceUid,\n        size: u32,\n        data: *mut *mut c_void,\n        timeout: *mut u32,\n    ) -> i32;\n    pub fn sceKernelTryAllocateVpl(uid: SceUid, size: u32, data: *mut *mut c_void) -> i32;\n    pub fn sceKernelFreeVpl(uid: SceUid, data: *mut c_void) -> i32;\n    pub fn sceKernelCancelVpl(uid: SceUid, num: *mut i32) -> i32;\n    pub fn sceKernelReferVplStatus(uid: SceUid, info: *mut SceKernelVplInfo) -> i32;\n    pub fn sceKernelCreateFpl(\n        name: *const u8,\n        part: i32,\n        attr: i32,\n        size: u32,\n        blocks: u32,\n        opt: *mut SceKernelFplOptParam,\n    ) -> i32;\n    pub fn sceKernelDeleteFpl(uid: SceUid) -> i32;\n    pub fn sceKernelAllocateFpl(uid: SceUid, data: *mut *mut c_void, timeout: *mut u32) -> i32;\n    pub fn sceKernelAllocateFplCB(uid: SceUid, data: *mut *mut c_void, timeout: *mut u32) -> i32;\n    pub fn sceKernelTryAllocateFpl(uid: SceUid, data: *mut *mut c_void) -> i32;\n    pub fn sceKernelFreeFpl(uid: SceUid, data: *mut c_void) -> i32;\n    pub fn sceKernelCancelFpl(uid: SceUid, pnum: *mut i32) -> i32;\n    pub fn sceKernelReferFplStatus(uid: SceUid, info: *mut SceKernelFplInfo) -> i32;\n    pub fn sceKernelUSec2SysClock(usec: u32, clock: *mut SceKernelSysClock) -> i32;\n    pub fn sceKernelUSec2SysClockWide(usec: u32) -> i64;\n    pub fn sceKernelSysClock2USec(\n        clock: *mut SceKernelSysClock,\n        low: *mut u32,\n        high: *mut u32,\n    ) -> i32;\n    pub fn sceKernelSysClock2USecWide(clock: i64, low: *mut u32, high: *mut u32) -> i32;\n    pub fn sceKernelGetSystemTime(time: *mut SceKernelSysClock) -> i32;\n    pub fn sceKernelGetSystemTimeWide() -> i64;\n    pub fn sceKernelGetSystemTimeLow() -> u32;\n    pub fn sceKernelCreateVTimer(name: *const u8, opt: *mut SceKernelVTimerOptParam) -> SceUid;\n    pub fn sceKernelDeleteVTimer(uid: SceUid) -> i32;\n    pub fn sceKernelGetVTimerBase(uid: SceUid, base: *mut SceKernelSysClock) -> i32;\n    pub fn sceKernelGetVTimerBaseWide(uid: SceUid) -> i64;\n    pub fn sceKernelGetVTimerTime(uid: SceUid, time: *mut SceKernelSysClock) -> i32;\n    pub fn sceKernelGetVTimerTimeWide(uid: SceUid) -> i64;\n    pub fn sceKernelSetVTimerTime(uid: SceUid, time: *mut SceKernelSysClock) -> i32;\n    pub fn sceKernelSetVTimerTimeWide(uid: SceUid, time: i64) -> i64;\n    pub fn sceKernelStartVTimer(uid: SceUid) -> i32;\n    pub fn sceKernelStopVTimer(uid: SceUid) -> i32;\n    pub fn sceKernelSetVTimerHandler(\n        uid: SceUid,\n        time: *mut SceKernelSysClock,\n        handler: SceKernelVTimerHandler,\n        common: *mut c_void,\n    ) -> i32;\n    pub fn sceKernelSetVTimerHandlerWide(\n        uid: SceUid,\n        time: i64,\n        handler: SceKernelVTimerHandlerWide,\n        common: *mut c_void,\n    ) -> i32;\n    pub fn sceKernelCancelVTimerHandler(uid: SceUid) -> i32;\n    pub fn sceKernelReferVTimerStatus(uid: SceUid, info: *mut SceKernelVTimerInfo) -> i32;\n    pub fn sceKernelRegisterThreadEventHandler(\n        name: *const u8,\n        thread_id: SceUid,\n        mask: i32,\n        handler: SceKernelThreadEventHandler,\n        common: *mut c_void,\n    ) -> SceUid;\n    pub fn sceKernelReleaseThreadEventHandler(uid: SceUid) -> i32;\n    pub fn sceKernelReferThreadEventHandlerStatus(\n        uid: SceUid,\n        info: *mut SceKernelThreadEventHandlerInfo,\n    ) -> i32;\n    pub fn sceKernelReferThreadProfiler() -> *mut DebugProfilerRegs;\n    pub fn sceKernelReferGlobalProfiler() -> *mut DebugProfilerRegs;\n\n    pub fn sceUsbStart(driver_name: *const u8, size: i32, args: *mut c_void) -> i32;\n    pub fn sceUsbStop(driver_name: *const u8, size: i32, args: *mut c_void) -> i32;\n    pub fn sceUsbActivate(pid: u32) -> i32;\n    pub fn sceUsbDeactivate(pid: u32) -> i32;\n    pub fn sceUsbGetState() -> i32;\n    pub fn sceUsbGetDrvState(driver_name: *const u8) -> i32;\n}\n\nextern \"C\" {\n    pub fn sceUsbCamSetupStill(param: *mut UsbCamSetupStillParam) -> i32;\n    pub fn sceUsbCamSetupStillEx(param: *mut UsbCamSetupStillExParam) -> i32;\n    pub fn sceUsbCamStillInputBlocking(buf: *mut u8, size: usize) -> i32;\n    pub fn sceUsbCamStillInput(buf: *mut u8, size: usize) -> i32;\n    pub fn sceUsbCamStillWaitInputEnd() -> i32;\n    pub fn sceUsbCamStillPollInputEnd() -> i32;\n    pub fn sceUsbCamStillCancelInput() -> i32;\n    pub fn sceUsbCamStillGetInputLength() -> i32;\n    pub fn sceUsbCamSetupVideo(\n        param: *mut UsbCamSetupVideoParam,\n        work_area: *mut c_void,\n        work_area_size: i32,\n    ) -> i32;\n    pub fn sceUsbCamSetupVideoEx(\n        param: *mut UsbCamSetupVideoExParam,\n        work_area: *mut c_void,\n        work_area_size: i32,\n    ) -> i32;\n    pub fn sceUsbCamStartVideo() -> i32;\n    pub fn sceUsbCamStopVideo() -> i32;\n    pub fn sceUsbCamReadVideoFrameBlocking(buf: *mut u8, size: usize) -> i32;\n    pub fn sceUsbCamReadVideoFrame(buf: *mut u8, size: usize) -> i32;\n    pub fn sceUsbCamWaitReadVideoFrameEnd() -> i32;\n    pub fn sceUsbCamPollReadVideoFrameEnd() -> i32;\n    pub fn sceUsbCamGetReadVideoFrameSize() -> i32;\n    pub fn sceUsbCamSetSaturation(saturation: i32) -> i32;\n    pub fn sceUsbCamSetBrightness(brightness: i32) -> i32;\n    pub fn sceUsbCamSetContrast(contrast: i32) -> i32;\n    pub fn sceUsbCamSetSharpness(sharpness: i32) -> i32;\n    pub fn sceUsbCamSetImageEffectMode(effect_mode: UsbCamEffectMode) -> i32;\n    pub fn sceUsbCamSetEvLevel(exposure_level: UsbCamEvLevel) -> i32;\n    pub fn sceUsbCamSetReverseMode(reverse_flags: i32) -> i32;\n    pub fn sceUsbCamSetZoom(zoom: i32) -> i32;\n    pub fn sceUsbCamGetSaturation(saturation: *mut i32) -> i32;\n    pub fn sceUsbCamGetBrightness(brightness: *mut i32) -> i32;\n    pub fn sceUsbCamGetContrast(contrast: *mut i32) -> i32;\n    pub fn sceUsbCamGetSharpness(sharpness: *mut i32) -> i32;\n    pub fn sceUsbCamGetImageEffectMode(effect_mode: *mut UsbCamEffectMode) -> i32;\n    pub fn sceUsbCamGetEvLevel(exposure_level: *mut UsbCamEvLevel) -> i32;\n    pub fn sceUsbCamGetReverseMode(reverse_flags: *mut i32) -> i32;\n    pub fn sceUsbCamGetZoom(zoom: *mut i32) -> i32;\n    pub fn sceUsbCamAutoImageReverseSW(on: i32) -> i32;\n    pub fn sceUsbCamGetAutoImageReverseState() -> i32;\n    pub fn sceUsbCamGetLensDirection() -> i32;\n\n    pub fn sceUsbstorBootRegisterNotify(event_flag: SceUid) -> i32;\n    pub fn sceUsbstorBootUnregisterNotify(event_flag: u32) -> i32;\n    pub fn sceUsbstorBootSetCapacity(size: u32) -> i32;\n\n    pub fn scePowerRegisterCallback(slot: i32, cbid: SceUid) -> i32;\n    pub fn scePowerUnregisterCallback(slot: i32) -> i32;\n    pub fn scePowerIsPowerOnline() -> i32;\n    pub fn scePowerIsBatteryExist() -> i32;\n    pub fn scePowerIsBatteryCharging() -> i32;\n    pub fn scePowerGetBatteryChargingStatus() -> i32;\n    pub fn scePowerIsLowBattery() -> i32;\n    pub fn scePowerGetBatteryLifePercent() -> i32;\n    pub fn scePowerGetBatteryLifeTime() -> i32;\n    pub fn scePowerGetBatteryTemp() -> i32;\n    pub fn scePowerGetBatteryElec() -> i32;\n    pub fn scePowerGetBatteryVolt() -> i32;\n    pub fn scePowerSetCpuClockFrequency(cpufreq: i32) -> i32;\n    pub fn scePowerSetBusClockFrequency(busfreq: i32) -> i32;\n    pub fn scePowerGetCpuClockFrequency() -> i32;\n    pub fn scePowerGetCpuClockFrequencyInt() -> i32;\n    pub fn scePowerGetCpuClockFrequencyFloat() -> f32;\n    pub fn scePowerGetBusClockFrequency() -> i32;\n    pub fn scePowerGetBusClockFrequencyInt() -> i32;\n    pub fn scePowerGetBusClockFrequencyFloat() -> f32;\n    pub fn scePowerSetClockFrequency(pllfreq: i32, cpufreq: i32, busfreq: i32) -> i32;\n    pub fn scePowerLock(unknown: i32) -> i32;\n    pub fn scePowerUnlock(unknown: i32) -> i32;\n    pub fn scePowerTick(t: PowerTick) -> i32;\n    pub fn scePowerGetIdleTimer() -> i32;\n    pub fn scePowerIdleTimerEnable(unknown: i32) -> i32;\n    pub fn scePowerIdleTimerDisable(unknown: i32) -> i32;\n    pub fn scePowerRequestStandby() -> i32;\n    pub fn scePowerRequestSuspend() -> i32;\n\n    pub fn sceWlanDevIsPowerOn() -> i32;\n    pub fn sceWlanGetSwitchState() -> i32;\n    pub fn sceWlanGetEtherAddr(ether_addr: *mut u8) -> i32;\n\n    pub fn sceWlanDevAttach() -> i32;\n    pub fn sceWlanDevDetach() -> i32;\n\n    pub fn sceRtcGetTickResolution() -> u32;\n    pub fn sceRtcGetCurrentTick(tick: *mut u64) -> i32;\n    pub fn sceRtcGetCurrentClock(tm: *mut ScePspDateTime, tz: i32) -> i32;\n    pub fn sceRtcGetCurrentClockLocalTime(tm: *mut ScePspDateTime) -> i32;\n    pub fn sceRtcConvertUtcToLocalTime(tick_utc: *const u64, tick_local: *mut u64) -> i32;\n    pub fn sceRtcConvertLocalTimeToUTC(tick_local: *const u64, tick_utc: *mut u64) -> i32;\n    pub fn sceRtcIsLeapYear(year: i32) -> i32;\n    pub fn sceRtcGetDaysInMonth(year: i32, month: i32) -> i32;\n    pub fn sceRtcGetDayOfWeek(year: i32, month: i32, day: i32) -> i32;\n    pub fn sceRtcCheckValid(date: *const ScePspDateTime) -> i32;\n    pub fn sceRtcSetTick(date: *mut ScePspDateTime, tick: *const u64) -> i32;\n    pub fn sceRtcGetTick(date: *const ScePspDateTime, tick: *mut u64) -> i32;\n    pub fn sceRtcCompareTick(tick1: *const u64, tick2: *const u64) -> i32;\n    pub fn sceRtcTickAddTicks(dest_tick: *mut u64, src_tick: *const u64, num_ticks: u64) -> i32;\n    pub fn sceRtcTickAddMicroseconds(dest_tick: *mut u64, src_tick: *const u64, num_ms: u64)\n        -> i32;\n    pub fn sceRtcTickAddSeconds(dest_tick: *mut u64, src_tick: *const u64, num_seconds: u64)\n        -> i32;\n    pub fn sceRtcTickAddMinutes(dest_tick: *mut u64, src_tick: *const u64, num_minutes: u64)\n        -> i32;\n    pub fn sceRtcTickAddHours(dest_tick: *mut u64, src_tick: *const u64, num_hours: u64) -> i32;\n    pub fn sceRtcTickAddDays(dest_tick: *mut u64, src_tick: *const u64, num_days: u64) -> i32;\n    pub fn sceRtcTickAddWeeks(dest_tick: *mut u64, src_tick: *const u64, num_weeks: u64) -> i32;\n    pub fn sceRtcTickAddMonths(dest_tick: *mut u64, src_tick: *const u64, num_months: u64) -> i32;\n    pub fn sceRtcTickAddYears(dest_tick: *mut u64, src_tick: *const u64, num_years: u64) -> i32;\n    pub fn sceRtcSetTime_t(date: *mut ScePspDateTime, time: u32) -> i32;\n    pub fn sceRtcGetTime_t(date: *const ScePspDateTime, time: *mut u32) -> i32;\n    pub fn sceRtcSetTime64_t(date: *mut ScePspDateTime, time: u64) -> i32;\n    pub fn sceRtcGetTime64_t(date: *const ScePspDateTime, time: *mut u64) -> i32;\n    pub fn sceRtcSetDosTime(date: *mut ScePspDateTime, dos_time: u32) -> i32;\n    pub fn sceRtcGetDosTime(date: *mut ScePspDateTime, dos_time: u32) -> i32;\n    pub fn sceRtcSetWin32FileTime(date: *mut ScePspDateTime, time: *mut u64) -> i32;\n    pub fn sceRtcGetWin32FileTime(date: *mut ScePspDateTime, time: *mut u64) -> i32;\n    pub fn sceRtcParseDateTime(dest_tick: *mut u64, date_string: *const u8) -> i32;\n    pub fn sceRtcFormatRFC3339(\n        psz_date_time: *mut char,\n        p_utc: *const u64,\n        time_zone_minutes: i32,\n    ) -> i32;\n    pub fn sceRtcFormatRFC3339LocalTime(psz_date_time: *mut char, p_utc: *const u64) -> i32;\n    pub fn sceRtcParseRFC3339(p_utc: *mut u64, psz_date_time: *const u8) -> i32;\n    pub fn sceRtcFormatRFC2822(\n        psz_date_time: *mut char,\n        p_utc: *const u64,\n        time_zone_minutes: i32,\n    ) -> i32;\n    pub fn sceRtcFormatRFC2822LocalTime(psz_date_time: *mut char, p_utc: *const u64) -> i32;\n\n    pub fn sceIoOpen(file: *const u8, flags: i32, permissions: IoPermissions) -> SceUid;\n    pub fn sceIoOpenAsync(file: *const u8, flags: i32, permissions: IoPermissions) -> SceUid;\n    pub fn sceIoClose(fd: SceUid) -> i32;\n    pub fn sceIoCloseAsync(fd: SceUid) -> i32;\n    pub fn sceIoRead(fd: SceUid, data: *mut c_void, size: u32) -> i32;\n    pub fn sceIoReadAsync(fd: SceUid, data: *mut c_void, size: u32) -> i32;\n    pub fn sceIoWrite(fd: SceUid, data: *const c_void, size: usize) -> i32;\n    pub fn sceIoWriteAsync(fd: SceUid, data: *const c_void, size: u32) -> i32;\n    pub fn sceIoLseek(fd: SceUid, offset: i64, whence: IoWhence) -> i64;\n    pub fn sceIoLseekAsync(fd: SceUid, offset: i64, whence: IoWhence) -> i32;\n    pub fn sceIoLseek32(fd: SceUid, offset: i32, whence: IoWhence) -> i32;\n    pub fn sceIoLseek32Async(fd: SceUid, offset: i32, whence: IoWhence) -> i32;\n    pub fn sceIoRemove(file: *const u8) -> i32;\n    pub fn sceIoMkdir(dir: *const u8, mode: IoPermissions) -> i32;\n    pub fn sceIoRmdir(path: *const u8) -> i32;\n    pub fn sceIoChdir(path: *const u8) -> i32;\n    pub fn sceIoRename(oldname: *const u8, newname: *const u8) -> i32;\n    pub fn sceIoDopen(dirname: *const u8) -> SceUid;\n    pub fn sceIoDread(fd: SceUid, dir: *mut SceIoDirent) -> i32;\n    pub fn sceIoDclose(fd: SceUid) -> i32;\n    pub fn sceIoDevctl(\n        dev: *const u8,\n        cmd: u32,\n        indata: *mut c_void,\n        inlen: i32,\n        outdata: *mut c_void,\n        outlen: i32,\n    ) -> i32;\n    pub fn sceIoAssign(\n        dev1: *const u8,\n        dev2: *const u8,\n        dev3: *const u8,\n        mode: IoAssignPerms,\n        unk1: *mut c_void,\n        unk2: i32,\n    ) -> i32;\n    pub fn sceIoUnassign(dev: *const u8) -> i32;\n    pub fn sceIoGetstat(file: *const u8, stat: *mut SceIoStat) -> i32;\n    pub fn sceIoChstat(file: *const u8, stat: *mut SceIoStat, bits: i32) -> i32;\n    pub fn sceIoIoctl(\n        fd: SceUid,\n        cmd: u32,\n        indata: *mut c_void,\n        inlen: i32,\n        outdata: *mut c_void,\n        outlen: i32,\n    ) -> i32;\n    pub fn sceIoIoctlAsync(\n        fd: SceUid,\n        cmd: u32,\n        indata: *mut c_void,\n        inlen: i32,\n        outdata: *mut c_void,\n        outlen: i32,\n    ) -> i32;\n    pub fn sceIoSync(device: *const u8, unk: u32) -> i32;\n    pub fn sceIoWaitAsync(fd: SceUid, res: *mut i64) -> i32;\n    pub fn sceIoWaitAsyncCB(fd: SceUid, res: *mut i64) -> i32;\n    pub fn sceIoPollAsync(fd: SceUid, res: *mut i64) -> i32;\n    pub fn sceIoGetAsyncStat(fd: SceUid, poll: i32, res: *mut i64) -> i32;\n    pub fn sceIoCancel(fd: SceUid) -> i32;\n    pub fn sceIoGetDevType(fd: SceUid) -> i32;\n    pub fn sceIoChangeAsyncPriority(fd: SceUid, pri: i32) -> i32;\n    pub fn sceIoSetAsyncCallback(fd: SceUid, cb: SceUid, argp: *mut c_void) -> i32;\n\n    pub fn sceJpegInitMJpeg() -> i32;\n    pub fn sceJpegFinishMJpeg() -> i32;\n    pub fn sceJpegCreateMJpeg(width: i32, height: i32) -> i32;\n    pub fn sceJpegDeleteMJpeg() -> i32;\n    pub fn sceJpegDecodeMJpeg(jpeg_buf: *mut u8, size: usize, rgba: *mut c_void, unk: u32) -> i32;\n\n    pub fn sceUmdCheckMedium() -> i32;\n    pub fn sceUmdGetDiscInfo(info: *mut UmdInfo) -> i32;\n    pub fn sceUmdActivate(unit: i32, drive: *const u8) -> i32;\n    pub fn sceUmdDeactivate(unit: i32, drive: *const u8) -> i32;\n    pub fn sceUmdWaitDriveStat(state: i32) -> i32;\n    pub fn sceUmdWaitDriveStatWithTimer(state: i32, timeout: u32) -> i32;\n    pub fn sceUmdWaitDriveStatCB(state: i32, timeout: u32) -> i32;\n    pub fn sceUmdCancelWaitDriveStat() -> i32;\n    pub fn sceUmdGetDriveStat() -> i32;\n    pub fn sceUmdGetErrorStat() -> i32;\n    pub fn sceUmdRegisterUMDCallBack(cbid: i32) -> i32;\n    pub fn sceUmdUnRegisterUMDCallBack(cbid: i32) -> i32;\n    pub fn sceUmdReplacePermit() -> i32;\n    pub fn sceUmdReplaceProhibit() -> i32;\n\n    pub fn sceMpegInit() -> i32;\n    pub fn sceMpegFinish();\n    pub fn sceMpegRingbufferQueryMemSize(packets: i32) -> i32;\n    pub fn sceMpegRingbufferConstruct(\n        ringbuffer: *mut SceMpegRingbuffer,\n        packets: i32,\n        data: *mut c_void,\n        size: i32,\n        callback: SceMpegRingbufferCb,\n        cb_param: *mut c_void,\n    ) -> i32;\n    pub fn sceMpegRingbufferDestruct(ringbuffer: *mut SceMpegRingbuffer);\n    pub fn sceMpegRingbufferAvailableSize(ringbuffer: *mut SceMpegRingbuffer) -> i32;\n    pub fn sceMpegRingbufferPut(\n        ringbuffer: *mut SceMpegRingbuffer,\n        num_packets: i32,\n        available: i32,\n    ) -> i32;\n    pub fn sceMpegQueryMemSize(unk: i32) -> i32;\n    pub fn sceMpegCreate(\n        handle: SceMpeg,\n        data: *mut c_void,\n        size: i32,\n        ringbuffer: *mut SceMpegRingbuffer,\n        frame_width: i32,\n        unk1: i32,\n        unk2: i32,\n    ) -> i32;\n    pub fn sceMpegDelete(handle: SceMpeg);\n    pub fn sceMpegQueryStreamOffset(handle: SceMpeg, buffer: *mut c_void, offset: *mut i32) -> i32;\n    pub fn sceMpegQueryStreamSize(buffer: *mut c_void, size: *mut i32) -> i32;\n    pub fn sceMpegRegistStream(handle: SceMpeg, stream_id: i32, unk: i32) -> SceMpegStream;\n    pub fn sceMpegUnRegistStream(handle: SceMpeg, stream: SceMpegStream);\n    pub fn sceMpegFlushAllStream(handle: SceMpeg) -> i32;\n    pub fn sceMpegMallocAvcEsBuf(handle: SceMpeg) -> *mut c_void;\n    pub fn sceMpegFreeAvcEsBuf(handle: SceMpeg, buf: *mut c_void);\n    pub fn sceMpegQueryAtracEsSize(handle: SceMpeg, es_size: *mut i32, out_size: *mut i32) -> i32;\n    pub fn sceMpegInitAu(handle: SceMpeg, es_buffer: *mut c_void, au: *mut SceMpegAu) -> i32;\n    pub fn sceMpegGetAvcAu(\n        handle: SceMpeg,\n        stream: SceMpegStream,\n        au: *mut SceMpegAu,\n        unk: *mut i32,\n    ) -> i32;\n    pub fn sceMpegAvcDecodeMode(handle: SceMpeg, mode: *mut SceMpegAvcMode) -> i32;\n    pub fn sceMpegAvcDecode(\n        handle: SceMpeg,\n        au: *mut SceMpegAu,\n        iframe_width: i32,\n        buffer: *mut c_void,\n        init: *mut i32,\n    ) -> i32;\n    pub fn sceMpegAvcDecodeStop(\n        handle: SceMpeg,\n        frame_width: i32,\n        buffer: *mut c_void,\n        status: *mut i32,\n    ) -> i32;\n    pub fn sceMpegGetAtracAu(\n        handle: SceMpeg,\n        stream: SceMpegStream,\n        au: *mut SceMpegAu,\n        unk: *mut c_void,\n    ) -> i32;\n    pub fn sceMpegAtracDecode(\n        handle: SceMpeg,\n        au: *mut SceMpegAu,\n        buffer: *mut c_void,\n        init: i32,\n    ) -> i32;\n\n    pub fn sceMpegBaseYCrCbCopyVme(yuv_buffer: *mut c_void, buffer: *mut i32, type_: i32) -> i32;\n    pub fn sceMpegBaseCscInit(width: i32) -> i32;\n    pub fn sceMpegBaseCscVme(\n        rgb_buffer: *mut c_void,\n        rgb_buffer2: *mut c_void,\n        width: i32,\n        y_cr_cb_buffer: *mut SceMpegYCrCbBuffer,\n    ) -> i32;\n    pub fn sceMpegbase_BEA18F91(lli: *mut SceMpegLLI) -> i32;\n\n    pub fn sceHprmPeekCurrentKey(key: *mut i32) -> i32;\n    pub fn sceHprmPeekLatch(latch: *mut [u32; 4]) -> i32;\n    pub fn sceHprmReadLatch(latch: *mut [u32; 4]) -> i32;\n    pub fn sceHprmIsHeadphoneExist() -> i32;\n    pub fn sceHprmIsRemoteExist() -> i32;\n    pub fn sceHprmIsMicrophoneExist() -> i32;\n\n    pub fn sceGuDepthBuffer(zbp: *mut c_void, zbw: i32);\n    pub fn sceGuDispBuffer(width: i32, height: i32, dispbp: *mut c_void, dispbw: i32);\n    pub fn sceGuDrawBuffer(psm: DisplayPixelFormat, fbp: *mut c_void, fbw: i32);\n    pub fn sceGuDrawBufferList(psm: DisplayPixelFormat, fbp: *mut c_void, fbw: i32);\n    pub fn sceGuDisplay(state: bool) -> bool;\n    pub fn sceGuDepthFunc(function: DepthFunc);\n    pub fn sceGuDepthMask(mask: i32);\n    pub fn sceGuDepthOffset(offset: i32);\n    pub fn sceGuDepthRange(near: i32, far: i32);\n    pub fn sceGuFog(near: f32, far: f32, color: u32);\n    pub fn sceGuInit();\n    pub fn sceGuTerm();\n    pub fn sceGuBreak(mode: i32);\n    pub fn sceGuContinue();\n    pub fn sceGuSetCallback(signal: GuCallbackId, callback: GuCallback) -> GuCallback;\n    pub fn sceGuSignal(behavior: SignalBehavior, signal: i32);\n    pub fn sceGuSendCommandf(cmd: GeCommand, argument: f32);\n    pub fn sceGuSendCommandi(cmd: GeCommand, argument: i32);\n    pub fn sceGuGetMemory(size: i32) -> *mut c_void;\n    pub fn sceGuStart(context_type: GuContextType, list: *mut c_void);\n    pub fn sceGuFinish() -> i32;\n    pub fn sceGuFinishId(id: u32) -> i32;\n    pub fn sceGuCallList(list: *const c_void);\n    pub fn sceGuCallMode(mode: i32);\n    pub fn sceGuCheckList() -> i32;\n    pub fn sceGuSendList(mode: GuQueueMode, list: *const c_void, context: *mut GeContext);\n    pub fn sceGuSwapBuffers() -> *mut c_void;\n    pub fn sceGuSync(mode: GuSyncMode, behavior: GuSyncBehavior) -> GeListState;\n    pub fn sceGuDrawArray(\n        prim: GuPrimitive,\n        vtype: i32,\n        count: i32,\n        indices: *const c_void,\n        vertices: *const c_void,\n    );\n    pub fn sceGuBeginObject(\n        vtype: i32,\n        count: i32,\n        indices: *const c_void,\n        vertices: *const c_void,\n    );\n    pub fn sceGuEndObject();\n    pub fn sceGuSetStatus(state: GuState, status: i32);\n    pub fn sceGuGetStatus(state: GuState) -> bool;\n    pub fn sceGuSetAllStatus(status: i32);\n    pub fn sceGuGetAllStatus() -> i32;\n    pub fn sceGuEnable(state: GuState);\n    pub fn sceGuDisable(state: GuState);\n    pub fn sceGuLight(light: i32, type_: LightType, components: i32, position: &ScePspFVector3);\n    pub fn sceGuLightAtt(light: i32, atten0: f32, atten1: f32, atten2: f32);\n    pub fn sceGuLightColor(light: i32, component: i32, color: u32);\n    pub fn sceGuLightMode(mode: LightMode);\n    pub fn sceGuLightSpot(light: i32, direction: &ScePspFVector3, exponent: f32, cutoff: f32);\n    pub fn sceGuClear(flags: i32);\n    pub fn sceGuClearColor(color: u32);\n    pub fn sceGuClearDepth(depth: u32);\n    pub fn sceGuClearStencil(stencil: u32);\n    pub fn sceGuPixelMask(mask: u32);\n    pub fn sceGuColor(color: u32);\n    pub fn sceGuColorFunc(func: ColorFunc, color: u32, mask: u32);\n    pub fn sceGuColorMaterial(components: i32);\n    pub fn sceGuAlphaFunc(func: AlphaFunc, value: i32, mask: i32);\n    pub fn sceGuAmbient(color: u32);\n    pub fn sceGuAmbientColor(color: u32);\n    pub fn sceGuBlendFunc(op: BlendOp, src: BlendSrc, dest: BlendDst, src_fix: u32, dest_fix: u32);\n    pub fn sceGuMaterial(components: i32, color: u32);\n    pub fn sceGuModelColor(emissive: u32, ambient: u32, diffuse: u32, specular: u32);\n    pub fn sceGuStencilFunc(func: StencilFunc, ref_: i32, mask: i32);\n    pub fn sceGuStencilOp(fail: StencilOperation, zfail: StencilOperation, zpass: StencilOperation);\n    pub fn sceGuSpecular(power: f32);\n    pub fn sceGuFrontFace(order: FrontFaceDirection);\n    pub fn sceGuLogicalOp(op: LogicalOperation);\n    pub fn sceGuSetDither(matrix: &ScePspIMatrix4);\n    pub fn sceGuShadeModel(mode: ShadingModel);\n    pub fn sceGuCopyImage(\n        psm: DisplayPixelFormat,\n        sx: i32,\n        sy: i32,\n        width: i32,\n        height: i32,\n        srcw: i32,\n        src: *mut c_void,\n        dx: i32,\n        dy: i32,\n        destw: i32,\n        dest: *mut c_void,\n    );\n    pub fn sceGuTexEnvColor(color: u32);\n    pub fn sceGuTexFilter(min: TextureFilter, mag: TextureFilter);\n    pub fn sceGuTexFlush();\n    pub fn sceGuTexFunc(tfx: TextureEffect, tcc: TextureColorComponent);\n    pub fn sceGuTexImage(\n        mipmap: MipmapLevel,\n        width: i32,\n        height: i32,\n        tbw: i32,\n        tbp: *const c_void,\n    );\n    pub fn sceGuTexLevelMode(mode: TextureLevelMode, bias: f32);\n    pub fn sceGuTexMapMode(mode: TextureMapMode, a1: u32, a2: u32);\n    pub fn sceGuTexMode(tpsm: TexturePixelFormat, maxmips: i32, a2: i32, swizzle: i32);\n    pub fn sceGuTexOffset(u: f32, v: f32);\n    pub fn sceGuTexProjMapMode(mode: TextureProjectionMapMode);\n    pub fn sceGuTexScale(u: f32, v: f32);\n    pub fn sceGuTexSlope(slope: f32);\n    pub fn sceGuTexSync();\n    pub fn sceGuTexWrap(u: GuTexWrapMode, v: GuTexWrapMode);\n    pub fn sceGuClutLoad(num_blocks: i32, cbp: *const c_void);\n    pub fn sceGuClutMode(cpsm: ClutPixelFormat, shift: u32, mask: u32, a3: u32);\n    pub fn sceGuOffset(x: u32, y: u32);\n    pub fn sceGuScissor(x: i32, y: i32, w: i32, h: i32);\n    pub fn sceGuViewport(cx: i32, cy: i32, width: i32, height: i32);\n    pub fn sceGuDrawBezier(\n        v_type: i32,\n        u_count: i32,\n        v_count: i32,\n        indices: *const c_void,\n        vertices: *const c_void,\n    );\n    pub fn sceGuPatchDivide(ulevel: u32, vlevel: u32);\n    pub fn sceGuPatchFrontFace(a0: u32);\n    pub fn sceGuPatchPrim(prim: PatchPrimitive);\n    pub fn sceGuDrawSpline(\n        v_type: i32,\n        u_count: i32,\n        v_count: i32,\n        u_edge: i32,\n        v_edge: i32,\n        indices: *const c_void,\n        vertices: *const c_void,\n    );\n    pub fn sceGuSetMatrix(type_: MatrixMode, matrix: &ScePspFMatrix4);\n    pub fn sceGuBoneMatrix(index: u32, matrix: &ScePspFMatrix4);\n    pub fn sceGuMorphWeight(index: i32, weight: f32);\n    pub fn sceGuDrawArrayN(\n        primitive_type: GuPrimitive,\n        v_type: i32,\n        count: i32,\n        a3: i32,\n        indices: *const c_void,\n        vertices: *const c_void,\n    );\n\n    pub fn sceGumDrawArray(\n        prim: GuPrimitive,\n        v_type: i32,\n        count: i32,\n        indices: *const c_void,\n        vertices: *const c_void,\n    );\n    pub fn sceGumDrawArrayN(\n        prim: GuPrimitive,\n        v_type: i32,\n        count: i32,\n        a3: i32,\n        indices: *const c_void,\n        vertices: *const c_void,\n    );\n    pub fn sceGumDrawBezier(\n        v_type: i32,\n        u_count: i32,\n        v_count: i32,\n        indices: *const c_void,\n        vertices: *const c_void,\n    );\n    pub fn sceGumDrawSpline(\n        v_type: i32,\n        u_count: i32,\n        v_count: i32,\n        u_edge: i32,\n        v_edge: i32,\n        indices: *const c_void,\n        vertices: *const c_void,\n    );\n    pub fn sceGumFastInverse();\n    pub fn sceGumFullInverse();\n    pub fn sceGumLoadIdentity();\n    pub fn sceGumLoadMatrix(m: &ScePspFMatrix4);\n    pub fn sceGumLookAt(eye: &ScePspFVector3, center: &ScePspFVector3, up: &ScePspFVector3);\n    pub fn sceGumMatrixMode(mode: MatrixMode);\n    pub fn sceGumMultMatrix(m: &ScePspFMatrix4);\n    pub fn sceGumOrtho(left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32);\n    pub fn sceGumPerspective(fovy: f32, aspect: f32, near: f32, far: f32);\n    pub fn sceGumPopMatrix();\n    pub fn sceGumPushMatrix();\n    pub fn sceGumRotateX(angle: f32);\n    pub fn sceGumRotateY(angle: f32);\n    pub fn sceGumRotateZ(angle: f32);\n    pub fn sceGumRotateXYZ(v: &ScePspFVector3);\n    pub fn sceGumRotateZYX(v: &ScePspFVector3);\n    pub fn sceGumScale(v: &ScePspFVector3);\n    pub fn sceGumStoreMatrix(m: &mut ScePspFMatrix4);\n    pub fn sceGumTranslate(v: &ScePspFVector3);\n    pub fn sceGumUpdateMatrix();\n\n    pub fn sceMp3ReserveMp3Handle(args: *mut SceMp3InitArg) -> i32;\n    pub fn sceMp3ReleaseMp3Handle(handle: Mp3Handle) -> i32;\n    pub fn sceMp3InitResource() -> i32;\n    pub fn sceMp3TermResource() -> i32;\n    pub fn sceMp3Init(handle: Mp3Handle) -> i32;\n    pub fn sceMp3Decode(handle: Mp3Handle, dst: *mut *mut i16) -> i32;\n    pub fn sceMp3GetInfoToAddStreamData(\n        handle: Mp3Handle,\n        dst: *mut *mut u8,\n        to_write: *mut i32,\n        src_pos: *mut i32,\n    ) -> i32;\n    pub fn sceMp3NotifyAddStreamData(handle: Mp3Handle, size: i32) -> i32;\n    pub fn sceMp3CheckStreamDataNeeded(handle: Mp3Handle) -> i32;\n    pub fn sceMp3SetLoopNum(handle: Mp3Handle, loop_: i32) -> i32;\n    pub fn sceMp3GetLoopNum(handle: Mp3Handle) -> i32;\n    pub fn sceMp3GetSumDecodedSample(handle: Mp3Handle) -> i32;\n    pub fn sceMp3GetMaxOutputSample(handle: Mp3Handle) -> i32;\n    pub fn sceMp3GetSamplingRate(handle: Mp3Handle) -> i32;\n    pub fn sceMp3GetBitRate(handle: Mp3Handle) -> i32;\n    pub fn sceMp3GetMp3ChannelNum(handle: Mp3Handle) -> i32;\n    pub fn sceMp3ResetPlayPosition(handle: Mp3Handle) -> i32;\n\n    pub fn sceRegOpenRegistry(reg: *mut Key, mode: i32, handle: *mut RegHandle) -> i32;\n    pub fn sceRegFlushRegistry(handle: RegHandle) -> i32;\n    pub fn sceRegCloseRegistry(handle: RegHandle) -> i32;\n    pub fn sceRegOpenCategory(\n        handle: RegHandle,\n        name: *const u8,\n        mode: i32,\n        dir_handle: *mut RegHandle,\n    ) -> i32;\n    pub fn sceRegRemoveCategory(handle: RegHandle, name: *const u8) -> i32;\n    pub fn sceRegCloseCategory(dir_handle: RegHandle) -> i32;\n    pub fn sceRegFlushCategory(dir_handle: RegHandle) -> i32;\n    pub fn sceRegGetKeyInfo(\n        dir_handle: RegHandle,\n        name: *const u8,\n        key_handle: *mut RegHandle,\n        type_: *mut KeyType,\n        size: *mut usize,\n    ) -> i32;\n    pub fn sceRegGetKeyInfoByName(\n        dir_handle: RegHandle,\n        name: *const u8,\n        type_: *mut KeyType,\n        size: *mut usize,\n    ) -> i32;\n    pub fn sceRegGetKeyValue(\n        dir_handle: RegHandle,\n        key_handle: RegHandle,\n        buf: *mut c_void,\n        size: usize,\n    ) -> i32;\n    pub fn sceRegGetKeyValueByName(\n        dir_handle: RegHandle,\n        name: *const u8,\n        buf: *mut c_void,\n        size: usize,\n    ) -> i32;\n    pub fn sceRegSetKeyValue(\n        dir_handle: RegHandle,\n        name: *const u8,\n        buf: *const c_void,\n        size: usize,\n    ) -> i32;\n    pub fn sceRegGetKeysNum(dir_handle: RegHandle, num: *mut i32) -> i32;\n    pub fn sceRegGetKeys(dir_handle: RegHandle, buf: *mut u8, num: i32) -> i32;\n    pub fn sceRegCreateKey(dir_handle: RegHandle, name: *const u8, type_: i32, size: usize) -> i32;\n    pub fn sceRegRemoveRegistry(key: *mut Key) -> i32;\n\n    pub fn sceOpenPSIDGetOpenPSID(openpsid: *mut OpenPSID) -> i32;\n\n    pub fn sceUtilityMsgDialogInitStart(params: *mut UtilityMsgDialogParams) -> i32;\n    pub fn sceUtilityMsgDialogShutdownStart();\n    pub fn sceUtilityMsgDialogGetStatus() -> i32;\n    pub fn sceUtilityMsgDialogUpdate(n: i32);\n    pub fn sceUtilityMsgDialogAbort() -> i32;\n    pub fn sceUtilityNetconfInitStart(data: *mut UtilityNetconfData) -> i32;\n    pub fn sceUtilityNetconfShutdownStart() -> i32;\n    pub fn sceUtilityNetconfUpdate(unknown: i32) -> i32;\n    pub fn sceUtilityNetconfGetStatus() -> i32;\n    pub fn sceUtilityCheckNetParam(id: i32) -> i32;\n    pub fn sceUtilityGetNetParam(conf: i32, param: NetParam, data: *mut UtilityNetData) -> i32;\n    pub fn sceUtilitySavedataInitStart(params: *mut SceUtilitySavedataParam) -> i32;\n    pub fn sceUtilitySavedataGetStatus() -> i32;\n    pub fn sceUtilitySavedataShutdownStart() -> i32;\n    pub fn sceUtilitySavedataUpdate(unknown: i32);\n    pub fn sceUtilityGameSharingInitStart(params: *mut UtilityGameSharingParams) -> i32;\n    pub fn sceUtilityGameSharingShutdownStart();\n    pub fn sceUtilityGameSharingGetStatus() -> i32;\n    pub fn sceUtilityGameSharingUpdate(n: i32);\n    pub fn sceUtilityHtmlViewerInitStart(params: *mut UtilityHtmlViewerParam) -> i32;\n    pub fn sceUtilityHtmlViewerShutdownStart() -> i32;\n    pub fn sceUtilityHtmlViewerUpdate(n: i32) -> i32;\n    pub fn sceUtilityHtmlViewerGetStatus() -> i32;\n    pub fn sceUtilitySetSystemParamInt(id: SystemParamId, value: i32) -> i32;\n    pub fn sceUtilitySetSystemParamString(id: SystemParamId, str: *const u8) -> i32;\n    pub fn sceUtilityGetSystemParamInt(id: SystemParamId, value: *mut i32) -> i32;\n    pub fn sceUtilityGetSystemParamString(id: SystemParamId, str: *mut u8, len: i32) -> i32;\n    pub fn sceUtilityOskInitStart(params: *mut SceUtilityOskParams) -> i32;\n    pub fn sceUtilityOskShutdownStart() -> i32;\n    pub fn sceUtilityOskUpdate(n: i32) -> i32;\n    pub fn sceUtilityOskGetStatus() -> i32;\n    pub fn sceUtilityLoadNetModule(module: NetModule) -> i32;\n    pub fn sceUtilityUnloadNetModule(module: NetModule) -> i32;\n    pub fn sceUtilityLoadAvModule(module: AvModule) -> i32;\n    pub fn sceUtilityUnloadAvModule(module: AvModule) -> i32;\n    pub fn sceUtilityLoadUsbModule(module: UsbModule) -> i32;\n    pub fn sceUtilityUnloadUsbModule(module: UsbModule) -> i32;\n    pub fn sceUtilityLoadModule(module: Module) -> i32;\n    pub fn sceUtilityUnloadModule(module: Module) -> i32;\n    pub fn sceUtilityCreateNetParam(conf: i32) -> i32;\n    pub fn sceUtilitySetNetParam(param: NetParam, val: *const c_void) -> i32;\n    pub fn sceUtilityCopyNetParam(src: i32, dest: i32) -> i32;\n    pub fn sceUtilityDeleteNetParam(conf: i32) -> i32;\n\n    pub fn sceNetInit(\n        poolsize: i32,\n        calloutprio: i32,\n        calloutstack: i32,\n        netintrprio: i32,\n        netintrstack: i32,\n    ) -> i32;\n    pub fn sceNetTerm() -> i32;\n    pub fn sceNetFreeThreadinfo(thid: i32) -> i32;\n    pub fn sceNetThreadAbort(thid: i32) -> i32;\n    pub fn sceNetEtherStrton(name: *mut u8, mac: *mut u8);\n    pub fn sceNetEtherNtostr(mac: *mut u8, name: *mut u8);\n    pub fn sceNetGetLocalEtherAddr(mac: *mut u8) -> i32;\n    pub fn sceNetGetMallocStat(stat: *mut SceNetMallocStat) -> i32;\n\n    pub fn sceNetAdhocctlInit(\n        stacksize: i32,\n        priority: i32,\n        adhoc_id: *mut SceNetAdhocctlAdhocId,\n    ) -> i32;\n    pub fn sceNetAdhocctlTerm() -> i32;\n    pub fn sceNetAdhocctlConnect(name: *const u8) -> i32;\n    pub fn sceNetAdhocctlDisconnect() -> i32;\n    pub fn sceNetAdhocctlGetState(event: *mut i32) -> i32;\n    pub fn sceNetAdhocctlCreate(name: *const u8) -> i32;\n    pub fn sceNetAdhocctlJoin(scaninfo: *mut SceNetAdhocctlScanInfo) -> i32;\n    pub fn sceNetAdhocctlGetAdhocId(id: *mut SceNetAdhocctlAdhocId) -> i32;\n    pub fn sceNetAdhocctlCreateEnterGameMode(\n        name: *const u8,\n        unknown: i32,\n        num: i32,\n        macs: *mut u8,\n        timeout: u32,\n        unknown2: i32,\n    ) -> i32;\n    pub fn sceNetAdhocctlJoinEnterGameMode(\n        name: *const u8,\n        hostmac: *mut u8,\n        timeout: u32,\n        unknown: i32,\n    ) -> i32;\n    pub fn sceNetAdhocctlGetGameModeInfo(gamemodeinfo: *mut SceNetAdhocctlGameModeInfo) -> i32;\n    pub fn sceNetAdhocctlExitGameMode() -> i32;\n    pub fn sceNetAdhocctlGetPeerList(length: *mut i32, buf: *mut c_void) -> i32;\n    pub fn sceNetAdhocctlGetPeerInfo(\n        mac: *mut u8,\n        size: i32,\n        peerinfo: *mut SceNetAdhocctlPeerInfo,\n    ) -> i32;\n    pub fn sceNetAdhocctlScan() -> i32;\n    pub fn sceNetAdhocctlGetScanInfo(length: *mut i32, buf: *mut c_void) -> i32;\n    pub fn sceNetAdhocctlAddHandler(handler: SceNetAdhocctlHandler, unknown: *mut c_void) -> i32;\n    pub fn sceNetAdhocctlDelHandler(id: i32) -> i32;\n    pub fn sceNetAdhocctlGetNameByAddr(mac: *mut u8, nickname: *mut u8) -> i32;\n    pub fn sceNetAdhocctlGetAddrByName(\n        nickname: *mut u8,\n        length: *mut i32,\n        buf: *mut c_void,\n    ) -> i32;\n    pub fn sceNetAdhocctlGetParameter(params: *mut SceNetAdhocctlParams) -> i32;\n\n    pub fn sceNetAdhocInit() -> i32;\n    pub fn sceNetAdhocTerm() -> i32;\n    pub fn sceNetAdhocPdpCreate(mac: *mut u8, port: u16, buf_size: u32, unk1: i32) -> i32;\n    pub fn sceNetAdhocPdpDelete(id: i32, unk1: i32) -> i32;\n    pub fn sceNetAdhocPdpSend(\n        id: i32,\n        dest_mac_addr: *mut u8,\n        port: u16,\n        data: *mut c_void,\n        len: u32,\n        timeout: u32,\n        nonblock: i32,\n    ) -> i32;\n    pub fn sceNetAdhocPdpRecv(\n        id: i32,\n        src_mac_addr: *mut u8,\n        port: *mut u16,\n        data: *mut c_void,\n        data_length: *mut c_void,\n        timeout: u32,\n        nonblock: i32,\n    ) -> i32;\n    pub fn sceNetAdhocGetPdpStat(size: *mut i32, stat: *mut SceNetAdhocPdpStat) -> i32;\n    pub fn sceNetAdhocGameModeCreateMaster(data: *mut c_void, size: i32) -> i32;\n    pub fn sceNetAdhocGameModeCreateReplica(mac: *mut u8, data: *mut c_void, size: i32) -> i32;\n    pub fn sceNetAdhocGameModeUpdateMaster() -> i32;\n    pub fn sceNetAdhocGameModeUpdateReplica(id: i32, unk1: i32) -> i32;\n    pub fn sceNetAdhocGameModeDeleteMaster() -> i32;\n    pub fn sceNetAdhocGameModeDeleteReplica(id: i32) -> i32;\n    pub fn sceNetAdhocPtpOpen(\n        srcmac: *mut u8,\n        srcport: u16,\n        destmac: *mut u8,\n        destport: u16,\n        buf_size: u32,\n        delay: u32,\n        count: i32,\n        unk1: i32,\n    ) -> i32;\n    pub fn sceNetAdhocPtpConnect(id: i32, timeout: u32, nonblock: i32) -> i32;\n    pub fn sceNetAdhocPtpListen(\n        srcmac: *mut u8,\n        srcport: u16,\n        buf_size: u32,\n        delay: u32,\n        count: i32,\n        queue: i32,\n        unk1: i32,\n    ) -> i32;\n    pub fn sceNetAdhocPtpAccept(\n        id: i32,\n        mac: *mut u8,\n        port: *mut u16,\n        timeout: u32,\n        nonblock: i32,\n    ) -> i32;\n    pub fn sceNetAdhocPtpSend(\n        id: i32,\n        data: *mut c_void,\n        data_size: *mut i32,\n        timeout: u32,\n        nonblock: i32,\n    ) -> i32;\n    pub fn sceNetAdhocPtpRecv(\n        id: i32,\n        data: *mut c_void,\n        data_size: *mut i32,\n        timeout: u32,\n        nonblock: i32,\n    ) -> i32;\n    pub fn sceNetAdhocPtpFlush(id: i32, timeout: u32, nonblock: i32) -> i32;\n    pub fn sceNetAdhocPtpClose(id: i32, unk1: i32) -> i32;\n    pub fn sceNetAdhocGetPtpStat(size: *mut i32, stat: *mut SceNetAdhocPtpStat) -> i32;\n}\n\nextern \"C\" {\n    pub fn sceNetAdhocMatchingInit(memsize: i32) -> i32;\n    pub fn sceNetAdhocMatchingTerm() -> i32;\n    pub fn sceNetAdhocMatchingCreate(\n        mode: AdhocMatchingMode,\n        max_peers: i32,\n        port: u16,\n        buf_size: i32,\n        hello_delay: u32,\n        ping_delay: u32,\n        init_count: i32,\n        msg_delay: u32,\n        callback: AdhocMatchingCallback,\n    ) -> i32;\n    pub fn sceNetAdhocMatchingDelete(matching_id: i32) -> i32;\n    pub fn sceNetAdhocMatchingStart(\n        matching_id: i32,\n        evth_pri: i32,\n        evth_stack: i32,\n        inth_pri: i32,\n        inth_stack: i32,\n        opt_len: i32,\n        opt_data: *mut c_void,\n    ) -> i32;\n    pub fn sceNetAdhocMatchingStop(matching_id: i32) -> i32;\n    pub fn sceNetAdhocMatchingSelectTarget(\n        matching_id: i32,\n        mac: *mut u8,\n        opt_len: i32,\n        opt_data: *mut c_void,\n    ) -> i32;\n    pub fn sceNetAdhocMatchingCancelTarget(matching_id: i32, mac: *mut u8) -> i32;\n    pub fn sceNetAdhocMatchingCancelTargetWithOpt(\n        matching_id: i32,\n        mac: *mut u8,\n        opt_len: i32,\n        opt_data: *mut c_void,\n    ) -> i32;\n    pub fn sceNetAdhocMatchingSendData(\n        matching_id: i32,\n        mac: *mut u8,\n        data_len: i32,\n        data: *mut c_void,\n    ) -> i32;\n    pub fn sceNetAdhocMatchingAbortSendData(matching_id: i32, mac: *mut u8) -> i32;\n    pub fn sceNetAdhocMatchingSetHelloOpt(\n        matching_id: i32,\n        opt_len: i32,\n        opt_data: *mut c_void,\n    ) -> i32;\n    pub fn sceNetAdhocMatchingGetHelloOpt(\n        matching_id: i32,\n        opt_len: *mut i32,\n        opt_data: *mut c_void,\n    ) -> i32;\n    pub fn sceNetAdhocMatchingGetMembers(\n        matching_id: i32,\n        length: *mut i32,\n        buf: *mut c_void,\n    ) -> i32;\n    pub fn sceNetAdhocMatchingGetPoolMaxAlloc() -> i32;\n    pub fn sceNetAdhocMatchingGetPoolStat(poolstat: *mut AdhocPoolStat) -> i32;\n}\n\nextern \"C\" {\n    pub fn sceNetApctlInit(stack_size: i32, init_priority: i32) -> i32;\n    pub fn sceNetApctlTerm() -> i32;\n    pub fn sceNetApctlGetInfo(code: ApctlInfo, pinfo: *mut SceNetApctlInfo) -> i32;\n    pub fn sceNetApctlAddHandler(handler: SceNetApctlHandler, parg: *mut c_void) -> i32;\n    pub fn sceNetApctlDelHandler(handler_id: i32) -> i32;\n    pub fn sceNetApctlConnect(conn_index: i32) -> i32;\n    pub fn sceNetApctlDisconnect() -> i32;\n    pub fn sceNetApctlGetState(pstate: *mut ApctlState) -> i32;\n\n    pub fn sceNetInetInit() -> i32;\n    pub fn sceNetInetTerm() -> i32;\n    pub fn sceNetInetAccept(s: i32, addr: *mut sockaddr, addr_len: *mut socklen_t) -> i32;\n    pub fn sceNetInetBind(s: i32, my_addr: *const sockaddr, addr_len: socklen_t) -> i32;\n    pub fn sceNetInetConnect(s: i32, serv_addr: *const sockaddr, addr_len: socklen_t) -> i32;\n    pub fn sceNetInetGetsockopt(\n        s: i32,\n        level: i32,\n        opt_name: i32,\n        opt_val: *mut c_void,\n        optl_en: *mut socklen_t,\n    ) -> i32;\n    pub fn sceNetInetListen(s: i32, backlog: i32) -> i32;\n    pub fn sceNetInetRecv(s: i32, buf: *mut c_void, len: usize, flags: i32) -> usize;\n    pub fn sceNetInetRecvfrom(\n        s: i32,\n        buf: *mut c_void,\n        flags: usize,\n        arg1: i32,\n        from: *mut sockaddr,\n        from_len: *mut socklen_t,\n    ) -> usize;\n    pub fn sceNetInetSend(s: i32, buf: *const c_void, len: usize, flags: i32) -> usize;\n    pub fn sceNetInetSendto(\n        s: i32,\n        buf: *const c_void,\n        len: usize,\n        flags: i32,\n        to: *const sockaddr,\n        to_len: socklen_t,\n    ) -> usize;\n    pub fn sceNetInetSetsockopt(\n        s: i32,\n        level: i32,\n        opt_name: i32,\n        opt_val: *const c_void,\n        opt_len: socklen_t,\n    ) -> i32;\n    pub fn sceNetInetShutdown(s: i32, how: i32) -> i32;\n    pub fn sceNetInetSocket(domain: i32, type_: i32, protocol: i32) -> i32;\n    pub fn sceNetInetClose(s: i32) -> i32;\n    pub fn sceNetInetGetErrno() -> i32;\n\n    pub fn sceSslInit(unknown1: i32) -> i32;\n    pub fn sceSslEnd() -> i32;\n    pub fn sceSslGetUsedMemoryMax(memory: *mut u32) -> i32;\n    pub fn sceSslGetUsedMemoryCurrent(memory: *mut u32) -> i32;\n\n    pub fn sceHttpInit(unknown1: u32) -> i32;\n    pub fn sceHttpEnd() -> i32;\n    pub fn sceHttpCreateTemplate(agent: *mut u8, unknown1: i32, unknown2: i32) -> i32;\n    pub fn sceHttpDeleteTemplate(templateid: i32) -> i32;\n    pub fn sceHttpCreateConnection(\n        templateid: i32,\n        host: *mut u8,\n        unknown1: *mut u8,\n        port: u16,\n        unknown2: i32,\n    ) -> i32;\n    pub fn sceHttpCreateConnectionWithURL(templateid: i32, url: *const u8, unknown1: i32) -> i32;\n    pub fn sceHttpDeleteConnection(connection_id: i32) -> i32;\n    pub fn sceHttpCreateRequest(\n        connection_id: i32,\n        method: HttpMethod,\n        path: *mut u8,\n        content_length: u64,\n    ) -> i32;\n    pub fn sceHttpCreateRequestWithURL(\n        connection_id: i32,\n        method: HttpMethod,\n        url: *mut u8,\n        content_length: u64,\n    ) -> i32;\n    pub fn sceHttpDeleteRequest(request_id: i32) -> i32;\n    pub fn sceHttpSendRequest(request_id: i32, data: *mut c_void, data_size: u32) -> i32;\n    pub fn sceHttpAbortRequest(request_id: i32) -> i32;\n    pub fn sceHttpReadData(request_id: i32, data: *mut c_void, data_size: u32) -> i32;\n    pub fn sceHttpGetContentLength(request_id: i32, content_length: *mut u64) -> i32;\n    pub fn sceHttpGetStatusCode(request_id: i32, status_code: *mut i32) -> i32;\n    pub fn sceHttpSetResolveTimeOut(id: i32, timeout: u32) -> i32;\n    pub fn sceHttpSetResolveRetry(id: i32, count: i32) -> i32;\n    pub fn sceHttpSetConnectTimeOut(id: i32, timeout: u32) -> i32;\n    pub fn sceHttpSetSendTimeOut(id: i32, timeout: u32) -> i32;\n    pub fn sceHttpSetRecvTimeOut(id: i32, timeout: u32) -> i32;\n    pub fn sceHttpEnableKeepAlive(id: i32) -> i32;\n    pub fn sceHttpDisableKeepAlive(id: i32) -> i32;\n    pub fn sceHttpEnableRedirect(id: i32) -> i32;\n    pub fn sceHttpDisableRedirect(id: i32) -> i32;\n    pub fn sceHttpEnableCookie(id: i32) -> i32;\n    pub fn sceHttpDisableCookie(id: i32) -> i32;\n    pub fn sceHttpSaveSystemCookie() -> i32;\n    pub fn sceHttpLoadSystemCookie() -> i32;\n    pub fn sceHttpAddExtraHeader(id: i32, name: *mut u8, value: *mut u8, unknown1: i32) -> i32;\n    pub fn sceHttpDeleteHeader(id: i32, name: *const u8) -> i32;\n    pub fn sceHttpsInit(unknown1: i32, unknown2: i32, unknown3: i32, unknown4: i32) -> i32;\n    pub fn sceHttpsEnd() -> i32;\n    pub fn sceHttpsLoadDefaultCert(unknown1: i32, unknown2: i32) -> i32;\n    pub fn sceHttpDisableAuth(id: i32) -> i32;\n    pub fn sceHttpDisableCache(id: i32) -> i32;\n    pub fn sceHttpEnableAuth(id: i32) -> i32;\n    pub fn sceHttpEnableCache(id: i32) -> i32;\n    pub fn sceHttpEndCache() -> i32;\n    pub fn sceHttpGetAllHeader(request: i32, header: *mut *mut u8, header_size: *mut u32) -> i32;\n    pub fn sceHttpGetNetworkErrno(request: i32, err_num: *mut i32) -> i32;\n    pub fn sceHttpGetProxy(\n        id: i32,\n        activate_flag: *mut i32,\n        mode: *mut i32,\n        proxy_host: *mut u8,\n        len: usize,\n        proxy_port: *mut u16,\n    ) -> i32;\n    pub fn sceHttpInitCache(max_size: usize) -> i32;\n    pub fn sceHttpSetAuthInfoCB(id: i32, cbfunc: HttpPasswordCB) -> i32;\n    pub fn sceHttpSetProxy(\n        id: i32,\n        activate_flag: i32,\n        mode: i32,\n        new_proxy_host: *const u8,\n        new_proxy_port: u16,\n    ) -> i32;\n    pub fn sceHttpSetResHeaderMaxSize(id: i32, header_size: u32) -> i32;\n    pub fn sceHttpSetMallocFunction(\n        malloc_func: HttpMallocFunction,\n        free_func: HttpFreeFunction,\n        realloc_func: HttpReallocFunction,\n    ) -> i32;\n\n    pub fn sceNetResolverInit() -> i32;\n    pub fn sceNetResolverCreate(rid: *mut i32, buf: *mut c_void, buf_length: u32) -> i32;\n    pub fn sceNetResolverDelete(rid: i32) -> i32;\n    pub fn sceNetResolverStartNtoA(\n        rid: i32,\n        hostname: *const u8,\n        addr: *mut in_addr,\n        timeout: u32,\n        retry: i32,\n    ) -> i32;\n    pub fn sceNetResolverStartAtoN(\n        rid: i32,\n        addr: *const in_addr,\n        hostname: *mut u8,\n        hostname_len: u32,\n        timeout: u32,\n        retry: i32,\n    ) -> i32;\n    pub fn sceNetResolverStop(rid: i32) -> i32;\n    pub fn sceNetResolverTerm() -> i32;\n}\n"],["1133","pub type c_ulong = u64;\npub type c_long = i64;\npub type time_t = i64;\n"],["1134","pub type rlim_t = ::uintptr_t;\npub type sa_family_t = u8;\npub type pthread_key_t = ::c_int;\npub type nfds_t = ::c_ulong;\npub type tcflag_t = ::c_uint;\npub type speed_t = ::c_uchar;\npub type c_char = i8;\npub type clock_t = i32;\npub type clockid_t = i32;\npub type suseconds_t = i32;\npub type wchar_t = i32;\npub type off_t = i64;\npub type ino_t = i64;\npub type blkcnt_t = i64;\npub type blksize_t = i32;\npub type dev_t = i32;\npub type mode_t = u32;\npub type nlink_t = i32;\npub type useconds_t = u32;\npub type socklen_t = u32;\npub type pthread_t = ::uintptr_t;\npub type pthread_condattr_t = ::uintptr_t;\npub type pthread_mutexattr_t = ::uintptr_t;\npub type pthread_rwlockattr_t = ::uintptr_t;\npub type sigset_t = u64;\npub type fsblkcnt_t = i64;\npub type fsfilcnt_t = i64;\npub type pthread_attr_t = *mut ::c_void;\npub type nl_item = ::c_int;\npub type id_t = i32;\npub type idtype_t = ::c_uint;\npub type fd_mask = u32;\n\n#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\npub enum timezone {}\nimpl ::Copy for timezone {}\nimpl ::Clone for timezone {\n    fn clone(&self) -> timezone {\n        *self\n    }\n}\n\nimpl siginfo_t {\n    pub unsafe fn si_addr(&self) -> *mut ::c_void {\n        self.si_addr\n    }\n\n    pub unsafe fn si_pid(&self) -> ::pid_t {\n        self.si_pid\n    }\n\n    pub unsafe fn si_uid(&self) -> ::uid_t {\n        self.si_uid\n    }\n\n    pub unsafe fn si_status(&self) -> ::c_int {\n        self.si_status\n    }\n}\n\ns! {\n    pub struct in_addr {\n        pub s_addr: ::in_addr_t,\n    }\n\n    pub struct ip_mreq {\n        pub imr_multiaddr: in_addr,\n        pub imr_interface: in_addr,\n    }\n\n    pub struct sockaddr {\n        pub sa_len: u8,\n        pub sa_family: sa_family_t,\n        pub sa_data: [u8; 30],\n    }\n\n    pub struct sockaddr_in {\n        pub sin_len: u8,\n        pub sin_family: sa_family_t,\n        pub sin_port: ::in_port_t,\n        pub sin_addr: ::in_addr,\n        pub sin_zero: [i8; 24],\n    }\n\n    pub struct sockaddr_in6 {\n        pub sin6_len: u8,\n        pub sin6_family: u8,\n        pub sin6_port: u16,\n        pub sin6_flowinfo: u32,\n        pub sin6_addr: ::in6_addr,\n        pub sin6_scope_id: u32,\n    }\n\n    pub struct addrinfo {\n        pub ai_flags: ::c_int,\n        pub ai_family: ::c_int,\n        pub ai_socktype: ::c_int,\n        pub ai_protocol: ::c_int,\n        pub ai_addrlen: socklen_t,\n        pub ai_canonname: *mut c_char,\n        pub ai_addr: *mut ::sockaddr,\n        pub ai_next: *mut addrinfo,\n    }\n\n    pub struct fd_set {\n        // size for 1024 bits, and a fd_mask with size u32\n        fds_bits: [fd_mask; 32],\n    }\n\n    pub struct tm {\n        pub tm_sec: ::c_int,\n        pub tm_min: ::c_int,\n        pub tm_hour: ::c_int,\n        pub tm_mday: ::c_int,\n        pub tm_mon: ::c_int,\n        pub tm_year: ::c_int,\n        pub tm_wday: ::c_int,\n        pub tm_yday: ::c_int,\n        pub tm_isdst: ::c_int,\n        pub tm_gmtoff: ::c_int,\n        pub tm_zone: *mut ::c_char,\n    }\n\n    pub struct utsname {\n        pub sysname: [::c_char; 32],\n        pub nodename: [::c_char; 32],\n        pub release: [::c_char; 32],\n        pub version: [::c_char; 32],\n        pub machine: [::c_char; 32],\n    }\n\n    pub struct lconv {\n        pub decimal_point: *mut ::c_char,\n        pub thousands_sep: *mut ::c_char,\n        pub grouping: *mut ::c_char,\n        pub int_curr_symbol: *mut ::c_char,\n        pub currency_symbol: *mut ::c_char,\n        pub mon_decimal_point: *mut ::c_char,\n        pub mon_thousands_sep: *mut ::c_char,\n        pub mon_grouping: *mut ::c_char,\n        pub positive_sign: *mut ::c_char,\n        pub negative_sign: *mut ::c_char,\n        pub int_frac_digits: ::c_char,\n        pub frac_digits: ::c_char,\n        pub p_cs_precedes: ::c_char,\n        pub p_sep_by_space: ::c_char,\n        pub n_cs_precedes: ::c_char,\n        pub n_sep_by_space: ::c_char,\n        pub p_sign_posn: ::c_char,\n        pub n_sign_posn: ::c_char,\n        pub int_p_cs_precedes: ::c_char,\n        pub int_p_sep_by_space: ::c_char,\n        pub int_n_cs_precedes: ::c_char,\n        pub int_n_sep_by_space: ::c_char,\n        pub int_p_sign_posn: ::c_char,\n        pub int_n_sign_posn: ::c_char,\n    }\n\n    pub struct msghdr {\n        pub msg_name: *mut ::c_void,\n        pub msg_namelen: socklen_t,\n        pub msg_iov: *mut ::iovec,\n        pub msg_iovlen: ::c_int,\n        pub msg_control: *mut ::c_void,\n        pub msg_controllen: socklen_t,\n        pub msg_flags: ::c_int,\n    }\n\n    pub struct cmsghdr {\n        pub cmsg_len: ::socklen_t,\n        pub cmsg_level: ::c_int,\n        pub cmsg_type: ::c_int,\n    }\n\n    pub struct Dl_info {\n        pub dli_fname: *const ::c_char,\n        pub dli_fbase: *mut ::c_void,\n        pub dli_sname: *const ::c_char,\n        pub dli_saddr: *mut ::c_void,\n    }\n\n    pub struct termios {\n        pub c_iflag: ::tcflag_t,\n        pub c_oflag: ::tcflag_t,\n        pub c_cflag: ::tcflag_t,\n        pub c_lflag: ::tcflag_t,\n        pub c_line:  ::c_char,\n        pub c_ispeed: ::speed_t,\n        pub c_ospeed: ::speed_t,\n        pub c_cc: [::cc_t; ::NCCS],\n    }\n\n    pub struct flock {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off_t,\n        pub l_len: ::off_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct stat {\n        pub st_dev: dev_t,\n        pub st_ino: ino_t,\n        pub st_mode: mode_t,\n        pub st_nlink: nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_size: off_t,\n        pub st_rdev: dev_t,\n        pub st_blksize: blksize_t,\n        pub st_atime: time_t,\n        pub st_atime_nsec: c_long,\n        pub st_mtime: time_t,\n        pub st_mtime_nsec: c_long,\n        pub st_ctime: time_t,\n        pub st_ctime_nsec: c_long,\n        pub st_crtime: time_t,\n        pub st_crtime_nsec: c_long,\n        pub st_type: u32,\n        pub st_blocks: blkcnt_t,\n    }\n\n    pub struct glob_t {\n        pub gl_pathc: ::size_t,\n        __unused1: ::size_t,\n        pub gl_offs: ::size_t,\n        __unused2: ::size_t,\n        pub gl_pathv: *mut *mut c_char,\n\n        __unused3: *mut ::c_void,\n        __unused4: *mut ::c_void,\n        __unused5: *mut ::c_void,\n        __unused6: *mut ::c_void,\n        __unused7: *mut ::c_void,\n        __unused8: *mut ::c_void,\n    }\n\n    pub struct pthread_mutex_t {\n        flags: u32,\n        lock: i32,\n        unused: i32,\n        owner: i32,\n        owner_count: i32,\n    }\n\n    pub struct pthread_cond_t {\n        flags: u32,\n        unused: i32,\n        mutex: *mut ::c_void,\n        waiter_count: i32,\n        lock: i32,\n    }\n\n    pub struct pthread_rwlock_t {\n        flags: u32,\n        owner: i32,\n        lock_sem: i32,      // this is actually a union\n        lock_count: i32,\n        reader_count: i32,\n        writer_count: i32,\n        waiters: [*mut ::c_void; 2],\n    }\n\n    pub struct passwd {\n        pub pw_name: *mut ::c_char,\n        pub pw_passwd: *mut ::c_char,\n        pub pw_uid: ::uid_t,\n        pub pw_gid: ::gid_t,\n        pub pw_dir: *mut ::c_char,\n        pub pw_shell: *mut ::c_char,\n        pub pw_gecos: *mut ::c_char,\n    }\n\n    pub struct statvfs {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_favail: ::fsfilcnt_t,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_size: ::size_t,\n        pub ss_flags: ::c_int,\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_code: ::c_int,\n        pub si_errno: ::c_int,\n        pub si_pid: ::pid_t,\n        pub si_uid: ::uid_t,\n        pub si_addr: *mut ::c_void,\n        pub si_status: ::c_int,\n        pub si_band: c_long,\n        pub sigval: *mut ::c_void,\n    }\n\n    pub struct sigaction {\n        pub sa_sigaction: ::sighandler_t, //actually a union with sa_handler\n        pub sa_mask: ::sigset_t,\n        pub sa_flags: ::c_int,\n        sa_userdata: *mut ::c_void,\n    }\n\n    pub struct sem_t {\n        pub type_: i32,\n        pub named_sem_id: i32, // actually a union with unnamed_sem (i32)\n        pub padding: [i32; 2],\n    }\n}\n\ns_no_extra_traits! {\n    pub struct sockaddr_un {\n        pub sun_len: u8,\n        pub sun_family: sa_family_t,\n        pub sun_path: [::c_char; 126]\n    }\n    pub struct sockaddr_storage {\n        pub ss_len: u8,\n        pub ss_family: sa_family_t,\n        __ss_pad1: [u8; 6],\n        __ss_pad2: u64,\n        __ss_pad3: [u8; 112],\n    }\n    pub struct dirent {\n        pub d_dev: dev_t,\n        pub d_pdev: dev_t,\n        pub d_ino: ino_t,\n        pub d_pino: i64,\n        pub d_reclen: ::c_ushort,\n        pub d_name: [::c_char; 1024], // Max length is _POSIX_PATH_MAX\n    }\n\n    pub struct sigevent {\n        pub sigev_notify: ::c_int,\n        pub sigev_signo: ::c_int,\n        pub sigev_value: ::sigval,\n        __unused1: *mut ::c_void, // actually a function pointer\n        pub sigev_notify_attributes: *mut ::pthread_attr_t,\n    }\n}\n\ncfg_if! {\n    if #[cfg(feature = \"extra_traits\")] {\n        impl PartialEq for sockaddr_un {\n            fn eq(&self, other: &sockaddr_un) -> bool {\n                self.sun_len == other.sun_len\n                    && self.sun_family == other.sun_family\n                    && self\n                    .sun_path\n                    .iter()\n                    .zip(other.sun_path.iter())\n                    .all(|(a,b)| a == b)\n            }\n        }\n        impl Eq for sockaddr_un {}\n        impl ::fmt::Debug for sockaddr_un {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"sockaddr_un\")\n                    .field(\"sun_len\", &self.sun_len)\n                    .field(\"sun_family\", &self.sun_family)\n                    // FIXME: .field(\"sun_path\", &self.sun_path)\n                    .finish()\n            }\n        }\n        impl ::hash::Hash for sockaddr_un {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.sun_len.hash(state);\n                self.sun_family.hash(state);\n                self.sun_path.hash(state);\n            }\n        }\n\n        impl PartialEq for sockaddr_storage {\n            fn eq(&self, other: &sockaddr_storage) -> bool {\n                self.ss_len == other.ss_len\n                    && self.ss_family == other.ss_family\n                    && self\n                    .__ss_pad1\n                    .iter()\n                    .zip(other.__ss_pad1.iter())\n                    .all(|(a, b)| a == b)\n                    && self.__ss_pad2 == other.__ss_pad2\n                    && self\n                    .__ss_pad3\n                    .iter()\n                    .zip(other.__ss_pad3.iter())\n                    .all(|(a, b)| a == b)\n            }\n        }\n        impl Eq for sockaddr_storage {}\n        impl ::fmt::Debug for sockaddr_storage {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"sockaddr_storage\")\n                    .field(\"ss_len\", &self.ss_len)\n                    .field(\"ss_family\", &self.ss_family)\n                    .field(\"__ss_pad1\", &self.__ss_pad1)\n                    .field(\"__ss_pad2\", &self.__ss_pad2)\n                    // FIXME: .field(\"__ss_pad3\", &self.__ss_pad3)\n                    .finish()\n            }\n        }\n        impl ::hash::Hash for sockaddr_storage {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.ss_len.hash(state);\n                self.ss_family.hash(state);\n                self.__ss_pad1.hash(state);\n                self.__ss_pad2.hash(state);\n                self.__ss_pad3.hash(state);\n            }\n        }\n\n        impl PartialEq for dirent {\n            fn eq(&self, other: &dirent) -> bool {\n                self.d_dev == other.d_dev\n                    && self.d_pdev == other.d_pdev\n                    && self.d_ino == other.d_ino\n                    && self.d_pino == other.d_pino\n                    && self.d_reclen == other.d_reclen\n                    && self\n                    .d_name\n                    .iter()\n                    .zip(other.d_name.iter())\n                    .all(|(a,b)| a == b)\n            }\n        }\n        impl Eq for dirent {}\n        impl ::fmt::Debug for dirent {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"dirent\")\n                    .field(\"d_dev\", &self.d_dev)\n                    .field(\"d_pdev\", &self.d_pdev)\n                    .field(\"d_ino\", &self.d_ino)\n                    .field(\"d_pino\", &self.d_pino)\n                    .field(\"d_reclen\", &self.d_reclen)\n                    // FIXME: .field(\"d_name\", &self.d_name)\n                    .finish()\n            }\n        }\n        impl ::hash::Hash for dirent {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.d_dev.hash(state);\n                self.d_pdev.hash(state);\n                self.d_ino.hash(state);\n                self.d_pino.hash(state);\n                self.d_reclen.hash(state);\n                self.d_name.hash(state);\n            }\n        }\n\n        impl PartialEq for sigevent {\n            fn eq(&self, other: &sigevent) -> bool {\n                self.sigev_notify == other.sigev_notify\n                    && self.sigev_signo == other.sigev_signo\n                    && self.sigev_value == other.sigev_value\n                    && self.sigev_notify_attributes\n                        == other.sigev_notify_attributes\n            }\n        }\n        impl Eq for sigevent {}\n        impl ::fmt::Debug for sigevent {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"sigevent\")\n                    .field(\"sigev_notify\", &self.sigev_notify)\n                    .field(\"sigev_signo\", &self.sigev_signo)\n                    .field(\"sigev_value\", &self.sigev_value)\n                    .field(\"sigev_notify_attributes\",\n                           &self.sigev_notify_attributes)\n                    .finish()\n            }\n        }\n        impl ::hash::Hash for sigevent {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.sigev_notify.hash(state);\n                self.sigev_signo.hash(state);\n                self.sigev_value.hash(state);\n                self.sigev_notify_attributes.hash(state);\n            }\n        }\n    }\n}\n\npub const EXIT_FAILURE: ::c_int = 1;\npub const EXIT_SUCCESS: ::c_int = 0;\npub const RAND_MAX: ::c_int = 2147483647;\npub const EOF: ::c_int = -1;\npub const SEEK_SET: ::c_int = 0;\npub const SEEK_CUR: ::c_int = 1;\npub const SEEK_END: ::c_int = 2;\npub const _IOFBF: ::c_int = 0;\npub const _IONBF: ::c_int = 2;\npub const _IOLBF: ::c_int = 1;\n\npub const F_DUPFD: ::c_int = 0x0001;\npub const F_GETFD: ::c_int = 0x0002;\npub const F_SETFD: ::c_int = 0x0004;\npub const F_GETFL: ::c_int = 0x0008;\npub const F_SETFL: ::c_int = 0x0010;\npub const F_GETLK: ::c_int = 0x0020;\npub const F_SETLK: ::c_int = 0x0080;\npub const F_SETLKW: ::c_int = 0x0100;\npub const F_DUPFD_CLOEXEC: ::c_int = 0x0200;\n\npub const F_RDLCK: ::c_int = 0x0040;\npub const F_UNLCK: ::c_int = 0x0200;\npub const F_WRLCK: ::c_int = 0x0400;\n\npub const AT_FDCWD: ::c_int = -1;\npub const AT_SYMLINK_NOFOLLOW: ::c_int = 0x01;\npub const AT_SYMLINK_FOLLOW: ::c_int = 0x02;\npub const AT_REMOVEDIR: ::c_int = 0x04;\npub const AT_EACCESS: ::c_int = 0x08;\n\npub const POLLIN: ::c_short = 0x0001;\npub const POLLOUT: ::c_short = 0x0002;\npub const POLLRDNORM: ::c_short = POLLIN;\npub const POLLWRNORM: ::c_short = POLLOUT;\npub const POLLRDBAND: ::c_short = 0x0008;\npub const POLLWRBAND: ::c_short = 0x0010;\npub const POLLPRI: ::c_short = 0x0020;\npub const POLLERR: ::c_short = 0x0004;\npub const POLLHUP: ::c_short = 0x0080;\npub const POLLNVAL: ::c_short = 0x1000;\n\npub const PTHREAD_CREATE_JOINABLE: ::c_int = 0;\npub const PTHREAD_CREATE_DETACHED: ::c_int = 1;\n\npub const CLOCK_REALTIME: ::c_int = -1;\npub const CLOCK_MONOTONIC: ::c_int = 0;\n\npub const RLIMIT_CORE: ::c_int = 0;\npub const RLIMIT_CPU: ::c_int = 1;\npub const RLIMIT_DATA: ::c_int = 2;\npub const RLIMIT_FSIZE: ::c_int = 3;\npub const RLIMIT_NOFILE: ::c_int = 4;\npub const RLIMIT_STACK: ::c_int = 5;\npub const RLIMIT_AS: ::c_int = 6;\n// Haiku specific\npub const RLIMIT_NOVMON: ::c_int = 7;\npub const RLIM_NLIMITS: ::c_int = 8;\n\npub const RUSAGE_SELF: ::c_int = 0;\n\npub const RTLD_LAZY: ::c_int = 0;\n\npub const NCCS: usize = 11;\n\npub const O_RDONLY: ::c_int = 0x0000;\npub const O_WRONLY: ::c_int = 0x0001;\npub const O_RDWR: ::c_int = 0x0002;\npub const O_ACCMODE: ::c_int = 0x0003;\n\npub const O_EXCL: ::c_int = 0x0100;\npub const O_CREAT: ::c_int = 0x0200;\npub const O_TRUNC: ::c_int = 0x0400;\npub const O_NOCTTY: ::c_int = 0x1000;\npub const O_NOTRAVERSE: ::c_int = 0x2000;\n\npub const O_CLOEXEC: ::c_int = 0x00000040;\npub const O_NONBLOCK: ::c_int = 0x00000080;\npub const O_APPEND: ::c_int = 0x00000800;\npub const O_SYNC: ::c_int = 0x00010000;\npub const O_RSYNC: ::c_int = 0x00020000;\npub const O_DSYNC: ::c_int = 0x00040000;\npub const O_NOFOLLOW: ::c_int = 0x00080000;\npub const O_NOCACHE: ::c_int = 0x00100000;\npub const O_DIRECTORY: ::c_int = 0x00200000;\n\npub const S_IFIFO: ::mode_t = 4096;\npub const S_IFCHR: ::mode_t = 8192;\npub const S_IFBLK: ::mode_t = 24576;\npub const S_IFDIR: ::mode_t = 16384;\npub const S_IFREG: ::mode_t = 32768;\npub const S_IFLNK: ::mode_t = 40960;\npub const S_IFSOCK: ::mode_t = 49152;\npub const S_IFMT: ::mode_t = 61440;\n\npub const S_IRWXU: ::mode_t = 0o00700;\npub const S_IRUSR: ::mode_t = 0o00400;\npub const S_IWUSR: ::mode_t = 0o00200;\npub const S_IXUSR: ::mode_t = 0o00100;\npub const S_IRWXG: ::mode_t = 0o00070;\npub const S_IRGRP: ::mode_t = 0o00040;\npub const S_IWGRP: ::mode_t = 0o00020;\npub const S_IXGRP: ::mode_t = 0o00010;\npub const S_IRWXO: ::mode_t = 0o00007;\npub const S_IROTH: ::mode_t = 0o00004;\npub const S_IWOTH: ::mode_t = 0o00002;\npub const S_IXOTH: ::mode_t = 0o00001;\n\npub const F_OK: ::c_int = 0;\npub const R_OK: ::c_int = 4;\npub const W_OK: ::c_int = 2;\npub const X_OK: ::c_int = 1;\npub const STDIN_FILENO: ::c_int = 0;\npub const STDOUT_FILENO: ::c_int = 1;\npub const STDERR_FILENO: ::c_int = 2;\n\npub const SIGHUP: ::c_int = 1;\npub const SIGINT: ::c_int = 2;\npub const SIGQUIT: ::c_int = 3;\npub const SIGILL: ::c_int = 4;\npub const SIGCHLD: ::c_int = 5;\npub const SIGABRT: ::c_int = 6;\npub const SIGPIPE: ::c_int = 7;\npub const SIGFPE: ::c_int = 8;\npub const SIGKILL: ::c_int = 9;\npub const SIGSTOP: ::c_int = 10;\npub const SIGSEGV: ::c_int = 11;\npub const SIGCONT: ::c_int = 12;\npub const SIGTSTP: ::c_int = 13;\npub const SIGALRM: ::c_int = 14;\npub const SIGTERM: ::c_int = 15;\npub const SIGTTIN: ::c_int = 16;\npub const SIGTTOU: ::c_int = 17;\npub const SIGUSR1: ::c_int = 18;\npub const SIGUSR2: ::c_int = 19;\npub const SIGWINCH: ::c_int = 20;\npub const SIGKILLTHR: ::c_int = 21;\npub const SIGTRAP: ::c_int = 22;\npub const SIGPOLL: ::c_int = 23;\npub const SIGPROF: ::c_int = 24;\npub const SIGSYS: ::c_int = 25;\npub const SIGURG: ::c_int = 26;\npub const SIGVTALRM: ::c_int = 27;\npub const SIGXCPU: ::c_int = 28;\npub const SIGXFSZ: ::c_int = 29;\npub const SIGBUS: ::c_int = 30;\n\npub const SIG_BLOCK: ::c_int = 1;\npub const SIG_UNBLOCK: ::c_int = 2;\npub const SIG_SETMASK: ::c_int = 3;\n\npub const SIGEV_NONE: ::c_int = 0;\npub const SIGEV_SIGNAL: ::c_int = 1;\npub const SIGEV_THREAD: ::c_int = 2;\n\npub const EAI_AGAIN: ::c_int = 2;\npub const EAI_BADFLAGS: ::c_int = 3;\npub const EAI_FAIL: ::c_int = 4;\npub const EAI_FAMILY: ::c_int = 5;\npub const EAI_MEMORY: ::c_int = 6;\npub const EAI_NODATA: ::c_int = 7;\npub const EAI_NONAME: ::c_int = 8;\npub const EAI_SERVICE: ::c_int = 9;\npub const EAI_SOCKTYPE: ::c_int = 10;\npub const EAI_SYSTEM: ::c_int = 11;\npub const EAI_OVERFLOW: ::c_int = 14;\n\npub const PROT_NONE: ::c_int = 0;\npub const PROT_READ: ::c_int = 1;\npub const PROT_WRITE: ::c_int = 2;\npub const PROT_EXEC: ::c_int = 4;\n\npub const LC_ALL: ::c_int = 0;\npub const LC_COLLATE: ::c_int = 1;\npub const LC_CTYPE: ::c_int = 2;\npub const LC_MONETARY: ::c_int = 3;\npub const LC_NUMERIC: ::c_int = 4;\npub const LC_TIME: ::c_int = 5;\npub const LC_MESSAGES: ::c_int = 6;\n\n// FIXME: Haiku does not have MAP_FILE, but libstd/os.rs requires it\npub const MAP_FILE: ::c_int = 0x00;\npub const MAP_SHARED: ::c_int = 0x01;\npub const MAP_PRIVATE: ::c_int = 0x02;\npub const MAP_FIXED: ::c_int = 0x04;\npub const MAP_ANONYMOUS: ::c_int = 0x08;\npub const MAP_ANON: ::c_int = MAP_ANONYMOUS;\n\npub const MAP_FAILED: *mut ::c_void = !0 as *mut ::c_void;\n\npub const MS_ASYNC: ::c_int = 0x01;\npub const MS_INVALIDATE: ::c_int = 0x04;\npub const MS_SYNC: ::c_int = 0x02;\n\npub const E2BIG: ::c_int = -2147454975;\npub const ECHILD: ::c_int = -2147454974;\npub const EDEADLK: ::c_int = -2147454973;\npub const EFBIG: ::c_int = -2147454972;\npub const EMLINK: ::c_int = -2147454971;\npub const ENFILE: ::c_int = -2147454970;\npub const ENODEV: ::c_int = -2147454969;\npub const ENOLCK: ::c_int = -2147454968;\npub const ENOSYS: ::c_int = -2147454967;\npub const ENOTTY: ::c_int = -2147454966;\npub const ENXIO: ::c_int = -2147454965;\npub const ESPIPE: ::c_int = -2147454964;\npub const ESRCH: ::c_int = -2147454963;\npub const EFPOS: ::c_int = -2147454962;\npub const ESIGPARM: ::c_int = -2147454961;\npub const EDOM: ::c_int = -2147454960;\npub const ERANGE: ::c_int = -2147454959;\npub const EPROTOTYPE: ::c_int = -2147454958;\npub const EPROTONOSUPPORT: ::c_int = -2147454957;\npub const EPFNOSUPPORT: ::c_int = -2147454956;\npub const EAFNOSUPPORT: ::c_int = -2147454955;\npub const EADDRINUSE: ::c_int = -2147454954;\npub const EADDRNOTAVAIL: ::c_int = -2147454953;\npub const ENETDOWN: ::c_int = -2147454952;\npub const ENETUNREACH: ::c_int = -2147454951;\npub const ENETRESET: ::c_int = -2147454950;\npub const ECONNABORTED: ::c_int = -2147454949;\npub const ECONNRESET: ::c_int = -2147454948;\npub const EISCONN: ::c_int = -2147454947;\npub const ENOTCONN: ::c_int = -2147454946;\npub const ESHUTDOWN: ::c_int = -2147454945;\npub const ECONNREFUSED: ::c_int = -2147454944;\npub const EHOSTUNREACH: ::c_int = -2147454943;\npub const ENOPROTOOPT: ::c_int = -2147454942;\npub const ENOBUFS: ::c_int = -2147454941;\npub const EINPROGRESS: ::c_int = -2147454940;\npub const EALREADY: ::c_int = -2147454939;\npub const EILSEQ: ::c_int = -2147454938;\npub const ENOMSG: ::c_int = -2147454937;\npub const ESTALE: ::c_int = -2147454936;\npub const EOVERFLOW: ::c_int = -2147454935;\npub const EMSGSIZE: ::c_int = -2147454934;\npub const EOPNOTSUPP: ::c_int = -2147454933;\npub const ENOTSOCK: ::c_int = -2147454932;\npub const EHOSTDOWN: ::c_int = -2147454931;\npub const EBADMSG: ::c_int = -2147454930;\npub const ECANCELED: ::c_int = -2147454929;\npub const EDESTADDRREQ: ::c_int = -2147454928;\npub const EDQUOT: ::c_int = -2147454927;\npub const EIDRM: ::c_int = -2147454926;\npub const EMULTIHOP: ::c_int = -2147454925;\npub const ENODATA: ::c_int = -2147454924;\npub const ENOLINK: ::c_int = -2147454923;\npub const ENOSR: ::c_int = -2147454922;\npub const ENOSTR: ::c_int = -2147454921;\npub const ENOTSUP: ::c_int = -2147454920;\npub const EPROTO: ::c_int = -2147454919;\npub const ETIME: ::c_int = -2147454918;\npub const ETXTBSY: ::c_int = -2147454917;\npub const ENOATTR: ::c_int = -2147454916;\n\n// INT_MIN\npub const ENOMEM: ::c_int = -2147483648;\n\n// POSIX errors that can be mapped to BeOS error codes\npub const EACCES: ::c_int = -2147483646;\npub const EINTR: ::c_int = -2147483638;\npub const EIO: ::c_int = -2147483647;\npub const EBUSY: ::c_int = -2147483634;\npub const EFAULT: ::c_int = -2147478783;\npub const ETIMEDOUT: ::c_int = -2147483639;\npub const EAGAIN: ::c_int = -2147483637;\npub const EWOULDBLOCK: ::c_int = -2147483637;\npub const EBADF: ::c_int = -2147459072;\npub const EEXIST: ::c_int = -2147459070;\npub const EINVAL: ::c_int = -2147483643;\npub const ENAMETOOLONG: ::c_int = -2147459068;\npub const ENOENT: ::c_int = -2147459069;\npub const EPERM: ::c_int = -2147483633;\npub const ENOTDIR: ::c_int = -2147459067;\npub const EISDIR: ::c_int = -2147459063;\npub const ENOTEMPTY: ::c_int = -2147459066;\npub const ENOSPC: ::c_int = -2147459065;\npub const EROFS: ::c_int = -2147459064;\npub const EMFILE: ::c_int = -2147459062;\npub const EXDEV: ::c_int = -2147459061;\npub const ELOOP: ::c_int = -2147459060;\npub const ENOEXEC: ::c_int = -2147478782;\npub const EPIPE: ::c_int = -2147459059;\n\npub const IPPROTO_RAW: ::c_int = 255;\n\n// These are prefixed with POSIX_ on Haiku\npub const MADV_NORMAL: ::c_int = 1;\npub const MADV_SEQUENTIAL: ::c_int = 2;\npub const MADV_RANDOM: ::c_int = 3;\npub const MADV_WILLNEED: ::c_int = 4;\npub const MADV_DONTNEED: ::c_int = 5;\n\n// https://github.com/haiku/haiku/blob/master/headers/posix/net/if.h#L80\npub const IFF_UP: ::c_int = 0x0001;\npub const IFF_BROADCAST: ::c_int = 0x0002; // valid broadcast address\npub const IFF_LOOPBACK: ::c_int = 0x0008;\npub const IFF_POINTOPOINT: ::c_int = 0x0010; // point-to-point link\npub const IFF_NOARP: ::c_int = 0x0040; // no address resolution\npub const IFF_AUTOUP: ::c_int = 0x0080; // auto dial\npub const IFF_PROMISC: ::c_int = 0x0100; // receive all packets\npub const IFF_ALLMULTI: ::c_int = 0x0200; // receive all multicast packets\npub const IFF_SIMPLEX: ::c_int = 0x0800; // doesn't receive own transmissions\npub const IFF_LINK: ::c_int = 0x1000; // has link\npub const IFF_AUTO_CONFIGURED: ::c_int = 0x2000;\npub const IFF_CONFIGURING: ::c_int = 0x4000;\npub const IFF_MULTICAST: ::c_int = 0x8000; // supports multicast\n\npub const AF_UNSPEC: ::c_int = 0;\npub const AF_INET: ::c_int = 1;\npub const AF_APPLETALK: ::c_int = 2;\npub const AF_ROUTE: ::c_int = 3;\npub const AF_LINK: ::c_int = 4;\npub const AF_INET6: ::c_int = 5;\npub const AF_DLI: ::c_int = 6;\npub const AF_IPX: ::c_int = 7;\npub const AF_NOTIFY: ::c_int = 8;\npub const AF_LOCAL: ::c_int = 9;\npub const AF_UNIX: ::c_int = AF_LOCAL;\npub const AF_BLUETOOTH: ::c_int = 10;\n\npub const IP_OPTIONS: ::c_int = 1;\npub const IP_HDRINCL: ::c_int = 2;\npub const IP_TOS: ::c_int = 3;\npub const IP_TTL: ::c_int = 4;\npub const IP_RECVOPTS: ::c_int = 5;\npub const IP_RECVRETOPTS: ::c_int = 6;\npub const IP_RECVDSTADDR: ::c_int = 7;\npub const IP_RETOPTS: ::c_int = 8;\npub const IP_MULTICAST_IF: ::c_int = 9;\npub const IP_MULTICAST_TTL: ::c_int = 10;\npub const IP_MULTICAST_LOOP: ::c_int = 11;\npub const IP_ADD_MEMBERSHIP: ::c_int = 12;\npub const IP_DROP_MEMBERSHIP: ::c_int = 13;\npub const IP_BLOCK_SOURCE: ::c_int = 14;\npub const IP_UNBLOCK_SOURCE: ::c_int = 15;\npub const IP_ADD_SOURCE_MEMBERSHIP: ::c_int = 16;\npub const IP_DROP_SOURCE_MEMBERSHIP: ::c_int = 17;\n\npub const TCP_NODELAY: ::c_int = 0x01;\npub const TCP_MAXSEG: ::c_int = 0x02;\npub const TCP_NOPUSH: ::c_int = 0x04;\npub const TCP_NOOPT: ::c_int = 0x08;\n\npub const IF_NAMESIZE: ::size_t = 32;\npub const IFNAMSIZ: ::size_t = IF_NAMESIZE;\n\npub const IPV6_MULTICAST_IF: ::c_int = 24;\npub const IPV6_MULTICAST_HOPS: ::c_int = 25;\npub const IPV6_MULTICAST_LOOP: ::c_int = 26;\npub const IPV6_UNICAST_HOPS: ::c_int = 27;\npub const IPV6_JOIN_GROUP: ::c_int = 28;\npub const IPV6_LEAVE_GROUP: ::c_int = 29;\npub const IPV6_V6ONLY: ::c_int = 30;\npub const IPV6_PKTINFO: ::c_int = 31;\npub const IPV6_RECVPKTINFO: ::c_int = 32;\npub const IPV6_HOPLIMIT: ::c_int = 33;\npub const IPV6_RECVHOPLIMIT: ::c_int = 34;\npub const IPV6_HOPOPTS: ::c_int = 35;\npub const IPV6_DSTOPTS: ::c_int = 36;\npub const IPV6_RTHDR: ::c_int = 37;\n\npub const MSG_OOB: ::c_int = 0x0001;\npub const MSG_PEEK: ::c_int = 0x0002;\npub const MSG_DONTROUTE: ::c_int = 0x0004;\npub const MSG_EOR: ::c_int = 0x0008;\npub const MSG_TRUNC: ::c_int = 0x0010;\npub const MSG_CTRUNC: ::c_int = 0x0020;\npub const MSG_WAITALL: ::c_int = 0x0040;\npub const MSG_DONTWAIT: ::c_int = 0x0080;\npub const MSG_BCAST: ::c_int = 0x0100;\npub const MSG_MCAST: ::c_int = 0x0200;\npub const MSG_EOF: ::c_int = 0x0400;\npub const MSG_NOSIGNAL: ::c_int = 0x0800;\n\npub const SHUT_RD: ::c_int = 0;\npub const SHUT_WR: ::c_int = 1;\npub const SHUT_RDWR: ::c_int = 2;\n\npub const LOCK_SH: ::c_int = 0x01;\npub const LOCK_EX: ::c_int = 0x02;\npub const LOCK_NB: ::c_int = 0x04;\npub const LOCK_UN: ::c_int = 0x08;\n\npub const SIGSTKSZ: ::size_t = 16384;\n\npub const IOV_MAX: ::c_int = 1024;\npub const PATH_MAX: ::c_int = 1024;\n\npub const SA_NOCLDSTOP: ::c_int = 0x01;\npub const SA_NOCLDWAIT: ::c_int = 0x02;\npub const SA_RESETHAND: ::c_int = 0x04;\npub const SA_NODEFER: ::c_int = 0x08;\npub const SA_RESTART: ::c_int = 0x10;\npub const SA_ONSTACK: ::c_int = 0x20;\npub const SA_SIGINFO: ::c_int = 0x40;\npub const SA_NOMASK: ::c_int = SA_NODEFER;\npub const SA_STACK: ::c_int = SA_ONSTACK;\npub const SA_ONESHOT: ::c_int = SA_RESETHAND;\n\npub const FD_SETSIZE: usize = 1024;\n\npub const RTLD_LOCAL: ::c_int = 0x0;\npub const RTLD_NOW: ::c_int = 0x1;\npub const RTLD_GLOBAL: ::c_int = 0x2;\npub const RTLD_DEFAULT: *mut ::c_void = 0isize as *mut ::c_void;\n\npub const BUFSIZ: ::c_uint = 8192;\npub const FILENAME_MAX: ::c_uint = 256;\npub const FOPEN_MAX: ::c_uint = 128;\npub const L_tmpnam: ::c_uint = 512;\npub const TMP_MAX: ::c_uint = 32768;\n\npub const _PC_CHOWN_RESTRICTED: ::c_int = 1;\npub const _PC_MAX_CANON: ::c_int = 2;\npub const _PC_MAX_INPUT: ::c_int = 3;\npub const _PC_NAME_MAX: ::c_int = 4;\npub const _PC_NO_TRUNC: ::c_int = 5;\npub const _PC_PATH_MAX: ::c_int = 6;\npub const _PC_PIPE_BUF: ::c_int = 7;\npub const _PC_VDISABLE: ::c_int = 8;\npub const _PC_LINK_MAX: ::c_int = 25;\npub const _PC_SYNC_IO: ::c_int = 26;\npub const _PC_ASYNC_IO: ::c_int = 27;\npub const _PC_PRIO_IO: ::c_int = 28;\npub const _PC_SOCK_MAXBUF: ::c_int = 29;\npub const _PC_FILESIZEBITS: ::c_int = 30;\npub const _PC_REC_INCR_XFER_SIZE: ::c_int = 31;\npub const _PC_REC_MAX_XFER_SIZE: ::c_int = 32;\npub const _PC_REC_MIN_XFER_SIZE: ::c_int = 33;\npub const _PC_REC_XFER_ALIGN: ::c_int = 34;\npub const _PC_ALLOC_SIZE_MIN: ::c_int = 35;\npub const _PC_SYMLINK_MAX: ::c_int = 36;\npub const _PC_2_SYMLINKS: ::c_int = 37;\npub const _PC_XATTR_EXISTS: ::c_int = 38;\npub const _PC_XATTR_ENABLED: ::c_int = 39;\n\npub const FIONBIO: ::c_ulong = 0xbe000000;\npub const FIONREAD: ::c_ulong = 0xbe000001;\npub const FIOSEEKDATA: ::c_ulong = 0xbe000002;\npub const FIOSEEKHOLE: ::c_ulong = 0xbe000003;\n\npub const _SC_ARG_MAX: ::c_int = 15;\npub const _SC_CHILD_MAX: ::c_int = 16;\npub const _SC_CLK_TCK: ::c_int = 17;\npub const _SC_JOB_CONTROL: ::c_int = 18;\npub const _SC_NGROUPS_MAX: ::c_int = 19;\npub const _SC_OPEN_MAX: ::c_int = 20;\npub const _SC_SAVED_IDS: ::c_int = 21;\npub const _SC_STREAM_MAX: ::c_int = 22;\npub const _SC_TZNAME_MAX: ::c_int = 23;\npub const _SC_VERSION: ::c_int = 24;\npub const _SC_GETGR_R_SIZE_MAX: ::c_int = 25;\npub const _SC_GETPW_R_SIZE_MAX: ::c_int = 26;\npub const _SC_PAGESIZE: ::c_int = 27;\npub const _SC_PAGE_SIZE: ::c_int = 27;\npub const _SC_SEM_NSEMS_MAX: ::c_int = 28;\npub const _SC_SEM_VALUE_MAX: ::c_int = 29;\npub const _SC_SEMAPHORES: ::c_int = 30;\npub const _SC_THREADS: ::c_int = 31;\npub const _SC_IOV_MAX: ::c_int = 32;\npub const _SC_UIO_MAXIOV: ::c_int = 32;\npub const _SC_NPROCESSORS_CONF: ::c_int = 34;\npub const _SC_NPROCESSORS_ONLN: ::c_int = 35;\npub const _SC_ATEXIT_MAX: ::c_int = 37;\npub const _SC_PASS_MAX: ::c_int = 39;\npub const _SC_PHYS_PAGES: ::c_int = 40;\npub const _SC_AVPHYS_PAGES: ::c_int = 41;\npub const _SC_PIPE: ::c_int = 42;\npub const _SC_SELECT: ::c_int = 43;\npub const _SC_POLL: ::c_int = 44;\npub const _SC_MAPPED_FILES: ::c_int = 45;\npub const _SC_THREAD_PROCESS_SHARED: ::c_int = 46;\npub const _SC_THREAD_STACK_MIN: ::c_int = 47;\npub const _SC_THREAD_ATTR_STACKADDR: ::c_int = 48;\npub const _SC_THREAD_ATTR_STACKSIZE: ::c_int = 49;\npub const _SC_THREAD_PRIORITY_SCHEDULING: ::c_int = 50;\npub const _SC_REALTIME_SIGNALS: ::c_int = 51;\npub const _SC_MEMORY_PROTECTION: ::c_int = 52;\npub const _SC_SIGQUEUE_MAX: ::c_int = 53;\npub const _SC_RTSIG_MAX: ::c_int = 54;\npub const _SC_MONOTONIC_CLOCK: ::c_int = 55;\npub const _SC_DELAYTIMER_MAX: ::c_int = 56;\npub const _SC_TIMER_MAX: ::c_int = 57;\npub const _SC_TIMERS: ::c_int = 58;\npub const _SC_CPUTIME: ::c_int = 59;\npub const _SC_THREAD_CPUTIME: ::c_int = 60;\npub const _SC_HOST_NAME_MAX: ::c_int = 61;\npub const _SC_REGEXP: ::c_int = 62;\npub const _SC_SYMLOOP_MAX: ::c_int = 63;\npub const _SC_SHELL: ::c_int = 64;\n\npub const PTHREAD_STACK_MIN: ::size_t = 8192;\n\npub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n    flags: 0,\n    lock: 0,\n    unused: -42,\n    owner: -1,\n    owner_count: 0,\n};\npub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n    flags: 0,\n    unused: -42,\n    mutex: 0 as *mut _,\n    waiter_count: 0,\n    lock: 0,\n};\npub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {\n    flags: 0,\n    owner: -1,\n    lock_sem: 0,\n    lock_count: 0,\n    reader_count: 0,\n    writer_count: 0,\n    waiters: [0 as *mut _; 2],\n};\n\npub const PTHREAD_MUTEX_DEFAULT: ::c_int = 0;\npub const PTHREAD_MUTEX_NORMAL: ::c_int = 1;\npub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = 2;\npub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 3;\n\npub const FIOCLEX: c_ulong = 0; // FIXME: does not exist on Haiku!\n\npub const RUSAGE_CHILDREN: ::c_int = -1;\n\npub const SOCK_STREAM: ::c_int = 1;\npub const SOCK_DGRAM: ::c_int = 2;\npub const SOCK_RAW: ::c_int = 3;\npub const SOCK_SEQPACKET: ::c_int = 5;\n\npub const SOL_SOCKET: ::c_int = -1;\npub const SO_ACCEPTCONN: ::c_int = 0x00000001;\npub const SO_BROADCAST: ::c_int = 0x00000002;\npub const SO_DEBUG: ::c_int = 0x00000004;\npub const SO_DONTROUTE: ::c_int = 0x00000008;\npub const SO_KEEPALIVE: ::c_int = 0x00000010;\npub const SO_OOBINLINE: ::c_int = 0x00000020;\npub const SO_REUSEADDR: ::c_int = 0x00000040;\npub const SO_REUSEPORT: ::c_int = 0x00000080;\npub const SO_USELOOPBACK: ::c_int = 0x00000100;\npub const SO_LINGER: ::c_int = 0x00000200;\npub const SO_SNDBUF: ::c_int = 0x40000001;\npub const SO_SNDLOWAT: ::c_int = 0x40000002;\npub const SO_SNDTIMEO: ::c_int = 0x40000003;\npub const SO_RCVBUF: ::c_int = 0x40000004;\npub const SO_RCVLOWAT: ::c_int = 0x40000005;\npub const SO_RCVTIMEO: ::c_int = 0x40000006;\npub const SO_ERROR: ::c_int = 0x40000007;\npub const SO_TYPE: ::c_int = 0x40000008;\npub const SO_NONBLOCK: ::c_int = 0x40000009;\npub const SO_BINDTODEVICE: ::c_int = 0x4000000a;\npub const SO_PEERCRED: ::c_int = 0x4000000b;\n\npub const SCM_RIGHTS: ::c_int = 0x01;\n\npub const NI_MAXHOST: ::size_t = 1025;\n\npub const WNOHANG: ::c_int = 0x01;\npub const WUNTRACED: ::c_int = 0x02;\npub const WCONTINUED: ::c_int = 0x04;\npub const WEXITED: ::c_int = 0x08;\npub const WSTOPPED: ::c_int = 0x10;\npub const WNOWAIT: ::c_int = 0x20;\n\npub const CLD_EXITED: ::c_int = 60;\npub const CLD_KILLED: ::c_int = 61;\npub const CLD_DUMPED: ::c_int = 62;\npub const CLD_TRAPPED: ::c_int = 63;\npub const CLD_STOPPED: ::c_int = 64;\npub const CLD_CONTINUED: ::c_int = 65;\n\npub const P_ALL: idtype_t = 0;\npub const P_PID: idtype_t = 1;\npub const P_PGID: idtype_t = 2;\n\npub const UTIME_OMIT: c_long = 1000000001;\npub const UTIME_NOW: c_long = 1000000000;\n\npub const VINTR: usize = 0;\npub const VQUIT: usize = 1;\npub const VERASE: usize = 2;\npub const VKILL: usize = 3;\npub const VEOF: usize = 4;\npub const VEOL: usize = 5;\npub const VMIN: usize = 4;\npub const VTIME: usize = 5;\npub const VEOL2: usize = 6;\npub const VSWTCH: usize = 7;\npub const VSTART: usize = 8;\npub const VSTOP: usize = 9;\npub const VSUSP: usize = 10;\n\npub const IGNBRK: ::tcflag_t = 0x01;\npub const BRKINT: ::tcflag_t = 0x02;\npub const IGNPAR: ::tcflag_t = 0x04;\npub const PARMRK: ::tcflag_t = 0x08;\npub const INPCK: ::tcflag_t = 0x10;\npub const ISTRIP: ::tcflag_t = 0x20;\npub const INLCR: ::tcflag_t = 0x40;\npub const IGNCR: ::tcflag_t = 0x80;\npub const ICRNL: ::tcflag_t = 0x100;\npub const IUCLC: ::tcflag_t = 0x200;\npub const IXON: ::tcflag_t = 0x400;\npub const IXANY: ::tcflag_t = 0x800;\npub const IXOFF: ::tcflag_t = 0x1000;\n\npub const OPOST: ::tcflag_t = 0x00000001;\npub const OLCUC: ::tcflag_t = 0x00000002;\npub const ONLCR: ::tcflag_t = 0x00000004;\npub const OCRNL: ::tcflag_t = 0x00000008;\npub const ONOCR: ::tcflag_t = 0x00000010;\npub const ONLRET: ::tcflag_t = 0x00000020;\npub const OFILL: ::tcflag_t = 0x00000040;\npub const OFDEL: ::tcflag_t = 0x00000080;\npub const NLDLY: ::tcflag_t = 0x00000100;\npub const NL0: ::tcflag_t = 0x00000000;\npub const NL1: ::tcflag_t = 0x00000100;\npub const CRDLY: ::tcflag_t = 0x00000600;\npub const CR0: ::tcflag_t = 0x00000000;\npub const CR1: ::tcflag_t = 0x00000200;\npub const CR2: ::tcflag_t = 0x00000400;\npub const CR3: ::tcflag_t = 0x00000600;\npub const TABDLY: ::tcflag_t = 0x00001800;\npub const TAB0: ::tcflag_t = 0x00000000;\npub const TAB1: ::tcflag_t = 0x00000800;\npub const TAB2: ::tcflag_t = 0x00001000;\npub const TAB3: ::tcflag_t = 0x00001800;\npub const BSDLY: ::tcflag_t = 0x00002000;\npub const BS0: ::tcflag_t = 0x00000000;\npub const BS1: ::tcflag_t = 0x00002000;\npub const VTDLY: ::tcflag_t = 0x00004000;\npub const VT0: ::tcflag_t = 0x00000000;\npub const VT1: ::tcflag_t = 0x00004000;\npub const FFDLY: ::tcflag_t = 0x00008000;\npub const FF0: ::tcflag_t = 0x00000000;\npub const FF1: ::tcflag_t = 0x00008000;\n\npub const CSIZE: ::tcflag_t = 0x00000020;\npub const CS5: ::tcflag_t = 0x00000000;\npub const CS6: ::tcflag_t = 0x00000000;\npub const CS7: ::tcflag_t = 0x00000000;\npub const CS8: ::tcflag_t = 0x00000020;\npub const CSTOPB: ::tcflag_t = 0x00000040;\npub const CREAD: ::tcflag_t = 0x00000080;\npub const PARENB: ::tcflag_t = 0x00000100;\npub const PARODD: ::tcflag_t = 0x00000200;\npub const HUPCL: ::tcflag_t = 0x00000400;\npub const CLOCAL: ::tcflag_t = 0x00000800;\npub const XLOBLK: ::tcflag_t = 0x00001000;\npub const CTSFLOW: ::tcflag_t = 0x00002000;\npub const RTSFLOW: ::tcflag_t = 0x00004000;\npub const CRTSCTS: ::tcflag_t = RTSFLOW | CTSFLOW;\n\npub const ISIG: ::tcflag_t = 0x00000001;\npub const ICANON: ::tcflag_t = 0x00000002;\npub const XCASE: ::tcflag_t = 0x00000004;\npub const ECHO: ::tcflag_t = 0x00000008;\npub const ECHOE: ::tcflag_t = 0x00000010;\npub const ECHOK: ::tcflag_t = 0x00000020;\npub const ECHONL: ::tcflag_t = 0x00000040;\npub const NOFLSH: ::tcflag_t = 0x00000080;\npub const TOSTOP: ::tcflag_t = 0x00000100;\npub const IEXTEN: ::tcflag_t = 0x00000200;\npub const ECHOCTL: ::tcflag_t = 0x00000400;\npub const ECHOPRT: ::tcflag_t = 0x00000800;\npub const ECHOKE: ::tcflag_t = 0x00001000;\npub const FLUSHO: ::tcflag_t = 0x00002000;\npub const PENDIN: ::tcflag_t = 0x00004000;\n\npub const TCGB_CTS: ::c_int = 0x01;\npub const TCGB_DSR: ::c_int = 0x02;\npub const TCGB_RI: ::c_int = 0x04;\npub const TCGB_DCD: ::c_int = 0x08;\npub const TIOCM_CTS: ::c_int = TCGB_CTS;\npub const TIOCM_CD: ::c_int = TCGB_DCD;\npub const TIOCM_CAR: ::c_int = TIOCM_CD;\npub const TIOCM_RI: ::c_int = TCGB_RI;\npub const TIOCM_DSR: ::c_int = TCGB_DSR;\npub const TIOCM_DTR: ::c_int = 0x10;\npub const TIOCM_RTS: ::c_int = 0x20;\n\npub const B0: speed_t = 0x00;\npub const B50: speed_t = 0x01;\npub const B75: speed_t = 0x02;\npub const B110: speed_t = 0x03;\npub const B134: speed_t = 0x04;\npub const B150: speed_t = 0x05;\npub const B200: speed_t = 0x06;\npub const B300: speed_t = 0x07;\npub const B600: speed_t = 0x08;\npub const B1200: speed_t = 0x09;\npub const B1800: speed_t = 0x0A;\npub const B2400: speed_t = 0x0B;\npub const B4800: speed_t = 0x0C;\npub const B9600: speed_t = 0x0D;\npub const B19200: speed_t = 0x0E;\npub const B38400: speed_t = 0x0F;\npub const B57600: speed_t = 0x10;\npub const B115200: speed_t = 0x11;\npub const B230400: speed_t = 0x12;\npub const B31250: speed_t = 0x13;\n\npub const TCSANOW: ::c_int = 0x01;\npub const TCSADRAIN: ::c_int = 0x02;\npub const TCSAFLUSH: ::c_int = 0x04;\n\npub const TCOOFF: ::c_int = 0x01;\npub const TCOON: ::c_int = 0x02;\npub const TCIOFF: ::c_int = 0x04;\npub const TCION: ::c_int = 0x08;\n\npub const TCIFLUSH: ::c_int = 0x01;\npub const TCOFLUSH: ::c_int = 0x02;\npub const TCIOFLUSH: ::c_int = 0x03;\n\npub const TCGETA: ::c_ulong = 0x8000;\npub const TCSETA: ::c_ulong = TCGETA + 1;\npub const TCSETAF: ::c_ulong = TCGETA + 2;\npub const TCSETAW: ::c_ulong = TCGETA + 3;\npub const TCWAITEVENT: ::c_ulong = TCGETA + 4;\npub const TCSBRK: ::c_ulong = TCGETA + 5;\npub const TCFLSH: ::c_ulong = TCGETA + 6;\npub const TCXONC: ::c_ulong = TCGETA + 7;\npub const TCQUERYCONNECTED: ::c_ulong = TCGETA + 8;\npub const TCGETBITS: ::c_ulong = TCGETA + 9;\npub const TCSETDTR: ::c_ulong = TCGETA + 10;\npub const TCSETRTS: ::c_ulong = TCGETA + 11;\npub const TIOCGWINSZ: ::c_ulong = TCGETA + 12;\npub const TIOCSWINSZ: ::c_ulong = TCGETA + 13;\npub const TCVTIME: ::c_ulong = TCGETA + 14;\npub const TIOCGPGRP: ::c_ulong = TCGETA + 15;\npub const TIOCSPGRP: ::c_ulong = TCGETA + 16;\npub const TIOCSCTTY: ::c_ulong = TCGETA + 17;\npub const TIOCMGET: ::c_ulong = TCGETA + 18;\npub const TIOCMSET: ::c_ulong = TCGETA + 19;\npub const TIOCSBRK: ::c_ulong = TCGETA + 20;\npub const TIOCCBRK: ::c_ulong = TCGETA + 21;\npub const TIOCMBIS: ::c_ulong = TCGETA + 22;\npub const TIOCMBIC: ::c_ulong = TCGETA + 23;\n\npub const PRIO_PROCESS: ::c_int = 0;\npub const PRIO_PGRP: ::c_int = 1;\npub const PRIO_USER: ::c_int = 2;\n\npub const LOG_PID: ::c_int = 1 << 12;\npub const LOG_CONS: ::c_int = 2 << 12;\npub const LOG_ODELAY: ::c_int = 4 << 12;\npub const LOG_NDELAY: ::c_int = 8 << 12;\npub const LOG_SERIAL: ::c_int = 16 << 12;\npub const LOG_PERROR: ::c_int = 32 << 12;\npub const LOG_NOWAIT: ::c_int = 64 << 12;\n\nconst_fn! {\n    {const} fn CMSG_ALIGN(len: usize) -> usize {\n        len + ::mem::size_of::<usize>() - 1 & !(::mem::size_of::<usize>() - 1)\n    }\n}\n\nf! {\n    pub fn CMSG_FIRSTHDR(mhdr: *const msghdr) -> *mut cmsghdr {\n        if (*mhdr).msg_controllen as usize >= ::mem::size_of::<cmsghdr>() {\n            (*mhdr).msg_control as *mut cmsghdr\n        } else {\n            0 as *mut cmsghdr\n        }\n    }\n\n    pub fn CMSG_DATA(cmsg: *const ::cmsghdr) -> *mut ::c_uchar {\n        (cmsg as *mut ::c_uchar)\n            .offset(CMSG_ALIGN(::mem::size_of::<::cmsghdr>()) as isize)\n    }\n\n    pub {const} fn CMSG_SPACE(length: ::c_uint) -> ::c_uint {\n        (CMSG_ALIGN(length as usize) + CMSG_ALIGN(::mem::size_of::<cmsghdr>()))\n            as ::c_uint\n    }\n\n    pub fn CMSG_LEN(length: ::c_uint) -> ::c_uint {\n        CMSG_ALIGN(::mem::size_of::<cmsghdr>()) as ::c_uint + length\n    }\n\n    pub fn CMSG_NXTHDR(mhdr: *const msghdr,\n                       cmsg: *const cmsghdr) -> *mut cmsghdr {\n        if cmsg.is_null() {\n            return ::CMSG_FIRSTHDR(mhdr);\n        };\n        let next = cmsg as usize + CMSG_ALIGN((*cmsg).cmsg_len as usize)\n            + CMSG_ALIGN(::mem::size_of::<::cmsghdr>());\n        let max = (*mhdr).msg_control as usize\n            + (*mhdr).msg_controllen as usize;\n        if next > max {\n            0 as *mut ::cmsghdr\n        } else {\n            (cmsg as usize + CMSG_ALIGN((*cmsg).cmsg_len as usize))\n                as *mut ::cmsghdr\n        }\n    }\n\n    pub fn FD_CLR(fd: ::c_int, set: *mut fd_set) -> () {\n        let fd = fd as usize;\n        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;\n        (*set).fds_bits[fd / size] &= !(1 << (fd % size));\n        return\n    }\n\n    pub fn FD_ISSET(fd: ::c_int, set: *mut fd_set) -> bool {\n        let fd = fd as usize;\n        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;\n        return ((*set).fds_bits[fd / size] & (1 << (fd % size))) != 0\n    }\n\n    pub fn FD_SET(fd: ::c_int, set: *mut fd_set) -> () {\n        let fd = fd as usize;\n        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;\n        (*set).fds_bits[fd / size] |= 1 << (fd % size);\n        return\n    }\n\n    pub fn FD_ZERO(set: *mut fd_set) -> () {\n        for slot in (*set).fds_bits.iter_mut() {\n            *slot = 0;\n        }\n    }\n}\n\nsafe_f! {\n    pub {const} fn WIFEXITED(status: ::c_int) -> bool {\n        (status & !0xff) == 0\n    }\n\n    pub {const} fn WEXITSTATUS(status: ::c_int) -> ::c_int {\n        status & 0xff\n    }\n\n    pub {const} fn WIFSIGNALED(status: ::c_int) -> bool {\n        ((status >> 8) & 0xff) != 0\n    }\n\n    pub {const} fn WTERMSIG(status: ::c_int) -> ::c_int {\n        (status >> 8) & 0xff\n    }\n\n    pub {const} fn WIFSTOPPED(status: ::c_int) -> bool {\n        ((status >> 16) & 0xff) != 0\n    }\n\n    pub {const} fn WSTOPSIG(status: ::c_int) -> ::c_int {\n        (status >> 16) & 0xff\n    }\n\n    // actually WIFCORED, but this is used everywhere else\n    pub {const} fn WCOREDUMP(status: ::c_int) -> bool {\n        (status & 0x10000) != 0\n    }\n\n    pub {const} fn WIFCONTINUED(status: ::c_int) -> bool {\n        (status & 0x20000) != 0\n    }\n}\n\nextern \"C\" {\n    pub fn getrlimit(resource: ::c_int, rlim: *mut ::rlimit) -> ::c_int;\n    pub fn setrlimit(resource: ::c_int, rlim: *const ::rlimit) -> ::c_int;\n    pub fn getpriority(which: ::c_int, who: id_t) -> ::c_int;\n    pub fn setpriority(which: ::c_int, who: id_t, priority: ::c_int) -> ::c_int;\n\n    pub fn utimensat(\n        fd: ::c_int,\n        path: *const ::c_char,\n        times: *const ::timespec,\n        flag: ::c_int,\n    ) -> ::c_int;\n    pub fn futimens(fd: ::c_int, times: *const ::timespec) -> ::c_int;\n    pub fn strerror_r(errnum: ::c_int, buf: *mut c_char, buflen: ::size_t) -> ::c_int;\n    pub fn _errnop() -> *mut ::c_int;\n\n    pub fn abs(i: ::c_int) -> ::c_int;\n    pub fn atof(s: *const ::c_char) -> ::c_double;\n    pub fn labs(i: ::c_long) -> ::c_long;\n    pub fn rand() -> ::c_int;\n    pub fn srand(seed: ::c_uint);\n}\n\n#[link(name = \"bsd\")]\nextern \"C\" {\n    pub fn sem_destroy(sem: *mut sem_t) -> ::c_int;\n    pub fn sem_init(sem: *mut sem_t, pshared: ::c_int, value: ::c_uint) -> ::c_int;\n\n    pub fn clock_gettime(clk_id: ::c_int, tp: *mut ::timespec) -> ::c_int;\n    pub fn clock_settime(clk_id: ::c_int, tp: *const ::timespec) -> ::c_int;\n    pub fn pthread_create(\n        thread: *mut ::pthread_t,\n        attr: *const ::pthread_attr_t,\n        f: extern \"C\" fn(*mut ::c_void) -> *mut ::c_void,\n        value: *mut ::c_void,\n    ) -> ::c_int;\n    pub fn pthread_attr_getguardsize(\n        attr: *const ::pthread_attr_t,\n        guardsize: *mut ::size_t,\n    ) -> ::c_int;\n    pub fn pthread_attr_getstack(\n        attr: *const ::pthread_attr_t,\n        stackaddr: *mut *mut ::c_void,\n        stacksize: *mut ::size_t,\n    ) -> ::c_int;\n    pub fn pthread_condattr_getclock(\n        attr: *const pthread_condattr_t,\n        clock_id: *mut clockid_t,\n    ) -> ::c_int;\n    pub fn pthread_condattr_setclock(\n        attr: *mut pthread_condattr_t,\n        clock_id: ::clockid_t,\n    ) -> ::c_int;\n    pub fn memalign(align: ::size_t, size: ::size_t) -> *mut ::c_void;\n    pub fn setgroups(ngroups: ::c_int, ptr: *const ::gid_t) -> ::c_int;\n    pub fn ioctl(fd: ::c_int, request: ::c_ulong, ...) -> ::c_int;\n    pub fn mprotect(addr: *mut ::c_void, len: ::size_t, prot: ::c_int) -> ::c_int;\n    pub fn dirfd(dirp: *mut ::DIR) -> ::c_int;\n    pub fn getnameinfo(\n        sa: *const ::sockaddr,\n        salen: ::socklen_t,\n        host: *mut ::c_char,\n        hostlen: ::socklen_t,\n        serv: *mut ::c_char,\n        sevlen: ::socklen_t,\n        flags: ::c_int,\n    ) -> ::c_int;\n    pub fn pthread_mutex_timedlock(\n        lock: *mut pthread_mutex_t,\n        abstime: *const ::timespec,\n    ) -> ::c_int;\n    pub fn waitid(idtype: idtype_t, id: id_t, infop: *mut ::siginfo_t, options: ::c_int)\n        -> ::c_int;\n\n    pub fn glob(\n        pattern: *const ::c_char,\n        flags: ::c_int,\n        errfunc: ::Option<extern \"C\" fn(epath: *const ::c_char, errno: ::c_int) -> ::c_int>,\n        pglob: *mut ::glob_t,\n    ) -> ::c_int;\n    pub fn globfree(pglob: *mut ::glob_t);\n    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::c_void) -> ::c_int;\n    pub fn posix_madvise(addr: *mut ::c_void, len: ::size_t, advice: ::c_int) -> ::c_int;\n\n    pub fn shm_open(name: *const ::c_char, oflag: ::c_int, mode: ::mode_t) -> ::c_int;\n    pub fn shm_unlink(name: *const ::c_char) -> ::c_int;\n\n    pub fn seekdir(dirp: *mut ::DIR, loc: ::c_long);\n\n    pub fn telldir(dirp: *mut ::DIR) -> ::c_long;\n    pub fn madvise(addr: *mut ::c_void, len: ::size_t, advice: ::c_int) -> ::c_int;\n\n    pub fn msync(addr: *mut ::c_void, len: ::size_t, flags: ::c_int) -> ::c_int;\n\n    pub fn recvfrom(\n        socket: ::c_int,\n        buf: *mut ::c_void,\n        len: ::size_t,\n        flags: ::c_int,\n        addr: *mut ::sockaddr,\n        addrlen: *mut ::socklen_t,\n    ) -> ::ssize_t;\n    pub fn mkstemps(template: *mut ::c_char, suffixlen: ::c_int) -> ::c_int;\n    pub fn lutimes(file: *const ::c_char, times: *const ::timeval) -> ::c_int;\n    pub fn nl_langinfo(item: ::nl_item) -> *mut ::c_char;\n\n    pub fn bind(socket: ::c_int, address: *const ::sockaddr, address_len: ::socklen_t) -> ::c_int;\n\n    pub fn writev(fd: ::c_int, iov: *const ::iovec, count: ::c_int) -> ::ssize_t;\n    pub fn readv(fd: ::c_int, iov: *const ::iovec, count: ::c_int) -> ::ssize_t;\n\n    pub fn sendmsg(fd: ::c_int, msg: *const ::msghdr, flags: ::c_int) -> ::ssize_t;\n    pub fn recvmsg(fd: ::c_int, msg: *mut ::msghdr, flags: ::c_int) -> ::ssize_t;\n    pub fn execvpe(\n        file: *const ::c_char,\n        argv: *const *const ::c_char,\n        environment: *const *const ::c_char,\n    ) -> ::c_int;\n    pub fn getgrgid_r(\n        gid: ::gid_t,\n        grp: *mut ::group,\n        buf: *mut ::c_char,\n        buflen: ::size_t,\n        result: *mut *mut ::group,\n    ) -> ::c_int;\n    pub fn sigaltstack(ss: *const stack_t, oss: *mut stack_t) -> ::c_int;\n    pub fn sem_close(sem: *mut sem_t) -> ::c_int;\n    pub fn getdtablesize() -> ::c_int;\n    pub fn getgrnam_r(\n        name: *const ::c_char,\n        grp: *mut ::group,\n        buf: *mut ::c_char,\n        buflen: ::size_t,\n        result: *mut *mut ::group,\n    ) -> ::c_int;\n    pub fn pthread_sigmask(how: ::c_int, set: *const sigset_t, oldset: *mut sigset_t) -> ::c_int;\n    pub fn sem_open(name: *const ::c_char, oflag: ::c_int, ...) -> *mut sem_t;\n    pub fn getgrnam(name: *const ::c_char) -> *mut ::group;\n    pub fn pthread_kill(thread: ::pthread_t, sig: ::c_int) -> ::c_int;\n    pub fn sem_unlink(name: *const ::c_char) -> ::c_int;\n    pub fn daemon(nochdir: ::c_int, noclose: ::c_int) -> ::c_int;\n    pub fn getpwnam_r(\n        name: *const ::c_char,\n        pwd: *mut passwd,\n        buf: *mut ::c_char,\n        buflen: ::size_t,\n        result: *mut *mut passwd,\n    ) -> ::c_int;\n    pub fn getpwuid_r(\n        uid: ::uid_t,\n        pwd: *mut passwd,\n        buf: *mut ::c_char,\n        buflen: ::size_t,\n        result: *mut *mut passwd,\n    ) -> ::c_int;\n    pub fn sigwait(set: *const sigset_t, sig: *mut ::c_int) -> ::c_int;\n    pub fn pthread_atfork(\n        prepare: ::Option<unsafe extern \"C\" fn()>,\n        parent: ::Option<unsafe extern \"C\" fn()>,\n        child: ::Option<unsafe extern \"C\" fn()>,\n    ) -> ::c_int;\n    pub fn getgrgid(gid: ::gid_t) -> *mut ::group;\n    pub fn popen(command: *const c_char, mode: *const c_char) -> *mut ::FILE;\n    pub fn openpty(\n        amaster: *mut ::c_int,\n        aslave: *mut ::c_int,\n        name: *mut ::c_char,\n        termp: *mut termios,\n        winp: *mut ::winsize,\n    ) -> ::c_int;\n    pub fn forkpty(\n        amaster: *mut ::c_int,\n        name: *mut ::c_char,\n        termp: *mut termios,\n        winp: *mut ::winsize,\n    ) -> ::pid_t;\n    pub fn sethostname(name: *const ::c_char, len: ::size_t) -> ::c_int;\n    pub fn uname(buf: *mut ::utsname) -> ::c_int;\n}\n\ncfg_if! {\n    if #[cfg(target_pointer_width = \"64\")] {\n        mod b64;\n        pub use self::b64::*;\n    } else {\n        mod b32;\n        pub use self::b32::*;\n    }\n}\n\nmod native;\npub use self::native::*;\n"],["1135","// This module contains bindings to the native Haiku API. The Haiku API\n// originates from BeOS, and it was the original way to perform low level\n// system and IO operations. The POSIX API was in that era was like a\n// compatibility layer. In current Haiku development, both the POSIX API and\n// the Haiku API are considered to be co-equal status. However, they are not\n// integrated like they are on other UNIX platforms, which means that for many\n// low level concepts there are two versions, like processes (POSIX) and\n// teams (Haiku), or pthreads and native threads.\n//\n// Both the POSIX API and the Haiku API live in libroot.so, the library that is\n// linked to any binary by default.\n//\n// This file follows the Haiku API for Haiku R1 beta 2. It is organized by the\n// C/C++ header files in which the concepts can be found, while adhering to the\n// style guide for this crate.\n\n// Helper macro to generate u32 constants. The Haiku API uses (non-standard)\n// multi-character constants (like 'UPDA' or 'MSGM') to represent 32 bit\n// integer constants.\n\nmacro_rules! haiku_constant {\n    ($a:tt, $b:tt, $c:tt, $d:tt) => {\n        (($a as u32) << 24) + (($b as u32) << 16) + (($c as u32) << 8) + ($d as u32)\n    };\n}\n\n// support/SupportDefs.h\npub type status_t = i32;\npub type bigtime_t = i64;\npub type nanotime_t = i64;\npub type type_code = u32;\npub type perform_code = u32;\n\n// kernel/OS.h\npub type area_id = i32;\npub type port_id = i32;\npub type sem_id = i32;\npub type team_id = i32;\npub type thread_id = i32;\n\npub type thread_func = extern \"C\" fn(*mut ::c_void) -> status_t;\n\n// kernel/image.h\npub type image_id = i32;\n\ne! {\n    // kernel/OS.h\n    pub enum thread_state {\n        B_THREAD_RUNNING = 1,\n        B_THREAD_READY,\n        B_THREAD_RECEIVING,\n        B_THREAD_ASLEEP,\n        B_THREAD_SUSPENDED,\n        B_THREAD_WAITING\n    }\n\n    // kernel/image.h\n    pub enum image_type {\n        B_APP_IMAGE = 1,\n        B_LIBRARY_IMAGE,\n        B_ADD_ON_IMAGE,\n        B_SYSTEM_IMAGE\n    }\n\n    // kernel/scheduler.h\n    pub enum schduler_mode {\n        SCHEDULER_MODE_LOW_LATENCY,\n        SCHEDULER_MODE_POWER_SAVING,\n    }\n}\n\ns! {\n    // kernel/OS.h\n    pub struct area_info {\n        pub area: area_id,\n        pub name: [::c_char; B_OS_NAME_LENGTH],\n        pub size: usize,\n        pub lock: u32,\n        pub protection: u32,\n        pub team: team_id,\n        pub ram_size: u32,\n        pub copy_count: u32,\n        pub in_count: u32,\n        pub out_count: u32,\n        pub address: *mut ::c_void\n    }\n\n    pub struct port_info {\n        pub port: port_id,\n        pub team: team_id,\n        pub name: [::c_char; B_OS_NAME_LENGTH],\n        pub capacity: i32,\n        pub queue_count: i32,\n        pub total_count: i32,\n    }\n\n    pub struct port_message_info {\n        pub size: ::size_t,\n        pub sender: ::uid_t,\n        pub sender_group: ::gid_t,\n        pub sender_team: ::team_id\n    }\n\n    pub struct team_info {\n        pub team: team_id,\n        pub thread_count: i32,\n        pub image_count: i32,\n        pub area_count: i32,\n        pub debugger_nub_thread: thread_id,\n        pub debugger_nub_port: port_id,\n        pub argc: i32,\n        pub args: [::c_char; 64],\n        pub uid: ::uid_t,\n        pub gid: ::gid_t\n    }\n\n    pub struct sem_info {\n        pub sem: sem_id,\n        pub team: team_id,\n        pub name: [::c_char; B_OS_NAME_LENGTH],\n        pub count: i32,\n        pub latest_holder: thread_id\n    }\n\n    pub struct team_usage_info {\n        pub user_time: bigtime_t,\n        pub kernel_time: bigtime_t\n    }\n\n    pub struct thread_info {\n        pub thread: thread_id,\n        pub team: team_id,\n        pub name: [::c_char; B_OS_NAME_LENGTH],\n        pub state: thread_state,\n        pub priority: i32,\n        pub sem: sem_id,\n        pub user_time: bigtime_t,\n        pub kernel_time: bigtime_t,\n        pub stack_base: *mut ::c_void,\n        pub stack_end: *mut ::c_void\n    }\n\n    pub struct cpu_info {\n        pub active_time: bigtime_t,\n        pub enabled: bool\n    }\n\n    pub struct system_info {\n        pub boot_time: bigtime_t,\n        pub cpu_count: u32,\n        pub max_pages: u64,\n        pub used_pages: u64,\n        pub cached_pages: u64,\n        pub block_cache_pages: u64,\n        pub ignored_pages: u64,\n        pub needed_memory: u64,\n        pub free_memory: u64,\n        pub max_swap_pages: u64,\n        pub free_swap_pages: u64,\n        pub page_faults: u32,\n        pub max_sems: u32,\n        pub used_sems: u32,\n        pub max_ports: u32,\n        pub used_ports: u32,\n        pub max_threads: u32,\n        pub used_threads: u32,\n        pub max_teams: u32,\n        pub used_teams: u32,\n        pub kernel_name: [::c_char; B_FILE_NAME_LENGTH],\n        pub kernel_build_date: [::c_char; B_OS_NAME_LENGTH],\n        pub kernel_build_time: [::c_char; B_OS_NAME_LENGTH],\n        pub kernel_version: i64,\n        pub abi: u32\n    }\n\n    pub struct object_wait_info {\n        pub object: i32,\n        pub type_: u16,\n        pub events: u16\n    }\n\n    // kernel/fs_attr.h\n    pub struct attr_info {\n        pub type_: u32,\n        pub size: ::off_t\n    }\n\n    // kernel/fs_index.h\n    pub struct index_info {\n        pub type_: u32,\n        pub size: ::off_t,\n        pub modification_time: ::time_t,\n        pub creation_time: ::time_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t\n    }\n\n    //kernel/fs_info.h\n    pub struct fs_info {\n        pub dev: ::dev_t,\n        pub root: ::ino_t,\n        pub flags: u32,\n        pub block_size: ::off_t,\n        pub io_size: ::off_t,\n        pub total_blocks: ::off_t,\n        pub free_blocks: ::off_t,\n        pub total_nodes: ::off_t,\n        pub free_nodes: ::off_t,\n        pub device_name: [::c_char; 128],\n        pub volume_name: [::c_char; B_FILE_NAME_LENGTH],\n        pub fsh_name: [::c_char; B_OS_NAME_LENGTH]\n    }\n\n    // kernel/image.h\n    pub struct image_info {\n        pub id: image_id,\n        pub image_type: ::c_int,\n        pub sequence: i32,\n        pub init_order: i32,\n        pub init_routine: extern \"C\" fn(),\n        pub term_routine: extern \"C\" fn(),\n        pub device: ::dev_t,\n        pub node: ::ino_t,\n        pub name: [::c_char; ::PATH_MAX as usize],\n        pub text: *mut ::c_void,\n        pub data: *mut ::c_void,\n        pub text_size: i32,\n        pub data_size: i32,\n        pub api_version: i32,\n        pub abi: i32\n    }\n}\n\n// kernel/OS.h\npub const B_OS_NAME_LENGTH: usize = 32;\npub const B_PAGE_SIZE: usize = 4096;\npub const B_INFINITE_TIMEOUT: usize = 9223372036854775807;\n\npub const B_RELATIVE_TIMEOUT: u32 = 0x8;\npub const B_ABSOLUTE_TIMEOUT: u32 = 0x10;\npub const B_TIMEOUT_REAL_TIME_BASE: u32 = 0x40;\npub const B_ABSOLUTE_REAL_TIME_TIMEOUT: u32 = B_ABSOLUTE_TIMEOUT | B_TIMEOUT_REAL_TIME_BASE;\n\npub const B_NO_LOCK: u32 = 0;\npub const B_LAZY_LOCK: u32 = 1;\npub const B_FULL_LOCK: u32 = 2;\npub const B_CONTIGUOUS: u32 = 3;\npub const B_LOMEM: u32 = 4;\npub const B_32_BIT_FULL_LOCK: u32 = 5;\npub const B_32_BIT_CONTIGUOUS: u32 = 6;\n\npub const B_ANY_ADDRESS: u32 = 0;\npub const B_EXACT_ADDRESS: u32 = 1;\npub const B_BASE_ADDRESS: u32 = 2;\npub const B_CLONE_ADDRESS: u32 = 3;\npub const B_ANY_KERNEL_ADDRESS: u32 = 4;\npub const B_RANDOMIZED_ANY_ADDRESS: u32 = 6;\npub const B_RANDOMIZED_BASE_ADDRESS: u32 = 7;\n\npub const B_READ_AREA: u32 = 1 << 0;\npub const B_WRITE_AREA: u32 = 1 << 1;\npub const B_EXECUTE_AREA: u32 = 1 << 2;\npub const B_STACK_AREA: u32 = 1 << 3;\npub const B_CLONEABLE_AREA: u32 = 1 << 8;\n\npub const B_CAN_INTERRUPT: u32 = 0x01;\npub const B_CHECK_PERMISSION: u32 = 0x04;\npub const B_KILL_CAN_INTERRUPT: u32 = 0x20;\npub const B_DO_NOT_RESCHEDULE: u32 = 0x02;\npub const B_RELEASE_ALL: u32 = 0x08;\npub const B_RELEASE_IF_WAITING_ONLY: u32 = 0x10;\n\npub const B_CURRENT_TEAM: team_id = 0;\npub const B_SYSTEM_TEAM: team_id = 1;\n\npub const B_TEAM_USAGE_SELF: i32 = 0;\npub const B_TEAM_USAGE_CHILDREN: i32 = -1;\n\npub const B_IDLE_PRIORITY: i32 = 0;\npub const B_LOWEST_ACTIVE_PRIORITY: i32 = 1;\npub const B_LOW_PRIORITY: i32 = 5;\npub const B_NORMAL_PRIORITY: i32 = 10;\npub const B_DISPLAY_PRIORITY: i32 = 15;\npub const B_URGENT_DISPLAY_PRIORITY: i32 = 20;\npub const B_REAL_TIME_DISPLAY_PRIORITY: i32 = 100;\npub const B_URGENT_PRIORITY: i32 = 110;\npub const B_REAL_TIME_PRIORITY: i32 = 120;\n\npub const B_SYSTEM_TIMEBASE: i32 = 0;\npub const B_FIRST_REAL_TIME_PRIORITY: i32 = B_REAL_TIME_DISPLAY_PRIORITY;\n\npub const B_ONE_SHOT_ABSOLUTE_ALARM: u32 = 1;\npub const B_ONE_SHOT_RELATIVE_ALARM: u32 = 2;\npub const B_PERIODIC_ALARM: u32 = 3;\n\npub const B_OBJECT_TYPE_FD: u16 = 0;\npub const B_OBJECT_TYPE_SEMAPHORE: u16 = 1;\npub const B_OBJECT_TYPE_PORT: u16 = 2;\npub const B_OBJECT_TYPE_THREAD: u16 = 3;\n\npub const B_EVENT_READ: u16 = 0x0001;\npub const B_EVENT_WRITE: u16 = 0x0002;\npub const B_EVENT_ERROR: u16 = 0x0004;\npub const B_EVENT_PRIORITY_READ: u16 = 0x0008;\npub const B_EVENT_PRIORITY_WRITE: u16 = 0x0010;\npub const B_EVENT_HIGH_PRIORITY_READ: u16 = 0x0020;\npub const B_EVENT_HIGH_PRIORITY_WRITE: u16 = 0x0040;\npub const B_EVENT_DISCONNECTED: u16 = 0x0080;\npub const B_EVENT_ACQUIRE_SEMAPHORE: u16 = 0x0001;\npub const B_EVENT_INVALID: u16 = 0x1000;\n\n// kernel/fs_info.h\npub const B_FS_IS_READONLY: u32 = 0x00000001;\npub const B_FS_IS_REMOVABLE: u32 = 0x00000002;\npub const B_FS_IS_PERSISTENT: u32 = 0x00000004;\npub const B_FS_IS_SHARED: u32 = 0x00000008;\npub const B_FS_HAS_MIME: u32 = 0x00010000;\npub const B_FS_HAS_ATTR: u32 = 0x00020000;\npub const B_FS_HAS_QUERY: u32 = 0x00040000;\npub const B_FS_HAS_SELF_HEALING_LINKS: u32 = 0x00080000;\npub const B_FS_HAS_ALIASES: u32 = 0x00100000;\npub const B_FS_SUPPORTS_NODE_MONITORING: u32 = 0x00200000;\npub const B_FS_SUPPORTS_MONITOR_CHILDREN: u32 = 0x00400000;\n\n// kernel/fs_query.h\npub const B_LIVE_QUERY: u32 = 0x00000001;\npub const B_QUERY_NON_INDEXED: u32 = 0x00000002;\n\n// kernel/fs_volume.h\npub const B_MOUNT_READ_ONLY: u32 = 1;\npub const B_MOUNT_VIRTUAL_DEVICE: u32 = 2;\npub const B_FORCE_UNMOUNT: u32 = 1;\n\n// kernel/image.h\npub const B_FLUSH_DCACHE: u32 = 0x0001;\npub const B_FLUSH_ICACHE: u32 = 0x0004;\npub const B_INVALIDATE_DCACHE: u32 = 0x0002;\npub const B_INVALIDATE_ICACHE: u32 = 0x0008;\n\npub const B_SYMBOL_TYPE_DATA: i32 = 0x1;\npub const B_SYMBOL_TYPE_TEXT: i32 = 0x2;\npub const B_SYMBOL_TYPE_ANY: i32 = 0x5;\n\n// storage/StorageDefs.h\npub const B_DEV_NAME_LENGTH: usize = 128;\npub const B_FILE_NAME_LENGTH: usize = ::FILENAME_MAX as usize;\npub const B_PATH_NAME_LENGTH: usize = ::PATH_MAX as usize;\npub const B_ATTR_NAME_LENGTH: usize = B_FILE_NAME_LENGTH - 1;\npub const B_MIME_TYPE_LENGTH: usize = B_ATTR_NAME_LENGTH - 15;\npub const B_MAX_SYMLINKS: usize = 16;\n\n// Haiku open modes in BFile are passed as u32\npub const B_READ_ONLY: u32 = ::O_RDONLY as u32;\npub const B_WRITE_ONLY: u32 = ::O_WRONLY as u32;\npub const B_READ_WRITE: u32 = ::O_RDWR as u32;\n\npub const B_FAIL_IF_EXISTS: u32 = ::O_EXCL as u32;\npub const B_CREATE_FILE: u32 = ::O_CREAT as u32;\npub const B_ERASE_FILE: u32 = ::O_TRUNC as u32;\npub const B_OPEN_AT_END: u32 = ::O_APPEND as u32;\n\npub const B_FILE_NODE: u32 = 0x01;\npub const B_SYMLINK_NODE: u32 = 0x02;\npub const B_DIRECTORY_NODE: u32 = 0x04;\npub const B_ANY_NODE: u32 = 0x07;\n\n// support/Errors.h\npub const B_GENERAL_ERROR_BASE: status_t = core::i32::MIN;\npub const B_OS_ERROR_BASE: status_t = B_GENERAL_ERROR_BASE + 0x1000;\npub const B_APP_ERROR_BASE: status_t = B_GENERAL_ERROR_BASE + 0x2000;\npub const B_INTERFACE_ERROR_BASE: status_t = B_GENERAL_ERROR_BASE + 0x3000;\npub const B_MEDIA_ERROR_BASE: status_t = B_GENERAL_ERROR_BASE + 0x4000;\npub const B_TRANSLATION_ERROR_BASE: status_t = B_GENERAL_ERROR_BASE + 0x4800;\npub const B_MIDI_ERROR_BASE: status_t = B_GENERAL_ERROR_BASE + 0x5000;\npub const B_STORAGE_ERROR_BASE: status_t = B_GENERAL_ERROR_BASE + 0x6000;\npub const B_POSIX_ERROR_BASE: status_t = B_GENERAL_ERROR_BASE + 0x7000;\npub const B_MAIL_ERROR_BASE: status_t = B_GENERAL_ERROR_BASE + 0x8000;\npub const B_PRINT_ERROR_BASE: status_t = B_GENERAL_ERROR_BASE + 0x9000;\npub const B_DEVICE_ERROR_BASE: status_t = B_GENERAL_ERROR_BASE + 0xa000;\npub const B_ERRORS_END: status_t = B_GENERAL_ERROR_BASE + 0xffff;\n\n// General errors\npub const B_NO_MEMORY: status_t = B_GENERAL_ERROR_BASE + 0;\npub const B_IO_ERROR: status_t = B_GENERAL_ERROR_BASE + 1;\npub const B_PERMISSION_DENIED: status_t = B_GENERAL_ERROR_BASE + 2;\npub const B_BAD_INDEX: status_t = B_GENERAL_ERROR_BASE + 3;\npub const B_BAD_TYPE: status_t = B_GENERAL_ERROR_BASE + 4;\npub const B_BAD_VALUE: status_t = B_GENERAL_ERROR_BASE + 5;\npub const B_MISMATCHED_VALUES: status_t = B_GENERAL_ERROR_BASE + 6;\npub const B_NAME_NOT_FOUND: status_t = B_GENERAL_ERROR_BASE + 7;\npub const B_NAME_IN_USE: status_t = B_GENERAL_ERROR_BASE + 8;\npub const B_TIMED_OUT: status_t = B_GENERAL_ERROR_BASE + 9;\npub const B_INTERRUPTED: status_t = B_GENERAL_ERROR_BASE + 10;\npub const B_WOULD_BLOCK: status_t = B_GENERAL_ERROR_BASE + 11;\npub const B_CANCELED: status_t = B_GENERAL_ERROR_BASE + 12;\npub const B_NO_INIT: status_t = B_GENERAL_ERROR_BASE + 13;\npub const B_NOT_INITIALIZED: status_t = B_GENERAL_ERROR_BASE + 13;\npub const B_BUSY: status_t = B_GENERAL_ERROR_BASE + 14;\npub const B_NOT_ALLOWED: status_t = B_GENERAL_ERROR_BASE + 15;\npub const B_BAD_DATA: status_t = B_GENERAL_ERROR_BASE + 16;\npub const B_DONT_DO_THAT: status_t = B_GENERAL_ERROR_BASE + 17;\n\npub const B_ERROR: status_t = -1;\npub const B_OK: status_t = 0;\npub const B_NO_ERROR: status_t = 0;\n\n// Kernel kit errors\npub const B_BAD_SEM_ID: status_t = B_OS_ERROR_BASE + 0;\npub const B_NO_MORE_SEMS: status_t = B_OS_ERROR_BASE + 1;\n\npub const B_BAD_THREAD_ID: status_t = B_OS_ERROR_BASE + 0x100;\npub const B_NO_MORE_THREADS: status_t = B_OS_ERROR_BASE + 0x101;\npub const B_BAD_THREAD_STATE: status_t = B_OS_ERROR_BASE + 0x102;\npub const B_BAD_TEAM_ID: status_t = B_OS_ERROR_BASE + 0x103;\npub const B_NO_MORE_TEAMS: status_t = B_OS_ERROR_BASE + 0x104;\n\npub const B_BAD_PORT_ID: status_t = B_OS_ERROR_BASE + 0x200;\npub const B_NO_MORE_PORTS: status_t = B_OS_ERROR_BASE + 0x201;\n\npub const B_BAD_IMAGE_ID: status_t = B_OS_ERROR_BASE + 0x300;\npub const B_BAD_ADDRESS: status_t = B_OS_ERROR_BASE + 0x301;\npub const B_NOT_AN_EXECUTABLE: status_t = B_OS_ERROR_BASE + 0x302;\npub const B_MISSING_LIBRARY: status_t = B_OS_ERROR_BASE + 0x303;\npub const B_MISSING_SYMBOL: status_t = B_OS_ERROR_BASE + 0x304;\npub const B_UNKNOWN_EXECUTABLE: status_t = B_OS_ERROR_BASE + 0x305;\npub const B_LEGACY_EXECUTABLE: status_t = B_OS_ERROR_BASE + 0x306;\n\npub const B_DEBUGGER_ALREADY_INSTALLED: status_t = B_OS_ERROR_BASE + 0x400;\n\n// Application kit errors\npub const B_BAD_REPLY: status_t = B_APP_ERROR_BASE + 0;\npub const B_DUPLICATE_REPLY: status_t = B_APP_ERROR_BASE + 1;\npub const B_MESSAGE_TO_SELF: status_t = B_APP_ERROR_BASE + 2;\npub const B_BAD_HANDLER: status_t = B_APP_ERROR_BASE + 3;\npub const B_ALREADY_RUNNING: status_t = B_APP_ERROR_BASE + 4;\npub const B_LAUNCH_FAILED: status_t = B_APP_ERROR_BASE + 5;\npub const B_AMBIGUOUS_APP_LAUNCH: status_t = B_APP_ERROR_BASE + 6;\npub const B_UNKNOWN_MIME_TYPE: status_t = B_APP_ERROR_BASE + 7;\npub const B_BAD_SCRIPT_SYNTAX: status_t = B_APP_ERROR_BASE + 8;\npub const B_LAUNCH_FAILED_NO_RESOLVE_LINK: status_t = B_APP_ERROR_BASE + 9;\npub const B_LAUNCH_FAILED_EXECUTABLE: status_t = B_APP_ERROR_BASE + 10;\npub const B_LAUNCH_FAILED_APP_NOT_FOUND: status_t = B_APP_ERROR_BASE + 11;\npub const B_LAUNCH_FAILED_APP_IN_TRASH: status_t = B_APP_ERROR_BASE + 12;\npub const B_LAUNCH_FAILED_NO_PREFERRED_APP: status_t = B_APP_ERROR_BASE + 13;\npub const B_LAUNCH_FAILED_FILES_APP_NOT_FOUND: status_t = B_APP_ERROR_BASE + 14;\npub const B_BAD_MIME_SNIFFER_RULE: status_t = B_APP_ERROR_BASE + 15;\npub const B_NOT_A_MESSAGE: status_t = B_APP_ERROR_BASE + 16;\npub const B_SHUTDOWN_CANCELLED: status_t = B_APP_ERROR_BASE + 17;\npub const B_SHUTTING_DOWN: status_t = B_APP_ERROR_BASE + 18;\n\n// Storage kit errors\npub const B_FILE_ERROR: status_t = B_STORAGE_ERROR_BASE + 0;\npub const B_FILE_NOT_FOUND: status_t = B_STORAGE_ERROR_BASE + 1;\npub const B_FILE_EXISTS: status_t = B_STORAGE_ERROR_BASE + 2;\npub const B_ENTRY_NOT_FOUND: status_t = B_STORAGE_ERROR_BASE + 3;\npub const B_NAME_TOO_LONG: status_t = B_STORAGE_ERROR_BASE + 4;\npub const B_NOT_A_DIRECTORY: status_t = B_STORAGE_ERROR_BASE + 5;\npub const B_DIRECTORY_NOT_EMPTY: status_t = B_STORAGE_ERROR_BASE + 6;\npub const B_DEVICE_FULL: status_t = B_STORAGE_ERROR_BASE + 7;\npub const B_READ_ONLY_DEVICE: status_t = B_STORAGE_ERROR_BASE + 8;\npub const B_IS_A_DIRECTORY: status_t = B_STORAGE_ERROR_BASE + 9;\npub const B_NO_MORE_FDS: status_t = B_STORAGE_ERROR_BASE + 10;\npub const B_CROSS_DEVICE_LINK: status_t = B_STORAGE_ERROR_BASE + 11;\npub const B_LINK_LIMIT: status_t = B_STORAGE_ERROR_BASE + 12;\npub const B_BUSTED_PIPE: status_t = B_STORAGE_ERROR_BASE + 13;\npub const B_UNSUPPORTED: status_t = B_STORAGE_ERROR_BASE + 14;\npub const B_PARTITION_TOO_SMALL: status_t = B_STORAGE_ERROR_BASE + 15;\npub const B_PARTIAL_READ: status_t = B_STORAGE_ERROR_BASE + 16;\npub const B_PARTIAL_WRITE: status_t = B_STORAGE_ERROR_BASE + 17;\n\n// Mapped posix errors\npub const B_BUFFER_OVERFLOW: status_t = ::EOVERFLOW;\npub const B_TOO_MANY_ARGS: status_t = ::E2BIG;\npub const B_FILE_TOO_LARGE: status_t = ::EFBIG;\npub const B_RESULT_NOT_REPRESENTABLE: status_t = ::ERANGE;\npub const B_DEVICE_NOT_FOUND: status_t = ::ENODEV;\npub const B_NOT_SUPPORTED: status_t = ::EOPNOTSUPP;\n\n// Media kit errors\npub const B_STREAM_NOT_FOUND: status_t = B_MEDIA_ERROR_BASE + 0;\npub const B_SERVER_NOT_FOUND: status_t = B_MEDIA_ERROR_BASE + 1;\npub const B_RESOURCE_NOT_FOUND: status_t = B_MEDIA_ERROR_BASE + 2;\npub const B_RESOURCE_UNAVAILABLE: status_t = B_MEDIA_ERROR_BASE + 3;\npub const B_BAD_SUBSCRIBER: status_t = B_MEDIA_ERROR_BASE + 4;\npub const B_SUBSCRIBER_NOT_ENTERED: status_t = B_MEDIA_ERROR_BASE + 5;\npub const B_BUFFER_NOT_AVAILABLE: status_t = B_MEDIA_ERROR_BASE + 6;\npub const B_LAST_BUFFER_ERROR: status_t = B_MEDIA_ERROR_BASE + 7;\n\npub const B_MEDIA_SYSTEM_FAILURE: status_t = B_MEDIA_ERROR_BASE + 100;\npub const B_MEDIA_BAD_NODE: status_t = B_MEDIA_ERROR_BASE + 101;\npub const B_MEDIA_NODE_BUSY: status_t = B_MEDIA_ERROR_BASE + 102;\npub const B_MEDIA_BAD_FORMAT: status_t = B_MEDIA_ERROR_BASE + 103;\npub const B_MEDIA_BAD_BUFFER: status_t = B_MEDIA_ERROR_BASE + 104;\npub const B_MEDIA_TOO_MANY_NODES: status_t = B_MEDIA_ERROR_BASE + 105;\npub const B_MEDIA_TOO_MANY_BUFFERS: status_t = B_MEDIA_ERROR_BASE + 106;\npub const B_MEDIA_NODE_ALREADY_EXISTS: status_t = B_MEDIA_ERROR_BASE + 107;\npub const B_MEDIA_BUFFER_ALREADY_EXISTS: status_t = B_MEDIA_ERROR_BASE + 108;\npub const B_MEDIA_CANNOT_SEEK: status_t = B_MEDIA_ERROR_BASE + 109;\npub const B_MEDIA_CANNOT_CHANGE_RUN_MODE: status_t = B_MEDIA_ERROR_BASE + 110;\npub const B_MEDIA_APP_ALREADY_REGISTERED: status_t = B_MEDIA_ERROR_BASE + 111;\npub const B_MEDIA_APP_NOT_REGISTERED: status_t = B_MEDIA_ERROR_BASE + 112;\npub const B_MEDIA_CANNOT_RECLAIM_BUFFERS: status_t = B_MEDIA_ERROR_BASE + 113;\npub const B_MEDIA_BUFFERS_NOT_RECLAIMED: status_t = B_MEDIA_ERROR_BASE + 114;\npub const B_MEDIA_TIME_SOURCE_STOPPED: status_t = B_MEDIA_ERROR_BASE + 115;\npub const B_MEDIA_TIME_SOURCE_BUSY: status_t = B_MEDIA_ERROR_BASE + 116;\npub const B_MEDIA_BAD_SOURCE: status_t = B_MEDIA_ERROR_BASE + 117;\npub const B_MEDIA_BAD_DESTINATION: status_t = B_MEDIA_ERROR_BASE + 118;\npub const B_MEDIA_ALREADY_CONNECTED: status_t = B_MEDIA_ERROR_BASE + 119;\npub const B_MEDIA_NOT_CONNECTED: status_t = B_MEDIA_ERROR_BASE + 120;\npub const B_MEDIA_BAD_CLIP_FORMAT: status_t = B_MEDIA_ERROR_BASE + 121;\npub const B_MEDIA_ADDON_FAILED: status_t = B_MEDIA_ERROR_BASE + 122;\npub const B_MEDIA_ADDON_DISABLED: status_t = B_MEDIA_ERROR_BASE + 123;\npub const B_MEDIA_CHANGE_IN_PROGRESS: status_t = B_MEDIA_ERROR_BASE + 124;\npub const B_MEDIA_STALE_CHANGE_COUNT: status_t = B_MEDIA_ERROR_BASE + 125;\npub const B_MEDIA_ADDON_RESTRICTED: status_t = B_MEDIA_ERROR_BASE + 126;\npub const B_MEDIA_NO_HANDLER: status_t = B_MEDIA_ERROR_BASE + 127;\npub const B_MEDIA_DUPLICATE_FORMAT: status_t = B_MEDIA_ERROR_BASE + 128;\npub const B_MEDIA_REALTIME_DISABLED: status_t = B_MEDIA_ERROR_BASE + 129;\npub const B_MEDIA_REALTIME_UNAVAILABLE: status_t = B_MEDIA_ERROR_BASE + 130;\n\n// Mail kit errors\npub const B_MAIL_NO_DAEMON: status_t = B_MAIL_ERROR_BASE + 0;\npub const B_MAIL_UNKNOWN_USER: status_t = B_MAIL_ERROR_BASE + 1;\npub const B_MAIL_WRONG_PASSWORD: status_t = B_MAIL_ERROR_BASE + 2;\npub const B_MAIL_UNKNOWN_HOST: status_t = B_MAIL_ERROR_BASE + 3;\npub const B_MAIL_ACCESS_ERROR: status_t = B_MAIL_ERROR_BASE + 4;\npub const B_MAIL_UNKNOWN_FIELD: status_t = B_MAIL_ERROR_BASE + 5;\npub const B_MAIL_NO_RECIPIENT: status_t = B_MAIL_ERROR_BASE + 6;\npub const B_MAIL_INVALID_MAIL: status_t = B_MAIL_ERROR_BASE + 7;\n\n// Print kit errors\npub const B_NO_PRINT_SERVER: status_t = B_PRINT_ERROR_BASE + 0;\n\n// Device kit errors\npub const B_DEV_INVALID_IOCTL: status_t = B_DEVICE_ERROR_BASE + 0;\npub const B_DEV_NO_MEMORY: status_t = B_DEVICE_ERROR_BASE + 1;\npub const B_DEV_BAD_DRIVE_NUM: status_t = B_DEVICE_ERROR_BASE + 2;\npub const B_DEV_NO_MEDIA: status_t = B_DEVICE_ERROR_BASE + 3;\npub const B_DEV_UNREADABLE: status_t = B_DEVICE_ERROR_BASE + 4;\npub const B_DEV_FORMAT_ERROR: status_t = B_DEVICE_ERROR_BASE + 5;\npub const B_DEV_TIMEOUT: status_t = B_DEVICE_ERROR_BASE + 6;\npub const B_DEV_RECALIBRATE_ERROR: status_t = B_DEVICE_ERROR_BASE + 7;\npub const B_DEV_SEEK_ERROR: status_t = B_DEVICE_ERROR_BASE + 8;\npub const B_DEV_ID_ERROR: status_t = B_DEVICE_ERROR_BASE + 9;\npub const B_DEV_READ_ERROR: status_t = B_DEVICE_ERROR_BASE + 10;\npub const B_DEV_WRITE_ERROR: status_t = B_DEVICE_ERROR_BASE + 11;\npub const B_DEV_NOT_READY: status_t = B_DEVICE_ERROR_BASE + 12;\npub const B_DEV_MEDIA_CHANGED: status_t = B_DEVICE_ERROR_BASE + 13;\npub const B_DEV_MEDIA_CHANGE_REQUESTED: status_t = B_DEVICE_ERROR_BASE + 14;\npub const B_DEV_RESOURCE_CONFLICT: status_t = B_DEVICE_ERROR_BASE + 15;\npub const B_DEV_CONFIGURATION_ERROR: status_t = B_DEVICE_ERROR_BASE + 16;\npub const B_DEV_DISABLED_BY_USER: status_t = B_DEVICE_ERROR_BASE + 17;\npub const B_DEV_DOOR_OPEN: status_t = B_DEVICE_ERROR_BASE + 18;\n\npub const B_DEV_INVALID_PIPE: status_t = B_DEVICE_ERROR_BASE + 19;\npub const B_DEV_CRC_ERROR: status_t = B_DEVICE_ERROR_BASE + 20;\npub const B_DEV_STALLED: status_t = B_DEVICE_ERROR_BASE + 21;\npub const B_DEV_BAD_PID: status_t = B_DEVICE_ERROR_BASE + 22;\npub const B_DEV_UNEXPECTED_PID: status_t = B_DEVICE_ERROR_BASE + 23;\npub const B_DEV_DATA_OVERRUN: status_t = B_DEVICE_ERROR_BASE + 24;\npub const B_DEV_DATA_UNDERRUN: status_t = B_DEVICE_ERROR_BASE + 25;\npub const B_DEV_FIFO_OVERRUN: status_t = B_DEVICE_ERROR_BASE + 26;\npub const B_DEV_FIFO_UNDERRUN: status_t = B_DEVICE_ERROR_BASE + 27;\npub const B_DEV_PENDING: status_t = B_DEVICE_ERROR_BASE + 28;\npub const B_DEV_MULTIPLE_ERRORS: status_t = B_DEVICE_ERROR_BASE + 29;\npub const B_DEV_TOO_LATE: status_t = B_DEVICE_ERROR_BASE + 30;\n\n// translation kit errors\npub const B_TRANSLATION_BASE_ERROR: status_t = B_TRANSLATION_ERROR_BASE + 0;\npub const B_NO_TRANSLATOR: status_t = B_TRANSLATION_ERROR_BASE + 1;\npub const B_ILLEGAL_DATA: status_t = B_TRANSLATION_ERROR_BASE + 2;\n\n// support/TypeConstants.h\npub const B_AFFINE_TRANSFORM_TYPE: u32 = haiku_constant!('A', 'M', 'T', 'X');\npub const B_ALIGNMENT_TYPE: u32 = haiku_constant!('A', 'L', 'G', 'N');\npub const B_ANY_TYPE: u32 = haiku_constant!('A', 'N', 'Y', 'T');\npub const B_ATOM_TYPE: u32 = haiku_constant!('A', 'T', 'O', 'M');\npub const B_ATOMREF_TYPE: u32 = haiku_constant!('A', 'T', 'M', 'R');\npub const B_BOOL_TYPE: u32 = haiku_constant!('B', 'O', 'O', 'L');\npub const B_CHAR_TYPE: u32 = haiku_constant!('C', 'H', 'A', 'R');\npub const B_COLOR_8_BIT_TYPE: u32 = haiku_constant!('C', 'L', 'R', 'B');\npub const B_DOUBLE_TYPE: u32 = haiku_constant!('D', 'B', 'L', 'E');\npub const B_FLOAT_TYPE: u32 = haiku_constant!('F', 'L', 'O', 'T');\npub const B_GRAYSCALE_8_BIT_TYPE: u32 = haiku_constant!('G', 'R', 'Y', 'B');\npub const B_INT16_TYPE: u32 = haiku_constant!('S', 'H', 'R', 'T');\npub const B_INT32_TYPE: u32 = haiku_constant!('L', 'O', 'N', 'G');\npub const B_INT64_TYPE: u32 = haiku_constant!('L', 'L', 'N', 'G');\npub const B_INT8_TYPE: u32 = haiku_constant!('B', 'Y', 'T', 'E');\npub const B_LARGE_ICON_TYPE: u32 = haiku_constant!('I', 'C', 'O', 'N');\npub const B_MEDIA_PARAMETER_GROUP_TYPE: u32 = haiku_constant!('B', 'M', 'C', 'G');\npub const B_MEDIA_PARAMETER_TYPE: u32 = haiku_constant!('B', 'M', 'C', 'T');\npub const B_MEDIA_PARAMETER_WEB_TYPE: u32 = haiku_constant!('B', 'M', 'C', 'W');\npub const B_MESSAGE_TYPE: u32 = haiku_constant!('M', 'S', 'G', 'G');\npub const B_MESSENGER_TYPE: u32 = haiku_constant!('M', 'S', 'N', 'G');\npub const B_MIME_TYPE: u32 = haiku_constant!('M', 'I', 'M', 'E');\npub const B_MINI_ICON_TYPE: u32 = haiku_constant!('M', 'I', 'C', 'N');\npub const B_MONOCHROME_1_BIT_TYPE: u32 = haiku_constant!('M', 'N', 'O', 'B');\npub const B_OBJECT_TYPE: u32 = haiku_constant!('O', 'P', 'T', 'R');\npub const B_OFF_T_TYPE: u32 = haiku_constant!('O', 'F', 'F', 'T');\npub const B_PATTERN_TYPE: u32 = haiku_constant!('P', 'A', 'T', 'N');\npub const B_POINTER_TYPE: u32 = haiku_constant!('P', 'N', 'T', 'R');\npub const B_POINT_TYPE: u32 = haiku_constant!('B', 'P', 'N', 'T');\npub const B_PROPERTY_INFO_TYPE: u32 = haiku_constant!('S', 'C', 'T', 'D');\npub const B_RAW_TYPE: u32 = haiku_constant!('R', 'A', 'W', 'T');\npub const B_RECT_TYPE: u32 = haiku_constant!('R', 'E', 'C', 'T');\npub const B_REF_TYPE: u32 = haiku_constant!('R', 'R', 'E', 'F');\npub const B_RGB_32_BIT_TYPE: u32 = haiku_constant!('R', 'G', 'B', 'B');\npub const B_RGB_COLOR_TYPE: u32 = haiku_constant!('R', 'G', 'B', 'C');\npub const B_SIZE_TYPE: u32 = haiku_constant!('S', 'I', 'Z', 'E');\npub const B_SIZE_T_TYPE: u32 = haiku_constant!('S', 'I', 'Z', 'T');\npub const B_SSIZE_T_TYPE: u32 = haiku_constant!('S', 'S', 'Z', 'T');\npub const B_STRING_TYPE: u32 = haiku_constant!('C', 'S', 'T', 'R');\npub const B_STRING_LIST_TYPE: u32 = haiku_constant!('S', 'T', 'R', 'L');\npub const B_TIME_TYPE: u32 = haiku_constant!('T', 'I', 'M', 'E');\npub const B_UINT16_TYPE: u32 = haiku_constant!('U', 'S', 'H', 'T');\npub const B_UINT32_TYPE: u32 = haiku_constant!('U', 'L', 'N', 'G');\npub const B_UINT64_TYPE: u32 = haiku_constant!('U', 'L', 'L', 'G');\npub const B_UINT8_TYPE: u32 = haiku_constant!('U', 'B', 'Y', 'T');\npub const B_VECTOR_ICON_TYPE: u32 = haiku_constant!('V', 'I', 'C', 'N');\npub const B_XATTR_TYPE: u32 = haiku_constant!('X', 'A', 'T', 'R');\npub const B_NETWORK_ADDRESS_TYPE: u32 = haiku_constant!('N', 'W', 'A', 'D');\npub const B_MIME_STRING_TYPE: u32 = haiku_constant!('M', 'I', 'M', 'S');\npub const B_ASCII_TYPE: u32 = haiku_constant!('T', 'E', 'X', 'T');\n\nextern \"C\" {\n    // kernel/OS.h\n    pub fn create_area(\n        name: *const ::c_char,\n        startAddress: *mut *mut ::c_void,\n        addressSpec: u32,\n        size: usize,\n        lock: u32,\n        protection: u32,\n    ) -> area_id;\n    pub fn clone_area(\n        name: *const ::c_char,\n        destAddress: *mut *mut ::c_void,\n        addressSpec: u32,\n        protection: u32,\n        source: area_id,\n    ) -> area_id;\n    pub fn find_area(name: *const ::c_char) -> area_id;\n    pub fn area_for(address: *mut ::c_void) -> area_id;\n    pub fn delete_area(id: area_id) -> status_t;\n    pub fn resize_area(id: area_id, newSize: usize) -> status_t;\n    pub fn set_area_protection(id: area_id, newProtection: u32) -> status_t;\n    pub fn _get_area_info(id: area_id, areaInfo: *mut area_info, size: usize) -> status_t;\n    pub fn _get_next_area_info(\n        team: team_id,\n        cookie: *mut isize,\n        areaInfo: *mut area_info,\n        size: usize,\n    ) -> status_t;\n\n    pub fn create_port(capacity: i32, name: *const ::c_char) -> port_id;\n    pub fn find_port(name: *const ::c_char) -> port_id;\n    pub fn read_port(\n        port: port_id,\n        code: *mut i32,\n        buffer: *mut ::c_void,\n        bufferSize: ::size_t,\n    ) -> ::ssize_t;\n    pub fn read_port_etc(\n        port: port_id,\n        code: *mut i32,\n        buffer: *mut ::c_void,\n        bufferSize: ::size_t,\n        flags: u32,\n        timeout: bigtime_t,\n    ) -> ::ssize_t;\n    pub fn write_port(\n        port: port_id,\n        code: i32,\n        buffer: *const ::c_void,\n        bufferSize: ::size_t,\n    ) -> status_t;\n    pub fn write_port_etc(\n        port: port_id,\n        code: i32,\n        buffer: *const ::c_void,\n        bufferSize: ::size_t,\n        flags: u32,\n        timeout: bigtime_t,\n    ) -> status_t;\n    pub fn close_port(port: port_id) -> status_t;\n    pub fn delete_port(port: port_id) -> status_t;\n    pub fn port_buffer_size(port: port_id) -> ::ssize_t;\n    pub fn port_buffer_size_etc(port: port_id, flags: u32, timeout: bigtime_t) -> ::ssize_t;\n    pub fn port_count(port: port_id) -> ::ssize_t;\n    pub fn set_port_owner(port: port_id, team: team_id) -> status_t;\n\n    pub fn _get_port_info(port: port_id, buf: *mut port_info, portInfoSize: ::size_t) -> status_t;\n    pub fn _get_next_port_info(\n        port: port_id,\n        cookie: *mut i32,\n        portInfo: *mut port_info,\n        portInfoSize: ::size_t,\n    ) -> status_t;\n    pub fn _get_port_message_info_etc(\n        port: port_id,\n        info: *mut port_message_info,\n        infoSize: ::size_t,\n        flags: u32,\n        timeout: bigtime_t,\n    ) -> status_t;\n\n    pub fn create_sem(count: i32, name: *const ::c_char) -> sem_id;\n    pub fn delete_sem(id: sem_id) -> status_t;\n    pub fn acquire_sem(id: sem_id) -> status_t;\n    pub fn acquire_sem_etc(id: sem_id, count: i32, flags: u32, timeout: bigtime_t) -> status_t;\n    pub fn release_sem(id: sem_id) -> status_t;\n    pub fn release_sem_etc(id: sem_id, count: i32, flags: u32) -> status_t;\n    pub fn switch_sem(semToBeReleased: sem_id, id: sem_id) -> status_t;\n    pub fn switch_sem_etc(\n        semToBeReleased: sem_id,\n        id: sem_id,\n        count: i32,\n        flags: u32,\n        timeout: bigtime_t,\n    ) -> status_t;\n    pub fn get_sem_count(id: sem_id, threadCount: *mut i32) -> status_t;\n    pub fn set_sem_owner(id: sem_id, team: team_id) -> status_t;\n    pub fn _get_sem_info(id: sem_id, info: *mut sem_info, infoSize: ::size_t) -> status_t;\n    pub fn _get_next_sem_info(\n        team: team_id,\n        cookie: *mut i32,\n        info: *mut sem_info,\n        infoSize: ::size_t,\n    ) -> status_t;\n\n    pub fn kill_team(team: team_id) -> status_t;\n    pub fn _get_team_info(team: team_id, info: *mut team_info, size: ::size_t) -> status_t;\n    pub fn _get_next_team_info(cookie: *mut i32, info: *mut team_info, size: ::size_t) -> status_t;\n\n    pub fn spawn_thread(\n        func: thread_func,\n        name: *const ::c_char,\n        priority: i32,\n        data: *mut ::c_void,\n    ) -> thread_id;\n    pub fn kill_thread(thread: thread_id) -> status_t;\n    pub fn resume_thread(thread: thread_id) -> status_t;\n    pub fn suspend_thread(thread: thread_id) -> status_t;\n\n    pub fn rename_thread(thread: thread_id, newName: *const ::c_char) -> status_t;\n    pub fn set_thread_priority(thread: thread_id, newPriority: i32) -> status_t;\n    pub fn exit_thread(status: status_t);\n    pub fn wait_for_thread(thread: thread_id, returnValue: *mut status_t) -> status_t;\n    pub fn on_exit_thread(callback: extern \"C\" fn(*mut ::c_void), data: *mut ::c_void) -> status_t;\n\n    pub fn find_thread(name: *const ::c_char) -> thread_id;\n\n    pub fn get_scheduler_mode() -> i32;\n    pub fn set_scheduler_mode(mode: i32) -> status_t;\n\n    pub fn send_data(\n        thread: thread_id,\n        code: i32,\n        buffer: *const ::c_void,\n        bufferSize: ::size_t,\n    ) -> status_t;\n    pub fn receive_data(sender: *mut thread_id, buffer: *mut ::c_void, bufferSize: ::size_t)\n        -> i32;\n    pub fn has_data(thread: thread_id) -> bool;\n\n    pub fn snooze(amount: bigtime_t) -> status_t;\n    pub fn snooze_etc(amount: bigtime_t, timeBase: ::c_int, flags: u32) -> status_t;\n    pub fn snooze_until(time: bigtime_t, timeBase: ::c_int) -> status_t;\n\n    pub fn _get_thread_info(id: thread_id, info: *mut thread_info, size: ::size_t) -> status_t;\n    pub fn _get_next_thread_info(\n        team: team_id,\n        cookie: *mut i32,\n        info: *mut thread_info,\n        size: ::size_t,\n    ) -> status_t;\n\n    pub fn get_pthread_thread_id(thread: ::pthread_t) -> thread_id;\n\n    pub fn _get_team_usage_info(\n        team: team_id,\n        who: i32,\n        info: *mut team_usage_info,\n        size: ::size_t,\n    ) -> status_t;\n\n    pub fn real_time_clock() -> ::c_ulong;\n    pub fn set_real_time_clock(secsSinceJan1st1970: ::c_ulong);\n    pub fn real_time_clock_usecs() -> bigtime_t;\n    pub fn system_time() -> bigtime_t;\n    pub fn system_time_nsecs() -> nanotime_t;\n    // set_timezone() is deprecated and a no-op\n\n    pub fn set_alarm(when: bigtime_t, flags: u32) -> bigtime_t;\n    pub fn debugger(message: *const ::c_char);\n    pub fn disable_debugger(state: ::c_int) -> ::c_int;\n\n    // TODO: cpuid_info struct and the get_cpuid() function\n\n    pub fn get_system_info(info: *mut system_info) -> status_t;\n    pub fn get_cpu_info(firstCPU: u32, cpuCount: u32, info: *mut cpu_info) -> status_t;\n    pub fn is_computer_on() -> i32;\n    pub fn is_computer_on_fire() -> ::c_double;\n    pub fn send_signal(threadID: thread_id, signal: ::c_uint) -> ::c_int;\n    pub fn set_signal_stack(base: *mut ::c_void, size: ::size_t);\n\n    pub fn wait_for_objects(infos: *mut object_wait_info, numInfos: ::c_int) -> ::ssize_t;\n    pub fn wait_for_objects_etc(\n        infos: *mut object_wait_info,\n        numInfos: ::c_int,\n        flags: u32,\n        timeout: bigtime_t,\n    ) -> ::ssize_t;\n\n    // kernel/fs_attr.h\n    pub fn fs_read_attr(\n        fd: ::c_int,\n        attribute: *const ::c_char,\n        type_: u32,\n        pos: ::off_t,\n        buffer: *mut ::c_void,\n        readBytes: ::size_t,\n    ) -> ::ssize_t;\n    pub fn fs_write_attr(\n        fd: ::c_int,\n        attribute: *const ::c_char,\n        type_: u32,\n        pos: ::off_t,\n        buffer: *const ::c_void,\n        writeBytes: ::size_t,\n    ) -> ::ssize_t;\n    pub fn fs_remove_attr(fd: ::c_int, attribute: *const ::c_char) -> ::c_int;\n    pub fn fs_stat_attr(\n        fd: ::c_int,\n        attribute: *const ::c_char,\n        attrInfo: *mut attr_info,\n    ) -> ::c_int;\n\n    pub fn fs_open_attr(\n        path: *const ::c_char,\n        attribute: *const ::c_char,\n        type_: u32,\n        openMode: ::c_int,\n    ) -> ::c_int;\n    pub fn fs_fopen_attr(\n        fd: ::c_int,\n        attribute: *const ::c_char,\n        type_: u32,\n        openMode: ::c_int,\n    ) -> ::c_int;\n    pub fn fs_close_attr(fd: ::c_int) -> ::c_int;\n\n    pub fn fs_open_attr_dir(path: *const ::c_char) -> *mut ::DIR;\n    pub fn fs_lopen_attr_dir(path: *const ::c_char) -> *mut ::DIR;\n    pub fn fs_fopen_attr_dir(fd: ::c_int) -> *mut ::DIR;\n    pub fn fs_close_attr_dir(dir: *mut ::DIR) -> ::c_int;\n    pub fn fs_read_attr_dir(dir: *mut ::DIR) -> *mut ::dirent;\n    pub fn fs_rewind_attr_dir(dir: *mut ::DIR);\n\n    // kernel/fs_image.h\n    pub fn fs_create_index(\n        device: ::dev_t,\n        name: *const ::c_char,\n        type_: u32,\n        flags: u32,\n    ) -> ::c_int;\n    pub fn fs_remove_index(device: ::dev_t, name: *const ::c_char) -> ::c_int;\n    pub fn fs_stat_index(\n        device: ::dev_t,\n        name: *const ::c_char,\n        indexInfo: *mut index_info,\n    ) -> ::c_int;\n\n    pub fn fs_open_index_dir(device: ::dev_t) -> *mut ::DIR;\n    pub fn fs_close_index_dir(indexDirectory: *mut ::DIR) -> ::c_int;\n    pub fn fs_read_index_dir(indexDirectory: *mut ::DIR) -> *mut ::dirent;\n    pub fn fs_rewind_index_dir(indexDirectory: *mut ::DIR);\n\n    // kernel/fs_info.h\n    pub fn dev_for_path(path: *const ::c_char) -> ::dev_t;\n    pub fn next_dev(pos: *mut i32) -> ::dev_t;\n    pub fn fs_stat_dev(dev: ::dev_t, info: *mut fs_info) -> ::c_int;\n\n    // kernel/fs_query.h\n    pub fn fs_open_query(device: ::dev_t, query: *const ::c_char, flags: u32) -> *mut ::DIR;\n    pub fn fs_open_live_query(\n        device: ::dev_t,\n        query: *const ::c_char,\n        flags: u32,\n        port: port_id,\n        token: i32,\n    ) -> *mut ::DIR;\n    pub fn fs_close_query(d: *mut ::DIR) -> ::c_int;\n    pub fn fs_read_query(d: *mut ::DIR) -> *mut ::dirent;\n    pub fn get_path_for_dirent(dent: *mut ::dirent, buf: *mut ::c_char, len: ::size_t) -> status_t;\n\n    // kernel/fs_volume.h\n    pub fn fs_mount_volume(\n        where_: *const ::c_char,\n        device: *const ::c_char,\n        filesystem: *const ::c_char,\n        flags: u32,\n        parameters: *const ::c_char,\n    ) -> ::dev_t;\n    pub fn fs_unmount_volume(path: *const ::c_char, flags: u32) -> status_t;\n\n    // kernel/image.h\n    pub fn load_image(\n        argc: i32,\n        argv: *mut *const ::c_char,\n        environ: *mut *const ::c_char,\n    ) -> thread_id;\n    pub fn load_add_on(path: *const ::c_char) -> image_id;\n    pub fn unload_add_on(image: image_id) -> status_t;\n    pub fn get_image_symbol(\n        image: image_id,\n        name: *const ::c_char,\n        symbolType: i32,\n        symbolLocation: *mut *mut ::c_void,\n    ) -> status_t;\n    pub fn get_nth_image_symbol(\n        image: image_id,\n        n: i32,\n        nameBuffer: *mut ::c_char,\n        nameLength: *mut i32,\n        symbolType: *mut i32,\n        symbolLocation: *mut *mut ::c_void,\n    ) -> status_t;\n    pub fn clear_caches(address: *mut ::c_void, length: ::size_t, flags: u32);\n    pub fn _get_image_info(image: image_id, info: *mut image_info, size: ::size_t) -> status_t;\n    pub fn _get_next_image_info(\n        team: team_id,\n        cookie: *mut i32,\n        info: *mut image_info,\n        size: ::size_t,\n    ) -> status_t;\n}\n\n// The following functions are defined as macros in C/C++\npub unsafe fn get_area_info(id: area_id, info: *mut area_info) -> status_t {\n    _get_area_info(id, info, core::mem::size_of::<area_info>() as usize)\n}\n\npub unsafe fn get_next_area_info(\n    team: team_id,\n    cookie: *mut isize,\n    info: *mut area_info,\n) -> status_t {\n    _get_next_area_info(\n        team,\n        cookie,\n        info,\n        core::mem::size_of::<area_info>() as usize,\n    )\n}\n\npub unsafe fn get_port_info(port: port_id, buf: *mut port_info) -> status_t {\n    _get_port_info(port, buf, core::mem::size_of::<port_info>() as ::size_t)\n}\n\npub unsafe fn get_next_port_info(\n    port: port_id,\n    cookie: *mut i32,\n    portInfo: *mut port_info,\n) -> status_t {\n    _get_next_port_info(\n        port,\n        cookie,\n        portInfo,\n        core::mem::size_of::<port_info>() as ::size_t,\n    )\n}\n\npub unsafe fn get_port_message_info_etc(\n    port: port_id,\n    info: *mut port_message_info,\n    flags: u32,\n    timeout: bigtime_t,\n) -> status_t {\n    _get_port_message_info_etc(\n        port,\n        info,\n        core::mem::size_of::<port_message_info>() as ::size_t,\n        flags,\n        timeout,\n    )\n}\n\npub unsafe fn get_sem_info(id: sem_id, info: *mut sem_info) -> status_t {\n    _get_sem_info(id, info, core::mem::size_of::<sem_info>() as ::size_t)\n}\n\npub unsafe fn get_next_sem_info(team: team_id, cookie: *mut i32, info: *mut sem_info) -> status_t {\n    _get_next_sem_info(\n        team,\n        cookie,\n        info,\n        core::mem::size_of::<sem_info>() as ::size_t,\n    )\n}\n\npub unsafe fn get_team_info(team: team_id, info: *mut team_info) -> status_t {\n    _get_team_info(team, info, core::mem::size_of::<team_info>() as ::size_t)\n}\n\npub unsafe fn get_next_team_info(cookie: *mut i32, info: *mut team_info) -> status_t {\n    _get_next_team_info(cookie, info, core::mem::size_of::<team_info>() as ::size_t)\n}\n\npub unsafe fn get_team_usage_info(team: team_id, who: i32, info: *mut team_usage_info) -> status_t {\n    _get_team_usage_info(\n        team,\n        who,\n        info,\n        core::mem::size_of::<team_usage_info>() as ::size_t,\n    )\n}\n\npub unsafe fn get_thread_info(id: thread_id, info: *mut thread_info) -> status_t {\n    _get_thread_info(id, info, core::mem::size_of::<thread_info>() as ::size_t)\n}\n\npub unsafe fn get_next_thread_info(\n    team: team_id,\n    cookie: *mut i32,\n    info: *mut thread_info,\n) -> status_t {\n    _get_next_thread_info(\n        team,\n        cookie,\n        info,\n        core::mem::size_of::<thread_info>() as ::size_t,\n    )\n}\n\n// kernel/image.h\npub unsafe fn get_image_info(image: image_id, info: *mut image_info) -> status_t {\n    _get_image_info(image, info, core::mem::size_of::<image_info>() as ::size_t)\n}\n\npub unsafe fn get_next_image_info(\n    team: team_id,\n    cookie: *mut i32,\n    info: *mut image_info,\n) -> status_t {\n    _get_next_image_info(\n        team,\n        cookie,\n        info,\n        core::mem::size_of::<image_info>() as ::size_t,\n    )\n}\n"],["1136","pub type c_long = i32;\npub type c_ulong = u32;\npub type time_t = i32;\n"],["1137","pub type c_char = i8;\npub type c_long = i64;\npub type c_ulong = u64;\npub type wchar_t = i32;\n\npub type blkcnt_t = ::c_ulong;\npub type blksize_t = ::c_long;\npub type clock_t = ::c_long;\npub type clockid_t = ::c_int;\npub type dev_t = ::c_long;\npub type fsblkcnt_t = ::c_ulong;\npub type fsfilcnt_t = ::c_ulong;\npub type ino_t = ::c_ulong;\npub type mode_t = ::c_int;\npub type nfds_t = ::c_ulong;\npub type nlink_t = ::c_ulong;\npub type off_t = ::c_long;\npub type pthread_t = *mut ::c_void;\npub type pthread_attr_t = *mut ::c_void;\npub type pthread_cond_t = *mut ::c_void;\npub type pthread_condattr_t = *mut ::c_void;\n// Must be usize due to libstd/sys_common/thread_local.rs,\n// should technically be *mut ::c_void\npub type pthread_key_t = usize;\npub type pthread_mutex_t = *mut ::c_void;\npub type pthread_mutexattr_t = *mut ::c_void;\npub type pthread_rwlock_t = *mut ::c_void;\npub type pthread_rwlockattr_t = *mut ::c_void;\npub type rlim_t = ::c_ulonglong;\npub type sa_family_t = u16;\npub type sem_t = *mut ::c_void;\npub type sigset_t = ::c_ulong;\npub type socklen_t = u32;\npub type speed_t = u32;\npub type suseconds_t = ::c_int;\npub type tcflag_t = u32;\npub type time_t = ::c_long;\n\n#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\npub enum timezone {}\nimpl ::Copy for timezone {}\nimpl ::Clone for timezone {\n    fn clone(&self) -> timezone {\n        *self\n    }\n}\n\ns_no_extra_traits! {\n    #[repr(C)]\n    pub struct utsname {\n        pub sysname: [::c_char; UTSLENGTH],\n        pub nodename: [::c_char; UTSLENGTH],\n        pub release: [::c_char; UTSLENGTH],\n        pub version: [::c_char; UTSLENGTH],\n        pub machine: [::c_char; UTSLENGTH],\n        pub domainname: [::c_char; UTSLENGTH],\n    }\n\n    pub struct dirent {\n        pub d_ino: ::ino_t,\n        pub d_off: ::off_t,\n        pub d_reclen: ::c_ushort,\n        pub d_type: ::c_uchar,\n        pub d_name: [::c_char; 256],\n    }\n\n    pub struct sockaddr_un {\n        pub sun_family: ::sa_family_t,\n        pub sun_path: [::c_char; 108]\n    }\n\n    pub struct sockaddr_storage {\n        pub ss_family: ::sa_family_t,\n        __ss_padding: [\n            u8;\n            128 -\n            ::core::mem::size_of::<sa_family_t>() -\n            ::core::mem::size_of::<c_ulong>()\n        ],\n        __ss_align: ::c_ulong,\n    }\n}\n\ns! {\n    pub struct addrinfo {\n        pub ai_flags: ::c_int,\n        pub ai_family: ::c_int,\n        pub ai_socktype: ::c_int,\n        pub ai_protocol: ::c_int,\n        pub ai_addrlen: ::size_t,\n        pub ai_canonname: *mut ::c_char,\n        pub ai_addr: *mut ::sockaddr,\n        pub ai_next: *mut ::addrinfo,\n    }\n\n    pub struct Dl_info {\n        pub dli_fname: *const ::c_char,\n        pub dli_fbase: *mut ::c_void,\n        pub dli_sname: *const ::c_char,\n        pub dli_saddr: *mut ::c_void,\n    }\n\n    pub struct epoll_event {\n        pub events: u32,\n        pub u64: u64,\n        pub _pad: u64,\n    }\n\n    pub struct fd_set {\n        fds_bits: [::c_ulong; ::FD_SETSIZE / ULONG_SIZE],\n    }\n\n    pub struct in_addr {\n        pub s_addr: ::in_addr_t,\n    }\n\n    pub struct ip_mreq {\n        pub imr_multiaddr: ::in_addr,\n        pub imr_interface: ::in_addr,\n    }\n\n    pub struct lconv {\n        pub currency_symbol: *const ::c_char,\n        pub decimal_point: *const ::c_char,\n        pub frac_digits: ::c_char,\n        pub grouping: *const ::c_char,\n        pub int_curr_symbol: *const ::c_char,\n        pub int_frac_digits: ::c_char,\n        pub mon_decimal_point: *const ::c_char,\n        pub mon_grouping: *const ::c_char,\n        pub mon_thousands_sep: *const ::c_char,\n        pub negative_sign: *const ::c_char,\n        pub n_cs_precedes: ::c_char,\n        pub n_sep_by_space: ::c_char,\n        pub n_sign_posn: ::c_char,\n        pub positive_sign: *const ::c_char,\n        pub p_cs_precedes: ::c_char,\n        pub p_sep_by_space: ::c_char,\n        pub p_sign_posn: ::c_char,\n        pub thousands_sep: *const ::c_char,\n    }\n\n    pub struct passwd {\n        pub pw_name: *mut ::c_char,\n        pub pw_passwd: *mut ::c_char,\n        pub pw_uid: ::uid_t,\n        pub pw_gid: ::gid_t,\n        pub pw_gecos: *mut ::c_char,\n        pub pw_dir: *mut ::c_char,\n        pub pw_shell: *mut ::c_char,\n    }\n\n    pub struct sigaction {\n        pub sa_handler: ::sighandler_t,\n        pub sa_flags: ::c_ulong,\n        pub sa_restorer: ::Option<extern fn()>,\n        pub sa_mask: ::sigset_t,\n    }\n\n    pub struct sockaddr {\n        pub sa_family: ::sa_family_t,\n        pub sa_data: [::c_char; 14],\n    }\n\n    pub struct sockaddr_in {\n        pub sin_family: ::sa_family_t,\n        pub sin_port: ::in_port_t,\n        pub sin_addr: ::in_addr,\n        pub sin_zero: [::c_char; 8],\n    }\n\n    pub struct sockaddr_in6 {\n        pub sin6_family: ::sa_family_t,\n        pub sin6_port: ::in_port_t,\n        pub sin6_flowinfo: u32,\n        pub sin6_addr: ::in6_addr,\n        pub sin6_scope_id: u32,\n    }\n\n    pub struct stat {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino_t,\n        pub st_nlink: ::nlink_t,\n        pub st_mode: ::mode_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        pub st_size: ::off_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        _pad: [::c_char; 24],\n    }\n\n    pub struct statvfs {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_favail: ::fsfilcnt_t,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n    }\n\n    pub struct termios {\n        pub c_iflag: ::tcflag_t,\n        pub c_oflag: ::tcflag_t,\n        pub c_cflag: ::tcflag_t,\n        pub c_lflag: ::tcflag_t,\n        pub c_line: ::cc_t,\n        pub c_cc: [::cc_t; ::NCCS],\n        pub c_ispeed: ::speed_t,\n        pub c_ospeed: ::speed_t,\n    }\n\n    pub struct tm {\n        pub tm_sec: ::c_int,\n        pub tm_min: ::c_int,\n        pub tm_hour: ::c_int,\n        pub tm_mday: ::c_int,\n        pub tm_mon: ::c_int,\n        pub tm_year: ::c_int,\n        pub tm_wday: ::c_int,\n        pub tm_yday: ::c_int,\n        pub tm_isdst: ::c_int,\n        pub tm_gmtoff: ::c_long,\n        pub tm_zone: *const ::c_char,\n    }\n}\n\npub const UTSLENGTH: usize = 65;\n\n// intentionally not public, only used for fd_set\ncfg_if! {\n    if #[cfg(target_pointer_width = \"32\")] {\n        const ULONG_SIZE: usize = 32;\n    } else if #[cfg(target_pointer_width = \"64\")] {\n        const ULONG_SIZE: usize = 64;\n    } else {\n        // Unknown target_pointer_width\n    }\n}\n\n// limits.h\npub const PATH_MAX: ::c_int = 4096;\n\n// fcntl.h\npub const F_GETLK: ::c_int = 5;\npub const F_SETLK: ::c_int = 6;\npub const F_SETLKW: ::c_int = 7;\n\n// FIXME: relibc {\npub const RTLD_DEFAULT: *mut ::c_void = 0i64 as *mut ::c_void;\n// }\n\n// dlfcn.h\npub const RTLD_LAZY: ::c_int = 0x0001;\npub const RTLD_NOW: ::c_int = 0x0002;\npub const RTLD_GLOBAL: ::c_int = 0x0100;\npub const RTLD_LOCAL: ::c_int = 0x0000;\n\n// errno.h\npub const EPERM: ::c_int = 1; /* Operation not permitted */\npub const ENOENT: ::c_int = 2; /* No such file or directory */\npub const ESRCH: ::c_int = 3; /* No such process */\npub const EINTR: ::c_int = 4; /* Interrupted system call */\npub const EIO: ::c_int = 5; /* I/O error */\npub const ENXIO: ::c_int = 6; /* No such device or address */\npub const E2BIG: ::c_int = 7; /* Argument list too long */\npub const ENOEXEC: ::c_int = 8; /* Exec format error */\npub const EBADF: ::c_int = 9; /* Bad file number */\npub const ECHILD: ::c_int = 10; /* No child processes */\npub const EAGAIN: ::c_int = 11; /* Try again */\npub const ENOMEM: ::c_int = 12; /* Out of memory */\npub const EACCES: ::c_int = 13; /* Permission denied */\npub const EFAULT: ::c_int = 14; /* Bad address */\npub const ENOTBLK: ::c_int = 15; /* Block device required */\npub const EBUSY: ::c_int = 16; /* Device or resource busy */\npub const EEXIST: ::c_int = 17; /* File exists */\npub const EXDEV: ::c_int = 18; /* Cross-device link */\npub const ENODEV: ::c_int = 19; /* No such device */\npub const ENOTDIR: ::c_int = 20; /* Not a directory */\npub const EISDIR: ::c_int = 21; /* Is a directory */\npub const EINVAL: ::c_int = 22; /* Invalid argument */\npub const ENFILE: ::c_int = 23; /* File table overflow */\npub const EMFILE: ::c_int = 24; /* Too many open files */\npub const ENOTTY: ::c_int = 25; /* Not a typewriter */\npub const ETXTBSY: ::c_int = 26; /* Text file busy */\npub const EFBIG: ::c_int = 27; /* File too large */\npub const ENOSPC: ::c_int = 28; /* No space left on device */\npub const ESPIPE: ::c_int = 29; /* Illegal seek */\npub const EROFS: ::c_int = 30; /* Read-only file system */\npub const EMLINK: ::c_int = 31; /* Too many links */\npub const EPIPE: ::c_int = 32; /* Broken pipe */\npub const EDOM: ::c_int = 33; /* Math argument out of domain of func */\npub const ERANGE: ::c_int = 34; /* Math result not representable */\npub const EDEADLK: ::c_int = 35; /* Resource deadlock would occur */\npub const ENAMETOOLONG: ::c_int = 36; /* File name too long */\npub const ENOLCK: ::c_int = 37; /* No record locks available */\npub const ENOSYS: ::c_int = 38; /* Function not implemented */\npub const ENOTEMPTY: ::c_int = 39; /* Directory not empty */\npub const ELOOP: ::c_int = 40; /* Too many symbolic links encountered */\npub const EWOULDBLOCK: ::c_int = 41; /* Operation would block */\npub const ENOMSG: ::c_int = 42; /* No message of desired type */\npub const EIDRM: ::c_int = 43; /* Identifier removed */\npub const ECHRNG: ::c_int = 44; /* Channel number out of range */\npub const EL2NSYNC: ::c_int = 45; /* Level 2 not synchronized */\npub const EL3HLT: ::c_int = 46; /* Level 3 halted */\npub const EL3RST: ::c_int = 47; /* Level 3 reset */\npub const ELNRNG: ::c_int = 48; /* Link number out of range */\npub const EUNATCH: ::c_int = 49; /* Protocol driver not attached */\npub const ENOCSI: ::c_int = 50; /* No CSI structure available */\npub const EL2HLT: ::c_int = 51; /* Level 2 halted */\npub const EBADE: ::c_int = 52; /* Invalid exchange */\npub const EBADR: ::c_int = 53; /* Invalid request descriptor */\npub const EXFULL: ::c_int = 54; /* Exchange full */\npub const ENOANO: ::c_int = 55; /* No anode */\npub const EBADRQC: ::c_int = 56; /* Invalid request code */\npub const EBADSLT: ::c_int = 57; /* Invalid slot */\npub const EDEADLOCK: ::c_int = 58; /* Resource deadlock would occur */\npub const EBFONT: ::c_int = 59; /* Bad font file format */\npub const ENOSTR: ::c_int = 60; /* Device not a stream */\npub const ENODATA: ::c_int = 61; /* No data available */\npub const ETIME: ::c_int = 62; /* Timer expired */\npub const ENOSR: ::c_int = 63; /* Out of streams resources */\npub const ENONET: ::c_int = 64; /* Machine is not on the network */\npub const ENOPKG: ::c_int = 65; /* Package not installed */\npub const EREMOTE: ::c_int = 66; /* Object is remote */\npub const ENOLINK: ::c_int = 67; /* Link has been severed */\npub const EADV: ::c_int = 68; /* Advertise error */\npub const ESRMNT: ::c_int = 69; /* Srmount error */\npub const ECOMM: ::c_int = 70; /* Communication error on send */\npub const EPROTO: ::c_int = 71; /* Protocol error */\npub const EMULTIHOP: ::c_int = 72; /* Multihop attempted */\npub const EDOTDOT: ::c_int = 73; /* RFS specific error */\npub const EBADMSG: ::c_int = 74; /* Not a data message */\npub const EOVERFLOW: ::c_int = 75; /* Value too large for defined data type */\npub const ENOTUNIQ: ::c_int = 76; /* Name not unique on network */\npub const EBADFD: ::c_int = 77; /* File descriptor in bad state */\npub const EREMCHG: ::c_int = 78; /* Remote address changed */\npub const ELIBACC: ::c_int = 79; /* Can not access a needed shared library */\npub const ELIBBAD: ::c_int = 80; /* Accessing a corrupted shared library */\npub const ELIBSCN: ::c_int = 81; /* .lib section in a.out corrupted */\n/* Attempting to link in too many shared libraries */\npub const ELIBMAX: ::c_int = 82;\npub const ELIBEXEC: ::c_int = 83; /* Cannot exec a shared library directly */\npub const EILSEQ: ::c_int = 84; /* Illegal byte sequence */\n/* Interrupted system call should be restarted */\npub const ERESTART: ::c_int = 85;\npub const ESTRPIPE: ::c_int = 86; /* Streams pipe error */\npub const EUSERS: ::c_int = 87; /* Too many users */\npub const ENOTSOCK: ::c_int = 88; /* Socket operation on non-socket */\npub const EDESTADDRREQ: ::c_int = 89; /* Destination address required */\npub const EMSGSIZE: ::c_int = 90; /* Message too long */\npub const EPROTOTYPE: ::c_int = 91; /* Protocol wrong type for socket */\npub const ENOPROTOOPT: ::c_int = 92; /* Protocol not available */\npub const EPROTONOSUPPORT: ::c_int = 93; /* Protocol not supported */\npub const ESOCKTNOSUPPORT: ::c_int = 94; /* Socket type not supported */\n/* Operation not supported on transport endpoint */\npub const EOPNOTSUPP: ::c_int = 95;\npub const EPFNOSUPPORT: ::c_int = 96; /* Protocol family not supported */\n/* Address family not supported by protocol */\npub const EAFNOSUPPORT: ::c_int = 97;\npub const EADDRINUSE: ::c_int = 98; /* Address already in use */\npub const EADDRNOTAVAIL: ::c_int = 99; /* Cannot assign requested address */\npub const ENETDOWN: ::c_int = 100; /* Network is down */\npub const ENETUNREACH: ::c_int = 101; /* Network is unreachable */\n/* Network dropped connection because of reset */\npub const ENETRESET: ::c_int = 102;\npub const ECONNABORTED: ::c_int = 103; /* Software caused connection abort */\npub const ECONNRESET: ::c_int = 104; /* Connection reset by peer */\npub const ENOBUFS: ::c_int = 105; /* No buffer space available */\npub const EISCONN: ::c_int = 106; /* Transport endpoint is already connected */\npub const ENOTCONN: ::c_int = 107; /* Transport endpoint is not connected */\n/* Cannot send after transport endpoint shutdown */\npub const ESHUTDOWN: ::c_int = 108;\npub const ETOOMANYREFS: ::c_int = 109; /* Too many references: cannot splice */\npub const ETIMEDOUT: ::c_int = 110; /* Connection timed out */\npub const ECONNREFUSED: ::c_int = 111; /* Connection refused */\npub const EHOSTDOWN: ::c_int = 112; /* Host is down */\npub const EHOSTUNREACH: ::c_int = 113; /* No route to host */\npub const EALREADY: ::c_int = 114; /* Operation already in progress */\npub const EINPROGRESS: ::c_int = 115; /* Operation now in progress */\npub const ESTALE: ::c_int = 116; /* Stale NFS file handle */\npub const EUCLEAN: ::c_int = 117; /* Structure needs cleaning */\npub const ENOTNAM: ::c_int = 118; /* Not a XENIX named type file */\npub const ENAVAIL: ::c_int = 119; /* No XENIX semaphores available */\npub const EISNAM: ::c_int = 120; /* Is a named type file */\npub const EREMOTEIO: ::c_int = 121; /* Remote I/O error */\npub const EDQUOT: ::c_int = 122; /* Quota exceeded */\npub const ENOMEDIUM: ::c_int = 123; /* No medium found */\npub const EMEDIUMTYPE: ::c_int = 124; /* Wrong medium type */\npub const ECANCELED: ::c_int = 125; /* Operation Canceled */\npub const ENOKEY: ::c_int = 126; /* Required key not available */\npub const EKEYEXPIRED: ::c_int = 127; /* Key has expired */\npub const EKEYREVOKED: ::c_int = 128; /* Key has been revoked */\npub const EKEYREJECTED: ::c_int = 129; /* Key was rejected by service */\npub const EOWNERDEAD: ::c_int = 130; /* Owner died */\npub const ENOTRECOVERABLE: ::c_int = 131; /* State not recoverable */\n\n// fcntl.h\npub const F_DUPFD: ::c_int = 0;\npub const F_GETFD: ::c_int = 1;\npub const F_SETFD: ::c_int = 2;\npub const F_GETFL: ::c_int = 3;\npub const F_SETFL: ::c_int = 4;\n// FIXME: relibc {\npub const F_DUPFD_CLOEXEC: ::c_int = ::F_DUPFD;\n// }\npub const FD_CLOEXEC: ::c_int = 0x0100_0000;\npub const O_RDONLY: ::c_int = 0x0001_0000;\npub const O_WRONLY: ::c_int = 0x0002_0000;\npub const O_RDWR: ::c_int = 0x0003_0000;\npub const O_ACCMODE: ::c_int = 0x0003_0000;\npub const O_NONBLOCK: ::c_int = 0x0004_0000;\npub const O_APPEND: ::c_int = 0x0008_0000;\npub const O_SHLOCK: ::c_int = 0x0010_0000;\npub const O_EXLOCK: ::c_int = 0x0020_0000;\npub const O_ASYNC: ::c_int = 0x0040_0000;\npub const O_FSYNC: ::c_int = 0x0080_0000;\npub const O_CLOEXEC: ::c_int = 0x0100_0000;\npub const O_CREAT: ::c_int = 0x0200_0000;\npub const O_TRUNC: ::c_int = 0x0400_0000;\npub const O_EXCL: ::c_int = 0x0800_0000;\npub const O_DIRECTORY: ::c_int = 0x1000_0000;\npub const O_PATH: ::c_int = 0x2000_0000;\npub const O_SYMLINK: ::c_int = 0x4000_0000;\n// Negative to allow it to be used as int\n// FIXME: Fix negative values missing from includes\npub const O_NOFOLLOW: ::c_int = -0x8000_0000;\n\n// netdb.h\npub const AI_PASSIVE: ::c_int = 0x0001;\npub const AI_CANONNAME: ::c_int = 0x0002;\npub const AI_NUMERICHOST: ::c_int = 0x0004;\npub const AI_V4MAPPED: ::c_int = 0x0008;\npub const AI_ALL: ::c_int = 0x0010;\npub const AI_ADDRCONFIG: ::c_int = 0x0020;\npub const AI_NUMERICSERV: ::c_int = 0x0400;\npub const EAI_BADFLAGS: ::c_int = -1;\npub const EAI_NONAME: ::c_int = -2;\npub const EAI_AGAIN: ::c_int = -3;\npub const EAI_FAIL: ::c_int = -4;\npub const EAI_NODATA: ::c_int = -5;\npub const EAI_FAMILY: ::c_int = -6;\npub const EAI_SOCKTYPE: ::c_int = -7;\npub const EAI_SERVICE: ::c_int = -8;\npub const EAI_ADDRFAMILY: ::c_int = -9;\npub const EAI_MEMORY: ::c_int = -10;\npub const EAI_SYSTEM: ::c_int = -11;\npub const EAI_OVERFLOW: ::c_int = -12;\npub const NI_MAXHOST: ::c_int = 1025;\npub const NI_MAXSERV: ::c_int = 32;\npub const NI_NUMERICHOST: ::c_int = 0x0001;\npub const NI_NUMERICSERV: ::c_int = 0x0002;\npub const NI_NOFQDN: ::c_int = 0x0004;\npub const NI_NAMEREQD: ::c_int = 0x0008;\npub const NI_DGRAM: ::c_int = 0x0010;\n\n// netinet/in.h\n// FIXME: relibc {\npub const IP_TTL: ::c_int = 2;\npub const IPV6_UNICAST_HOPS: ::c_int = 16;\npub const IPV6_MULTICAST_IF: ::c_int = 17;\npub const IPV6_MULTICAST_HOPS: ::c_int = 18;\npub const IPV6_MULTICAST_LOOP: ::c_int = 19;\npub const IPV6_ADD_MEMBERSHIP: ::c_int = 20;\npub const IPV6_DROP_MEMBERSHIP: ::c_int = 21;\npub const IPV6_V6ONLY: ::c_int = 26;\npub const IP_MULTICAST_IF: ::c_int = 32;\npub const IP_MULTICAST_TTL: ::c_int = 33;\npub const IP_MULTICAST_LOOP: ::c_int = 34;\npub const IP_ADD_MEMBERSHIP: ::c_int = 35;\npub const IP_DROP_MEMBERSHIP: ::c_int = 36;\n// }\n\n// netinet/tcp.h\npub const TCP_NODELAY: ::c_int = 1;\n// FIXME: relibc {\npub const TCP_KEEPIDLE: ::c_int = 1;\n// }\n\n// poll.h\npub const POLLIN: ::c_short = 0x001;\npub const POLLPRI: ::c_short = 0x002;\npub const POLLOUT: ::c_short = 0x004;\npub const POLLERR: ::c_short = 0x008;\npub const POLLHUP: ::c_short = 0x010;\npub const POLLNVAL: ::c_short = 0x020;\n\n// pthread.h\npub const PTHREAD_MUTEX_NORMAL: ::c_int = 0;\npub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 1;\npub const PTHREAD_MUTEX_INITIALIZER: ::pthread_mutex_t = -1isize as *mut _;\npub const PTHREAD_COND_INITIALIZER: ::pthread_cond_t = -1isize as *mut _;\npub const PTHREAD_RWLOCK_INITIALIZER: ::pthread_rwlock_t = -1isize as *mut _;\npub const PTHREAD_STACK_MIN: ::size_t = 4096;\n\n// signal.h\npub const SIG_BLOCK: ::c_int = 0;\npub const SIG_UNBLOCK: ::c_int = 1;\npub const SIG_SETMASK: ::c_int = 2;\npub const SIGHUP: ::c_int = 1;\npub const SIGINT: ::c_int = 2;\npub const SIGQUIT: ::c_int = 3;\npub const SIGILL: ::c_int = 4;\npub const SIGTRAP: ::c_int = 5;\npub const SIGABRT: ::c_int = 6;\npub const SIGBUS: ::c_int = 7;\npub const SIGFPE: ::c_int = 8;\npub const SIGKILL: ::c_int = 9;\npub const SIGUSR1: ::c_int = 10;\npub const SIGSEGV: ::c_int = 11;\npub const SIGUSR2: ::c_int = 12;\npub const SIGPIPE: ::c_int = 13;\npub const SIGALRM: ::c_int = 14;\npub const SIGTERM: ::c_int = 15;\npub const SIGSTKFLT: ::c_int = 16;\npub const SIGCHLD: ::c_int = 17;\npub const SIGCONT: ::c_int = 18;\npub const SIGSTOP: ::c_int = 19;\npub const SIGTSTP: ::c_int = 20;\npub const SIGTTIN: ::c_int = 21;\npub const SIGTTOU: ::c_int = 22;\npub const SIGURG: ::c_int = 23;\npub const SIGXCPU: ::c_int = 24;\npub const SIGXFSZ: ::c_int = 25;\npub const SIGVTALRM: ::c_int = 26;\npub const SIGPROF: ::c_int = 27;\npub const SIGWINCH: ::c_int = 28;\npub const SIGIO: ::c_int = 29;\npub const SIGPWR: ::c_int = 30;\npub const SIGSYS: ::c_int = 31;\npub const NSIG: ::c_int = 32;\n\npub const SA_NOCLDSTOP: ::c_ulong = 0x00000001;\npub const SA_NOCLDWAIT: ::c_ulong = 0x00000002;\npub const SA_SIGINFO: ::c_ulong = 0x00000004;\npub const SA_RESTORER: ::c_ulong = 0x04000000;\npub const SA_ONSTACK: ::c_ulong = 0x08000000;\npub const SA_RESTART: ::c_ulong = 0x10000000;\npub const SA_NODEFER: ::c_ulong = 0x40000000;\npub const SA_RESETHAND: ::c_ulong = 0x80000000;\n\n// sys/file.h\npub const LOCK_SH: ::c_int = 1;\npub const LOCK_EX: ::c_int = 2;\npub const LOCK_NB: ::c_int = 4;\npub const LOCK_UN: ::c_int = 8;\n\n// sys/epoll.h\npub const EPOLL_CLOEXEC: ::c_int = 0x0100_0000;\npub const EPOLL_CTL_ADD: ::c_int = 1;\npub const EPOLL_CTL_DEL: ::c_int = 2;\npub const EPOLL_CTL_MOD: ::c_int = 3;\npub const EPOLLIN: ::c_int = 1;\npub const EPOLLPRI: ::c_int = 0;\npub const EPOLLOUT: ::c_int = 2;\npub const EPOLLRDNORM: ::c_int = 0;\npub const EPOLLNVAL: ::c_int = 0;\npub const EPOLLRDBAND: ::c_int = 0;\npub const EPOLLWRNORM: ::c_int = 0;\npub const EPOLLWRBAND: ::c_int = 0;\npub const EPOLLMSG: ::c_int = 0;\npub const EPOLLERR: ::c_int = 0;\npub const EPOLLHUP: ::c_int = 0;\npub const EPOLLRDHUP: ::c_int = 0;\npub const EPOLLEXCLUSIVE: ::c_int = 0;\npub const EPOLLWAKEUP: ::c_int = 0;\npub const EPOLLONESHOT: ::c_int = 0;\npub const EPOLLET: ::c_int = 0;\n\n// sys/stat.h\npub const S_IFMT: ::c_int = 0o0_170_000;\npub const S_IFDIR: ::c_int = 0o040_000;\npub const S_IFCHR: ::c_int = 0o020_000;\npub const S_IFBLK: ::c_int = 0o060_000;\npub const S_IFREG: ::c_int = 0o100_000;\npub const S_IFIFO: ::c_int = 0o010_000;\npub const S_IFLNK: ::c_int = 0o120_000;\npub const S_IFSOCK: ::c_int = 0o140_000;\npub const S_IRWXU: ::c_int = 0o0_700;\npub const S_IRUSR: ::c_int = 0o0_400;\npub const S_IWUSR: ::c_int = 0o0_200;\npub const S_IXUSR: ::c_int = 0o0_100;\npub const S_IRWXG: ::c_int = 0o0_070;\npub const S_IRGRP: ::c_int = 0o0_040;\npub const S_IWGRP: ::c_int = 0o0_020;\npub const S_IXGRP: ::c_int = 0o0_010;\npub const S_IRWXO: ::c_int = 0o0_007;\npub const S_IROTH: ::c_int = 0o0_004;\npub const S_IWOTH: ::c_int = 0o0_002;\npub const S_IXOTH: ::c_int = 0o0_001;\n\n// stdlib.h\npub const EXIT_SUCCESS: ::c_int = 0;\npub const EXIT_FAILURE: ::c_int = 1;\n\n// sys/ioctl.h\n// FIXME: relibc {\npub const FIONBIO: ::c_ulong = 0x5421;\npub const FIOCLEX: ::c_ulong = 0x5451;\n// }\npub const TCGETS: ::c_ulong = 0x5401;\npub const TCSETS: ::c_ulong = 0x5402;\npub const TCFLSH: ::c_ulong = 0x540B;\npub const TIOCGPGRP: ::c_ulong = 0x540F;\npub const TIOCSPGRP: ::c_ulong = 0x5410;\npub const TIOCGWINSZ: ::c_ulong = 0x5413;\npub const TIOCSWINSZ: ::c_ulong = 0x5414;\n\n// sys/mman.h\npub const PROT_NONE: ::c_int = 0x0000;\npub const PROT_READ: ::c_int = 0x0004;\npub const PROT_WRITE: ::c_int = 0x0002;\npub const PROT_EXEC: ::c_int = 0x0001;\n\npub const MAP_SHARED: ::c_int = 0x0001;\npub const MAP_PRIVATE: ::c_int = 0x0002;\npub const MAP_ANON: ::c_int = 0x0020;\npub const MAP_ANONYMOUS: ::c_int = MAP_ANON;\npub const MAP_FIXED: ::c_int = 0x0010;\npub const MAP_FAILED: *mut ::c_void = !0 as _;\n\npub const MS_ASYNC: ::c_int = 0x0001;\npub const MS_INVALIDATE: ::c_int = 0x0002;\npub const MS_SYNC: ::c_int = 0x0004;\n\n// sys/select.h\npub const FD_SETSIZE: usize = 1024;\n\n// sys/socket.h\npub const AF_INET: ::c_int = 2;\npub const AF_INET6: ::c_int = 10;\npub const AF_UNIX: ::c_int = 1;\npub const AF_UNSPEC: ::c_int = 0;\npub const PF_INET: ::c_int = 2;\npub const PF_INET6: ::c_int = 10;\npub const PF_UNIX: ::c_int = 1;\npub const PF_UNSPEC: ::c_int = 0;\npub const MSG_CTRUNC: ::c_int = 8;\npub const MSG_DONTROUTE: ::c_int = 4;\npub const MSG_EOR: ::c_int = 128;\npub const MSG_OOB: ::c_int = 1;\npub const MSG_PEEK: ::c_int = 2;\npub const MSG_TRUNC: ::c_int = 32;\npub const MSG_WAITALL: ::c_int = 256;\npub const SHUT_RD: ::c_int = 0;\npub const SHUT_WR: ::c_int = 1;\npub const SHUT_RDWR: ::c_int = 2;\npub const SO_DEBUG: ::c_int = 1;\npub const SO_REUSEADDR: ::c_int = 2;\npub const SO_TYPE: ::c_int = 3;\npub const SO_ERROR: ::c_int = 4;\npub const SO_DONTROUTE: ::c_int = 5;\npub const SO_BROADCAST: ::c_int = 6;\npub const SO_SNDBUF: ::c_int = 7;\npub const SO_RCVBUF: ::c_int = 8;\npub const SO_KEEPALIVE: ::c_int = 9;\npub const SO_OOBINLINE: ::c_int = 10;\npub const SO_NO_CHECK: ::c_int = 11;\npub const SO_PRIORITY: ::c_int = 12;\npub const SO_LINGER: ::c_int = 13;\npub const SO_BSDCOMPAT: ::c_int = 14;\npub const SO_REUSEPORT: ::c_int = 15;\npub const SO_PASSCRED: ::c_int = 16;\npub const SO_PEERCRED: ::c_int = 17;\npub const SO_RCVLOWAT: ::c_int = 18;\npub const SO_SNDLOWAT: ::c_int = 19;\npub const SO_RCVTIMEO: ::c_int = 20;\npub const SO_SNDTIMEO: ::c_int = 21;\npub const SO_ACCEPTCONN: ::c_int = 30;\npub const SO_PEERSEC: ::c_int = 31;\npub const SO_SNDBUFFORCE: ::c_int = 32;\npub const SO_RCVBUFFORCE: ::c_int = 33;\npub const SO_PROTOCOL: ::c_int = 38;\npub const SO_DOMAIN: ::c_int = 39;\npub const SOCK_STREAM: ::c_int = 1;\npub const SOCK_DGRAM: ::c_int = 2;\npub const SOCK_NONBLOCK: ::c_int = 0o4_000;\npub const SOCK_CLOEXEC: ::c_int = 0o2_000_000;\npub const SOCK_SEQPACKET: ::c_int = 5;\npub const SOL_SOCKET: ::c_int = 1;\n\n// sys/termios.h\npub const NCCS: usize = 32;\n\npub const VINTR: usize = 0;\npub const VQUIT: usize = 1;\npub const VERASE: usize = 2;\npub const VKILL: usize = 3;\npub const VEOF: usize = 4;\npub const VTIME: usize = 5;\npub const VMIN: usize = 6;\npub const VSWTC: usize = 7;\npub const VSTART: usize = 8;\npub const VSTOP: usize = 9;\npub const VSUSP: usize = 10;\npub const VEOL: usize = 11;\npub const VREPRINT: usize = 12;\npub const VDISCARD: usize = 13;\npub const VWERASE: usize = 14;\npub const VLNEXT: usize = 15;\npub const VEOL2: usize = 16;\n\npub const IGNBRK: ::tcflag_t = 0o000_001;\npub const BRKINT: ::tcflag_t = 0o000_002;\npub const IGNPAR: ::tcflag_t = 0o000_004;\npub const PARMRK: ::tcflag_t = 0o000_010;\npub const INPCK: ::tcflag_t = 0o000_020;\npub const ISTRIP: ::tcflag_t = 0o000_040;\npub const INLCR: ::tcflag_t = 0o000_100;\npub const IGNCR: ::tcflag_t = 0o000_200;\npub const ICRNL: ::tcflag_t = 0o000_400;\npub const IUCLC: ::tcflag_t = 0o001_000;\npub const IXON: ::tcflag_t = 0o002_000;\npub const IXANY: ::tcflag_t = 0o004_000;\npub const IXOFF: ::tcflag_t = 0o010_000;\npub const IMAXBEL: ::tcflag_t = 0o020_000;\npub const IUTF8: ::tcflag_t = 0o040_000;\n\npub const OPOST: ::tcflag_t = 0o000_001;\npub const OLCUC: ::tcflag_t = 0o000_002;\npub const ONLCR: ::tcflag_t = 0o000_004;\npub const OCRNL: ::tcflag_t = 0o000_010;\npub const ONOCR: ::tcflag_t = 0o000_020;\npub const ONLRET: ::tcflag_t = 0o00_0040;\npub const OFILL: ::tcflag_t = 0o000_100;\npub const OFDEL: ::tcflag_t = 0o000_200;\n\npub const VTDLY: usize = 0o040_000;\npub const VT0: usize = 0o000_000;\npub const VT1: usize = 0o040_000;\n\npub const B0: speed_t = 0o000_000;\npub const B50: speed_t = 0o000_001;\npub const B75: speed_t = 0o000_002;\npub const B110: speed_t = 0o000_003;\npub const B134: speed_t = 0o000_004;\npub const B150: speed_t = 0o000_005;\npub const B200: speed_t = 0o000_006;\npub const B300: speed_t = 0o000_007;\npub const B600: speed_t = 0o000_010;\npub const B1200: speed_t = 0o000_011;\npub const B1800: speed_t = 0o000_012;\npub const B2400: speed_t = 0o000_013;\npub const B4800: speed_t = 0o000_014;\npub const B9600: speed_t = 0o000_015;\npub const B19200: speed_t = 0o000_016;\npub const B38400: speed_t = 0o000_017;\n\npub const B57600: speed_t = 0o010_001;\npub const B115200: speed_t = 0o010_002;\npub const B230400: speed_t = 0o010_003;\npub const B460800: speed_t = 0o010_004;\npub const B500000: speed_t = 0o010_005;\npub const B576000: speed_t = 0o010_006;\npub const B921600: speed_t = 0o010_007;\npub const B1000000: speed_t = 0o010_010;\npub const B1152000: speed_t = 0o010_011;\npub const B1500000: speed_t = 0o010_012;\npub const B2000000: speed_t = 0o010_013;\npub const B2500000: speed_t = 0o010_014;\npub const B3000000: speed_t = 0o010_015;\npub const B3500000: speed_t = 0o010_016;\npub const B4000000: speed_t = 0o010_017;\n\npub const CSIZE: ::tcflag_t = 0o000_060;\npub const CS5: ::tcflag_t = 0o000_000;\npub const CS6: ::tcflag_t = 0o000_020;\npub const CS7: ::tcflag_t = 0o000_040;\npub const CS8: ::tcflag_t = 0o000_060;\npub const CSTOPB: ::tcflag_t = 0o000_100;\npub const CREAD: ::tcflag_t = 0o000_200;\npub const PARENB: ::tcflag_t = 0o000_400;\npub const PARODD: ::tcflag_t = 0o001_000;\npub const HUPCL: ::tcflag_t = 0o002_000;\npub const CLOCAL: ::tcflag_t = 0o004_000;\n\npub const ISIG: ::tcflag_t = 0o000_001;\npub const ICANON: ::tcflag_t = 0o000_002;\npub const ECHO: ::tcflag_t = 0o000_010;\npub const ECHOE: ::tcflag_t = 0o000_020;\npub const ECHOK: ::tcflag_t = 0o000_040;\npub const ECHONL: ::tcflag_t = 0o000_100;\npub const NOFLSH: ::tcflag_t = 0o000_200;\npub const TOSTOP: ::tcflag_t = 0o000_400;\npub const IEXTEN: ::tcflag_t = 0o100_000;\n\npub const TCOOFF: ::c_int = 0;\npub const TCOON: ::c_int = 1;\npub const TCIOFF: ::c_int = 2;\npub const TCION: ::c_int = 3;\n\npub const TCIFLUSH: ::c_int = 0;\npub const TCOFLUSH: ::c_int = 1;\npub const TCIOFLUSH: ::c_int = 2;\n\npub const TCSANOW: ::c_int = 0;\npub const TCSADRAIN: ::c_int = 1;\npub const TCSAFLUSH: ::c_int = 2;\n\n// sys/wait.h\npub const WNOHANG: ::c_int = 1;\npub const WUNTRACED: ::c_int = 2;\n\npub const WSTOPPED: ::c_int = 2;\npub const WEXITED: ::c_int = 4;\npub const WCONTINUED: ::c_int = 8;\npub const WNOWAIT: ::c_int = 0x0100_0000;\n\npub const __WNOTHREAD: ::c_int = 0x2000_0000;\npub const __WALL: ::c_int = 0x4000_0000;\n#[allow(overflowing_literals)]\npub const __WCLONE: ::c_int = 0x8000_0000;\n\n// time.h\npub const CLOCK_REALTIME: ::c_int = 1;\npub const CLOCK_MONOTONIC: ::c_int = 4;\n\n// unistd.h\n// POSIX.1 {\npub const _SC_ARG_MAX: ::c_int = 0;\npub const _SC_CHILD_MAX: ::c_int = 1;\npub const _SC_CLK_TCK: ::c_int = 2;\npub const _SC_NGROUPS_MAX: ::c_int = 3;\npub const _SC_OPEN_MAX: ::c_int = 4;\npub const _SC_STREAM_MAX: ::c_int = 5;\npub const _SC_TZNAME_MAX: ::c_int = 6;\n// ...\npub const _SC_VERSION: ::c_int = 29;\npub const _SC_PAGESIZE: ::c_int = 30;\npub const _SC_PAGE_SIZE: ::c_int = 30;\n// ...\npub const _SC_RE_DUP_MAX: ::c_int = 44;\n// ...\npub const _SC_LOGIN_NAME_MAX: ::c_int = 71;\npub const _SC_TTY_NAME_MAX: ::c_int = 72;\n// ...\npub const _SC_SYMLOOP_MAX: ::c_int = 173;\n// ...\npub const _SC_HOST_NAME_MAX: ::c_int = 180;\n// } POSIX.1\n\npub const F_OK: ::c_int = 0;\npub const R_OK: ::c_int = 4;\npub const W_OK: ::c_int = 2;\npub const X_OK: ::c_int = 1;\n\npub const SEEK_SET: ::c_int = 0;\npub const SEEK_CUR: ::c_int = 1;\npub const SEEK_END: ::c_int = 2;\npub const STDIN_FILENO: ::c_int = 0;\npub const STDOUT_FILENO: ::c_int = 1;\npub const STDERR_FILENO: ::c_int = 2;\n\npub const _PC_LINK_MAX: ::c_int = 0;\npub const _PC_MAX_CANON: ::c_int = 1;\npub const _PC_MAX_INPUT: ::c_int = 2;\npub const _PC_NAME_MAX: ::c_int = 3;\npub const _PC_PATH_MAX: ::c_int = 4;\npub const _PC_PIPE_BUF: ::c_int = 5;\npub const _PC_CHOWN_RESTRICTED: ::c_int = 6;\npub const _PC_NO_TRUNC: ::c_int = 7;\npub const _PC_VDISABLE: ::c_int = 8;\npub const _PC_SYNC_IO: ::c_int = 9;\npub const _PC_ASYNC_IO: ::c_int = 10;\npub const _PC_PRIO_IO: ::c_int = 11;\npub const _PC_SOCK_MAXBUF: ::c_int = 12;\npub const _PC_FILESIZEBITS: ::c_int = 13;\npub const _PC_REC_INCR_XFER_SIZE: ::c_int = 14;\npub const _PC_REC_MAX_XFER_SIZE: ::c_int = 15;\npub const _PC_REC_MIN_XFER_SIZE: ::c_int = 16;\npub const _PC_REC_XFER_ALIGN: ::c_int = 17;\npub const _PC_ALLOC_SIZE_MIN: ::c_int = 18;\npub const _PC_SYMLINK_MAX: ::c_int = 19;\npub const _PC_2_SYMLINKS: ::c_int = 20;\n\npub const PRIO_PROCESS: ::c_int = 0;\npub const PRIO_PGRP: ::c_int = 1;\npub const PRIO_USER: ::c_int = 2;\n\n// wait.h\nf! {\n    pub fn FD_CLR(fd: ::c_int, set: *mut fd_set) -> () {\n        let fd = fd as usize;\n        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;\n        (*set).fds_bits[fd / size] &= !(1 << (fd % size));\n        return\n    }\n\n    pub fn FD_ISSET(fd: ::c_int, set: *mut fd_set) -> bool {\n        let fd = fd as usize;\n        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;\n        return ((*set).fds_bits[fd / size] & (1 << (fd % size))) != 0\n    }\n\n    pub fn FD_SET(fd: ::c_int, set: *mut fd_set) -> () {\n        let fd = fd as usize;\n        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;\n        (*set).fds_bits[fd / size] |= 1 << (fd % size);\n        return\n    }\n\n    pub fn FD_ZERO(set: *mut fd_set) -> () {\n        for slot in (*set).fds_bits.iter_mut() {\n            *slot = 0;\n        }\n    }\n}\n\nsafe_f! {\n    pub {const} fn WIFSTOPPED(status: ::c_int) -> bool {\n        (status & 0xff) == 0x7f\n    }\n\n    pub {const} fn WSTOPSIG(status: ::c_int) -> ::c_int {\n        (status >> 8) & 0xff\n    }\n\n    pub {const} fn WIFCONTINUED(status: ::c_int) -> bool {\n        status == 0xffff\n    }\n\n    pub {const} fn WIFSIGNALED(status: ::c_int) -> bool {\n        ((status & 0x7f) + 1) as i8 >= 2\n    }\n\n    pub {const} fn WTERMSIG(status: ::c_int) -> ::c_int {\n        status & 0x7f\n    }\n\n    pub {const} fn WIFEXITED(status: ::c_int) -> bool {\n        (status & 0x7f) == 0\n    }\n\n    pub {const} fn WEXITSTATUS(status: ::c_int) -> ::c_int {\n        (status >> 8) & 0xff\n    }\n\n    pub {const} fn WCOREDUMP(status: ::c_int) -> bool {\n        (status & 0x80) != 0\n    }\n}\n\nextern \"C\" {\n    // errno.h\n    pub fn __errno_location() -> *mut ::c_int;\n    pub fn strerror_r(errnum: ::c_int, buf: *mut c_char, buflen: ::size_t) -> ::c_int;\n\n    // unistd.h\n    pub fn pipe2(fds: *mut ::c_int, flags: ::c_int) -> ::c_int;\n\n    // malloc.h\n    pub fn memalign(align: ::size_t, size: ::size_t) -> *mut ::c_void;\n\n    // netdb.h\n    pub fn getnameinfo(\n        addr: *const ::sockaddr,\n        addrlen: ::socklen_t,\n        host: *mut ::c_char,\n        hostlen: ::socklen_t,\n        serv: *mut ::c_char,\n        servlen: ::socklen_t,\n        flags: ::c_int,\n    ) -> ::c_int;\n\n    // pthread.h\n    pub fn pthread_atfork(\n        prepare: ::Option<unsafe extern \"C\" fn()>,\n        parent: ::Option<unsafe extern \"C\" fn()>,\n        child: ::Option<unsafe extern \"C\" fn()>,\n    ) -> ::c_int;\n    pub fn pthread_create(\n        tid: *mut ::pthread_t,\n        attr: *const ::pthread_attr_t,\n        start: extern \"C\" fn(*mut ::c_void) -> *mut ::c_void,\n        arg: *mut ::c_void,\n    ) -> ::c_int;\n    pub fn pthread_condattr_setclock(\n        attr: *mut pthread_condattr_t,\n        clock_id: ::clockid_t,\n    ) -> ::c_int;\n\n    // pwd.h\n    pub fn getpwuid_r(\n        uid: ::uid_t,\n        pwd: *mut passwd,\n        buf: *mut ::c_char,\n        buflen: ::size_t,\n        result: *mut *mut passwd,\n    ) -> ::c_int;\n\n    // signal.h\n    pub fn pthread_sigmask(\n        how: ::c_int,\n        set: *const ::sigset_t,\n        oldset: *mut ::sigset_t,\n    ) -> ::c_int;\n\n    // sys/epoll.h\n    pub fn epoll_create(size: ::c_int) -> ::c_int;\n    pub fn epoll_create1(flags: ::c_int) -> ::c_int;\n    pub fn epoll_wait(\n        epfd: ::c_int,\n        events: *mut ::epoll_event,\n        maxevents: ::c_int,\n        timeout: ::c_int,\n    ) -> ::c_int;\n    pub fn epoll_ctl(epfd: ::c_int, op: ::c_int, fd: ::c_int, event: *mut ::epoll_event)\n        -> ::c_int;\n\n    // sys/ioctl.h\n    pub fn ioctl(fd: ::c_int, request: ::c_ulong, ...) -> ::c_int;\n\n    // sys/mman.h\n    pub fn msync(addr: *mut ::c_void, len: ::size_t, flags: ::c_int) -> ::c_int;\n    pub fn mprotect(addr: *mut ::c_void, len: ::size_t, prot: ::c_int) -> ::c_int;\n    pub fn shm_open(name: *const c_char, oflag: ::c_int, mode: mode_t) -> ::c_int;\n    pub fn shm_unlink(name: *const ::c_char) -> ::c_int;\n\n    // sys/resource.h\n    pub fn getrlimit(resource: ::c_int, rlim: *mut ::rlimit) -> ::c_int;\n    pub fn setrlimit(resource: ::c_int, rlim: *const ::rlimit) -> ::c_int;\n\n    // sys/socket.h\n    pub fn bind(socket: ::c_int, address: *const ::sockaddr, address_len: ::socklen_t) -> ::c_int;\n    pub fn recvfrom(\n        socket: ::c_int,\n        buf: *mut ::c_void,\n        len: ::size_t,\n        flags: ::c_int,\n        addr: *mut ::sockaddr,\n        addrlen: *mut ::socklen_t,\n    ) -> ::ssize_t;\n\n    // sys/stat.h\n    pub fn futimens(fd: ::c_int, times: *const ::timespec) -> ::c_int;\n\n    // sys/uio.h\n    pub fn readv(fd: ::c_int, iov: *const ::iovec, iovcnt: ::c_int) -> ::ssize_t;\n    pub fn writev(fd: ::c_int, iov: *const ::iovec, iovcnt: ::c_int) -> ::ssize_t;\n\n    // sys/utsname.h\n    pub fn uname(utsname: *mut utsname) -> ::c_int;\n\n    // time.h\n    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::timezone) -> ::c_int;\n    pub fn clock_gettime(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;\n}\n\ncfg_if! {\n    if #[cfg(feature = \"extra_traits\")] {\n        impl PartialEq for dirent {\n            fn eq(&self, other: &dirent) -> bool {\n                self.d_ino == other.d_ino\n                    && self.d_off == other.d_off\n                    && self.d_reclen == other.d_reclen\n                    && self.d_type == other.d_type\n                    && self\n                    .d_name\n                    .iter()\n                    .zip(other.d_name.iter())\n                    .all(|(a,b)| a == b)\n            }\n        }\n\n        impl Eq for dirent {}\n\n        impl ::fmt::Debug for dirent {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"dirent\")\n                    .field(\"d_ino\", &self.d_ino)\n                    .field(\"d_off\", &self.d_off)\n                    .field(\"d_reclen\", &self.d_reclen)\n                    .field(\"d_type\", &self.d_type)\n                // FIXME: .field(\"d_name\", &self.d_name)\n                    .finish()\n            }\n        }\n\n        impl ::hash::Hash for dirent {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.d_ino.hash(state);\n                self.d_off.hash(state);\n                self.d_reclen.hash(state);\n                self.d_type.hash(state);\n                self.d_name.hash(state);\n            }\n        }\n\n        impl PartialEq for sockaddr_un {\n            fn eq(&self, other: &sockaddr_un) -> bool {\n                self.sun_family == other.sun_family\n                    && self\n                    .sun_path\n                    .iter()\n                    .zip(other.sun_path.iter())\n                    .all(|(a,b)| a == b)\n            }\n        }\n\n        impl Eq for sockaddr_un {}\n\n        impl ::fmt::Debug for sockaddr_un {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"sockaddr_un\")\n                    .field(\"sun_family\", &self.sun_family)\n                // FIXME: .field(\"sun_path\", &self.sun_path)\n                    .finish()\n            }\n        }\n\n        impl ::hash::Hash for sockaddr_un {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.sun_family.hash(state);\n                self.sun_path.hash(state);\n            }\n        }\n\n        impl PartialEq for sockaddr_storage {\n            fn eq(&self, other: &sockaddr_storage) -> bool {\n                self.ss_family == other.ss_family\n                    && self.__ss_align == self.__ss_align\n                    && self\n                    .__ss_padding\n                    .iter()\n                    .zip(other.__ss_padding.iter())\n                    .all(|(a,b)| a == b)\n            }\n        }\n\n        impl Eq for sockaddr_storage {}\n\n        impl ::fmt::Debug for sockaddr_storage {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"sockaddr_storage\")\n                    .field(\"ss_family\", &self.ss_family)\n                    .field(\"__ss_align\", &self.__ss_align)\n                // FIXME: .field(\"__ss_padding\", &self.__ss_padding)\n                    .finish()\n            }\n        }\n\n        impl ::hash::Hash for sockaddr_storage {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.ss_family.hash(state);\n                self.__ss_padding.hash(state);\n                self.__ss_align.hash(state);\n            }\n        }\n\n        impl PartialEq for utsname {\n            fn eq(&self, other: &utsname) -> bool {\n                self.sysname\n                    .iter()\n                    .zip(other.sysname.iter())\n                    .all(|(a, b)| a == b)\n                    && self\n                    .nodename\n                    .iter()\n                    .zip(other.nodename.iter())\n                    .all(|(a, b)| a == b)\n                    && self\n                    .release\n                    .iter()\n                    .zip(other.release.iter())\n                    .all(|(a, b)| a == b)\n                    && self\n                    .version\n                    .iter()\n                    .zip(other.version.iter())\n                    .all(|(a, b)| a == b)\n                    && self\n                    .machine\n                    .iter()\n                    .zip(other.machine.iter())\n                    .all(|(a, b)| a == b)\n                    && self\n                    .domainname\n                    .iter()\n                    .zip(other.domainname.iter())\n                    .all(|(a, b)| a == b)\n            }\n        }\n\n        impl Eq for utsname {}\n\n        impl ::fmt::Debug for utsname {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"utsname\")\n                // FIXME: .field(\"sysname\", &self.sysname)\n                // FIXME: .field(\"nodename\", &self.nodename)\n                // FIXME: .field(\"release\", &self.release)\n                // FIXME: .field(\"version\", &self.version)\n                // FIXME: .field(\"machine\", &self.machine)\n                // FIXME: .field(\"domainname\", &self.domainname)\n                    .finish()\n            }\n        }\n\n        impl ::hash::Hash for utsname {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.sysname.hash(state);\n                self.nodename.hash(state);\n                self.release.hash(state);\n                self.version.hash(state);\n                self.machine.hash(state);\n                self.domainname.hash(state);\n            }\n        }\n    }\n}\n"],["1138","//! Android-specific definitions for linux-like values\n\npub type clock_t = ::c_long;\npub type time_t = ::c_long;\npub type suseconds_t = ::c_long;\npub type off_t = ::c_long;\npub type blkcnt_t = ::c_ulong;\npub type blksize_t = ::c_ulong;\npub type nlink_t = u32;\npub type useconds_t = u32;\npub type pthread_t = ::c_long;\npub type pthread_mutexattr_t = ::c_long;\npub type pthread_rwlockattr_t = ::c_long;\npub type pthread_condattr_t = ::c_long;\npub type pthread_key_t = ::c_int;\npub type fsfilcnt_t = ::c_ulong;\npub type fsblkcnt_t = ::c_ulong;\npub type nfds_t = ::c_uint;\npub type rlim_t = ::c_ulong;\npub type dev_t = ::c_ulong;\npub type ino_t = ::c_ulong;\npub type ino64_t = u64;\npub type __CPU_BITTYPE = ::c_ulong;\npub type idtype_t = ::c_int;\npub type loff_t = ::c_longlong;\npub type __kernel_loff_t = ::c_longlong;\npub type __kernel_pid_t = ::c_int;\n\n// linux/elf.h\n\npub type Elf32_Addr = u32;\npub type Elf32_Half = u16;\npub type Elf32_Off = u32;\npub type Elf32_Word = u32;\n\npub type Elf64_Addr = u64;\npub type Elf64_Half = u16;\npub type Elf64_Off = u64;\npub type Elf64_Word = u32;\npub type Elf64_Xword = u64;\n\ns! {\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_flags: ::c_int,\n        pub ss_size: ::size_t\n    }\n\n    pub struct __fsid_t {\n        __val: [::c_int; 2],\n    }\n\n    pub struct msghdr {\n        pub msg_name: *mut ::c_void,\n        pub msg_namelen: ::socklen_t,\n        pub msg_iov: *mut ::iovec,\n        pub msg_iovlen: ::size_t,\n        pub msg_control: *mut ::c_void,\n        pub msg_controllen: ::size_t,\n        pub msg_flags: ::c_int,\n    }\n\n    pub struct cmsghdr {\n        pub cmsg_len: ::size_t,\n        pub cmsg_level: ::c_int,\n        pub cmsg_type: ::c_int,\n    }\n\n    pub struct termios {\n        pub c_iflag: ::tcflag_t,\n        pub c_oflag: ::tcflag_t,\n        pub c_cflag: ::tcflag_t,\n        pub c_lflag: ::tcflag_t,\n        pub c_line: ::cc_t,\n        pub c_cc: [::cc_t; ::NCCS],\n    }\n\n    pub struct termios2 {\n        pub c_iflag: ::tcflag_t,\n        pub c_oflag: ::tcflag_t,\n        pub c_cflag: ::tcflag_t,\n        pub c_lflag: ::tcflag_t,\n        pub c_line: ::cc_t,\n        pub c_cc: [::cc_t; 19],\n        pub c_ispeed: ::speed_t,\n        pub c_ospeed: ::speed_t,\n    }\n\n    pub struct flock {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off_t,\n        pub l_len: ::off_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct flock64 {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::__kernel_loff_t,\n        pub l_len: ::__kernel_loff_t,\n        pub l_pid: ::__kernel_pid_t,\n    }\n\n    pub struct cpu_set_t {\n        #[cfg(target_pointer_width = \"64\")]\n        __bits: [__CPU_BITTYPE; 16],\n        #[cfg(target_pointer_width = \"32\")]\n        __bits: [__CPU_BITTYPE; 1],\n    }\n\n    pub struct sem_t {\n        count: ::c_uint,\n        #[cfg(target_pointer_width = \"64\")]\n        __reserved: [::c_int; 3],\n    }\n\n    pub struct exit_status {\n        pub e_termination: ::c_short,\n        pub e_exit: ::c_short,\n    }\n\n    pub struct statvfs {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_favail: ::fsfilcnt_t,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        #[cfg(target_pointer_width = \"64\")]\n        __f_reserved: [u32; 6],\n    }\n\n    pub struct signalfd_siginfo {\n        pub ssi_signo: u32,\n        pub ssi_errno: i32,\n        pub ssi_code: i32,\n        pub ssi_pid: u32,\n        pub ssi_uid: u32,\n        pub ssi_fd: i32,\n        pub ssi_tid: u32,\n        pub ssi_band: u32,\n        pub ssi_overrun: u32,\n        pub ssi_trapno: u32,\n        pub ssi_status: i32,\n        pub ssi_int: i32,\n        pub ssi_ptr: ::c_ulonglong,\n        pub ssi_utime: ::c_ulonglong,\n        pub ssi_stime: ::c_ulonglong,\n        pub ssi_addr: ::c_ulonglong,\n        pub ssi_addr_lsb: u16,\n        _pad2: u16,\n        pub ssi_syscall: i32,\n        pub ssi_call_addr: u64,\n        pub ssi_arch: u32,\n        _pad: [u8; 28],\n    }\n\n    pub struct itimerspec {\n        pub it_interval: ::timespec,\n        pub it_value: ::timespec,\n    }\n\n    pub struct ucred {\n        pub pid: ::pid_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n    }\n\n    pub struct genlmsghdr {\n        pub cmd: u8,\n        pub version: u8,\n        pub reserved: u16,\n    }\n\n    pub struct nlmsghdr {\n        pub nlmsg_len: u32,\n        pub nlmsg_type: u16,\n        pub nlmsg_flags: u16,\n        pub nlmsg_seq: u32,\n        pub nlmsg_pid: u32,\n    }\n\n    pub struct nlmsgerr {\n        pub error: ::c_int,\n        pub msg: nlmsghdr,\n    }\n\n    pub struct nl_pktinfo {\n        pub group: u32,\n    }\n\n    pub struct nl_mmap_req {\n        pub nm_block_size: ::c_uint,\n        pub nm_block_nr: ::c_uint,\n        pub nm_frame_size: ::c_uint,\n        pub nm_frame_nr: ::c_uint,\n    }\n\n    pub struct nl_mmap_hdr {\n        pub nm_status: ::c_uint,\n        pub nm_len: ::c_uint,\n        pub nm_group: u32,\n        pub nm_pid: u32,\n        pub nm_uid: u32,\n        pub nm_gid: u32,\n    }\n\n    pub struct nlattr {\n        pub nla_len: u16,\n        pub nla_type: u16,\n    }\n\n    pub struct in6_pktinfo {\n        pub ipi6_addr: ::in6_addr,\n        pub ipi6_ifindex: ::c_int,\n    }\n\n    pub struct inotify_event {\n        pub wd: ::c_int,\n        pub mask: u32,\n        pub cookie: u32,\n        pub len: u32\n    }\n\n    pub struct sock_extended_err {\n        pub ee_errno: u32,\n        pub ee_origin: u8,\n        pub ee_type: u8,\n        pub ee_code: u8,\n        pub ee_pad: u8,\n        pub ee_info: u32,\n        pub ee_data: u32,\n    }\n\n    pub struct regex_t {\n        re_magic: ::c_int,\n        re_nsub: ::size_t,\n        re_endp: *const ::c_char,\n        re_guts: *mut ::c_void,\n    }\n\n    pub struct regmatch_t {\n        pub rm_so: ::ssize_t,\n        pub rm_eo: ::ssize_t,\n    }\n\n    pub struct sockaddr_vm {\n        pub svm_family: ::sa_family_t,\n        pub svm_reserved1: ::c_ushort,\n        pub svm_port: ::c_uint,\n        pub svm_cid: ::c_uint,\n        pub svm_zero: [u8; 4]\n    }\n\n    // linux/elf.h\n\n    pub struct Elf32_Phdr {\n        pub p_type: Elf32_Word,\n        pub p_offset: Elf32_Off,\n        pub p_vaddr: Elf32_Addr,\n        pub p_paddr: Elf32_Addr,\n        pub p_filesz: Elf32_Word,\n        pub p_memsz: Elf32_Word,\n        pub p_flags: Elf32_Word,\n        pub p_align: Elf32_Word,\n    }\n\n    pub struct Elf64_Phdr {\n        pub p_type: Elf64_Word,\n        pub p_flags: Elf64_Word,\n        pub p_offset: Elf64_Off,\n        pub p_vaddr: Elf64_Addr,\n        pub p_paddr: Elf64_Addr,\n        pub p_filesz: Elf64_Xword,\n        pub p_memsz: Elf64_Xword,\n        pub p_align: Elf64_Xword,\n    }\n\n    // link.h\n\n    pub struct dl_phdr_info {\n        #[cfg(target_pointer_width = \"64\")]\n        pub dlpi_addr: Elf64_Addr,\n        #[cfg(target_pointer_width = \"32\")]\n        pub dlpi_addr: Elf32_Addr,\n\n        pub dlpi_name: *const ::c_char,\n\n        #[cfg(target_pointer_width = \"64\")]\n        pub dlpi_phdr: *const Elf64_Phdr,\n        #[cfg(target_pointer_width = \"32\")]\n        pub dlpi_phdr: *const Elf32_Phdr,\n\n        #[cfg(target_pointer_width = \"64\")]\n        pub dlpi_phnum: Elf64_Half,\n        #[cfg(target_pointer_width = \"32\")]\n        pub dlpi_phnum: Elf32_Half,\n\n        // These fields were added in Android R\n        pub dlpi_adds: ::c_ulonglong,\n        pub dlpi_subs: ::c_ulonglong,\n        pub dlpi_tls_modid: ::size_t,\n        pub dlpi_tls_data: *mut ::c_void,\n    }\n}\n\ns_no_extra_traits! {\n    pub struct sockaddr_nl {\n        pub nl_family: ::sa_family_t,\n        nl_pad: ::c_ushort,\n        pub nl_pid: u32,\n        pub nl_groups: u32\n    }\n\n    pub struct dirent {\n        pub d_ino: u64,\n        pub d_off: i64,\n        pub d_reclen: ::c_ushort,\n        pub d_type: ::c_uchar,\n        pub d_name: [::c_char; 256],\n    }\n\n    pub struct dirent64 {\n        pub d_ino: u64,\n        pub d_off: i64,\n        pub d_reclen: ::c_ushort,\n        pub d_type: ::c_uchar,\n        pub d_name: [::c_char; 256],\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_errno: ::c_int,\n        pub si_code: ::c_int,\n        pub _pad: [::c_int; 29],\n        _align: [usize; 0],\n    }\n\n    pub struct lastlog {\n        ll_time: ::time_t,\n        ll_line: [::c_char; UT_LINESIZE],\n        ll_host: [::c_char; UT_HOSTSIZE],\n    }\n\n    pub struct utmp {\n        pub ut_type: ::c_short,\n        pub ut_pid: ::pid_t,\n        pub ut_line: [::c_char; UT_LINESIZE],\n        pub ut_id: [::c_char; 4],\n        pub ut_user: [::c_char; UT_NAMESIZE],\n        pub ut_host: [::c_char; UT_HOSTSIZE],\n        pub ut_exit: exit_status,\n        pub ut_session: ::c_long,\n        pub ut_tv: ::timeval,\n        pub ut_addr_v6: [i32; 4],\n        unused: [::c_char; 20],\n    }\n\n    pub struct sockaddr_alg {\n        pub salg_family: ::sa_family_t,\n        pub salg_type: [::c_uchar; 14],\n        pub salg_feat: u32,\n        pub salg_mask: u32,\n        pub salg_name: [::c_uchar; 64],\n    }\n\n    /// WARNING: The `PartialEq`, `Eq` and `Hash` implementations of this\n    /// type are unsound and will be removed in the future.\n    #[deprecated(\n        note = \"this struct has unsafe trait implementations that will be \\\n                removed in the future\",\n        since = \"0.2.80\"\n    )]\n    pub struct af_alg_iv {\n        pub ivlen: u32,\n        pub iv: [::c_uchar; 0],\n    }\n}\n\ncfg_if! {\n    if #[cfg(feature = \"extra_traits\")] {\n        impl PartialEq for sockaddr_nl {\n            fn eq(&self, other: &sockaddr_nl) -> bool {\n                self.nl_family == other.nl_family &&\n                    self.nl_pid == other.nl_pid &&\n                    self.nl_groups == other.nl_groups\n            }\n        }\n        impl Eq for sockaddr_nl {}\n        impl ::fmt::Debug for sockaddr_nl {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"sockaddr_nl\")\n                    .field(\"nl_family\", &self.nl_family)\n                    .field(\"nl_pid\", &self.nl_pid)\n                    .field(\"nl_groups\", &self.nl_groups)\n                    .finish()\n            }\n        }\n        impl ::hash::Hash for sockaddr_nl {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.nl_family.hash(state);\n                self.nl_pid.hash(state);\n                self.nl_groups.hash(state);\n            }\n        }\n\n        impl PartialEq for dirent {\n            fn eq(&self, other: &dirent) -> bool {\n                self.d_ino == other.d_ino\n                    && self.d_off == other.d_off\n                    && self.d_reclen == other.d_reclen\n                    && self.d_type == other.d_type\n                    && self\n                    .d_name\n                    .iter()\n                    .zip(other.d_name.iter())\n                    .all(|(a,b)| a == b)\n            }\n        }\n\n        impl Eq for dirent {}\n\n        impl ::fmt::Debug for dirent {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"dirent\")\n                    .field(\"d_ino\", &self.d_ino)\n                    .field(\"d_off\", &self.d_off)\n                    .field(\"d_reclen\", &self.d_reclen)\n                    .field(\"d_type\", &self.d_type)\n                // FIXME: .field(\"d_name\", &self.d_name)\n                    .finish()\n            }\n        }\n\n        impl ::hash::Hash for dirent {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.d_ino.hash(state);\n                self.d_off.hash(state);\n                self.d_reclen.hash(state);\n                self.d_type.hash(state);\n                self.d_name.hash(state);\n            }\n        }\n\n        impl PartialEq for dirent64 {\n            fn eq(&self, other: &dirent64) -> bool {\n                self.d_ino == other.d_ino\n                    && self.d_off == other.d_off\n                    && self.d_reclen == other.d_reclen\n                    && self.d_type == other.d_type\n                    && self\n                    .d_name\n                    .iter()\n                    .zip(other.d_name.iter())\n                    .all(|(a,b)| a == b)\n            }\n        }\n\n        impl Eq for dirent64 {}\n\n        impl ::fmt::Debug for dirent64 {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"dirent64\")\n                    .field(\"d_ino\", &self.d_ino)\n                    .field(\"d_off\", &self.d_off)\n                    .field(\"d_reclen\", &self.d_reclen)\n                    .field(\"d_type\", &self.d_type)\n                // FIXME: .field(\"d_name\", &self.d_name)\n                    .finish()\n            }\n        }\n\n        impl ::hash::Hash for dirent64 {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.d_ino.hash(state);\n                self.d_off.hash(state);\n                self.d_reclen.hash(state);\n                self.d_type.hash(state);\n                self.d_name.hash(state);\n            }\n        }\n\n        impl PartialEq for siginfo_t {\n            fn eq(&self, other: &siginfo_t) -> bool {\n                self.si_signo == other.si_signo\n                    && self.si_errno == other.si_errno\n                    && self.si_code == other.si_code\n                // Ignore _pad\n                // Ignore _align\n            }\n        }\n\n        impl Eq for siginfo_t {}\n\n        impl ::fmt::Debug for siginfo_t {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"siginfo_t\")\n                    .field(\"si_signo\", &self.si_signo)\n                    .field(\"si_errno\", &self.si_errno)\n                    .field(\"si_code\", &self.si_code)\n                // Ignore _pad\n                // Ignore _align\n                    .finish()\n            }\n        }\n\n        impl ::hash::Hash for siginfo_t {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.si_signo.hash(state);\n                self.si_errno.hash(state);\n                self.si_code.hash(state);\n                // Ignore _pad\n                // Ignore _align\n            }\n        }\n\n        impl PartialEq for lastlog {\n            fn eq(&self, other: &lastlog) -> bool {\n                self.ll_time == other.ll_time\n                    && self\n                    .ll_line\n                    .iter()\n                    .zip(other.ll_line.iter())\n                    .all(|(a,b)| a == b)\n                    && self\n                    .ll_host\n                    .iter()\n                    .zip(other.ll_host.iter())\n                    .all(|(a,b)| a == b)\n            }\n        }\n\n        impl Eq for lastlog {}\n\n        impl ::fmt::Debug for lastlog {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"lastlog\")\n                    .field(\"ll_time\", &self.ll_time)\n                    .field(\"ll_line\", &self.ll_line)\n                // FIXME: .field(\"ll_host\", &self.ll_host)\n                    .finish()\n            }\n        }\n\n        impl ::hash::Hash for lastlog {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.ll_time.hash(state);\n                self.ll_line.hash(state);\n                self.ll_host.hash(state);\n            }\n        }\n\n        impl PartialEq for utmp {\n            fn eq(&self, other: &utmp) -> bool {\n                self.ut_type == other.ut_type\n                    && self.ut_pid == other.ut_pid\n                    && self\n                    .ut_line\n                    .iter()\n                    .zip(other.ut_line.iter())\n                    .all(|(a,b)| a == b)\n                    && self.ut_id == other.ut_id\n                    && self\n                    .ut_user\n                    .iter()\n                    .zip(other.ut_user.iter())\n                    .all(|(a,b)| a == b)\n                    && self\n                    .ut_host\n                    .iter()\n                    .zip(other.ut_host.iter())\n                    .all(|(a,b)| a == b)\n                    && self.ut_exit == other.ut_exit\n                    && self.ut_session == other.ut_session\n                    && self.ut_tv == other.ut_tv\n                    && self.ut_addr_v6 == other.ut_addr_v6\n                    && self.unused == other.unused\n            }\n        }\n\n        impl Eq for utmp {}\n\n        impl ::fmt::Debug for utmp {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"utmp\")\n                    .field(\"ut_type\", &self.ut_type)\n                    .field(\"ut_pid\", &self.ut_pid)\n                    .field(\"ut_line\", &self.ut_line)\n                    .field(\"ut_id\", &self.ut_id)\n                    .field(\"ut_user\", &self.ut_user)\n                // FIXME: .field(\"ut_host\", &self.ut_host)\n                    .field(\"ut_exit\", &self.ut_exit)\n                    .field(\"ut_session\", &self.ut_session)\n                    .field(\"ut_tv\", &self.ut_tv)\n                    .field(\"ut_addr_v6\", &self.ut_addr_v6)\n                    .field(\"unused\", &self.unused)\n                    .finish()\n            }\n        }\n\n        impl ::hash::Hash for utmp {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.ut_type.hash(state);\n                self.ut_pid.hash(state);\n                self.ut_line.hash(state);\n                self.ut_id.hash(state);\n                self.ut_user.hash(state);\n                self.ut_host.hash(state);\n                self.ut_exit.hash(state);\n                self.ut_session.hash(state);\n                self.ut_tv.hash(state);\n                self.ut_addr_v6.hash(state);\n                self.unused.hash(state);\n            }\n        }\n\n        impl PartialEq for sockaddr_alg {\n            fn eq(&self, other: &sockaddr_alg) -> bool {\n                self.salg_family == other.salg_family\n                    && self\n                    .salg_type\n                    .iter()\n                    .zip(other.salg_type.iter())\n                    .all(|(a, b)| a == b)\n                    && self.salg_feat == other.salg_feat\n                    && self.salg_mask == other.salg_mask\n                    && self\n                    .salg_name\n                    .iter()\n                    .zip(other.salg_name.iter())\n                    .all(|(a, b)| a == b)\n           }\n        }\n\n        impl Eq for sockaddr_alg {}\n\n        impl ::fmt::Debug for sockaddr_alg {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"sockaddr_alg\")\n                    .field(\"salg_family\", &self.salg_family)\n                    .field(\"salg_type\", &self.salg_type)\n                    .field(\"salg_feat\", &self.salg_feat)\n                    .field(\"salg_mask\", &self.salg_mask)\n                    .field(\"salg_name\", &&self.salg_name[..])\n                    .finish()\n            }\n        }\n\n        impl ::hash::Hash for sockaddr_alg {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.salg_family.hash(state);\n                self.salg_type.hash(state);\n                self.salg_feat.hash(state);\n                self.salg_mask.hash(state);\n                self.salg_name.hash(state);\n            }\n        }\n\n        #[allow(deprecated)]\n        impl af_alg_iv {\n            fn as_slice(&self) -> &[u8] {\n                unsafe {\n                    ::core::slice::from_raw_parts(\n                        self.iv.as_ptr(),\n                        self.ivlen as usize\n                    )\n                }\n            }\n        }\n\n        #[allow(deprecated)]\n        impl PartialEq for af_alg_iv {\n            fn eq(&self, other: &af_alg_iv) -> bool {\n                *self.as_slice() == *other.as_slice()\n           }\n        }\n\n        #[allow(deprecated)]\n        impl Eq for af_alg_iv {}\n\n        #[allow(deprecated)]\n        impl ::fmt::Debug for af_alg_iv {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"af_alg_iv\")\n                    .field(\"ivlen\", &self.ivlen)\n                    .finish()\n            }\n        }\n\n        #[allow(deprecated)]\n        impl ::hash::Hash for af_alg_iv {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.as_slice().hash(state);\n            }\n        }\n    }\n}\n\npub const MADV_SOFT_OFFLINE: ::c_int = 101;\npub const MS_NOUSER: ::c_ulong = 0xffffffff80000000;\npub const MS_RMT_MASK: ::c_ulong = 0x02800051;\n\npub const O_TRUNC: ::c_int = 512;\npub const O_CLOEXEC: ::c_int = 0x80000;\npub const O_PATH: ::c_int = 0o10000000;\npub const O_NOATIME: ::c_int = 0o1000000;\n\npub const EBFONT: ::c_int = 59;\npub const ENOSTR: ::c_int = 60;\npub const ENODATA: ::c_int = 61;\npub const ETIME: ::c_int = 62;\npub const ENOSR: ::c_int = 63;\npub const ENONET: ::c_int = 64;\npub const ENOPKG: ::c_int = 65;\npub const EREMOTE: ::c_int = 66;\npub const ENOLINK: ::c_int = 67;\npub const EADV: ::c_int = 68;\npub const ESRMNT: ::c_int = 69;\npub const ECOMM: ::c_int = 70;\npub const EPROTO: ::c_int = 71;\npub const EDOTDOT: ::c_int = 73;\n\npub const EPOLL_CLOEXEC: ::c_int = 0x80000;\npub const EPOLLONESHOT: ::c_int = 0x40000000;\npub const EPOLLRDHUP: ::c_int = 0x00002000;\npub const EPOLLWAKEUP: ::c_int = 0x20000000;\n\n// sys/eventfd.h\npub const EFD_SEMAPHORE: ::c_int = 0x1;\npub const EFD_CLOEXEC: ::c_int = O_CLOEXEC;\npub const EFD_NONBLOCK: ::c_int = O_NONBLOCK;\n\n// sys/timerfd.h\npub const TFD_CLOEXEC: ::c_int = O_CLOEXEC;\npub const TFD_NONBLOCK: ::c_int = O_NONBLOCK;\npub const TFD_TIMER_ABSTIME: ::c_int = 1;\npub const TFD_TIMER_CANCEL_ON_SET: ::c_int = 2;\n\npub const USER_PROCESS: ::c_short = 7;\n\n// linux/falloc.h\npub const FALLOC_FL_KEEP_SIZE: ::c_int = 0x01;\npub const FALLOC_FL_PUNCH_HOLE: ::c_int = 0x02;\npub const FALLOC_FL_NO_HIDE_STALE: ::c_int = 0x04;\npub const FALLOC_FL_COLLAPSE_RANGE: ::c_int = 0x08;\npub const FALLOC_FL_ZERO_RANGE: ::c_int = 0x10;\npub const FALLOC_FL_INSERT_RANGE: ::c_int = 0x20;\npub const FALLOC_FL_UNSHARE_RANGE: ::c_int = 0x40;\n\npub const BUFSIZ: ::c_uint = 1024;\npub const FILENAME_MAX: ::c_uint = 4096;\npub const FOPEN_MAX: ::c_uint = 20;\npub const POSIX_FADV_DONTNEED: ::c_int = 4;\npub const POSIX_FADV_NOREUSE: ::c_int = 5;\npub const L_tmpnam: ::c_uint = 4096;\npub const TMP_MAX: ::c_uint = 308915776;\npub const _PC_LINK_MAX: ::c_int = 1;\npub const _PC_MAX_CANON: ::c_int = 2;\npub const _PC_MAX_INPUT: ::c_int = 3;\npub const _PC_NAME_MAX: ::c_int = 4;\npub const _PC_PATH_MAX: ::c_int = 5;\npub const _PC_PIPE_BUF: ::c_int = 6;\npub const _PC_2_SYMLINKS: ::c_int = 7;\npub const _PC_ALLOC_SIZE_MIN: ::c_int = 8;\npub const _PC_REC_INCR_XFER_SIZE: ::c_int = 9;\npub const _PC_REC_MAX_XFER_SIZE: ::c_int = 10;\npub const _PC_REC_MIN_XFER_SIZE: ::c_int = 11;\npub const _PC_REC_XFER_ALIGN: ::c_int = 12;\npub const _PC_SYMLINK_MAX: ::c_int = 13;\npub const _PC_CHOWN_RESTRICTED: ::c_int = 14;\npub const _PC_NO_TRUNC: ::c_int = 15;\npub const _PC_VDISABLE: ::c_int = 16;\npub const _PC_ASYNC_IO: ::c_int = 17;\npub const _PC_PRIO_IO: ::c_int = 18;\npub const _PC_SYNC_IO: ::c_int = 19;\n\npub const FIONBIO: ::c_int = 0x5421;\n\npub const _SC_ARG_MAX: ::c_int = 0;\npub const _SC_BC_BASE_MAX: ::c_int = 1;\npub const _SC_BC_DIM_MAX: ::c_int = 2;\npub const _SC_BC_SCALE_MAX: ::c_int = 3;\npub const _SC_BC_STRING_MAX: ::c_int = 4;\npub const _SC_CHILD_MAX: ::c_int = 5;\npub const _SC_CLK_TCK: ::c_int = 6;\npub const _SC_COLL_WEIGHTS_MAX: ::c_int = 7;\npub const _SC_EXPR_NEST_MAX: ::c_int = 8;\npub const _SC_LINE_MAX: ::c_int = 9;\npub const _SC_NGROUPS_MAX: ::c_int = 10;\npub const _SC_OPEN_MAX: ::c_int = 11;\npub const _SC_PASS_MAX: ::c_int = 12;\npub const _SC_2_C_BIND: ::c_int = 13;\npub const _SC_2_C_DEV: ::c_int = 14;\npub const _SC_2_C_VERSION: ::c_int = 15;\npub const _SC_2_CHAR_TERM: ::c_int = 16;\npub const _SC_2_FORT_DEV: ::c_int = 17;\npub const _SC_2_FORT_RUN: ::c_int = 18;\npub const _SC_2_LOCALEDEF: ::c_int = 19;\npub const _SC_2_SW_DEV: ::c_int = 20;\npub const _SC_2_UPE: ::c_int = 21;\npub const _SC_2_VERSION: ::c_int = 22;\npub const _SC_JOB_CONTROL: ::c_int = 23;\npub const _SC_SAVED_IDS: ::c_int = 24;\npub const _SC_VERSION: ::c_int = 25;\npub const _SC_RE_DUP_MAX: ::c_int = 26;\npub const _SC_STREAM_MAX: ::c_int = 27;\npub const _SC_TZNAME_MAX: ::c_int = 28;\npub const _SC_XOPEN_CRYPT: ::c_int = 29;\npub const _SC_XOPEN_ENH_I18N: ::c_int = 30;\npub const _SC_XOPEN_SHM: ::c_int = 31;\npub const _SC_XOPEN_VERSION: ::c_int = 32;\npub const _SC_XOPEN_XCU_VERSION: ::c_int = 33;\npub const _SC_XOPEN_REALTIME: ::c_int = 34;\npub const _SC_XOPEN_REALTIME_THREADS: ::c_int = 35;\npub const _SC_XOPEN_LEGACY: ::c_int = 36;\npub const _SC_ATEXIT_MAX: ::c_int = 37;\npub const _SC_IOV_MAX: ::c_int = 38;\npub const _SC_PAGESIZE: ::c_int = 39;\npub const _SC_PAGE_SIZE: ::c_int = 40;\npub const _SC_XOPEN_UNIX: ::c_int = 41;\npub const _SC_XBS5_ILP32_OFF32: ::c_int = 42;\npub const _SC_XBS5_ILP32_OFFBIG: ::c_int = 43;\npub const _SC_XBS5_LP64_OFF64: ::c_int = 44;\npub const _SC_XBS5_LPBIG_OFFBIG: ::c_int = 45;\npub const _SC_AIO_LISTIO_MAX: ::c_int = 46;\npub const _SC_AIO_MAX: ::c_int = 47;\npub const _SC_AIO_PRIO_DELTA_MAX: ::c_int = 48;\npub const _SC_DELAYTIMER_MAX: ::c_int = 49;\npub const _SC_MQ_OPEN_MAX: ::c_int = 50;\npub const _SC_MQ_PRIO_MAX: ::c_int = 51;\npub const _SC_RTSIG_MAX: ::c_int = 52;\npub const _SC_SEM_NSEMS_MAX: ::c_int = 53;\npub const _SC_SEM_VALUE_MAX: ::c_int = 54;\npub const _SC_SIGQUEUE_MAX: ::c_int = 55;\npub const _SC_TIMER_MAX: ::c_int = 56;\npub const _SC_ASYNCHRONOUS_IO: ::c_int = 57;\npub const _SC_FSYNC: ::c_int = 58;\npub const _SC_MAPPED_FILES: ::c_int = 59;\npub const _SC_MEMLOCK: ::c_int = 60;\npub const _SC_MEMLOCK_RANGE: ::c_int = 61;\npub const _SC_MEMORY_PROTECTION: ::c_int = 62;\npub const _SC_MESSAGE_PASSING: ::c_int = 63;\npub const _SC_PRIORITIZED_IO: ::c_int = 64;\npub const _SC_PRIORITY_SCHEDULING: ::c_int = 65;\npub const _SC_REALTIME_SIGNALS: ::c_int = 66;\npub const _SC_SEMAPHORES: ::c_int = 67;\npub const _SC_SHARED_MEMORY_OBJECTS: ::c_int = 68;\npub const _SC_SYNCHRONIZED_IO: ::c_int = 69;\npub const _SC_TIMERS: ::c_int = 70;\npub const _SC_GETGR_R_SIZE_MAX: ::c_int = 71;\npub const _SC_GETPW_R_SIZE_MAX: ::c_int = 72;\npub const _SC_LOGIN_NAME_MAX: ::c_int = 73;\npub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::c_int = 74;\npub const _SC_THREAD_KEYS_MAX: ::c_int = 75;\npub const _SC_THREAD_STACK_MIN: ::c_int = 76;\npub const _SC_THREAD_THREADS_MAX: ::c_int = 77;\npub const _SC_TTY_NAME_MAX: ::c_int = 78;\npub const _SC_THREADS: ::c_int = 79;\npub const _SC_THREAD_ATTR_STACKADDR: ::c_int = 80;\npub const _SC_THREAD_ATTR_STACKSIZE: ::c_int = 81;\npub const _SC_THREAD_PRIORITY_SCHEDULING: ::c_int = 82;\npub const _SC_THREAD_PRIO_INHERIT: ::c_int = 83;\npub const _SC_THREAD_PRIO_PROTECT: ::c_int = 84;\npub const _SC_THREAD_SAFE_FUNCTIONS: ::c_int = 85;\npub const _SC_NPROCESSORS_CONF: ::c_int = 96;\npub const _SC_NPROCESSORS_ONLN: ::c_int = 97;\npub const _SC_PHYS_PAGES: ::c_int = 98;\npub const _SC_AVPHYS_PAGES: ::c_int = 99;\npub const _SC_MONOTONIC_CLOCK: ::c_int = 100;\n\npub const _SC_2_PBS: ::c_int = 101;\npub const _SC_2_PBS_ACCOUNTING: ::c_int = 102;\npub const _SC_2_PBS_CHECKPOINT: ::c_int = 103;\npub const _SC_2_PBS_LOCATE: ::c_int = 104;\npub const _SC_2_PBS_MESSAGE: ::c_int = 105;\npub const _SC_2_PBS_TRACK: ::c_int = 106;\npub const _SC_ADVISORY_INFO: ::c_int = 107;\npub const _SC_BARRIERS: ::c_int = 108;\npub const _SC_CLOCK_SELECTION: ::c_int = 109;\npub const _SC_CPUTIME: ::c_int = 110;\npub const _SC_HOST_NAME_MAX: ::c_int = 111;\npub const _SC_IPV6: ::c_int = 112;\npub const _SC_RAW_SOCKETS: ::c_int = 113;\npub const _SC_READER_WRITER_LOCKS: ::c_int = 114;\npub const _SC_REGEXP: ::c_int = 115;\npub const _SC_SHELL: ::c_int = 116;\npub const _SC_SPAWN: ::c_int = 117;\npub const _SC_SPIN_LOCKS: ::c_int = 118;\npub const _SC_SPORADIC_SERVER: ::c_int = 119;\npub const _SC_SS_REPL_MAX: ::c_int = 120;\npub const _SC_SYMLOOP_MAX: ::c_int = 121;\npub const _SC_THREAD_CPUTIME: ::c_int = 122;\npub const _SC_THREAD_PROCESS_SHARED: ::c_int = 123;\npub const _SC_THREAD_ROBUST_PRIO_INHERIT: ::c_int = 124;\npub const _SC_THREAD_ROBUST_PRIO_PROTECT: ::c_int = 125;\npub const _SC_THREAD_SPORADIC_SERVER: ::c_int = 126;\npub const _SC_TIMEOUTS: ::c_int = 127;\npub const _SC_TRACE: ::c_int = 128;\npub const _SC_TRACE_EVENT_FILTER: ::c_int = 129;\npub const _SC_TRACE_EVENT_NAME_MAX: ::c_int = 130;\npub const _SC_TRACE_INHERIT: ::c_int = 131;\npub const _SC_TRACE_LOG: ::c_int = 132;\npub const _SC_TRACE_NAME_MAX: ::c_int = 133;\npub const _SC_TRACE_SYS_MAX: ::c_int = 134;\npub const _SC_TRACE_USER_EVENT_MAX: ::c_int = 135;\npub const _SC_TYPED_MEMORY_OBJECTS: ::c_int = 136;\npub const _SC_V7_ILP32_OFF32: ::c_int = 137;\npub const _SC_V7_ILP32_OFFBIG: ::c_int = 138;\npub const _SC_V7_LP64_OFF64: ::c_int = 139;\npub const _SC_V7_LPBIG_OFFBIG: ::c_int = 140;\npub const _SC_XOPEN_STREAMS: ::c_int = 141;\npub const _SC_XOPEN_UUCP: ::c_int = 142;\n\npub const F_LOCK: ::c_int = 1;\npub const F_TEST: ::c_int = 3;\npub const F_TLOCK: ::c_int = 2;\npub const F_ULOCK: ::c_int = 0;\n\npub const PTHREAD_MUTEX_NORMAL: ::c_int = 0;\npub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 1;\npub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = 2;\npub const PTHREAD_MUTEX_DEFAULT: ::c_int = PTHREAD_MUTEX_NORMAL;\n\n// stdio.h\npub const RENAME_NOREPLACE: ::c_int = 1;\npub const RENAME_EXCHANGE: ::c_int = 2;\npub const RENAME_WHITEOUT: ::c_int = 4;\n\npub const FIOCLEX: ::c_int = 0x5451;\npub const FIONCLEX: ::c_int = 0x5450;\n\npub const SIGCHLD: ::c_int = 17;\npub const SIGBUS: ::c_int = 7;\npub const SIGUSR1: ::c_int = 10;\npub const SIGUSR2: ::c_int = 12;\npub const SIGCONT: ::c_int = 18;\npub const SIGSTOP: ::c_int = 19;\npub const SIGTSTP: ::c_int = 20;\npub const SIGURG: ::c_int = 23;\npub const SIGIO: ::c_int = 29;\npub const SIGSYS: ::c_int = 31;\npub const SIGSTKFLT: ::c_int = 16;\n#[deprecated(since = \"0.2.55\", note = \"Use SIGSYS instead\")]\npub const SIGUNUSED: ::c_int = 31;\npub const SIGTTIN: ::c_int = 21;\npub const SIGTTOU: ::c_int = 22;\npub const SIGXCPU: ::c_int = 24;\npub const SIGXFSZ: ::c_int = 25;\npub const SIGVTALRM: ::c_int = 26;\npub const SIGPROF: ::c_int = 27;\npub const SIGWINCH: ::c_int = 28;\npub const SIGPOLL: ::c_int = 29;\npub const SIGPWR: ::c_int = 30;\npub const SIG_SETMASK: ::c_int = 2;\npub const SIG_BLOCK: ::c_int = 0x000000;\npub const SIG_UNBLOCK: ::c_int = 0x01;\n\npub const RUSAGE_CHILDREN: ::c_int = -1;\n\npub const LC_PAPER: ::c_int = 7;\npub const LC_NAME: ::c_int = 8;\npub const LC_ADDRESS: ::c_int = 9;\npub const LC_TELEPHONE: ::c_int = 10;\npub const LC_MEASUREMENT: ::c_int = 11;\npub const LC_IDENTIFICATION: ::c_int = 12;\npub const LC_PAPER_MASK: ::c_int = 1 << LC_PAPER;\npub const LC_NAME_MASK: ::c_int = 1 << LC_NAME;\npub const LC_ADDRESS_MASK: ::c_int = 1 << LC_ADDRESS;\npub const LC_TELEPHONE_MASK: ::c_int = 1 << LC_TELEPHONE;\npub const LC_MEASUREMENT_MASK: ::c_int = 1 << LC_MEASUREMENT;\npub const LC_IDENTIFICATION_MASK: ::c_int = 1 << LC_IDENTIFICATION;\npub const LC_ALL_MASK: ::c_int = ::LC_CTYPE_MASK\n    | ::LC_NUMERIC_MASK\n    | ::LC_TIME_MASK\n    | ::LC_COLLATE_MASK\n    | ::LC_MONETARY_MASK\n    | ::LC_MESSAGES_MASK\n    | LC_PAPER_MASK\n    | LC_NAME_MASK\n    | LC_ADDRESS_MASK\n    | LC_TELEPHONE_MASK\n    | LC_MEASUREMENT_MASK\n    | LC_IDENTIFICATION_MASK;\n\npub const MAP_ANON: ::c_int = 0x0020;\npub const MAP_ANONYMOUS: ::c_int = 0x0020;\npub const MAP_GROWSDOWN: ::c_int = 0x0100;\npub const MAP_DENYWRITE: ::c_int = 0x0800;\npub const MAP_EXECUTABLE: ::c_int = 0x01000;\npub const MAP_LOCKED: ::c_int = 0x02000;\npub const MAP_NORESERVE: ::c_int = 0x04000;\npub const MAP_POPULATE: ::c_int = 0x08000;\npub const MAP_NONBLOCK: ::c_int = 0x010000;\npub const MAP_STACK: ::c_int = 0x020000;\n\npub const EDEADLK: ::c_int = 35;\npub const ENAMETOOLONG: ::c_int = 36;\npub const ENOLCK: ::c_int = 37;\npub const ENOSYS: ::c_int = 38;\npub const ENOTEMPTY: ::c_int = 39;\npub const ELOOP: ::c_int = 40;\npub const ENOMSG: ::c_int = 42;\npub const EIDRM: ::c_int = 43;\npub const ECHRNG: ::c_int = 44;\npub const EL2NSYNC: ::c_int = 45;\npub const EL3HLT: ::c_int = 46;\npub const EL3RST: ::c_int = 47;\npub const ELNRNG: ::c_int = 48;\npub const EUNATCH: ::c_int = 49;\npub const ENOCSI: ::c_int = 50;\npub const EL2HLT: ::c_int = 51;\npub const EBADE: ::c_int = 52;\npub const EBADR: ::c_int = 53;\npub const EXFULL: ::c_int = 54;\npub const ENOANO: ::c_int = 55;\npub const EBADRQC: ::c_int = 56;\npub const EBADSLT: ::c_int = 57;\n\npub const EMULTIHOP: ::c_int = 72;\npub const EBADMSG: ::c_int = 74;\npub const EOVERFLOW: ::c_int = 75;\npub const ENOTUNIQ: ::c_int = 76;\npub const EBADFD: ::c_int = 77;\npub const EREMCHG: ::c_int = 78;\npub const ELIBACC: ::c_int = 79;\npub const ELIBBAD: ::c_int = 80;\npub const ELIBSCN: ::c_int = 81;\npub const ELIBMAX: ::c_int = 82;\npub const ELIBEXEC: ::c_int = 83;\npub const EILSEQ: ::c_int = 84;\npub const ERESTART: ::c_int = 85;\npub const ESTRPIPE: ::c_int = 86;\npub const EUSERS: ::c_int = 87;\npub const ENOTSOCK: ::c_int = 88;\npub const EDESTADDRREQ: ::c_int = 89;\npub const EMSGSIZE: ::c_int = 90;\npub const EPROTOTYPE: ::c_int = 91;\npub const ENOPROTOOPT: ::c_int = 92;\npub const EPROTONOSUPPORT: ::c_int = 93;\npub const ESOCKTNOSUPPORT: ::c_int = 94;\npub const EOPNOTSUPP: ::c_int = 95;\npub const ENOTSUP: ::c_int = EOPNOTSUPP;\npub const EPFNOSUPPORT: ::c_int = 96;\npub const EAFNOSUPPORT: ::c_int = 97;\npub const EADDRINUSE: ::c_int = 98;\npub const EADDRNOTAVAIL: ::c_int = 99;\npub const ENETDOWN: ::c_int = 100;\npub const ENETUNREACH: ::c_int = 101;\npub const ENETRESET: ::c_int = 102;\npub const ECONNABORTED: ::c_int = 103;\npub const ECONNRESET: ::c_int = 104;\npub const ENOBUFS: ::c_int = 105;\npub const EISCONN: ::c_int = 106;\npub const ENOTCONN: ::c_int = 107;\npub const ESHUTDOWN: ::c_int = 108;\npub const ETOOMANYREFS: ::c_int = 109;\npub const ETIMEDOUT: ::c_int = 110;\npub const ECONNREFUSED: ::c_int = 111;\npub const EHOSTDOWN: ::c_int = 112;\npub const EHOSTUNREACH: ::c_int = 113;\npub const EALREADY: ::c_int = 114;\npub const EINPROGRESS: ::c_int = 115;\npub const ESTALE: ::c_int = 116;\npub const EUCLEAN: ::c_int = 117;\npub const ENOTNAM: ::c_int = 118;\npub const ENAVAIL: ::c_int = 119;\npub const EISNAM: ::c_int = 120;\npub const EREMOTEIO: ::c_int = 121;\npub const EDQUOT: ::c_int = 122;\npub const ENOMEDIUM: ::c_int = 123;\npub const EMEDIUMTYPE: ::c_int = 124;\npub const ECANCELED: ::c_int = 125;\npub const ENOKEY: ::c_int = 126;\npub const EKEYEXPIRED: ::c_int = 127;\npub const EKEYREVOKED: ::c_int = 128;\npub const EKEYREJECTED: ::c_int = 129;\npub const EOWNERDEAD: ::c_int = 130;\npub const ENOTRECOVERABLE: ::c_int = 131;\n\npub const SOCK_STREAM: ::c_int = 1;\npub const SOCK_DGRAM: ::c_int = 2;\npub const SOCK_SEQPACKET: ::c_int = 5;\npub const SOCK_DCCP: ::c_int = 6;\npub const SOCK_PACKET: ::c_int = 10;\n\npub const IPPROTO_MAX: ::c_int = 256;\n\npub const SOL_SOCKET: ::c_int = 1;\npub const SOL_SCTP: ::c_int = 132;\npub const SOL_IPX: ::c_int = 256;\npub const SOL_AX25: ::c_int = 257;\npub const SOL_ATALK: ::c_int = 258;\npub const SOL_NETROM: ::c_int = 259;\npub const SOL_ROSE: ::c_int = 260;\n\n/* DCCP socket options */\npub const DCCP_SOCKOPT_PACKET_SIZE: ::c_int = 1;\npub const DCCP_SOCKOPT_SERVICE: ::c_int = 2;\npub const DCCP_SOCKOPT_CHANGE_L: ::c_int = 3;\npub const DCCP_SOCKOPT_CHANGE_R: ::c_int = 4;\npub const DCCP_SOCKOPT_GET_CUR_MPS: ::c_int = 5;\npub const DCCP_SOCKOPT_SERVER_TIMEWAIT: ::c_int = 6;\npub const DCCP_SOCKOPT_SEND_CSCOV: ::c_int = 10;\npub const DCCP_SOCKOPT_RECV_CSCOV: ::c_int = 11;\npub const DCCP_SOCKOPT_AVAILABLE_CCIDS: ::c_int = 12;\npub const DCCP_SOCKOPT_CCID: ::c_int = 13;\npub const DCCP_SOCKOPT_TX_CCID: ::c_int = 14;\npub const DCCP_SOCKOPT_RX_CCID: ::c_int = 15;\npub const DCCP_SOCKOPT_QPOLICY_ID: ::c_int = 16;\npub const DCCP_SOCKOPT_QPOLICY_TXQLEN: ::c_int = 17;\npub const DCCP_SOCKOPT_CCID_RX_INFO: ::c_int = 128;\npub const DCCP_SOCKOPT_CCID_TX_INFO: ::c_int = 192;\n\n/// maximum number of services provided on the same listening port\npub const DCCP_SERVICE_LIST_MAX_LEN: ::c_int = 32;\n\npub const SO_REUSEADDR: ::c_int = 2;\npub const SO_TYPE: ::c_int = 3;\npub const SO_ERROR: ::c_int = 4;\npub const SO_DONTROUTE: ::c_int = 5;\npub const SO_BROADCAST: ::c_int = 6;\npub const SO_SNDBUF: ::c_int = 7;\npub const SO_RCVBUF: ::c_int = 8;\npub const SO_KEEPALIVE: ::c_int = 9;\npub const SO_OOBINLINE: ::c_int = 10;\npub const SO_PRIORITY: ::c_int = 12;\npub const SO_LINGER: ::c_int = 13;\npub const SO_BSDCOMPAT: ::c_int = 14;\npub const SO_REUSEPORT: ::c_int = 15;\npub const SO_PASSCRED: ::c_int = 16;\npub const SO_PEERCRED: ::c_int = 17;\npub const SO_RCVLOWAT: ::c_int = 18;\npub const SO_SNDLOWAT: ::c_int = 19;\npub const SO_RCVTIMEO: ::c_int = 20;\npub const SO_SNDTIMEO: ::c_int = 21;\npub const SO_BINDTODEVICE: ::c_int = 25;\npub const SO_TIMESTAMP: ::c_int = 29;\npub const SO_ACCEPTCONN: ::c_int = 30;\npub const SO_PEERSEC: ::c_int = 31;\npub const SO_SNDBUFFORCE: ::c_int = 32;\npub const SO_RCVBUFFORCE: ::c_int = 33;\npub const SO_PASSSEC: ::c_int = 34;\npub const SO_MARK: ::c_int = 36;\npub const SO_PROTOCOL: ::c_int = 38;\npub const SO_DOMAIN: ::c_int = 39;\npub const SO_RXQ_OVFL: ::c_int = 40;\npub const SO_PEEK_OFF: ::c_int = 42;\npub const SO_BUSY_POLL: ::c_int = 46;\n\npub const IPTOS_ECN_NOTECT: u8 = 0x00;\n\npub const O_ACCMODE: ::c_int = 3;\npub const O_APPEND: ::c_int = 1024;\npub const O_CREAT: ::c_int = 64;\npub const O_EXCL: ::c_int = 128;\npub const O_NOCTTY: ::c_int = 256;\npub const O_NONBLOCK: ::c_int = 2048;\npub const O_SYNC: ::c_int = 0x101000;\npub const O_ASYNC: ::c_int = 0x2000;\npub const O_NDELAY: ::c_int = 0x800;\npub const O_DSYNC: ::c_int = 4096;\npub const O_RSYNC: ::c_int = O_SYNC;\n\npub const NI_MAXHOST: ::size_t = 1025;\npub const NI_MAXSERV: ::size_t = 32;\n\npub const NI_NOFQDN: ::c_int = 0x00000001;\npub const NI_NUMERICHOST: ::c_int = 0x00000002;\npub const NI_NAMEREQD: ::c_int = 0x00000004;\npub const NI_NUMERICSERV: ::c_int = 0x00000008;\npub const NI_DGRAM: ::c_int = 0x00000010;\n\npub const NCCS: usize = 19;\npub const TCSBRKP: ::c_int = 0x5425;\npub const TCSANOW: ::c_int = 0;\npub const TCSADRAIN: ::c_int = 0x1;\npub const TCSAFLUSH: ::c_int = 0x2;\npub const VEOF: usize = 4;\npub const VEOL: usize = 11;\npub const VEOL2: usize = 16;\npub const VMIN: usize = 6;\npub const IEXTEN: ::tcflag_t = 0x00008000;\npub const TOSTOP: ::tcflag_t = 0x00000100;\npub const FLUSHO: ::tcflag_t = 0x00001000;\npub const EXTPROC: ::tcflag_t = 0o200000;\n\npub const ADFS_SUPER_MAGIC: ::c_long = 0x0000adf5;\npub const AFFS_SUPER_MAGIC: ::c_long = 0x0000adff;\npub const CODA_SUPER_MAGIC: ::c_long = 0x73757245;\npub const CRAMFS_MAGIC: ::c_long = 0x28cd3d45;\npub const EFS_SUPER_MAGIC: ::c_long = 0x00414a53;\npub const EXT2_SUPER_MAGIC: ::c_long = 0x0000ef53;\npub const EXT3_SUPER_MAGIC: ::c_long = 0x0000ef53;\npub const EXT4_SUPER_MAGIC: ::c_long = 0x0000ef53;\npub const HPFS_SUPER_MAGIC: ::c_long = 0xf995e849;\npub const HUGETLBFS_MAGIC: ::c_long = 0x958458f6;\npub const ISOFS_SUPER_MAGIC: ::c_long = 0x00009660;\npub const JFFS2_SUPER_MAGIC: ::c_long = 0x000072b6;\npub const MINIX_SUPER_MAGIC: ::c_long = 0x0000137f;\npub const MINIX_SUPER_MAGIC2: ::c_long = 0x0000138f;\npub const MINIX2_SUPER_MAGIC: ::c_long = 0x00002468;\npub const MINIX2_SUPER_MAGIC2: ::c_long = 0x00002478;\npub const MSDOS_SUPER_MAGIC: ::c_long = 0x00004d44;\npub const NCP_SUPER_MAGIC: ::c_long = 0x0000564c;\npub const NFS_SUPER_MAGIC: ::c_long = 0x00006969;\npub const OPENPROM_SUPER_MAGIC: ::c_long = 0x00009fa1;\npub const PROC_SUPER_MAGIC: ::c_long = 0x00009fa0;\npub const QNX4_SUPER_MAGIC: ::c_long = 0x0000002f;\npub const REISERFS_SUPER_MAGIC: ::c_long = 0x52654973;\npub const SMB_SUPER_MAGIC: ::c_long = 0x0000517b;\npub const TMPFS_MAGIC: ::c_long = 0x01021994;\npub const USBDEVICE_SUPER_MAGIC: ::c_long = 0x00009fa2;\n\npub const MAP_HUGETLB: ::c_int = 0x040000;\n\npub const PTRACE_TRACEME: ::c_int = 0;\npub const PTRACE_PEEKTEXT: ::c_int = 1;\npub const PTRACE_PEEKDATA: ::c_int = 2;\npub const PTRACE_PEEKUSER: ::c_int = 3;\npub const PTRACE_POKETEXT: ::c_int = 4;\npub const PTRACE_POKEDATA: ::c_int = 5;\npub const PTRACE_POKEUSER: ::c_int = 6;\npub const PTRACE_CONT: ::c_int = 7;\npub const PTRACE_KILL: ::c_int = 8;\npub const PTRACE_SINGLESTEP: ::c_int = 9;\npub const PTRACE_ATTACH: ::c_int = 16;\npub const PTRACE_DETACH: ::c_int = 17;\npub const PTRACE_SYSCALL: ::c_int = 24;\npub const PTRACE_SETOPTIONS: ::c_int = 0x4200;\npub const PTRACE_GETEVENTMSG: ::c_int = 0x4201;\npub const PTRACE_GETSIGINFO: ::c_int = 0x4202;\npub const PTRACE_SETSIGINFO: ::c_int = 0x4203;\n\npub const PTRACE_EVENT_STOP: ::c_int = 128;\n\npub const F_GETLK: ::c_int = 5;\npub const F_GETOWN: ::c_int = 9;\npub const F_SETOWN: ::c_int = 8;\npub const F_SETLK: ::c_int = 6;\npub const F_SETLKW: ::c_int = 7;\npub const F_RDLCK: ::c_int = 0;\npub const F_WRLCK: ::c_int = 1;\npub const F_UNLCK: ::c_int = 2;\npub const F_OFD_GETLK: ::c_int = 36;\npub const F_OFD_SETLK: ::c_int = 37;\npub const F_OFD_SETLKW: ::c_int = 38;\n\npub const RLIMIT_CPU: ::c_int = 0;\npub const RLIMIT_FSIZE: ::c_int = 1;\npub const RLIMIT_DATA: ::c_int = 2;\npub const RLIMIT_STACK: ::c_int = 3;\npub const RLIMIT_CORE: ::c_int = 4;\npub const RLIMIT_RSS: ::c_int = 5;\npub const RLIMIT_NPROC: ::c_int = 6;\npub const RLIMIT_NOFILE: ::c_int = 7;\npub const RLIMIT_MEMLOCK: ::c_int = 8;\npub const RLIMIT_AS: ::c_int = 9;\npub const RLIMIT_LOCKS: ::c_int = 10;\npub const RLIMIT_SIGPENDING: ::c_int = 11;\npub const RLIMIT_MSGQUEUE: ::c_int = 12;\npub const RLIMIT_NICE: ::c_int = 13;\npub const RLIMIT_RTPRIO: ::c_int = 14;\n\npub const RLIM_NLIMITS: ::c_int = 16;\npub const RLIM_INFINITY: ::rlim_t = !0;\n\npub const TCGETS: ::c_int = 0x5401;\npub const TCSETS: ::c_int = 0x5402;\npub const TCSETSW: ::c_int = 0x5403;\npub const TCSETSF: ::c_int = 0x5404;\npub const TCGETA: ::c_int = 0x5405;\npub const TCSETA: ::c_int = 0x5406;\npub const TCSETAW: ::c_int = 0x5407;\npub const TCSETAF: ::c_int = 0x5408;\npub const TCSBRK: ::c_int = 0x5409;\npub const TCXONC: ::c_int = 0x540A;\npub const TCFLSH: ::c_int = 0x540B;\npub const TIOCGSOFTCAR: ::c_int = 0x5419;\npub const TIOCSSOFTCAR: ::c_int = 0x541A;\npub const TIOCINQ: ::c_int = 0x541B;\npub const TIOCLINUX: ::c_int = 0x541C;\npub const TIOCGSERIAL: ::c_int = 0x541E;\npub const TIOCEXCL: ::c_int = 0x540C;\npub const TIOCNXCL: ::c_int = 0x540D;\npub const TIOCSCTTY: ::c_int = 0x540E;\npub const TIOCGPGRP: ::c_int = 0x540F;\npub const TIOCSPGRP: ::c_int = 0x5410;\npub const TIOCOUTQ: ::c_int = 0x5411;\npub const TIOCSTI: ::c_int = 0x5412;\npub const TIOCGWINSZ: ::c_int = 0x5413;\npub const TIOCSWINSZ: ::c_int = 0x5414;\npub const TIOCMGET: ::c_int = 0x5415;\npub const TIOCMBIS: ::c_int = 0x5416;\npub const TIOCMBIC: ::c_int = 0x5417;\npub const TIOCMSET: ::c_int = 0x5418;\npub const FIONREAD: ::c_int = 0x541B;\npub const TIOCCONS: ::c_int = 0x541D;\npub const TIOCSBRK: ::c_int = 0x5427;\npub const TIOCCBRK: ::c_int = 0x5428;\n\npub const ST_RDONLY: ::c_ulong = 1;\npub const ST_NOSUID: ::c_ulong = 2;\npub const ST_NODEV: ::c_ulong = 4;\npub const ST_NOEXEC: ::c_ulong = 8;\npub const ST_SYNCHRONOUS: ::c_ulong = 16;\npub const ST_MANDLOCK: ::c_ulong = 64;\npub const ST_NOATIME: ::c_ulong = 1024;\npub const ST_NODIRATIME: ::c_ulong = 2048;\npub const ST_RELATIME: ::c_ulong = 4096;\n\npub const RTLD_NOLOAD: ::c_int = 0x4;\n\npub const SEM_FAILED: *mut sem_t = 0 as *mut sem_t;\n\npub const AI_PASSIVE: ::c_int = 0x00000001;\npub const AI_CANONNAME: ::c_int = 0x00000002;\npub const AI_NUMERICHOST: ::c_int = 0x00000004;\npub const AI_NUMERICSERV: ::c_int = 0x00000008;\npub const AI_MASK: ::c_int =\n    AI_PASSIVE | AI_CANONNAME | AI_NUMERICHOST | AI_NUMERICSERV | AI_ADDRCONFIG;\npub const AI_ALL: ::c_int = 0x00000100;\npub const AI_V4MAPPED_CFG: ::c_int = 0x00000200;\npub const AI_ADDRCONFIG: ::c_int = 0x00000400;\npub const AI_V4MAPPED: ::c_int = 0x00000800;\npub const AI_DEFAULT: ::c_int = AI_V4MAPPED_CFG | AI_ADDRCONFIG;\n\npub const LINUX_REBOOT_MAGIC1: ::c_int = 0xfee1dead;\npub const LINUX_REBOOT_MAGIC2: ::c_int = 672274793;\npub const LINUX_REBOOT_MAGIC2A: ::c_int = 85072278;\npub const LINUX_REBOOT_MAGIC2B: ::c_int = 369367448;\npub const LINUX_REBOOT_MAGIC2C: ::c_int = 537993216;\n\npub const LINUX_REBOOT_CMD_RESTART: ::c_int = 0x01234567;\npub const LINUX_REBOOT_CMD_HALT: ::c_int = 0xCDEF0123;\npub const LINUX_REBOOT_CMD_CAD_ON: ::c_int = 0x89ABCDEF;\npub const LINUX_REBOOT_CMD_CAD_OFF: ::c_int = 0x00000000;\npub const LINUX_REBOOT_CMD_POWER_OFF: ::c_int = 0x4321FEDC;\npub const LINUX_REBOOT_CMD_RESTART2: ::c_int = 0xA1B2C3D4;\npub const LINUX_REBOOT_CMD_SW_SUSPEND: ::c_int = 0xD000FCE2;\npub const LINUX_REBOOT_CMD_KEXEC: ::c_int = 0x45584543;\n\npub const REG_BASIC: ::c_int = 0;\npub const REG_EXTENDED: ::c_int = 1;\npub const REG_ICASE: ::c_int = 2;\npub const REG_NOSUB: ::c_int = 4;\npub const REG_NEWLINE: ::c_int = 8;\npub const REG_NOSPEC: ::c_int = 16;\npub const REG_PEND: ::c_int = 32;\npub const REG_DUMP: ::c_int = 128;\n\npub const REG_NOMATCH: ::c_int = 1;\npub const REG_BADPAT: ::c_int = 2;\npub const REG_ECOLLATE: ::c_int = 3;\npub const REG_ECTYPE: ::c_int = 4;\npub const REG_EESCAPE: ::c_int = 5;\npub const REG_ESUBREG: ::c_int = 6;\npub const REG_EBRACK: ::c_int = 7;\npub const REG_EPAREN: ::c_int = 8;\npub const REG_EBRACE: ::c_int = 9;\npub const REG_BADBR: ::c_int = 10;\npub const REG_ERANGE: ::c_int = 11;\npub const REG_ESPACE: ::c_int = 12;\npub const REG_BADRPT: ::c_int = 13;\npub const REG_EMPTY: ::c_int = 14;\npub const REG_ASSERT: ::c_int = 15;\npub const REG_INVARG: ::c_int = 16;\npub const REG_ATOI: ::c_int = 255;\npub const REG_ITOA: ::c_int = 256;\n\npub const REG_NOTBOL: ::c_int = 1;\npub const REG_NOTEOL: ::c_int = 2;\npub const REG_STARTEND: ::c_int = 4;\npub const REG_TRACE: ::c_int = 256;\npub const REG_LARGE: ::c_int = 512;\npub const REG_BACKR: ::c_int = 1024;\n\npub const MCL_CURRENT: ::c_int = 0x0001;\npub const MCL_FUTURE: ::c_int = 0x0002;\n\npub const CBAUD: ::tcflag_t = 0o0010017;\npub const TAB1: ::tcflag_t = 0x00000800;\npub const TAB2: ::tcflag_t = 0x00001000;\npub const TAB3: ::tcflag_t = 0x00001800;\npub const CR1: ::tcflag_t = 0x00000200;\npub const CR2: ::tcflag_t = 0x00000400;\npub const CR3: ::tcflag_t = 0x00000600;\npub const FF1: ::tcflag_t = 0x00008000;\npub const BS1: ::tcflag_t = 0x00002000;\npub const VT1: ::tcflag_t = 0x00004000;\npub const VWERASE: usize = 14;\npub const VREPRINT: usize = 12;\npub const VSUSP: usize = 10;\npub const VSTART: usize = 8;\npub const VSTOP: usize = 9;\npub const VDISCARD: usize = 13;\npub const VTIME: usize = 5;\npub const IXON: ::tcflag_t = 0x00000400;\npub const IXOFF: ::tcflag_t = 0x00001000;\npub const ONLCR: ::tcflag_t = 0x4;\npub const CSIZE: ::tcflag_t = 0x00000030;\npub const CS6: ::tcflag_t = 0x00000010;\npub const CS7: ::tcflag_t = 0x00000020;\npub const CS8: ::tcflag_t = 0x00000030;\npub const CSTOPB: ::tcflag_t = 0x00000040;\npub const CREAD: ::tcflag_t = 0x00000080;\npub const PARENB: ::tcflag_t = 0x00000100;\npub const PARODD: ::tcflag_t = 0x00000200;\npub const HUPCL: ::tcflag_t = 0x00000400;\npub const CLOCAL: ::tcflag_t = 0x00000800;\npub const ECHOKE: ::tcflag_t = 0x00000800;\npub const ECHOE: ::tcflag_t = 0x00000010;\npub const ECHOK: ::tcflag_t = 0x00000020;\npub const ECHONL: ::tcflag_t = 0x00000040;\npub const ECHOPRT: ::tcflag_t = 0x00000400;\npub const ECHOCTL: ::tcflag_t = 0x00000200;\npub const ISIG: ::tcflag_t = 0x00000001;\npub const ICANON: ::tcflag_t = 0x00000002;\npub const PENDIN: ::tcflag_t = 0x00004000;\npub const NOFLSH: ::tcflag_t = 0x00000080;\npub const VSWTC: usize = 7;\npub const OLCUC: ::tcflag_t = 0o000002;\npub const NLDLY: ::tcflag_t = 0o000400;\npub const CRDLY: ::tcflag_t = 0o003000;\npub const TABDLY: ::tcflag_t = 0o014000;\npub const BSDLY: ::tcflag_t = 0o020000;\npub const FFDLY: ::tcflag_t = 0o100000;\npub const VTDLY: ::tcflag_t = 0o040000;\npub const XTABS: ::tcflag_t = 0o014000;\n\npub const B0: ::speed_t = 0o000000;\npub const B50: ::speed_t = 0o000001;\npub const B75: ::speed_t = 0o000002;\npub const B110: ::speed_t = 0o000003;\npub const B134: ::speed_t = 0o000004;\npub const B150: ::speed_t = 0o000005;\npub const B200: ::speed_t = 0o000006;\npub const B300: ::speed_t = 0o000007;\npub const B600: ::speed_t = 0o000010;\npub const B1200: ::speed_t = 0o000011;\npub const B1800: ::speed_t = 0o000012;\npub const B2400: ::speed_t = 0o000013;\npub const B4800: ::speed_t = 0o000014;\npub const B9600: ::speed_t = 0o000015;\npub const B19200: ::speed_t = 0o000016;\npub const B38400: ::speed_t = 0o000017;\npub const EXTA: ::speed_t = B19200;\npub const EXTB: ::speed_t = B38400;\npub const BOTHER: ::speed_t = 0o010000;\npub const B57600: ::speed_t = 0o010001;\npub const B115200: ::speed_t = 0o010002;\npub const B230400: ::speed_t = 0o010003;\npub const B460800: ::speed_t = 0o010004;\npub const B500000: ::speed_t = 0o010005;\npub const B576000: ::speed_t = 0o010006;\npub const B921600: ::speed_t = 0o010007;\npub const B1000000: ::speed_t = 0o010010;\npub const B1152000: ::speed_t = 0o010011;\npub const B1500000: ::speed_t = 0o010012;\npub const B2000000: ::speed_t = 0o010013;\npub const B2500000: ::speed_t = 0o010014;\npub const B3000000: ::speed_t = 0o010015;\npub const B3500000: ::speed_t = 0o010016;\npub const B4000000: ::speed_t = 0o010017;\n\npub const EAI_AGAIN: ::c_int = 2;\npub const EAI_BADFLAGS: ::c_int = 3;\npub const EAI_FAIL: ::c_int = 4;\npub const EAI_FAMILY: ::c_int = 5;\npub const EAI_MEMORY: ::c_int = 6;\npub const EAI_NODATA: ::c_int = 7;\npub const EAI_NONAME: ::c_int = 8;\npub const EAI_SERVICE: ::c_int = 9;\npub const EAI_SOCKTYPE: ::c_int = 10;\npub const EAI_SYSTEM: ::c_int = 11;\npub const EAI_OVERFLOW: ::c_int = 14;\n\npub const NETLINK_ROUTE: ::c_int = 0;\npub const NETLINK_UNUSED: ::c_int = 1;\npub const NETLINK_USERSOCK: ::c_int = 2;\npub const NETLINK_FIREWALL: ::c_int = 3;\npub const NETLINK_SOCK_DIAG: ::c_int = 4;\npub const NETLINK_NFLOG: ::c_int = 5;\npub const NETLINK_XFRM: ::c_int = 6;\npub const NETLINK_SELINUX: ::c_int = 7;\npub const NETLINK_ISCSI: ::c_int = 8;\npub const NETLINK_AUDIT: ::c_int = 9;\npub const NETLINK_FIB_LOOKUP: ::c_int = 10;\npub const NETLINK_CONNECTOR: ::c_int = 11;\npub const NETLINK_NETFILTER: ::c_int = 12;\npub const NETLINK_IP6_FW: ::c_int = 13;\npub const NETLINK_DNRTMSG: ::c_int = 14;\npub const NETLINK_KOBJECT_UEVENT: ::c_int = 15;\npub const NETLINK_GENERIC: ::c_int = 16;\npub const NETLINK_SCSITRANSPORT: ::c_int = 18;\npub const NETLINK_ECRYPTFS: ::c_int = 19;\npub const NETLINK_RDMA: ::c_int = 20;\npub const NETLINK_CRYPTO: ::c_int = 21;\npub const NETLINK_INET_DIAG: ::c_int = NETLINK_SOCK_DIAG;\n\npub const MAX_LINKS: ::c_int = 32;\n\npub const NLM_F_REQUEST: ::c_int = 1;\npub const NLM_F_MULTI: ::c_int = 2;\npub const NLM_F_ACK: ::c_int = 4;\npub const NLM_F_ECHO: ::c_int = 8;\npub const NLM_F_DUMP_INTR: ::c_int = 16;\n\npub const NLM_F_ROOT: ::c_int = 0x100;\npub const NLM_F_MATCH: ::c_int = 0x200;\npub const NLM_F_ATOMIC: ::c_int = 0x400;\npub const NLM_F_DUMP: ::c_int = NLM_F_ROOT | NLM_F_MATCH;\n\npub const NLM_F_REPLACE: ::c_int = 0x100;\npub const NLM_F_EXCL: ::c_int = 0x200;\npub const NLM_F_CREATE: ::c_int = 0x400;\npub const NLM_F_APPEND: ::c_int = 0x800;\n\npub const NLMSG_NOOP: ::c_int = 0x1;\npub const NLMSG_ERROR: ::c_int = 0x2;\npub const NLMSG_DONE: ::c_int = 0x3;\npub const NLMSG_OVERRUN: ::c_int = 0x4;\npub const NLMSG_MIN_TYPE: ::c_int = 0x10;\n\n// linux/netfilter/nfnetlink.h\npub const NFNLGRP_NONE: ::c_int = 0;\npub const NFNLGRP_CONNTRACK_NEW: ::c_int = 1;\npub const NFNLGRP_CONNTRACK_UPDATE: ::c_int = 2;\npub const NFNLGRP_CONNTRACK_DESTROY: ::c_int = 3;\npub const NFNLGRP_CONNTRACK_EXP_NEW: ::c_int = 4;\npub const NFNLGRP_CONNTRACK_EXP_UPDATE: ::c_int = 5;\npub const NFNLGRP_CONNTRACK_EXP_DESTROY: ::c_int = 6;\npub const NFNLGRP_NFTABLES: ::c_int = 7;\npub const NFNLGRP_ACCT_QUOTA: ::c_int = 8;\n\npub const NFNETLINK_V0: ::c_int = 0;\n\npub const NFNL_SUBSYS_NONE: ::c_int = 0;\npub const NFNL_SUBSYS_CTNETLINK: ::c_int = 1;\npub const NFNL_SUBSYS_CTNETLINK_EXP: ::c_int = 2;\npub const NFNL_SUBSYS_QUEUE: ::c_int = 3;\npub const NFNL_SUBSYS_ULOG: ::c_int = 4;\npub const NFNL_SUBSYS_OSF: ::c_int = 5;\npub const NFNL_SUBSYS_IPSET: ::c_int = 6;\npub const NFNL_SUBSYS_ACCT: ::c_int = 7;\npub const NFNL_SUBSYS_CTNETLINK_TIMEOUT: ::c_int = 8;\npub const NFNL_SUBSYS_CTHELPER: ::c_int = 9;\npub const NFNL_SUBSYS_NFTABLES: ::c_int = 10;\npub const NFNL_SUBSYS_NFT_COMPAT: ::c_int = 11;\npub const NFNL_SUBSYS_COUNT: ::c_int = 12;\n\npub const NFNL_MSG_BATCH_BEGIN: ::c_int = NLMSG_MIN_TYPE;\npub const NFNL_MSG_BATCH_END: ::c_int = NLMSG_MIN_TYPE + 1;\n\n// linux/netfilter/nfnetlink_log.h\npub const NFULNL_MSG_PACKET: ::c_int = 0;\npub const NFULNL_MSG_CONFIG: ::c_int = 1;\n\npub const NFULA_UNSPEC: ::c_int = 0;\npub const NFULA_PACKET_HDR: ::c_int = 1;\npub const NFULA_MARK: ::c_int = 2;\npub const NFULA_TIMESTAMP: ::c_int = 3;\npub const NFULA_IFINDEX_INDEV: ::c_int = 4;\npub const NFULA_IFINDEX_OUTDEV: ::c_int = 5;\npub const NFULA_IFINDEX_PHYSINDEV: ::c_int = 6;\npub const NFULA_IFINDEX_PHYSOUTDEV: ::c_int = 7;\npub const NFULA_HWADDR: ::c_int = 8;\npub const NFULA_PAYLOAD: ::c_int = 9;\npub const NFULA_PREFIX: ::c_int = 10;\npub const NFULA_UID: ::c_int = 11;\npub const NFULA_SEQ: ::c_int = 12;\npub const NFULA_SEQ_GLOBAL: ::c_int = 13;\npub const NFULA_GID: ::c_int = 14;\npub const NFULA_HWTYPE: ::c_int = 15;\npub const NFULA_HWHEADER: ::c_int = 16;\npub const NFULA_HWLEN: ::c_int = 17;\npub const NFULA_CT: ::c_int = 18;\npub const NFULA_CT_INFO: ::c_int = 19;\n\npub const NFULNL_CFG_CMD_NONE: ::c_int = 0;\npub const NFULNL_CFG_CMD_BIND: ::c_int = 1;\npub const NFULNL_CFG_CMD_UNBIND: ::c_int = 2;\npub const NFULNL_CFG_CMD_PF_BIND: ::c_int = 3;\npub const NFULNL_CFG_CMD_PF_UNBIND: ::c_int = 4;\n\npub const NFULA_CFG_UNSPEC: ::c_int = 0;\npub const NFULA_CFG_CMD: ::c_int = 1;\npub const NFULA_CFG_MODE: ::c_int = 2;\npub const NFULA_CFG_NLBUFSIZ: ::c_int = 3;\npub const NFULA_CFG_TIMEOUT: ::c_int = 4;\npub const NFULA_CFG_QTHRESH: ::c_int = 5;\npub const NFULA_CFG_FLAGS: ::c_int = 6;\n\npub const NFULNL_COPY_NONE: ::c_int = 0x00;\npub const NFULNL_COPY_META: ::c_int = 0x01;\npub const NFULNL_COPY_PACKET: ::c_int = 0x02;\n\npub const NFULNL_CFG_F_SEQ: ::c_int = 0x0001;\npub const NFULNL_CFG_F_SEQ_GLOBAL: ::c_int = 0x0002;\npub const NFULNL_CFG_F_CONNTRACK: ::c_int = 0x0004;\n\n// linux/netfilter/nfnetlink_log.h\npub const NFQNL_MSG_PACKET: ::c_int = 0;\npub const NFQNL_MSG_VERDICT: ::c_int = 1;\npub const NFQNL_MSG_CONFIG: ::c_int = 2;\npub const NFQNL_MSG_VERDICT_BATCH: ::c_int = 3;\n\npub const NFQA_UNSPEC: ::c_int = 0;\npub const NFQA_PACKET_HDR: ::c_int = 1;\npub const NFQA_VERDICT_HDR: ::c_int = 2;\npub const NFQA_MARK: ::c_int = 3;\npub const NFQA_TIMESTAMP: ::c_int = 4;\npub const NFQA_IFINDEX_INDEV: ::c_int = 5;\npub const NFQA_IFINDEX_OUTDEV: ::c_int = 6;\npub const NFQA_IFINDEX_PHYSINDEV: ::c_int = 7;\npub const NFQA_IFINDEX_PHYSOUTDEV: ::c_int = 8;\npub const NFQA_HWADDR: ::c_int = 9;\npub const NFQA_PAYLOAD: ::c_int = 10;\npub const NFQA_CT: ::c_int = 11;\npub const NFQA_CT_INFO: ::c_int = 12;\npub const NFQA_CAP_LEN: ::c_int = 13;\npub const NFQA_SKB_INFO: ::c_int = 14;\npub const NFQA_EXP: ::c_int = 15;\npub const NFQA_UID: ::c_int = 16;\npub const NFQA_GID: ::c_int = 17;\npub const NFQA_SECCTX: ::c_int = 18;\n/*\n FIXME: These are not yet available in musl sanitized kernel headers and\n make the tests fail. Enable them once musl has them.\n\n See https://github.com/rust-lang/libc/pull/1628 for more details.\npub const NFQA_VLAN: ::c_int = 19;\npub const NFQA_L2HDR: ::c_int = 20;\n\npub const NFQA_VLAN_UNSPEC: ::c_int = 0;\npub const NFQA_VLAN_PROTO: ::c_int = 1;\npub const NFQA_VLAN_TCI: ::c_int = 2;\n*/\n\npub const NFQNL_CFG_CMD_NONE: ::c_int = 0;\npub const NFQNL_CFG_CMD_BIND: ::c_int = 1;\npub const NFQNL_CFG_CMD_UNBIND: ::c_int = 2;\npub const NFQNL_CFG_CMD_PF_BIND: ::c_int = 3;\npub const NFQNL_CFG_CMD_PF_UNBIND: ::c_int = 4;\n\npub const NFQNL_COPY_NONE: ::c_int = 0;\npub const NFQNL_COPY_META: ::c_int = 1;\npub const NFQNL_COPY_PACKET: ::c_int = 2;\n\npub const NFQA_CFG_UNSPEC: ::c_int = 0;\npub const NFQA_CFG_CMD: ::c_int = 1;\npub const NFQA_CFG_PARAMS: ::c_int = 2;\npub const NFQA_CFG_QUEUE_MAXLEN: ::c_int = 3;\npub const NFQA_CFG_MASK: ::c_int = 4;\npub const NFQA_CFG_FLAGS: ::c_int = 5;\n\npub const NFQA_CFG_F_FAIL_OPEN: ::c_int = 0x0001;\npub const NFQA_CFG_F_CONNTRACK: ::c_int = 0x0002;\npub const NFQA_CFG_F_GSO: ::c_int = 0x0004;\npub const NFQA_CFG_F_UID_GID: ::c_int = 0x0008;\npub const NFQA_CFG_F_SECCTX: ::c_int = 0x0010;\npub const NFQA_CFG_F_MAX: ::c_int = 0x0020;\n\npub const NFQA_SKB_CSUMNOTREADY: ::c_int = 0x0001;\npub const NFQA_SKB_GSO: ::c_int = 0x0002;\npub const NFQA_SKB_CSUM_NOTVERIFIED: ::c_int = 0x0004;\n\npub const GENL_NAMSIZ: ::c_int = 16;\n\npub const GENL_MIN_ID: ::c_int = NLMSG_MIN_TYPE;\npub const GENL_MAX_ID: ::c_int = 1023;\n\npub const GENL_ADMIN_PERM: ::c_int = 0x01;\npub const GENL_CMD_CAP_DO: ::c_int = 0x02;\npub const GENL_CMD_CAP_DUMP: ::c_int = 0x04;\npub const GENL_CMD_CAP_HASPOL: ::c_int = 0x08;\npub const GENL_UNS_ADMIN_PERM: ::c_int = 0x10;\n\npub const GENL_ID_CTRL: ::c_int = NLMSG_MIN_TYPE;\npub const GENL_ID_VFS_DQUOT: ::c_int = NLMSG_MIN_TYPE + 1;\npub const GENL_ID_PMCRAID: ::c_int = NLMSG_MIN_TYPE + 2;\n\npub const CTRL_CMD_UNSPEC: ::c_int = 0;\npub const CTRL_CMD_NEWFAMILY: ::c_int = 1;\npub const CTRL_CMD_DELFAMILY: ::c_int = 2;\npub const CTRL_CMD_GETFAMILY: ::c_int = 3;\npub const CTRL_CMD_NEWOPS: ::c_int = 4;\npub const CTRL_CMD_DELOPS: ::c_int = 5;\npub const CTRL_CMD_GETOPS: ::c_int = 6;\npub const CTRL_CMD_NEWMCAST_GRP: ::c_int = 7;\npub const CTRL_CMD_DELMCAST_GRP: ::c_int = 8;\npub const CTRL_CMD_GETMCAST_GRP: ::c_int = 9;\n\npub const CTRL_ATTR_UNSPEC: ::c_int = 0;\npub const CTRL_ATTR_FAMILY_ID: ::c_int = 1;\npub const CTRL_ATTR_FAMILY_NAME: ::c_int = 2;\npub const CTRL_ATTR_VERSION: ::c_int = 3;\npub const CTRL_ATTR_HDRSIZE: ::c_int = 4;\npub const CTRL_ATTR_MAXATTR: ::c_int = 5;\npub const CTRL_ATTR_OPS: ::c_int = 6;\npub const CTRL_ATTR_MCAST_GROUPS: ::c_int = 7;\n\npub const CTRL_ATTR_OP_UNSPEC: ::c_int = 0;\npub const CTRL_ATTR_OP_ID: ::c_int = 1;\npub const CTRL_ATTR_OP_FLAGS: ::c_int = 2;\n\npub const CTRL_ATTR_MCAST_GRP_UNSPEC: ::c_int = 0;\npub const CTRL_ATTR_MCAST_GRP_NAME: ::c_int = 1;\npub const CTRL_ATTR_MCAST_GRP_ID: ::c_int = 2;\n\npub const NETLINK_ADD_MEMBERSHIP: ::c_int = 1;\npub const NETLINK_DROP_MEMBERSHIP: ::c_int = 2;\npub const NETLINK_PKTINFO: ::c_int = 3;\npub const NETLINK_BROADCAST_ERROR: ::c_int = 4;\npub const NETLINK_NO_ENOBUFS: ::c_int = 5;\npub const NETLINK_RX_RING: ::c_int = 6;\npub const NETLINK_TX_RING: ::c_int = 7;\n\npub const GRND_NONBLOCK: ::c_uint = 0x0001;\npub const GRND_RANDOM: ::c_uint = 0x0002;\n\npub const SECCOMP_MODE_DISABLED: ::c_uint = 0;\npub const SECCOMP_MODE_STRICT: ::c_uint = 1;\npub const SECCOMP_MODE_FILTER: ::c_uint = 2;\n\npub const NLA_F_NESTED: ::c_int = 1 << 15;\npub const NLA_F_NET_BYTEORDER: ::c_int = 1 << 14;\npub const NLA_TYPE_MASK: ::c_int = !(NLA_F_NESTED | NLA_F_NET_BYTEORDER);\n\npub const NLA_ALIGNTO: ::c_int = 4;\n\npub const SIGEV_THREAD_ID: ::c_int = 4;\n\npub const CIBAUD: ::tcflag_t = 0o02003600000;\npub const CBAUDEX: ::tcflag_t = 0o010000;\n\npub const TIOCM_LE: ::c_int = 0x001;\npub const TIOCM_DTR: ::c_int = 0x002;\npub const TIOCM_RTS: ::c_int = 0x004;\npub const TIOCM_ST: ::c_int = 0x008;\npub const TIOCM_SR: ::c_int = 0x010;\npub const TIOCM_CTS: ::c_int = 0x020;\npub const TIOCM_CAR: ::c_int = 0x040;\npub const TIOCM_RNG: ::c_int = 0x080;\npub const TIOCM_DSR: ::c_int = 0x100;\npub const TIOCM_CD: ::c_int = TIOCM_CAR;\npub const TIOCM_RI: ::c_int = TIOCM_RNG;\n\npub const POLLWRNORM: ::c_short = 0x100;\npub const POLLWRBAND: ::c_short = 0x200;\n\npub const SFD_CLOEXEC: ::c_int = O_CLOEXEC;\npub const SFD_NONBLOCK: ::c_int = O_NONBLOCK;\n\npub const SOCK_NONBLOCK: ::c_int = O_NONBLOCK;\n\npub const SO_ORIGINAL_DST: ::c_int = 80;\n\npub const IP_RECVFRAGSIZE: ::c_int = 25;\n\npub const IPV6_FLOWINFO: ::c_int = 11;\npub const IPV6_MULTICAST_ALL: ::c_int = 29;\npub const IPV6_ROUTER_ALERT_ISOLATE: ::c_int = 30;\npub const IPV6_FLOWLABEL_MGR: ::c_int = 32;\npub const IPV6_FLOWINFO_SEND: ::c_int = 33;\npub const IPV6_RECVFRAGSIZE: ::c_int = 77;\npub const IPV6_FREEBIND: ::c_int = 78;\npub const IPV6_FLOWINFO_FLOWLABEL: ::c_int = 0x000fffff;\npub const IPV6_FLOWINFO_PRIORITY: ::c_int = 0x0ff00000;\n\npub const IUTF8: ::tcflag_t = 0x00004000;\npub const CMSPAR: ::tcflag_t = 0o10000000000;\npub const O_TMPFILE: ::c_int = 0o20000000 | O_DIRECTORY;\n\npub const MFD_CLOEXEC: ::c_uint = 0x0001;\npub const MFD_ALLOW_SEALING: ::c_uint = 0x0002;\npub const MFD_HUGETLB: ::c_uint = 0x0004;\n\n// linux/netfilter.h\npub const NF_DROP: ::c_int = 0;\npub const NF_ACCEPT: ::c_int = 1;\npub const NF_STOLEN: ::c_int = 2;\npub const NF_QUEUE: ::c_int = 3;\npub const NF_REPEAT: ::c_int = 4;\npub const NF_STOP: ::c_int = 5;\npub const NF_MAX_VERDICT: ::c_int = NF_STOP;\n\npub const NF_VERDICT_MASK: ::c_int = 0x000000ff;\npub const NF_VERDICT_FLAG_QUEUE_BYPASS: ::c_int = 0x00008000;\n\npub const NF_VERDICT_QMASK: ::c_int = 0xffff0000;\npub const NF_VERDICT_QBITS: ::c_int = 16;\n\npub const NF_VERDICT_BITS: ::c_int = 16;\n\npub const NF_INET_PRE_ROUTING: ::c_int = 0;\npub const NF_INET_LOCAL_IN: ::c_int = 1;\npub const NF_INET_FORWARD: ::c_int = 2;\npub const NF_INET_LOCAL_OUT: ::c_int = 3;\npub const NF_INET_POST_ROUTING: ::c_int = 4;\npub const NF_INET_NUMHOOKS: ::c_int = 5;\n\npub const NF_NETDEV_INGRESS: ::c_int = 0;\npub const NF_NETDEV_NUMHOOKS: ::c_int = 1;\n\npub const NFPROTO_UNSPEC: ::c_int = 0;\npub const NFPROTO_INET: ::c_int = 1;\npub const NFPROTO_IPV4: ::c_int = 2;\npub const NFPROTO_ARP: ::c_int = 3;\npub const NFPROTO_NETDEV: ::c_int = 5;\npub const NFPROTO_BRIDGE: ::c_int = 7;\npub const NFPROTO_IPV6: ::c_int = 10;\npub const NFPROTO_DECNET: ::c_int = 12;\npub const NFPROTO_NUMPROTO: ::c_int = 13;\n\n// linux/netfilter_ipv4.h\npub const NF_IP_PRE_ROUTING: ::c_int = 0;\npub const NF_IP_LOCAL_IN: ::c_int = 1;\npub const NF_IP_FORWARD: ::c_int = 2;\npub const NF_IP_LOCAL_OUT: ::c_int = 3;\npub const NF_IP_POST_ROUTING: ::c_int = 4;\npub const NF_IP_NUMHOOKS: ::c_int = 5;\n\npub const NF_IP_PRI_FIRST: ::c_int = ::INT_MIN;\npub const NF_IP_PRI_CONNTRACK_DEFRAG: ::c_int = -400;\npub const NF_IP_PRI_RAW: ::c_int = -300;\npub const NF_IP_PRI_SELINUX_FIRST: ::c_int = -225;\npub const NF_IP_PRI_CONNTRACK: ::c_int = -200;\npub const NF_IP_PRI_MANGLE: ::c_int = -150;\npub const NF_IP_PRI_NAT_DST: ::c_int = -100;\npub const NF_IP_PRI_FILTER: ::c_int = 0;\npub const NF_IP_PRI_SECURITY: ::c_int = 50;\npub const NF_IP_PRI_NAT_SRC: ::c_int = 100;\npub const NF_IP_PRI_SELINUX_LAST: ::c_int = 225;\npub const NF_IP_PRI_CONNTRACK_HELPER: ::c_int = 300;\npub const NF_IP_PRI_CONNTRACK_CONFIRM: ::c_int = ::INT_MAX;\npub const NF_IP_PRI_LAST: ::c_int = ::INT_MAX;\n\n// linux/netfilter_ipv6.h\npub const NF_IP6_PRE_ROUTING: ::c_int = 0;\npub const NF_IP6_LOCAL_IN: ::c_int = 1;\npub const NF_IP6_FORWARD: ::c_int = 2;\npub const NF_IP6_LOCAL_OUT: ::c_int = 3;\npub const NF_IP6_POST_ROUTING: ::c_int = 4;\npub const NF_IP6_NUMHOOKS: ::c_int = 5;\n\npub const NF_IP6_PRI_FIRST: ::c_int = ::INT_MIN;\npub const NF_IP6_PRI_CONNTRACK_DEFRAG: ::c_int = -400;\npub const NF_IP6_PRI_RAW: ::c_int = -300;\npub const NF_IP6_PRI_SELINUX_FIRST: ::c_int = -225;\npub const NF_IP6_PRI_CONNTRACK: ::c_int = -200;\npub const NF_IP6_PRI_MANGLE: ::c_int = -150;\npub const NF_IP6_PRI_NAT_DST: ::c_int = -100;\npub const NF_IP6_PRI_FILTER: ::c_int = 0;\npub const NF_IP6_PRI_SECURITY: ::c_int = 50;\npub const NF_IP6_PRI_NAT_SRC: ::c_int = 100;\npub const NF_IP6_PRI_SELINUX_LAST: ::c_int = 225;\npub const NF_IP6_PRI_CONNTRACK_HELPER: ::c_int = 300;\npub const NF_IP6_PRI_LAST: ::c_int = ::INT_MAX;\n\n// linux/netfilter_ipv6/ip6_tables.h\npub const IP6T_SO_ORIGINAL_DST: ::c_int = 80;\n\n// linux/netfilter/nf_tables.h\npub const NFT_TABLE_MAXNAMELEN: ::c_int = 256;\npub const NFT_CHAIN_MAXNAMELEN: ::c_int = 256;\npub const NFT_SET_MAXNAMELEN: ::c_int = 256;\npub const NFT_OBJ_MAXNAMELEN: ::c_int = 256;\npub const NFT_USERDATA_MAXLEN: ::c_int = 256;\n\npub const NFT_REG_VERDICT: ::c_int = 0;\npub const NFT_REG_1: ::c_int = 1;\npub const NFT_REG_2: ::c_int = 2;\npub const NFT_REG_3: ::c_int = 3;\npub const NFT_REG_4: ::c_int = 4;\npub const __NFT_REG_MAX: ::c_int = 5;\npub const NFT_REG32_00: ::c_int = 8;\npub const NFT_REG32_01: ::c_int = 9;\npub const NFT_REG32_02: ::c_int = 10;\npub const NFT_REG32_03: ::c_int = 11;\npub const NFT_REG32_04: ::c_int = 12;\npub const NFT_REG32_05: ::c_int = 13;\npub const NFT_REG32_06: ::c_int = 14;\npub const NFT_REG32_07: ::c_int = 15;\npub const NFT_REG32_08: ::c_int = 16;\npub const NFT_REG32_09: ::c_int = 17;\npub const NFT_REG32_10: ::c_int = 18;\npub const NFT_REG32_11: ::c_int = 19;\npub const NFT_REG32_12: ::c_int = 20;\npub const NFT_REG32_13: ::c_int = 21;\npub const NFT_REG32_14: ::c_int = 22;\npub const NFT_REG32_15: ::c_int = 23;\n\npub const NFT_REG_SIZE: ::c_int = 16;\npub const NFT_REG32_SIZE: ::c_int = 4;\n\npub const NFT_CONTINUE: ::c_int = -1;\npub const NFT_BREAK: ::c_int = -2;\npub const NFT_JUMP: ::c_int = -3;\npub const NFT_GOTO: ::c_int = -4;\npub const NFT_RETURN: ::c_int = -5;\n\npub const NFT_MSG_NEWTABLE: ::c_int = 0;\npub const NFT_MSG_GETTABLE: ::c_int = 1;\npub const NFT_MSG_DELTABLE: ::c_int = 2;\npub const NFT_MSG_NEWCHAIN: ::c_int = 3;\npub const NFT_MSG_GETCHAIN: ::c_int = 4;\npub const NFT_MSG_DELCHAIN: ::c_int = 5;\npub const NFT_MSG_NEWRULE: ::c_int = 6;\npub const NFT_MSG_GETRULE: ::c_int = 7;\npub const NFT_MSG_DELRULE: ::c_int = 8;\npub const NFT_MSG_NEWSET: ::c_int = 9;\npub const NFT_MSG_GETSET: ::c_int = 10;\npub const NFT_MSG_DELSET: ::c_int = 11;\npub const NFT_MSG_NEWSETELEM: ::c_int = 12;\npub const NFT_MSG_GETSETELEM: ::c_int = 13;\npub const NFT_MSG_DELSETELEM: ::c_int = 14;\npub const NFT_MSG_NEWGEN: ::c_int = 15;\npub const NFT_MSG_GETGEN: ::c_int = 16;\npub const NFT_MSG_TRACE: ::c_int = 17;\npub const NFT_MSG_NEWOBJ: ::c_int = 18;\npub const NFT_MSG_GETOBJ: ::c_int = 19;\npub const NFT_MSG_DELOBJ: ::c_int = 20;\npub const NFT_MSG_GETOBJ_RESET: ::c_int = 21;\npub const NFT_MSG_MAX: ::c_int = 25;\n\npub const NFT_SET_ANONYMOUS: ::c_int = 0x1;\npub const NFT_SET_CONSTANT: ::c_int = 0x2;\npub const NFT_SET_INTERVAL: ::c_int = 0x4;\npub const NFT_SET_MAP: ::c_int = 0x8;\npub const NFT_SET_TIMEOUT: ::c_int = 0x10;\npub const NFT_SET_EVAL: ::c_int = 0x20;\n\npub const NFT_SET_POL_PERFORMANCE: ::c_int = 0;\npub const NFT_SET_POL_MEMORY: ::c_int = 1;\n\npub const NFT_SET_ELEM_INTERVAL_END: ::c_int = 0x1;\n\npub const NFT_DATA_VALUE: ::c_uint = 0;\npub const NFT_DATA_VERDICT: ::c_uint = 0xffffff00;\n\npub const NFT_DATA_RESERVED_MASK: ::c_uint = 0xffffff00;\n\npub const NFT_DATA_VALUE_MAXLEN: ::c_int = 64;\n\npub const NFT_BYTEORDER_NTOH: ::c_int = 0;\npub const NFT_BYTEORDER_HTON: ::c_int = 1;\n\npub const NFT_CMP_EQ: ::c_int = 0;\npub const NFT_CMP_NEQ: ::c_int = 1;\npub const NFT_CMP_LT: ::c_int = 2;\npub const NFT_CMP_LTE: ::c_int = 3;\npub const NFT_CMP_GT: ::c_int = 4;\npub const NFT_CMP_GTE: ::c_int = 5;\n\npub const NFT_RANGE_EQ: ::c_int = 0;\npub const NFT_RANGE_NEQ: ::c_int = 1;\n\npub const NFT_LOOKUP_F_INV: ::c_int = 1 << 0;\n\npub const NFT_DYNSET_OP_ADD: ::c_int = 0;\npub const NFT_DYNSET_OP_UPDATE: ::c_int = 1;\n\npub const NFT_DYNSET_F_INV: ::c_int = 1 << 0;\n\npub const NFT_PAYLOAD_LL_HEADER: ::c_int = 0;\npub const NFT_PAYLOAD_NETWORK_HEADER: ::c_int = 1;\npub const NFT_PAYLOAD_TRANSPORT_HEADER: ::c_int = 2;\n\npub const NFT_PAYLOAD_CSUM_NONE: ::c_int = 0;\npub const NFT_PAYLOAD_CSUM_INET: ::c_int = 1;\n\npub const NFT_META_LEN: ::c_int = 0;\npub const NFT_META_PROTOCOL: ::c_int = 1;\npub const NFT_META_PRIORITY: ::c_int = 2;\npub const NFT_META_MARK: ::c_int = 3;\npub const NFT_META_IIF: ::c_int = 4;\npub const NFT_META_OIF: ::c_int = 5;\npub const NFT_META_IIFNAME: ::c_int = 6;\npub const NFT_META_OIFNAME: ::c_int = 7;\npub const NFT_META_IIFTYPE: ::c_int = 8;\npub const NFT_META_OIFTYPE: ::c_int = 9;\npub const NFT_META_SKUID: ::c_int = 10;\npub const NFT_META_SKGID: ::c_int = 11;\npub const NFT_META_NFTRACE: ::c_int = 12;\npub const NFT_META_RTCLASSID: ::c_int = 13;\npub const NFT_META_SECMARK: ::c_int = 14;\npub const NFT_META_NFPROTO: ::c_int = 15;\npub const NFT_META_L4PROTO: ::c_int = 16;\npub const NFT_META_BRI_IIFNAME: ::c_int = 17;\npub const NFT_META_BRI_OIFNAME: ::c_int = 18;\npub const NFT_META_PKTTYPE: ::c_int = 19;\npub const NFT_META_CPU: ::c_int = 20;\npub const NFT_META_IIFGROUP: ::c_int = 21;\npub const NFT_META_OIFGROUP: ::c_int = 22;\npub const NFT_META_CGROUP: ::c_int = 23;\npub const NFT_META_PRANDOM: ::c_int = 24;\n\npub const NFT_CT_STATE: ::c_int = 0;\npub const NFT_CT_DIRECTION: ::c_int = 1;\npub const NFT_CT_STATUS: ::c_int = 2;\npub const NFT_CT_MARK: ::c_int = 3;\npub const NFT_CT_SECMARK: ::c_int = 4;\npub const NFT_CT_EXPIRATION: ::c_int = 5;\npub const NFT_CT_HELPER: ::c_int = 6;\npub const NFT_CT_L3PROTOCOL: ::c_int = 7;\npub const NFT_CT_SRC: ::c_int = 8;\npub const NFT_CT_DST: ::c_int = 9;\npub const NFT_CT_PROTOCOL: ::c_int = 10;\npub const NFT_CT_PROTO_SRC: ::c_int = 11;\npub const NFT_CT_PROTO_DST: ::c_int = 12;\npub const NFT_CT_LABELS: ::c_int = 13;\npub const NFT_CT_PKTS: ::c_int = 14;\npub const NFT_CT_BYTES: ::c_int = 15;\n\npub const NFT_LIMIT_PKTS: ::c_int = 0;\npub const NFT_LIMIT_PKT_BYTES: ::c_int = 1;\n\npub const NFT_LIMIT_F_INV: ::c_int = 1 << 0;\n\npub const NFT_QUEUE_FLAG_BYPASS: ::c_int = 0x01;\npub const NFT_QUEUE_FLAG_CPU_FANOUT: ::c_int = 0x02;\npub const NFT_QUEUE_FLAG_MASK: ::c_int = 0x03;\n\npub const NFT_QUOTA_F_INV: ::c_int = 1 << 0;\n\npub const NFT_REJECT_ICMP_UNREACH: ::c_int = 0;\npub const NFT_REJECT_TCP_RST: ::c_int = 1;\npub const NFT_REJECT_ICMPX_UNREACH: ::c_int = 2;\n\npub const NFT_REJECT_ICMPX_NO_ROUTE: ::c_int = 0;\npub const NFT_REJECT_ICMPX_PORT_UNREACH: ::c_int = 1;\npub const NFT_REJECT_ICMPX_HOST_UNREACH: ::c_int = 2;\npub const NFT_REJECT_ICMPX_ADMIN_PROHIBITED: ::c_int = 3;\n\npub const NFT_NAT_SNAT: ::c_int = 0;\npub const NFT_NAT_DNAT: ::c_int = 1;\n\npub const NFT_TRACETYPE_UNSPEC: ::c_int = 0;\npub const NFT_TRACETYPE_POLICY: ::c_int = 1;\npub const NFT_TRACETYPE_RETURN: ::c_int = 2;\npub const NFT_TRACETYPE_RULE: ::c_int = 3;\n\npub const NFT_NG_INCREMENTAL: ::c_int = 0;\npub const NFT_NG_RANDOM: ::c_int = 1;\n\npub const IFF_TUN: ::c_int = 0x0001;\npub const IFF_TAP: ::c_int = 0x0002;\npub const IFF_NO_PI: ::c_int = 0x1000;\n\n// start android/platform/bionic/libc/kernel/uapi/linux/if_ether.h\n// from https://android.googlesource.com/\n// platform/bionic/+/master/libc/kernel/uapi/linux/if_ether.h\npub const ETH_ALEN: ::c_int = 6;\npub const ETH_HLEN: ::c_int = 14;\npub const ETH_ZLEN: ::c_int = 60;\npub const ETH_DATA_LEN: ::c_int = 1500;\npub const ETH_FRAME_LEN: ::c_int = 1514;\npub const ETH_FCS_LEN: ::c_int = 4;\npub const ETH_MIN_MTU: ::c_int = 68;\npub const ETH_MAX_MTU: ::c_int = 0xFFFF;\npub const ETH_P_LOOP: ::c_int = 0x0060;\npub const ETH_P_PUP: ::c_int = 0x0200;\npub const ETH_P_PUPAT: ::c_int = 0x0201;\npub const ETH_P_TSN: ::c_int = 0x22F0;\npub const ETH_P_IP: ::c_int = 0x0800;\npub const ETH_P_X25: ::c_int = 0x0805;\npub const ETH_P_ARP: ::c_int = 0x0806;\npub const ETH_P_BPQ: ::c_int = 0x08FF;\npub const ETH_P_IEEEPUP: ::c_int = 0x0a00;\npub const ETH_P_IEEEPUPAT: ::c_int = 0x0a01;\npub const ETH_P_BATMAN: ::c_int = 0x4305;\npub const ETH_P_DEC: ::c_int = 0x6000;\npub const ETH_P_DNA_DL: ::c_int = 0x6001;\npub const ETH_P_DNA_RC: ::c_int = 0x6002;\npub const ETH_P_DNA_RT: ::c_int = 0x6003;\npub const ETH_P_LAT: ::c_int = 0x6004;\npub const ETH_P_DIAG: ::c_int = 0x6005;\npub const ETH_P_CUST: ::c_int = 0x6006;\npub const ETH_P_SCA: ::c_int = 0x6007;\npub const ETH_P_TEB: ::c_int = 0x6558;\npub const ETH_P_RARP: ::c_int = 0x8035;\npub const ETH_P_ATALK: ::c_int = 0x809B;\npub const ETH_P_AARP: ::c_int = 0x80F3;\npub const ETH_P_8021Q: ::c_int = 0x8100;\n/* see rust-lang/libc#924 pub const ETH_P_ERSPAN: ::c_int = 0x88BE;*/\npub const ETH_P_IPX: ::c_int = 0x8137;\npub const ETH_P_IPV6: ::c_int = 0x86DD;\npub const ETH_P_PAUSE: ::c_int = 0x8808;\npub const ETH_P_SLOW: ::c_int = 0x8809;\npub const ETH_P_WCCP: ::c_int = 0x883E;\npub const ETH_P_MPLS_UC: ::c_int = 0x8847;\npub const ETH_P_MPLS_MC: ::c_int = 0x8848;\npub const ETH_P_ATMMPOA: ::c_int = 0x884c;\npub const ETH_P_PPP_DISC: ::c_int = 0x8863;\npub const ETH_P_PPP_SES: ::c_int = 0x8864;\npub const ETH_P_LINK_CTL: ::c_int = 0x886c;\npub const ETH_P_ATMFATE: ::c_int = 0x8884;\npub const ETH_P_PAE: ::c_int = 0x888E;\npub const ETH_P_AOE: ::c_int = 0x88A2;\npub const ETH_P_8021AD: ::c_int = 0x88A8;\npub const ETH_P_802_EX1: ::c_int = 0x88B5;\npub const ETH_P_TIPC: ::c_int = 0x88CA;\npub const ETH_P_MACSEC: ::c_int = 0x88E5;\npub const ETH_P_8021AH: ::c_int = 0x88E7;\npub const ETH_P_MVRP: ::c_int = 0x88F5;\npub const ETH_P_1588: ::c_int = 0x88F7;\npub const ETH_P_NCSI: ::c_int = 0x88F8;\npub const ETH_P_PRP: ::c_int = 0x88FB;\npub const ETH_P_FCOE: ::c_int = 0x8906;\n/* see rust-lang/libc#924 pub const ETH_P_IBOE: ::c_int = 0x8915;*/\npub const ETH_P_TDLS: ::c_int = 0x890D;\npub const ETH_P_FIP: ::c_int = 0x8914;\npub const ETH_P_80221: ::c_int = 0x8917;\npub const ETH_P_HSR: ::c_int = 0x892F;\n/* see rust-lang/libc#924 pub const ETH_P_NSH: ::c_int = 0x894F;*/\npub const ETH_P_LOOPBACK: ::c_int = 0x9000;\npub const ETH_P_QINQ1: ::c_int = 0x9100;\npub const ETH_P_QINQ2: ::c_int = 0x9200;\npub const ETH_P_QINQ3: ::c_int = 0x9300;\npub const ETH_P_EDSA: ::c_int = 0xDADA;\n/* see rust-lang/libc#924 pub const ETH_P_IFE: ::c_int = 0xED3E;*/\npub const ETH_P_AF_IUCV: ::c_int = 0xFBFB;\npub const ETH_P_802_3_MIN: ::c_int = 0x0600;\npub const ETH_P_802_3: ::c_int = 0x0001;\npub const ETH_P_AX25: ::c_int = 0x0002;\npub const ETH_P_ALL: ::c_int = 0x0003;\npub const ETH_P_802_2: ::c_int = 0x0004;\npub const ETH_P_SNAP: ::c_int = 0x0005;\npub const ETH_P_DDCMP: ::c_int = 0x0006;\npub const ETH_P_WAN_PPP: ::c_int = 0x0007;\npub const ETH_P_PPP_MP: ::c_int = 0x0008;\npub const ETH_P_LOCALTALK: ::c_int = 0x0009;\npub const ETH_P_CAN: ::c_int = 0x000C;\npub const ETH_P_CANFD: ::c_int = 0x000D;\npub const ETH_P_PPPTALK: ::c_int = 0x0010;\npub const ETH_P_TR_802_2: ::c_int = 0x0011;\npub const ETH_P_MOBITEX: ::c_int = 0x0015;\npub const ETH_P_CONTROL: ::c_int = 0x0016;\npub const ETH_P_IRDA: ::c_int = 0x0017;\npub const ETH_P_ECONET: ::c_int = 0x0018;\npub const ETH_P_HDLC: ::c_int = 0x0019;\npub const ETH_P_ARCNET: ::c_int = 0x001A;\npub const ETH_P_DSA: ::c_int = 0x001B;\npub const ETH_P_TRAILER: ::c_int = 0x001C;\npub const ETH_P_PHONET: ::c_int = 0x00F5;\npub const ETH_P_IEEE802154: ::c_int = 0x00F6;\npub const ETH_P_CAIF: ::c_int = 0x00F7;\npub const ETH_P_XDSA: ::c_int = 0x00F8;\n/* see rust-lang/libc#924 pub const ETH_P_MAP: ::c_int = 0x00F9;*/\n// end android/platform/bionic/libc/kernel/uapi/linux/if_ether.h\n\npub const SIOCADDRT: ::c_ulong = 0x0000890B;\npub const SIOCDELRT: ::c_ulong = 0x0000890C;\npub const SIOCGIFNAME: ::c_ulong = 0x00008910;\npub const SIOCSIFLINK: ::c_ulong = 0x00008911;\npub const SIOCGIFCONF: ::c_ulong = 0x00008912;\npub const SIOCGIFFLAGS: ::c_ulong = 0x00008913;\npub const SIOCSIFFLAGS: ::c_ulong = 0x00008914;\npub const SIOCGIFADDR: ::c_ulong = 0x00008915;\npub const SIOCSIFADDR: ::c_ulong = 0x00008916;\npub const SIOCGIFDSTADDR: ::c_ulong = 0x00008917;\npub const SIOCSIFDSTADDR: ::c_ulong = 0x00008918;\npub const SIOCGIFBRDADDR: ::c_ulong = 0x00008919;\npub const SIOCSIFBRDADDR: ::c_ulong = 0x0000891A;\npub const SIOCGIFNETMASK: ::c_ulong = 0x0000891B;\npub const SIOCSIFNETMASK: ::c_ulong = 0x0000891C;\npub const SIOCGIFMETRIC: ::c_ulong = 0x0000891D;\npub const SIOCSIFMETRIC: ::c_ulong = 0x0000891E;\npub const SIOCGIFMEM: ::c_ulong = 0x0000891F;\npub const SIOCSIFMEM: ::c_ulong = 0x00008920;\npub const SIOCGIFMTU: ::c_ulong = 0x00008921;\npub const SIOCSIFMTU: ::c_ulong = 0x00008922;\npub const SIOCSIFHWADDR: ::c_ulong = 0x00008924;\npub const SIOCGIFENCAP: ::c_ulong = 0x00008925;\npub const SIOCSIFENCAP: ::c_ulong = 0x00008926;\npub const SIOCGIFHWADDR: ::c_ulong = 0x00008927;\npub const SIOCGIFSLAVE: ::c_ulong = 0x00008929;\npub const SIOCSIFSLAVE: ::c_ulong = 0x00008930;\npub const SIOCADDMULTI: ::c_ulong = 0x00008931;\npub const SIOCDELMULTI: ::c_ulong = 0x00008932;\npub const SIOCDARP: ::c_ulong = 0x00008953;\npub const SIOCGARP: ::c_ulong = 0x00008954;\npub const SIOCSARP: ::c_ulong = 0x00008955;\npub const SIOCDRARP: ::c_ulong = 0x00008960;\npub const SIOCGRARP: ::c_ulong = 0x00008961;\npub const SIOCSRARP: ::c_ulong = 0x00008962;\npub const SIOCGIFMAP: ::c_ulong = 0x00008970;\npub const SIOCSIFMAP: ::c_ulong = 0x00008971;\n\n// linux/module.h\npub const MODULE_INIT_IGNORE_MODVERSIONS: ::c_uint = 0x0001;\npub const MODULE_INIT_IGNORE_VERMAGIC: ::c_uint = 0x0002;\n\n#[deprecated(\n    since = \"0.2.55\",\n    note = \"ENOATTR is not available on Android; use ENODATA instead\"\n)]\npub const ENOATTR: ::c_int = ::ENODATA;\n\n// linux/if_alg.h\npub const ALG_SET_KEY: ::c_int = 1;\npub const ALG_SET_IV: ::c_int = 2;\npub const ALG_SET_OP: ::c_int = 3;\npub const ALG_SET_AEAD_ASSOCLEN: ::c_int = 4;\npub const ALG_SET_AEAD_AUTHSIZE: ::c_int = 5;\n\npub const ALG_OP_DECRYPT: ::c_int = 0;\npub const ALG_OP_ENCRYPT: ::c_int = 1;\n\n// uapi/linux/vm_sockets.h\npub const VMADDR_CID_ANY: ::c_uint = 0xFFFFFFFF;\npub const VMADDR_CID_HYPERVISOR: ::c_uint = 0;\npub const VMADDR_CID_LOCAL: ::c_uint = 1;\npub const VMADDR_CID_HOST: ::c_uint = 2;\npub const VMADDR_PORT_ANY: ::c_uint = 0xFFFFFFFF;\n\n// uapi/linux/inotify.h\npub const IN_ACCESS: u32 = 0x0000_0001;\npub const IN_MODIFY: u32 = 0x0000_0002;\npub const IN_ATTRIB: u32 = 0x0000_0004;\npub const IN_CLOSE_WRITE: u32 = 0x0000_0008;\npub const IN_CLOSE_NOWRITE: u32 = 0x0000_0010;\npub const IN_CLOSE: u32 = IN_CLOSE_WRITE | IN_CLOSE_NOWRITE;\npub const IN_OPEN: u32 = 0x0000_0020;\npub const IN_MOVED_FROM: u32 = 0x0000_0040;\npub const IN_MOVED_TO: u32 = 0x0000_0080;\npub const IN_MOVE: u32 = IN_MOVED_FROM | IN_MOVED_TO;\npub const IN_CREATE: u32 = 0x0000_0100;\npub const IN_DELETE: u32 = 0x0000_0200;\npub const IN_DELETE_SELF: u32 = 0x0000_0400;\npub const IN_MOVE_SELF: u32 = 0x0000_0800;\npub const IN_UNMOUNT: u32 = 0x0000_2000;\npub const IN_Q_OVERFLOW: u32 = 0x0000_4000;\npub const IN_IGNORED: u32 = 0x0000_8000;\npub const IN_ONLYDIR: u32 = 0x0100_0000;\npub const IN_DONT_FOLLOW: u32 = 0x0200_0000;\n// pub const IN_EXCL_UNLINK:   u32 = 0x0400_0000;\n\n// pub const IN_MASK_CREATE:   u32 = 0x1000_0000;\n// pub const IN_MASK_ADD:      u32 = 0x2000_0000;\npub const IN_ISDIR: u32 = 0x4000_0000;\npub const IN_ONESHOT: u32 = 0x8000_0000;\n\npub const IN_ALL_EVENTS: u32 = IN_ACCESS\n    | IN_MODIFY\n    | IN_ATTRIB\n    | IN_CLOSE_WRITE\n    | IN_CLOSE_NOWRITE\n    | IN_OPEN\n    | IN_MOVED_FROM\n    | IN_MOVED_TO\n    | IN_DELETE\n    | IN_CREATE\n    | IN_DELETE_SELF\n    | IN_MOVE_SELF;\n\npub const IN_CLOEXEC: ::c_int = O_CLOEXEC;\npub const IN_NONBLOCK: ::c_int = O_NONBLOCK;\n\npub const FUTEX_WAIT: ::c_int = 0;\npub const FUTEX_WAKE: ::c_int = 1;\npub const FUTEX_FD: ::c_int = 2;\npub const FUTEX_REQUEUE: ::c_int = 3;\npub const FUTEX_CMP_REQUEUE: ::c_int = 4;\npub const FUTEX_WAKE_OP: ::c_int = 5;\npub const FUTEX_LOCK_PI: ::c_int = 6;\npub const FUTEX_UNLOCK_PI: ::c_int = 7;\npub const FUTEX_TRYLOCK_PI: ::c_int = 8;\npub const FUTEX_WAIT_BITSET: ::c_int = 9;\npub const FUTEX_WAKE_BITSET: ::c_int = 10;\npub const FUTEX_WAIT_REQUEUE_PI: ::c_int = 11;\npub const FUTEX_CMP_REQUEUE_PI: ::c_int = 12;\n\npub const FUTEX_PRIVATE_FLAG: ::c_int = 128;\npub const FUTEX_CLOCK_REALTIME: ::c_int = 256;\npub const FUTEX_CMD_MASK: ::c_int = !(FUTEX_PRIVATE_FLAG | FUTEX_CLOCK_REALTIME);\n\n// linux/errqueue.h\npub const SO_EE_ORIGIN_NONE: u8 = 0;\npub const SO_EE_ORIGIN_LOCAL: u8 = 1;\npub const SO_EE_ORIGIN_ICMP: u8 = 2;\npub const SO_EE_ORIGIN_ICMP6: u8 = 3;\npub const SO_EE_ORIGIN_TXSTATUS: u8 = 4;\npub const SO_EE_ORIGIN_TIMESTAMPING: u8 = SO_EE_ORIGIN_TXSTATUS;\n\n// errno.h\npub const EPERM: ::c_int = 1;\npub const ENOENT: ::c_int = 2;\npub const ESRCH: ::c_int = 3;\npub const EINTR: ::c_int = 4;\npub const EIO: ::c_int = 5;\npub const ENXIO: ::c_int = 6;\npub const E2BIG: ::c_int = 7;\npub const ENOEXEC: ::c_int = 8;\npub const EBADF: ::c_int = 9;\npub const ECHILD: ::c_int = 10;\npub const EAGAIN: ::c_int = 11;\npub const ENOMEM: ::c_int = 12;\npub const EACCES: ::c_int = 13;\npub const EFAULT: ::c_int = 14;\npub const ENOTBLK: ::c_int = 15;\npub const EBUSY: ::c_int = 16;\npub const EEXIST: ::c_int = 17;\npub const EXDEV: ::c_int = 18;\npub const ENODEV: ::c_int = 19;\npub const ENOTDIR: ::c_int = 20;\npub const EISDIR: ::c_int = 21;\npub const EINVAL: ::c_int = 22;\npub const ENFILE: ::c_int = 23;\npub const EMFILE: ::c_int = 24;\npub const ENOTTY: ::c_int = 25;\npub const ETXTBSY: ::c_int = 26;\npub const EFBIG: ::c_int = 27;\npub const ENOSPC: ::c_int = 28;\npub const ESPIPE: ::c_int = 29;\npub const EROFS: ::c_int = 30;\npub const EMLINK: ::c_int = 31;\npub const EPIPE: ::c_int = 32;\npub const EDOM: ::c_int = 33;\npub const ERANGE: ::c_int = 34;\npub const EWOULDBLOCK: ::c_int = EAGAIN;\n\npub const PRIO_PROCESS: ::c_int = 0;\npub const PRIO_PGRP: ::c_int = 1;\npub const PRIO_USER: ::c_int = 2;\n\n// linux/sched.h\npub const SCHED_NORMAL: ::c_int = 0;\npub const SCHED_FIFO: ::c_int = 1;\npub const SCHED_RR: ::c_int = 2;\npub const SCHED_BATCH: ::c_int = 3;\npub const SCHED_IDLE: ::c_int = 5;\npub const SCHED_DEADLINE: ::c_int = 6;\n\n// bits/seek_constants.h\npub const SEEK_DATA: ::c_int = 3;\npub const SEEK_HOLE: ::c_int = 4;\n\n// sys/socket.h\npub const AF_NFC: ::c_int = 39;\npub const AF_VSOCK: ::c_int = 40;\npub const PF_NFC: ::c_int = AF_NFC;\npub const PF_VSOCK: ::c_int = AF_VSOCK;\n\n// sys/system_properties.h\npub const PROP_VALUE_MAX: ::c_int = 92;\n\nf! {\n    pub fn CMSG_NXTHDR(mhdr: *const msghdr,\n                       cmsg: *const cmsghdr) -> *mut cmsghdr {\n        let next = (cmsg as usize\n                    + super::CMSG_ALIGN((*cmsg).cmsg_len as usize))\n            as *mut cmsghdr;\n        let max = (*mhdr).msg_control as usize\n            + (*mhdr).msg_controllen as usize;\n        if (next.offset(1)) as usize > max {\n            0 as *mut cmsghdr\n        } else {\n            next as *mut cmsghdr\n        }\n    }\n\n    pub fn CPU_ZERO(cpuset: &mut cpu_set_t) -> () {\n        for slot in cpuset.__bits.iter_mut() {\n            *slot = 0;\n        }\n    }\n\n    pub fn CPU_SET(cpu: usize, cpuset: &mut cpu_set_t) -> () {\n        let size_in___bits = 8 * ::mem::size_of_val(&cpuset.__bits[0]);\n        let (idx, offset) = (cpu / size_in___bits, cpu % size_in___bits);\n        cpuset.__bits[idx] |= 1 << offset;\n        ()\n    }\n\n    pub fn CPU_CLR(cpu: usize, cpuset: &mut cpu_set_t) -> () {\n        let size_in___bits = 8 * ::mem::size_of_val(&cpuset.__bits[0]);\n        let (idx, offset) = (cpu / size_in___bits, cpu % size_in___bits);\n        cpuset.__bits[idx] &= !(1 << offset);\n        ()\n    }\n\n    pub fn CPU_ISSET(cpu: usize, cpuset: &cpu_set_t) -> bool {\n        let size_in___bits = 8 * ::mem::size_of_val(&cpuset.__bits[0]);\n        let (idx, offset) = (cpu / size_in___bits, cpu % size_in___bits);\n        0 != (cpuset.__bits[idx] & (1 << offset))\n    }\n\n    pub fn CPU_EQUAL(set1: &cpu_set_t, set2: &cpu_set_t) -> bool {\n        set1.__bits == set2.__bits\n    }\n    pub fn major(dev: ::dev_t) -> ::c_int {\n        ((dev >> 8) & 0xfff) as ::c_int\n    }\n    pub fn minor(dev: ::dev_t) -> ::c_int {\n        ((dev & 0xff) | ((dev >> 12) & 0xfff00)) as ::c_int\n    }\n    pub fn makedev(ma: ::c_int, mi: ::c_int) -> ::dev_t {\n        let ma = ma as ::dev_t;\n        let mi = mi as ::dev_t;\n        ((ma & 0xfff) << 8) | (mi & 0xff) | ((mi & 0xfff00) << 12)\n    }\n\n    pub fn NLA_ALIGN(len: ::c_int) -> ::c_int {\n        return ((len) + NLA_ALIGNTO - 1) & !(NLA_ALIGNTO - 1)\n    }\n\n    pub fn SO_EE_OFFENDER(ee: *const ::sock_extended_err) -> *mut ::sockaddr {\n        ee.offset(1) as *mut ::sockaddr\n    }\n}\n\nextern \"C\" {\n    pub fn getrlimit64(resource: ::c_int, rlim: *mut rlimit64) -> ::c_int;\n    pub fn setrlimit64(resource: ::c_int, rlim: *const rlimit64) -> ::c_int;\n    pub fn getrlimit(resource: ::c_int, rlim: *mut ::rlimit) -> ::c_int;\n    pub fn setrlimit(resource: ::c_int, rlim: *const ::rlimit) -> ::c_int;\n    pub fn prlimit(\n        pid: ::pid_t,\n        resource: ::c_int,\n        new_limit: *const ::rlimit,\n        old_limit: *mut ::rlimit,\n    ) -> ::c_int;\n    pub fn prlimit64(\n        pid: ::pid_t,\n        resource: ::c_int,\n        new_limit: *const ::rlimit64,\n        old_limit: *mut ::rlimit64,\n    ) -> ::c_int;\n    pub fn strerror_r(errnum: ::c_int, buf: *mut c_char, buflen: ::size_t) -> ::c_int;\n\n    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::timezone) -> ::c_int;\n    pub fn madvise(addr: *mut ::c_void, len: ::size_t, advice: ::c_int) -> ::c_int;\n    pub fn ioctl(fd: ::c_int, request: ::c_int, ...) -> ::c_int;\n    pub fn msync(addr: *mut ::c_void, len: ::size_t, flags: ::c_int) -> ::c_int;\n    pub fn mprotect(addr: *mut ::c_void, len: ::size_t, prot: ::c_int) -> ::c_int;\n    pub fn recvfrom(\n        socket: ::c_int,\n        buf: *mut ::c_void,\n        len: ::size_t,\n        flags: ::c_int,\n        addr: *mut ::sockaddr,\n        addrlen: *mut ::socklen_t,\n    ) -> ::ssize_t;\n    pub fn getnameinfo(\n        sa: *const ::sockaddr,\n        salen: ::socklen_t,\n        host: *mut ::c_char,\n        hostlen: ::size_t,\n        serv: *mut ::c_char,\n        sevlen: ::size_t,\n        flags: ::c_int,\n    ) -> ::c_int;\n    pub fn preadv(fd: ::c_int, iov: *const ::iovec, count: ::c_int, offset: ::off_t) -> ::ssize_t;\n    pub fn pwritev(fd: ::c_int, iov: *const ::iovec, count: ::c_int, offset: ::off_t) -> ::ssize_t;\n    pub fn process_vm_readv(\n        pid: ::pid_t,\n        local_iov: *const ::iovec,\n        local_iov_count: ::c_ulong,\n        remote_iov: *const ::iovec,\n        remote_iov_count: ::c_ulong,\n        flags: ::c_ulong,\n    ) -> ::ssize_t;\n    pub fn process_vm_writev(\n        pid: ::pid_t,\n        local_iov: *const ::iovec,\n        local_iov_count: ::c_ulong,\n        remote_iov: *const ::iovec,\n        remote_iov_count: ::c_ulong,\n        flags: ::c_ulong,\n    ) -> ::ssize_t;\n    pub fn ptrace(request: ::c_int, ...) -> ::c_long;\n    pub fn getpriority(which: ::c_int, who: ::id_t) -> ::c_int;\n    pub fn setpriority(which: ::c_int, who: ::id_t, prio: ::c_int) -> ::c_int;\n    pub fn __sched_cpualloc(count: ::size_t) -> *mut ::cpu_set_t;\n    pub fn __sched_cpufree(set: *mut ::cpu_set_t);\n    pub fn __sched_cpucount(setsize: ::size_t, set: *const cpu_set_t) -> ::c_int;\n    pub fn sched_getcpu() -> ::c_int;\n\n    pub fn utmpname(name: *const ::c_char) -> ::c_int;\n    pub fn setutent();\n    pub fn getutent() -> *mut utmp;\n\n    pub fn seekdir(dirp: *mut ::DIR, loc: ::c_long);\n    pub fn telldir(dirp: *mut ::DIR) -> ::c_long;\n    pub fn fallocate(fd: ::c_int, mode: ::c_int, offset: ::off_t, len: ::off_t) -> ::c_int;\n    pub fn fallocate64(fd: ::c_int, mode: ::c_int, offset: ::off64_t, len: ::off64_t) -> ::c_int;\n    pub fn posix_fallocate(fd: ::c_int, offset: ::off_t, len: ::off_t) -> ::c_int;\n    pub fn posix_fallocate64(fd: ::c_int, offset: ::off64_t, len: ::off64_t) -> ::c_int;\n    pub fn getxattr(\n        path: *const c_char,\n        name: *const c_char,\n        value: *mut ::c_void,\n        size: ::size_t,\n    ) -> ::ssize_t;\n    pub fn lgetxattr(\n        path: *const c_char,\n        name: *const c_char,\n        value: *mut ::c_void,\n        size: ::size_t,\n    ) -> ::ssize_t;\n    pub fn fgetxattr(\n        filedes: ::c_int,\n        name: *const c_char,\n        value: *mut ::c_void,\n        size: ::size_t,\n    ) -> ::ssize_t;\n    pub fn setxattr(\n        path: *const c_char,\n        name: *const c_char,\n        value: *const ::c_void,\n        size: ::size_t,\n        flags: ::c_int,\n    ) -> ::c_int;\n    pub fn lsetxattr(\n        path: *const c_char,\n        name: *const c_char,\n        value: *const ::c_void,\n        size: ::size_t,\n        flags: ::c_int,\n    ) -> ::c_int;\n    pub fn fsetxattr(\n        filedes: ::c_int,\n        name: *const c_char,\n        value: *const ::c_void,\n        size: ::size_t,\n        flags: ::c_int,\n    ) -> ::c_int;\n    pub fn listxattr(path: *const c_char, list: *mut c_char, size: ::size_t) -> ::ssize_t;\n    pub fn llistxattr(path: *const c_char, list: *mut c_char, size: ::size_t) -> ::ssize_t;\n    pub fn flistxattr(filedes: ::c_int, list: *mut c_char, size: ::size_t) -> ::ssize_t;\n    pub fn removexattr(path: *const c_char, name: *const c_char) -> ::c_int;\n    pub fn lremovexattr(path: *const c_char, name: *const c_char) -> ::c_int;\n    pub fn fremovexattr(filedes: ::c_int, name: *const c_char) -> ::c_int;\n    pub fn signalfd(fd: ::c_int, mask: *const ::sigset_t, flags: ::c_int) -> ::c_int;\n    pub fn timerfd_create(clock: ::clockid_t, flags: ::c_int) -> ::c_int;\n    pub fn timerfd_gettime(fd: ::c_int, current_value: *mut itimerspec) -> ::c_int;\n    pub fn timerfd_settime(\n        fd: ::c_int,\n        flags: ::c_int,\n        new_value: *const itimerspec,\n        old_value: *mut itimerspec,\n    ) -> ::c_int;\n    pub fn syscall(num: ::c_long, ...) -> ::c_long;\n    pub fn sched_getaffinity(pid: ::pid_t, cpusetsize: ::size_t, cpuset: *mut cpu_set_t)\n        -> ::c_int;\n    pub fn sched_setaffinity(\n        pid: ::pid_t,\n        cpusetsize: ::size_t,\n        cpuset: *const cpu_set_t,\n    ) -> ::c_int;\n    pub fn epoll_create(size: ::c_int) -> ::c_int;\n    pub fn epoll_create1(flags: ::c_int) -> ::c_int;\n    pub fn epoll_wait(\n        epfd: ::c_int,\n        events: *mut ::epoll_event,\n        maxevents: ::c_int,\n        timeout: ::c_int,\n    ) -> ::c_int;\n    pub fn epoll_ctl(epfd: ::c_int, op: ::c_int, fd: ::c_int, event: *mut ::epoll_event)\n        -> ::c_int;\n    pub fn pthread_getschedparam(\n        native: ::pthread_t,\n        policy: *mut ::c_int,\n        param: *mut ::sched_param,\n    ) -> ::c_int;\n    pub fn unshare(flags: ::c_int) -> ::c_int;\n    pub fn umount(target: *const ::c_char) -> ::c_int;\n    pub fn sched_get_priority_max(policy: ::c_int) -> ::c_int;\n    pub fn tee(fd_in: ::c_int, fd_out: ::c_int, len: ::size_t, flags: ::c_uint) -> ::ssize_t;\n    pub fn settimeofday(tv: *const ::timeval, tz: *const ::timezone) -> ::c_int;\n    pub fn splice(\n        fd_in: ::c_int,\n        off_in: *mut ::loff_t,\n        fd_out: ::c_int,\n        off_out: *mut ::loff_t,\n        len: ::size_t,\n        flags: ::c_uint,\n    ) -> ::ssize_t;\n    pub fn eventfd(init: ::c_uint, flags: ::c_int) -> ::c_int;\n    pub fn sched_rr_get_interval(pid: ::pid_t, tp: *mut ::timespec) -> ::c_int;\n    pub fn sem_timedwait(sem: *mut sem_t, abstime: *const ::timespec) -> ::c_int;\n    pub fn sem_getvalue(sem: *mut sem_t, sval: *mut ::c_int) -> ::c_int;\n    pub fn sched_setparam(pid: ::pid_t, param: *const ::sched_param) -> ::c_int;\n    pub fn setns(fd: ::c_int, nstype: ::c_int) -> ::c_int;\n    pub fn swapoff(puath: *const ::c_char) -> ::c_int;\n    pub fn vmsplice(\n        fd: ::c_int,\n        iov: *const ::iovec,\n        nr_segs: ::size_t,\n        flags: ::c_uint,\n    ) -> ::ssize_t;\n    pub fn mount(\n        src: *const ::c_char,\n        target: *const ::c_char,\n        fstype: *const ::c_char,\n        flags: ::c_ulong,\n        data: *const ::c_void,\n    ) -> ::c_int;\n    pub fn personality(persona: ::c_uint) -> ::c_int;\n    pub fn prctl(option: ::c_int, ...) -> ::c_int;\n    pub fn sched_getparam(pid: ::pid_t, param: *mut ::sched_param) -> ::c_int;\n    pub fn ppoll(\n        fds: *mut ::pollfd,\n        nfds: nfds_t,\n        timeout: *const ::timespec,\n        sigmask: *const sigset_t,\n    ) -> ::c_int;\n    pub fn pthread_mutex_timedlock(\n        lock: *mut pthread_mutex_t,\n        abstime: *const ::timespec,\n    ) -> ::c_int;\n    pub fn clone(\n        cb: extern \"C\" fn(*mut ::c_void) -> ::c_int,\n        child_stack: *mut ::c_void,\n        flags: ::c_int,\n        arg: *mut ::c_void,\n        ...\n    ) -> ::c_int;\n    pub fn sched_getscheduler(pid: ::pid_t) -> ::c_int;\n    pub fn clock_nanosleep(\n        clk_id: ::clockid_t,\n        flags: ::c_int,\n        rqtp: *const ::timespec,\n        rmtp: *mut ::timespec,\n    ) -> ::c_int;\n    pub fn pthread_attr_getguardsize(\n        attr: *const ::pthread_attr_t,\n        guardsize: *mut ::size_t,\n    ) -> ::c_int;\n    pub fn sethostname(name: *const ::c_char, len: ::size_t) -> ::c_int;\n    pub fn sched_get_priority_min(policy: ::c_int) -> ::c_int;\n    pub fn pthread_condattr_getpshared(\n        attr: *const pthread_condattr_t,\n        pshared: *mut ::c_int,\n    ) -> ::c_int;\n    pub fn sysinfo(info: *mut ::sysinfo) -> ::c_int;\n    pub fn umount2(target: *const ::c_char, flags: ::c_int) -> ::c_int;\n    pub fn pthread_setschedparam(\n        native: ::pthread_t,\n        policy: ::c_int,\n        param: *const ::sched_param,\n    ) -> ::c_int;\n    pub fn swapon(path: *const ::c_char, swapflags: ::c_int) -> ::c_int;\n    pub fn sched_setscheduler(\n        pid: ::pid_t,\n        policy: ::c_int,\n        param: *const ::sched_param,\n    ) -> ::c_int;\n    pub fn sendfile(\n        out_fd: ::c_int,\n        in_fd: ::c_int,\n        offset: *mut off_t,\n        count: ::size_t,\n    ) -> ::ssize_t;\n    pub fn setfsgid(gid: ::gid_t) -> ::c_int;\n    pub fn setfsuid(uid: ::uid_t) -> ::c_int;\n    pub fn sigsuspend(mask: *const ::sigset_t) -> ::c_int;\n    pub fn getgrgid_r(\n        gid: ::gid_t,\n        grp: *mut ::group,\n        buf: *mut ::c_char,\n        buflen: ::size_t,\n        result: *mut *mut ::group,\n    ) -> ::c_int;\n    pub fn sigaltstack(ss: *const stack_t, oss: *mut stack_t) -> ::c_int;\n    pub fn sem_close(sem: *mut sem_t) -> ::c_int;\n    pub fn getgrnam_r(\n        name: *const ::c_char,\n        grp: *mut ::group,\n        buf: *mut ::c_char,\n        buflen: ::size_t,\n        result: *mut *mut ::group,\n    ) -> ::c_int;\n    pub fn pthread_sigmask(how: ::c_int, set: *const sigset_t, oldset: *mut sigset_t) -> ::c_int;\n    pub fn sem_open(name: *const ::c_char, oflag: ::c_int, ...) -> *mut sem_t;\n    pub fn getgrnam(name: *const ::c_char) -> *mut ::group;\n    pub fn pthread_kill(thread: ::pthread_t, sig: ::c_int) -> ::c_int;\n    pub fn sem_unlink(name: *const ::c_char) -> ::c_int;\n    pub fn daemon(nochdir: ::c_int, noclose: ::c_int) -> ::c_int;\n    pub fn getpwnam_r(\n        name: *const ::c_char,\n        pwd: *mut passwd,\n        buf: *mut ::c_char,\n        buflen: ::size_t,\n        result: *mut *mut passwd,\n    ) -> ::c_int;\n    pub fn getpwuid_r(\n        uid: ::uid_t,\n        pwd: *mut passwd,\n        buf: *mut ::c_char,\n        buflen: ::size_t,\n        result: *mut *mut passwd,\n    ) -> ::c_int;\n    pub fn sigtimedwait(\n        set: *const sigset_t,\n        info: *mut siginfo_t,\n        timeout: *const ::timespec,\n    ) -> ::c_int;\n    pub fn sigwait(set: *const sigset_t, sig: *mut ::c_int) -> ::c_int;\n    pub fn pthread_atfork(\n        prepare: ::Option<unsafe extern \"C\" fn()>,\n        parent: ::Option<unsafe extern \"C\" fn()>,\n        child: ::Option<unsafe extern \"C\" fn()>,\n    ) -> ::c_int;\n    pub fn getgrgid(gid: ::gid_t) -> *mut ::group;\n    pub fn getgrouplist(\n        user: *const ::c_char,\n        group: ::gid_t,\n        groups: *mut ::gid_t,\n        ngroups: *mut ::c_int,\n    ) -> ::c_int;\n    pub fn initgroups(user: *const ::c_char, group: ::gid_t) -> ::c_int;\n    pub fn pthread_mutexattr_getpshared(\n        attr: *const pthread_mutexattr_t,\n        pshared: *mut ::c_int,\n    ) -> ::c_int;\n    pub fn popen(command: *const c_char, mode: *const c_char) -> *mut ::FILE;\n    pub fn faccessat(\n        dirfd: ::c_int,\n        pathname: *const ::c_char,\n        mode: ::c_int,\n        flags: ::c_int,\n    ) -> ::c_int;\n    pub fn pthread_create(\n        native: *mut ::pthread_t,\n        attr: *const ::pthread_attr_t,\n        f: extern \"C\" fn(*mut ::c_void) -> *mut ::c_void,\n        value: *mut ::c_void,\n    ) -> ::c_int;\n    pub fn __errno() -> *mut ::c_int;\n    pub fn inotify_rm_watch(fd: ::c_int, wd: u32) -> ::c_int;\n    pub fn sendmmsg(\n        sockfd: ::c_int,\n        msgvec: *const ::mmsghdr,\n        vlen: ::c_uint,\n        flags: ::c_int,\n    ) -> ::c_int;\n    pub fn recvmmsg(\n        sockfd: ::c_int,\n        msgvec: *mut ::mmsghdr,\n        vlen: ::c_uint,\n        flags: ::c_int,\n        timeout: *const ::timespec,\n    ) -> ::c_int;\n    pub fn inotify_init() -> ::c_int;\n    pub fn inotify_init1(flags: ::c_int) -> ::c_int;\n    pub fn inotify_add_watch(fd: ::c_int, path: *const ::c_char, mask: u32) -> ::c_int;\n\n    pub fn regcomp(preg: *mut ::regex_t, pattern: *const ::c_char, cflags: ::c_int) -> ::c_int;\n\n    pub fn regexec(\n        preg: *const ::regex_t,\n        input: *const ::c_char,\n        nmatch: ::size_t,\n        pmatch: *mut regmatch_t,\n        eflags: ::c_int,\n    ) -> ::c_int;\n\n    pub fn regerror(\n        errcode: ::c_int,\n        preg: *const ::regex_t,\n        errbuf: *mut ::c_char,\n        errbuf_size: ::size_t,\n    ) -> ::size_t;\n\n    pub fn regfree(preg: *mut ::regex_t);\n\n    pub fn android_set_abort_message(msg: *const ::c_char);\n\n    pub fn gettid() -> ::pid_t;\n\n    pub fn __system_property_set(__name: *const ::c_char, __value: *const ::c_char) -> ::c_int;\n    pub fn __system_property_get(__name: *const ::c_char, __value: *mut ::c_char) -> ::c_int;\n\n    // #include <link.h>\n    /// Only available in API Version 21+\n    pub fn dl_iterate_phdr(\n        callback: ::Option<\n            unsafe extern \"C\" fn(\n                info: *mut dl_phdr_info,\n                size: usize,\n                data: *mut ::c_void,\n            ) -> ::c_int,\n        >,\n        data: *mut ::c_void,\n    ) -> ::c_int;\n}\n\ncfg_if! {\n    if #[cfg(target_pointer_width = \"32\")] {\n        mod b32;\n        pub use self::b32::*;\n    } else if #[cfg(target_pointer_width = \"64\")] {\n        mod b64;\n        pub use self::b64::*;\n    } else {\n        // Unknown target_pointer_width\n    }\n}\n\nimpl siginfo_t {\n    pub unsafe fn si_addr(&self) -> *mut ::c_void {\n        #[repr(C)]\n        struct siginfo_sigfault {\n            _si_signo: ::c_int,\n            _si_errno: ::c_int,\n            _si_code: ::c_int,\n            si_addr: *mut ::c_void,\n        }\n        (*(self as *const siginfo_t as *const siginfo_sigfault)).si_addr\n    }\n\n    pub unsafe fn si_value(&self) -> ::sigval {\n        #[repr(C)]\n        struct siginfo_timer {\n            _si_signo: ::c_int,\n            _si_errno: ::c_int,\n            _si_code: ::c_int,\n            _si_tid: ::c_int,\n            _si_overrun: ::c_int,\n            si_sigval: ::sigval,\n        }\n        (*(self as *const siginfo_t as *const siginfo_timer)).si_sigval\n    }\n}\n\ncfg_if! {\n    if #[cfg(libc_union)] {\n        // Internal, for casts to access union fields\n        #[repr(C)]\n        struct sifields_sigchld {\n            si_pid: ::pid_t,\n            si_uid: ::uid_t,\n            si_status: ::c_int,\n            si_utime: ::c_long,\n            si_stime: ::c_long,\n        }\n        impl ::Copy for sifields_sigchld {}\n        impl ::Clone for sifields_sigchld {\n            fn clone(&self) -> sifields_sigchld {\n                *self\n            }\n        }\n\n        // Internal, for casts to access union fields\n        #[repr(C)]\n        union sifields {\n            _align_pointer: *mut ::c_void,\n            sigchld: sifields_sigchld,\n        }\n\n        // Internal, for casts to access union fields. Note that some variants\n        // of sifields start with a pointer, which makes the alignment of\n        // sifields vary on 32-bit and 64-bit architectures.\n        #[repr(C)]\n        struct siginfo_f {\n            _siginfo_base: [::c_int; 3],\n            sifields: sifields,\n        }\n\n        impl siginfo_t {\n            unsafe fn sifields(&self) -> &sifields {\n                &(*(self as *const siginfo_t as *const siginfo_f)).sifields\n            }\n\n            pub unsafe fn si_pid(&self) -> ::pid_t {\n                self.sifields().sigchld.si_pid\n            }\n\n            pub unsafe fn si_uid(&self) -> ::uid_t {\n                self.sifields().sigchld.si_uid\n            }\n\n            pub unsafe fn si_status(&self) -> ::c_int {\n                self.sifields().sigchld.si_status\n            }\n\n            pub unsafe fn si_utime(&self) -> ::c_long {\n                self.sifields().sigchld.si_utime\n            }\n\n            pub unsafe fn si_stime(&self) -> ::c_long {\n                self.sifields().sigchld.si_stime\n            }\n        }\n    }\n}\n"],["1139","// The following definitions are correct for arm and i686,\n// but may be wrong for mips\n\npub type c_long = i32;\npub type c_ulong = u32;\npub type mode_t = u16;\npub type off64_t = ::c_longlong;\npub type sigset_t = ::c_ulong;\npub type socklen_t = i32;\npub type time64_t = i64;\n\ns! {\n    pub struct sigaction {\n        pub sa_sigaction: ::sighandler_t,\n        pub sa_mask: ::sigset_t,\n        pub sa_flags: ::c_int,\n        pub sa_restorer: ::Option<extern fn()>,\n    }\n\n    pub struct rlimit64 {\n        pub rlim_cur: u64,\n        pub rlim_max: u64,\n    }\n\n    pub struct stat {\n        pub st_dev: ::c_ulonglong,\n        __pad0: [::c_uchar; 4],\n        __st_ino: ::ino_t,\n        pub st_mode: ::c_uint,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::c_ulonglong,\n        __pad3: [::c_uchar; 4],\n        pub st_size: ::c_longlong,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::c_ulonglong,\n        pub st_atime: ::c_long,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::c_long,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::c_long,\n        pub st_ctime_nsec: ::c_long,\n        pub st_ino: ::c_ulonglong,\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::c_ulonglong,\n        __pad0: [::c_uchar; 4],\n        __st_ino: ::ino_t,\n        pub st_mode: ::c_uint,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::c_ulonglong,\n        __pad3: [::c_uchar; 4],\n        pub st_size: ::c_longlong,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::c_ulonglong,\n        pub st_atime: ::c_long,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::c_long,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::c_long,\n        pub st_ctime_nsec: ::c_long,\n        pub st_ino: ::c_ulonglong,\n    }\n\n    pub struct statfs64 {\n        pub f_type: u32,\n        pub f_bsize: u32,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_fsid: ::__fsid_t,\n        pub f_namelen: u32,\n        pub f_frsize: u32,\n        pub f_flags: u32,\n        pub f_spare: [u32; 4],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: ::c_ulong,\n        pub f_bfree: ::c_ulong,\n        pub f_bavail: ::c_ulong,\n        pub f_files: ::c_ulong,\n        pub f_ffree: ::c_ulong,\n        pub f_favail: ::c_ulong,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n    }\n\n    pub struct pthread_attr_t {\n        pub flags: u32,\n        pub stack_base: *mut ::c_void,\n        pub stack_size: ::size_t,\n        pub guard_size: ::size_t,\n        pub sched_policy: i32,\n        pub sched_priority: i32,\n    }\n\n    pub struct pthread_mutex_t { value: ::c_int }\n\n    pub struct pthread_cond_t { value: ::c_int }\n\n    pub struct pthread_rwlock_t {\n        lock: pthread_mutex_t,\n        cond: pthread_cond_t,\n        numLocks: ::c_int,\n        writerThreadId: ::c_int,\n        pendingReaders: ::c_int,\n        pendingWriters: ::c_int,\n        attr: i32,\n        __reserved: [::c_char; 12],\n    }\n\n    pub struct passwd {\n        pub pw_name: *mut ::c_char,\n        pub pw_passwd: *mut ::c_char,\n        pub pw_uid: ::uid_t,\n        pub pw_gid: ::gid_t,\n        pub pw_dir: *mut ::c_char,\n        pub pw_shell: *mut ::c_char,\n    }\n\n    pub struct statfs {\n        pub f_type: u32,\n        pub f_bsize: u32,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_fsid: ::__fsid_t,\n        pub f_namelen: u32,\n        pub f_frsize: u32,\n        pub f_flags: u32,\n        pub f_spare: [u32; 4],\n    }\n\n    pub struct sysinfo {\n        pub uptime: ::c_long,\n        pub loads: [::c_ulong; 3],\n        pub totalram: ::c_ulong,\n        pub freeram: ::c_ulong,\n        pub sharedram: ::c_ulong,\n        pub bufferram: ::c_ulong,\n        pub totalswap: ::c_ulong,\n        pub freeswap: ::c_ulong,\n        pub procs: ::c_ushort,\n        pub pad: ::c_ushort,\n        pub totalhigh: ::c_ulong,\n        pub freehigh: ::c_ulong,\n        pub mem_unit: ::c_uint,\n        pub _f: [::c_char; 8],\n    }\n}\n\ns_no_extra_traits! {\n    pub struct sigset64_t {\n        __bits: [::c_ulong; 2]\n    }\n}\n\ncfg_if! {\n    if #[cfg(feature = \"extra_traits\")] {\n        impl ::fmt::Debug for sigset64_t {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"sigset64_t\")\n                    .field(\"__bits\", &self.__bits)\n                    .finish()\n            }\n        }\n    }\n}\n\n// These constants must be of the same type of sigaction.sa_flags\npub const SA_NOCLDSTOP: ::c_int = 0x00000001;\npub const SA_NOCLDWAIT: ::c_int = 0x00000002;\npub const SA_NODEFER: ::c_int = 0x40000000;\npub const SA_ONSTACK: ::c_int = 0x08000000;\npub const SA_RESETHAND: ::c_int = 0x80000000;\npub const SA_RESTART: ::c_int = 0x10000000;\npub const SA_SIGINFO: ::c_int = 0x00000004;\n\npub const RTLD_GLOBAL: ::c_int = 2;\npub const RTLD_NOW: ::c_int = 0;\npub const RTLD_DEFAULT: *mut ::c_void = -1isize as *mut ::c_void;\n\npub const PTRACE_GETFPREGS: ::c_int = 14;\npub const PTRACE_SETFPREGS: ::c_int = 15;\npub const PTRACE_GETREGS: ::c_int = 12;\npub const PTRACE_SETREGS: ::c_int = 13;\n\npub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t { value: 0 };\npub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t { value: 0 };\npub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {\n    lock: PTHREAD_MUTEX_INITIALIZER,\n    cond: PTHREAD_COND_INITIALIZER,\n    numLocks: 0,\n    writerThreadId: 0,\n    pendingReaders: 0,\n    pendingWriters: 0,\n    attr: 0,\n    __reserved: [0; 12],\n};\npub const PTHREAD_STACK_MIN: ::size_t = 4096 * 2;\npub const CPU_SETSIZE: ::size_t = 32;\npub const __CPU_BITS: ::size_t = 32;\n\npub const UT_LINESIZE: usize = 8;\npub const UT_NAMESIZE: usize = 8;\npub const UT_HOSTSIZE: usize = 16;\n\npub const SIGSTKSZ: ::size_t = 8192;\npub const MINSIGSTKSZ: ::size_t = 2048;\n\nextern \"C\" {\n    pub fn timegm64(tm: *const ::tm) -> ::time64_t;\n}\n\ncfg_if! {\n    if #[cfg(target_arch = \"x86\")] {\n        mod x86;\n        pub use self::x86::*;\n    } else if #[cfg(target_arch = \"arm\")] {\n        mod arm;\n        pub use self::arm::*;\n    } else {\n        // Unknown target_arch\n    }\n}\n"],["1140","pub type c_char = i8;\npub type wchar_t = i32;\npub type greg_t = i32;\n\ns! {\n    pub struct _libc_fpreg {\n        pub significand: [u16; 4],\n        pub exponent: u16,\n    }\n\n    pub struct _libc_fpstate {\n        pub cw: ::c_ulong,\n        pub sw: ::c_ulong,\n        pub tag: ::c_ulong,\n        pub ipoff: ::c_ulong,\n        pub cssel: ::c_ulong,\n        pub dataoff: ::c_ulong,\n        pub datasel: ::c_ulong,\n        pub _st: [_libc_fpreg; 8],\n        pub status: ::c_ulong,\n    }\n\n    pub struct mcontext_t {\n        pub gregs: [greg_t; 19],\n        pub fpregs: *mut _libc_fpstate,\n        pub oldmask: ::c_ulong,\n        pub cr2: ::c_ulong,\n    }\n}\n\ncfg_if! {\n    if #[cfg(libc_union)] {\n        s_no_extra_traits! {\n            pub struct __c_anonymous_uc_sigmask_with_padding {\n                pub uc_sigmask: ::sigset_t,\n                /* Android has a wrong (smaller) sigset_t on x86. */\n                __padding_rt_sigset: u32,\n            }\n\n            pub union __c_anonymous_uc_sigmask {\n                uc_sigmask: __c_anonymous_uc_sigmask_with_padding,\n                uc_sigmask64: ::sigset64_t,\n            }\n\n            pub struct ucontext_t {\n                pub uc_flags: ::c_ulong,\n                pub uc_link: *mut ucontext_t,\n                pub uc_stack: ::stack_t,\n                pub uc_mcontext: mcontext_t,\n                pub uc_sigmask__c_anonymous_union: __c_anonymous_uc_sigmask,\n                __padding_rt_sigset: u32,\n                __fpregs_mem: _libc_fpstate,\n            }\n        }\n\n        cfg_if! {\n            if #[cfg(feature = \"extra_traits\")] {\n                impl PartialEq for __c_anonymous_uc_sigmask_with_padding {\n                    fn eq(\n                        &self, other: &__c_anonymous_uc_sigmask_with_padding\n                    ) -> bool {\n                        self.uc_sigmask == other.uc_sigmask\n                            // Ignore padding\n                    }\n                }\n                impl Eq for __c_anonymous_uc_sigmask_with_padding {}\n                impl ::fmt::Debug for __c_anonymous_uc_sigmask_with_padding {\n                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                        f.debug_struct(\"uc_sigmask_with_padding\")\n                            .field(\"uc_sigmask_with_padding\", &self.uc_sigmask)\n                            // Ignore padding\n                            .finish()\n                    }\n                }\n                impl ::hash::Hash for __c_anonymous_uc_sigmask_with_padding {\n                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                        self.uc_sigmask.hash(state)\n                            // Ignore padding\n                    }\n                }\n\n                impl PartialEq for __c_anonymous_uc_sigmask {\n                    fn eq(&self, other: &__c_anonymous_uc_sigmask) -> bool {\n                        unsafe { self.uc_sigmask == other.uc_sigmask }\n                    }\n                }\n                impl Eq for __c_anonymous_uc_sigmask {}\n                impl ::fmt::Debug for __c_anonymous_uc_sigmask {\n                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                        f.debug_struct(\"uc_sigmask\")\n                            .field(\"uc_sigmask\", unsafe { &self.uc_sigmask })\n                            .finish()\n                    }\n                }\n                impl ::hash::Hash for __c_anonymous_uc_sigmask {\n                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                        unsafe { self.uc_sigmask.hash(state) }\n                    }\n                }\n\n                impl PartialEq for ucontext_t {\n                    fn eq(&self, other: &Self) -> bool {\n                        self.uc_flags == other.uc_flags\n                            && self.uc_link == other.uc_link\n                            && self.uc_stack == other.uc_stack\n                            && self.uc_mcontext == other.uc_mcontext\n                            && self.uc_sigmask__c_anonymous_union\n                                == other.uc_sigmask__c_anonymous_union\n                            // Ignore padding field\n                    }\n                }\n                impl Eq for ucontext_t {}\n                impl ::fmt::Debug for ucontext_t {\n                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                        f.debug_struct(\"ucontext_t\")\n                            .field(\"uc_flags\", &self.uc_flags)\n                            .field(\"uc_link\", &self.uc_link)\n                            .field(\"uc_stack\", &self.uc_stack)\n                            .field(\"uc_mcontext\", &self.uc_mcontext)\n                            .field(\n                                \"uc_sigmask__c_anonymous_union\",\n                                &self.uc_sigmask__c_anonymous_union\n                            )\n                            // Ignore padding field\n                            .finish()\n                    }\n                }\n                impl ::hash::Hash for ucontext_t {\n                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                        self.uc_flags.hash(state);\n                        self.uc_link.hash(state);\n                        self.uc_stack.hash(state);\n                        self.uc_mcontext.hash(state);\n                        self.uc_sigmask__c_anonymous_union.hash(state);\n                        // Ignore padding field\n                    }\n                }\n            }\n        }\n    }\n}\n\npub const O_DIRECT: ::c_int = 0x4000;\npub const O_DIRECTORY: ::c_int = 0x10000;\npub const O_NOFOLLOW: ::c_int = 0x20000;\npub const O_LARGEFILE: ::c_int = 0o0100000;\n\npub const MAP_32BIT: ::c_int = 0x40;\n\n// Syscall table\npub const SYS_restart_syscall: ::c_long = 0;\npub const SYS_exit: ::c_long = 1;\npub const SYS_fork: ::c_long = 2;\npub const SYS_read: ::c_long = 3;\npub const SYS_write: ::c_long = 4;\npub const SYS_open: ::c_long = 5;\npub const SYS_close: ::c_long = 6;\npub const SYS_waitpid: ::c_long = 7;\npub const SYS_creat: ::c_long = 8;\npub const SYS_link: ::c_long = 9;\npub const SYS_unlink: ::c_long = 10;\npub const SYS_execve: ::c_long = 11;\npub const SYS_chdir: ::c_long = 12;\npub const SYS_time: ::c_long = 13;\npub const SYS_mknod: ::c_long = 14;\npub const SYS_chmod: ::c_long = 15;\npub const SYS_lchown: ::c_long = 16;\npub const SYS_break: ::c_long = 17;\npub const SYS_oldstat: ::c_long = 18;\npub const SYS_lseek: ::c_long = 19;\npub const SYS_getpid: ::c_long = 20;\npub const SYS_mount: ::c_long = 21;\npub const SYS_umount: ::c_long = 22;\npub const SYS_setuid: ::c_long = 23;\npub const SYS_getuid: ::c_long = 24;\npub const SYS_stime: ::c_long = 25;\npub const SYS_ptrace: ::c_long = 26;\npub const SYS_alarm: ::c_long = 27;\npub const SYS_oldfstat: ::c_long = 28;\npub const SYS_pause: ::c_long = 29;\npub const SYS_utime: ::c_long = 30;\npub const SYS_stty: ::c_long = 31;\npub const SYS_gtty: ::c_long = 32;\npub const SYS_access: ::c_long = 33;\npub const SYS_nice: ::c_long = 34;\npub const SYS_ftime: ::c_long = 35;\npub const SYS_sync: ::c_long = 36;\npub const SYS_kill: ::c_long = 37;\npub const SYS_rename: ::c_long = 38;\npub const SYS_mkdir: ::c_long = 39;\npub const SYS_rmdir: ::c_long = 40;\npub const SYS_dup: ::c_long = 41;\npub const SYS_pipe: ::c_long = 42;\npub const SYS_times: ::c_long = 43;\npub const SYS_prof: ::c_long = 44;\npub const SYS_brk: ::c_long = 45;\npub const SYS_setgid: ::c_long = 46;\npub const SYS_getgid: ::c_long = 47;\npub const SYS_signal: ::c_long = 48;\npub const SYS_geteuid: ::c_long = 49;\npub const SYS_getegid: ::c_long = 50;\npub const SYS_acct: ::c_long = 51;\npub const SYS_umount2: ::c_long = 52;\npub const SYS_lock: ::c_long = 53;\npub const SYS_ioctl: ::c_long = 54;\npub const SYS_fcntl: ::c_long = 55;\npub const SYS_mpx: ::c_long = 56;\npub const SYS_setpgid: ::c_long = 57;\npub const SYS_ulimit: ::c_long = 58;\npub const SYS_oldolduname: ::c_long = 59;\npub const SYS_umask: ::c_long = 60;\npub const SYS_chroot: ::c_long = 61;\npub const SYS_ustat: ::c_long = 62;\npub const SYS_dup2: ::c_long = 63;\npub const SYS_getppid: ::c_long = 64;\npub const SYS_getpgrp: ::c_long = 65;\npub const SYS_setsid: ::c_long = 66;\npub const SYS_sigaction: ::c_long = 67;\npub const SYS_sgetmask: ::c_long = 68;\npub const SYS_ssetmask: ::c_long = 69;\npub const SYS_setreuid: ::c_long = 70;\npub const SYS_setregid: ::c_long = 71;\npub const SYS_sigsuspend: ::c_long = 72;\npub const SYS_sigpending: ::c_long = 73;\npub const SYS_sethostname: ::c_long = 74;\npub const SYS_setrlimit: ::c_long = 75;\npub const SYS_getrlimit: ::c_long = 76;\npub const SYS_getrusage: ::c_long = 77;\npub const SYS_gettimeofday: ::c_long = 78;\npub const SYS_settimeofday: ::c_long = 79;\npub const SYS_getgroups: ::c_long = 80;\npub const SYS_setgroups: ::c_long = 81;\npub const SYS_select: ::c_long = 82;\npub const SYS_symlink: ::c_long = 83;\npub const SYS_oldlstat: ::c_long = 84;\npub const SYS_readlink: ::c_long = 85;\npub const SYS_uselib: ::c_long = 86;\npub const SYS_swapon: ::c_long = 87;\npub const SYS_reboot: ::c_long = 88;\npub const SYS_readdir: ::c_long = 89;\npub const SYS_mmap: ::c_long = 90;\npub const SYS_munmap: ::c_long = 91;\npub const SYS_truncate: ::c_long = 92;\npub const SYS_ftruncate: ::c_long = 93;\npub const SYS_fchmod: ::c_long = 94;\npub const SYS_fchown: ::c_long = 95;\npub const SYS_getpriority: ::c_long = 96;\npub const SYS_setpriority: ::c_long = 97;\npub const SYS_profil: ::c_long = 98;\npub const SYS_statfs: ::c_long = 99;\npub const SYS_fstatfs: ::c_long = 100;\npub const SYS_ioperm: ::c_long = 101;\npub const SYS_socketcall: ::c_long = 102;\npub const SYS_syslog: ::c_long = 103;\npub const SYS_setitimer: ::c_long = 104;\npub const SYS_getitimer: ::c_long = 105;\npub const SYS_stat: ::c_long = 106;\npub const SYS_lstat: ::c_long = 107;\npub const SYS_fstat: ::c_long = 108;\npub const SYS_olduname: ::c_long = 109;\npub const SYS_iopl: ::c_long = 110;\npub const SYS_vhangup: ::c_long = 111;\npub const SYS_idle: ::c_long = 112;\npub const SYS_vm86old: ::c_long = 113;\npub const SYS_wait4: ::c_long = 114;\npub const SYS_swapoff: ::c_long = 115;\npub const SYS_sysinfo: ::c_long = 116;\npub const SYS_ipc: ::c_long = 117;\npub const SYS_fsync: ::c_long = 118;\npub const SYS_sigreturn: ::c_long = 119;\npub const SYS_clone: ::c_long = 120;\npub const SYS_setdomainname: ::c_long = 121;\npub const SYS_uname: ::c_long = 122;\npub const SYS_modify_ldt: ::c_long = 123;\npub const SYS_adjtimex: ::c_long = 124;\npub const SYS_mprotect: ::c_long = 125;\npub const SYS_sigprocmask: ::c_long = 126;\npub const SYS_create_module: ::c_long = 127;\npub const SYS_init_module: ::c_long = 128;\npub const SYS_delete_module: ::c_long = 129;\npub const SYS_get_kernel_syms: ::c_long = 130;\npub const SYS_quotactl: ::c_long = 131;\npub const SYS_getpgid: ::c_long = 132;\npub const SYS_fchdir: ::c_long = 133;\npub const SYS_bdflush: ::c_long = 134;\npub const SYS_sysfs: ::c_long = 135;\npub const SYS_personality: ::c_long = 136;\npub const SYS_afs_syscall: ::c_long = 137;\npub const SYS_setfsuid: ::c_long = 138;\npub const SYS_setfsgid: ::c_long = 139;\n// FIXME: SYS__llseek is in the NDK sources but for some reason is\n//        not available in the tests\n// pub const SYS__llseek: ::c_long = 140;\npub const SYS_getdents: ::c_long = 141;\n// FIXME: SYS__newselect is in the NDK sources but for some reason is\n//        not available in the tests\n// pub const SYS__newselect: ::c_long = 142;\npub const SYS_flock: ::c_long = 143;\npub const SYS_msync: ::c_long = 144;\npub const SYS_readv: ::c_long = 145;\npub const SYS_writev: ::c_long = 146;\npub const SYS_getsid: ::c_long = 147;\npub const SYS_fdatasync: ::c_long = 148;\n// FIXME: SYS__llseek is in the NDK sources but for some reason is\n//        not available in the tests\n// pub const SYS__sysctl: ::c_long = 149;\npub const SYS_mlock: ::c_long = 150;\npub const SYS_munlock: ::c_long = 151;\npub const SYS_mlockall: ::c_long = 152;\npub const SYS_munlockall: ::c_long = 153;\npub const SYS_sched_setparam: ::c_long = 154;\npub const SYS_sched_getparam: ::c_long = 155;\npub const SYS_sched_setscheduler: ::c_long = 156;\npub const SYS_sched_getscheduler: ::c_long = 157;\npub const SYS_sched_yield: ::c_long = 158;\npub const SYS_sched_get_priority_max: ::c_long = 159;\npub const SYS_sched_get_priority_min: ::c_long = 160;\npub const SYS_sched_rr_get_interval: ::c_long = 161;\npub const SYS_nanosleep: ::c_long = 162;\npub const SYS_mremap: ::c_long = 163;\npub const SYS_setresuid: ::c_long = 164;\npub const SYS_getresuid: ::c_long = 165;\npub const SYS_vm86: ::c_long = 166;\npub const SYS_query_module: ::c_long = 167;\npub const SYS_poll: ::c_long = 168;\npub const SYS_nfsservctl: ::c_long = 169;\npub const SYS_setresgid: ::c_long = 170;\npub const SYS_getresgid: ::c_long = 171;\npub const SYS_prctl: ::c_long = 172;\npub const SYS_rt_sigreturn: ::c_long = 173;\npub const SYS_rt_sigaction: ::c_long = 174;\npub const SYS_rt_sigprocmask: ::c_long = 175;\npub const SYS_rt_sigpending: ::c_long = 176;\npub const SYS_rt_sigtimedwait: ::c_long = 177;\npub const SYS_rt_sigqueueinfo: ::c_long = 178;\npub const SYS_rt_sigsuspend: ::c_long = 179;\npub const SYS_pread64: ::c_long = 180;\npub const SYS_pwrite64: ::c_long = 181;\npub const SYS_chown: ::c_long = 182;\npub const SYS_getcwd: ::c_long = 183;\npub const SYS_capget: ::c_long = 184;\npub const SYS_capset: ::c_long = 185;\npub const SYS_sigaltstack: ::c_long = 186;\npub const SYS_sendfile: ::c_long = 187;\npub const SYS_getpmsg: ::c_long = 188;\npub const SYS_putpmsg: ::c_long = 189;\npub const SYS_vfork: ::c_long = 190;\npub const SYS_ugetrlimit: ::c_long = 191;\npub const SYS_mmap2: ::c_long = 192;\npub const SYS_truncate64: ::c_long = 193;\npub const SYS_ftruncate64: ::c_long = 194;\npub const SYS_stat64: ::c_long = 195;\npub const SYS_lstat64: ::c_long = 196;\npub const SYS_fstat64: ::c_long = 197;\npub const SYS_lchown32: ::c_long = 198;\npub const SYS_getuid32: ::c_long = 199;\npub const SYS_getgid32: ::c_long = 200;\npub const SYS_geteuid32: ::c_long = 201;\npub const SYS_getegid32: ::c_long = 202;\npub const SYS_setreuid32: ::c_long = 203;\npub const SYS_setregid32: ::c_long = 204;\npub const SYS_getgroups32: ::c_long = 205;\npub const SYS_setgroups32: ::c_long = 206;\npub const SYS_fchown32: ::c_long = 207;\npub const SYS_setresuid32: ::c_long = 208;\npub const SYS_getresuid32: ::c_long = 209;\npub const SYS_setresgid32: ::c_long = 210;\npub const SYS_getresgid32: ::c_long = 211;\npub const SYS_chown32: ::c_long = 212;\npub const SYS_setuid32: ::c_long = 213;\npub const SYS_setgid32: ::c_long = 214;\npub const SYS_setfsuid32: ::c_long = 215;\npub const SYS_setfsgid32: ::c_long = 216;\npub const SYS_pivot_root: ::c_long = 217;\npub const SYS_mincore: ::c_long = 218;\npub const SYS_madvise: ::c_long = 219;\npub const SYS_getdents64: ::c_long = 220;\npub const SYS_fcntl64: ::c_long = 221;\npub const SYS_gettid: ::c_long = 224;\npub const SYS_readahead: ::c_long = 225;\npub const SYS_setxattr: ::c_long = 226;\npub const SYS_lsetxattr: ::c_long = 227;\npub const SYS_fsetxattr: ::c_long = 228;\npub const SYS_getxattr: ::c_long = 229;\npub const SYS_lgetxattr: ::c_long = 230;\npub const SYS_fgetxattr: ::c_long = 231;\npub const SYS_listxattr: ::c_long = 232;\npub const SYS_llistxattr: ::c_long = 233;\npub const SYS_flistxattr: ::c_long = 234;\npub const SYS_removexattr: ::c_long = 235;\npub const SYS_lremovexattr: ::c_long = 236;\npub const SYS_fremovexattr: ::c_long = 237;\npub const SYS_tkill: ::c_long = 238;\npub const SYS_sendfile64: ::c_long = 239;\npub const SYS_futex: ::c_long = 240;\npub const SYS_sched_setaffinity: ::c_long = 241;\npub const SYS_sched_getaffinity: ::c_long = 242;\npub const SYS_set_thread_area: ::c_long = 243;\npub const SYS_get_thread_area: ::c_long = 244;\npub const SYS_io_setup: ::c_long = 245;\npub const SYS_io_destroy: ::c_long = 246;\npub const SYS_io_getevents: ::c_long = 247;\npub const SYS_io_submit: ::c_long = 248;\npub const SYS_io_cancel: ::c_long = 249;\npub const SYS_fadvise64: ::c_long = 250;\npub const SYS_exit_group: ::c_long = 252;\npub const SYS_lookup_dcookie: ::c_long = 253;\npub const SYS_epoll_create: ::c_long = 254;\npub const SYS_epoll_ctl: ::c_long = 255;\npub const SYS_epoll_wait: ::c_long = 256;\npub const SYS_remap_file_pages: ::c_long = 257;\npub const SYS_set_tid_address: ::c_long = 258;\npub const SYS_timer_create: ::c_long = 259;\npub const SYS_timer_settime: ::c_long = 260;\npub const SYS_timer_gettime: ::c_long = 261;\npub const SYS_timer_getoverrun: ::c_long = 262;\npub const SYS_timer_delete: ::c_long = 263;\npub const SYS_clock_settime: ::c_long = 264;\npub const SYS_clock_gettime: ::c_long = 265;\npub const SYS_clock_getres: ::c_long = 266;\npub const SYS_clock_nanosleep: ::c_long = 267;\npub const SYS_statfs64: ::c_long = 268;\npub const SYS_fstatfs64: ::c_long = 269;\npub const SYS_tgkill: ::c_long = 270;\npub const SYS_utimes: ::c_long = 271;\npub const SYS_fadvise64_64: ::c_long = 272;\npub const SYS_vserver: ::c_long = 273;\npub const SYS_mbind: ::c_long = 274;\npub const SYS_get_mempolicy: ::c_long = 275;\npub const SYS_set_mempolicy: ::c_long = 276;\npub const SYS_mq_open: ::c_long = 277;\npub const SYS_mq_unlink: ::c_long = 278;\npub const SYS_mq_timedsend: ::c_long = 279;\npub const SYS_mq_timedreceive: ::c_long = 280;\npub const SYS_mq_notify: ::c_long = 281;\npub const SYS_mq_getsetattr: ::c_long = 282;\npub const SYS_kexec_load: ::c_long = 283;\npub const SYS_waitid: ::c_long = 284;\npub const SYS_add_key: ::c_long = 286;\npub const SYS_request_key: ::c_long = 287;\npub const SYS_keyctl: ::c_long = 288;\npub const SYS_ioprio_set: ::c_long = 289;\npub const SYS_ioprio_get: ::c_long = 290;\npub const SYS_inotify_init: ::c_long = 291;\npub const SYS_inotify_add_watch: ::c_long = 292;\npub const SYS_inotify_rm_watch: ::c_long = 293;\npub const SYS_migrate_pages: ::c_long = 294;\npub const SYS_openat: ::c_long = 295;\npub const SYS_mkdirat: ::c_long = 296;\npub const SYS_mknodat: ::c_long = 297;\npub const SYS_fchownat: ::c_long = 298;\npub const SYS_futimesat: ::c_long = 299;\npub const SYS_fstatat64: ::c_long = 300;\npub const SYS_unlinkat: ::c_long = 301;\npub const SYS_renameat: ::c_long = 302;\npub const SYS_linkat: ::c_long = 303;\npub const SYS_symlinkat: ::c_long = 304;\npub const SYS_readlinkat: ::c_long = 305;\npub const SYS_fchmodat: ::c_long = 306;\npub const SYS_faccessat: ::c_long = 307;\npub const SYS_pselect6: ::c_long = 308;\npub const SYS_ppoll: ::c_long = 309;\npub const SYS_unshare: ::c_long = 310;\npub const SYS_set_robust_list: ::c_long = 311;\npub const SYS_get_robust_list: ::c_long = 312;\npub const SYS_splice: ::c_long = 313;\npub const SYS_sync_file_range: ::c_long = 314;\npub const SYS_tee: ::c_long = 315;\npub const SYS_vmsplice: ::c_long = 316;\npub const SYS_move_pages: ::c_long = 317;\npub const SYS_getcpu: ::c_long = 318;\npub const SYS_epoll_pwait: ::c_long = 319;\npub const SYS_utimensat: ::c_long = 320;\npub const SYS_signalfd: ::c_long = 321;\npub const SYS_timerfd_create: ::c_long = 322;\npub const SYS_eventfd: ::c_long = 323;\npub const SYS_fallocate: ::c_long = 324;\npub const SYS_timerfd_settime: ::c_long = 325;\npub const SYS_timerfd_gettime: ::c_long = 326;\npub const SYS_signalfd4: ::c_long = 327;\npub const SYS_eventfd2: ::c_long = 328;\npub const SYS_epoll_create1: ::c_long = 329;\npub const SYS_dup3: ::c_long = 330;\npub const SYS_pipe2: ::c_long = 331;\npub const SYS_inotify_init1: ::c_long = 332;\npub const SYS_preadv: ::c_long = 333;\npub const SYS_pwritev: ::c_long = 334;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 335;\npub const SYS_perf_event_open: ::c_long = 336;\npub const SYS_recvmmsg: ::c_long = 337;\npub const SYS_fanotify_init: ::c_long = 338;\npub const SYS_fanotify_mark: ::c_long = 339;\npub const SYS_prlimit64: ::c_long = 340;\npub const SYS_name_to_handle_at: ::c_long = 341;\npub const SYS_open_by_handle_at: ::c_long = 342;\npub const SYS_clock_adjtime: ::c_long = 343;\npub const SYS_syncfs: ::c_long = 344;\npub const SYS_sendmmsg: ::c_long = 345;\npub const SYS_setns: ::c_long = 346;\npub const SYS_process_vm_readv: ::c_long = 347;\npub const SYS_process_vm_writev: ::c_long = 348;\npub const SYS_kcmp: ::c_long = 349;\npub const SYS_finit_module: ::c_long = 350;\npub const SYS_sched_setattr: ::c_long = 351;\npub const SYS_sched_getattr: ::c_long = 352;\npub const SYS_renameat2: ::c_long = 353;\npub const SYS_seccomp: ::c_long = 354;\npub const SYS_getrandom: ::c_long = 355;\npub const SYS_memfd_create: ::c_long = 356;\npub const SYS_bpf: ::c_long = 357;\npub const SYS_execveat: ::c_long = 358;\npub const SYS_socket: ::c_long = 359;\npub const SYS_socketpair: ::c_long = 360;\npub const SYS_bind: ::c_long = 361;\npub const SYS_connect: ::c_long = 362;\npub const SYS_listen: ::c_long = 363;\npub const SYS_accept4: ::c_long = 364;\npub const SYS_getsockopt: ::c_long = 365;\npub const SYS_setsockopt: ::c_long = 366;\npub const SYS_getsockname: ::c_long = 367;\npub const SYS_getpeername: ::c_long = 368;\npub const SYS_sendto: ::c_long = 369;\npub const SYS_sendmsg: ::c_long = 370;\npub const SYS_recvfrom: ::c_long = 371;\npub const SYS_recvmsg: ::c_long = 372;\npub const SYS_shutdown: ::c_long = 373;\npub const SYS_userfaultfd: ::c_long = 374;\npub const SYS_membarrier: ::c_long = 375;\npub const SYS_mlock2: ::c_long = 376;\npub const SYS_copy_file_range: ::c_long = 377;\npub const SYS_preadv2: ::c_long = 378;\npub const SYS_pwritev2: ::c_long = 379;\npub const SYS_pkey_mprotect: ::c_long = 380;\npub const SYS_pkey_alloc: ::c_long = 381;\npub const SYS_pkey_free: ::c_long = 382;\n\n// offsets in user_regs_structs, from sys/reg.h\npub const EBX: ::c_int = 0;\npub const ECX: ::c_int = 1;\npub const EDX: ::c_int = 2;\npub const ESI: ::c_int = 3;\npub const EDI: ::c_int = 4;\npub const EBP: ::c_int = 5;\npub const EAX: ::c_int = 6;\npub const DS: ::c_int = 7;\npub const ES: ::c_int = 8;\npub const FS: ::c_int = 9;\npub const GS: ::c_int = 10;\npub const ORIG_EAX: ::c_int = 11;\npub const EIP: ::c_int = 12;\npub const CS: ::c_int = 13;\npub const EFL: ::c_int = 14;\npub const UESP: ::c_int = 15;\npub const SS: ::c_int = 16;\n\n// offsets in mcontext_t.gregs from sys/ucontext.h\npub const REG_GS: ::c_int = 0;\npub const REG_FS: ::c_int = 1;\npub const REG_ES: ::c_int = 2;\npub const REG_DS: ::c_int = 3;\npub const REG_EDI: ::c_int = 4;\npub const REG_ESI: ::c_int = 5;\npub const REG_EBP: ::c_int = 6;\npub const REG_ESP: ::c_int = 7;\npub const REG_EBX: ::c_int = 8;\npub const REG_EDX: ::c_int = 9;\npub const REG_ECX: ::c_int = 10;\npub const REG_EAX: ::c_int = 11;\npub const REG_TRAPNO: ::c_int = 12;\npub const REG_ERR: ::c_int = 13;\npub const REG_EIP: ::c_int = 14;\npub const REG_CS: ::c_int = 15;\npub const REG_EFL: ::c_int = 16;\npub const REG_UESP: ::c_int = 17;\npub const REG_SS: ::c_int = 18;\n\n// socketcall values from linux/net.h (only the needed ones, and not public)\nconst SYS_ACCEPT4: ::c_int = 18;\n\nf! {\n    // Sadly, Android before 5.0 (API level 21), the accept4 syscall is not\n    // exposed by the libc. As work-around, we implement it as raw syscall.\n    // Note that for x86, the `accept4` syscall is not available either,\n    // and we must use the `socketcall` syscall instead.\n    // This workaround can be removed if the minimum Android version is bumped.\n    // When the workaround is removed, `accept4` can be moved back\n    // to `linux_like/mod.rs`\n    pub fn accept4(\n        fd: ::c_int,\n        addr: *mut ::sockaddr,\n        len: *mut ::socklen_t,\n        flg: ::c_int\n    ) -> ::c_int {\n        // Arguments are passed as array of `long int`\n        // (which is big enough on x86 for a pointer).\n        let mut args = [\n            fd as ::c_long,\n            addr as ::c_long,\n            len as ::c_long,\n            flg as ::c_long,\n        ];\n        ::syscall(SYS_socketcall, SYS_ACCEPT4, args[..].as_mut_ptr())\n    }\n}\n\ncfg_if! {\n    if #[cfg(libc_align)] {\n        mod align;\n        pub use self::align::*;\n    }\n}\n"],["1141","s_no_extra_traits! {\n    #[allow(missing_debug_implementations)]\n    #[repr(align(8))]\n    pub struct max_align_t {\n        priv_: [f64; 2]\n    }\n}\n"],["1142","pub type c_char = u8;\npub type wchar_t = u32;\npub type greg_t = i32;\npub type mcontext_t = sigcontext;\n\ns! {\n    pub struct sigcontext {\n        pub trap_no: ::c_ulong,\n        pub error_code: ::c_ulong,\n        pub oldmask: ::c_ulong,\n        pub arm_r0: ::c_ulong,\n        pub arm_r1: ::c_ulong,\n        pub arm_r2: ::c_ulong,\n        pub arm_r3: ::c_ulong,\n        pub arm_r4: ::c_ulong,\n        pub arm_r5: ::c_ulong,\n        pub arm_r6: ::c_ulong,\n        pub arm_r7: ::c_ulong,\n        pub arm_r8: ::c_ulong,\n        pub arm_r9: ::c_ulong,\n        pub arm_r10: ::c_ulong,\n        pub arm_fp: ::c_ulong,\n        pub arm_ip: ::c_ulong,\n        pub arm_sp: ::c_ulong,\n        pub arm_lr: ::c_ulong,\n        pub arm_pc: ::c_ulong,\n        pub arm_cpsr: ::c_ulong,\n        pub fault_address: ::c_ulong,\n    }\n}\n\ncfg_if! {\n    if #[cfg(libc_union)] {\n        s_no_extra_traits! {\n            pub struct __c_anonymous_uc_sigmask_with_padding {\n                pub uc_sigmask: ::sigset_t,\n                /* Android has a wrong (smaller) sigset_t on x86. */\n                __padding_rt_sigset: u32,\n            }\n\n            pub union __c_anonymous_uc_sigmask {\n                uc_sigmask: __c_anonymous_uc_sigmask_with_padding,\n                uc_sigmask64: ::sigset64_t,\n            }\n\n            pub struct ucontext_t {\n                pub uc_flags: ::c_ulong,\n                pub uc_link: *mut ucontext_t,\n                pub uc_stack: ::stack_t,\n                pub uc_mcontext: mcontext_t,\n                pub uc_sigmask__c_anonymous_union: __c_anonymous_uc_sigmask,\n                /* The kernel adds extra padding after uc_sigmask to match\n                 * glibc sigset_t on ARM. */\n                __padding: [c_char; 120],\n                __align: [::c_longlong; 0],\n                uc_regspace: [::c_ulong; 128],\n            }\n        }\n\n        cfg_if! {\n            if #[cfg(feature = \"extra_traits\")] {\n                impl PartialEq for __c_anonymous_uc_sigmask_with_padding {\n                    fn eq(\n                        &self, other: &__c_anonymous_uc_sigmask_with_padding\n                    ) -> bool {\n                        self.uc_sigmask == other.uc_sigmask\n                            // Ignore padding\n                    }\n                }\n                impl Eq for __c_anonymous_uc_sigmask_with_padding {}\n                impl ::fmt::Debug for __c_anonymous_uc_sigmask_with_padding {\n                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                        f.debug_struct(\"uc_sigmask_with_padding\")\n                            .field(\"uc_sigmask_with_padding\", &self.uc_sigmask)\n                            // Ignore padding\n                            .finish()\n                    }\n                }\n                impl ::hash::Hash for __c_anonymous_uc_sigmask_with_padding {\n                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                        self.uc_sigmask.hash(state)\n                            // Ignore padding\n                    }\n                }\n\n                impl PartialEq for __c_anonymous_uc_sigmask {\n                    fn eq(&self, other: &__c_anonymous_uc_sigmask) -> bool {\n                        unsafe { self.uc_sigmask == other.uc_sigmask }\n                    }\n                }\n                impl Eq for __c_anonymous_uc_sigmask {}\n                impl ::fmt::Debug for __c_anonymous_uc_sigmask {\n                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                        f.debug_struct(\"uc_sigmask\")\n                            .field(\"uc_sigmask\", unsafe { &self.uc_sigmask })\n                            .finish()\n                    }\n                }\n                impl ::hash::Hash for __c_anonymous_uc_sigmask {\n                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                        unsafe { self.uc_sigmask.hash(state) }\n                    }\n                }\n\n                impl PartialEq for ucontext_t {\n                    fn eq(&self, other: &Self) -> bool {\n                        self.uc_flags == other.uc_flags\n                            && self.uc_link == other.uc_link\n                            && self.uc_stack == other.uc_stack\n                            && self.uc_mcontext == other.uc_mcontext\n                            && self.uc_sigmask__c_anonymous_union\n                                == other.uc_sigmask__c_anonymous_union\n                            && &self.uc_regspace[..] == &other.uc_regspace[..]\n                            // Ignore padding field\n                    }\n                }\n                impl Eq for ucontext_t {}\n                impl ::fmt::Debug for ucontext_t {\n                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                        f.debug_struct(\"ucontext_t\")\n                            .field(\"uc_flags\", &self.uc_flags)\n                            .field(\"uc_link\", &self.uc_link)\n                            .field(\"uc_stack\", &self.uc_stack)\n                            .field(\"uc_mcontext\", &self.uc_mcontext)\n                            .field(\n                                \"uc_sigmask__c_anonymous_union\",\n                                &self.uc_sigmask__c_anonymous_union\n                            )\n                            .field(\"uc_regspace\", &&self.uc_regspace[..])\n                            // Ignore padding field\n                            .finish()\n                    }\n                }\n                impl ::hash::Hash for ucontext_t {\n                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                        self.uc_flags.hash(state);\n                        self.uc_link.hash(state);\n                        self.uc_stack.hash(state);\n                        self.uc_mcontext.hash(state);\n                        self.uc_sigmask__c_anonymous_union.hash(state);\n                        &self.uc_regspace[..].hash(state);\n                        // Ignore padding field\n                    }\n                }\n            }\n        }\n    }\n}\n\npub const O_DIRECT: ::c_int = 0x10000;\npub const O_DIRECTORY: ::c_int = 0x4000;\npub const O_NOFOLLOW: ::c_int = 0x8000;\npub const O_LARGEFILE: ::c_int = 0o400000;\n\npub const SYS_restart_syscall: ::c_long = 0;\npub const SYS_exit: ::c_long = 1;\npub const SYS_fork: ::c_long = 2;\npub const SYS_read: ::c_long = 3;\npub const SYS_write: ::c_long = 4;\npub const SYS_open: ::c_long = 5;\npub const SYS_close: ::c_long = 6;\npub const SYS_creat: ::c_long = 8;\npub const SYS_link: ::c_long = 9;\npub const SYS_unlink: ::c_long = 10;\npub const SYS_execve: ::c_long = 11;\npub const SYS_chdir: ::c_long = 12;\npub const SYS_mknod: ::c_long = 14;\npub const SYS_chmod: ::c_long = 15;\npub const SYS_lchown: ::c_long = 16;\npub const SYS_lseek: ::c_long = 19;\npub const SYS_getpid: ::c_long = 20;\npub const SYS_mount: ::c_long = 21;\npub const SYS_setuid: ::c_long = 23;\npub const SYS_getuid: ::c_long = 24;\npub const SYS_ptrace: ::c_long = 26;\npub const SYS_pause: ::c_long = 29;\npub const SYS_access: ::c_long = 33;\npub const SYS_nice: ::c_long = 34;\npub const SYS_sync: ::c_long = 36;\npub const SYS_kill: ::c_long = 37;\npub const SYS_rename: ::c_long = 38;\npub const SYS_mkdir: ::c_long = 39;\npub const SYS_rmdir: ::c_long = 40;\npub const SYS_dup: ::c_long = 41;\npub const SYS_pipe: ::c_long = 42;\npub const SYS_times: ::c_long = 43;\npub const SYS_brk: ::c_long = 45;\npub const SYS_setgid: ::c_long = 46;\npub const SYS_getgid: ::c_long = 47;\npub const SYS_geteuid: ::c_long = 49;\npub const SYS_getegid: ::c_long = 50;\npub const SYS_acct: ::c_long = 51;\npub const SYS_umount2: ::c_long = 52;\npub const SYS_ioctl: ::c_long = 54;\npub const SYS_fcntl: ::c_long = 55;\npub const SYS_setpgid: ::c_long = 57;\npub const SYS_umask: ::c_long = 60;\npub const SYS_chroot: ::c_long = 61;\npub const SYS_ustat: ::c_long = 62;\npub const SYS_dup2: ::c_long = 63;\npub const SYS_getppid: ::c_long = 64;\npub const SYS_getpgrp: ::c_long = 65;\npub const SYS_setsid: ::c_long = 66;\npub const SYS_sigaction: ::c_long = 67;\npub const SYS_setreuid: ::c_long = 70;\npub const SYS_setregid: ::c_long = 71;\npub const SYS_sigsuspend: ::c_long = 72;\npub const SYS_sigpending: ::c_long = 73;\npub const SYS_sethostname: ::c_long = 74;\npub const SYS_setrlimit: ::c_long = 75;\npub const SYS_getrusage: ::c_long = 77;\npub const SYS_gettimeofday: ::c_long = 78;\npub const SYS_settimeofday: ::c_long = 79;\npub const SYS_getgroups: ::c_long = 80;\npub const SYS_setgroups: ::c_long = 81;\npub const SYS_symlink: ::c_long = 83;\npub const SYS_readlink: ::c_long = 85;\npub const SYS_uselib: ::c_long = 86;\npub const SYS_swapon: ::c_long = 87;\npub const SYS_reboot: ::c_long = 88;\npub const SYS_munmap: ::c_long = 91;\npub const SYS_truncate: ::c_long = 92;\npub const SYS_ftruncate: ::c_long = 93;\npub const SYS_fchmod: ::c_long = 94;\npub const SYS_fchown: ::c_long = 95;\npub const SYS_getpriority: ::c_long = 96;\npub const SYS_setpriority: ::c_long = 97;\npub const SYS_statfs: ::c_long = 99;\npub const SYS_fstatfs: ::c_long = 100;\npub const SYS_syslog: ::c_long = 103;\npub const SYS_setitimer: ::c_long = 104;\npub const SYS_getitimer: ::c_long = 105;\npub const SYS_stat: ::c_long = 106;\npub const SYS_lstat: ::c_long = 107;\npub const SYS_fstat: ::c_long = 108;\npub const SYS_vhangup: ::c_long = 111;\npub const SYS_wait4: ::c_long = 114;\npub const SYS_swapoff: ::c_long = 115;\npub const SYS_sysinfo: ::c_long = 116;\npub const SYS_fsync: ::c_long = 118;\npub const SYS_sigreturn: ::c_long = 119;\npub const SYS_clone: ::c_long = 120;\npub const SYS_setdomainname: ::c_long = 121;\npub const SYS_uname: ::c_long = 122;\npub const SYS_adjtimex: ::c_long = 124;\npub const SYS_mprotect: ::c_long = 125;\npub const SYS_sigprocmask: ::c_long = 126;\npub const SYS_init_module: ::c_long = 128;\npub const SYS_delete_module: ::c_long = 129;\npub const SYS_quotactl: ::c_long = 131;\npub const SYS_getpgid: ::c_long = 132;\npub const SYS_fchdir: ::c_long = 133;\npub const SYS_bdflush: ::c_long = 134;\npub const SYS_sysfs: ::c_long = 135;\npub const SYS_personality: ::c_long = 136;\npub const SYS_setfsuid: ::c_long = 138;\npub const SYS_setfsgid: ::c_long = 139;\npub const SYS_getdents: ::c_long = 141;\npub const SYS_flock: ::c_long = 143;\npub const SYS_msync: ::c_long = 144;\npub const SYS_readv: ::c_long = 145;\npub const SYS_writev: ::c_long = 146;\npub const SYS_getsid: ::c_long = 147;\npub const SYS_fdatasync: ::c_long = 148;\npub const SYS_mlock: ::c_long = 150;\npub const SYS_munlock: ::c_long = 151;\npub const SYS_mlockall: ::c_long = 152;\npub const SYS_munlockall: ::c_long = 153;\npub const SYS_sched_setparam: ::c_long = 154;\npub const SYS_sched_getparam: ::c_long = 155;\npub const SYS_sched_setscheduler: ::c_long = 156;\npub const SYS_sched_getscheduler: ::c_long = 157;\npub const SYS_sched_yield: ::c_long = 158;\npub const SYS_sched_get_priority_max: ::c_long = 159;\npub const SYS_sched_get_priority_min: ::c_long = 160;\npub const SYS_sched_rr_get_interval: ::c_long = 161;\npub const SYS_nanosleep: ::c_long = 162;\npub const SYS_mremap: ::c_long = 163;\npub const SYS_setresuid: ::c_long = 164;\npub const SYS_getresuid: ::c_long = 165;\npub const SYS_poll: ::c_long = 168;\npub const SYS_nfsservctl: ::c_long = 169;\npub const SYS_setresgid: ::c_long = 170;\npub const SYS_getresgid: ::c_long = 171;\npub const SYS_prctl: ::c_long = 172;\npub const SYS_rt_sigreturn: ::c_long = 173;\npub const SYS_rt_sigaction: ::c_long = 174;\npub const SYS_rt_sigprocmask: ::c_long = 175;\npub const SYS_rt_sigpending: ::c_long = 176;\npub const SYS_rt_sigtimedwait: ::c_long = 177;\npub const SYS_rt_sigqueueinfo: ::c_long = 178;\npub const SYS_rt_sigsuspend: ::c_long = 179;\npub const SYS_pread64: ::c_long = 180;\npub const SYS_pwrite64: ::c_long = 181;\npub const SYS_chown: ::c_long = 182;\npub const SYS_getcwd: ::c_long = 183;\npub const SYS_capget: ::c_long = 184;\npub const SYS_capset: ::c_long = 185;\npub const SYS_sigaltstack: ::c_long = 186;\npub const SYS_sendfile: ::c_long = 187;\npub const SYS_vfork: ::c_long = 190;\npub const SYS_ugetrlimit: ::c_long = 191;\npub const SYS_mmap2: ::c_long = 192;\npub const SYS_truncate64: ::c_long = 193;\npub const SYS_ftruncate64: ::c_long = 194;\npub const SYS_stat64: ::c_long = 195;\npub const SYS_lstat64: ::c_long = 196;\npub const SYS_fstat64: ::c_long = 197;\npub const SYS_lchown32: ::c_long = 198;\npub const SYS_getuid32: ::c_long = 199;\npub const SYS_getgid32: ::c_long = 200;\npub const SYS_geteuid32: ::c_long = 201;\npub const SYS_getegid32: ::c_long = 202;\npub const SYS_setreuid32: ::c_long = 203;\npub const SYS_setregid32: ::c_long = 204;\npub const SYS_getgroups32: ::c_long = 205;\npub const SYS_setgroups32: ::c_long = 206;\npub const SYS_fchown32: ::c_long = 207;\npub const SYS_setresuid32: ::c_long = 208;\npub const SYS_getresuid32: ::c_long = 209;\npub const SYS_setresgid32: ::c_long = 210;\npub const SYS_getresgid32: ::c_long = 211;\npub const SYS_chown32: ::c_long = 212;\npub const SYS_setuid32: ::c_long = 213;\npub const SYS_setgid32: ::c_long = 214;\npub const SYS_setfsuid32: ::c_long = 215;\npub const SYS_setfsgid32: ::c_long = 216;\npub const SYS_getdents64: ::c_long = 217;\npub const SYS_pivot_root: ::c_long = 218;\npub const SYS_mincore: ::c_long = 219;\npub const SYS_madvise: ::c_long = 220;\npub const SYS_fcntl64: ::c_long = 221;\npub const SYS_gettid: ::c_long = 224;\npub const SYS_readahead: ::c_long = 225;\npub const SYS_setxattr: ::c_long = 226;\npub const SYS_lsetxattr: ::c_long = 227;\npub const SYS_fsetxattr: ::c_long = 228;\npub const SYS_getxattr: ::c_long = 229;\npub const SYS_lgetxattr: ::c_long = 230;\npub const SYS_fgetxattr: ::c_long = 231;\npub const SYS_listxattr: ::c_long = 232;\npub const SYS_llistxattr: ::c_long = 233;\npub const SYS_flistxattr: ::c_long = 234;\npub const SYS_removexattr: ::c_long = 235;\npub const SYS_lremovexattr: ::c_long = 236;\npub const SYS_fremovexattr: ::c_long = 237;\npub const SYS_tkill: ::c_long = 238;\npub const SYS_sendfile64: ::c_long = 239;\npub const SYS_futex: ::c_long = 240;\npub const SYS_sched_setaffinity: ::c_long = 241;\npub const SYS_sched_getaffinity: ::c_long = 242;\npub const SYS_io_setup: ::c_long = 243;\npub const SYS_io_destroy: ::c_long = 244;\npub const SYS_io_getevents: ::c_long = 245;\npub const SYS_io_submit: ::c_long = 246;\npub const SYS_io_cancel: ::c_long = 247;\npub const SYS_exit_group: ::c_long = 248;\npub const SYS_lookup_dcookie: ::c_long = 249;\npub const SYS_epoll_create: ::c_long = 250;\npub const SYS_epoll_ctl: ::c_long = 251;\npub const SYS_epoll_wait: ::c_long = 252;\npub const SYS_remap_file_pages: ::c_long = 253;\npub const SYS_set_tid_address: ::c_long = 256;\npub const SYS_timer_create: ::c_long = 257;\npub const SYS_timer_settime: ::c_long = 258;\npub const SYS_timer_gettime: ::c_long = 259;\npub const SYS_timer_getoverrun: ::c_long = 260;\npub const SYS_timer_delete: ::c_long = 261;\npub const SYS_clock_settime: ::c_long = 262;\npub const SYS_clock_gettime: ::c_long = 263;\npub const SYS_clock_getres: ::c_long = 264;\npub const SYS_clock_nanosleep: ::c_long = 265;\npub const SYS_statfs64: ::c_long = 266;\npub const SYS_fstatfs64: ::c_long = 267;\npub const SYS_tgkill: ::c_long = 268;\npub const SYS_utimes: ::c_long = 269;\npub const SYS_arm_fadvise64_64: ::c_long = 270;\npub const SYS_pciconfig_iobase: ::c_long = 271;\npub const SYS_pciconfig_read: ::c_long = 272;\npub const SYS_pciconfig_write: ::c_long = 273;\npub const SYS_mq_open: ::c_long = 274;\npub const SYS_mq_unlink: ::c_long = 275;\npub const SYS_mq_timedsend: ::c_long = 276;\npub const SYS_mq_timedreceive: ::c_long = 277;\npub const SYS_mq_notify: ::c_long = 278;\npub const SYS_mq_getsetattr: ::c_long = 279;\npub const SYS_waitid: ::c_long = 280;\npub const SYS_socket: ::c_long = 281;\npub const SYS_bind: ::c_long = 282;\npub const SYS_connect: ::c_long = 283;\npub const SYS_listen: ::c_long = 284;\npub const SYS_accept: ::c_long = 285;\npub const SYS_getsockname: ::c_long = 286;\npub const SYS_getpeername: ::c_long = 287;\npub const SYS_socketpair: ::c_long = 288;\npub const SYS_send: ::c_long = 289;\npub const SYS_sendto: ::c_long = 290;\npub const SYS_recv: ::c_long = 291;\npub const SYS_recvfrom: ::c_long = 292;\npub const SYS_shutdown: ::c_long = 293;\npub const SYS_setsockopt: ::c_long = 294;\npub const SYS_getsockopt: ::c_long = 295;\npub const SYS_sendmsg: ::c_long = 296;\npub const SYS_recvmsg: ::c_long = 297;\npub const SYS_semop: ::c_long = 298;\npub const SYS_semget: ::c_long = 299;\npub const SYS_semctl: ::c_long = 300;\npub const SYS_msgsnd: ::c_long = 301;\npub const SYS_msgrcv: ::c_long = 302;\npub const SYS_msgget: ::c_long = 303;\npub const SYS_msgctl: ::c_long = 304;\npub const SYS_shmat: ::c_long = 305;\npub const SYS_shmdt: ::c_long = 306;\npub const SYS_shmget: ::c_long = 307;\npub const SYS_shmctl: ::c_long = 308;\npub const SYS_add_key: ::c_long = 309;\npub const SYS_request_key: ::c_long = 310;\npub const SYS_keyctl: ::c_long = 311;\npub const SYS_semtimedop: ::c_long = 312;\npub const SYS_vserver: ::c_long = 313;\npub const SYS_ioprio_set: ::c_long = 314;\npub const SYS_ioprio_get: ::c_long = 315;\npub const SYS_inotify_init: ::c_long = 316;\npub const SYS_inotify_add_watch: ::c_long = 317;\npub const SYS_inotify_rm_watch: ::c_long = 318;\npub const SYS_mbind: ::c_long = 319;\npub const SYS_get_mempolicy: ::c_long = 320;\npub const SYS_set_mempolicy: ::c_long = 321;\npub const SYS_openat: ::c_long = 322;\npub const SYS_mkdirat: ::c_long = 323;\npub const SYS_mknodat: ::c_long = 324;\npub const SYS_fchownat: ::c_long = 325;\npub const SYS_futimesat: ::c_long = 326;\npub const SYS_fstatat64: ::c_long = 327;\npub const SYS_unlinkat: ::c_long = 328;\npub const SYS_renameat: ::c_long = 329;\npub const SYS_linkat: ::c_long = 330;\npub const SYS_symlinkat: ::c_long = 331;\npub const SYS_readlinkat: ::c_long = 332;\npub const SYS_fchmodat: ::c_long = 333;\npub const SYS_faccessat: ::c_long = 334;\npub const SYS_pselect6: ::c_long = 335;\npub const SYS_ppoll: ::c_long = 336;\npub const SYS_unshare: ::c_long = 337;\npub const SYS_set_robust_list: ::c_long = 338;\npub const SYS_get_robust_list: ::c_long = 339;\npub const SYS_splice: ::c_long = 340;\npub const SYS_arm_sync_file_range: ::c_long = 341;\npub const SYS_tee: ::c_long = 342;\npub const SYS_vmsplice: ::c_long = 343;\npub const SYS_move_pages: ::c_long = 344;\npub const SYS_getcpu: ::c_long = 345;\npub const SYS_epoll_pwait: ::c_long = 346;\npub const SYS_kexec_load: ::c_long = 347;\npub const SYS_utimensat: ::c_long = 348;\npub const SYS_signalfd: ::c_long = 349;\npub const SYS_timerfd_create: ::c_long = 350;\npub const SYS_eventfd: ::c_long = 351;\npub const SYS_fallocate: ::c_long = 352;\npub const SYS_timerfd_settime: ::c_long = 353;\npub const SYS_timerfd_gettime: ::c_long = 354;\npub const SYS_signalfd4: ::c_long = 355;\npub const SYS_eventfd2: ::c_long = 356;\npub const SYS_epoll_create1: ::c_long = 357;\npub const SYS_dup3: ::c_long = 358;\npub const SYS_pipe2: ::c_long = 359;\npub const SYS_inotify_init1: ::c_long = 360;\npub const SYS_preadv: ::c_long = 361;\npub const SYS_pwritev: ::c_long = 362;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 363;\npub const SYS_perf_event_open: ::c_long = 364;\npub const SYS_recvmmsg: ::c_long = 365;\npub const SYS_accept4: ::c_long = 366;\npub const SYS_fanotify_init: ::c_long = 367;\npub const SYS_fanotify_mark: ::c_long = 368;\npub const SYS_prlimit64: ::c_long = 369;\npub const SYS_name_to_handle_at: ::c_long = 370;\npub const SYS_open_by_handle_at: ::c_long = 371;\npub const SYS_clock_adjtime: ::c_long = 372;\npub const SYS_syncfs: ::c_long = 373;\npub const SYS_sendmmsg: ::c_long = 374;\npub const SYS_setns: ::c_long = 375;\npub const SYS_process_vm_readv: ::c_long = 376;\npub const SYS_process_vm_writev: ::c_long = 377;\npub const SYS_kcmp: ::c_long = 378;\npub const SYS_finit_module: ::c_long = 379;\npub const SYS_sched_setattr: ::c_long = 380;\npub const SYS_sched_getattr: ::c_long = 381;\npub const SYS_renameat2: ::c_long = 382;\npub const SYS_seccomp: ::c_long = 383;\npub const SYS_getrandom: ::c_long = 384;\npub const SYS_memfd_create: ::c_long = 385;\npub const SYS_bpf: ::c_long = 386;\npub const SYS_execveat: ::c_long = 387;\npub const SYS_userfaultfd: ::c_long = 388;\npub const SYS_membarrier: ::c_long = 389;\npub const SYS_mlock2: ::c_long = 390;\npub const SYS_copy_file_range: ::c_long = 391;\npub const SYS_preadv2: ::c_long = 392;\npub const SYS_pwritev2: ::c_long = 393;\npub const SYS_pkey_mprotect: ::c_long = 394;\npub const SYS_pkey_alloc: ::c_long = 395;\npub const SYS_pkey_free: ::c_long = 396;\n\n// offsets in mcontext_t.gregs from sys/ucontext.h\npub const REG_R0: ::c_int = 0;\npub const REG_R1: ::c_int = 1;\npub const REG_R2: ::c_int = 2;\npub const REG_R3: ::c_int = 3;\npub const REG_R4: ::c_int = 4;\npub const REG_R5: ::c_int = 5;\npub const REG_R6: ::c_int = 6;\npub const REG_R7: ::c_int = 7;\npub const REG_R8: ::c_int = 8;\npub const REG_R9: ::c_int = 9;\npub const REG_R10: ::c_int = 10;\npub const REG_R11: ::c_int = 11;\npub const REG_R12: ::c_int = 12;\npub const REG_R13: ::c_int = 13;\npub const REG_R14: ::c_int = 14;\npub const REG_R15: ::c_int = 15;\n\npub const NGREG: ::c_int = 18;\n\nf! {\n    // Sadly, Android before 5.0 (API level 21), the accept4 syscall is not\n    // exposed by the libc. As work-around, we implement it through `syscall`\n    // directly. This workaround can be removed if the minimum version of\n    // Android is bumped. When the workaround is removed, `accept4` can be\n    // moved back to `linux_like/mod.rs`\n    pub fn accept4(\n        fd: ::c_int,\n        addr: *mut ::sockaddr,\n        len: *mut ::socklen_t,\n        flg: ::c_int\n    ) -> ::c_int {\n        ::syscall(SYS_accept4, fd, addr, len, flg) as ::c_int\n    }\n}\n"],["1143","// The following definitions are correct for aarch64 and x86_64,\n// but may be wrong for mips64\n\npub type c_long = i64;\npub type c_ulong = u64;\npub type mode_t = u32;\npub type off64_t = i64;\npub type socklen_t = u32;\n\ns! {\n    pub struct sigset_t {\n        __val: [::c_ulong; 1],\n    }\n\n    pub struct sigaction {\n        pub sa_flags: ::c_int,\n        pub sa_sigaction: ::sighandler_t,\n        pub sa_mask: ::sigset_t,\n        pub sa_restorer: ::Option<extern fn()>,\n    }\n\n    pub struct rlimit64 {\n        pub rlim_cur: ::c_ulonglong,\n        pub rlim_max: ::c_ulonglong,\n    }\n\n    pub struct pthread_attr_t {\n        pub flags: u32,\n        pub stack_base: *mut ::c_void,\n        pub stack_size: ::size_t,\n        pub guard_size: ::size_t,\n        pub sched_policy: i32,\n        pub sched_priority: i32,\n        __reserved: [::c_char; 16],\n    }\n\n    pub struct passwd {\n        pub pw_name: *mut ::c_char,\n        pub pw_passwd: *mut ::c_char,\n        pub pw_uid: ::uid_t,\n        pub pw_gid: ::gid_t,\n        pub pw_gecos: *mut ::c_char,\n        pub pw_dir: *mut ::c_char,\n        pub pw_shell: *mut ::c_char,\n    }\n\n    pub struct statfs {\n        pub f_type: u64,\n        pub f_bsize: u64,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_fsid: ::__fsid_t,\n        pub f_namelen: u64,\n        pub f_frsize: u64,\n        pub f_flags: u64,\n        pub f_spare: [u64; 4],\n    }\n\n    pub struct sysinfo {\n        pub uptime: ::c_long,\n        pub loads: [::c_ulong; 3],\n        pub totalram: ::c_ulong,\n        pub freeram: ::c_ulong,\n        pub sharedram: ::c_ulong,\n        pub bufferram: ::c_ulong,\n        pub totalswap: ::c_ulong,\n        pub freeswap: ::c_ulong,\n        pub procs: ::c_ushort,\n        pub pad: ::c_ushort,\n        pub totalhigh: ::c_ulong,\n        pub freehigh: ::c_ulong,\n        pub mem_unit: ::c_uint,\n        pub _f: [::c_char; 0],\n    }\n\n    pub struct statfs64 {\n        pub f_type: u64,\n        pub f_bsize: u64,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_fsid: ::__fsid_t,\n        pub f_namelen: u64,\n        pub f_frsize: u64,\n        pub f_flags: u64,\n        pub f_spare: [u64; 4],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_favail: u64,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n}\n\ns_no_extra_traits! {\n    pub struct pthread_mutex_t {\n        value: ::c_int,\n        __reserved: [::c_char; 36],\n    }\n\n    pub struct pthread_cond_t {\n        value: ::c_int,\n        __reserved: [::c_char; 44],\n    }\n\n    pub struct pthread_rwlock_t {\n        numLocks: ::c_int,\n        writerThreadId: ::c_int,\n        pendingReaders: ::c_int,\n        pendingWriters: ::c_int,\n        attr: i32,\n        __reserved: [::c_char; 36],\n    }\n\n    pub struct sigset64_t {\n        __bits: [::c_ulong; 1]\n    }\n}\n\ncfg_if! {\n    if #[cfg(feature = \"extra_traits\")] {\n        impl PartialEq for pthread_mutex_t {\n            fn eq(&self, other: &pthread_mutex_t) -> bool {\n                self.value == other.value\n                    && self\n                    .__reserved\n                    .iter()\n                    .zip(other.__reserved.iter())\n                    .all(|(a,b)| a == b)\n            }\n        }\n\n        impl Eq for pthread_mutex_t {}\n\n        impl ::fmt::Debug for pthread_mutex_t {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"pthread_mutex_t\")\n                    .field(\"value\", &self.value)\n                    // FIXME: .field(\"__reserved\", &self.__reserved)\n                    .finish()\n            }\n        }\n\n        impl ::hash::Hash for pthread_mutex_t {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.value.hash(state);\n                self.__reserved.hash(state);\n            }\n        }\n\n        impl PartialEq for pthread_cond_t {\n            fn eq(&self, other: &pthread_cond_t) -> bool {\n                self.value == other.value\n                    && self\n                    .__reserved\n                    .iter()\n                    .zip(other.__reserved.iter())\n                    .all(|(a,b)| a == b)\n            }\n        }\n\n        impl Eq for pthread_cond_t {}\n\n        impl ::fmt::Debug for pthread_cond_t {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"pthread_cond_t\")\n                    .field(\"value\", &self.value)\n                    // FIXME: .field(\"__reserved\", &self.__reserved)\n                    .finish()\n            }\n        }\n\n        impl ::hash::Hash for pthread_cond_t {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.value.hash(state);\n                self.__reserved.hash(state);\n            }\n        }\n\n        impl PartialEq for pthread_rwlock_t {\n            fn eq(&self, other: &pthread_rwlock_t) -> bool {\n                self.numLocks == other.numLocks\n                    && self.writerThreadId == other.writerThreadId\n                    && self.pendingReaders == other.pendingReaders\n                    && self.pendingWriters == other.pendingWriters\n                    && self.attr == other.attr\n                    && self\n                    .__reserved\n                    .iter()\n                    .zip(other.__reserved.iter())\n                    .all(|(a,b)| a == b)\n            }\n        }\n\n        impl Eq for pthread_rwlock_t {}\n\n        impl ::fmt::Debug for pthread_rwlock_t {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"pthread_rwlock_t\")\n                    .field(\"numLocks\", &self.numLocks)\n                    .field(\"writerThreadId\", &self.writerThreadId)\n                    .field(\"pendingReaders\", &self.pendingReaders)\n                    .field(\"pendingWriters\", &self.pendingWriters)\n                    .field(\"attr\", &self.attr)\n                    // FIXME: .field(\"__reserved\", &self.__reserved)\n                    .finish()\n            }\n        }\n\n        impl ::hash::Hash for pthread_rwlock_t {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.numLocks.hash(state);\n                self.writerThreadId.hash(state);\n                self.pendingReaders.hash(state);\n                self.pendingWriters.hash(state);\n                self.attr.hash(state);\n                self.__reserved.hash(state);\n            }\n        }\n\n        impl ::fmt::Debug for sigset64_t {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"sigset64_t\")\n                    .field(\"__bits\", &self.__bits)\n                    .finish()\n            }\n        }\n    }\n}\n\n// These constants must be of the same type of sigaction.sa_flags\npub const SA_NOCLDSTOP: ::c_int = 0x00000001;\npub const SA_NOCLDWAIT: ::c_int = 0x00000002;\npub const SA_NODEFER: ::c_int = 0x40000000;\npub const SA_ONSTACK: ::c_int = 0x08000000;\npub const SA_RESETHAND: ::c_int = 0x80000000;\npub const SA_RESTART: ::c_int = 0x10000000;\npub const SA_SIGINFO: ::c_int = 0x00000004;\n\npub const RTLD_GLOBAL: ::c_int = 0x00100;\npub const RTLD_NOW: ::c_int = 2;\npub const RTLD_DEFAULT: *mut ::c_void = 0i64 as *mut ::c_void;\n\n// From NDK's linux/auxvec.h\npub const AT_NULL: ::c_ulong = 0;\npub const AT_IGNORE: ::c_ulong = 1;\npub const AT_EXECFD: ::c_ulong = 2;\npub const AT_PHDR: ::c_ulong = 3;\npub const AT_PHENT: ::c_ulong = 4;\npub const AT_PHNUM: ::c_ulong = 5;\npub const AT_PAGESZ: ::c_ulong = 6;\npub const AT_BASE: ::c_ulong = 7;\npub const AT_FLAGS: ::c_ulong = 8;\npub const AT_ENTRY: ::c_ulong = 9;\npub const AT_NOTELF: ::c_ulong = 10;\npub const AT_UID: ::c_ulong = 11;\npub const AT_EUID: ::c_ulong = 12;\npub const AT_GID: ::c_ulong = 13;\npub const AT_EGID: ::c_ulong = 14;\npub const AT_PLATFORM: ::c_ulong = 15;\npub const AT_HWCAP: ::c_ulong = 16;\npub const AT_CLKTCK: ::c_ulong = 17;\npub const AT_SECURE: ::c_ulong = 23;\npub const AT_BASE_PLATFORM: ::c_ulong = 24;\npub const AT_RANDOM: ::c_ulong = 25;\npub const AT_HWCAP2: ::c_ulong = 26;\npub const AT_EXECFN: ::c_ulong = 31;\n\npub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n    value: 0,\n    __reserved: [0; 36],\n};\npub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n    value: 0,\n    __reserved: [0; 44],\n};\npub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {\n    numLocks: 0,\n    writerThreadId: 0,\n    pendingReaders: 0,\n    pendingWriters: 0,\n    attr: 0,\n    __reserved: [0; 36],\n};\npub const PTHREAD_STACK_MIN: ::size_t = 4096 * 4;\npub const CPU_SETSIZE: ::size_t = 1024;\npub const __CPU_BITS: ::size_t = 64;\n\npub const UT_LINESIZE: usize = 32;\npub const UT_NAMESIZE: usize = 32;\npub const UT_HOSTSIZE: usize = 256;\n\nf! {\n    // Sadly, Android before 5.0 (API level 21), the accept4 syscall is not\n    // exposed by the libc. As work-around, we implement it through `syscall`\n    // directly. This workaround can be removed if the minimum version of\n    // Android is bumped. When the workaround is removed, `accept4` can be\n    // moved back to `linux_like/mod.rs`\n    pub fn accept4(\n        fd: ::c_int,\n        addr: *mut ::sockaddr,\n        len: *mut ::socklen_t,\n        flg: ::c_int\n    ) -> ::c_int {\n        ::syscall(SYS_accept4, fd, addr, len, flg) as ::c_int\n    }\n}\n\nextern \"C\" {\n    pub fn getauxval(type_: ::c_ulong) -> ::c_ulong;\n}\n\ncfg_if! {\n    if #[cfg(target_arch = \"x86_64\")] {\n        mod x86_64;\n        pub use self::x86_64::*;\n    } else if #[cfg(target_arch = \"aarch64\")] {\n        mod aarch64;\n        pub use self::aarch64::*;\n    } else {\n        // Unknown target_arch\n    }\n}\n"],["1144","pub type c_char = i8;\npub type wchar_t = i32;\npub type greg_t = i64;\n\ns! {\n    pub struct stat {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino_t,\n        pub st_nlink: ::c_ulong,\n        pub st_mode: ::c_uint,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        pub st_size: ::off64_t,\n        pub st_blksize: ::c_long,\n        pub st_blocks: ::c_long,\n        pub st_atime: ::c_long,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::c_long,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::c_long,\n        pub st_ctime_nsec: ::c_long,\n        __unused: [::c_long; 3],\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino_t,\n        pub st_nlink: ::c_ulong,\n        pub st_mode: ::c_uint,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        pub st_size: ::off64_t,\n        pub st_blksize: ::c_long,\n        pub st_blocks: ::c_long,\n        pub st_atime: ::c_long,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::c_long,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::c_long,\n        pub st_ctime_nsec: ::c_long,\n        __unused: [::c_long; 3],\n    }\n\n    pub struct _libc_xmmreg {\n        pub element: [u32; 4],\n    }\n}\n\ncfg_if! {\n    if #[cfg(libc_union)] {\n        s_no_extra_traits! {\n            pub union __c_anonymous_uc_sigmask {\n                uc_sigmask: ::sigset_t,\n                uc_sigmask64: ::sigset64_t,\n            }\n        }\n\n        cfg_if! {\n            if #[cfg(feature = \"extra_traits\")] {\n                impl PartialEq for __c_anonymous_uc_sigmask {\n                    fn eq(&self, other: &__c_anonymous_uc_sigmask) -> bool {\n                        unsafe { self.uc_sigmask == other.uc_sigmask }\n                    }\n                }\n                impl Eq for __c_anonymous_uc_sigmask {}\n                impl ::fmt::Debug for __c_anonymous_uc_sigmask {\n                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                        f.debug_struct(\"uc_sigmask\")\n                            .field(\"uc_sigmask\", unsafe { &self.uc_sigmask })\n                            .finish()\n                    }\n                }\n                impl ::hash::Hash for __c_anonymous_uc_sigmask {\n                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                        unsafe { self.uc_sigmask.hash(state) }\n                    }\n                }\n            }\n        }\n    }\n}\n\ns_no_extra_traits! {\n    pub struct _libc_fpxreg {\n        pub significand: [u16; 4],\n        pub exponent: u16,\n        __padding: [u16; 3],\n    }\n\n    pub struct _libc_fpstate {\n        pub cwd: u16,\n        pub swd: u16,\n        pub ftw: u16,\n        pub fop: u16,\n        pub rip: u64,\n        pub rdp: u64,\n        pub mxcsr: u32,\n        pub mxcr_mask: u32,\n        pub _st: [_libc_fpxreg; 8],\n        pub _xmm: [_libc_xmmreg; 16],\n        __private: [u32; 24],\n    }\n\n    pub struct mcontext_t {\n        pub gregs: [greg_t; 23],\n        pub fpregs: *mut _libc_fpstate,\n        __private: [u64; 8],\n    }\n\n    pub struct ucontext_t {\n        pub uc_flags: ::c_ulong,\n        pub uc_link: *mut ucontext_t,\n        pub uc_stack: ::stack_t,\n        pub uc_mcontext: mcontext_t,\n        pub uc_sigmask64: __c_anonymous_uc_sigmask,\n        __fpregs_mem: _libc_fpstate,\n    }\n}\n\ncfg_if! {\n    if #[cfg(feature = \"extra_traits\")] {\n        impl PartialEq for _libc_fpxreg {\n            fn eq(&self, other: &Self) -> bool {\n                self.significand == other.significand\n                    && self.exponent == other.exponent\n                    // Ignore padding field\n            }\n        }\n        impl Eq for _libc_fpxreg {}\n        impl ::fmt::Debug for _libc_fpxreg {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"_libc_fpxreg\")\n                    .field(\"significand\", &self.significand)\n                    .field(\"exponent\", &self.exponent)\n                    // Ignore padding field\n                    .finish()\n            }\n        }\n        impl ::hash::Hash for _libc_fpxreg {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.significand.hash(state);\n                self.exponent.hash(state);\n                // Ignore padding field\n            }\n        }\n\n        impl PartialEq for _libc_fpstate {\n            fn eq(&self, other: &Self) -> bool {\n                self.cwd == other.cwd\n                    && self.swd == other.swd\n                    && self.ftw == other.ftw\n                    && self.fop == other.fop\n                    && self.rip == other.rip\n                    && self.rdp == other.rdp\n                    && self.mxcsr == other.mxcsr\n                    && self.mxcr_mask == other.mxcr_mask\n                    && self._st == other._st\n                    && self._xmm == other._xmm\n                    // Ignore padding field\n            }\n        }\n        impl Eq for _libc_fpstate {}\n        impl ::fmt::Debug for _libc_fpstate {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"_libc_fpstate\")\n                    .field(\"cwd\", &self.cwd)\n                    .field(\"swd\", &self.swd)\n                    .field(\"ftw\", &self.ftw)\n                    .field(\"fop\", &self.fop)\n                    .field(\"rip\", &self.rip)\n                    .field(\"rdp\", &self.rdp)\n                    .field(\"mxcsr\", &self.mxcsr)\n                    .field(\"mxcr_mask\", &self.mxcr_mask)\n                    .field(\"_st\", &self._st)\n                    .field(\"_xmm\", &self._xmm)\n                    // Ignore padding field\n                    .finish()\n            }\n        }\n        impl ::hash::Hash for _libc_fpstate {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.cwd.hash(state);\n                self.swd.hash(state);\n                self.ftw.hash(state);\n                self.fop.hash(state);\n                self.rip.hash(state);\n                self.rdp.hash(state);\n                self.mxcsr.hash(state);\n                self.mxcr_mask.hash(state);\n                self._st.hash(state);\n                self._xmm.hash(state);\n                // Ignore padding field\n            }\n        }\n\n        impl PartialEq for mcontext_t {\n            fn eq(&self, other: &Self) -> bool {\n                self.gregs == other.gregs\n                    && self.fpregs == other.fpregs\n                    // Ignore padding field\n            }\n        }\n        impl Eq for mcontext_t {}\n        impl ::fmt::Debug for mcontext_t {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"mcontext_t\")\n                    .field(\"gregs\", &self.gregs)\n                    .field(\"fpregs\", &self.fpregs)\n                    // Ignore padding field\n                    .finish()\n            }\n        }\n        impl ::hash::Hash for mcontext_t {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.gregs.hash(state);\n                self.fpregs.hash(state);\n                // Ignore padding field\n            }\n        }\n\n        impl PartialEq for ucontext_t {\n            fn eq(&self, other: &Self) -> bool {\n                self.uc_flags == other.uc_flags\n                    && self.uc_link == other.uc_link\n                    && self.uc_stack == other.uc_stack\n                    && self.uc_mcontext == other.uc_mcontext\n                    && self.uc_sigmask64 == other.uc_sigmask64\n                    // Ignore padding field\n            }\n        }\n        impl Eq for ucontext_t {}\n        impl ::fmt::Debug for ucontext_t {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"ucontext_t\")\n                    .field(\"uc_flags\", &self.uc_flags)\n                    .field(\"uc_link\", &self.uc_link)\n                    .field(\"uc_stack\", &self.uc_stack)\n                    .field(\"uc_mcontext\", &self.uc_mcontext)\n                    .field(\"uc_sigmask64\", &self.uc_sigmask64)\n                    // Ignore padding field\n                    .finish()\n            }\n        }\n        impl ::hash::Hash for ucontext_t {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.uc_flags.hash(state);\n                self.uc_link.hash(state);\n                self.uc_stack.hash(state);\n                self.uc_mcontext.hash(state);\n                self.uc_sigmask64.hash(state);\n                // Ignore padding field\n            }\n        }\n    }\n}\n\npub const O_DIRECT: ::c_int = 0x4000;\npub const O_DIRECTORY: ::c_int = 0x10000;\npub const O_NOFOLLOW: ::c_int = 0x20000;\npub const O_LARGEFILE: ::c_int = 0o0100000;\n\npub const SIGSTKSZ: ::size_t = 8192;\npub const MINSIGSTKSZ: ::size_t = 2048;\n\npub const MAP_32BIT: ::c_int = 0x40;\n\n// Syscall table\n\npub const SYS_read: ::c_long = 0;\npub const SYS_write: ::c_long = 1;\npub const SYS_open: ::c_long = 2;\npub const SYS_close: ::c_long = 3;\npub const SYS_stat: ::c_long = 4;\npub const SYS_fstat: ::c_long = 5;\npub const SYS_lstat: ::c_long = 6;\npub const SYS_poll: ::c_long = 7;\npub const SYS_lseek: ::c_long = 8;\npub const SYS_mmap: ::c_long = 9;\npub const SYS_mprotect: ::c_long = 10;\npub const SYS_munmap: ::c_long = 11;\npub const SYS_brk: ::c_long = 12;\npub const SYS_rt_sigaction: ::c_long = 13;\npub const SYS_rt_sigprocmask: ::c_long = 14;\npub const SYS_rt_sigreturn: ::c_long = 15;\npub const SYS_ioctl: ::c_long = 16;\npub const SYS_pread64: ::c_long = 17;\npub const SYS_pwrite64: ::c_long = 18;\npub const SYS_readv: ::c_long = 19;\npub const SYS_writev: ::c_long = 20;\npub const SYS_access: ::c_long = 21;\npub const SYS_pipe: ::c_long = 22;\npub const SYS_select: ::c_long = 23;\npub const SYS_sched_yield: ::c_long = 24;\npub const SYS_mremap: ::c_long = 25;\npub const SYS_msync: ::c_long = 26;\npub const SYS_mincore: ::c_long = 27;\npub const SYS_madvise: ::c_long = 28;\npub const SYS_shmget: ::c_long = 29;\npub const SYS_shmat: ::c_long = 30;\npub const SYS_shmctl: ::c_long = 31;\npub const SYS_dup: ::c_long = 32;\npub const SYS_dup2: ::c_long = 33;\npub const SYS_pause: ::c_long = 34;\npub const SYS_nanosleep: ::c_long = 35;\npub const SYS_getitimer: ::c_long = 36;\npub const SYS_alarm: ::c_long = 37;\npub const SYS_setitimer: ::c_long = 38;\npub const SYS_getpid: ::c_long = 39;\npub const SYS_sendfile: ::c_long = 40;\npub const SYS_socket: ::c_long = 41;\npub const SYS_connect: ::c_long = 42;\npub const SYS_accept: ::c_long = 43;\npub const SYS_sendto: ::c_long = 44;\npub const SYS_recvfrom: ::c_long = 45;\npub const SYS_sendmsg: ::c_long = 46;\npub const SYS_recvmsg: ::c_long = 47;\npub const SYS_shutdown: ::c_long = 48;\npub const SYS_bind: ::c_long = 49;\npub const SYS_listen: ::c_long = 50;\npub const SYS_getsockname: ::c_long = 51;\npub const SYS_getpeername: ::c_long = 52;\npub const SYS_socketpair: ::c_long = 53;\npub const SYS_setsockopt: ::c_long = 54;\npub const SYS_getsockopt: ::c_long = 55;\npub const SYS_clone: ::c_long = 56;\npub const SYS_fork: ::c_long = 57;\npub const SYS_vfork: ::c_long = 58;\npub const SYS_execve: ::c_long = 59;\npub const SYS_exit: ::c_long = 60;\npub const SYS_wait4: ::c_long = 61;\npub const SYS_kill: ::c_long = 62;\npub const SYS_uname: ::c_long = 63;\npub const SYS_semget: ::c_long = 64;\npub const SYS_semop: ::c_long = 65;\npub const SYS_semctl: ::c_long = 66;\npub const SYS_shmdt: ::c_long = 67;\npub const SYS_msgget: ::c_long = 68;\npub const SYS_msgsnd: ::c_long = 69;\npub const SYS_msgrcv: ::c_long = 70;\npub const SYS_msgctl: ::c_long = 71;\npub const SYS_fcntl: ::c_long = 72;\npub const SYS_flock: ::c_long = 73;\npub const SYS_fsync: ::c_long = 74;\npub const SYS_fdatasync: ::c_long = 75;\npub const SYS_truncate: ::c_long = 76;\npub const SYS_ftruncate: ::c_long = 77;\npub const SYS_getdents: ::c_long = 78;\npub const SYS_getcwd: ::c_long = 79;\npub const SYS_chdir: ::c_long = 80;\npub const SYS_fchdir: ::c_long = 81;\npub const SYS_rename: ::c_long = 82;\npub const SYS_mkdir: ::c_long = 83;\npub const SYS_rmdir: ::c_long = 84;\npub const SYS_creat: ::c_long = 85;\npub const SYS_link: ::c_long = 86;\npub const SYS_unlink: ::c_long = 87;\npub const SYS_symlink: ::c_long = 88;\npub const SYS_readlink: ::c_long = 89;\npub const SYS_chmod: ::c_long = 90;\npub const SYS_fchmod: ::c_long = 91;\npub const SYS_chown: ::c_long = 92;\npub const SYS_fchown: ::c_long = 93;\npub const SYS_lchown: ::c_long = 94;\npub const SYS_umask: ::c_long = 95;\npub const SYS_gettimeofday: ::c_long = 96;\npub const SYS_getrlimit: ::c_long = 97;\npub const SYS_getrusage: ::c_long = 98;\npub const SYS_sysinfo: ::c_long = 99;\npub const SYS_times: ::c_long = 100;\npub const SYS_ptrace: ::c_long = 101;\npub const SYS_getuid: ::c_long = 102;\npub const SYS_syslog: ::c_long = 103;\npub const SYS_getgid: ::c_long = 104;\npub const SYS_setuid: ::c_long = 105;\npub const SYS_setgid: ::c_long = 106;\npub const SYS_geteuid: ::c_long = 107;\npub const SYS_getegid: ::c_long = 108;\npub const SYS_setpgid: ::c_long = 109;\npub const SYS_getppid: ::c_long = 110;\npub const SYS_getpgrp: ::c_long = 111;\npub const SYS_setsid: ::c_long = 112;\npub const SYS_setreuid: ::c_long = 113;\npub const SYS_setregid: ::c_long = 114;\npub const SYS_getgroups: ::c_long = 115;\npub const SYS_setgroups: ::c_long = 116;\npub const SYS_setresuid: ::c_long = 117;\npub const SYS_getresuid: ::c_long = 118;\npub const SYS_setresgid: ::c_long = 119;\npub const SYS_getresgid: ::c_long = 120;\npub const SYS_getpgid: ::c_long = 121;\npub const SYS_setfsuid: ::c_long = 122;\npub const SYS_setfsgid: ::c_long = 123;\npub const SYS_getsid: ::c_long = 124;\npub const SYS_capget: ::c_long = 125;\npub const SYS_capset: ::c_long = 126;\npub const SYS_rt_sigpending: ::c_long = 127;\npub const SYS_rt_sigtimedwait: ::c_long = 128;\npub const SYS_rt_sigqueueinfo: ::c_long = 129;\npub const SYS_rt_sigsuspend: ::c_long = 130;\npub const SYS_sigaltstack: ::c_long = 131;\npub const SYS_utime: ::c_long = 132;\npub const SYS_mknod: ::c_long = 133;\npub const SYS_uselib: ::c_long = 134;\npub const SYS_personality: ::c_long = 135;\npub const SYS_ustat: ::c_long = 136;\npub const SYS_statfs: ::c_long = 137;\npub const SYS_fstatfs: ::c_long = 138;\npub const SYS_sysfs: ::c_long = 139;\npub const SYS_getpriority: ::c_long = 140;\npub const SYS_setpriority: ::c_long = 141;\npub const SYS_sched_setparam: ::c_long = 142;\npub const SYS_sched_getparam: ::c_long = 143;\npub const SYS_sched_setscheduler: ::c_long = 144;\npub const SYS_sched_getscheduler: ::c_long = 145;\npub const SYS_sched_get_priority_max: ::c_long = 146;\npub const SYS_sched_get_priority_min: ::c_long = 147;\npub const SYS_sched_rr_get_interval: ::c_long = 148;\npub const SYS_mlock: ::c_long = 149;\npub const SYS_munlock: ::c_long = 150;\npub const SYS_mlockall: ::c_long = 151;\npub const SYS_munlockall: ::c_long = 152;\npub const SYS_vhangup: ::c_long = 153;\npub const SYS_modify_ldt: ::c_long = 154;\npub const SYS_pivot_root: ::c_long = 155;\n// FIXME: SYS__sysctl is in the NDK sources but for some reason is\n//        not available in the tests\n// pub const SYS__sysctl: ::c_long = 156;\npub const SYS_prctl: ::c_long = 157;\npub const SYS_arch_prctl: ::c_long = 158;\npub const SYS_adjtimex: ::c_long = 159;\npub const SYS_setrlimit: ::c_long = 160;\npub const SYS_chroot: ::c_long = 161;\npub const SYS_sync: ::c_long = 162;\npub const SYS_acct: ::c_long = 163;\npub const SYS_settimeofday: ::c_long = 164;\npub const SYS_mount: ::c_long = 165;\npub const SYS_umount2: ::c_long = 166;\npub const SYS_swapon: ::c_long = 167;\npub const SYS_swapoff: ::c_long = 168;\npub const SYS_reboot: ::c_long = 169;\npub const SYS_sethostname: ::c_long = 170;\npub const SYS_setdomainname: ::c_long = 171;\npub const SYS_iopl: ::c_long = 172;\npub const SYS_ioperm: ::c_long = 173;\npub const SYS_create_module: ::c_long = 174;\npub const SYS_init_module: ::c_long = 175;\npub const SYS_delete_module: ::c_long = 176;\npub const SYS_get_kernel_syms: ::c_long = 177;\npub const SYS_query_module: ::c_long = 178;\npub const SYS_quotactl: ::c_long = 179;\npub const SYS_nfsservctl: ::c_long = 180;\npub const SYS_getpmsg: ::c_long = 181;\npub const SYS_putpmsg: ::c_long = 182;\npub const SYS_afs_syscall: ::c_long = 183;\npub const SYS_tuxcall: ::c_long = 184;\npub const SYS_security: ::c_long = 185;\npub const SYS_gettid: ::c_long = 186;\npub const SYS_readahead: ::c_long = 187;\npub const SYS_setxattr: ::c_long = 188;\npub const SYS_lsetxattr: ::c_long = 189;\npub const SYS_fsetxattr: ::c_long = 190;\npub const SYS_getxattr: ::c_long = 191;\npub const SYS_lgetxattr: ::c_long = 192;\npub const SYS_fgetxattr: ::c_long = 193;\npub const SYS_listxattr: ::c_long = 194;\npub const SYS_llistxattr: ::c_long = 195;\npub const SYS_flistxattr: ::c_long = 196;\npub const SYS_removexattr: ::c_long = 197;\npub const SYS_lremovexattr: ::c_long = 198;\npub const SYS_fremovexattr: ::c_long = 199;\npub const SYS_tkill: ::c_long = 200;\npub const SYS_time: ::c_long = 201;\npub const SYS_futex: ::c_long = 202;\npub const SYS_sched_setaffinity: ::c_long = 203;\npub const SYS_sched_getaffinity: ::c_long = 204;\npub const SYS_set_thread_area: ::c_long = 205;\npub const SYS_io_setup: ::c_long = 206;\npub const SYS_io_destroy: ::c_long = 207;\npub const SYS_io_getevents: ::c_long = 208;\npub const SYS_io_submit: ::c_long = 209;\npub const SYS_io_cancel: ::c_long = 210;\npub const SYS_get_thread_area: ::c_long = 211;\npub const SYS_lookup_dcookie: ::c_long = 212;\npub const SYS_epoll_create: ::c_long = 213;\npub const SYS_epoll_ctl_old: ::c_long = 214;\npub const SYS_epoll_wait_old: ::c_long = 215;\npub const SYS_remap_file_pages: ::c_long = 216;\npub const SYS_getdents64: ::c_long = 217;\npub const SYS_set_tid_address: ::c_long = 218;\npub const SYS_restart_syscall: ::c_long = 219;\npub const SYS_semtimedop: ::c_long = 220;\npub const SYS_fadvise64: ::c_long = 221;\npub const SYS_timer_create: ::c_long = 222;\npub const SYS_timer_settime: ::c_long = 223;\npub const SYS_timer_gettime: ::c_long = 224;\npub const SYS_timer_getoverrun: ::c_long = 225;\npub const SYS_timer_delete: ::c_long = 226;\npub const SYS_clock_settime: ::c_long = 227;\npub const SYS_clock_gettime: ::c_long = 228;\npub const SYS_clock_getres: ::c_long = 229;\npub const SYS_clock_nanosleep: ::c_long = 230;\npub const SYS_exit_group: ::c_long = 231;\npub const SYS_epoll_wait: ::c_long = 232;\npub const SYS_epoll_ctl: ::c_long = 233;\npub const SYS_tgkill: ::c_long = 234;\npub const SYS_utimes: ::c_long = 235;\npub const SYS_vserver: ::c_long = 236;\npub const SYS_mbind: ::c_long = 237;\npub const SYS_set_mempolicy: ::c_long = 238;\npub const SYS_get_mempolicy: ::c_long = 239;\npub const SYS_mq_open: ::c_long = 240;\npub const SYS_mq_unlink: ::c_long = 241;\npub const SYS_mq_timedsend: ::c_long = 242;\npub const SYS_mq_timedreceive: ::c_long = 243;\npub const SYS_mq_notify: ::c_long = 244;\npub const SYS_mq_getsetattr: ::c_long = 245;\npub const SYS_kexec_load: ::c_long = 246;\npub const SYS_waitid: ::c_long = 247;\npub const SYS_add_key: ::c_long = 248;\npub const SYS_request_key: ::c_long = 249;\npub const SYS_keyctl: ::c_long = 250;\npub const SYS_ioprio_set: ::c_long = 251;\npub const SYS_ioprio_get: ::c_long = 252;\npub const SYS_inotify_init: ::c_long = 253;\npub const SYS_inotify_add_watch: ::c_long = 254;\npub const SYS_inotify_rm_watch: ::c_long = 255;\npub const SYS_migrate_pages: ::c_long = 256;\npub const SYS_openat: ::c_long = 257;\npub const SYS_mkdirat: ::c_long = 258;\npub const SYS_mknodat: ::c_long = 259;\npub const SYS_fchownat: ::c_long = 260;\npub const SYS_futimesat: ::c_long = 261;\npub const SYS_newfstatat: ::c_long = 262;\npub const SYS_unlinkat: ::c_long = 263;\npub const SYS_renameat: ::c_long = 264;\npub const SYS_linkat: ::c_long = 265;\npub const SYS_symlinkat: ::c_long = 266;\npub const SYS_readlinkat: ::c_long = 267;\npub const SYS_fchmodat: ::c_long = 268;\npub const SYS_faccessat: ::c_long = 269;\npub const SYS_pselect6: ::c_long = 270;\npub const SYS_ppoll: ::c_long = 271;\npub const SYS_unshare: ::c_long = 272;\npub const SYS_set_robust_list: ::c_long = 273;\npub const SYS_get_robust_list: ::c_long = 274;\npub const SYS_splice: ::c_long = 275;\npub const SYS_tee: ::c_long = 276;\npub const SYS_sync_file_range: ::c_long = 277;\npub const SYS_vmsplice: ::c_long = 278;\npub const SYS_move_pages: ::c_long = 279;\npub const SYS_utimensat: ::c_long = 280;\npub const SYS_epoll_pwait: ::c_long = 281;\npub const SYS_signalfd: ::c_long = 282;\npub const SYS_timerfd_create: ::c_long = 283;\npub const SYS_eventfd: ::c_long = 284;\npub const SYS_fallocate: ::c_long = 285;\npub const SYS_timerfd_settime: ::c_long = 286;\npub const SYS_timerfd_gettime: ::c_long = 287;\npub const SYS_accept4: ::c_long = 288;\npub const SYS_signalfd4: ::c_long = 289;\npub const SYS_eventfd2: ::c_long = 290;\npub const SYS_epoll_create1: ::c_long = 291;\npub const SYS_dup3: ::c_long = 292;\npub const SYS_pipe2: ::c_long = 293;\npub const SYS_inotify_init1: ::c_long = 294;\npub const SYS_preadv: ::c_long = 295;\npub const SYS_pwritev: ::c_long = 296;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 297;\npub const SYS_perf_event_open: ::c_long = 298;\npub const SYS_recvmmsg: ::c_long = 299;\npub const SYS_fanotify_init: ::c_long = 300;\npub const SYS_fanotify_mark: ::c_long = 301;\npub const SYS_prlimit64: ::c_long = 302;\npub const SYS_name_to_handle_at: ::c_long = 303;\npub const SYS_open_by_handle_at: ::c_long = 304;\npub const SYS_clock_adjtime: ::c_long = 305;\npub const SYS_syncfs: ::c_long = 306;\npub const SYS_sendmmsg: ::c_long = 307;\npub const SYS_setns: ::c_long = 308;\npub const SYS_getcpu: ::c_long = 309;\npub const SYS_process_vm_readv: ::c_long = 310;\npub const SYS_process_vm_writev: ::c_long = 311;\npub const SYS_kcmp: ::c_long = 312;\npub const SYS_finit_module: ::c_long = 313;\npub const SYS_sched_setattr: ::c_long = 314;\npub const SYS_sched_getattr: ::c_long = 315;\npub const SYS_renameat2: ::c_long = 316;\npub const SYS_seccomp: ::c_long = 317;\npub const SYS_getrandom: ::c_long = 318;\npub const SYS_memfd_create: ::c_long = 319;\npub const SYS_kexec_file_load: ::c_long = 320;\npub const SYS_bpf: ::c_long = 321;\npub const SYS_execveat: ::c_long = 322;\npub const SYS_userfaultfd: ::c_long = 323;\npub const SYS_membarrier: ::c_long = 324;\npub const SYS_mlock2: ::c_long = 325;\npub const SYS_copy_file_range: ::c_long = 326;\npub const SYS_preadv2: ::c_long = 327;\npub const SYS_pwritev2: ::c_long = 328;\npub const SYS_pkey_mprotect: ::c_long = 329;\npub const SYS_pkey_alloc: ::c_long = 330;\npub const SYS_pkey_free: ::c_long = 331;\n\n// offsets in user_regs_structs, from sys/reg.h\npub const R15: ::c_int = 0;\npub const R14: ::c_int = 1;\npub const R13: ::c_int = 2;\npub const R12: ::c_int = 3;\npub const RBP: ::c_int = 4;\npub const RBX: ::c_int = 5;\npub const R11: ::c_int = 6;\npub const R10: ::c_int = 7;\npub const R9: ::c_int = 8;\npub const R8: ::c_int = 9;\npub const RAX: ::c_int = 10;\npub const RCX: ::c_int = 11;\npub const RDX: ::c_int = 12;\npub const RSI: ::c_int = 13;\npub const RDI: ::c_int = 14;\npub const ORIG_RAX: ::c_int = 15;\npub const RIP: ::c_int = 16;\npub const CS: ::c_int = 17;\npub const EFLAGS: ::c_int = 18;\npub const RSP: ::c_int = 19;\npub const SS: ::c_int = 20;\npub const FS_BASE: ::c_int = 21;\npub const GS_BASE: ::c_int = 22;\npub const DS: ::c_int = 23;\npub const ES: ::c_int = 24;\npub const FS: ::c_int = 25;\npub const GS: ::c_int = 26;\n\n// offsets in mcontext_t.gregs from sys/ucontext.h\npub const REG_R8: ::c_int = 0;\npub const REG_R9: ::c_int = 1;\npub const REG_R10: ::c_int = 2;\npub const REG_R11: ::c_int = 3;\npub const REG_R12: ::c_int = 4;\npub const REG_R13: ::c_int = 5;\npub const REG_R14: ::c_int = 6;\npub const REG_R15: ::c_int = 7;\npub const REG_RDI: ::c_int = 8;\npub const REG_RSI: ::c_int = 9;\npub const REG_RBP: ::c_int = 10;\npub const REG_RBX: ::c_int = 11;\npub const REG_RDX: ::c_int = 12;\npub const REG_RAX: ::c_int = 13;\npub const REG_RCX: ::c_int = 14;\npub const REG_RSP: ::c_int = 15;\npub const REG_RIP: ::c_int = 16;\npub const REG_EFL: ::c_int = 17;\npub const REG_CSGSFS: ::c_int = 18;\npub const REG_ERR: ::c_int = 19;\npub const REG_TRAPNO: ::c_int = 20;\npub const REG_OLDMASK: ::c_int = 21;\npub const REG_CR2: ::c_int = 22;\n\ncfg_if! {\n    if #[cfg(libc_align)] {\n        mod align;\n        pub use self::align::*;\n    }\n}\n"],["1145","s_no_extra_traits! {\n    #[allow(missing_debug_implementations)]\n    #[repr(align(16))]\n    pub struct max_align_t {\n        priv_: [f64; 4]\n    }\n}\n"],["1146","s_no_extra_traits! {\n    #[allow(missing_debug_implementations)]\n    #[repr(align(16))]\n    pub struct max_align_t {\n        priv_: [f32; 8]\n    }\n}\n\ns! {\n    pub struct ucontext_t {\n        pub uc_flags: ::c_ulong,\n        pub uc_link: *mut ucontext_t,\n        pub uc_stack: ::stack_t,\n        pub uc_sigmask: ::sigset_t,\n        pub uc_mcontext: mcontext_t,\n    }\n\n    #[repr(align(16))]\n    pub struct mcontext_t {\n        pub fault_address: ::c_ulonglong,\n        pub regs: [::c_ulonglong; 31],\n        pub sp: ::c_ulonglong,\n        pub pc: ::c_ulonglong,\n        pub pstate: ::c_ulonglong,\n        // nested arrays to get the right size/length while being able to\n        // auto-derive traits like Debug\n        __reserved: [[u64; 32]; 16],\n    }\n}\n"],["1147","pub type c_char = u8;\npub type wchar_t = u32;\n\ns! {\n    pub struct stat {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino_t,\n        pub st_mode: ::c_uint,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        __pad1: ::c_ulong,\n        pub st_size: ::off64_t,\n        pub st_blksize: ::c_int,\n        __pad2: ::c_int,\n        pub st_blocks: ::c_long,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __unused4: ::c_uint,\n        __unused5: ::c_uint,\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino_t,\n        pub st_mode: ::c_uint,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        __pad1: ::c_ulong,\n        pub st_size: ::off64_t,\n        pub st_blksize: ::c_int,\n        __pad2: ::c_int,\n        pub st_blocks: ::c_long,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __unused4: ::c_uint,\n        __unused5: ::c_uint,\n    }\n}\n\npub const O_DIRECT: ::c_int = 0x10000;\npub const O_DIRECTORY: ::c_int = 0x4000;\npub const O_NOFOLLOW: ::c_int = 0x8000;\npub const O_LARGEFILE: ::c_int = 0o400000;\n\npub const SIGSTKSZ: ::size_t = 16384;\npub const MINSIGSTKSZ: ::size_t = 5120;\n\n// From NDK's asm/hwcap.h\npub const HWCAP_FP: ::c_ulong = 1 << 0;\npub const HWCAP_ASIMD: ::c_ulong = 1 << 1;\npub const HWCAP_EVTSTRM: ::c_ulong = 1 << 2;\npub const HWCAP_AES: ::c_ulong = 1 << 3;\npub const HWCAP_PMULL: ::c_ulong = 1 << 4;\npub const HWCAP_SHA1: ::c_ulong = 1 << 5;\npub const HWCAP_SHA2: ::c_ulong = 1 << 6;\npub const HWCAP_CRC32: ::c_ulong = 1 << 7;\npub const HWCAP_ATOMICS: ::c_ulong = 1 << 8;\npub const HWCAP_FPHP: ::c_ulong = 1 << 9;\npub const HWCAP_ASIMDHP: ::c_ulong = 1 << 10;\npub const HWCAP_CPUID: ::c_ulong = 1 << 11;\npub const HWCAP_ASIMDRDM: ::c_ulong = 1 << 12;\npub const HWCAP_JSCVT: ::c_ulong = 1 << 13;\npub const HWCAP_FCMA: ::c_ulong = 1 << 14;\npub const HWCAP_LRCPC: ::c_ulong = 1 << 15;\npub const HWCAP_DCPOP: ::c_ulong = 1 << 16;\npub const HWCAP_SHA3: ::c_ulong = 1 << 17;\npub const HWCAP_SM3: ::c_ulong = 1 << 18;\npub const HWCAP_SM4: ::c_ulong = 1 << 19;\npub const HWCAP_ASIMDDP: ::c_ulong = 1 << 20;\npub const HWCAP_SHA512: ::c_ulong = 1 << 21;\npub const HWCAP_SVE: ::c_ulong = 1 << 22;\npub const HWCAP_ASIMDFHM: ::c_ulong = 1 << 23;\npub const HWCAP_DIT: ::c_ulong = 1 << 24;\npub const HWCAP_USCAT: ::c_ulong = 1 << 25;\npub const HWCAP_ILRCPC: ::c_ulong = 1 << 26;\npub const HWCAP_FLAGM: ::c_ulong = 1 << 27;\npub const HWCAP_SSBS: ::c_ulong = 1 << 28;\npub const HWCAP_SB: ::c_ulong = 1 << 29;\npub const HWCAP_PACA: ::c_ulong = 1 << 30;\npub const HWCAP_PACG: ::c_ulong = 1 << 31;\npub const HWCAP2_DCPODP: ::c_ulong = 1 << 0;\npub const HWCAP2_SVE2: ::c_ulong = 1 << 1;\npub const HWCAP2_SVEAES: ::c_ulong = 1 << 2;\npub const HWCAP2_SVEPMULL: ::c_ulong = 1 << 3;\npub const HWCAP2_SVEBITPERM: ::c_ulong = 1 << 4;\npub const HWCAP2_SVESHA3: ::c_ulong = 1 << 5;\npub const HWCAP2_SVESM4: ::c_ulong = 1 << 6;\npub const HWCAP2_FLAGM2: ::c_ulong = 1 << 7;\npub const HWCAP2_FRINT: ::c_ulong = 1 << 8;\n\npub const SYS_io_setup: ::c_long = 0;\npub const SYS_io_destroy: ::c_long = 1;\npub const SYS_io_submit: ::c_long = 2;\npub const SYS_io_cancel: ::c_long = 3;\npub const SYS_io_getevents: ::c_long = 4;\npub const SYS_setxattr: ::c_long = 5;\npub const SYS_lsetxattr: ::c_long = 6;\npub const SYS_fsetxattr: ::c_long = 7;\npub const SYS_getxattr: ::c_long = 8;\npub const SYS_lgetxattr: ::c_long = 9;\npub const SYS_fgetxattr: ::c_long = 10;\npub const SYS_listxattr: ::c_long = 11;\npub const SYS_llistxattr: ::c_long = 12;\npub const SYS_flistxattr: ::c_long = 13;\npub const SYS_removexattr: ::c_long = 14;\npub const SYS_lremovexattr: ::c_long = 15;\npub const SYS_fremovexattr: ::c_long = 16;\npub const SYS_getcwd: ::c_long = 17;\npub const SYS_lookup_dcookie: ::c_long = 18;\npub const SYS_eventfd2: ::c_long = 19;\npub const SYS_epoll_create1: ::c_long = 20;\npub const SYS_epoll_ctl: ::c_long = 21;\npub const SYS_epoll_pwait: ::c_long = 22;\npub const SYS_dup: ::c_long = 23;\npub const SYS_dup3: ::c_long = 24;\npub const SYS_inotify_init1: ::c_long = 26;\npub const SYS_inotify_add_watch: ::c_long = 27;\npub const SYS_inotify_rm_watch: ::c_long = 28;\npub const SYS_ioctl: ::c_long = 29;\npub const SYS_ioprio_set: ::c_long = 30;\npub const SYS_ioprio_get: ::c_long = 31;\npub const SYS_flock: ::c_long = 32;\npub const SYS_mknodat: ::c_long = 33;\npub const SYS_mkdirat: ::c_long = 34;\npub const SYS_unlinkat: ::c_long = 35;\npub const SYS_symlinkat: ::c_long = 36;\npub const SYS_linkat: ::c_long = 37;\npub const SYS_renameat: ::c_long = 38;\npub const SYS_umount2: ::c_long = 39;\npub const SYS_mount: ::c_long = 40;\npub const SYS_pivot_root: ::c_long = 41;\npub const SYS_nfsservctl: ::c_long = 42;\npub const SYS_fallocate: ::c_long = 47;\npub const SYS_faccessat: ::c_long = 48;\npub const SYS_chdir: ::c_long = 49;\npub const SYS_fchdir: ::c_long = 50;\npub const SYS_chroot: ::c_long = 51;\npub const SYS_fchmod: ::c_long = 52;\npub const SYS_fchmodat: ::c_long = 53;\npub const SYS_fchownat: ::c_long = 54;\npub const SYS_fchown: ::c_long = 55;\npub const SYS_openat: ::c_long = 56;\npub const SYS_close: ::c_long = 57;\npub const SYS_vhangup: ::c_long = 58;\npub const SYS_pipe2: ::c_long = 59;\npub const SYS_quotactl: ::c_long = 60;\npub const SYS_getdents64: ::c_long = 61;\npub const SYS_read: ::c_long = 63;\npub const SYS_write: ::c_long = 64;\npub const SYS_readv: ::c_long = 65;\npub const SYS_writev: ::c_long = 66;\npub const SYS_pread64: ::c_long = 67;\npub const SYS_pwrite64: ::c_long = 68;\npub const SYS_preadv: ::c_long = 69;\npub const SYS_pwritev: ::c_long = 70;\npub const SYS_pselect6: ::c_long = 72;\npub const SYS_ppoll: ::c_long = 73;\npub const SYS_signalfd4: ::c_long = 74;\npub const SYS_vmsplice: ::c_long = 75;\npub const SYS_splice: ::c_long = 76;\npub const SYS_tee: ::c_long = 77;\npub const SYS_readlinkat: ::c_long = 78;\npub const SYS_sync: ::c_long = 81;\npub const SYS_fsync: ::c_long = 82;\npub const SYS_fdatasync: ::c_long = 83;\npub const SYS_sync_file_range: ::c_long = 84;\npub const SYS_timerfd_create: ::c_long = 85;\npub const SYS_timerfd_settime: ::c_long = 86;\npub const SYS_timerfd_gettime: ::c_long = 87;\npub const SYS_utimensat: ::c_long = 88;\npub const SYS_acct: ::c_long = 89;\npub const SYS_capget: ::c_long = 90;\npub const SYS_capset: ::c_long = 91;\npub const SYS_personality: ::c_long = 92;\npub const SYS_exit: ::c_long = 93;\npub const SYS_exit_group: ::c_long = 94;\npub const SYS_waitid: ::c_long = 95;\npub const SYS_set_tid_address: ::c_long = 96;\npub const SYS_unshare: ::c_long = 97;\npub const SYS_futex: ::c_long = 98;\npub const SYS_set_robust_list: ::c_long = 99;\npub const SYS_get_robust_list: ::c_long = 100;\npub const SYS_nanosleep: ::c_long = 101;\npub const SYS_getitimer: ::c_long = 102;\npub const SYS_setitimer: ::c_long = 103;\npub const SYS_kexec_load: ::c_long = 104;\npub const SYS_init_module: ::c_long = 105;\npub const SYS_delete_module: ::c_long = 106;\npub const SYS_timer_create: ::c_long = 107;\npub const SYS_timer_gettime: ::c_long = 108;\npub const SYS_timer_getoverrun: ::c_long = 109;\npub const SYS_timer_settime: ::c_long = 110;\npub const SYS_timer_delete: ::c_long = 111;\npub const SYS_clock_settime: ::c_long = 112;\npub const SYS_clock_gettime: ::c_long = 113;\npub const SYS_clock_getres: ::c_long = 114;\npub const SYS_clock_nanosleep: ::c_long = 115;\npub const SYS_syslog: ::c_long = 116;\npub const SYS_ptrace: ::c_long = 117;\npub const SYS_sched_setparam: ::c_long = 118;\npub const SYS_sched_setscheduler: ::c_long = 119;\npub const SYS_sched_getscheduler: ::c_long = 120;\npub const SYS_sched_getparam: ::c_long = 121;\npub const SYS_sched_setaffinity: ::c_long = 122;\npub const SYS_sched_getaffinity: ::c_long = 123;\npub const SYS_sched_yield: ::c_long = 124;\npub const SYS_sched_get_priority_max: ::c_long = 125;\npub const SYS_sched_get_priority_min: ::c_long = 126;\npub const SYS_sched_rr_get_interval: ::c_long = 127;\npub const SYS_restart_syscall: ::c_long = 128;\npub const SYS_kill: ::c_long = 129;\npub const SYS_tkill: ::c_long = 130;\npub const SYS_tgkill: ::c_long = 131;\npub const SYS_sigaltstack: ::c_long = 132;\npub const SYS_rt_sigsuspend: ::c_long = 133;\npub const SYS_rt_sigaction: ::c_long = 134;\npub const SYS_rt_sigprocmask: ::c_long = 135;\npub const SYS_rt_sigpending: ::c_long = 136;\npub const SYS_rt_sigtimedwait: ::c_long = 137;\npub const SYS_rt_sigqueueinfo: ::c_long = 138;\npub const SYS_rt_sigreturn: ::c_long = 139;\npub const SYS_setpriority: ::c_long = 140;\npub const SYS_getpriority: ::c_long = 141;\npub const SYS_reboot: ::c_long = 142;\npub const SYS_setregid: ::c_long = 143;\npub const SYS_setgid: ::c_long = 144;\npub const SYS_setreuid: ::c_long = 145;\npub const SYS_setuid: ::c_long = 146;\npub const SYS_setresuid: ::c_long = 147;\npub const SYS_getresuid: ::c_long = 148;\npub const SYS_setresgid: ::c_long = 149;\npub const SYS_getresgid: ::c_long = 150;\npub const SYS_setfsuid: ::c_long = 151;\npub const SYS_setfsgid: ::c_long = 152;\npub const SYS_times: ::c_long = 153;\npub const SYS_setpgid: ::c_long = 154;\npub const SYS_getpgid: ::c_long = 155;\npub const SYS_getsid: ::c_long = 156;\npub const SYS_setsid: ::c_long = 157;\npub const SYS_getgroups: ::c_long = 158;\npub const SYS_setgroups: ::c_long = 159;\npub const SYS_uname: ::c_long = 160;\npub const SYS_sethostname: ::c_long = 161;\npub const SYS_setdomainname: ::c_long = 162;\npub const SYS_getrlimit: ::c_long = 163;\npub const SYS_setrlimit: ::c_long = 164;\npub const SYS_getrusage: ::c_long = 165;\npub const SYS_umask: ::c_long = 166;\npub const SYS_prctl: ::c_long = 167;\npub const SYS_getcpu: ::c_long = 168;\npub const SYS_gettimeofday: ::c_long = 169;\npub const SYS_settimeofday: ::c_long = 170;\npub const SYS_adjtimex: ::c_long = 171;\npub const SYS_getpid: ::c_long = 172;\npub const SYS_getppid: ::c_long = 173;\npub const SYS_getuid: ::c_long = 174;\npub const SYS_geteuid: ::c_long = 175;\npub const SYS_getgid: ::c_long = 176;\npub const SYS_getegid: ::c_long = 177;\npub const SYS_gettid: ::c_long = 178;\npub const SYS_sysinfo: ::c_long = 179;\npub const SYS_mq_open: ::c_long = 180;\npub const SYS_mq_unlink: ::c_long = 181;\npub const SYS_mq_timedsend: ::c_long = 182;\npub const SYS_mq_timedreceive: ::c_long = 183;\npub const SYS_mq_notify: ::c_long = 184;\npub const SYS_mq_getsetattr: ::c_long = 185;\npub const SYS_msgget: ::c_long = 186;\npub const SYS_msgctl: ::c_long = 187;\npub const SYS_msgrcv: ::c_long = 188;\npub const SYS_msgsnd: ::c_long = 189;\npub const SYS_semget: ::c_long = 190;\npub const SYS_semctl: ::c_long = 191;\npub const SYS_semtimedop: ::c_long = 192;\npub const SYS_semop: ::c_long = 193;\npub const SYS_shmget: ::c_long = 194;\npub const SYS_shmctl: ::c_long = 195;\npub const SYS_shmat: ::c_long = 196;\npub const SYS_shmdt: ::c_long = 197;\npub const SYS_socket: ::c_long = 198;\npub const SYS_socketpair: ::c_long = 199;\npub const SYS_bind: ::c_long = 200;\npub const SYS_listen: ::c_long = 201;\npub const SYS_accept: ::c_long = 202;\npub const SYS_connect: ::c_long = 203;\npub const SYS_getsockname: ::c_long = 204;\npub const SYS_getpeername: ::c_long = 205;\npub const SYS_sendto: ::c_long = 206;\npub const SYS_recvfrom: ::c_long = 207;\npub const SYS_setsockopt: ::c_long = 208;\npub const SYS_getsockopt: ::c_long = 209;\npub const SYS_shutdown: ::c_long = 210;\npub const SYS_sendmsg: ::c_long = 211;\npub const SYS_recvmsg: ::c_long = 212;\npub const SYS_readahead: ::c_long = 213;\npub const SYS_brk: ::c_long = 214;\npub const SYS_munmap: ::c_long = 215;\npub const SYS_mremap: ::c_long = 216;\npub const SYS_add_key: ::c_long = 217;\npub const SYS_request_key: ::c_long = 218;\npub const SYS_keyctl: ::c_long = 219;\npub const SYS_clone: ::c_long = 220;\npub const SYS_execve: ::c_long = 221;\npub const SYS_swapon: ::c_long = 224;\npub const SYS_swapoff: ::c_long = 225;\npub const SYS_mprotect: ::c_long = 226;\npub const SYS_msync: ::c_long = 227;\npub const SYS_mlock: ::c_long = 228;\npub const SYS_munlock: ::c_long = 229;\npub const SYS_mlockall: ::c_long = 230;\npub const SYS_munlockall: ::c_long = 231;\npub const SYS_mincore: ::c_long = 232;\npub const SYS_madvise: ::c_long = 233;\npub const SYS_remap_file_pages: ::c_long = 234;\npub const SYS_mbind: ::c_long = 235;\npub const SYS_get_mempolicy: ::c_long = 236;\npub const SYS_set_mempolicy: ::c_long = 237;\npub const SYS_migrate_pages: ::c_long = 238;\npub const SYS_move_pages: ::c_long = 239;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 240;\npub const SYS_perf_event_open: ::c_long = 241;\npub const SYS_accept4: ::c_long = 242;\npub const SYS_recvmmsg: ::c_long = 243;\npub const SYS_arch_specific_syscall: ::c_long = 244;\npub const SYS_wait4: ::c_long = 260;\npub const SYS_prlimit64: ::c_long = 261;\npub const SYS_fanotify_init: ::c_long = 262;\npub const SYS_fanotify_mark: ::c_long = 263;\npub const SYS_name_to_handle_at: ::c_long = 264;\npub const SYS_open_by_handle_at: ::c_long = 265;\npub const SYS_clock_adjtime: ::c_long = 266;\npub const SYS_syncfs: ::c_long = 267;\npub const SYS_setns: ::c_long = 268;\npub const SYS_sendmmsg: ::c_long = 269;\npub const SYS_process_vm_readv: ::c_long = 270;\npub const SYS_process_vm_writev: ::c_long = 271;\npub const SYS_kcmp: ::c_long = 272;\npub const SYS_finit_module: ::c_long = 273;\npub const SYS_sched_setattr: ::c_long = 274;\npub const SYS_sched_getattr: ::c_long = 275;\npub const SYS_renameat2: ::c_long = 276;\npub const SYS_seccomp: ::c_long = 277;\npub const SYS_getrandom: ::c_long = 278;\npub const SYS_memfd_create: ::c_long = 279;\npub const SYS_bpf: ::c_long = 280;\npub const SYS_execveat: ::c_long = 281;\npub const SYS_userfaultfd: ::c_long = 282;\npub const SYS_membarrier: ::c_long = 283;\npub const SYS_mlock2: ::c_long = 284;\npub const SYS_copy_file_range: ::c_long = 285;\npub const SYS_preadv2: ::c_long = 286;\npub const SYS_pwritev2: ::c_long = 287;\npub const SYS_pkey_mprotect: ::c_long = 288;\npub const SYS_pkey_alloc: ::c_long = 289;\npub const SYS_pkey_free: ::c_long = 290;\npub const SYS_syscalls: ::c_long = 436;\n\ncfg_if! {\n    if #[cfg(libc_align)] {\n        mod align;\n        pub use self::align::*;\n    }\n}\n"],["1148","s! {\n    // FIXME this is actually a union\n    #[cfg_attr(target_pointer_width = \"32\",\n               repr(align(4)))]\n    #[cfg_attr(target_pointer_width = \"64\",\n               repr(align(8)))]\n    pub struct sem_t {\n        #[cfg(target_pointer_width = \"32\")]\n        __size: [::c_char; 16],\n        #[cfg(target_pointer_width = \"64\")]\n        __size: [::c_char; 32],\n    }\n}\n"],["1149","s! {\n    // FIXME this is actually a union\n    pub struct sem_t {\n        #[cfg(target_pointer_width = \"32\")]\n        __size: [::c_char; 16],\n        #[cfg(target_pointer_width = \"64\")]\n        __size: [::c_char; 32],\n        __align: [::c_long; 0],\n    }\n}\n"],["1150","pub type c_char = i8;\npub type c_long = i32;\npub type c_ulong = u32;\npub type clock_t = i32;\npub type time_t = i32;\npub type suseconds_t = i32;\npub type wchar_t = i32;\npub type off_t = i32;\npub type ino_t = u32;\npub type blkcnt_t = i32;\npub type blksize_t = i32;\npub type nlink_t = u32;\npub type fsblkcnt_t = ::c_ulong;\npub type fsfilcnt_t = ::c_ulong;\npub type rlim_t = ::c_ulong;\npub type __u64 = ::c_ulonglong;\npub type fsblkcnt64_t = u64;\npub type fsfilcnt64_t = u64;\n\ns! {\n    pub struct stat {\n        pub st_dev: ::dev_t,\n        st_pad1: [::c_long; 2],\n        pub st_ino: ::ino_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        pub st_pad2: [::c_long; 1],\n        pub st_size: ::off_t,\n        st_pad3: ::c_long,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt_t,\n        st_pad5: [::c_long; 14],\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::dev_t,\n        st_pad1: [::c_long; 2],\n        pub st_ino: ::ino64_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        st_pad2: [::c_long; 2],\n        pub st_size: ::off64_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        pub st_blksize: ::blksize_t,\n        st_pad3: ::c_long,\n        pub st_blocks: ::blkcnt64_t,\n        st_pad5: [::c_long; 14],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt64_t,\n        pub f_bfree: ::fsblkcnt64_t,\n        pub f_bavail: ::fsblkcnt64_t,\n        pub f_files: ::fsfilcnt64_t,\n        pub f_ffree: ::fsfilcnt64_t,\n        pub f_favail: ::fsfilcnt64_t,\n        pub f_fsid: ::c_ulong,\n        pub __f_unused: ::c_int,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        pub __f_spare: [::c_int; 6],\n    }\n\n    pub struct pthread_attr_t {\n        __size: [u32; 9]\n    }\n\n    pub struct sigaction {\n        pub sa_flags: ::c_uint,\n        pub sa_sigaction: ::sighandler_t,\n        pub sa_mask: sigset_t,\n        _restorer: *mut ::c_void,\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_size: ::size_t,\n        pub ss_flags: ::c_int,\n    }\n\n    pub struct sigset_t {\n        __val: [::c_ulong; 4],\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_code: ::c_int,\n        pub si_errno: ::c_int,\n        pub _pad: [::c_int; 29],\n    }\n\n    pub struct glob64_t {\n        pub gl_pathc: ::size_t,\n        pub gl_pathv: *mut *mut ::c_char,\n        pub gl_offs: ::size_t,\n        pub gl_flags: ::c_int,\n\n        __unused1: *mut ::c_void,\n        __unused2: *mut ::c_void,\n        __unused3: *mut ::c_void,\n        __unused4: *mut ::c_void,\n        __unused5: *mut ::c_void,\n    }\n\n    pub struct ipc_perm {\n        pub __key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::c_uint,\n        pub __seq: ::c_ushort,\n        __pad1: ::c_ushort,\n        __unused1: ::c_ulong,\n        __unused2: ::c_ulong\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        pub shm_segsz: ::size_t,\n        pub shm_atime: ::time_t,\n        pub shm_dtime: ::time_t,\n        pub shm_ctime: ::time_t,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::shmatt_t,\n        __unused4: ::c_ulong,\n        __unused5: ::c_ulong\n    }\n\n    pub struct msqid_ds {\n        pub msg_perm: ::ipc_perm,\n        #[cfg(target_endian = \"big\")]\n        __glibc_reserved1: ::c_ulong,\n        pub msg_stime: ::time_t,\n        #[cfg(target_endian = \"little\")]\n        __glibc_reserved1: ::c_ulong,\n        #[cfg(target_endian = \"big\")]\n        __glibc_reserved2: ::c_ulong,\n        pub msg_rtime: ::time_t,\n        #[cfg(target_endian = \"little\")]\n        __glibc_reserved2: ::c_ulong,\n        #[cfg(target_endian = \"big\")]\n        __glibc_reserved3: ::c_ulong,\n        pub msg_ctime: ::time_t,\n        #[cfg(target_endian = \"little\")]\n        __glibc_reserved3: ::c_ulong,\n        __msg_cbytes: ::c_ulong,\n        pub msg_qnum: ::msgqnum_t,\n        pub msg_qbytes: ::msglen_t,\n        pub msg_lspid: ::pid_t,\n        pub msg_lrpid: ::pid_t,\n        __glibc_reserved4: ::c_ulong,\n        __glibc_reserved5: ::c_ulong,\n    }\n\n    pub struct statfs {\n        pub f_type: ::c_long,\n        pub f_bsize: ::c_long,\n        pub f_frsize: ::c_long,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_files: ::fsblkcnt_t,\n        pub f_ffree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_fsid: ::fsid_t,\n\n        pub f_namelen: ::c_long,\n        f_spare: [::c_long; 6],\n    }\n\n    pub struct statfs64 {\n        pub f_type: ::c_long,\n        pub f_bsize: ::c_long,\n        pub f_frsize: ::c_long,\n        pub f_blocks: ::fsblkcnt64_t,\n        pub f_bfree: ::fsblkcnt64_t,\n        pub f_files: ::fsblkcnt64_t,\n        pub f_ffree: ::fsblkcnt64_t,\n        pub f_bavail: ::fsblkcnt64_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_long,\n        pub f_flags: ::c_long,\n        pub f_spare: [::c_long; 5],\n    }\n\n    pub struct msghdr {\n        pub msg_name: *mut ::c_void,\n        pub msg_namelen: ::socklen_t,\n        pub msg_iov: *mut ::iovec,\n        pub msg_iovlen: ::c_int,\n        pub msg_control: *mut ::c_void,\n        pub msg_controllen: ::size_t,\n        pub msg_flags: ::c_int,\n    }\n\n    pub struct cmsghdr {\n        pub cmsg_len: ::size_t,\n        pub cmsg_level: ::c_int,\n        pub cmsg_type: ::c_int,\n    }\n\n    pub struct termios {\n        pub c_iflag: ::tcflag_t,\n        pub c_oflag: ::tcflag_t,\n        pub c_cflag: ::tcflag_t,\n        pub c_lflag: ::tcflag_t,\n        pub c_line: ::cc_t,\n        pub c_cc: [::cc_t; ::NCCS],\n    }\n\n    pub struct flock {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off_t,\n        pub l_len: ::off_t,\n        pub l_sysid: ::c_long,\n        pub l_pid: ::pid_t,\n        pad: [::c_long; 4],\n    }\n\n    pub struct sysinfo {\n        pub uptime: ::c_long,\n        pub loads: [::c_ulong; 3],\n        pub totalram: ::c_ulong,\n        pub freeram: ::c_ulong,\n        pub sharedram: ::c_ulong,\n        pub bufferram: ::c_ulong,\n        pub totalswap: ::c_ulong,\n        pub freeswap: ::c_ulong,\n        pub procs: ::c_ushort,\n        pub pad: ::c_ushort,\n        pub totalhigh: ::c_ulong,\n        pub freehigh: ::c_ulong,\n        pub mem_unit: ::c_uint,\n        pub _f: [::c_char; 8],\n    }\n}\n\npub const __SIZEOF_PTHREAD_ATTR_T: usize = 36;\npub const __SIZEOF_PTHREAD_MUTEX_T: usize = 24;\npub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;\npub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;\npub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 32;\npub const __SIZEOF_PTHREAD_RWLOCKATTR_T: usize = 8;\npub const __SIZEOF_PTHREAD_BARRIER_T: usize = 20;\npub const __SIZEOF_PTHREAD_BARRIERATTR_T: usize = 4;\n\npub const RLIM_INFINITY: ::rlim_t = 0x7fffffff;\n\npub const SYS_syscall: ::c_long = 4000 + 0;\npub const SYS_exit: ::c_long = 4000 + 1;\npub const SYS_fork: ::c_long = 4000 + 2;\npub const SYS_read: ::c_long = 4000 + 3;\npub const SYS_write: ::c_long = 4000 + 4;\npub const SYS_open: ::c_long = 4000 + 5;\npub const SYS_close: ::c_long = 4000 + 6;\npub const SYS_waitpid: ::c_long = 4000 + 7;\npub const SYS_creat: ::c_long = 4000 + 8;\npub const SYS_link: ::c_long = 4000 + 9;\npub const SYS_unlink: ::c_long = 4000 + 10;\npub const SYS_execve: ::c_long = 4000 + 11;\npub const SYS_chdir: ::c_long = 4000 + 12;\npub const SYS_time: ::c_long = 4000 + 13;\npub const SYS_mknod: ::c_long = 4000 + 14;\npub const SYS_chmod: ::c_long = 4000 + 15;\npub const SYS_lchown: ::c_long = 4000 + 16;\npub const SYS_break: ::c_long = 4000 + 17;\npub const SYS_lseek: ::c_long = 4000 + 19;\npub const SYS_getpid: ::c_long = 4000 + 20;\npub const SYS_mount: ::c_long = 4000 + 21;\npub const SYS_umount: ::c_long = 4000 + 22;\npub const SYS_setuid: ::c_long = 4000 + 23;\npub const SYS_getuid: ::c_long = 4000 + 24;\npub const SYS_stime: ::c_long = 4000 + 25;\npub const SYS_ptrace: ::c_long = 4000 + 26;\npub const SYS_alarm: ::c_long = 4000 + 27;\npub const SYS_pause: ::c_long = 4000 + 29;\npub const SYS_utime: ::c_long = 4000 + 30;\npub const SYS_stty: ::c_long = 4000 + 31;\npub const SYS_gtty: ::c_long = 4000 + 32;\npub const SYS_access: ::c_long = 4000 + 33;\npub const SYS_nice: ::c_long = 4000 + 34;\npub const SYS_ftime: ::c_long = 4000 + 35;\npub const SYS_sync: ::c_long = 4000 + 36;\npub const SYS_kill: ::c_long = 4000 + 37;\npub const SYS_rename: ::c_long = 4000 + 38;\npub const SYS_mkdir: ::c_long = 4000 + 39;\npub const SYS_rmdir: ::c_long = 4000 + 40;\npub const SYS_dup: ::c_long = 4000 + 41;\npub const SYS_pipe: ::c_long = 4000 + 42;\npub const SYS_times: ::c_long = 4000 + 43;\npub const SYS_prof: ::c_long = 4000 + 44;\npub const SYS_brk: ::c_long = 4000 + 45;\npub const SYS_setgid: ::c_long = 4000 + 46;\npub const SYS_getgid: ::c_long = 4000 + 47;\npub const SYS_signal: ::c_long = 4000 + 48;\npub const SYS_geteuid: ::c_long = 4000 + 49;\npub const SYS_getegid: ::c_long = 4000 + 50;\npub const SYS_acct: ::c_long = 4000 + 51;\npub const SYS_umount2: ::c_long = 4000 + 52;\npub const SYS_lock: ::c_long = 4000 + 53;\npub const SYS_ioctl: ::c_long = 4000 + 54;\npub const SYS_fcntl: ::c_long = 4000 + 55;\npub const SYS_mpx: ::c_long = 4000 + 56;\npub const SYS_setpgid: ::c_long = 4000 + 57;\npub const SYS_ulimit: ::c_long = 4000 + 58;\npub const SYS_umask: ::c_long = 4000 + 60;\npub const SYS_chroot: ::c_long = 4000 + 61;\npub const SYS_ustat: ::c_long = 4000 + 62;\npub const SYS_dup2: ::c_long = 4000 + 63;\npub const SYS_getppid: ::c_long = 4000 + 64;\npub const SYS_getpgrp: ::c_long = 4000 + 65;\npub const SYS_setsid: ::c_long = 4000 + 66;\npub const SYS_sigaction: ::c_long = 4000 + 67;\npub const SYS_sgetmask: ::c_long = 4000 + 68;\npub const SYS_ssetmask: ::c_long = 4000 + 69;\npub const SYS_setreuid: ::c_long = 4000 + 70;\npub const SYS_setregid: ::c_long = 4000 + 71;\npub const SYS_sigsuspend: ::c_long = 4000 + 72;\npub const SYS_sigpending: ::c_long = 4000 + 73;\npub const SYS_sethostname: ::c_long = 4000 + 74;\npub const SYS_setrlimit: ::c_long = 4000 + 75;\npub const SYS_getrlimit: ::c_long = 4000 + 76;\npub const SYS_getrusage: ::c_long = 4000 + 77;\npub const SYS_gettimeofday: ::c_long = 4000 + 78;\npub const SYS_settimeofday: ::c_long = 4000 + 79;\npub const SYS_getgroups: ::c_long = 4000 + 80;\npub const SYS_setgroups: ::c_long = 4000 + 81;\npub const SYS_symlink: ::c_long = 4000 + 83;\npub const SYS_readlink: ::c_long = 4000 + 85;\npub const SYS_uselib: ::c_long = 4000 + 86;\npub const SYS_swapon: ::c_long = 4000 + 87;\npub const SYS_reboot: ::c_long = 4000 + 88;\npub const SYS_readdir: ::c_long = 4000 + 89;\npub const SYS_mmap: ::c_long = 4000 + 90;\npub const SYS_munmap: ::c_long = 4000 + 91;\npub const SYS_truncate: ::c_long = 4000 + 92;\npub const SYS_ftruncate: ::c_long = 4000 + 93;\npub const SYS_fchmod: ::c_long = 4000 + 94;\npub const SYS_fchown: ::c_long = 4000 + 95;\npub const SYS_getpriority: ::c_long = 4000 + 96;\npub const SYS_setpriority: ::c_long = 4000 + 97;\npub const SYS_profil: ::c_long = 4000 + 98;\npub const SYS_statfs: ::c_long = 4000 + 99;\npub const SYS_fstatfs: ::c_long = 4000 + 100;\npub const SYS_ioperm: ::c_long = 4000 + 101;\npub const SYS_socketcall: ::c_long = 4000 + 102;\npub const SYS_syslog: ::c_long = 4000 + 103;\npub const SYS_setitimer: ::c_long = 4000 + 104;\npub const SYS_getitimer: ::c_long = 4000 + 105;\npub const SYS_stat: ::c_long = 4000 + 106;\npub const SYS_lstat: ::c_long = 4000 + 107;\npub const SYS_fstat: ::c_long = 4000 + 108;\npub const SYS_iopl: ::c_long = 4000 + 110;\npub const SYS_vhangup: ::c_long = 4000 + 111;\npub const SYS_idle: ::c_long = 4000 + 112;\npub const SYS_vm86: ::c_long = 4000 + 113;\npub const SYS_wait4: ::c_long = 4000 + 114;\npub const SYS_swapoff: ::c_long = 4000 + 115;\npub const SYS_sysinfo: ::c_long = 4000 + 116;\npub const SYS_ipc: ::c_long = 4000 + 117;\npub const SYS_fsync: ::c_long = 4000 + 118;\npub const SYS_sigreturn: ::c_long = 4000 + 119;\npub const SYS_clone: ::c_long = 4000 + 120;\npub const SYS_setdomainname: ::c_long = 4000 + 121;\npub const SYS_uname: ::c_long = 4000 + 122;\npub const SYS_modify_ldt: ::c_long = 4000 + 123;\npub const SYS_adjtimex: ::c_long = 4000 + 124;\npub const SYS_mprotect: ::c_long = 4000 + 125;\npub const SYS_sigprocmask: ::c_long = 4000 + 126;\npub const SYS_create_module: ::c_long = 4000 + 127;\npub const SYS_init_module: ::c_long = 4000 + 128;\npub const SYS_delete_module: ::c_long = 4000 + 129;\npub const SYS_get_kernel_syms: ::c_long = 4000 + 130;\npub const SYS_quotactl: ::c_long = 4000 + 131;\npub const SYS_getpgid: ::c_long = 4000 + 132;\npub const SYS_fchdir: ::c_long = 4000 + 133;\npub const SYS_bdflush: ::c_long = 4000 + 134;\npub const SYS_sysfs: ::c_long = 4000 + 135;\npub const SYS_personality: ::c_long = 4000 + 136;\npub const SYS_afs_syscall: ::c_long = 4000 + 137;\npub const SYS_setfsuid: ::c_long = 4000 + 138;\npub const SYS_setfsgid: ::c_long = 4000 + 139;\npub const SYS__llseek: ::c_long = 4000 + 140;\npub const SYS_getdents: ::c_long = 4000 + 141;\npub const SYS__newselect: ::c_long = 4000 + 142;\npub const SYS_flock: ::c_long = 4000 + 143;\npub const SYS_msync: ::c_long = 4000 + 144;\npub const SYS_readv: ::c_long = 4000 + 145;\npub const SYS_writev: ::c_long = 4000 + 146;\npub const SYS_cacheflush: ::c_long = 4000 + 147;\npub const SYS_cachectl: ::c_long = 4000 + 148;\npub const SYS_sysmips: ::c_long = 4000 + 149;\npub const SYS_getsid: ::c_long = 4000 + 151;\npub const SYS_fdatasync: ::c_long = 4000 + 152;\npub const SYS__sysctl: ::c_long = 4000 + 153;\npub const SYS_mlock: ::c_long = 4000 + 154;\npub const SYS_munlock: ::c_long = 4000 + 155;\npub const SYS_mlockall: ::c_long = 4000 + 156;\npub const SYS_munlockall: ::c_long = 4000 + 157;\npub const SYS_sched_setparam: ::c_long = 4000 + 158;\npub const SYS_sched_getparam: ::c_long = 4000 + 159;\npub const SYS_sched_setscheduler: ::c_long = 4000 + 160;\npub const SYS_sched_getscheduler: ::c_long = 4000 + 161;\npub const SYS_sched_yield: ::c_long = 4000 + 162;\npub const SYS_sched_get_priority_max: ::c_long = 4000 + 163;\npub const SYS_sched_get_priority_min: ::c_long = 4000 + 164;\npub const SYS_sched_rr_get_interval: ::c_long = 4000 + 165;\npub const SYS_nanosleep: ::c_long = 4000 + 166;\npub const SYS_mremap: ::c_long = 4000 + 167;\npub const SYS_accept: ::c_long = 4000 + 168;\npub const SYS_bind: ::c_long = 4000 + 169;\npub const SYS_connect: ::c_long = 4000 + 170;\npub const SYS_getpeername: ::c_long = 4000 + 171;\npub const SYS_getsockname: ::c_long = 4000 + 172;\npub const SYS_getsockopt: ::c_long = 4000 + 173;\npub const SYS_listen: ::c_long = 4000 + 174;\npub const SYS_recv: ::c_long = 4000 + 175;\npub const SYS_recvfrom: ::c_long = 4000 + 176;\npub const SYS_recvmsg: ::c_long = 4000 + 177;\npub const SYS_send: ::c_long = 4000 + 178;\npub const SYS_sendmsg: ::c_long = 4000 + 179;\npub const SYS_sendto: ::c_long = 4000 + 180;\npub const SYS_setsockopt: ::c_long = 4000 + 181;\npub const SYS_shutdown: ::c_long = 4000 + 182;\npub const SYS_socket: ::c_long = 4000 + 183;\npub const SYS_socketpair: ::c_long = 4000 + 184;\npub const SYS_setresuid: ::c_long = 4000 + 185;\npub const SYS_getresuid: ::c_long = 4000 + 186;\npub const SYS_query_module: ::c_long = 4000 + 187;\npub const SYS_poll: ::c_long = 4000 + 188;\npub const SYS_nfsservctl: ::c_long = 4000 + 189;\npub const SYS_setresgid: ::c_long = 4000 + 190;\npub const SYS_getresgid: ::c_long = 4000 + 191;\npub const SYS_prctl: ::c_long = 4000 + 192;\npub const SYS_rt_sigreturn: ::c_long = 4000 + 193;\npub const SYS_rt_sigaction: ::c_long = 4000 + 194;\npub const SYS_rt_sigprocmask: ::c_long = 4000 + 195;\npub const SYS_rt_sigpending: ::c_long = 4000 + 196;\npub const SYS_rt_sigtimedwait: ::c_long = 4000 + 197;\npub const SYS_rt_sigqueueinfo: ::c_long = 4000 + 198;\npub const SYS_rt_sigsuspend: ::c_long = 4000 + 199;\npub const SYS_pread64: ::c_long = 4000 + 200;\npub const SYS_pwrite64: ::c_long = 4000 + 201;\npub const SYS_chown: ::c_long = 4000 + 202;\npub const SYS_getcwd: ::c_long = 4000 + 203;\npub const SYS_capget: ::c_long = 4000 + 204;\npub const SYS_capset: ::c_long = 4000 + 205;\npub const SYS_sigaltstack: ::c_long = 4000 + 206;\npub const SYS_sendfile: ::c_long = 4000 + 207;\npub const SYS_getpmsg: ::c_long = 4000 + 208;\npub const SYS_putpmsg: ::c_long = 4000 + 209;\npub const SYS_mmap2: ::c_long = 4000 + 210;\npub const SYS_truncate64: ::c_long = 4000 + 211;\npub const SYS_ftruncate64: ::c_long = 4000 + 212;\npub const SYS_stat64: ::c_long = 4000 + 213;\npub const SYS_lstat64: ::c_long = 4000 + 214;\npub const SYS_fstat64: ::c_long = 4000 + 215;\npub const SYS_pivot_root: ::c_long = 4000 + 216;\npub const SYS_mincore: ::c_long = 4000 + 217;\npub const SYS_madvise: ::c_long = 4000 + 218;\npub const SYS_getdents64: ::c_long = 4000 + 219;\npub const SYS_fcntl64: ::c_long = 4000 + 220;\npub const SYS_gettid: ::c_long = 4000 + 222;\npub const SYS_readahead: ::c_long = 4000 + 223;\npub const SYS_setxattr: ::c_long = 4000 + 224;\npub const SYS_lsetxattr: ::c_long = 4000 + 225;\npub const SYS_fsetxattr: ::c_long = 4000 + 226;\npub const SYS_getxattr: ::c_long = 4000 + 227;\npub const SYS_lgetxattr: ::c_long = 4000 + 228;\npub const SYS_fgetxattr: ::c_long = 4000 + 229;\npub const SYS_listxattr: ::c_long = 4000 + 230;\npub const SYS_llistxattr: ::c_long = 4000 + 231;\npub const SYS_flistxattr: ::c_long = 4000 + 232;\npub const SYS_removexattr: ::c_long = 4000 + 233;\npub const SYS_lremovexattr: ::c_long = 4000 + 234;\npub const SYS_fremovexattr: ::c_long = 4000 + 235;\npub const SYS_tkill: ::c_long = 4000 + 236;\npub const SYS_sendfile64: ::c_long = 4000 + 237;\npub const SYS_futex: ::c_long = 4000 + 238;\npub const SYS_sched_setaffinity: ::c_long = 4000 + 239;\npub const SYS_sched_getaffinity: ::c_long = 4000 + 240;\npub const SYS_io_setup: ::c_long = 4000 + 241;\npub const SYS_io_destroy: ::c_long = 4000 + 242;\npub const SYS_io_getevents: ::c_long = 4000 + 243;\npub const SYS_io_submit: ::c_long = 4000 + 244;\npub const SYS_io_cancel: ::c_long = 4000 + 245;\npub const SYS_exit_group: ::c_long = 4000 + 246;\npub const SYS_lookup_dcookie: ::c_long = 4000 + 247;\npub const SYS_epoll_create: ::c_long = 4000 + 248;\npub const SYS_epoll_ctl: ::c_long = 4000 + 249;\npub const SYS_epoll_wait: ::c_long = 4000 + 250;\npub const SYS_remap_file_pages: ::c_long = 4000 + 251;\npub const SYS_set_tid_address: ::c_long = 4000 + 252;\npub const SYS_restart_syscall: ::c_long = 4000 + 253;\npub const SYS_fadvise64: ::c_long = 4000 + 254;\npub const SYS_statfs64: ::c_long = 4000 + 255;\npub const SYS_fstatfs64: ::c_long = 4000 + 256;\npub const SYS_timer_create: ::c_long = 4000 + 257;\npub const SYS_timer_settime: ::c_long = 4000 + 258;\npub const SYS_timer_gettime: ::c_long = 4000 + 259;\npub const SYS_timer_getoverrun: ::c_long = 4000 + 260;\npub const SYS_timer_delete: ::c_long = 4000 + 261;\npub const SYS_clock_settime: ::c_long = 4000 + 262;\npub const SYS_clock_gettime: ::c_long = 4000 + 263;\npub const SYS_clock_getres: ::c_long = 4000 + 264;\npub const SYS_clock_nanosleep: ::c_long = 4000 + 265;\npub const SYS_tgkill: ::c_long = 4000 + 266;\npub const SYS_utimes: ::c_long = 4000 + 267;\npub const SYS_mbind: ::c_long = 4000 + 268;\npub const SYS_get_mempolicy: ::c_long = 4000 + 269;\npub const SYS_set_mempolicy: ::c_long = 4000 + 270;\npub const SYS_mq_open: ::c_long = 4000 + 271;\npub const SYS_mq_unlink: ::c_long = 4000 + 272;\npub const SYS_mq_timedsend: ::c_long = 4000 + 273;\npub const SYS_mq_timedreceive: ::c_long = 4000 + 274;\npub const SYS_mq_notify: ::c_long = 4000 + 275;\npub const SYS_mq_getsetattr: ::c_long = 4000 + 276;\npub const SYS_vserver: ::c_long = 4000 + 277;\npub const SYS_waitid: ::c_long = 4000 + 278;\n/* pub const SYS_sys_setaltroot: ::c_long = 4000 + 279; */\npub const SYS_add_key: ::c_long = 4000 + 280;\npub const SYS_request_key: ::c_long = 4000 + 281;\npub const SYS_keyctl: ::c_long = 4000 + 282;\npub const SYS_set_thread_area: ::c_long = 4000 + 283;\npub const SYS_inotify_init: ::c_long = 4000 + 284;\npub const SYS_inotify_add_watch: ::c_long = 4000 + 285;\npub const SYS_inotify_rm_watch: ::c_long = 4000 + 286;\npub const SYS_migrate_pages: ::c_long = 4000 + 287;\npub const SYS_openat: ::c_long = 4000 + 288;\npub const SYS_mkdirat: ::c_long = 4000 + 289;\npub const SYS_mknodat: ::c_long = 4000 + 290;\npub const SYS_fchownat: ::c_long = 4000 + 291;\npub const SYS_futimesat: ::c_long = 4000 + 292;\npub const SYS_fstatat64: ::c_long = 4000 + 293;\npub const SYS_unlinkat: ::c_long = 4000 + 294;\npub const SYS_renameat: ::c_long = 4000 + 295;\npub const SYS_linkat: ::c_long = 4000 + 296;\npub const SYS_symlinkat: ::c_long = 4000 + 297;\npub const SYS_readlinkat: ::c_long = 4000 + 298;\npub const SYS_fchmodat: ::c_long = 4000 + 299;\npub const SYS_faccessat: ::c_long = 4000 + 300;\npub const SYS_pselect6: ::c_long = 4000 + 301;\npub const SYS_ppoll: ::c_long = 4000 + 302;\npub const SYS_unshare: ::c_long = 4000 + 303;\npub const SYS_splice: ::c_long = 4000 + 304;\npub const SYS_sync_file_range: ::c_long = 4000 + 305;\npub const SYS_tee: ::c_long = 4000 + 306;\npub const SYS_vmsplice: ::c_long = 4000 + 307;\npub const SYS_move_pages: ::c_long = 4000 + 308;\npub const SYS_set_robust_list: ::c_long = 4000 + 309;\npub const SYS_get_robust_list: ::c_long = 4000 + 310;\npub const SYS_kexec_load: ::c_long = 4000 + 311;\npub const SYS_getcpu: ::c_long = 4000 + 312;\npub const SYS_epoll_pwait: ::c_long = 4000 + 313;\npub const SYS_ioprio_set: ::c_long = 4000 + 314;\npub const SYS_ioprio_get: ::c_long = 4000 + 315;\npub const SYS_utimensat: ::c_long = 4000 + 316;\npub const SYS_signalfd: ::c_long = 4000 + 317;\npub const SYS_timerfd: ::c_long = 4000 + 318;\npub const SYS_eventfd: ::c_long = 4000 + 319;\npub const SYS_fallocate: ::c_long = 4000 + 320;\npub const SYS_timerfd_create: ::c_long = 4000 + 321;\npub const SYS_timerfd_gettime: ::c_long = 4000 + 322;\npub const SYS_timerfd_settime: ::c_long = 4000 + 323;\npub const SYS_signalfd4: ::c_long = 4000 + 324;\npub const SYS_eventfd2: ::c_long = 4000 + 325;\npub const SYS_epoll_create1: ::c_long = 4000 + 326;\npub const SYS_dup3: ::c_long = 4000 + 327;\npub const SYS_pipe2: ::c_long = 4000 + 328;\npub const SYS_inotify_init1: ::c_long = 4000 + 329;\npub const SYS_preadv: ::c_long = 4000 + 330;\npub const SYS_pwritev: ::c_long = 4000 + 331;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 4000 + 332;\npub const SYS_perf_event_open: ::c_long = 4000 + 333;\npub const SYS_accept4: ::c_long = 4000 + 334;\npub const SYS_recvmmsg: ::c_long = 4000 + 335;\npub const SYS_fanotify_init: ::c_long = 4000 + 336;\npub const SYS_fanotify_mark: ::c_long = 4000 + 337;\npub const SYS_prlimit64: ::c_long = 4000 + 338;\npub const SYS_name_to_handle_at: ::c_long = 4000 + 339;\npub const SYS_open_by_handle_at: ::c_long = 4000 + 340;\npub const SYS_clock_adjtime: ::c_long = 4000 + 341;\npub const SYS_syncfs: ::c_long = 4000 + 342;\npub const SYS_sendmmsg: ::c_long = 4000 + 343;\npub const SYS_setns: ::c_long = 4000 + 344;\npub const SYS_process_vm_readv: ::c_long = 4000 + 345;\npub const SYS_process_vm_writev: ::c_long = 4000 + 346;\npub const SYS_kcmp: ::c_long = 4000 + 347;\npub const SYS_finit_module: ::c_long = 4000 + 348;\npub const SYS_sched_setattr: ::c_long = 4000 + 349;\npub const SYS_sched_getattr: ::c_long = 4000 + 350;\npub const SYS_renameat2: ::c_long = 4000 + 351;\npub const SYS_seccomp: ::c_long = 4000 + 352;\npub const SYS_getrandom: ::c_long = 4000 + 353;\npub const SYS_memfd_create: ::c_long = 4000 + 354;\npub const SYS_bpf: ::c_long = 4000 + 355;\npub const SYS_execveat: ::c_long = 4000 + 356;\npub const SYS_userfaultfd: ::c_long = 4000 + 357;\npub const SYS_membarrier: ::c_long = 4000 + 358;\npub const SYS_mlock2: ::c_long = 4000 + 359;\npub const SYS_copy_file_range: ::c_long = 4000 + 360;\npub const SYS_preadv2: ::c_long = 4000 + 361;\npub const SYS_pwritev2: ::c_long = 4000 + 362;\npub const SYS_pkey_mprotect: ::c_long = 4000 + 363;\npub const SYS_pkey_alloc: ::c_long = 4000 + 364;\npub const SYS_pkey_free: ::c_long = 4000 + 365;\n\n#[link(name = \"util\")]\nextern \"C\" {\n    pub fn sysctl(\n        name: *mut ::c_int,\n        namelen: ::c_int,\n        oldp: *mut ::c_void,\n        oldlenp: *mut ::size_t,\n        newp: *mut ::c_void,\n        newlen: ::size_t,\n    ) -> ::c_int;\n    pub fn ioctl(fd: ::c_int, request: ::c_ulong, ...) -> ::c_int;\n    pub fn glob64(\n        pattern: *const ::c_char,\n        flags: ::c_int,\n        errfunc: ::Option<extern \"C\" fn(epath: *const ::c_char, errno: ::c_int) -> ::c_int>,\n        pglob: *mut glob64_t,\n    ) -> ::c_int;\n    pub fn globfree64(pglob: *mut glob64_t);\n    pub fn pthread_attr_getaffinity_np(\n        attr: *const ::pthread_attr_t,\n        cpusetsize: ::size_t,\n        cpuset: *mut ::cpu_set_t,\n    ) -> ::c_int;\n    pub fn pthread_attr_setaffinity_np(\n        attr: *mut ::pthread_attr_t,\n        cpusetsize: ::size_t,\n        cpuset: *const ::cpu_set_t,\n    ) -> ::c_int;\n}\n\ncfg_if! {\n    if #[cfg(libc_align)] {\n        mod align;\n        pub use self::align::*;\n    } else {\n        mod no_align;\n        pub use self::no_align::*;\n    }\n}\n"],["1151","s! {\n    // FIXME this is actually a union\n    #[cfg_attr(target_pointer_width = \"32\",\n               repr(align(4)))]\n    #[cfg_attr(target_pointer_width = \"64\",\n               repr(align(8)))]\n    pub struct sem_t {\n        __size: [::c_char; 32],\n    }\n}\n"],["1152","pub type blkcnt_t = i64;\npub type blksize_t = i64;\npub type c_char = i8;\npub type c_long = i64;\npub type c_ulong = u64;\npub type fsblkcnt_t = ::c_ulong;\npub type fsfilcnt_t = ::c_ulong;\npub type ino_t = u64;\npub type nlink_t = u64;\npub type off_t = i64;\npub type rlim_t = ::c_ulong;\npub type suseconds_t = i64;\npub type time_t = i64;\npub type wchar_t = i32;\n\ns! {\n    pub struct stat {\n        pub st_dev: ::c_ulong,\n        st_pad1: [::c_long; 2],\n        pub st_ino: ::ino_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::c_ulong,\n        st_pad2: [::c_ulong; 1],\n        pub st_size: ::off_t,\n        st_pad3: ::c_long,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        pub st_blksize: ::blksize_t,\n        st_pad4: ::c_long,\n        pub st_blocks: ::blkcnt_t,\n        st_pad5: [::c_long; 7],\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::c_ulong,\n        st_pad1: [::c_long; 2],\n        pub st_ino: ::ino64_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::c_ulong,\n        st_pad2: [::c_long; 2],\n        pub st_size: ::off64_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        pub st_blksize: ::blksize_t,\n        st_pad3: ::c_long,\n        pub st_blocks: ::blkcnt64_t,\n        st_pad5: [::c_long; 7],\n    }\n\n    pub struct pthread_attr_t {\n        __size: [::c_ulong; 7]\n    }\n\n    pub struct sigaction {\n        pub sa_flags: ::c_int,\n        pub sa_sigaction: ::sighandler_t,\n        pub sa_mask: sigset_t,\n        _restorer: *mut ::c_void,\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_size: ::size_t,\n        pub ss_flags: ::c_int,\n    }\n\n    pub struct sigset_t {\n        __size: [::c_ulong; 16],\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_code: ::c_int,\n        pub si_errno: ::c_int,\n        _pad: ::c_int,\n        _pad2: [::c_long; 14],\n    }\n\n    pub struct ipc_perm {\n        pub __key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::c_uint,\n        pub __seq: ::c_ushort,\n        __pad1: ::c_ushort,\n        __unused1: ::c_ulong,\n        __unused2: ::c_ulong\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        pub shm_segsz: ::size_t,\n        pub shm_atime: ::time_t,\n        pub shm_dtime: ::time_t,\n        pub shm_ctime: ::time_t,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::shmatt_t,\n        __unused4: ::c_ulong,\n        __unused5: ::c_ulong\n    }\n\n    pub struct msqid_ds {\n        pub msg_perm: ::ipc_perm,\n        pub msg_stime: ::time_t,\n        pub msg_rtime: ::time_t,\n        pub msg_ctime: ::time_t,\n        __msg_cbytes: ::c_ulong,\n        pub msg_qnum: ::msgqnum_t,\n        pub msg_qbytes: ::msglen_t,\n        pub msg_lspid: ::pid_t,\n        pub msg_lrpid: ::pid_t,\n        __glibc_reserved4: ::c_ulong,\n        __glibc_reserved5: ::c_ulong,\n    }\n\n    pub struct statfs {\n        pub f_type: ::c_long,\n        pub f_bsize: ::c_long,\n        pub f_frsize: ::c_long,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_files: ::fsblkcnt_t,\n        pub f_ffree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_fsid: ::fsid_t,\n\n        pub f_namelen: ::c_long,\n        f_spare: [::c_long; 6],\n    }\n\n    pub struct msghdr {\n        pub msg_name: *mut ::c_void,\n        pub msg_namelen: ::socklen_t,\n        pub msg_iov: *mut ::iovec,\n        pub msg_iovlen: ::size_t,\n        pub msg_control: *mut ::c_void,\n        pub msg_controllen: ::size_t,\n        pub msg_flags: ::c_int,\n    }\n\n    pub struct cmsghdr {\n        pub cmsg_len: ::size_t,\n        pub cmsg_level: ::c_int,\n        pub cmsg_type: ::c_int,\n    }\n\n    pub struct termios {\n        pub c_iflag: ::tcflag_t,\n        pub c_oflag: ::tcflag_t,\n        pub c_cflag: ::tcflag_t,\n        pub c_lflag: ::tcflag_t,\n        pub c_line: ::cc_t,\n        pub c_cc: [::cc_t; ::NCCS],\n    }\n\n    pub struct sysinfo {\n        pub uptime: ::c_long,\n        pub loads: [::c_ulong; 3],\n        pub totalram: ::c_ulong,\n        pub freeram: ::c_ulong,\n        pub sharedram: ::c_ulong,\n        pub bufferram: ::c_ulong,\n        pub totalswap: ::c_ulong,\n        pub freeswap: ::c_ulong,\n        pub procs: ::c_ushort,\n        pub pad: ::c_ushort,\n        pub totalhigh: ::c_ulong,\n        pub freehigh: ::c_ulong,\n        pub mem_unit: ::c_uint,\n        pub _f: [::c_char; 0],\n    }\n}\n\npub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;\npub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;\npub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;\npub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;\n\npub const RLIM_INFINITY: ::rlim_t = 0xffff_ffff_ffff_ffff;\n\npub const SYS_gettid: ::c_long = 5178; // Valid for n64\n\n#[link(name = \"util\")]\nextern \"C\" {\n    pub fn ioctl(fd: ::c_int, request: ::c_ulong, ...) -> ::c_int;\n}\n\ncfg_if! {\n    if #[cfg(libc_align)] {\n        mod align;\n        pub use self::align::*;\n    } else {\n        mod no_align;\n        pub use self::no_align::*;\n    }\n}\n"],["1153","s! {\n    // FIXME this is actually a union\n    pub struct sem_t {\n        __size: [::c_char; 32],\n        __align: [::c_long; 0],\n    }\n}\n"],["1154","pub type pthread_t = ::c_ulong;\n\npub const SFD_CLOEXEC: ::c_int = 0x080000;\n\npub const NCCS: usize = 32;\n\npub const O_TRUNC: ::c_int = 512;\n\npub const O_CLOEXEC: ::c_int = 0x80000;\n\npub const EBFONT: ::c_int = 59;\npub const ENOSTR: ::c_int = 60;\npub const ENODATA: ::c_int = 61;\npub const ETIME: ::c_int = 62;\npub const ENOSR: ::c_int = 63;\npub const ENONET: ::c_int = 64;\npub const ENOPKG: ::c_int = 65;\npub const EREMOTE: ::c_int = 66;\npub const ENOLINK: ::c_int = 67;\npub const EADV: ::c_int = 68;\npub const ESRMNT: ::c_int = 69;\npub const ECOMM: ::c_int = 70;\npub const EPROTO: ::c_int = 71;\npub const EDOTDOT: ::c_int = 73;\n\npub const SA_NODEFER: ::c_int = 0x40000000;\npub const SA_RESETHAND: ::c_int = 0x80000000;\npub const SA_RESTART: ::c_int = 0x10000000;\npub const SA_NOCLDSTOP: ::c_int = 0x00000001;\n\npub const EPOLL_CLOEXEC: ::c_int = 0x80000;\n\npub const EFD_CLOEXEC: ::c_int = 0x80000;\n\npub const BUFSIZ: ::c_uint = 4096;\npub const TMP_MAX: ::c_uint = 238328;\npub const FOPEN_MAX: ::c_uint = 16;\npub const POSIX_MADV_DONTNEED: ::c_int = 4;\npub const _SC_2_C_VERSION: ::c_int = 96;\npub const O_ACCMODE: ::c_int = 3;\npub const O_DIRECT: ::c_int = 0x8000;\npub const O_DIRECTORY: ::c_int = 0x10000;\npub const O_NOFOLLOW: ::c_int = 0x20000;\npub const NI_MAXHOST: ::socklen_t = 1025;\n\npub const RLIMIT_NOFILE: ::c_int = 5;\npub const RLIMIT_AS: ::c_int = 6;\npub const RLIMIT_RSS: ::c_int = 7;\npub const RLIMIT_NPROC: ::c_int = 8;\npub const RLIMIT_MEMLOCK: ::c_int = 9;\npub const RLIMIT_NLIMITS: ::c_int = 15;\npub const RLIM_NLIMITS: ::c_int = RLIMIT_NLIMITS;\n\npub const O_APPEND: ::c_int = 8;\npub const O_CREAT: ::c_int = 256;\npub const O_EXCL: ::c_int = 1024;\npub const O_NOCTTY: ::c_int = 2048;\npub const O_NONBLOCK: ::c_int = 128;\npub const O_SYNC: ::c_int = 0x10;\npub const O_RSYNC: ::c_int = 0x10;\npub const O_DSYNC: ::c_int = 0x10;\npub const O_FSYNC: ::c_int = 0x10;\npub const O_ASYNC: ::c_int = 0x1000;\npub const O_NDELAY: ::c_int = 0x80;\n\npub const SOCK_NONBLOCK: ::c_int = 128;\n\npub const EDEADLK: ::c_int = 45;\npub const ENAMETOOLONG: ::c_int = 78;\npub const ENOLCK: ::c_int = 46;\npub const ENOSYS: ::c_int = 89;\npub const ENOTEMPTY: ::c_int = 93;\npub const ELOOP: ::c_int = 90;\npub const ENOMSG: ::c_int = 35;\npub const EIDRM: ::c_int = 36;\npub const ECHRNG: ::c_int = 37;\npub const EL2NSYNC: ::c_int = 38;\npub const EL3HLT: ::c_int = 39;\npub const EL3RST: ::c_int = 40;\npub const ELNRNG: ::c_int = 41;\npub const EUNATCH: ::c_int = 42;\npub const ENOCSI: ::c_int = 43;\npub const EL2HLT: ::c_int = 44;\npub const EBADE: ::c_int = 50;\npub const EBADR: ::c_int = 51;\npub const EXFULL: ::c_int = 52;\npub const ENOANO: ::c_int = 53;\npub const EBADRQC: ::c_int = 54;\npub const EBADSLT: ::c_int = 55;\npub const EDEADLOCK: ::c_int = 56;\npub const EMULTIHOP: ::c_int = 74;\npub const EOVERFLOW: ::c_int = 79;\npub const ENOTUNIQ: ::c_int = 80;\npub const EBADFD: ::c_int = 81;\npub const EBADMSG: ::c_int = 77;\npub const EREMCHG: ::c_int = 82;\npub const ELIBACC: ::c_int = 83;\npub const ELIBBAD: ::c_int = 84;\npub const ELIBSCN: ::c_int = 85;\npub const ELIBMAX: ::c_int = 86;\npub const ELIBEXEC: ::c_int = 87;\npub const EILSEQ: ::c_int = 88;\npub const ERESTART: ::c_int = 91;\npub const ESTRPIPE: ::c_int = 92;\npub const EUSERS: ::c_int = 94;\npub const ENOTSOCK: ::c_int = 95;\npub const EDESTADDRREQ: ::c_int = 96;\npub const EMSGSIZE: ::c_int = 97;\npub const EPROTOTYPE: ::c_int = 98;\npub const ENOPROTOOPT: ::c_int = 99;\npub const EPROTONOSUPPORT: ::c_int = 120;\npub const ESOCKTNOSUPPORT: ::c_int = 121;\npub const EOPNOTSUPP: ::c_int = 122;\npub const EPFNOSUPPORT: ::c_int = 123;\npub const EAFNOSUPPORT: ::c_int = 124;\npub const EADDRINUSE: ::c_int = 125;\npub const EADDRNOTAVAIL: ::c_int = 126;\npub const ENETDOWN: ::c_int = 127;\npub const ENETUNREACH: ::c_int = 128;\npub const ENETRESET: ::c_int = 129;\npub const ECONNABORTED: ::c_int = 130;\npub const ECONNRESET: ::c_int = 131;\npub const ENOBUFS: ::c_int = 132;\npub const EISCONN: ::c_int = 133;\npub const ENOTCONN: ::c_int = 134;\npub const ESHUTDOWN: ::c_int = 143;\npub const ETOOMANYREFS: ::c_int = 144;\npub const ETIMEDOUT: ::c_int = 145;\npub const ECONNREFUSED: ::c_int = 146;\npub const EHOSTDOWN: ::c_int = 147;\npub const EHOSTUNREACH: ::c_int = 148;\npub const EALREADY: ::c_int = 149;\npub const EINPROGRESS: ::c_int = 150;\npub const ESTALE: ::c_int = 151;\npub const EUCLEAN: ::c_int = 135;\npub const ENOTNAM: ::c_int = 137;\npub const ENAVAIL: ::c_int = 138;\npub const EISNAM: ::c_int = 139;\npub const EREMOTEIO: ::c_int = 140;\npub const EDQUOT: ::c_int = 1133;\npub const ENOMEDIUM: ::c_int = 159;\npub const EMEDIUMTYPE: ::c_int = 160;\npub const ECANCELED: ::c_int = 158;\npub const ENOKEY: ::c_int = 161;\npub const EKEYEXPIRED: ::c_int = 162;\npub const EKEYREVOKED: ::c_int = 163;\npub const EKEYREJECTED: ::c_int = 164;\npub const EOWNERDEAD: ::c_int = 165;\npub const ENOTRECOVERABLE: ::c_int = 166;\npub const ERFKILL: ::c_int = 167;\n\npub const MAP_NORESERVE: ::c_int = 0x400;\npub const MAP_ANON: ::c_int = 0x800;\npub const MAP_ANONYMOUS: ::c_int = 0x800;\npub const MAP_GROWSDOWN: ::c_int = 0x1000;\npub const MAP_DENYWRITE: ::c_int = 0x2000;\npub const MAP_EXECUTABLE: ::c_int = 0x4000;\npub const MAP_LOCKED: ::c_int = 0x8000;\npub const MAP_POPULATE: ::c_int = 0x10000;\npub const MAP_NONBLOCK: ::c_int = 0x20000;\npub const MAP_STACK: ::c_int = 0x40000;\n\npub const SOCK_STREAM: ::c_int = 2;\npub const SOCK_DGRAM: ::c_int = 1;\npub const SOCK_SEQPACKET: ::c_int = 5;\n\npub const FIOCLEX: ::c_ulong = 0x6601;\npub const FIONCLEX: ::c_ulong = 0x6602;\npub const FIONBIO: ::c_ulong = 0x667e;\n\npub const SA_ONSTACK: ::c_uint = 0x08000000;\npub const SA_SIGINFO: ::c_uint = 0x00000008;\npub const SA_NOCLDWAIT: ::c_int = 0x00010000;\n\npub const SIGCHLD: ::c_int = 18;\npub const SIGBUS: ::c_int = 10;\npub const SIGTTIN: ::c_int = 26;\npub const SIGTTOU: ::c_int = 27;\npub const SIGXCPU: ::c_int = 30;\npub const SIGXFSZ: ::c_int = 31;\npub const SIGVTALRM: ::c_int = 28;\npub const SIGPROF: ::c_int = 29;\npub const SIGWINCH: ::c_int = 20;\npub const SIGUSR1: ::c_int = 16;\npub const SIGUSR2: ::c_int = 17;\npub const SIGCONT: ::c_int = 25;\npub const SIGSTOP: ::c_int = 23;\npub const SIGTSTP: ::c_int = 24;\npub const SIGURG: ::c_int = 21;\npub const SIGIO: ::c_int = 22;\npub const SIGSYS: ::c_int = 12;\npub const SIGPOLL: ::c_int = 22;\npub const SIGPWR: ::c_int = 19;\npub const SIG_SETMASK: ::c_int = 3;\npub const SIG_BLOCK: ::c_int = 0x1;\npub const SIG_UNBLOCK: ::c_int = 0x2;\n\npub const POLLWRNORM: ::c_short = 0x004;\npub const POLLWRBAND: ::c_short = 0x100;\n\npub const PTHREAD_STACK_MIN: ::size_t = 16384;\n\npub const VEOF: usize = 16;\npub const VEOL: usize = 17;\npub const VEOL2: usize = 6;\npub const VMIN: usize = 4;\npub const IEXTEN: ::tcflag_t = 0x00000100;\npub const TOSTOP: ::tcflag_t = 0x00008000;\npub const FLUSHO: ::tcflag_t = 0x00002000;\npub const TCSANOW: ::c_int = 0x540e;\npub const TCSADRAIN: ::c_int = 0x540f;\npub const TCSAFLUSH: ::c_int = 0x5410;\n\npub const CPU_SETSIZE: ::c_int = 0x400;\n\npub const EFD_NONBLOCK: ::c_int = 0x80;\n\npub const F_GETLK: ::c_int = 14;\npub const F_GETOWN: ::c_int = 23;\npub const F_SETOWN: ::c_int = 24;\npub const F_SETLK: ::c_int = 6;\npub const F_SETLKW: ::c_int = 7;\n\npub const SFD_NONBLOCK: ::c_int = 0x80;\n\npub const TCGETS: ::c_ulong = 0x540d;\npub const TCSETS: ::c_ulong = 0x540e;\npub const TCSETSW: ::c_ulong = 0x540f;\npub const TCSETSF: ::c_ulong = 0x5410;\npub const TCGETA: ::c_ulong = 0x5401;\npub const TCSETA: ::c_ulong = 0x5402;\npub const TCSETAW: ::c_ulong = 0x5403;\npub const TCSETAF: ::c_ulong = 0x5404;\npub const TCSBRK: ::c_ulong = 0x5405;\npub const TCXONC: ::c_ulong = 0x5406;\npub const TCFLSH: ::c_ulong = 0x5407;\npub const TIOCGSOFTCAR: ::c_ulong = 0x5481;\npub const TIOCSSOFTCAR: ::c_ulong = 0x5482;\npub const TIOCINQ: ::c_ulong = 0x467f;\npub const TIOCLINUX: ::c_ulong = 0x5483;\npub const TIOCGSERIAL: ::c_ulong = 0x5484;\npub const TIOCEXCL: ::c_ulong = 0x740d;\npub const TIOCNXCL: ::c_ulong = 0x740e;\npub const TIOCSCTTY: ::c_ulong = 0x5480;\npub const TIOCGPGRP: ::c_ulong = 0x40047477;\npub const TIOCSPGRP: ::c_ulong = 0x80047476;\npub const TIOCOUTQ: ::c_ulong = 0x7472;\npub const TIOCSTI: ::c_ulong = 0x5472;\npub const TIOCGWINSZ: ::c_ulong = 0x40087468;\npub const TIOCSWINSZ: ::c_ulong = 0x80087467;\npub const TIOCMGET: ::c_ulong = 0x741d;\npub const TIOCMBIS: ::c_ulong = 0x741b;\npub const TIOCMBIC: ::c_ulong = 0x741c;\npub const TIOCMSET: ::c_ulong = 0x741a;\npub const FIONREAD: ::c_ulong = 0x467f;\npub const TIOCCONS: ::c_ulong = 0x80047478;\n\npub const RTLD_GLOBAL: ::c_int = 0x4;\npub const RTLD_NOLOAD: ::c_int = 0x8;\n\npub const SIGSTKSZ: ::size_t = 8192;\npub const CBAUD: ::tcflag_t = 0o0010017;\npub const TAB1: ::tcflag_t = 0x00000800;\npub const TAB2: ::tcflag_t = 0x00001000;\npub const TAB3: ::tcflag_t = 0x00001800;\npub const CR1: ::tcflag_t = 0x00000200;\npub const CR2: ::tcflag_t = 0x00000400;\npub const CR3: ::tcflag_t = 0x00000600;\npub const FF1: ::tcflag_t = 0x00008000;\npub const BS1: ::tcflag_t = 0x00002000;\npub const VT1: ::tcflag_t = 0x00004000;\npub const VWERASE: usize = 14;\npub const VREPRINT: usize = 12;\npub const VSUSP: usize = 10;\npub const VSTART: usize = 8;\npub const VSTOP: usize = 9;\npub const VDISCARD: usize = 13;\npub const VTIME: usize = 5;\npub const IXON: ::tcflag_t = 0x00000400;\npub const IXOFF: ::tcflag_t = 0x00001000;\npub const ONLCR: ::tcflag_t = 0x4;\npub const CSIZE: ::tcflag_t = 0x00000030;\npub const CS6: ::tcflag_t = 0x00000010;\npub const CS7: ::tcflag_t = 0x00000020;\npub const CS8: ::tcflag_t = 0x00000030;\npub const CSTOPB: ::tcflag_t = 0x00000040;\npub const CREAD: ::tcflag_t = 0x00000080;\npub const PARENB: ::tcflag_t = 0x00000100;\npub const PARODD: ::tcflag_t = 0x00000200;\npub const HUPCL: ::tcflag_t = 0x00000400;\npub const CLOCAL: ::tcflag_t = 0x00000800;\npub const ECHOKE: ::tcflag_t = 0x00000800;\npub const ECHOE: ::tcflag_t = 0x00000010;\npub const ECHOK: ::tcflag_t = 0x00000020;\npub const ECHONL: ::tcflag_t = 0x00000040;\npub const ECHOPRT: ::tcflag_t = 0x00000400;\npub const ECHOCTL: ::tcflag_t = 0x00000200;\npub const ISIG: ::tcflag_t = 0x00000001;\npub const ICANON: ::tcflag_t = 0x00000002;\npub const PENDIN: ::tcflag_t = 0x00004000;\npub const NOFLSH: ::tcflag_t = 0x00000080;\n\npub const B0: ::speed_t = 0o000000;\npub const B50: ::speed_t = 0o000001;\npub const B75: ::speed_t = 0o000002;\npub const B110: ::speed_t = 0o000003;\npub const B134: ::speed_t = 0o000004;\npub const B150: ::speed_t = 0o000005;\npub const B200: ::speed_t = 0o000006;\npub const B300: ::speed_t = 0o000007;\npub const B600: ::speed_t = 0o000010;\npub const B1200: ::speed_t = 0o000011;\npub const B1800: ::speed_t = 0o000012;\npub const B2400: ::speed_t = 0o000013;\npub const B4800: ::speed_t = 0o000014;\npub const B9600: ::speed_t = 0o000015;\npub const B19200: ::speed_t = 0o000016;\npub const B38400: ::speed_t = 0o000017;\npub const EXTA: ::speed_t = B19200;\npub const EXTB: ::speed_t = B38400;\npub const B57600: ::speed_t = 0o010001;\npub const B115200: ::speed_t = 0o010002;\npub const B230400: ::speed_t = 0o010003;\npub const B460800: ::speed_t = 0o010004;\npub const B500000: ::speed_t = 0o010005;\npub const B576000: ::speed_t = 0o010006;\npub const B921600: ::speed_t = 0o010007;\npub const B1000000: ::speed_t = 0o010010;\npub const B1152000: ::speed_t = 0o010011;\npub const B1500000: ::speed_t = 0o010012;\npub const B2000000: ::speed_t = 0o010013;\npub const B2500000: ::speed_t = 0o010014;\npub const B3000000: ::speed_t = 0o010015;\npub const B3500000: ::speed_t = 0o010016;\npub const B4000000: ::speed_t = 0o010017;\n\ncfg_if! {\n    if #[cfg(target_arch = \"mips\")] {\n        mod mips32;\n        pub use self::mips32::*;\n    } else if #[cfg(target_arch = \"mips64\")] {\n        mod mips64;\n        pub use self::mips64::*;\n    } else {\n        // Unknown target_arch\n    }\n}\n"],["1155","pub type shmatt_t = ::c_ulong;\npub type msgqnum_t = ::c_ulong;\npub type msglen_t = ::c_ulong;\npub type regoff_t = ::c_int;\n\ns! {\n    pub struct statvfs {  // Different than GNU!\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_favail: ::fsfilcnt_t,\n        #[cfg(target_endian = \"little\")]\n        pub f_fsid: ::c_ulong,\n        #[cfg(target_pointer_width = \"32\")]\n        __f_unused: ::c_int,\n        #[cfg(target_endian = \"big\")]\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct regex_t {\n        __buffer: *mut ::c_void,\n        __allocated: ::size_t,\n        __used: ::size_t,\n        __syntax: ::c_ulong,\n        __fastmap: *mut ::c_char,\n        __translate: *mut ::c_char,\n        __re_nsub: ::size_t,\n        __bitfield: u8,\n    }\n}\n\npub const MCL_CURRENT: ::c_int = 0x0001;\npub const MCL_FUTURE: ::c_int = 0x0002;\n\npub const SIGEV_THREAD_ID: ::c_int = 4;\n\npub const ADFS_SUPER_MAGIC: ::c_long = 0x0000adf5;\npub const AFFS_SUPER_MAGIC: ::c_long = 0x0000adff;\npub const AFS_SUPER_MAGIC: ::c_long = 0x5346414f;\npub const AUTOFS_SUPER_MAGIC: ::c_long = 0x0187;\npub const BINDERFS_SUPER_MAGIC: ::c_long = 0x6c6f6f70;\npub const BPF_FS_MAGIC: ::c_long = 0xcafe4a11;\npub const BTRFS_SUPER_MAGIC: ::c_long = 0x9123683e;\npub const CGROUP2_SUPER_MAGIC: ::c_long = 0x63677270;\npub const CGROUP_SUPER_MAGIC: ::c_long = 0x27e0eb;\npub const CODA_SUPER_MAGIC: ::c_long = 0x73757245;\npub const CRAMFS_MAGIC: ::c_long = 0x28cd3d45;\npub const DEBUGFS_MAGIC: ::c_long = 0x64626720;\npub const DEVPTS_SUPER_MAGIC: ::c_long = 0x1cd1;\npub const ECRYPTFS_SUPER_MAGIC: ::c_long = 0xf15f;\npub const EFS_SUPER_MAGIC: ::c_long = 0x00414a53;\npub const EXT2_SUPER_MAGIC: ::c_long = 0x0000ef53;\npub const EXT3_SUPER_MAGIC: ::c_long = 0x0000ef53;\npub const EXT4_SUPER_MAGIC: ::c_long = 0x0000ef53;\npub const F2FS_SUPER_MAGIC: ::c_long = 0xf2f52010;\npub const FUTEXFS_SUPER_MAGIC: ::c_long = 0xbad1dea;\npub const HOSTFS_SUPER_MAGIC: ::c_long = 0x00c0ffee;\npub const HPFS_SUPER_MAGIC: ::c_long = 0xf995e849;\npub const HUGETLBFS_MAGIC: ::c_long = 0x958458f6;\npub const ISOFS_SUPER_MAGIC: ::c_long = 0x00009660;\npub const JFFS2_SUPER_MAGIC: ::c_long = 0x000072b6;\npub const MINIX2_SUPER_MAGIC2: ::c_long = 0x00002478;\npub const MINIX2_SUPER_MAGIC: ::c_long = 0x00002468;\npub const MINIX3_SUPER_MAGIC: ::c_long = 0x4d5a;\npub const MINIX_SUPER_MAGIC2: ::c_long = 0x0000138f;\npub const MINIX_SUPER_MAGIC: ::c_long = 0x0000137f;\npub const MSDOS_SUPER_MAGIC: ::c_long = 0x00004d44;\npub const NCP_SUPER_MAGIC: ::c_long = 0x0000564c;\npub const NFS_SUPER_MAGIC: ::c_long = 0x00006969;\npub const NILFS_SUPER_MAGIC: ::c_long = 0x3434;\npub const OCFS2_SUPER_MAGIC: ::c_long = 0x7461636f;\npub const OPENPROM_SUPER_MAGIC: ::c_long = 0x00009fa1;\npub const OVERLAYFS_SUPER_MAGIC: ::c_long = 0x794c7630;\npub const PROC_SUPER_MAGIC: ::c_long = 0x00009fa0;\npub const QNX4_SUPER_MAGIC: ::c_long = 0x0000002f;\npub const QNX6_SUPER_MAGIC: ::c_long = 0x68191122;\npub const RDTGROUP_SUPER_MAGIC: ::c_long = 0x7655821;\npub const REISERFS_SUPER_MAGIC: ::c_long = 0x52654973;\npub const SMB_SUPER_MAGIC: ::c_long = 0x0000517b;\npub const SYSFS_MAGIC: ::c_long = 0x62656572;\npub const TMPFS_MAGIC: ::c_long = 0x01021994;\npub const TRACEFS_MAGIC: ::c_long = 0x74726163;\npub const UDF_SUPER_MAGIC: ::c_long = 0x15013346;\npub const USBDEVICE_SUPER_MAGIC: ::c_long = 0x00009fa2;\npub const XENFS_SUPER_MAGIC: ::c_long = 0xabba1974;\npub const XFS_SUPER_MAGIC: ::c_long = 0x58465342;\n\npub const PTRACE_TRACEME: ::c_int = 0;\npub const PTRACE_PEEKTEXT: ::c_int = 1;\npub const PTRACE_PEEKDATA: ::c_int = 2;\npub const PTRACE_PEEKUSER: ::c_int = 3;\npub const PTRACE_POKETEXT: ::c_int = 4;\npub const PTRACE_POKEDATA: ::c_int = 5;\npub const PTRACE_POKEUSER: ::c_int = 6;\npub const PTRACE_CONT: ::c_int = 7;\npub const PTRACE_KILL: ::c_int = 8;\npub const PTRACE_SINGLESTEP: ::c_int = 9;\npub const PTRACE_GETREGS: ::c_int = 12;\npub const PTRACE_SETREGS: ::c_int = 13;\npub const PTRACE_GETFPREGS: ::c_int = 14;\npub const PTRACE_SETFPREGS: ::c_int = 15;\npub const PTRACE_ATTACH: ::c_int = 16;\npub const PTRACE_DETACH: ::c_int = 17;\npub const PTRACE_GETFPXREGS: ::c_int = 18;\npub const PTRACE_SETFPXREGS: ::c_int = 19;\npub const PTRACE_SYSCALL: ::c_int = 24;\npub const PTRACE_SETOPTIONS: ::c_int = 0x4200;\npub const PTRACE_GETEVENTMSG: ::c_int = 0x4201;\npub const PTRACE_GETSIGINFO: ::c_int = 0x4202;\npub const PTRACE_SETSIGINFO: ::c_int = 0x4203;\npub const PTRACE_GETREGSET: ::c_int = 0x4204;\npub const PTRACE_SETREGSET: ::c_int = 0x4205;\npub const PTRACE_SEIZE: ::c_int = 0x4206;\npub const PTRACE_INTERRUPT: ::c_int = 0x4207;\npub const PTRACE_LISTEN: ::c_int = 0x4208;\npub const PTRACE_O_MASK: ::c_int = 0x000000ff;\n\npub const POSIX_FADV_DONTNEED: ::c_int = 4;\npub const POSIX_FADV_NOREUSE: ::c_int = 5;\n\npub const RLIMIT_CPU: ::c_int = 0;\npub const RLIMIT_FSIZE: ::c_int = 1;\npub const RLIMIT_DATA: ::c_int = 2;\npub const RLIMIT_STACK: ::c_int = 3;\npub const RLIMIT_CORE: ::c_int = 4;\npub const RLIMIT_LOCKS: ::c_int = 10;\npub const RLIMIT_SIGPENDING: ::c_int = 11;\npub const RLIMIT_MSGQUEUE: ::c_int = 12;\npub const RLIMIT_NICE: ::c_int = 13;\npub const RLIMIT_RTPRIO: ::c_int = 14;\n\n// These are different than GNU!\npub const LC_CTYPE: ::c_int = 0;\npub const LC_NUMERIC: ::c_int = 1;\npub const LC_TIME: ::c_int = 3;\npub const LC_COLLATE: ::c_int = 4;\npub const LC_MONETARY: ::c_int = 2;\npub const LC_MESSAGES: ::c_int = 5;\npub const LC_ALL: ::c_int = 6;\n// end different section\n\n// MS_ flags for mount(2)\npub const MS_RMT_MASK: ::c_ulong = ::MS_RDONLY | ::MS_SYNCHRONOUS | ::MS_MANDLOCK | ::MS_I_VERSION;\n\npub const ENOTSUP: ::c_int = EOPNOTSUPP;\n\npub const IPV6_JOIN_GROUP: ::c_int = 20;\npub const IPV6_LEAVE_GROUP: ::c_int = 21;\n\n// These are different from GNU\npub const ABDAY_1: ::nl_item = 0x300;\npub const ABDAY_2: ::nl_item = 0x301;\npub const ABDAY_3: ::nl_item = 0x302;\npub const ABDAY_4: ::nl_item = 0x303;\npub const ABDAY_5: ::nl_item = 0x304;\npub const ABDAY_6: ::nl_item = 0x305;\npub const ABDAY_7: ::nl_item = 0x306;\npub const DAY_1: ::nl_item = 0x307;\npub const DAY_2: ::nl_item = 0x308;\npub const DAY_3: ::nl_item = 0x309;\npub const DAY_4: ::nl_item = 0x30A;\npub const DAY_5: ::nl_item = 0x30B;\npub const DAY_6: ::nl_item = 0x30C;\npub const DAY_7: ::nl_item = 0x30D;\npub const ABMON_1: ::nl_item = 0x30E;\npub const ABMON_2: ::nl_item = 0x30F;\npub const ABMON_3: ::nl_item = 0x310;\npub const ABMON_4: ::nl_item = 0x311;\npub const ABMON_5: ::nl_item = 0x312;\npub const ABMON_6: ::nl_item = 0x313;\npub const ABMON_7: ::nl_item = 0x314;\npub const ABMON_8: ::nl_item = 0x315;\npub const ABMON_9: ::nl_item = 0x316;\npub const ABMON_10: ::nl_item = 0x317;\npub const ABMON_11: ::nl_item = 0x318;\npub const ABMON_12: ::nl_item = 0x319;\npub const MON_1: ::nl_item = 0x31A;\npub const MON_2: ::nl_item = 0x31B;\npub const MON_3: ::nl_item = 0x31C;\npub const MON_4: ::nl_item = 0x31D;\npub const MON_5: ::nl_item = 0x31E;\npub const MON_6: ::nl_item = 0x31F;\npub const MON_7: ::nl_item = 0x320;\npub const MON_8: ::nl_item = 0x321;\npub const MON_9: ::nl_item = 0x322;\npub const MON_10: ::nl_item = 0x323;\npub const MON_11: ::nl_item = 0x324;\npub const MON_12: ::nl_item = 0x325;\npub const AM_STR: ::nl_item = 0x326;\npub const PM_STR: ::nl_item = 0x327;\npub const D_T_FMT: ::nl_item = 0x328;\npub const D_FMT: ::nl_item = 0x329;\npub const T_FMT: ::nl_item = 0x32A;\npub const T_FMT_AMPM: ::nl_item = 0x32B;\npub const ERA: ::nl_item = 0x32C;\npub const ERA_D_FMT: ::nl_item = 0x32E;\npub const ALT_DIGITS: ::nl_item = 0x32F;\npub const ERA_D_T_FMT: ::nl_item = 0x330;\npub const ERA_T_FMT: ::nl_item = 0x331;\npub const CODESET: ::nl_item = 10;\npub const CRNCYSTR: ::nl_item = 0x215;\npub const RADIXCHAR: ::nl_item = 0x100;\npub const THOUSEP: ::nl_item = 0x101;\npub const NOEXPR: ::nl_item = 0x501;\npub const YESSTR: ::nl_item = 0x502;\npub const NOSTR: ::nl_item = 0x503;\n\n// Different than Gnu.\npub const FILENAME_MAX: ::c_uint = 4095;\n\npub const PRIO_PROCESS: ::c_int = 0;\npub const PRIO_PGRP: ::c_int = 1;\npub const PRIO_USER: ::c_int = 2;\n\npub const ST_RELATIME: ::c_ulong = 4096;\n\nextern \"C\" {\n    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::timezone) -> ::c_int;\n\n    pub fn pthread_rwlockattr_getkind_np(\n        attr: *const ::pthread_rwlockattr_t,\n        val: *mut ::c_int,\n    ) -> ::c_int;\n    pub fn pthread_rwlockattr_setkind_np(\n        attr: *mut ::pthread_rwlockattr_t,\n        val: ::c_int,\n    ) -> ::c_int;\n\n    pub fn ptrace(request: ::c_uint, ...) -> ::c_long;\n\n    pub fn sendmmsg(\n        sockfd: ::c_int,\n        msgvec: *mut ::mmsghdr,\n        vlen: ::c_uint,\n        flags: ::c_int,\n    ) -> ::c_int;\n    pub fn recvmmsg(\n        sockfd: ::c_int,\n        msgvec: *mut ::mmsghdr,\n        vlen: ::c_uint,\n        flags: ::c_int,\n        timeout: *mut ::timespec,\n    ) -> ::c_int;\n\n    pub fn openpty(\n        amaster: *mut ::c_int,\n        aslave: *mut ::c_int,\n        name: *mut ::c_char,\n        termp: *mut termios,\n        winp: *mut ::winsize,\n    ) -> ::c_int;\n    pub fn forkpty(\n        amaster: *mut ::c_int,\n        name: *mut ::c_char,\n        termp: *mut termios,\n        winp: *mut ::winsize,\n    ) -> ::pid_t;\n\n    pub fn getnameinfo(\n        sa: *const ::sockaddr,\n        salen: ::socklen_t,\n        host: *mut ::c_char,\n        hostlen: ::socklen_t,\n        serv: *mut ::c_char,\n        sevlen: ::socklen_t,\n        flags: ::c_int,\n    ) -> ::c_int;\n\n    pub fn pwritev(\n        fd: ::c_int,\n        iov: *const ::iovec,\n        iovcnt: ::c_int,\n        offset: ::off64_t,\n    ) -> ::ssize_t;\n    pub fn preadv(\n        fd: ::c_int,\n        iov: *const ::iovec,\n        iovcnt: ::c_int,\n        offset: ::off64_t,\n    ) -> ::ssize_t;\n}\n\ncfg_if! {\n    if #[cfg(any(target_arch = \"mips\", target_arch = \"mips64\"))] {\n        mod mips;\n        pub use self::mips::*;\n    } else if #[cfg(target_arch = \"x86_64\")] {\n        mod x86_64;\n        pub use self::x86_64::*;\n    } else if #[cfg(target_arch = \"arm\")] {\n        mod arm;\n        pub use self::arm::*;\n    } else {\n        pub use unsupported_target;\n    }\n}\n"],["1156","macro_rules! expand_align {\n    () => {\n        s! {\n            #[cfg_attr(any(target_pointer_width = \"32\",\n                           target_arch = \"x86_64\",\n                           target_arch = \"powerpc64\",\n                           target_arch = \"mips64\",\n                           target_arch = \"s390x\",\n                           target_arch = \"sparc64\"),\n                       repr(align(4)))]\n            #[cfg_attr(not(any(target_pointer_width = \"32\",\n                               target_arch = \"x86_64\",\n                               target_arch = \"powerpc64\",\n                               target_arch = \"mips64\",\n                               target_arch = \"s390x\",\n                               target_arch = \"sparc64\")),\n                       repr(align(8)))]\n            pub struct pthread_mutexattr_t {\n                size: [u8; ::__SIZEOF_PTHREAD_MUTEXATTR_T],\n            }\n\n            #[repr(align(4))]\n            pub struct pthread_condattr_t {\n                size: [u8; ::__SIZEOF_PTHREAD_CONDATTR_T],\n            }\n        }\n    };\n}\n"],["1157","macro_rules! expand_align {\n    () => {\n        s! {\n            pub struct pthread_mutex_t {\n                #[cfg(any(target_arch = \"mips\",\n                          target_arch = \"arm\",\n                          target_arch = \"powerpc\"))]\n                __align: [::c_long; 0],\n                #[cfg(any(libc_align,\n                          target_arch = \"mips\",\n                          target_arch = \"arm\",\n                          target_arch = \"powerpc\"))]\n                __align: [::c_longlong; 0],\n                size: [u8; ::__SIZEOF_PTHREAD_MUTEX_T],\n            }\n\n            pub struct pthread_rwlock_t {\n                #[cfg(any(target_arch = \"mips\",\n                          target_arch = \"arm\",\n                          target_arch = \"powerpc\"))]\n                __align: [::c_long; 0],\n                #[cfg(not(any(\n                    target_arch = \"mips\",\n                    target_arch = \"arm\",\n                    target_arch = \"powerpc\")))]\n                __align: [::c_longlong; 0],\n                size: [u8; ::__SIZEOF_PTHREAD_RWLOCK_T],\n            }\n\n            pub struct pthread_mutexattr_t {\n                #[cfg(any(target_arch = \"x86_64\", target_arch = \"powerpc64\",\n                          target_arch = \"mips64\", target_arch = \"s390x\",\n                          target_arch = \"sparc64\"))]\n                __align: [::c_int; 0],\n                #[cfg(not(any(target_arch = \"x86_64\", target_arch = \"powerpc64\",\n                              target_arch = \"mips64\", target_arch = \"s390x\",\n                              target_arch = \"sparc64\")))]\n                __align: [::c_long; 0],\n                size: [u8; ::__SIZEOF_PTHREAD_MUTEXATTR_T],\n            }\n\n            pub struct pthread_cond_t {\n                __align: [::c_longlong; 0],\n                size: [u8; ::__SIZEOF_PTHREAD_COND_T],\n            }\n\n            pub struct pthread_condattr_t {\n                __align: [::c_int; 0],\n                size: [u8; ::__SIZEOF_PTHREAD_CONDATTR_T],\n            }\n        }\n    }\n}\n"],["1158","// Thestyle checker discourages the use of #[cfg], so this has to go into a\n// separate module\npub type pthread_t = ::c_ulong;\n\npub const PTHREAD_STACK_MIN: usize = 16384;\n"],["1159","//! Definitions for uclibc on 64bit systems\npub type blkcnt_t = i64;\npub type blksize_t = i64;\npub type clock_t = i64;\npub type c_char = u8;\npub type c_long = i64;\npub type c_ulong = u64;\npub type fsblkcnt_t = ::c_ulong;\npub type fsfilcnt_t = ::c_ulong;\npub type fsword_t = ::c_long;\npub type ino_t = ::c_ulong;\npub type nlink_t = ::c_uint;\npub type off_t = ::c_long;\npub type rlim_t = c_ulong;\n// [uClibc docs] Note stat64 has the same shape as stat for x86-64.\npub type stat64 = stat;\npub type suseconds_t = ::c_long;\npub type time_t = ::c_int;\npub type wchar_t = ::c_int;\n\npub type fsblkcnt64_t = u64;\npub type fsfilcnt64_t = u64;\npub type __u64 = ::c_ulong;\n\ns! {\n    pub struct ipc_perm {\n        pub __key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::c_ushort, // read / write\n        __pad1: ::c_ushort,\n        pub __seq: ::c_ushort,\n        __pad2: ::c_ushort,\n        __unused1: ::c_ulong,\n        __unused2: ::c_ulong\n    }\n\n    #[cfg(not(target_os = \"l4re\"))]\n    pub struct pthread_attr_t {\n        __detachstate: ::c_int,\n        __schedpolicy: ::c_int,\n        __schedparam: __sched_param,\n        __inheritsched: ::c_int,\n        __scope: ::c_int,\n        __guardsize: ::size_t,\n        __stackaddr_set: ::c_int,\n        __stackaddr: *mut ::c_void, // better don't use it\n        __stacksize: ::size_t,\n    }\n\n    pub struct __sched_param {\n        __sched_priority: ::c_int,\n    }\n\n    pub struct siginfo_t {\n        si_signo: ::c_int, // signal number\n        si_errno: ::c_int, // if not zero: error value of signal, see errno.h\n        si_code: ::c_int,  // signal code\n        pub _pad: [::c_int; 28], // unported union\n        _align: [usize; 0],\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        pub shm_segsz: ::size_t, // segment size in bytes\n        pub shm_atime: ::time_t, // time of last shmat()\n        pub shm_dtime: ::time_t,\n        pub shm_ctime: ::time_t,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::shmatt_t,\n        __unused1: ::c_ulong,\n        __unused2: ::c_ulong\n    }\n\n    pub struct msqid_ds {\n        pub msg_perm: ::ipc_perm,\n        pub msg_stime: ::time_t,\n        pub msg_rtime: ::time_t,\n        pub msg_ctime: ::time_t,\n        __msg_cbytes: ::c_ulong,\n        pub msg_qnum: ::msgqnum_t,\n        pub msg_qbytes: ::msglen_t,\n        pub msg_lspid: ::pid_t,\n        pub msg_lrpid: ::pid_t,\n        __ignored1: ::c_ulong,\n        __ignored2: ::c_ulong,\n    }\n\n    pub struct sockaddr {\n        pub sa_family: ::sa_family_t,\n        pub sa_data: [::c_char; 14],\n    }\n\n    pub struct sockaddr_in {\n        pub sin_family: ::sa_family_t,\n        pub sin_port: ::in_port_t,\n        pub sin_addr: ::in_addr,\n        pub sin_zero: [u8; 8],\n    }\n\n    pub struct sockaddr_in6 {\n        pub sin6_family: ::sa_family_t,\n        pub sin6_port: ::in_port_t,\n        pub sin6_flowinfo: u32,\n        pub sin6_addr: ::in6_addr,\n        pub sin6_scope_id: u32,\n    }\n\n    // ------------------------------------------------------------\n    // definitions below are *unverified* and might **break** the software\n//    pub struct in_addr {\n//        pub s_addr: in_addr_t,\n//    }\n//\n//    pub struct in6_addr {\n//        pub s6_addr: [u8; 16],\n//        #[cfg(not(libc_align))]\n//        __align: [u32; 0],\n//    }\n\n    pub struct stat {\n        pub st_dev: ::c_ulong,\n        pub st_ino: ::ino_t,\n        // According to uclibc/libc/sysdeps/linux/x86_64/bits/stat.h, order of\n        // nlink and mode are swapped on 64 bit systems.\n        pub st_nlink: ::nlink_t,\n        pub st_mode: ::mode_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::c_ulong, // dev_t\n        pub st_size: off_t, // file size\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_ulong,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_ulong,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_ulong,\n        st_pad4: [::c_long; 3]\n    }\n\n    pub struct sigaction {\n        pub sa_handler: ::sighandler_t,\n        pub sa_flags: ::c_ulong,\n        pub sa_restorer: ::Option<extern fn()>,\n        pub sa_mask: ::sigset_t,\n    }\n\n    pub struct stack_t { // FIXME\n        pub ss_sp: *mut ::c_void,\n        pub ss_flags: ::c_int,\n        pub ss_size: ::size_t\n    }\n\n    pub struct statfs { // FIXME\n        pub f_type: fsword_t,\n        pub f_bsize: fsword_t,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: fsword_t,\n        pub f_frsize: fsword_t,\n        f_spare: [fsword_t; 5],\n    }\n\n    pub struct statfs64 {\n        pub f_type: ::c_int,\n        pub f_bsize: ::c_int,\n        pub f_blocks: ::fsblkcnt64_t,\n        pub f_bfree: ::fsblkcnt64_t,\n        pub f_bavail: ::fsblkcnt64_t,\n        pub f_files: ::fsfilcnt64_t,\n        pub f_ffree: ::fsfilcnt64_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_int,\n        pub f_frsize: ::c_int,\n        pub f_flags: ::c_int,\n        pub f_spare: [::c_int; 4],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_favail: u64,\n        pub f_fsid: ::c_ulong,\n        __f_unused: ::c_int,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct msghdr { // FIXME\n        pub msg_name: *mut ::c_void,\n        pub msg_namelen: ::socklen_t,\n        pub msg_iov: *mut ::iovec,\n        pub msg_iovlen: ::size_t,\n        pub msg_control: *mut ::c_void,\n        pub msg_controllen: ::size_t,\n        pub msg_flags: ::c_int,\n    }\n\n    pub struct termios { // FIXME\n        pub c_iflag: ::tcflag_t,\n        pub c_oflag: ::tcflag_t,\n        pub c_cflag: ::tcflag_t,\n        pub c_lflag: ::tcflag_t,\n        pub c_line: ::cc_t,\n        pub c_cc: [::cc_t; ::NCCS],\n    }\n\n    pub struct sigset_t { // FIXME\n        __val: [::c_ulong; 16],\n    }\n\n    pub struct sysinfo { // FIXME\n        pub uptime: ::c_long,\n        pub loads: [::c_ulong; 3],\n        pub totalram: ::c_ulong,\n        pub freeram: ::c_ulong,\n        pub sharedram: ::c_ulong,\n        pub bufferram: ::c_ulong,\n        pub totalswap: ::c_ulong,\n        pub freeswap: ::c_ulong,\n        pub procs: ::c_ushort,\n        pub pad: ::c_ushort,\n        pub totalhigh: ::c_ulong,\n        pub freehigh: ::c_ulong,\n        pub mem_unit: ::c_uint,\n        pub _f: [::c_char; 0],\n    }\n\n    pub struct glob_t { // FIXME\n        pub gl_pathc: ::size_t,\n        pub gl_pathv: *mut *mut c_char,\n        pub gl_offs: ::size_t,\n        pub gl_flags: ::c_int,\n        __unused1: *mut ::c_void,\n        __unused2: *mut ::c_void,\n        __unused3: *mut ::c_void,\n        __unused4: *mut ::c_void,\n        __unused5: *mut ::c_void,\n    }\n\n    pub struct cpu_set_t { // FIXME\n        #[cfg(target_pointer_width = \"32\")]\n        bits: [u32; 32],\n        #[cfg(target_pointer_width = \"64\")]\n        bits: [u64; 16],\n    }\n\n    pub struct fsid_t { // FIXME\n        __val: [::c_int; 2],\n    }\n\n    // FIXME this is actually a union\n    pub struct sem_t {\n        #[cfg(target_pointer_width = \"32\")]\n        __size: [::c_char; 16],\n        #[cfg(target_pointer_width = \"64\")]\n        __size: [::c_char; 32],\n        __align: [::c_long; 0],\n    }\n\n    pub struct cmsghdr {\n        pub cmsg_len: ::size_t,\n        pub cmsg_level: ::c_int,\n        pub cmsg_type: ::c_int,\n    }\n}\n\ns_no_extra_traits! {\n    #[allow(missing_debug_implementations)]\n    pub struct dirent {\n        pub d_ino: ::ino64_t,\n        pub d_off: ::off64_t,\n        pub d_reclen: u16,\n        pub d_type: u8,\n        pub d_name: [::c_char; 256],\n    }\n}\n\n// constants\npub const EADDRINUSE: ::c_int = 98; // Address already in use\npub const EADDRNOTAVAIL: ::c_int = 99; // Cannot assign requested address\npub const ECONNABORTED: ::c_int = 103; // Software caused connection abort\npub const ECONNREFUSED: ::c_int = 111; // Connection refused\npub const ECONNRESET: ::c_int = 104; // Connection reset by peer\npub const EDEADLK: ::c_int = 35; // Resource deadlock would occur\npub const ENOSYS: ::c_int = 38; // Function not implemented\npub const ENOTCONN: ::c_int = 107; // Transport endpoint is not connected\npub const ETIMEDOUT: ::c_int = 110; // connection timed out\npub const EOPNOTSUPP: ::c_int = 0x5f;\npub const ENODATA: ::c_int = 0x3d;\npub const O_APPEND: ::c_int = 02000;\npub const O_ACCMODE: ::c_int = 0003;\npub const O_CLOEXEC: ::c_int = 0x80000;\npub const O_CREAT: ::c_int = 0100;\npub const O_DIRECTORY: ::c_int = 0200000;\npub const O_EXCL: ::c_int = 0200;\npub const O_NONBLOCK: ::c_int = 04000;\npub const O_TRUNC: ::c_int = 01000;\npub const NCCS: usize = 32;\npub const SIG_SETMASK: ::c_int = 2; // Set the set of blocked signals\npub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;\npub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;\npub const SOCK_DGRAM: ::c_int = 2; // connectionless, unreliable datagrams\npub const SOCK_STREAM: ::c_int = 1; // â€¦/common/bits/socket_type.h\npub const RLIM_INFINITY: u64 = 0xffffffffffffffff;\npub const __SIZEOF_PTHREAD_COND_T: usize = 48;\npub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;\npub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;\npub const __SIZEOF_PTHREAD_RWLOCKATTR_T: usize = 8;\n\ncfg_if! {\n    if #[cfg(target_os = \"l4re\")] {\n        mod l4re;\n        pub use self::l4re::*;\n    } else {\n        mod other;\n        pub use other::*;\n    }\n}\n"],["1160","/// L4Re specifics\n/// This module contains definitions required by various L4Re libc backends.\n/// Some of them are formally not part of the libc, but are a dependency of the\n/// libc and hence we should provide them here.\n\npub type l4_umword_t = ::c_ulong; // Unsigned machine word.\npub type pthread_t = *mut ::c_void;\n\ns! {\n    /// CPU sets.\n    pub struct l4_sched_cpu_set_t {\n        // from the L4Re docs\n        /// Combination of granularity and offset.\n        ///\n        /// The granularity defines how many CPUs each bit in map describes.\n        /// The offset is the numer of the first CPU described by the first\n        /// bit in the bitmap.\n        /// offset must be a multiple of 2^graularity.\n        ///\n        /// | MSB              |                 LSB |\n        /// | ---------------- | ------------------- |\n        /// | 8bit granularity | 24bit offset ..     |\n        gran_offset: l4_umword_t ,\n        /// Bitmap of CPUs.\n        map: l4_umword_t ,\n    }\n}\n\n#[cfg(target_os = \"l4re\")]\n#[allow(missing_debug_implementations)]\npub struct pthread_attr_t {\n    pub __detachstate: ::c_int,\n    pub __schedpolicy: ::c_int,\n    pub __schedparam: super::__sched_param,\n    pub __inheritsched: ::c_int,\n    pub __scope: ::c_int,\n    pub __guardsize: ::size_t,\n    pub __stackaddr_set: ::c_int,\n    pub __stackaddr: *mut ::c_void, // better don't use it\n    pub __stacksize: ::size_t,\n    // L4Re specifics\n    pub affinity: l4_sched_cpu_set_t,\n    pub create_flags: ::c_uint,\n}\n\n// L4Re requires a min stack size of 64k; that isn't defined in uClibc, but\n// somewhere in the core libraries. uClibc wants 16k, but that's not enough.\npub const PTHREAD_STACK_MIN: usize = 65536;\n"],["1161","s! {\n    // FIXME this is actually a union\n    pub struct sem_t {\n        #[cfg(target_pointer_width = \"32\")]\n        __size: [::c_char; 16],\n        #[cfg(target_pointer_width = \"64\")]\n        __size: [::c_char; 32],\n        __align: [::c_long; 0],\n    }\n}\n"],["1162","s! {\n    // FIXME this is actually a union\n    #[cfg_attr(target_pointer_width = \"32\",\n               repr(align(4)))]\n    #[cfg_attr(target_pointer_width = \"64\",\n               repr(align(8)))]\n    pub struct sem_t {\n        #[cfg(target_pointer_width = \"32\")]\n        __size: [::c_char; 16],\n        #[cfg(target_pointer_width = \"64\")]\n        __size: [::c_char; 32],\n    }\n}\n"],["1163","pub type c_char = u8;\npub type wchar_t = ::c_uint;\npub type c_long = i32;\npub type c_ulong = u32;\npub type time_t = ::c_long;\n\npub type clock_t = ::c_long;\npub type fsblkcnt_t = ::c_ulong;\npub type fsfilcnt_t = ::c_ulong;\npub type ino_t = ::c_ulong;\npub type off_t = ::c_long;\npub type pthread_t = ::c_ulong;\npub type rlim_t = ::c_ulong;\npub type suseconds_t = ::c_long;\n\npub type nlink_t = ::c_uint;\npub type blksize_t = ::c_long;\npub type blkcnt_t = ::c_long;\n\npub type fsblkcnt64_t = u64;\npub type fsfilcnt64_t = u64;\npub type __u64 = ::c_ulonglong;\n\ns! {\n    pub struct cmsghdr {\n        pub cmsg_len: ::size_t,\n        pub cmsg_level: ::c_int,\n        pub cmsg_type: ::c_int,\n    }\n\n    pub struct msghdr {\n        pub msg_name: *mut ::c_void,\n        pub msg_namelen: ::socklen_t,\n        pub msg_iov: *mut ::iovec,\n        pub msg_iovlen: ::c_int,\n        pub msg_control: *mut ::c_void,\n        pub msg_controllen: ::socklen_t,\n        pub msg_flags: ::c_int,\n    }\n\n    pub struct pthread_attr_t {\n        __size: [::c_long; 9],\n    }\n\n    pub struct stat {\n        pub st_dev: ::c_ulonglong,\n        pub __pad1: ::c_ushort,\n        pub st_ino: ::ino_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::c_ulonglong,\n        pub __pad2: ::c_ushort,\n        pub st_size: ::off_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        pub __uclibc_unused4: ::c_ulong,\n        pub __uclibc_unused5: ::c_ulong,\n    }\n\n    pub struct stat64\n    {\n        pub st_dev: ::c_ulonglong,\n        pub __pad1: ::c_uint,\n        pub __st_ino: ::ino_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::c_ulonglong,\n        pub __pad2: ::c_uint,\n        pub st_size: ::off64_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt64_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        pub st_ino: ::ino64_t,\n    }\n\n    pub struct flock {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off_t,\n        pub l_len: ::off_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct sysinfo {\n        pub uptime: ::c_long,\n        pub loads: [::c_ulong; 3],\n        pub totalram: ::c_ulong,\n        pub freeram: ::c_ulong,\n        pub sharedram: ::c_ulong,\n        pub bufferram: ::c_ulong,\n        pub totalswap: ::c_ulong,\n        pub freeswap: ::c_ulong,\n        pub procs: ::c_ushort,\n        pub pad: ::c_ushort,\n        pub totalhigh: ::c_ulong,\n        pub freehigh: ::c_ulong,\n        pub mem_unit: ::c_uint,\n        pub _f: [::c_char; 8],\n    }\n\n    pub struct statfs {\n        pub f_type: ::c_int,\n        pub f_bsize: ::c_int,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_int,\n        pub f_frsize: ::c_int,\n        pub f_flags: ::c_int,\n        pub f_spare: [::c_int; 4],\n    }\n\n    pub struct statfs64 {\n        pub f_type: ::c_int,\n        pub f_bsize: ::c_int,\n        pub f_blocks: ::fsblkcnt64_t,\n        pub f_bfree: ::fsblkcnt64_t,\n        pub f_bavail: ::fsblkcnt64_t,\n        pub f_files: ::fsfilcnt64_t,\n        pub f_ffree: ::fsfilcnt64_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_int,\n        pub f_frsize: ::c_int,\n        pub f_flags: ::c_int,\n        pub f_spare: [::c_int; 4],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_favail: u64,\n        pub f_fsid: ::c_ulong,\n        __f_unused: ::c_int,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct sigset_t {\n        __val: [::c_ulong; 2],\n    }\n\n    pub struct sigaction {\n        pub sa_sigaction: ::sighandler_t,\n        pub sa_flags: ::c_ulong,\n        pub sa_restorer: ::Option<extern fn()>,\n        pub sa_mask: sigset_t,\n    }\n\n    pub struct termios {\n        pub c_iflag: ::tcflag_t,\n        pub c_oflag: ::tcflag_t,\n        pub c_cflag: ::tcflag_t,\n        pub c_lflag: ::tcflag_t,\n        pub c_line: ::cc_t,\n        pub c_cc: [::cc_t; ::NCCS],\n        pub c_ispeed: ::speed_t,\n        pub c_ospeed: ::speed_t,\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_errno: ::c_int,\n        pub si_code: ::c_int,\n        pub _pad: [::c_int; 29],\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_flags: ::c_int,\n        pub ss_size: ::size_t,\n    }\n\n    pub struct ipc_perm {\n        pub __key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::c_ushort,\n        pub __pad1: ::c_ushort,\n        pub __seq: ::c_ushort,\n        pub __pad2: ::c_ushort,\n        pub __uclibc_unused1: ::c_ulong,\n        pub __uclibc_unused2: ::c_ulong,\n    }\n\n    pub struct msqid_ds {\n        pub msg_perm: ::ipc_perm,\n        pub msg_stime: ::time_t,\n        pub __uclibc_unused1: ::c_ulong,\n        pub msg_rtime: ::time_t,\n        pub __uclibc_unused2: ::c_ulong,\n        pub msg_ctime: ::time_t,\n        pub __uclibc_unused3: ::c_ulong,\n        pub __msg_cbytes: ::c_ulong,\n        pub msg_qnum: ::msgqnum_t,\n        pub msg_qbytes: ::msglen_t,\n        pub msg_lspid: ::pid_t,\n        pub msg_lrpid: ::pid_t,\n        pub __uclibc_unused4: ::c_ulong,\n        pub __uclibc_unused5: ::c_ulong,\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        pub shm_segsz: ::size_t,\n        pub shm_atime: ::time_t,\n        pub __uclibc_unused1: ::c_ulong,\n        pub shm_dtime: ::time_t,\n        pub __uclibc_unused2: ::c_ulong,\n        pub shm_ctime: ::time_t,\n        pub __uclibc_unused3: ::c_ulong,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::shmatt_t,\n        pub __uclibc_unused4: ::c_ulong,\n        pub __uclibc_unused5: ::c_ulong,\n    }\n}\n\npub const O_CLOEXEC: ::c_int = 0o2000000;\npub const RLIM_INFINITY: rlim_t = !0;\npub const __SIZEOF_PTHREAD_ATTR_T: usize = 36;\npub const __SIZEOF_PTHREAD_MUTEX_T: usize = 24;\npub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;\npub const __SIZEOF_PTHREAD_COND_COMPAT_T: usize = 12;\npub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;\npub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 32;\npub const __SIZEOF_PTHREAD_RWLOCKATTR_T: usize = 8;\npub const __SIZEOF_PTHREAD_BARRIER_T: usize = 20;\npub const __SIZEOF_PTHREAD_BARRIERATTR_T: usize = 4;\npub const NCCS: usize = 32;\n\n// I wasn't able to find those constants\n// in uclibc build environment for armv7\npub const MAP_HUGETLB: ::c_int = 0x040000; // from linux/other/mod.rs\n\n// autogenerated constants with hand tuned types\npub const B0: ::speed_t = 0;\npub const B1000000: ::speed_t = 0x1008;\npub const B110: ::speed_t = 0x3;\npub const B115200: ::speed_t = 0x1002;\npub const B1152000: ::speed_t = 0x1009;\npub const B1200: ::speed_t = 0x9;\npub const B134: ::speed_t = 0x4;\npub const B150: ::speed_t = 0x5;\npub const B1500000: ::speed_t = 0x100a;\npub const B1800: ::speed_t = 0xa;\npub const B19200: ::speed_t = 0xe;\npub const B200: ::speed_t = 0x6;\npub const B2000000: ::speed_t = 0x100b;\npub const B230400: ::speed_t = 0x1003;\npub const B2400: ::speed_t = 0xb;\npub const B2500000: ::speed_t = 0x100c;\npub const B300: ::speed_t = 0x7;\npub const B3000000: ::speed_t = 0x100d;\npub const B3500000: ::speed_t = 0x100e;\npub const B38400: ::speed_t = 0xf;\npub const B4000000: ::speed_t = 0x100f;\npub const B460800: ::speed_t = 0x1004;\npub const B4800: ::speed_t = 0xc;\npub const B50: ::speed_t = 0x1;\npub const B500000: ::speed_t = 0x1005;\npub const B57600: ::speed_t = 0x1001;\npub const B576000: ::speed_t = 0x1006;\npub const B600: ::speed_t = 0x8;\npub const B75: ::speed_t = 0x2;\npub const B921600: ::speed_t = 0x1007;\npub const B9600: ::speed_t = 0xd;\npub const BS1: ::c_int = 0x2000;\npub const BSDLY: ::c_int = 0x2000;\npub const CBAUD: ::tcflag_t = 0x100f;\npub const CBAUDEX: ::tcflag_t = 0x1000;\npub const CIBAUD: ::tcflag_t = 0x100f0000;\npub const CLOCAL: ::tcflag_t = 0x800;\npub const CPU_SETSIZE: ::c_int = 0x400;\npub const CR1: ::c_int = 0x200;\npub const CR2: ::c_int = 0x400;\npub const CR3: ::c_int = 0x600;\npub const CRDLY: ::c_int = 0x600;\npub const CREAD: ::tcflag_t = 0x80;\npub const CS6: ::tcflag_t = 0x10;\npub const CS7: ::tcflag_t = 0x20;\npub const CS8: ::tcflag_t = 0x30;\npub const CSIZE: ::tcflag_t = 0x30;\npub const CSTOPB: ::tcflag_t = 0x40;\npub const EADDRINUSE: ::c_int = 0x62;\npub const EADDRNOTAVAIL: ::c_int = 0x63;\npub const EADV: ::c_int = 0x44;\npub const EAFNOSUPPORT: ::c_int = 0x61;\npub const EALREADY: ::c_int = 0x72;\npub const EBADE: ::c_int = 0x34;\npub const EBADFD: ::c_int = 0x4d;\npub const EBADMSG: ::c_int = 0x4a;\npub const EBADR: ::c_int = 0x35;\npub const EBADRQC: ::c_int = 0x38;\npub const EBADSLT: ::c_int = 0x39;\npub const EBFONT: ::c_int = 0x3b;\npub const ECANCELED: ::c_int = 0x7d;\npub const ECHOCTL: ::tcflag_t = 0x200;\npub const ECHOE: ::tcflag_t = 0x10;\npub const ECHOK: ::tcflag_t = 0x20;\npub const ECHOKE: ::tcflag_t = 0x800;\npub const ECHONL: ::tcflag_t = 0x40;\npub const ECHOPRT: ::tcflag_t = 0x400;\npub const ECHRNG: ::c_int = 0x2c;\npub const ECOMM: ::c_int = 0x46;\npub const ECONNABORTED: ::c_int = 0x67;\npub const ECONNREFUSED: ::c_int = 0x6f;\npub const ECONNRESET: ::c_int = 0x68;\npub const EDEADLK: ::c_int = 0x23;\npub const EDESTADDRREQ: ::c_int = 0x59;\npub const EDOTDOT: ::c_int = 0x49;\npub const EDQUOT: ::c_int = 0x7a;\npub const EFD_CLOEXEC: ::c_int = 0x80000;\npub const EFD_NONBLOCK: ::c_int = 0x800;\npub const EHOSTDOWN: ::c_int = 0x70;\npub const EHOSTUNREACH: ::c_int = 0x71;\npub const EHWPOISON: ::c_int = 0x85;\npub const EIDRM: ::c_int = 0x2b;\npub const EILSEQ: ::c_int = 0x54;\npub const EINPROGRESS: ::c_int = 0x73;\npub const EISCONN: ::c_int = 0x6a;\npub const EISNAM: ::c_int = 0x78;\npub const EKEYEXPIRED: ::c_int = 0x7f;\npub const EKEYREJECTED: ::c_int = 0x81;\npub const EKEYREVOKED: ::c_int = 0x80;\npub const EL2HLT: ::c_int = 0x33;\npub const EL2NSYNC: ::c_int = 0x2d;\npub const EL3HLT: ::c_int = 0x2e;\npub const EL3RST: ::c_int = 0x2f;\npub const ELIBACC: ::c_int = 0x4f;\npub const ELIBBAD: ::c_int = 0x50;\npub const ELIBEXEC: ::c_int = 0x53;\npub const ELIBMAX: ::c_int = 0x52;\npub const ELIBSCN: ::c_int = 0x51;\npub const ELNRNG: ::c_int = 0x30;\npub const ELOOP: ::c_int = 0x28;\npub const EMEDIUMTYPE: ::c_int = 0x7c;\npub const EMSGSIZE: ::c_int = 0x5a;\npub const EMULTIHOP: ::c_int = 0x48;\npub const ENAMETOOLONG: ::c_int = 0x24;\npub const ENAVAIL: ::c_int = 0x77;\npub const ENETDOWN: ::c_int = 0x64;\npub const ENETRESET: ::c_int = 0x66;\npub const ENETUNREACH: ::c_int = 0x65;\npub const ENOANO: ::c_int = 0x37;\npub const ENOBUFS: ::c_int = 0x69;\npub const ENOCSI: ::c_int = 0x32;\npub const ENODATA: ::c_int = 0x3d;\npub const ENOKEY: ::c_int = 0x7e;\npub const ENOLCK: ::c_int = 0x25;\npub const ENOLINK: ::c_int = 0x43;\npub const ENOMEDIUM: ::c_int = 0x7b;\npub const ENOMSG: ::c_int = 0x2a;\npub const ENONET: ::c_int = 0x40;\npub const ENOPKG: ::c_int = 0x41;\npub const ENOPROTOOPT: ::c_int = 0x5c;\npub const ENOSR: ::c_int = 0x3f;\npub const ENOSTR: ::c_int = 0x3c;\npub const ENOSYS: ::c_int = 0x26;\npub const ENOTCONN: ::c_int = 0x6b;\npub const ENOTEMPTY: ::c_int = 0x27;\npub const ENOTNAM: ::c_int = 0x76;\npub const ENOTRECOVERABLE: ::c_int = 0x83;\npub const ENOTSOCK: ::c_int = 0x58;\npub const ENOTUNIQ: ::c_int = 0x4c;\npub const EOPNOTSUPP: ::c_int = 0x5f;\npub const EOVERFLOW: ::c_int = 0x4b;\npub const EOWNERDEAD: ::c_int = 0x82;\npub const EPFNOSUPPORT: ::c_int = 0x60;\npub const EPOLL_CLOEXEC: ::c_int = 0x80000;\npub const EPROTO: ::c_int = 0x47;\npub const EPROTONOSUPPORT: ::c_int = 0x5d;\npub const EPROTOTYPE: ::c_int = 0x5b;\npub const EREMCHG: ::c_int = 0x4e;\npub const EREMOTE: ::c_int = 0x42;\npub const EREMOTEIO: ::c_int = 0x79;\npub const ERESTART: ::c_int = 0x55;\npub const ERFKILL: ::c_int = 0x84;\npub const ESHUTDOWN: ::c_int = 0x6c;\npub const ESOCKTNOSUPPORT: ::c_int = 0x5e;\npub const ESRMNT: ::c_int = 0x45;\npub const ESTALE: ::c_int = 0x74;\npub const ESTRPIPE: ::c_int = 0x56;\npub const ETIME: ::c_int = 0x3e;\npub const ETIMEDOUT: ::c_int = 0x6e;\npub const ETOOMANYREFS: ::c_int = 0x6d;\npub const EUCLEAN: ::c_int = 0x75;\npub const EUNATCH: ::c_int = 0x31;\npub const EUSERS: ::c_int = 0x57;\npub const EXFULL: ::c_int = 0x36;\npub const FF1: ::c_int = 0x8000;\npub const FFDLY: ::c_int = 0x8000;\npub const FIONBIO: ::c_ulong = 0x5421;\npub const FIOCLEX: ::c_ulong = 0x5451;\npub const FIONCLEX: ::c_ulong = 0x5450;\npub const FLUSHO: ::tcflag_t = 0x1000;\npub const F_GETLK: ::c_int = 0x5;\npub const F_SETLK: ::c_int = 0x6;\npub const F_SETLKW: ::c_int = 0x7;\npub const HUPCL: ::tcflag_t = 0x400;\npub const ICANON: ::tcflag_t = 0x2;\npub const IEXTEN: ::tcflag_t = 0x8000;\npub const ISIG: ::tcflag_t = 0x1;\npub const IXOFF: ::tcflag_t = 0x1000;\npub const IXON: ::tcflag_t = 0x400;\npub const MAP_ANON: ::c_int = 0x20;\npub const MAP_ANONYMOUS: ::c_int = 0x20;\npub const MAP_DENYWRITE: ::c_int = 0x800;\npub const MAP_EXECUTABLE: ::c_int = 0x1000;\npub const MAP_GROWSDOWN: ::c_int = 0x100;\npub const MAP_LOCKED: ::c_int = 0x2000;\npub const MAP_NONBLOCK: ::c_int = 0x10000;\npub const MAP_NORESERVE: ::c_int = 0x4000;\npub const MAP_POPULATE: ::c_int = 0x8000;\npub const MAP_STACK: ::c_int = 0x20000;\npub const NLDLY: ::tcflag_t = 0x100;\npub const NOFLSH: ::tcflag_t = 0x80;\npub const OLCUC: ::tcflag_t = 0x2;\npub const ONLCR: ::tcflag_t = 0x4;\npub const O_ACCMODE: ::c_int = 0x3;\npub const O_APPEND: ::c_int = 0x400;\npub const O_ASYNC: ::c_int = 0o20000;\npub const O_CREAT: ::c_int = 0x40;\npub const O_DIRECT: ::c_int = 0x10000;\npub const O_DIRECTORY: ::c_int = 0x4000;\npub const O_DSYNC: ::c_int = O_SYNC;\npub const O_EXCL: ::c_int = 0x80;\npub const O_FSYNC: ::c_int = O_SYNC;\npub const O_LARGEFILE: ::c_int = 0o400000;\npub const O_NDELAY: ::c_int = O_NONBLOCK;\npub const O_NOATIME: ::c_int = 0o1000000;\npub const O_NOCTTY: ::c_int = 0x100;\npub const O_NOFOLLOW: ::c_int = 0x8000;\npub const O_NONBLOCK: ::c_int = 0x800;\npub const O_PATH: ::c_int = 0o10000000;\npub const O_RSYNC: ::c_int = O_SYNC;\npub const O_SYNC: ::c_int = 0o10000;\npub const O_TRUNC: ::c_int = 0x200;\npub const PARENB: ::tcflag_t = 0x100;\npub const PARODD: ::tcflag_t = 0x200;\npub const PENDIN: ::tcflag_t = 0x4000;\npub const POLLWRBAND: ::c_short = 0x200;\npub const POLLWRNORM: ::c_short = 0x100;\npub const PTHREAD_STACK_MIN: ::size_t = 16384;\n\n// These are typed unsigned to match sigaction\npub const SA_NOCLDSTOP: ::c_ulong = 0x1;\npub const SA_NOCLDWAIT: ::c_ulong = 0x2;\npub const SA_SIGINFO: ::c_ulong = 0x4;\npub const SA_NODEFER: ::c_ulong = 0x40000000;\npub const SA_ONSTACK: ::c_ulong = 0x8000000;\npub const SA_RESETHAND: ::c_ulong = 0x80000000;\npub const SA_RESTART: ::c_ulong = 0x10000000;\n\npub const SFD_CLOEXEC: ::c_int = 0x80000;\npub const SFD_NONBLOCK: ::c_int = 0x800;\npub const SIGBUS: ::c_int = 0x7;\npub const SIGCHLD: ::c_int = 0x11;\npub const SIGCONT: ::c_int = 0x12;\npub const SIGIO: ::c_int = 0x1d;\npub const SIGPROF: ::c_int = 0x1b;\npub const SIGPWR: ::c_int = 0x1e;\npub const SIGSTKFLT: ::c_int = 0x10;\npub const SIGSTKSZ: ::size_t = 8192;\npub const SIGSTOP: ::c_int = 0x13;\npub const SIGSYS: ::c_int = 0x1f;\npub const SIGTSTP: ::c_int = 0x14;\npub const SIGTTIN: ::c_int = 0x15;\npub const SIGTTOU: ::c_int = 0x16;\npub const SIGURG: ::c_int = 0x17;\npub const SIGUSR1: ::c_int = 0xa;\npub const SIGUSR2: ::c_int = 0xc;\npub const SIGVTALRM: ::c_int = 0x1a;\npub const SIGWINCH: ::c_int = 0x1c;\npub const SIGXCPU: ::c_int = 0x18;\npub const SIGXFSZ: ::c_int = 0x19;\npub const SIG_BLOCK: ::c_int = 0;\npub const SIG_SETMASK: ::c_int = 0x2;\npub const SIG_UNBLOCK: ::c_int = 0x1;\npub const SOCK_DGRAM: ::c_int = 0x2;\npub const SOCK_NONBLOCK: ::c_int = 0o0004000;\npub const SOCK_SEQPACKET: ::c_int = 0x5;\npub const SOCK_STREAM: ::c_int = 0x1;\n\npub const TAB1: ::c_int = 0x800;\npub const TAB2: ::c_int = 0x1000;\npub const TAB3: ::c_int = 0x1800;\npub const TABDLY: ::c_int = 0x1800;\npub const TCSADRAIN: ::c_int = 0x1;\npub const TCSAFLUSH: ::c_int = 0x2;\npub const TCSANOW: ::c_int = 0;\npub const TOSTOP: ::tcflag_t = 0x100;\npub const VDISCARD: usize = 0xd;\npub const VEOF: usize = 0x4;\npub const VEOL: usize = 0xb;\npub const VEOL2: usize = 0x10;\npub const VMIN: usize = 0x6;\npub const VREPRINT: usize = 0xc;\npub const VSTART: usize = 0x8;\npub const VSTOP: usize = 0x9;\npub const VSUSP: usize = 0xa;\npub const VSWTC: usize = 0x7;\npub const VT1: ::c_int = 0x4000;\npub const VTDLY: ::c_int = 0x4000;\npub const VTIME: usize = 0x5;\npub const VWERASE: usize = 0xe;\npub const XTABS: ::tcflag_t = 0x1800;\n\npub const MADV_SOFT_OFFLINE: ::c_int = 101;\n\n// Syscall table is copied from src/unix/notbsd/linux/musl/b32/arm.rs\npub const SYS_restart_syscall: ::c_long = 0;\npub const SYS_exit: ::c_long = 1;\npub const SYS_fork: ::c_long = 2;\npub const SYS_read: ::c_long = 3;\npub const SYS_write: ::c_long = 4;\npub const SYS_open: ::c_long = 5;\npub const SYS_close: ::c_long = 6;\npub const SYS_creat: ::c_long = 8;\npub const SYS_link: ::c_long = 9;\npub const SYS_unlink: ::c_long = 10;\npub const SYS_execve: ::c_long = 11;\npub const SYS_chdir: ::c_long = 12;\npub const SYS_mknod: ::c_long = 14;\npub const SYS_chmod: ::c_long = 15;\npub const SYS_lchown: ::c_long = 16;\npub const SYS_lseek: ::c_long = 19;\npub const SYS_getpid: ::c_long = 20;\npub const SYS_mount: ::c_long = 21;\npub const SYS_setuid: ::c_long = 23;\npub const SYS_getuid: ::c_long = 24;\npub const SYS_ptrace: ::c_long = 26;\npub const SYS_pause: ::c_long = 29;\npub const SYS_access: ::c_long = 33;\npub const SYS_nice: ::c_long = 34;\npub const SYS_sync: ::c_long = 36;\npub const SYS_kill: ::c_long = 37;\npub const SYS_rename: ::c_long = 38;\npub const SYS_mkdir: ::c_long = 39;\npub const SYS_rmdir: ::c_long = 40;\npub const SYS_dup: ::c_long = 41;\npub const SYS_pipe: ::c_long = 42;\npub const SYS_times: ::c_long = 43;\npub const SYS_brk: ::c_long = 45;\npub const SYS_setgid: ::c_long = 46;\npub const SYS_getgid: ::c_long = 47;\npub const SYS_geteuid: ::c_long = 49;\npub const SYS_getegid: ::c_long = 50;\npub const SYS_acct: ::c_long = 51;\npub const SYS_umount2: ::c_long = 52;\npub const SYS_ioctl: ::c_long = 54;\npub const SYS_fcntl: ::c_long = 55;\npub const SYS_setpgid: ::c_long = 57;\npub const SYS_umask: ::c_long = 60;\npub const SYS_chroot: ::c_long = 61;\npub const SYS_ustat: ::c_long = 62;\npub const SYS_dup2: ::c_long = 63;\npub const SYS_getppid: ::c_long = 64;\npub const SYS_getpgrp: ::c_long = 65;\npub const SYS_setsid: ::c_long = 66;\npub const SYS_sigaction: ::c_long = 67;\npub const SYS_setreuid: ::c_long = 70;\npub const SYS_setregid: ::c_long = 71;\npub const SYS_sigsuspend: ::c_long = 72;\npub const SYS_sigpending: ::c_long = 73;\npub const SYS_sethostname: ::c_long = 74;\npub const SYS_setrlimit: ::c_long = 75;\npub const SYS_getrusage: ::c_long = 77;\npub const SYS_gettimeofday: ::c_long = 78;\npub const SYS_settimeofday: ::c_long = 79;\npub const SYS_getgroups: ::c_long = 80;\npub const SYS_setgroups: ::c_long = 81;\npub const SYS_symlink: ::c_long = 83;\npub const SYS_readlink: ::c_long = 85;\npub const SYS_uselib: ::c_long = 86;\npub const SYS_swapon: ::c_long = 87;\npub const SYS_reboot: ::c_long = 88;\npub const SYS_munmap: ::c_long = 91;\npub const SYS_truncate: ::c_long = 92;\npub const SYS_ftruncate: ::c_long = 93;\npub const SYS_fchmod: ::c_long = 94;\npub const SYS_fchown: ::c_long = 95;\npub const SYS_getpriority: ::c_long = 96;\npub const SYS_setpriority: ::c_long = 97;\npub const SYS_statfs: ::c_long = 99;\npub const SYS_fstatfs: ::c_long = 100;\npub const SYS_syslog: ::c_long = 103;\npub const SYS_setitimer: ::c_long = 104;\npub const SYS_getitimer: ::c_long = 105;\npub const SYS_stat: ::c_long = 106;\npub const SYS_lstat: ::c_long = 107;\npub const SYS_fstat: ::c_long = 108;\npub const SYS_vhangup: ::c_long = 111;\npub const SYS_wait4: ::c_long = 114;\npub const SYS_swapoff: ::c_long = 115;\npub const SYS_sysinfo: ::c_long = 116;\npub const SYS_fsync: ::c_long = 118;\npub const SYS_sigreturn: ::c_long = 119;\npub const SYS_clone: ::c_long = 120;\npub const SYS_setdomainname: ::c_long = 121;\npub const SYS_uname: ::c_long = 122;\npub const SYS_adjtimex: ::c_long = 124;\npub const SYS_mprotect: ::c_long = 125;\npub const SYS_sigprocmask: ::c_long = 126;\npub const SYS_init_module: ::c_long = 128;\npub const SYS_delete_module: ::c_long = 129;\npub const SYS_quotactl: ::c_long = 131;\npub const SYS_getpgid: ::c_long = 132;\npub const SYS_fchdir: ::c_long = 133;\npub const SYS_bdflush: ::c_long = 134;\npub const SYS_sysfs: ::c_long = 135;\npub const SYS_personality: ::c_long = 136;\npub const SYS_setfsuid: ::c_long = 138;\npub const SYS_setfsgid: ::c_long = 139;\npub const SYS__llseek: ::c_long = 140;\npub const SYS_getdents: ::c_long = 141;\npub const SYS__newselect: ::c_long = 142;\npub const SYS_flock: ::c_long = 143;\npub const SYS_msync: ::c_long = 144;\npub const SYS_readv: ::c_long = 145;\npub const SYS_writev: ::c_long = 146;\npub const SYS_getsid: ::c_long = 147;\npub const SYS_fdatasync: ::c_long = 148;\npub const SYS__sysctl: ::c_long = 149;\npub const SYS_mlock: ::c_long = 150;\npub const SYS_munlock: ::c_long = 151;\npub const SYS_mlockall: ::c_long = 152;\npub const SYS_munlockall: ::c_long = 153;\npub const SYS_sched_setparam: ::c_long = 154;\npub const SYS_sched_getparam: ::c_long = 155;\npub const SYS_sched_setscheduler: ::c_long = 156;\npub const SYS_sched_getscheduler: ::c_long = 157;\npub const SYS_sched_yield: ::c_long = 158;\npub const SYS_sched_get_priority_max: ::c_long = 159;\npub const SYS_sched_get_priority_min: ::c_long = 160;\npub const SYS_sched_rr_get_interval: ::c_long = 161;\npub const SYS_nanosleep: ::c_long = 162;\npub const SYS_mremap: ::c_long = 163;\npub const SYS_setresuid: ::c_long = 164;\npub const SYS_getresuid: ::c_long = 165;\npub const SYS_poll: ::c_long = 168;\npub const SYS_nfsservctl: ::c_long = 169;\npub const SYS_setresgid: ::c_long = 170;\npub const SYS_getresgid: ::c_long = 171;\npub const SYS_prctl: ::c_long = 172;\npub const SYS_rt_sigreturn: ::c_long = 173;\npub const SYS_rt_sigaction: ::c_long = 174;\npub const SYS_rt_sigprocmask: ::c_long = 175;\npub const SYS_rt_sigpending: ::c_long = 176;\npub const SYS_rt_sigtimedwait: ::c_long = 177;\npub const SYS_rt_sigqueueinfo: ::c_long = 178;\npub const SYS_rt_sigsuspend: ::c_long = 179;\npub const SYS_pread64: ::c_long = 180;\npub const SYS_pwrite64: ::c_long = 181;\npub const SYS_chown: ::c_long = 182;\npub const SYS_getcwd: ::c_long = 183;\npub const SYS_capget: ::c_long = 184;\npub const SYS_capset: ::c_long = 185;\npub const SYS_sigaltstack: ::c_long = 186;\npub const SYS_sendfile: ::c_long = 187;\npub const SYS_vfork: ::c_long = 190;\npub const SYS_ugetrlimit: ::c_long = 191;\npub const SYS_mmap2: ::c_long = 192;\npub const SYS_truncate64: ::c_long = 193;\npub const SYS_ftruncate64: ::c_long = 194;\npub const SYS_stat64: ::c_long = 195;\npub const SYS_lstat64: ::c_long = 196;\npub const SYS_fstat64: ::c_long = 197;\npub const SYS_lchown32: ::c_long = 198;\npub const SYS_getuid32: ::c_long = 199;\npub const SYS_getgid32: ::c_long = 200;\npub const SYS_geteuid32: ::c_long = 201;\npub const SYS_getegid32: ::c_long = 202;\npub const SYS_setreuid32: ::c_long = 203;\npub const SYS_setregid32: ::c_long = 204;\npub const SYS_getgroups32: ::c_long = 205;\npub const SYS_setgroups32: ::c_long = 206;\npub const SYS_fchown32: ::c_long = 207;\npub const SYS_setresuid32: ::c_long = 208;\npub const SYS_getresuid32: ::c_long = 209;\npub const SYS_setresgid32: ::c_long = 210;\npub const SYS_getresgid32: ::c_long = 211;\npub const SYS_chown32: ::c_long = 212;\npub const SYS_setuid32: ::c_long = 213;\npub const SYS_setgid32: ::c_long = 214;\npub const SYS_setfsuid32: ::c_long = 215;\npub const SYS_setfsgid32: ::c_long = 216;\npub const SYS_getdents64: ::c_long = 217;\npub const SYS_pivot_root: ::c_long = 218;\npub const SYS_mincore: ::c_long = 219;\npub const SYS_madvise: ::c_long = 220;\npub const SYS_fcntl64: ::c_long = 221;\npub const SYS_gettid: ::c_long = 224;\npub const SYS_readahead: ::c_long = 225;\npub const SYS_setxattr: ::c_long = 226;\npub const SYS_lsetxattr: ::c_long = 227;\npub const SYS_fsetxattr: ::c_long = 228;\npub const SYS_getxattr: ::c_long = 229;\npub const SYS_lgetxattr: ::c_long = 230;\npub const SYS_fgetxattr: ::c_long = 231;\npub const SYS_listxattr: ::c_long = 232;\npub const SYS_llistxattr: ::c_long = 233;\npub const SYS_flistxattr: ::c_long = 234;\npub const SYS_removexattr: ::c_long = 235;\npub const SYS_lremovexattr: ::c_long = 236;\npub const SYS_fremovexattr: ::c_long = 237;\npub const SYS_tkill: ::c_long = 238;\npub const SYS_sendfile64: ::c_long = 239;\npub const SYS_futex: ::c_long = 240;\npub const SYS_sched_setaffinity: ::c_long = 241;\npub const SYS_sched_getaffinity: ::c_long = 242;\npub const SYS_io_setup: ::c_long = 243;\npub const SYS_io_destroy: ::c_long = 244;\npub const SYS_io_getevents: ::c_long = 245;\npub const SYS_io_submit: ::c_long = 246;\npub const SYS_io_cancel: ::c_long = 247;\npub const SYS_exit_group: ::c_long = 248;\npub const SYS_lookup_dcookie: ::c_long = 249;\npub const SYS_epoll_create: ::c_long = 250;\npub const SYS_epoll_ctl: ::c_long = 251;\npub const SYS_epoll_wait: ::c_long = 252;\npub const SYS_remap_file_pages: ::c_long = 253;\npub const SYS_set_tid_address: ::c_long = 256;\npub const SYS_timer_create: ::c_long = 257;\npub const SYS_timer_settime: ::c_long = 258;\npub const SYS_timer_gettime: ::c_long = 259;\npub const SYS_timer_getoverrun: ::c_long = 260;\npub const SYS_timer_delete: ::c_long = 261;\npub const SYS_clock_settime: ::c_long = 262;\npub const SYS_clock_gettime: ::c_long = 263;\npub const SYS_clock_getres: ::c_long = 264;\npub const SYS_clock_nanosleep: ::c_long = 265;\npub const SYS_statfs64: ::c_long = 266;\npub const SYS_fstatfs64: ::c_long = 267;\npub const SYS_tgkill: ::c_long = 268;\npub const SYS_utimes: ::c_long = 269;\npub const SYS_pciconfig_iobase: ::c_long = 271;\npub const SYS_pciconfig_read: ::c_long = 272;\npub const SYS_pciconfig_write: ::c_long = 273;\npub const SYS_mq_open: ::c_long = 274;\npub const SYS_mq_unlink: ::c_long = 275;\npub const SYS_mq_timedsend: ::c_long = 276;\npub const SYS_mq_timedreceive: ::c_long = 277;\npub const SYS_mq_notify: ::c_long = 278;\npub const SYS_mq_getsetattr: ::c_long = 279;\npub const SYS_waitid: ::c_long = 280;\npub const SYS_socket: ::c_long = 281;\npub const SYS_bind: ::c_long = 282;\npub const SYS_connect: ::c_long = 283;\npub const SYS_listen: ::c_long = 284;\npub const SYS_accept: ::c_long = 285;\npub const SYS_getsockname: ::c_long = 286;\npub const SYS_getpeername: ::c_long = 287;\npub const SYS_socketpair: ::c_long = 288;\npub const SYS_send: ::c_long = 289;\npub const SYS_sendto: ::c_long = 290;\npub const SYS_recv: ::c_long = 291;\npub const SYS_recvfrom: ::c_long = 292;\npub const SYS_shutdown: ::c_long = 293;\npub const SYS_setsockopt: ::c_long = 294;\npub const SYS_getsockopt: ::c_long = 295;\npub const SYS_sendmsg: ::c_long = 296;\npub const SYS_recvmsg: ::c_long = 297;\npub const SYS_semop: ::c_long = 298;\npub const SYS_semget: ::c_long = 299;\npub const SYS_semctl: ::c_long = 300;\npub const SYS_msgsnd: ::c_long = 301;\npub const SYS_msgrcv: ::c_long = 302;\npub const SYS_msgget: ::c_long = 303;\npub const SYS_msgctl: ::c_long = 304;\npub const SYS_shmat: ::c_long = 305;\npub const SYS_shmdt: ::c_long = 306;\npub const SYS_shmget: ::c_long = 307;\npub const SYS_shmctl: ::c_long = 308;\npub const SYS_add_key: ::c_long = 309;\npub const SYS_request_key: ::c_long = 310;\npub const SYS_keyctl: ::c_long = 311;\npub const SYS_semtimedop: ::c_long = 312;\npub const SYS_vserver: ::c_long = 313;\npub const SYS_ioprio_set: ::c_long = 314;\npub const SYS_ioprio_get: ::c_long = 315;\npub const SYS_inotify_init: ::c_long = 316;\npub const SYS_inotify_add_watch: ::c_long = 317;\npub const SYS_inotify_rm_watch: ::c_long = 318;\npub const SYS_mbind: ::c_long = 319;\npub const SYS_get_mempolicy: ::c_long = 320;\npub const SYS_set_mempolicy: ::c_long = 321;\npub const SYS_openat: ::c_long = 322;\npub const SYS_mkdirat: ::c_long = 323;\npub const SYS_mknodat: ::c_long = 324;\npub const SYS_fchownat: ::c_long = 325;\npub const SYS_futimesat: ::c_long = 326;\npub const SYS_fstatat64: ::c_long = 327;\npub const SYS_unlinkat: ::c_long = 328;\npub const SYS_renameat: ::c_long = 329;\npub const SYS_linkat: ::c_long = 330;\npub const SYS_symlinkat: ::c_long = 331;\npub const SYS_readlinkat: ::c_long = 332;\npub const SYS_fchmodat: ::c_long = 333;\npub const SYS_faccessat: ::c_long = 334;\npub const SYS_pselect6: ::c_long = 335;\npub const SYS_ppoll: ::c_long = 336;\npub const SYS_unshare: ::c_long = 337;\npub const SYS_set_robust_list: ::c_long = 338;\npub const SYS_get_robust_list: ::c_long = 339;\npub const SYS_splice: ::c_long = 340;\npub const SYS_tee: ::c_long = 342;\npub const SYS_vmsplice: ::c_long = 343;\npub const SYS_move_pages: ::c_long = 344;\npub const SYS_getcpu: ::c_long = 345;\npub const SYS_epoll_pwait: ::c_long = 346;\npub const SYS_kexec_load: ::c_long = 347;\npub const SYS_utimensat: ::c_long = 348;\npub const SYS_signalfd: ::c_long = 349;\npub const SYS_timerfd_create: ::c_long = 350;\npub const SYS_eventfd: ::c_long = 351;\npub const SYS_fallocate: ::c_long = 352;\npub const SYS_timerfd_settime: ::c_long = 353;\npub const SYS_timerfd_gettime: ::c_long = 354;\npub const SYS_signalfd4: ::c_long = 355;\npub const SYS_eventfd2: ::c_long = 356;\npub const SYS_epoll_create1: ::c_long = 357;\npub const SYS_dup3: ::c_long = 358;\npub const SYS_pipe2: ::c_long = 359;\npub const SYS_inotify_init1: ::c_long = 360;\npub const SYS_preadv: ::c_long = 361;\npub const SYS_pwritev: ::c_long = 362;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 363;\npub const SYS_perf_event_open: ::c_long = 364;\npub const SYS_recvmmsg: ::c_long = 365;\npub const SYS_accept4: ::c_long = 366;\npub const SYS_fanotify_init: ::c_long = 367;\npub const SYS_fanotify_mark: ::c_long = 368;\npub const SYS_prlimit64: ::c_long = 369;\npub const SYS_name_to_handle_at: ::c_long = 370;\npub const SYS_open_by_handle_at: ::c_long = 371;\npub const SYS_clock_adjtime: ::c_long = 372;\npub const SYS_syncfs: ::c_long = 373;\npub const SYS_sendmmsg: ::c_long = 374;\npub const SYS_setns: ::c_long = 375;\npub const SYS_process_vm_readv: ::c_long = 376;\npub const SYS_process_vm_writev: ::c_long = 377;\npub const SYS_kcmp: ::c_long = 378;\npub const SYS_finit_module: ::c_long = 379;\npub const SYS_sched_setattr: ::c_long = 380;\npub const SYS_sched_getattr: ::c_long = 381;\npub const SYS_renameat2: ::c_long = 382;\npub const SYS_seccomp: ::c_long = 383;\npub const SYS_getrandom: ::c_long = 384;\npub const SYS_memfd_create: ::c_long = 385;\npub const SYS_bpf: ::c_long = 386;\npub const SYS_execveat: ::c_long = 387;\npub const SYS_userfaultfd: ::c_long = 388;\npub const SYS_membarrier: ::c_long = 389;\npub const SYS_mlock2: ::c_long = 390;\npub const SYS_copy_file_range: ::c_long = 391;\npub const SYS_preadv2: ::c_long = 392;\npub const SYS_pwritev2: ::c_long = 393;\npub const SYS_pkey_mprotect: ::c_long = 394;\npub const SYS_pkey_alloc: ::c_long = 395;\npub const SYS_pkey_free: ::c_long = 396;\n\nextern \"C\" {\n    pub fn ioctl(fd: ::c_int, request: ::c_ulong, ...) -> ::c_int;\n}\n\ncfg_if! {\n    if #[cfg(libc_align)] {\n        mod align;\n        pub use self::align::*;\n    } else {\n        mod no_align;\n        pub use self::no_align::*;\n    }\n}\n"],["1164","s! {\n    // FIXME this is actually a union\n    pub struct sem_t {\n        #[cfg(target_pointer_width = \"32\")]\n        __size: [::c_char; 16],\n        #[cfg(target_pointer_width = \"64\")]\n        __size: [::c_char; 32],\n        __align: [::c_long; 0],\n    }\n}\n"],["1165","pub type pthread_t = c_ulong;\npub type __priority_which_t = ::c_uint;\npub type __rlimit_resource_t = ::c_uint;\npub type Lmid_t = ::c_long;\npub type regoff_t = ::c_int;\n\ns! {\n    pub struct statx {\n        pub stx_mask: u32,\n        pub stx_blksize: u32,\n        pub stx_attributes: u64,\n        pub stx_nlink: u32,\n        pub stx_uid: u32,\n        pub stx_gid: u32,\n        pub stx_mode: u16,\n        __statx_pad1: [u16; 1],\n        pub stx_ino: u64,\n        pub stx_size: u64,\n        pub stx_blocks: u64,\n        pub stx_attributes_mask: u64,\n        pub stx_atime: ::statx_timestamp,\n        pub stx_btime: ::statx_timestamp,\n        pub stx_ctime: ::statx_timestamp,\n        pub stx_mtime: ::statx_timestamp,\n        pub stx_rdev_major: u32,\n        pub stx_rdev_minor: u32,\n        pub stx_dev_major: u32,\n        pub stx_dev_minor: u32,\n        pub stx_mnt_id: u64,\n        __statx_pad2: u64,\n        __statx_pad3: [u64; 12],\n    }\n\n    pub struct statx_timestamp {\n        pub tv_sec: i64,\n        pub tv_nsec: u32,\n        pub __statx_timestamp_pad1: [i32; 1],\n    }\n\n    pub struct aiocb {\n        pub aio_fildes: ::c_int,\n        pub aio_lio_opcode: ::c_int,\n        pub aio_reqprio: ::c_int,\n        pub aio_buf: *mut ::c_void,\n        pub aio_nbytes: ::size_t,\n        pub aio_sigevent: ::sigevent,\n        __next_prio: *mut aiocb,\n        __abs_prio: ::c_int,\n        __policy: ::c_int,\n        __error_code: ::c_int,\n        __return_value: ::ssize_t,\n        pub aio_offset: off_t,\n        #[cfg(all(not(target_arch = \"x86_64\"), target_pointer_width = \"32\"))]\n        __unused1: [::c_char; 4],\n        __glibc_reserved: [::c_char; 32]\n    }\n\n    pub struct __exit_status {\n        pub e_termination: ::c_short,\n        pub e_exit: ::c_short,\n    }\n\n    pub struct __timeval {\n        pub tv_sec: i32,\n        pub tv_usec: i32,\n    }\n\n    pub struct glob64_t {\n        pub gl_pathc: ::size_t,\n        pub gl_pathv: *mut *mut ::c_char,\n        pub gl_offs: ::size_t,\n        pub gl_flags: ::c_int,\n\n        __unused1: *mut ::c_void,\n        __unused2: *mut ::c_void,\n        __unused3: *mut ::c_void,\n        __unused4: *mut ::c_void,\n        __unused5: *mut ::c_void,\n    }\n\n    pub struct msghdr {\n        pub msg_name: *mut ::c_void,\n        pub msg_namelen: ::socklen_t,\n        pub msg_iov: *mut ::iovec,\n        pub msg_iovlen: ::size_t,\n        pub msg_control: *mut ::c_void,\n        pub msg_controllen: ::size_t,\n        pub msg_flags: ::c_int,\n    }\n\n    pub struct cmsghdr {\n        pub cmsg_len: ::size_t,\n        pub cmsg_level: ::c_int,\n        pub cmsg_type: ::c_int,\n    }\n\n    pub struct termios {\n        pub c_iflag: ::tcflag_t,\n        pub c_oflag: ::tcflag_t,\n        pub c_cflag: ::tcflag_t,\n        pub c_lflag: ::tcflag_t,\n        pub c_line: ::cc_t,\n        pub c_cc: [::cc_t; ::NCCS],\n        #[cfg(not(any(\n            target_arch = \"sparc\",\n            target_arch = \"sparc64\",\n            target_arch = \"mips\",\n            target_arch = \"mips64\")))]\n        pub c_ispeed: ::speed_t,\n        #[cfg(not(any(\n            target_arch = \"sparc\",\n            target_arch = \"sparc64\",\n            target_arch = \"mips\",\n            target_arch = \"mips64\")))]\n        pub c_ospeed: ::speed_t,\n    }\n\n    pub struct mallinfo {\n        pub arena: ::c_int,\n        pub ordblks: ::c_int,\n        pub smblks: ::c_int,\n        pub hblks: ::c_int,\n        pub hblkhd: ::c_int,\n        pub usmblks: ::c_int,\n        pub fsmblks: ::c_int,\n        pub uordblks: ::c_int,\n        pub fordblks: ::c_int,\n        pub keepcost: ::c_int,\n    }\n\n    pub struct nlmsghdr {\n        pub nlmsg_len: u32,\n        pub nlmsg_type: u16,\n        pub nlmsg_flags: u16,\n        pub nlmsg_seq: u32,\n        pub nlmsg_pid: u32,\n    }\n\n    pub struct nlmsgerr {\n        pub error: ::c_int,\n        pub msg: nlmsghdr,\n    }\n\n    pub struct nl_pktinfo {\n        pub group: u32,\n    }\n\n    pub struct nl_mmap_req {\n        pub nm_block_size: ::c_uint,\n        pub nm_block_nr: ::c_uint,\n        pub nm_frame_size: ::c_uint,\n        pub nm_frame_nr: ::c_uint,\n    }\n\n    pub struct nl_mmap_hdr {\n        pub nm_status: ::c_uint,\n        pub nm_len: ::c_uint,\n        pub nm_group: u32,\n        pub nm_pid: u32,\n        pub nm_uid: u32,\n        pub nm_gid: u32,\n    }\n\n    pub struct nlattr {\n        pub nla_len: u16,\n        pub nla_type: u16,\n    }\n\n    pub struct rtentry {\n        pub rt_pad1: ::c_ulong,\n        pub rt_dst: ::sockaddr,\n        pub rt_gateway: ::sockaddr,\n        pub rt_genmask: ::sockaddr,\n        pub rt_flags: ::c_ushort,\n        pub rt_pad2: ::c_short,\n        pub rt_pad3: ::c_ulong,\n        pub rt_tos: ::c_uchar,\n        pub rt_class: ::c_uchar,\n        #[cfg(target_pointer_width = \"64\")]\n        pub rt_pad4: [::c_short; 3usize],\n        #[cfg(not(target_pointer_width = \"64\"))]\n        pub rt_pad4: ::c_short,\n        pub rt_metric: ::c_short,\n        pub rt_dev: *mut ::c_char,\n        pub rt_mtu: ::c_ulong,\n        pub rt_window: ::c_ulong,\n        pub rt_irtt: ::c_ushort,\n    }\n\n    pub struct timex {\n        pub modes: ::c_uint,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        pub offset: i64,\n        #[cfg(not(all(target_arch = \"x86_64\", target_pointer_width = \"32\")))]\n        pub offset: ::c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        pub freq: i64,\n        #[cfg(not(all(target_arch = \"x86_64\", target_pointer_width = \"32\")))]\n        pub freq: ::c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        pub maxerror: i64,\n        #[cfg(not(all(target_arch = \"x86_64\", target_pointer_width = \"32\")))]\n        pub maxerror: ::c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        pub esterror: i64,\n        #[cfg(not(all(target_arch = \"x86_64\", target_pointer_width = \"32\")))]\n        pub esterror: ::c_long,\n        pub status: ::c_int,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        pub constant: i64,\n        #[cfg(not(all(target_arch = \"x86_64\", target_pointer_width = \"32\")))]\n        pub constant: ::c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        pub precision: i64,\n        #[cfg(not(all(target_arch = \"x86_64\", target_pointer_width = \"32\")))]\n        pub precision: ::c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        pub tolerance: i64,\n        #[cfg(not(all(target_arch = \"x86_64\", target_pointer_width = \"32\")))]\n        pub tolerance: ::c_long,\n        pub time: ::timeval,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        pub tick: i64,\n        #[cfg(not(all(target_arch = \"x86_64\", target_pointer_width = \"32\")))]\n        pub tick: ::c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        pub ppsfreq: i64,\n        #[cfg(not(all(target_arch = \"x86_64\", target_pointer_width = \"32\")))]\n        pub ppsfreq: ::c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        pub jitter: i64,\n        #[cfg(not(all(target_arch = \"x86_64\", target_pointer_width = \"32\")))]\n        pub jitter: ::c_long,\n        pub shift: ::c_int,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        pub stabil: i64,\n        #[cfg(not(all(target_arch = \"x86_64\", target_pointer_width = \"32\")))]\n        pub stabil: ::c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        pub jitcnt: i64,\n        #[cfg(not(all(target_arch = \"x86_64\", target_pointer_width = \"32\")))]\n        pub jitcnt: ::c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        pub calcnt: i64,\n        #[cfg(not(all(target_arch = \"x86_64\", target_pointer_width = \"32\")))]\n        pub calcnt: ::c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        pub errcnt: i64,\n        #[cfg(not(all(target_arch = \"x86_64\", target_pointer_width = \"32\")))]\n        pub errcnt: ::c_long,\n        #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\n        pub stbcnt: i64,\n        #[cfg(not(all(target_arch = \"x86_64\", target_pointer_width = \"32\")))]\n        pub stbcnt: ::c_long,\n        pub tai: ::c_int,\n        pub __unused1: i32,\n        pub __unused2: i32,\n        pub __unused3: i32,\n        pub __unused4: i32,\n        pub __unused5: i32,\n        pub __unused6: i32,\n        pub __unused7: i32,\n        pub __unused8: i32,\n        pub __unused9: i32,\n        pub __unused10: i32,\n        pub __unused11: i32,\n    }\n\n    pub struct ntptimeval {\n        pub time: ::timeval,\n        pub maxerror: ::c_long,\n        pub esterror: ::c_long,\n        pub tai: ::c_long,\n        pub __glibc_reserved1: ::c_long,\n        pub __glibc_reserved2: ::c_long,\n        pub __glibc_reserved3: ::c_long,\n        pub __glibc_reserved4: ::c_long,\n    }\n\n    pub struct regex_t {\n        __buffer: *mut ::c_void,\n        __allocated: ::size_t,\n        __used: ::size_t,\n        __syntax: ::c_ulong,\n        __fastmap: *mut ::c_char,\n        __translate: *mut ::c_char,\n        __re_nsub: ::size_t,\n        __bitfield: u8,\n    }\n\n    pub struct Elf64_Chdr {\n        pub ch_type: ::Elf64_Word,\n        pub ch_reserved: ::Elf64_Word,\n        pub ch_size: ::Elf64_Xword,\n        pub ch_addralign: ::Elf64_Xword,\n    }\n\n    pub struct Elf32_Chdr {\n        pub ch_type: ::Elf32_Word,\n        pub ch_size: ::Elf32_Word,\n        pub ch_addralign: ::Elf32_Word,\n    }\n}\n\nimpl siginfo_t {\n    pub unsafe fn si_addr(&self) -> *mut ::c_void {\n        #[repr(C)]\n        struct siginfo_sigfault {\n            _si_signo: ::c_int,\n            _si_errno: ::c_int,\n            _si_code: ::c_int,\n            si_addr: *mut ::c_void,\n        }\n        (*(self as *const siginfo_t as *const siginfo_sigfault)).si_addr\n    }\n\n    pub unsafe fn si_value(&self) -> ::sigval {\n        #[repr(C)]\n        struct siginfo_timer {\n            _si_signo: ::c_int,\n            _si_errno: ::c_int,\n            _si_code: ::c_int,\n            _si_tid: ::c_int,\n            _si_overrun: ::c_int,\n            si_sigval: ::sigval,\n        }\n        (*(self as *const siginfo_t as *const siginfo_timer)).si_sigval\n    }\n}\n\ncfg_if! {\n    if #[cfg(libc_union)] {\n        // Internal, for casts to access union fields\n        #[repr(C)]\n        struct sifields_sigchld {\n            si_pid: ::pid_t,\n            si_uid: ::uid_t,\n            si_status: ::c_int,\n            si_utime: ::c_long,\n            si_stime: ::c_long,\n        }\n        impl ::Copy for sifields_sigchld {}\n        impl ::Clone for sifields_sigchld {\n            fn clone(&self) -> sifields_sigchld {\n                *self\n            }\n        }\n\n        // Internal, for casts to access union fields\n        #[repr(C)]\n        union sifields {\n            _align_pointer: *mut ::c_void,\n            sigchld: sifields_sigchld,\n        }\n\n        // Internal, for casts to access union fields. Note that some variants\n        // of sifields start with a pointer, which makes the alignment of\n        // sifields vary on 32-bit and 64-bit architectures.\n        #[repr(C)]\n        struct siginfo_f {\n            _siginfo_base: [::c_int; 3],\n            sifields: sifields,\n        }\n\n        impl siginfo_t {\n            unsafe fn sifields(&self) -> &sifields {\n                &(*(self as *const siginfo_t as *const siginfo_f)).sifields\n            }\n\n            pub unsafe fn si_pid(&self) -> ::pid_t {\n                self.sifields().sigchld.si_pid\n            }\n\n            pub unsafe fn si_uid(&self) -> ::uid_t {\n                self.sifields().sigchld.si_uid\n            }\n\n            pub unsafe fn si_status(&self) -> ::c_int {\n                self.sifields().sigchld.si_status\n            }\n\n            pub unsafe fn si_utime(&self) -> ::c_long {\n                self.sifields().sigchld.si_utime\n            }\n\n            pub unsafe fn si_stime(&self) -> ::c_long {\n                self.sifields().sigchld.si_stime\n            }\n        }\n    }\n}\n\ns_no_extra_traits! {\n    pub struct utmpx {\n        pub ut_type: ::c_short,\n        pub ut_pid: ::pid_t,\n        pub ut_line: [::c_char; __UT_LINESIZE],\n        pub ut_id: [::c_char; 4],\n\n        pub ut_user: [::c_char; __UT_NAMESIZE],\n        pub ut_host: [::c_char; __UT_HOSTSIZE],\n        pub ut_exit: __exit_status,\n\n        #[cfg(any(target_arch = \"aarch64\",\n                  target_arch = \"s390x\",\n                  all(target_pointer_width = \"32\",\n                      not(target_arch = \"x86_64\"))))]\n        pub ut_session: ::c_long,\n        #[cfg(any(target_arch = \"aarch64\",\n                  target_arch = \"s390x\",\n                  all(target_pointer_width = \"32\",\n                      not(target_arch = \"x86_64\"))))]\n        pub ut_tv: ::timeval,\n\n        #[cfg(not(any(target_arch = \"aarch64\",\n                      target_arch = \"s390x\",\n                      all(target_pointer_width = \"32\",\n                          not(target_arch = \"x86_64\")))))]\n        pub ut_session: i32,\n        #[cfg(not(any(target_arch = \"aarch64\",\n                      target_arch = \"s390x\",\n                      all(target_pointer_width = \"32\",\n                          not(target_arch = \"x86_64\")))))]\n        pub ut_tv: __timeval,\n\n        pub ut_addr_v6: [i32; 4],\n        __glibc_reserved: [::c_char; 20],\n    }\n}\n\ncfg_if! {\n    if #[cfg(feature = \"extra_traits\")] {\n        impl PartialEq for utmpx {\n            fn eq(&self, other: &utmpx) -> bool {\n                self.ut_type == other.ut_type\n                    && self.ut_pid == other.ut_pid\n                    && self.ut_line == other.ut_line\n                    && self.ut_id == other.ut_id\n                    && self.ut_user == other.ut_user\n                    && self\n                    .ut_host\n                    .iter()\n                    .zip(other.ut_host.iter())\n                    .all(|(a,b)| a == b)\n                    && self.ut_exit == other.ut_exit\n                    && self.ut_session == other.ut_session\n                    && self.ut_tv == other.ut_tv\n                    && self.ut_addr_v6 == other.ut_addr_v6\n                    && self.__glibc_reserved == other.__glibc_reserved\n            }\n        }\n\n        impl Eq for utmpx {}\n\n        impl ::fmt::Debug for utmpx {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"utmpx\")\n                    .field(\"ut_type\", &self.ut_type)\n                    .field(\"ut_pid\", &self.ut_pid)\n                    .field(\"ut_line\", &self.ut_line)\n                    .field(\"ut_id\", &self.ut_id)\n                    .field(\"ut_user\", &self.ut_user)\n                // FIXME: .field(\"ut_host\", &self.ut_host)\n                    .field(\"ut_exit\", &self.ut_exit)\n                    .field(\"ut_session\", &self.ut_session)\n                    .field(\"ut_tv\", &self.ut_tv)\n                    .field(\"ut_addr_v6\", &self.ut_addr_v6)\n                    .field(\"__glibc_reserved\", &self.__glibc_reserved)\n                    .finish()\n            }\n        }\n\n        impl ::hash::Hash for utmpx {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.ut_type.hash(state);\n                self.ut_pid.hash(state);\n                self.ut_line.hash(state);\n                self.ut_id.hash(state);\n                self.ut_user.hash(state);\n                self.ut_host.hash(state);\n                self.ut_exit.hash(state);\n                self.ut_session.hash(state);\n                self.ut_tv.hash(state);\n                self.ut_addr_v6.hash(state);\n                self.__glibc_reserved.hash(state);\n            }\n        }\n    }\n}\n\n// include/uapi/asm-generic/hugetlb_encode.h\npub const HUGETLB_FLAG_ENCODE_SHIFT: ::c_int = 26;\npub const HUGETLB_FLAG_ENCODE_MASK: ::c_int = 0x3f;\n\npub const HUGETLB_FLAG_ENCODE_64KB: ::c_int = 16 << HUGETLB_FLAG_ENCODE_SHIFT;\npub const HUGETLB_FLAG_ENCODE_512KB: ::c_int = 19 << HUGETLB_FLAG_ENCODE_SHIFT;\npub const HUGETLB_FLAG_ENCODE_1MB: ::c_int = 20 << HUGETLB_FLAG_ENCODE_SHIFT;\npub const HUGETLB_FLAG_ENCODE_2MB: ::c_int = 21 << HUGETLB_FLAG_ENCODE_SHIFT;\npub const HUGETLB_FLAG_ENCODE_8MB: ::c_int = 23 << HUGETLB_FLAG_ENCODE_SHIFT;\npub const HUGETLB_FLAG_ENCODE_16MB: ::c_int = 24 << HUGETLB_FLAG_ENCODE_SHIFT;\npub const HUGETLB_FLAG_ENCODE_32MB: ::c_int = 25 << HUGETLB_FLAG_ENCODE_SHIFT;\npub const HUGETLB_FLAG_ENCODE_256MB: ::c_int = 28 << HUGETLB_FLAG_ENCODE_SHIFT;\npub const HUGETLB_FLAG_ENCODE_512MB: ::c_int = 29 << HUGETLB_FLAG_ENCODE_SHIFT;\npub const HUGETLB_FLAG_ENCODE_1GB: ::c_int = 30 << HUGETLB_FLAG_ENCODE_SHIFT;\npub const HUGETLB_FLAG_ENCODE_2GB: ::c_int = 31 << HUGETLB_FLAG_ENCODE_SHIFT;\npub const HUGETLB_FLAG_ENCODE_16GB: ::c_int = 34 << HUGETLB_FLAG_ENCODE_SHIFT;\n\n// include/uapi/linux/mman.h\n/*\n * Huge page size encoding when MAP_HUGETLB is specified, and a huge page\n * size other than the default is desired.  See hugetlb_encode.h.\n * All known huge page size encodings are provided here.  It is the\n * responsibility of the application to know which sizes are supported on\n * the running system.  See mmap(2) man page for details.\n */\npub const MAP_HUGE_SHIFT: ::c_int = HUGETLB_FLAG_ENCODE_SHIFT;\npub const MAP_HUGE_MASK: ::c_int = HUGETLB_FLAG_ENCODE_MASK;\n\npub const MAP_HUGE_64KB: ::c_int = HUGETLB_FLAG_ENCODE_64KB;\npub const MAP_HUGE_512KB: ::c_int = HUGETLB_FLAG_ENCODE_512KB;\npub const MAP_HUGE_1MB: ::c_int = HUGETLB_FLAG_ENCODE_1MB;\npub const MAP_HUGE_2MB: ::c_int = HUGETLB_FLAG_ENCODE_2MB;\npub const MAP_HUGE_8MB: ::c_int = HUGETLB_FLAG_ENCODE_8MB;\npub const MAP_HUGE_16MB: ::c_int = HUGETLB_FLAG_ENCODE_16MB;\npub const MAP_HUGE_32MB: ::c_int = HUGETLB_FLAG_ENCODE_32MB;\npub const MAP_HUGE_256MB: ::c_int = HUGETLB_FLAG_ENCODE_256MB;\npub const MAP_HUGE_512MB: ::c_int = HUGETLB_FLAG_ENCODE_512MB;\npub const MAP_HUGE_1GB: ::c_int = HUGETLB_FLAG_ENCODE_1GB;\npub const MAP_HUGE_2GB: ::c_int = HUGETLB_FLAG_ENCODE_2GB;\npub const MAP_HUGE_16GB: ::c_int = HUGETLB_FLAG_ENCODE_16GB;\n\npub const RLIMIT_CPU: ::__rlimit_resource_t = 0;\npub const RLIMIT_FSIZE: ::__rlimit_resource_t = 1;\npub const RLIMIT_DATA: ::__rlimit_resource_t = 2;\npub const RLIMIT_STACK: ::__rlimit_resource_t = 3;\npub const RLIMIT_CORE: ::__rlimit_resource_t = 4;\npub const RLIMIT_LOCKS: ::__rlimit_resource_t = 10;\npub const RLIMIT_SIGPENDING: ::__rlimit_resource_t = 11;\npub const RLIMIT_MSGQUEUE: ::__rlimit_resource_t = 12;\npub const RLIMIT_NICE: ::__rlimit_resource_t = 13;\npub const RLIMIT_RTPRIO: ::__rlimit_resource_t = 14;\npub const RLIMIT_RTTIME: ::__rlimit_resource_t = 15;\npub const RLIMIT_NLIMITS: ::__rlimit_resource_t = 16;\npub const RLIM_NLIMITS: ::__rlimit_resource_t = RLIMIT_NLIMITS;\n\npub const PRIO_PROCESS: ::__priority_which_t = 0;\npub const PRIO_PGRP: ::__priority_which_t = 1;\npub const PRIO_USER: ::__priority_which_t = 2;\n\npub const MS_RMT_MASK: ::c_ulong = 0x02800051;\n\npub const __UT_LINESIZE: usize = 32;\npub const __UT_NAMESIZE: usize = 32;\npub const __UT_HOSTSIZE: usize = 256;\npub const EMPTY: ::c_short = 0;\npub const RUN_LVL: ::c_short = 1;\npub const BOOT_TIME: ::c_short = 2;\npub const NEW_TIME: ::c_short = 3;\npub const OLD_TIME: ::c_short = 4;\npub const INIT_PROCESS: ::c_short = 5;\npub const LOGIN_PROCESS: ::c_short = 6;\npub const USER_PROCESS: ::c_short = 7;\npub const DEAD_PROCESS: ::c_short = 8;\npub const ACCOUNTING: ::c_short = 9;\n\n// dlfcn.h\npub const LM_ID_BASE: ::c_long = 0;\npub const LM_ID_NEWLM: ::c_long = -1;\n\npub const RTLD_DI_LMID: ::c_int = 1;\npub const RTLD_DI_LINKMAP: ::c_int = 2;\npub const RTLD_DI_CONFIGADDR: ::c_int = 3;\npub const RTLD_DI_SERINFO: ::c_int = 4;\npub const RTLD_DI_SERINFOSIZE: ::c_int = 5;\npub const RTLD_DI_ORIGIN: ::c_int = 6;\npub const RTLD_DI_PROFILENAME: ::c_int = 7;\npub const RTLD_DI_PROFILEOUT: ::c_int = 8;\npub const RTLD_DI_TLS_MODID: ::c_int = 9;\npub const RTLD_DI_TLS_DATA: ::c_int = 10;\n\npub const SOCK_NONBLOCK: ::c_int = O_NONBLOCK;\n\npub const SOL_RXRPC: ::c_int = 272;\npub const SOL_PPPOL2TP: ::c_int = 273;\npub const SOL_PNPIPE: ::c_int = 275;\npub const SOL_RDS: ::c_int = 276;\npub const SOL_IUCV: ::c_int = 277;\npub const SOL_CAIF: ::c_int = 278;\npub const SOL_NFC: ::c_int = 280;\npub const SOL_XDP: ::c_int = 283;\n\npub const MSG_TRYHARD: ::c_int = 4;\n\npub const LC_PAPER: ::c_int = 7;\npub const LC_NAME: ::c_int = 8;\npub const LC_ADDRESS: ::c_int = 9;\npub const LC_TELEPHONE: ::c_int = 10;\npub const LC_MEASUREMENT: ::c_int = 11;\npub const LC_IDENTIFICATION: ::c_int = 12;\npub const LC_PAPER_MASK: ::c_int = 1 << LC_PAPER;\npub const LC_NAME_MASK: ::c_int = 1 << LC_NAME;\npub const LC_ADDRESS_MASK: ::c_int = 1 << LC_ADDRESS;\npub const LC_TELEPHONE_MASK: ::c_int = 1 << LC_TELEPHONE;\npub const LC_MEASUREMENT_MASK: ::c_int = 1 << LC_MEASUREMENT;\npub const LC_IDENTIFICATION_MASK: ::c_int = 1 << LC_IDENTIFICATION;\npub const LC_ALL_MASK: ::c_int = ::LC_CTYPE_MASK\n    | ::LC_NUMERIC_MASK\n    | ::LC_TIME_MASK\n    | ::LC_COLLATE_MASK\n    | ::LC_MONETARY_MASK\n    | ::LC_MESSAGES_MASK\n    | LC_PAPER_MASK\n    | LC_NAME_MASK\n    | LC_ADDRESS_MASK\n    | LC_TELEPHONE_MASK\n    | LC_MEASUREMENT_MASK\n    | LC_IDENTIFICATION_MASK;\n\npub const ENOTSUP: ::c_int = EOPNOTSUPP;\n\npub const SOCK_SEQPACKET: ::c_int = 5;\npub const SOCK_DCCP: ::c_int = 6;\npub const SOCK_PACKET: ::c_int = 10;\n\npub const FAN_MARK_INODE: ::c_uint = 0x0000_0000;\npub const FAN_MARK_MOUNT: ::c_uint = 0x0000_0010;\n// NOTE: FAN_MARK_FILESYSTEM requires Linux Kernel >= 4.20.0\npub const FAN_MARK_FILESYSTEM: ::c_uint = 0x0000_0100;\n\npub const AF_IB: ::c_int = 27;\npub const AF_MPLS: ::c_int = 28;\npub const AF_NFC: ::c_int = 39;\npub const AF_VSOCK: ::c_int = 40;\npub const AF_XDP: ::c_int = 44;\npub const PF_IB: ::c_int = AF_IB;\npub const PF_MPLS: ::c_int = AF_MPLS;\npub const PF_NFC: ::c_int = AF_NFC;\npub const PF_VSOCK: ::c_int = AF_VSOCK;\npub const PF_XDP: ::c_int = AF_XDP;\n\n/* DCCP socket options */\npub const DCCP_SOCKOPT_PACKET_SIZE: ::c_int = 1;\npub const DCCP_SOCKOPT_SERVICE: ::c_int = 2;\npub const DCCP_SOCKOPT_CHANGE_L: ::c_int = 3;\npub const DCCP_SOCKOPT_CHANGE_R: ::c_int = 4;\npub const DCCP_SOCKOPT_GET_CUR_MPS: ::c_int = 5;\npub const DCCP_SOCKOPT_SERVER_TIMEWAIT: ::c_int = 6;\npub const DCCP_SOCKOPT_SEND_CSCOV: ::c_int = 10;\npub const DCCP_SOCKOPT_RECV_CSCOV: ::c_int = 11;\npub const DCCP_SOCKOPT_AVAILABLE_CCIDS: ::c_int = 12;\npub const DCCP_SOCKOPT_CCID: ::c_int = 13;\npub const DCCP_SOCKOPT_TX_CCID: ::c_int = 14;\npub const DCCP_SOCKOPT_RX_CCID: ::c_int = 15;\npub const DCCP_SOCKOPT_QPOLICY_ID: ::c_int = 16;\npub const DCCP_SOCKOPT_QPOLICY_TXQLEN: ::c_int = 17;\npub const DCCP_SOCKOPT_CCID_RX_INFO: ::c_int = 128;\npub const DCCP_SOCKOPT_CCID_TX_INFO: ::c_int = 192;\n\n/// maximum number of services provided on the same listening port\npub const DCCP_SERVICE_LIST_MAX_LEN: ::c_int = 32;\n\npub const SIGEV_THREAD_ID: ::c_int = 4;\n\npub const BUFSIZ: ::c_uint = 8192;\npub const TMP_MAX: ::c_uint = 238328;\npub const FOPEN_MAX: ::c_uint = 16;\npub const FILENAME_MAX: ::c_uint = 4096;\npub const POSIX_MADV_DONTNEED: ::c_int = 4;\npub const _SC_EQUIV_CLASS_MAX: ::c_int = 41;\npub const _SC_CHARCLASS_NAME_MAX: ::c_int = 45;\npub const _SC_PII: ::c_int = 53;\npub const _SC_PII_XTI: ::c_int = 54;\npub const _SC_PII_SOCKET: ::c_int = 55;\npub const _SC_PII_INTERNET: ::c_int = 56;\npub const _SC_PII_OSI: ::c_int = 57;\npub const _SC_POLL: ::c_int = 58;\npub const _SC_SELECT: ::c_int = 59;\npub const _SC_PII_INTERNET_STREAM: ::c_int = 61;\npub const _SC_PII_INTERNET_DGRAM: ::c_int = 62;\npub const _SC_PII_OSI_COTS: ::c_int = 63;\npub const _SC_PII_OSI_CLTS: ::c_int = 64;\npub const _SC_PII_OSI_M: ::c_int = 65;\npub const _SC_T_IOV_MAX: ::c_int = 66;\npub const _SC_2_C_VERSION: ::c_int = 96;\npub const _SC_CHAR_BIT: ::c_int = 101;\npub const _SC_CHAR_MAX: ::c_int = 102;\npub const _SC_CHAR_MIN: ::c_int = 103;\npub const _SC_INT_MAX: ::c_int = 104;\npub const _SC_INT_MIN: ::c_int = 105;\npub const _SC_LONG_BIT: ::c_int = 106;\npub const _SC_WORD_BIT: ::c_int = 107;\npub const _SC_MB_LEN_MAX: ::c_int = 108;\npub const _SC_SSIZE_MAX: ::c_int = 110;\npub const _SC_SCHAR_MAX: ::c_int = 111;\npub const _SC_SCHAR_MIN: ::c_int = 112;\npub const _SC_SHRT_MAX: ::c_int = 113;\npub const _SC_SHRT_MIN: ::c_int = 114;\npub const _SC_UCHAR_MAX: ::c_int = 115;\npub const _SC_UINT_MAX: ::c_int = 116;\npub const _SC_ULONG_MAX: ::c_int = 117;\npub const _SC_USHRT_MAX: ::c_int = 118;\npub const _SC_NL_ARGMAX: ::c_int = 119;\npub const _SC_NL_LANGMAX: ::c_int = 120;\npub const _SC_NL_MSGMAX: ::c_int = 121;\npub const _SC_NL_NMAX: ::c_int = 122;\npub const _SC_NL_SETMAX: ::c_int = 123;\npub const _SC_NL_TEXTMAX: ::c_int = 124;\npub const _SC_BASE: ::c_int = 134;\npub const _SC_C_LANG_SUPPORT: ::c_int = 135;\npub const _SC_C_LANG_SUPPORT_R: ::c_int = 136;\npub const _SC_DEVICE_IO: ::c_int = 140;\npub const _SC_DEVICE_SPECIFIC: ::c_int = 141;\npub const _SC_DEVICE_SPECIFIC_R: ::c_int = 142;\npub const _SC_FD_MGMT: ::c_int = 143;\npub const _SC_FIFO: ::c_int = 144;\npub const _SC_PIPE: ::c_int = 145;\npub const _SC_FILE_ATTRIBUTES: ::c_int = 146;\npub const _SC_FILE_LOCKING: ::c_int = 147;\npub const _SC_FILE_SYSTEM: ::c_int = 148;\npub const _SC_MULTI_PROCESS: ::c_int = 150;\npub const _SC_SINGLE_PROCESS: ::c_int = 151;\npub const _SC_NETWORKING: ::c_int = 152;\npub const _SC_REGEX_VERSION: ::c_int = 156;\npub const _SC_SIGNALS: ::c_int = 158;\npub const _SC_SYSTEM_DATABASE: ::c_int = 162;\npub const _SC_SYSTEM_DATABASE_R: ::c_int = 163;\npub const _SC_USER_GROUPS: ::c_int = 166;\npub const _SC_USER_GROUPS_R: ::c_int = 167;\npub const _SC_LEVEL1_ICACHE_SIZE: ::c_int = 185;\npub const _SC_LEVEL1_ICACHE_ASSOC: ::c_int = 186;\npub const _SC_LEVEL1_ICACHE_LINESIZE: ::c_int = 187;\npub const _SC_LEVEL1_DCACHE_SIZE: ::c_int = 188;\npub const _SC_LEVEL1_DCACHE_ASSOC: ::c_int = 189;\npub const _SC_LEVEL1_DCACHE_LINESIZE: ::c_int = 190;\npub const _SC_LEVEL2_CACHE_SIZE: ::c_int = 191;\npub const _SC_LEVEL2_CACHE_ASSOC: ::c_int = 192;\npub const _SC_LEVEL2_CACHE_LINESIZE: ::c_int = 193;\npub const _SC_LEVEL3_CACHE_SIZE: ::c_int = 194;\npub const _SC_LEVEL3_CACHE_ASSOC: ::c_int = 195;\npub const _SC_LEVEL3_CACHE_LINESIZE: ::c_int = 196;\npub const _SC_LEVEL4_CACHE_SIZE: ::c_int = 197;\npub const _SC_LEVEL4_CACHE_ASSOC: ::c_int = 198;\npub const _SC_LEVEL4_CACHE_LINESIZE: ::c_int = 199;\npub const O_ACCMODE: ::c_int = 3;\npub const ST_RELATIME: ::c_ulong = 4096;\npub const NI_MAXHOST: ::socklen_t = 1025;\n\ncfg_if! {\n    if #[cfg(not(target_arch = \"s390x\"))] {\n        pub const ADFS_SUPER_MAGIC: ::c_long = 0x0000adf5;\n        pub const AFFS_SUPER_MAGIC: ::c_long = 0x0000adff;\n        pub const AFS_SUPER_MAGIC: ::c_long = 0x5346414f;\n        pub const AUTOFS_SUPER_MAGIC: ::c_long = 0x0187;\n        pub const BINDERFS_SUPER_MAGIC: ::c_long = 0x6c6f6f70;\n        pub const BPF_FS_MAGIC: ::c_long = 0xcafe4a11;\n        pub const BTRFS_SUPER_MAGIC: ::c_long = 0x9123683e;\n        pub const CGROUP2_SUPER_MAGIC: ::c_long = 0x63677270;\n        pub const CGROUP_SUPER_MAGIC: ::c_long = 0x27e0eb;\n        pub const CODA_SUPER_MAGIC: ::c_long = 0x73757245;\n        pub const CRAMFS_MAGIC: ::c_long = 0x28cd3d45;\n        pub const DEBUGFS_MAGIC: ::c_long = 0x64626720;\n        pub const DEVPTS_SUPER_MAGIC: ::c_long = 0x1cd1;\n        pub const ECRYPTFS_SUPER_MAGIC: ::c_long = 0xf15f;\n        pub const EFS_SUPER_MAGIC: ::c_long = 0x00414a53;\n        pub const EXT2_SUPER_MAGIC: ::c_long = 0x0000ef53;\n        pub const EXT3_SUPER_MAGIC: ::c_long = 0x0000ef53;\n        pub const EXT4_SUPER_MAGIC: ::c_long = 0x0000ef53;\n        pub const F2FS_SUPER_MAGIC: ::c_long = 0xf2f52010;\n        pub const FUTEXFS_SUPER_MAGIC: ::c_long = 0xbad1dea;\n        pub const HOSTFS_SUPER_MAGIC: ::c_long = 0x00c0ffee;\n        pub const HPFS_SUPER_MAGIC: ::c_long = 0xf995e849;\n        pub const HUGETLBFS_MAGIC: ::c_long = 0x958458f6;\n        pub const ISOFS_SUPER_MAGIC: ::c_long = 0x00009660;\n        pub const JFFS2_SUPER_MAGIC: ::c_long = 0x000072b6;\n        pub const MINIX2_SUPER_MAGIC2: ::c_long = 0x00002478;\n        pub const MINIX2_SUPER_MAGIC: ::c_long = 0x00002468;\n        pub const MINIX3_SUPER_MAGIC: ::c_long = 0x4d5a;\n        pub const MINIX_SUPER_MAGIC2: ::c_long = 0x0000138f;\n        pub const MINIX_SUPER_MAGIC: ::c_long = 0x0000137f;\n        pub const MSDOS_SUPER_MAGIC: ::c_long = 0x00004d44;\n        pub const NCP_SUPER_MAGIC: ::c_long = 0x0000564c;\n        pub const NFS_SUPER_MAGIC: ::c_long = 0x00006969;\n        pub const NILFS_SUPER_MAGIC: ::c_long = 0x3434;\n        pub const OCFS2_SUPER_MAGIC: ::c_long = 0x7461636f;\n        pub const OPENPROM_SUPER_MAGIC: ::c_long = 0x00009fa1;\n        pub const OVERLAYFS_SUPER_MAGIC: ::c_long = 0x794c7630;\n        pub const PROC_SUPER_MAGIC: ::c_long = 0x00009fa0;\n        pub const QNX4_SUPER_MAGIC: ::c_long = 0x0000002f;\n        pub const QNX6_SUPER_MAGIC: ::c_long = 0x68191122;\n        pub const RDTGROUP_SUPER_MAGIC: ::c_long = 0x7655821;\n        pub const REISERFS_SUPER_MAGIC: ::c_long = 0x52654973;\n        pub const SECURITYFS_MAGIC: ::c_long = 0x73636673;\n        pub const SELINUX_MAGIC: ::c_long = 0xf97cff8c;\n        pub const SMACK_MAGIC: ::c_long = 0x43415d53;\n        pub const SMB_SUPER_MAGIC: ::c_long = 0x0000517b;\n        pub const SYSFS_MAGIC: ::c_long = 0x62656572;\n        pub const TMPFS_MAGIC: ::c_long = 0x01021994;\n        pub const TRACEFS_MAGIC: ::c_long = 0x74726163;\n        pub const UDF_SUPER_MAGIC: ::c_long = 0x15013346;\n        pub const USBDEVICE_SUPER_MAGIC: ::c_long = 0x00009fa2;\n        pub const XENFS_SUPER_MAGIC: ::c_long = 0xabba1974;\n        pub const XFS_SUPER_MAGIC: ::c_long = 0x58465342;\n    } else if #[cfg(target_arch = \"s390x\")] {\n        pub const ADFS_SUPER_MAGIC: ::c_uint = 0x0000adf5;\n        pub const AFFS_SUPER_MAGIC: ::c_uint = 0x0000adff;\n        pub const AFS_SUPER_MAGIC: ::c_uint = 0x5346414f;\n        pub const AUTOFS_SUPER_MAGIC: ::c_uint = 0x0187;\n        pub const BINDERFS_SUPER_MAGIC: ::c_uint = 0x6c6f6f70;\n        pub const BPF_FS_MAGIC: ::c_uint = 0xcafe4a11;\n        pub const BTRFS_SUPER_MAGIC: ::c_uint = 0x9123683e;\n        pub const CGROUP2_SUPER_MAGIC: ::c_uint = 0x63677270;\n        pub const CGROUP_SUPER_MAGIC: ::c_uint = 0x27e0eb;\n        pub const CODA_SUPER_MAGIC: ::c_uint = 0x73757245;\n        pub const CRAMFS_MAGIC: ::c_uint = 0x28cd3d45;\n        pub const DEBUGFS_MAGIC: ::c_uint = 0x64626720;\n        pub const DEVPTS_SUPER_MAGIC: ::c_uint = 0x1cd1;\n        pub const ECRYPTFS_SUPER_MAGIC: ::c_uint = 0xf15f;\n        pub const EFS_SUPER_MAGIC: ::c_uint = 0x00414a53;\n        pub const EXT2_SUPER_MAGIC: ::c_uint = 0x0000ef53;\n        pub const EXT3_SUPER_MAGIC: ::c_uint = 0x0000ef53;\n        pub const EXT4_SUPER_MAGIC: ::c_uint = 0x0000ef53;\n        pub const F2FS_SUPER_MAGIC: ::c_uint = 0xf2f52010;\n        pub const FUTEXFS_SUPER_MAGIC: ::c_uint = 0xbad1dea;\n        pub const HOSTFS_SUPER_MAGIC: ::c_uint = 0x00c0ffee;\n        pub const HPFS_SUPER_MAGIC: ::c_uint = 0xf995e849;\n        pub const HUGETLBFS_MAGIC: ::c_uint = 0x958458f6;\n        pub const ISOFS_SUPER_MAGIC: ::c_uint = 0x00009660;\n        pub const JFFS2_SUPER_MAGIC: ::c_uint = 0x000072b6;\n        pub const MINIX2_SUPER_MAGIC2: ::c_uint = 0x00002478;\n        pub const MINIX2_SUPER_MAGIC: ::c_uint = 0x00002468;\n        pub const MINIX3_SUPER_MAGIC: ::c_uint = 0x4d5a;\n        pub const MINIX_SUPER_MAGIC2: ::c_uint = 0x0000138f;\n        pub const MINIX_SUPER_MAGIC: ::c_uint = 0x0000137f;\n        pub const MSDOS_SUPER_MAGIC: ::c_uint = 0x00004d44;\n        pub const NCP_SUPER_MAGIC: ::c_uint = 0x0000564c;\n        pub const NFS_SUPER_MAGIC: ::c_uint = 0x00006969;\n        pub const NILFS_SUPER_MAGIC: ::c_uint = 0x3434;\n        pub const OCFS2_SUPER_MAGIC: ::c_uint = 0x7461636f;\n        pub const OPENPROM_SUPER_MAGIC: ::c_uint = 0x00009fa1;\n        pub const OVERLAYFS_SUPER_MAGIC: ::c_uint = 0x794c7630;\n        pub const PROC_SUPER_MAGIC: ::c_uint = 0x00009fa0;\n        pub const QNX4_SUPER_MAGIC: ::c_uint = 0x0000002f;\n        pub const QNX6_SUPER_MAGIC: ::c_uint = 0x68191122;\n        pub const RDTGROUP_SUPER_MAGIC: ::c_uint = 0x7655821;\n        pub const REISERFS_SUPER_MAGIC: ::c_uint = 0x52654973;\n        pub const SECURITYFS_MAGIC: ::c_uint = 0x73636673;\n        pub const SELINUX_MAGIC: ::c_uint = 0xf97cff8c;\n        pub const SMACK_MAGIC: ::c_uint = 0x43415d53;\n        pub const SMB_SUPER_MAGIC: ::c_uint = 0x0000517b;\n        pub const SYSFS_MAGIC: ::c_uint = 0x62656572;\n        pub const TMPFS_MAGIC: ::c_uint = 0x01021994;\n        pub const TRACEFS_MAGIC: ::c_uint = 0x74726163;\n        pub const UDF_SUPER_MAGIC: ::c_uint = 0x15013346;\n        pub const USBDEVICE_SUPER_MAGIC: ::c_uint = 0x00009fa2;\n        pub const XENFS_SUPER_MAGIC: ::c_uint = 0xabba1974;\n        pub const XFS_SUPER_MAGIC: ::c_uint = 0x58465342;\n    }\n}\n\npub const CPU_SETSIZE: ::c_int = 0x400;\n\npub const PTRACE_TRACEME: ::c_uint = 0;\npub const PTRACE_PEEKTEXT: ::c_uint = 1;\npub const PTRACE_PEEKDATA: ::c_uint = 2;\npub const PTRACE_PEEKUSER: ::c_uint = 3;\npub const PTRACE_POKETEXT: ::c_uint = 4;\npub const PTRACE_POKEDATA: ::c_uint = 5;\npub const PTRACE_POKEUSER: ::c_uint = 6;\npub const PTRACE_CONT: ::c_uint = 7;\npub const PTRACE_KILL: ::c_uint = 8;\npub const PTRACE_SINGLESTEP: ::c_uint = 9;\npub const PTRACE_ATTACH: ::c_uint = 16;\npub const PTRACE_SYSCALL: ::c_uint = 24;\npub const PTRACE_SETOPTIONS: ::c_uint = 0x4200;\npub const PTRACE_GETEVENTMSG: ::c_uint = 0x4201;\npub const PTRACE_GETSIGINFO: ::c_uint = 0x4202;\npub const PTRACE_SETSIGINFO: ::c_uint = 0x4203;\npub const PTRACE_GETREGSET: ::c_uint = 0x4204;\npub const PTRACE_SETREGSET: ::c_uint = 0x4205;\npub const PTRACE_SEIZE: ::c_uint = 0x4206;\npub const PTRACE_INTERRUPT: ::c_uint = 0x4207;\npub const PTRACE_LISTEN: ::c_uint = 0x4208;\npub const PTRACE_PEEKSIGINFO: ::c_uint = 0x4209;\n\n// linux/fs.h\n\n// Flags for preadv2/pwritev2\npub const RWF_HIPRI: ::c_int = 0x00000001;\npub const RWF_DSYNC: ::c_int = 0x00000002;\npub const RWF_SYNC: ::c_int = 0x00000004;\npub const RWF_NOWAIT: ::c_int = 0x00000008;\npub const RWF_APPEND: ::c_int = 0x00000010;\n\n// linux/rtnetlink.h\npub const TCA_PAD: ::c_ushort = 9;\npub const TCA_DUMP_INVISIBLE: ::c_ushort = 10;\npub const TCA_CHAIN: ::c_ushort = 11;\npub const TCA_HW_OFFLOAD: ::c_ushort = 12;\n\npub const RTM_DELNETCONF: u16 = 81;\npub const RTM_NEWSTATS: u16 = 92;\npub const RTM_GETSTATS: u16 = 94;\npub const RTM_NEWCACHEREPORT: u16 = 96;\n\npub const RTM_F_LOOKUP_TABLE: ::c_uint = 0x1000;\npub const RTM_F_FIB_MATCH: ::c_uint = 0x2000;\n\npub const RTA_VIA: ::c_ushort = 18;\npub const RTA_NEWDST: ::c_ushort = 19;\npub const RTA_PREF: ::c_ushort = 20;\npub const RTA_ENCAP_TYPE: ::c_ushort = 21;\npub const RTA_ENCAP: ::c_ushort = 22;\npub const RTA_EXPIRES: ::c_ushort = 23;\npub const RTA_PAD: ::c_ushort = 24;\npub const RTA_UID: ::c_ushort = 25;\npub const RTA_TTL_PROPAGATE: ::c_ushort = 26;\n\n// linux/neighbor.h\npub const NTF_EXT_LEARNED: u8 = 0x10;\npub const NTF_OFFLOADED: u8 = 0x20;\n\npub const NDA_MASTER: ::c_ushort = 9;\npub const NDA_LINK_NETNSID: ::c_ushort = 10;\npub const NDA_SRC_VNI: ::c_ushort = 11;\n\n// linux/personality.h\npub const UNAME26: ::c_int = 0x0020000;\npub const FDPIC_FUNCPTRS: ::c_int = 0x0080000;\n\n// linux/if_addr.h\npub const IFA_FLAGS: ::c_ushort = 8;\n\npub const IFA_F_MANAGETEMPADDR: u32 = 0x100;\npub const IFA_F_NOPREFIXROUTE: u32 = 0x200;\npub const IFA_F_MCAUTOJOIN: u32 = 0x400;\npub const IFA_F_STABLE_PRIVACY: u32 = 0x800;\n\npub const MAX_LINKS: ::c_int = 32;\n\npub const GENL_UNS_ADMIN_PERM: ::c_int = 0x10;\n\npub const GENL_ID_VFS_DQUOT: ::c_int = ::NLMSG_MIN_TYPE + 1;\npub const GENL_ID_PMCRAID: ::c_int = ::NLMSG_MIN_TYPE + 2;\n\npub const TIOCM_LE: ::c_int = 0x001;\npub const TIOCM_DTR: ::c_int = 0x002;\npub const TIOCM_RTS: ::c_int = 0x004;\npub const TIOCM_CD: ::c_int = TIOCM_CAR;\npub const TIOCM_RI: ::c_int = TIOCM_RNG;\n\n// linux/keyctl.h\npub const KEYCTL_DH_COMPUTE: u32 = 23;\npub const KEYCTL_PKEY_QUERY: u32 = 24;\npub const KEYCTL_PKEY_ENCRYPT: u32 = 25;\npub const KEYCTL_PKEY_DECRYPT: u32 = 26;\npub const KEYCTL_PKEY_SIGN: u32 = 27;\npub const KEYCTL_PKEY_VERIFY: u32 = 28;\npub const KEYCTL_RESTRICT_KEYRING: u32 = 29;\n\npub const KEYCTL_SUPPORTS_ENCRYPT: u32 = 0x01;\npub const KEYCTL_SUPPORTS_DECRYPT: u32 = 0x02;\npub const KEYCTL_SUPPORTS_SIGN: u32 = 0x04;\npub const KEYCTL_SUPPORTS_VERIFY: u32 = 0x08;\ncfg_if! {\n    if #[cfg(not(any(target_arch=\"mips\", target_arch=\"mips64\")))] {\n        pub const KEYCTL_MOVE: u32 = 30;\n        pub const KEYCTL_CAPABILITIES: u32 = 31;\n\n        pub const KEYCTL_CAPS0_CAPABILITIES: u32 = 0x01;\n        pub const KEYCTL_CAPS0_PERSISTENT_KEYRINGS: u32 = 0x02;\n        pub const KEYCTL_CAPS0_DIFFIE_HELLMAN: u32 = 0x04;\n        pub const KEYCTL_CAPS0_PUBLIC_KEY: u32 = 0x08;\n        pub const KEYCTL_CAPS0_BIG_KEY: u32 = 0x10;\n        pub const KEYCTL_CAPS0_INVALIDATE: u32 = 0x20;\n        pub const KEYCTL_CAPS0_RESTRICT_KEYRING: u32 = 0x40;\n        pub const KEYCTL_CAPS0_MOVE: u32 = 0x80;\n        pub const KEYCTL_CAPS1_NS_KEYRING_NAME: u32 = 0x01;\n        pub const KEYCTL_CAPS1_NS_KEY_TAG: u32 = 0x02;\n    }\n}\n\npub const M_MXFAST: ::c_int = 1;\npub const M_NLBLKS: ::c_int = 2;\npub const M_GRAIN: ::c_int = 3;\npub const M_KEEP: ::c_int = 4;\npub const M_TRIM_THRESHOLD: ::c_int = -1;\npub const M_TOP_PAD: ::c_int = -2;\npub const M_MMAP_THRESHOLD: ::c_int = -3;\npub const M_MMAP_MAX: ::c_int = -4;\npub const M_CHECK_ACTION: ::c_int = -5;\npub const M_PERTURB: ::c_int = -6;\npub const M_ARENA_TEST: ::c_int = -7;\npub const M_ARENA_MAX: ::c_int = -8;\n\npub const AT_STATX_SYNC_TYPE: ::c_int = 0x6000;\npub const AT_STATX_SYNC_AS_STAT: ::c_int = 0x0000;\npub const AT_STATX_FORCE_SYNC: ::c_int = 0x2000;\npub const AT_STATX_DONT_SYNC: ::c_int = 0x4000;\npub const STATX_TYPE: ::c_uint = 0x0001;\npub const STATX_MODE: ::c_uint = 0x0002;\npub const STATX_NLINK: ::c_uint = 0x0004;\npub const STATX_UID: ::c_uint = 0x0008;\npub const STATX_GID: ::c_uint = 0x0010;\npub const STATX_ATIME: ::c_uint = 0x0020;\npub const STATX_MTIME: ::c_uint = 0x0040;\npub const STATX_CTIME: ::c_uint = 0x0080;\npub const STATX_INO: ::c_uint = 0x0100;\npub const STATX_SIZE: ::c_uint = 0x0200;\npub const STATX_BLOCKS: ::c_uint = 0x0400;\npub const STATX_BASIC_STATS: ::c_uint = 0x07ff;\npub const STATX_BTIME: ::c_uint = 0x0800;\npub const STATX_MNT_ID: ::c_uint = 0x1000;\npub const STATX_ALL: ::c_uint = 0x0fff;\npub const STATX__RESERVED: ::c_int = 0x80000000;\npub const STATX_ATTR_COMPRESSED: ::c_int = 0x0004;\npub const STATX_ATTR_IMMUTABLE: ::c_int = 0x0010;\npub const STATX_ATTR_APPEND: ::c_int = 0x0020;\npub const STATX_ATTR_NODUMP: ::c_int = 0x0040;\npub const STATX_ATTR_ENCRYPTED: ::c_int = 0x0800;\npub const STATX_ATTR_AUTOMOUNT: ::c_int = 0x1000;\n\n//sys/timex.h\npub const ADJ_OFFSET: ::c_uint = 0x0001;\npub const ADJ_FREQUENCY: ::c_uint = 0x0002;\npub const ADJ_MAXERROR: ::c_uint = 0x0004;\npub const ADJ_ESTERROR: ::c_uint = 0x0008;\npub const ADJ_STATUS: ::c_uint = 0x0010;\npub const ADJ_TIMECONST: ::c_uint = 0x0020;\npub const ADJ_TAI: ::c_uint = 0x0080;\npub const ADJ_SETOFFSET: ::c_uint = 0x0100;\npub const ADJ_MICRO: ::c_uint = 0x1000;\npub const ADJ_NANO: ::c_uint = 0x2000;\npub const ADJ_TICK: ::c_uint = 0x4000;\npub const ADJ_OFFSET_SINGLESHOT: ::c_uint = 0x8001;\npub const ADJ_OFFSET_SS_READ: ::c_uint = 0xa001;\npub const MOD_OFFSET: ::c_uint = ADJ_OFFSET;\npub const MOD_FREQUENCY: ::c_uint = ADJ_FREQUENCY;\npub const MOD_MAXERROR: ::c_uint = ADJ_MAXERROR;\npub const MOD_ESTERROR: ::c_uint = ADJ_ESTERROR;\npub const MOD_STATUS: ::c_uint = ADJ_STATUS;\npub const MOD_TIMECONST: ::c_uint = ADJ_TIMECONST;\npub const MOD_CLKB: ::c_uint = ADJ_TICK;\npub const MOD_CLKA: ::c_uint = ADJ_OFFSET_SINGLESHOT;\npub const MOD_TAI: ::c_uint = ADJ_TAI;\npub const MOD_MICRO: ::c_uint = ADJ_MICRO;\npub const MOD_NANO: ::c_uint = ADJ_NANO;\npub const STA_PLL: ::c_int = 0x0001;\npub const STA_PPSFREQ: ::c_int = 0x0002;\npub const STA_PPSTIME: ::c_int = 0x0004;\npub const STA_FLL: ::c_int = 0x0008;\npub const STA_INS: ::c_int = 0x0010;\npub const STA_DEL: ::c_int = 0x0020;\npub const STA_UNSYNC: ::c_int = 0x0040;\npub const STA_FREQHOLD: ::c_int = 0x0080;\npub const STA_PPSSIGNAL: ::c_int = 0x0100;\npub const STA_PPSJITTER: ::c_int = 0x0200;\npub const STA_PPSWANDER: ::c_int = 0x0400;\npub const STA_PPSERROR: ::c_int = 0x0800;\npub const STA_CLOCKERR: ::c_int = 0x1000;\npub const STA_NANO: ::c_int = 0x2000;\npub const STA_MODE: ::c_int = 0x4000;\npub const STA_CLK: ::c_int = 0x8000;\npub const STA_RONLY: ::c_int = STA_PPSSIGNAL\n    | STA_PPSJITTER\n    | STA_PPSWANDER\n    | STA_PPSERROR\n    | STA_CLOCKERR\n    | STA_NANO\n    | STA_MODE\n    | STA_CLK;\npub const NTP_API: ::c_int = 4;\npub const TIME_OK: ::c_int = 0;\npub const TIME_INS: ::c_int = 1;\npub const TIME_DEL: ::c_int = 2;\npub const TIME_OOP: ::c_int = 3;\npub const TIME_WAIT: ::c_int = 4;\npub const TIME_ERROR: ::c_int = 5;\npub const TIME_BAD: ::c_int = TIME_ERROR;\npub const MAXTC: ::c_long = 6;\n\ncfg_if! {\n    if #[cfg(any(\n        target_arch = \"arm\",\n        target_arch = \"x86\",\n        target_arch = \"x86_64\",\n        target_arch = \"s390x\",\n        target_arch = \"riscv64\",\n        target_arch = \"riscv32\"\n    ))] {\n        pub const PTHREAD_STACK_MIN: ::size_t = 16384;\n    } else if #[cfg(any(\n               target_arch = \"sparc\",\n               target_arch = \"sparc64\"\n           ))] {\n        pub const PTHREAD_STACK_MIN: ::size_t = 0x6000;\n    } else {\n        pub const PTHREAD_STACK_MIN: ::size_t = 131072;\n    }\n}\npub const PTHREAD_MUTEX_ADAPTIVE_NP: ::c_int = 3;\n\npub const REG_STARTEND: ::c_int = 4;\n\npub const REG_EEND: ::c_int = 14;\npub const REG_ESIZE: ::c_int = 15;\npub const REG_ERPAREN: ::c_int = 16;\n\nextern \"C\" {\n    pub fn fgetspent_r(\n        fp: *mut ::FILE,\n        spbuf: *mut ::spwd,\n        buf: *mut ::c_char,\n        buflen: ::size_t,\n        spbufp: *mut *mut ::spwd,\n    ) -> ::c_int;\n    pub fn sgetspent_r(\n        s: *const ::c_char,\n        spbuf: *mut ::spwd,\n        buf: *mut ::c_char,\n        buflen: ::size_t,\n        spbufp: *mut *mut ::spwd,\n    ) -> ::c_int;\n    pub fn getspent_r(\n        spbuf: *mut ::spwd,\n        buf: *mut ::c_char,\n        buflen: ::size_t,\n        spbufp: *mut *mut ::spwd,\n    ) -> ::c_int;\n    pub fn qsort_r(\n        base: *mut ::c_void,\n        num: ::size_t,\n        size: ::size_t,\n        compar: ::Option<\n            unsafe extern \"C\" fn(*const ::c_void, *const ::c_void, *mut ::c_void) -> ::c_int,\n        >,\n        arg: *mut ::c_void,\n    );\n    pub fn sendmmsg(\n        sockfd: ::c_int,\n        msgvec: *mut ::mmsghdr,\n        vlen: ::c_uint,\n        flags: ::c_int,\n    ) -> ::c_int;\n    pub fn recvmmsg(\n        sockfd: ::c_int,\n        msgvec: *mut ::mmsghdr,\n        vlen: ::c_uint,\n        flags: ::c_int,\n        timeout: *mut ::timespec,\n    ) -> ::c_int;\n\n    pub fn getrlimit64(resource: ::__rlimit_resource_t, rlim: *mut ::rlimit64) -> ::c_int;\n    pub fn setrlimit64(resource: ::__rlimit_resource_t, rlim: *const ::rlimit64) -> ::c_int;\n    pub fn getrlimit(resource: ::__rlimit_resource_t, rlim: *mut ::rlimit) -> ::c_int;\n    pub fn setrlimit(resource: ::__rlimit_resource_t, rlim: *const ::rlimit) -> ::c_int;\n    pub fn prlimit(\n        pid: ::pid_t,\n        resource: ::__rlimit_resource_t,\n        new_limit: *const ::rlimit,\n        old_limit: *mut ::rlimit,\n    ) -> ::c_int;\n    pub fn prlimit64(\n        pid: ::pid_t,\n        resource: ::__rlimit_resource_t,\n        new_limit: *const ::rlimit64,\n        old_limit: *mut ::rlimit64,\n    ) -> ::c_int;\n    pub fn utmpname(file: *const ::c_char) -> ::c_int;\n    pub fn utmpxname(file: *const ::c_char) -> ::c_int;\n    pub fn getutxent() -> *mut utmpx;\n    pub fn getutxid(ut: *const utmpx) -> *mut utmpx;\n    pub fn getutxline(ut: *const utmpx) -> *mut utmpx;\n    pub fn pututxline(ut: *const utmpx) -> *mut utmpx;\n    pub fn setutxent();\n    pub fn endutxent();\n    pub fn getpt() -> ::c_int;\n    pub fn mallopt(param: ::c_int, value: ::c_int) -> ::c_int;\n    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::timezone) -> ::c_int;\n    pub fn statx(\n        dirfd: ::c_int,\n        pathname: *const c_char,\n        flags: ::c_int,\n        mask: ::c_uint,\n        statxbuf: *mut statx,\n    ) -> ::c_int;\n    pub fn getrandom(buf: *mut ::c_void, buflen: ::size_t, flags: ::c_uint) -> ::ssize_t;\n\n    pub fn memmem(\n        haystack: *const ::c_void,\n        haystacklen: ::size_t,\n        needle: *const ::c_void,\n        needlelen: ::size_t,\n    ) -> *mut ::c_void;\n    pub fn getauxval(type_: ::c_ulong) -> ::c_ulong;\n\n    pub fn adjtimex(buf: *mut timex) -> ::c_int;\n    pub fn ntp_adjtime(buf: *mut timex) -> ::c_int;\n    #[link_name = \"ntp_gettimex\"]\n    pub fn ntp_gettime(buf: *mut ntptimeval) -> ::c_int;\n    pub fn copy_file_range(\n        fd_in: ::c_int,\n        off_in: *mut ::off64_t,\n        fd_out: ::c_int,\n        off_out: *mut ::off64_t,\n        len: ::size_t,\n        flags: ::c_uint,\n    ) -> ::ssize_t;\n    pub fn fanotify_mark(\n        fd: ::c_int,\n        flags: ::c_uint,\n        mask: u64,\n        dirfd: ::c_int,\n        path: *const ::c_char,\n    ) -> ::c_int;\n    pub fn preadv2(\n        fd: ::c_int,\n        iov: *const ::iovec,\n        iovcnt: ::c_int,\n        offset: ::off_t,\n        flags: ::c_int,\n    ) -> ::ssize_t;\n    pub fn pwritev2(\n        fd: ::c_int,\n        iov: *const ::iovec,\n        iovcnt: ::c_int,\n        offset: ::off_t,\n        flags: ::c_int,\n    ) -> ::ssize_t;\n    pub fn renameat2(\n        olddirfd: ::c_int,\n        oldpath: *const ::c_char,\n        newdirfd: ::c_int,\n        newpath: *const ::c_char,\n        flags: ::c_uint,\n    ) -> ::c_int;\n\n    // Added in `glibc` 2.25\n    pub fn explicit_bzero(s: *mut ::c_void, len: ::size_t);\n}\n\nextern \"C\" {\n    pub fn ioctl(fd: ::c_int, request: ::c_ulong, ...) -> ::c_int;\n    pub fn backtrace(buf: *mut *mut ::c_void, sz: ::c_int) -> ::c_int;\n    pub fn glob64(\n        pattern: *const ::c_char,\n        flags: ::c_int,\n        errfunc: ::Option<extern \"C\" fn(epath: *const ::c_char, errno: ::c_int) -> ::c_int>,\n        pglob: *mut glob64_t,\n    ) -> ::c_int;\n    pub fn globfree64(pglob: *mut glob64_t);\n    pub fn ptrace(request: ::c_uint, ...) -> ::c_long;\n    pub fn pthread_attr_getaffinity_np(\n        attr: *const ::pthread_attr_t,\n        cpusetsize: ::size_t,\n        cpuset: *mut ::cpu_set_t,\n    ) -> ::c_int;\n    pub fn pthread_attr_setaffinity_np(\n        attr: *mut ::pthread_attr_t,\n        cpusetsize: ::size_t,\n        cpuset: *const ::cpu_set_t,\n    ) -> ::c_int;\n    pub fn getpriority(which: ::__priority_which_t, who: ::id_t) -> ::c_int;\n    pub fn setpriority(which: ::__priority_which_t, who: ::id_t, prio: ::c_int) -> ::c_int;\n    pub fn pthread_getaffinity_np(\n        thread: ::pthread_t,\n        cpusetsize: ::size_t,\n        cpuset: *mut ::cpu_set_t,\n    ) -> ::c_int;\n    pub fn pthread_setaffinity_np(\n        thread: ::pthread_t,\n        cpusetsize: ::size_t,\n        cpuset: *const ::cpu_set_t,\n    ) -> ::c_int;\n    pub fn pthread_rwlockattr_getkind_np(\n        attr: *const ::pthread_rwlockattr_t,\n        val: *mut ::c_int,\n    ) -> ::c_int;\n    pub fn pthread_rwlockattr_setkind_np(\n        attr: *mut ::pthread_rwlockattr_t,\n        val: ::c_int,\n    ) -> ::c_int;\n    pub fn sched_getcpu() -> ::c_int;\n    pub fn mallinfo() -> ::mallinfo;\n    pub fn malloc_usable_size(ptr: *mut ::c_void) -> ::size_t;\n    pub fn getpwent_r(\n        pwd: *mut ::passwd,\n        buf: *mut ::c_char,\n        buflen: ::size_t,\n        result: *mut *mut ::passwd,\n    ) -> ::c_int;\n    pub fn getgrent_r(\n        grp: *mut ::group,\n        buf: *mut ::c_char,\n        buflen: ::size_t,\n        result: *mut *mut ::group,\n    ) -> ::c_int;\n    pub fn pthread_getname_np(thread: ::pthread_t, name: *mut ::c_char, len: ::size_t) -> ::c_int;\n    pub fn pthread_setname_np(thread: ::pthread_t, name: *const ::c_char) -> ::c_int;\n}\n\nextern \"C\" {\n    pub fn dlmopen(lmid: Lmid_t, filename: *const ::c_char, flag: ::c_int) -> *mut ::c_void;\n    pub fn dlinfo(handle: *mut ::c_void, request: ::c_int, info: *mut ::c_void) -> ::c_int;\n}\n\ncfg_if! {\n    if #[cfg(any(target_arch = \"x86\",\n                 target_arch = \"arm\",\n                 target_arch = \"mips\",\n                 target_arch = \"powerpc\",\n                 target_arch = \"sparc\",\n                 target_arch = \"riscv32\"))] {\n        mod b32;\n        pub use self::b32::*;\n    } else if #[cfg(any(target_arch = \"x86_64\",\n                        target_arch = \"aarch64\",\n                        target_arch = \"powerpc64\",\n                        target_arch = \"mips64\",\n                        target_arch = \"s390x\",\n                        target_arch = \"sparc64\",\n                        target_arch = \"riscv64\"))] {\n        mod b64;\n        pub use self::b64::*;\n    } else {\n        // Unknown target_arch\n    }\n}\n\ncfg_if! {\n    if #[cfg(libc_align)] {\n        mod align;\n        pub use self::align::*;\n    } else {\n        mod no_align;\n        pub use self::no_align::*;\n    }\n}\n"],["1166","use pthread_mutex_t;\n\npub type c_long = i64;\npub type c_ulong = u64;\n\npub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 8;\npub const __SIZEOF_PTHREAD_MUTEX_T: usize = 48;\npub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 8;\npub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;\n\nalign_const! {\n    #[cfg(target_endian = \"little\")]\n    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"little\")]\n    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"little\")]\n    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"big\")]\n    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"big\")]\n    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"big\")]\n    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0,\n            ],\n        };\n}\n\npub const SYS_renameat: ::c_long = 38;\npub const SYS_sync_file_range: ::c_long = 84;\npub const SYS_getrlimit: ::c_long = 163;\npub const SYS_setrlimit: ::c_long = 164;\n"],["1167","use pthread_mutex_t;\n\npub type c_long = i32;\npub type c_ulong = u32;\n\npub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;\npub const __SIZEOF_PTHREAD_MUTEX_T: usize = 32;\npub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;\npub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 48;\n\nalign_const! {\n    #[cfg(target_endian = \"little\")]\n    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"little\")]\n    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"little\")]\n    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"big\")]\n    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"big\")]\n    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"big\")]\n    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n}\n\npub const SYS_sync_file_range2: ::c_long = 84;\n"],["1168","s_no_extra_traits! {\n    #[allow(missing_debug_implementations)]\n    #[repr(align(16))]\n    pub struct max_align_t {\n        priv_: [f32; 8]\n    }\n}\n\ns! {\n    pub struct ucontext_t {\n        pub uc_flags: ::c_ulong,\n        pub uc_link: *mut ucontext_t,\n        pub uc_stack: ::stack_t,\n        pub uc_sigmask: ::sigset_t,\n        pub uc_mcontext: mcontext_t,\n    }\n\n    #[repr(align(16))]\n    pub struct mcontext_t {\n        pub fault_address: ::c_ulonglong,\n        pub regs: [::c_ulonglong; 31],\n        pub sp: ::c_ulonglong,\n        pub pc: ::c_ulonglong,\n        pub pstate: ::c_ulonglong,\n        // nested arrays to get the right size/length while being able to\n        // auto-derive traits like Debug\n        __reserved: [[u64; 32]; 16],\n    }\n}\n"],["1169","//! AArch64-specific definitions for 64-bit linux-like values\n\npub type c_char = u8;\npub type wchar_t = u32;\npub type nlink_t = u32;\npub type blksize_t = i32;\npub type suseconds_t = i64;\npub type __u64 = ::c_ulonglong;\n\ns! {\n    pub struct sigaction {\n        pub sa_sigaction: ::sighandler_t,\n        pub sa_mask: ::sigset_t,\n        #[cfg(target_arch = \"sparc64\")]\n        __reserved0: ::c_int,\n        pub sa_flags: ::c_int,\n        pub sa_restorer: ::Option<extern fn()>,\n    }\n\n    pub struct statfs {\n        pub f_type: ::__fsword_t,\n        pub f_bsize: ::__fsword_t,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n\n        pub f_namelen: ::__fsword_t,\n        pub f_frsize: ::__fsword_t,\n        f_spare: [::__fsword_t; 5],\n    }\n\n    pub struct flock {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off_t,\n        pub l_len: ::off_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct flock64 {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off64_t,\n        pub l_len: ::off64_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct stat {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        __pad1: ::dev_t,\n        pub st_size: ::off_t,\n        pub st_blksize: ::blksize_t,\n        __pad2: ::c_int,\n        pub st_blocks: ::blkcnt_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __unused: [::c_int; 2],\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        __pad1: ::dev_t,\n        pub st_size: ::off64_t,\n        pub st_blksize: ::blksize_t,\n        __pad2: ::c_int,\n        pub st_blocks: ::blkcnt64_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __unused: [::c_int; 2],\n    }\n\n    pub struct statfs64 {\n        pub f_type: ::__fsword_t,\n        pub f_bsize: ::__fsword_t,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::__fsword_t,\n        pub f_frsize: ::__fsword_t,\n        pub f_flags: ::__fsword_t,\n        pub f_spare: [::__fsword_t; 4],\n    }\n\n    pub struct statvfs {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_favail: ::fsfilcnt_t,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_favail: u64,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct pthread_attr_t {\n        __size: [usize; 8]\n    }\n\n    pub struct ipc_perm {\n        pub __key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::c_uint,\n        pub __seq: ::c_ushort,\n        __pad1: ::c_ushort,\n        __unused1: ::c_ulong,\n        __unused2: ::c_ulong\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        pub shm_segsz: ::size_t,\n        pub shm_atime: ::time_t,\n        pub shm_dtime: ::time_t,\n        pub shm_ctime: ::time_t,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::shmatt_t,\n        __unused4: ::c_ulong,\n        __unused5: ::c_ulong\n    }\n\n    pub struct termios2 {\n        pub c_iflag: ::tcflag_t,\n        pub c_oflag: ::tcflag_t,\n        pub c_cflag: ::tcflag_t,\n        pub c_lflag: ::tcflag_t,\n        pub c_line: ::cc_t,\n        pub c_cc: [::cc_t; 19],\n        pub c_ispeed: ::speed_t,\n        pub c_ospeed: ::speed_t,\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_errno: ::c_int,\n        pub si_code: ::c_int,\n        #[doc(hidden)]\n        #[deprecated(\n            since=\"0.2.54\",\n            note=\"Please leave a comment on \\\n                  https://github.com/rust-lang/libc/pull/1316 if you're using \\\n                  this field\"\n        )]\n        pub _pad: [::c_int; 29],\n        _align: [usize; 0],\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_flags: ::c_int,\n        pub ss_size: ::size_t\n    }\n\n    pub struct ip_mreqn {\n        pub imr_multiaddr: ::in_addr,\n        pub imr_address: ::in_addr,\n        pub imr_ifindex: ::c_int,\n    }\n}\n\npub const VEOF: usize = 4;\n\npub const RTLD_DEEPBIND: ::c_int = 0x8;\npub const RTLD_GLOBAL: ::c_int = 0x100;\npub const RTLD_NOLOAD: ::c_int = 0x4;\n\npub const RLIMIT_RSS: ::__rlimit_resource_t = 5;\npub const RLIMIT_AS: ::__rlimit_resource_t = 9;\npub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 8;\npub const RLIMIT_NOFILE: ::__rlimit_resource_t = 7;\npub const RLIMIT_NPROC: ::__rlimit_resource_t = 6;\n\npub const O_APPEND: ::c_int = 1024;\npub const O_CREAT: ::c_int = 64;\npub const O_EXCL: ::c_int = 128;\npub const O_NOCTTY: ::c_int = 256;\npub const O_NONBLOCK: ::c_int = 2048;\npub const O_SYNC: ::c_int = 1052672;\npub const O_RSYNC: ::c_int = 1052672;\npub const O_DSYNC: ::c_int = 4096;\npub const O_FSYNC: ::c_int = 0x101000;\npub const O_NOATIME: ::c_int = 0o1000000;\npub const O_PATH: ::c_int = 0o10000000;\npub const O_TMPFILE: ::c_int = 0o20000000 | O_DIRECTORY;\n\npub const MADV_SOFT_OFFLINE: ::c_int = 101;\npub const MAP_GROWSDOWN: ::c_int = 0x0100;\n\npub const EUCLEAN: ::c_int = 117;\npub const ENOTNAM: ::c_int = 118;\npub const ENAVAIL: ::c_int = 119;\npub const EISNAM: ::c_int = 120;\npub const EREMOTEIO: ::c_int = 121;\npub const EDEADLK: ::c_int = 35;\npub const ENAMETOOLONG: ::c_int = 36;\npub const ENOLCK: ::c_int = 37;\npub const ENOSYS: ::c_int = 38;\npub const ENOTEMPTY: ::c_int = 39;\npub const ELOOP: ::c_int = 40;\npub const ENOMSG: ::c_int = 42;\npub const EIDRM: ::c_int = 43;\npub const ECHRNG: ::c_int = 44;\npub const EL2NSYNC: ::c_int = 45;\npub const EL3HLT: ::c_int = 46;\npub const EL3RST: ::c_int = 47;\npub const ELNRNG: ::c_int = 48;\npub const EUNATCH: ::c_int = 49;\npub const ENOCSI: ::c_int = 50;\npub const EL2HLT: ::c_int = 51;\npub const EBADE: ::c_int = 52;\npub const EBADR: ::c_int = 53;\npub const EXFULL: ::c_int = 54;\npub const ENOANO: ::c_int = 55;\npub const EBADRQC: ::c_int = 56;\npub const EBADSLT: ::c_int = 57;\npub const EMULTIHOP: ::c_int = 72;\npub const EOVERFLOW: ::c_int = 75;\npub const ENOTUNIQ: ::c_int = 76;\npub const EBADFD: ::c_int = 77;\npub const EBADMSG: ::c_int = 74;\npub const EREMCHG: ::c_int = 78;\npub const ELIBACC: ::c_int = 79;\npub const ELIBBAD: ::c_int = 80;\npub const ELIBSCN: ::c_int = 81;\npub const ELIBMAX: ::c_int = 82;\npub const ELIBEXEC: ::c_int = 83;\npub const EILSEQ: ::c_int = 84;\npub const ERESTART: ::c_int = 85;\npub const ESTRPIPE: ::c_int = 86;\npub const EUSERS: ::c_int = 87;\npub const ENOTSOCK: ::c_int = 88;\npub const EDESTADDRREQ: ::c_int = 89;\npub const EMSGSIZE: ::c_int = 90;\npub const EPROTOTYPE: ::c_int = 91;\npub const ENOPROTOOPT: ::c_int = 92;\npub const EPROTONOSUPPORT: ::c_int = 93;\npub const ESOCKTNOSUPPORT: ::c_int = 94;\npub const EOPNOTSUPP: ::c_int = 95;\npub const EPFNOSUPPORT: ::c_int = 96;\npub const EAFNOSUPPORT: ::c_int = 97;\npub const EADDRINUSE: ::c_int = 98;\npub const EADDRNOTAVAIL: ::c_int = 99;\npub const ENETDOWN: ::c_int = 100;\npub const ENETUNREACH: ::c_int = 101;\npub const ENETRESET: ::c_int = 102;\npub const ECONNABORTED: ::c_int = 103;\npub const ECONNRESET: ::c_int = 104;\npub const ENOBUFS: ::c_int = 105;\npub const EISCONN: ::c_int = 106;\npub const ENOTCONN: ::c_int = 107;\npub const ESHUTDOWN: ::c_int = 108;\npub const ETOOMANYREFS: ::c_int = 109;\npub const ETIMEDOUT: ::c_int = 110;\npub const ECONNREFUSED: ::c_int = 111;\npub const EHOSTDOWN: ::c_int = 112;\npub const EHOSTUNREACH: ::c_int = 113;\npub const EALREADY: ::c_int = 114;\npub const EINPROGRESS: ::c_int = 115;\npub const ESTALE: ::c_int = 116;\npub const EDQUOT: ::c_int = 122;\npub const ENOMEDIUM: ::c_int = 123;\npub const EMEDIUMTYPE: ::c_int = 124;\npub const ECANCELED: ::c_int = 125;\npub const ENOKEY: ::c_int = 126;\npub const EKEYEXPIRED: ::c_int = 127;\npub const EKEYREVOKED: ::c_int = 128;\npub const EKEYREJECTED: ::c_int = 129;\npub const EOWNERDEAD: ::c_int = 130;\npub const ENOTRECOVERABLE: ::c_int = 131;\npub const EHWPOISON: ::c_int = 133;\npub const ERFKILL: ::c_int = 132;\n\npub const POSIX_FADV_DONTNEED: ::c_int = 4;\npub const POSIX_FADV_NOREUSE: ::c_int = 5;\n\npub const SOCK_STREAM: ::c_int = 1;\npub const SOCK_DGRAM: ::c_int = 2;\n\npub const SA_ONSTACK: ::c_int = 0x08000000;\npub const SA_SIGINFO: ::c_int = 0x00000004;\npub const SA_NOCLDWAIT: ::c_int = 0x00000002;\n\npub const SIGTTIN: ::c_int = 21;\npub const SIGTTOU: ::c_int = 22;\npub const SIGXCPU: ::c_int = 24;\npub const SIGXFSZ: ::c_int = 25;\npub const SIGVTALRM: ::c_int = 26;\npub const SIGPROF: ::c_int = 27;\npub const SIGWINCH: ::c_int = 28;\npub const SIGCHLD: ::c_int = 17;\npub const SIGBUS: ::c_int = 7;\npub const SIGUSR1: ::c_int = 10;\npub const SIGUSR2: ::c_int = 12;\npub const SIGCONT: ::c_int = 18;\npub const SIGSTOP: ::c_int = 19;\npub const SIGTSTP: ::c_int = 20;\npub const SIGURG: ::c_int = 23;\npub const SIGIO: ::c_int = 29;\npub const SIGSYS: ::c_int = 31;\npub const SIGSTKFLT: ::c_int = 16;\n#[deprecated(since = \"0.2.55\", note = \"Use SIGSYS instead\")]\npub const SIGUNUSED: ::c_int = 31;\npub const SIGPOLL: ::c_int = 29;\npub const SIGPWR: ::c_int = 30;\npub const SIG_SETMASK: ::c_int = 2;\npub const SIG_BLOCK: ::c_int = 0x000000;\npub const SIG_UNBLOCK: ::c_int = 0x01;\n\npub const POLLWRNORM: ::c_short = 0x100;\npub const POLLWRBAND: ::c_short = 0x200;\n\npub const O_ASYNC: ::c_int = 0x2000;\npub const O_NDELAY: ::c_int = 0x800;\n\npub const PTRACE_DETACH: ::c_uint = 17;\n\npub const EFD_NONBLOCK: ::c_int = 0x800;\n\npub const F_GETLK: ::c_int = 5;\npub const F_GETOWN: ::c_int = 9;\npub const F_SETOWN: ::c_int = 8;\npub const F_SETLK: ::c_int = 6;\npub const F_SETLKW: ::c_int = 7;\npub const F_OFD_GETLK: ::c_int = 36;\npub const F_OFD_SETLK: ::c_int = 37;\npub const F_OFD_SETLKW: ::c_int = 38;\n\npub const F_RDLCK: ::c_int = 0;\npub const F_WRLCK: ::c_int = 1;\npub const F_UNLCK: ::c_int = 2;\n\npub const SFD_NONBLOCK: ::c_int = 0x0800;\n\npub const TIOCEXCL: ::c_ulong = 0x540C;\npub const TIOCNXCL: ::c_ulong = 0x540D;\npub const TIOCSCTTY: ::c_ulong = 0x540E;\npub const TIOCSTI: ::c_ulong = 0x5412;\npub const TIOCMGET: ::c_ulong = 0x5415;\npub const TIOCMBIS: ::c_ulong = 0x5416;\npub const TIOCMBIC: ::c_ulong = 0x5417;\npub const TIOCMSET: ::c_ulong = 0x5418;\npub const TIOCGSOFTCAR: ::c_ulong = 0x5419;\npub const TIOCSSOFTCAR: ::c_ulong = 0x541A;\npub const TIOCCONS: ::c_ulong = 0x541D;\npub const TIOCSBRK: ::c_ulong = 0x5427;\npub const TIOCCBRK: ::c_ulong = 0x5428;\npub const TIOCGRS485: ::c_int = 0x542E;\npub const TIOCSRS485: ::c_int = 0x542F;\n\npub const TIOCM_ST: ::c_int = 0x008;\npub const TIOCM_SR: ::c_int = 0x010;\npub const TIOCM_CTS: ::c_int = 0x020;\npub const TIOCM_CAR: ::c_int = 0x040;\npub const TIOCM_RNG: ::c_int = 0x080;\npub const TIOCM_DSR: ::c_int = 0x100;\n\npub const SFD_CLOEXEC: ::c_int = 0x080000;\n\npub const NCCS: usize = 32;\n\npub const O_TRUNC: ::c_int = 512;\n\npub const O_CLOEXEC: ::c_int = 0x80000;\n\npub const EBFONT: ::c_int = 59;\npub const ENOSTR: ::c_int = 60;\npub const ENODATA: ::c_int = 61;\npub const ETIME: ::c_int = 62;\npub const ENOSR: ::c_int = 63;\npub const ENONET: ::c_int = 64;\npub const ENOPKG: ::c_int = 65;\npub const EREMOTE: ::c_int = 66;\npub const ENOLINK: ::c_int = 67;\npub const EADV: ::c_int = 68;\npub const ESRMNT: ::c_int = 69;\npub const ECOMM: ::c_int = 70;\npub const EPROTO: ::c_int = 71;\npub const EDOTDOT: ::c_int = 73;\n\npub const SA_NODEFER: ::c_int = 0x40000000;\npub const SA_RESETHAND: ::c_int = 0x80000000;\npub const SA_RESTART: ::c_int = 0x10000000;\npub const SA_NOCLDSTOP: ::c_int = 0x00000001;\n\npub const EPOLL_CLOEXEC: ::c_int = 0x80000;\n\npub const EFD_CLOEXEC: ::c_int = 0x80000;\n\npub const O_DIRECT: ::c_int = 0x10000;\npub const O_DIRECTORY: ::c_int = 0x4000;\npub const O_NOFOLLOW: ::c_int = 0x8000;\n\npub const MAP_LOCKED: ::c_int = 0x02000;\npub const MAP_NORESERVE: ::c_int = 0x04000;\npub const MAP_ANON: ::c_int = 0x0020;\npub const MAP_ANONYMOUS: ::c_int = 0x0020;\npub const MAP_DENYWRITE: ::c_int = 0x0800;\npub const MAP_EXECUTABLE: ::c_int = 0x01000;\npub const MAP_POPULATE: ::c_int = 0x08000;\npub const MAP_NONBLOCK: ::c_int = 0x010000;\npub const MAP_STACK: ::c_int = 0x020000;\npub const MAP_HUGETLB: ::c_int = 0x040000;\npub const MAP_SYNC: ::c_int = 0x080000;\n\npub const EDEADLOCK: ::c_int = 35;\n\npub const FIOCLEX: ::c_ulong = 0x5451;\npub const FIONCLEX: ::c_ulong = 0x5450;\npub const FIONBIO: ::c_ulong = 0x5421;\n\npub const MCL_CURRENT: ::c_int = 0x0001;\npub const MCL_FUTURE: ::c_int = 0x0002;\n\npub const SIGSTKSZ: ::size_t = 16384;\npub const MINSIGSTKSZ: ::size_t = 5120;\npub const CBAUD: ::tcflag_t = 0o0010017;\npub const TAB1: ::tcflag_t = 0x00000800;\npub const TAB2: ::tcflag_t = 0x00001000;\npub const TAB3: ::tcflag_t = 0x00001800;\npub const CR1: ::tcflag_t = 0x00000200;\npub const CR2: ::tcflag_t = 0x00000400;\npub const CR3: ::tcflag_t = 0x00000600;\npub const FF1: ::tcflag_t = 0x00008000;\npub const BS1: ::tcflag_t = 0x00002000;\npub const VT1: ::tcflag_t = 0x00004000;\npub const VWERASE: usize = 14;\npub const VREPRINT: usize = 12;\npub const VSUSP: usize = 10;\npub const VSTART: usize = 8;\npub const VSTOP: usize = 9;\npub const VDISCARD: usize = 13;\npub const VTIME: usize = 5;\npub const IXON: ::tcflag_t = 0x00000400;\npub const IXOFF: ::tcflag_t = 0x00001000;\npub const ONLCR: ::tcflag_t = 0x4;\npub const CSIZE: ::tcflag_t = 0x00000030;\npub const CS6: ::tcflag_t = 0x00000010;\npub const CS7: ::tcflag_t = 0x00000020;\npub const CS8: ::tcflag_t = 0x00000030;\npub const CSTOPB: ::tcflag_t = 0x00000040;\npub const CREAD: ::tcflag_t = 0x00000080;\npub const PARENB: ::tcflag_t = 0x00000100;\npub const PARODD: ::tcflag_t = 0x00000200;\npub const HUPCL: ::tcflag_t = 0x00000400;\npub const CLOCAL: ::tcflag_t = 0x00000800;\npub const ECHOKE: ::tcflag_t = 0x00000800;\npub const ECHOE: ::tcflag_t = 0x00000010;\npub const ECHOK: ::tcflag_t = 0x00000020;\npub const ECHONL: ::tcflag_t = 0x00000040;\npub const ECHOPRT: ::tcflag_t = 0x00000400;\npub const ECHOCTL: ::tcflag_t = 0x00000200;\npub const ISIG: ::tcflag_t = 0x00000001;\npub const ICANON: ::tcflag_t = 0x00000002;\npub const PENDIN: ::tcflag_t = 0x00004000;\npub const NOFLSH: ::tcflag_t = 0x00000080;\npub const CIBAUD: ::tcflag_t = 0o02003600000;\npub const CBAUDEX: ::tcflag_t = 0o010000;\npub const VSWTC: usize = 7;\npub const OLCUC: ::tcflag_t = 0o000002;\npub const NLDLY: ::tcflag_t = 0o000400;\npub const CRDLY: ::tcflag_t = 0o003000;\npub const TABDLY: ::tcflag_t = 0o014000;\npub const BSDLY: ::tcflag_t = 0o020000;\npub const FFDLY: ::tcflag_t = 0o100000;\npub const VTDLY: ::tcflag_t = 0o040000;\npub const XTABS: ::tcflag_t = 0o014000;\n\npub const B0: ::speed_t = 0o000000;\npub const B50: ::speed_t = 0o000001;\npub const B75: ::speed_t = 0o000002;\npub const B110: ::speed_t = 0o000003;\npub const B134: ::speed_t = 0o000004;\npub const B150: ::speed_t = 0o000005;\npub const B200: ::speed_t = 0o000006;\npub const B300: ::speed_t = 0o000007;\npub const B600: ::speed_t = 0o000010;\npub const B1200: ::speed_t = 0o000011;\npub const B1800: ::speed_t = 0o000012;\npub const B2400: ::speed_t = 0o000013;\npub const B4800: ::speed_t = 0o000014;\npub const B9600: ::speed_t = 0o000015;\npub const B19200: ::speed_t = 0o000016;\npub const B38400: ::speed_t = 0o000017;\npub const EXTA: ::speed_t = B19200;\npub const EXTB: ::speed_t = B38400;\npub const BOTHER: ::speed_t = 0o010000;\npub const B57600: ::speed_t = 0o010001;\npub const B115200: ::speed_t = 0o010002;\npub const B230400: ::speed_t = 0o010003;\npub const B460800: ::speed_t = 0o010004;\npub const B500000: ::speed_t = 0o010005;\npub const B576000: ::speed_t = 0o010006;\npub const B921600: ::speed_t = 0o010007;\npub const B1000000: ::speed_t = 0o010010;\npub const B1152000: ::speed_t = 0o010011;\npub const B1500000: ::speed_t = 0o010012;\npub const B2000000: ::speed_t = 0o010013;\npub const B2500000: ::speed_t = 0o010014;\npub const B3000000: ::speed_t = 0o010015;\npub const B3500000: ::speed_t = 0o010016;\npub const B4000000: ::speed_t = 0o010017;\n\npub const VEOL: usize = 11;\npub const VEOL2: usize = 16;\npub const VMIN: usize = 6;\npub const IEXTEN: ::tcflag_t = 0x00008000;\npub const TOSTOP: ::tcflag_t = 0x00000100;\npub const FLUSHO: ::tcflag_t = 0x00001000;\npub const EXTPROC: ::tcflag_t = 0x00010000;\npub const TCGETS: ::c_ulong = 0x5401;\npub const TCSETS: ::c_ulong = 0x5402;\npub const TCSETSW: ::c_ulong = 0x5403;\npub const TCSETSF: ::c_ulong = 0x5404;\npub const TCGETA: ::c_ulong = 0x5405;\npub const TCSETA: ::c_ulong = 0x5406;\npub const TCSETAW: ::c_ulong = 0x5407;\npub const TCSETAF: ::c_ulong = 0x5408;\npub const TCSBRK: ::c_ulong = 0x5409;\npub const TCXONC: ::c_ulong = 0x540A;\npub const TCFLSH: ::c_ulong = 0x540B;\npub const TIOCINQ: ::c_ulong = 0x541B;\npub const TIOCGPGRP: ::c_ulong = 0x540F;\npub const TIOCSPGRP: ::c_ulong = 0x5410;\npub const TIOCOUTQ: ::c_ulong = 0x5411;\npub const TIOCGWINSZ: ::c_ulong = 0x5413;\npub const TIOCSWINSZ: ::c_ulong = 0x5414;\npub const FIONREAD: ::c_ulong = 0x541B;\n\npub const TCSANOW: ::c_int = 0;\npub const TCSADRAIN: ::c_int = 1;\npub const TCSAFLUSH: ::c_int = 2;\n\npub const TIOCLINUX: ::c_ulong = 0x541C;\npub const TIOCGSERIAL: ::c_ulong = 0x541E;\n\n// sys/auxv.h\npub const HWCAP_FP: ::c_ulong = 1 << 0;\npub const HWCAP_ASIMD: ::c_ulong = 1 << 1;\npub const HWCAP_EVTSTRM: ::c_ulong = 1 << 2;\npub const HWCAP_AES: ::c_ulong = 1 << 3;\npub const HWCAP_PMULL: ::c_ulong = 1 << 4;\npub const HWCAP_SHA1: ::c_ulong = 1 << 5;\npub const HWCAP_SHA2: ::c_ulong = 1 << 6;\npub const HWCAP_CRC32: ::c_ulong = 1 << 7;\npub const HWCAP_ATOMICS: ::c_ulong = 1 << 8;\npub const HWCAP_FPHP: ::c_ulong = 1 << 9;\npub const HWCAP_ASIMDHP: ::c_ulong = 1 << 10;\npub const HWCAP_CPUID: ::c_ulong = 1 << 11;\npub const HWCAP_ASIMDRDM: ::c_ulong = 1 << 12;\npub const HWCAP_JSCVT: ::c_ulong = 1 << 13;\npub const HWCAP_FCMA: ::c_ulong = 1 << 14;\npub const HWCAP_LRCPC: ::c_ulong = 1 << 15;\npub const HWCAP_DCPOP: ::c_ulong = 1 << 16;\npub const HWCAP_SHA3: ::c_ulong = 1 << 17;\npub const HWCAP_SM3: ::c_ulong = 1 << 18;\npub const HWCAP_SM4: ::c_ulong = 1 << 19;\npub const HWCAP_ASIMDDP: ::c_ulong = 1 << 20;\npub const HWCAP_SHA512: ::c_ulong = 1 << 21;\npub const HWCAP_SVE: ::c_ulong = 1 << 22;\npub const HWCAP_ASIMDFHM: ::c_ulong = 1 << 23;\npub const HWCAP_DIT: ::c_ulong = 1 << 24;\npub const HWCAP_USCAT: ::c_ulong = 1 << 25;\npub const HWCAP_ILRCPC: ::c_ulong = 1 << 26;\npub const HWCAP_FLAGM: ::c_ulong = 1 << 27;\npub const HWCAP_SSBS: ::c_ulong = 1 << 28;\npub const HWCAP_SB: ::c_ulong = 1 << 29;\npub const HWCAP_PACA: ::c_ulong = 1 << 30;\npub const HWCAP_PACG: ::c_ulong = 1 << 31;\n// FIXME: enable these again once linux-api-headers are up to date enough on CI.\n// See discussion in https://github.com/rust-lang/libc/pull/1638\n//pub const HWCAP2_DCPODP: ::c_ulong = 1 << 0;\n//pub const HWCAP2_SVE2: ::c_ulong = 1 << 1;\n//pub const HWCAP2_SVEAES: ::c_ulong = 1 << 2;\n//pub const HWCAP2_SVEPMULL: ::c_ulong = 1 << 3;\n//pub const HWCAP2_SVEBITPERM: ::c_ulong = 1 << 4;\n//pub const HWCAP2_SVESHA3: ::c_ulong = 1 << 5;\n//pub const HWCAP2_SVESM4: ::c_ulong = 1 << 6;\n//pub const HWCAP2_FLAGM2: ::c_ulong = 1 << 7;\n//pub const HWCAP2_FRINT: ::c_ulong = 1 << 8;\n\n// Syscall table\npub const SYS_io_setup: ::c_long = 0;\npub const SYS_io_destroy: ::c_long = 1;\npub const SYS_io_submit: ::c_long = 2;\npub const SYS_io_cancel: ::c_long = 3;\npub const SYS_io_getevents: ::c_long = 4;\npub const SYS_setxattr: ::c_long = 5;\npub const SYS_lsetxattr: ::c_long = 6;\npub const SYS_fsetxattr: ::c_long = 7;\npub const SYS_getxattr: ::c_long = 8;\npub const SYS_lgetxattr: ::c_long = 9;\npub const SYS_fgetxattr: ::c_long = 10;\npub const SYS_listxattr: ::c_long = 11;\npub const SYS_llistxattr: ::c_long = 12;\npub const SYS_flistxattr: ::c_long = 13;\npub const SYS_removexattr: ::c_long = 14;\npub const SYS_lremovexattr: ::c_long = 15;\npub const SYS_fremovexattr: ::c_long = 16;\npub const SYS_getcwd: ::c_long = 17;\npub const SYS_lookup_dcookie: ::c_long = 18;\npub const SYS_eventfd2: ::c_long = 19;\npub const SYS_epoll_create1: ::c_long = 20;\npub const SYS_epoll_ctl: ::c_long = 21;\npub const SYS_epoll_pwait: ::c_long = 22;\npub const SYS_dup: ::c_long = 23;\npub const SYS_dup3: ::c_long = 24;\npub const SYS_fcntl: ::c_long = 25;\npub const SYS_inotify_init1: ::c_long = 26;\npub const SYS_inotify_add_watch: ::c_long = 27;\npub const SYS_inotify_rm_watch: ::c_long = 28;\npub const SYS_ioctl: ::c_long = 29;\npub const SYS_ioprio_set: ::c_long = 30;\npub const SYS_ioprio_get: ::c_long = 31;\npub const SYS_flock: ::c_long = 32;\npub const SYS_mknodat: ::c_long = 33;\npub const SYS_mkdirat: ::c_long = 34;\npub const SYS_unlinkat: ::c_long = 35;\npub const SYS_symlinkat: ::c_long = 36;\npub const SYS_linkat: ::c_long = 37;\n// 38 is renameat only on LP64\npub const SYS_umount2: ::c_long = 39;\npub const SYS_mount: ::c_long = 40;\npub const SYS_pivot_root: ::c_long = 41;\npub const SYS_nfsservctl: ::c_long = 42;\npub const SYS_statfs: ::c_long = 43;\npub const SYS_fstatfs: ::c_long = 44;\npub const SYS_truncate: ::c_long = 45;\npub const SYS_ftruncate: ::c_long = 46;\npub const SYS_fallocate: ::c_long = 47;\npub const SYS_faccessat: ::c_long = 48;\npub const SYS_chdir: ::c_long = 49;\npub const SYS_fchdir: ::c_long = 50;\npub const SYS_chroot: ::c_long = 51;\npub const SYS_fchmod: ::c_long = 52;\npub const SYS_fchmodat: ::c_long = 53;\npub const SYS_fchownat: ::c_long = 54;\npub const SYS_fchown: ::c_long = 55;\npub const SYS_openat: ::c_long = 56;\npub const SYS_close: ::c_long = 57;\npub const SYS_vhangup: ::c_long = 58;\npub const SYS_pipe2: ::c_long = 59;\npub const SYS_quotactl: ::c_long = 60;\npub const SYS_getdents64: ::c_long = 61;\npub const SYS_lseek: ::c_long = 62;\npub const SYS_read: ::c_long = 63;\npub const SYS_write: ::c_long = 64;\npub const SYS_readv: ::c_long = 65;\npub const SYS_writev: ::c_long = 66;\npub const SYS_pread64: ::c_long = 67;\npub const SYS_pwrite64: ::c_long = 68;\npub const SYS_preadv: ::c_long = 69;\npub const SYS_pwritev: ::c_long = 70;\npub const SYS_pselect6: ::c_long = 72;\npub const SYS_ppoll: ::c_long = 73;\npub const SYS_signalfd4: ::c_long = 74;\npub const SYS_vmsplice: ::c_long = 75;\npub const SYS_splice: ::c_long = 76;\npub const SYS_tee: ::c_long = 77;\npub const SYS_readlinkat: ::c_long = 78;\npub const SYS_newfstatat: ::c_long = 79;\npub const SYS_fstat: ::c_long = 80;\npub const SYS_sync: ::c_long = 81;\npub const SYS_fsync: ::c_long = 82;\npub const SYS_fdatasync: ::c_long = 83;\n// 84 sync_file_range on LP64 and sync_file_range2 on ILP32\npub const SYS_timerfd_create: ::c_long = 85;\npub const SYS_timerfd_settime: ::c_long = 86;\npub const SYS_timerfd_gettime: ::c_long = 87;\npub const SYS_utimensat: ::c_long = 88;\npub const SYS_acct: ::c_long = 89;\npub const SYS_capget: ::c_long = 90;\npub const SYS_capset: ::c_long = 91;\npub const SYS_personality: ::c_long = 92;\npub const SYS_exit: ::c_long = 93;\npub const SYS_exit_group: ::c_long = 94;\npub const SYS_waitid: ::c_long = 95;\npub const SYS_set_tid_address: ::c_long = 96;\npub const SYS_unshare: ::c_long = 97;\npub const SYS_futex: ::c_long = 98;\npub const SYS_set_robust_list: ::c_long = 99;\npub const SYS_get_robust_list: ::c_long = 100;\npub const SYS_nanosleep: ::c_long = 101;\npub const SYS_getitimer: ::c_long = 102;\npub const SYS_setitimer: ::c_long = 103;\npub const SYS_kexec_load: ::c_long = 104;\npub const SYS_init_module: ::c_long = 105;\npub const SYS_delete_module: ::c_long = 106;\npub const SYS_timer_create: ::c_long = 107;\npub const SYS_timer_gettime: ::c_long = 108;\npub const SYS_timer_getoverrun: ::c_long = 109;\npub const SYS_timer_settime: ::c_long = 110;\npub const SYS_timer_delete: ::c_long = 111;\npub const SYS_clock_settime: ::c_long = 112;\npub const SYS_clock_gettime: ::c_long = 113;\npub const SYS_clock_getres: ::c_long = 114;\npub const SYS_clock_nanosleep: ::c_long = 115;\npub const SYS_syslog: ::c_long = 116;\npub const SYS_ptrace: ::c_long = 117;\npub const SYS_sched_setparam: ::c_long = 118;\npub const SYS_sched_setscheduler: ::c_long = 119;\npub const SYS_sched_getscheduler: ::c_long = 120;\npub const SYS_sched_getparam: ::c_long = 121;\npub const SYS_sched_setaffinity: ::c_long = 122;\npub const SYS_sched_getaffinity: ::c_long = 123;\npub const SYS_sched_yield: ::c_long = 124;\npub const SYS_sched_get_priority_max: ::c_long = 125;\npub const SYS_sched_get_priority_min: ::c_long = 126;\npub const SYS_sched_rr_get_interval: ::c_long = 127;\npub const SYS_restart_syscall: ::c_long = 128;\npub const SYS_kill: ::c_long = 129;\npub const SYS_tkill: ::c_long = 130;\npub const SYS_tgkill: ::c_long = 131;\npub const SYS_sigaltstack: ::c_long = 132;\npub const SYS_rt_sigsuspend: ::c_long = 133;\npub const SYS_rt_sigaction: ::c_long = 134;\npub const SYS_rt_sigprocmask: ::c_long = 135;\npub const SYS_rt_sigpending: ::c_long = 136;\npub const SYS_rt_sigtimedwait: ::c_long = 137;\npub const SYS_rt_sigqueueinfo: ::c_long = 138;\npub const SYS_rt_sigreturn: ::c_long = 139;\npub const SYS_setpriority: ::c_long = 140;\npub const SYS_getpriority: ::c_long = 141;\npub const SYS_reboot: ::c_long = 142;\npub const SYS_setregid: ::c_long = 143;\npub const SYS_setgid: ::c_long = 144;\npub const SYS_setreuid: ::c_long = 145;\npub const SYS_setuid: ::c_long = 146;\npub const SYS_setresuid: ::c_long = 147;\npub const SYS_getresuid: ::c_long = 148;\npub const SYS_setresgid: ::c_long = 149;\npub const SYS_getresgid: ::c_long = 150;\npub const SYS_setfsuid: ::c_long = 151;\npub const SYS_setfsgid: ::c_long = 152;\npub const SYS_times: ::c_long = 153;\npub const SYS_setpgid: ::c_long = 154;\npub const SYS_getpgid: ::c_long = 155;\npub const SYS_getsid: ::c_long = 156;\npub const SYS_setsid: ::c_long = 157;\npub const SYS_getgroups: ::c_long = 158;\npub const SYS_setgroups: ::c_long = 159;\npub const SYS_uname: ::c_long = 160;\npub const SYS_sethostname: ::c_long = 161;\npub const SYS_setdomainname: ::c_long = 162;\n// 163 is getrlimit only on LP64\n// 164 is setrlimit only on LP64\npub const SYS_getrusage: ::c_long = 165;\npub const SYS_umask: ::c_long = 166;\npub const SYS_prctl: ::c_long = 167;\npub const SYS_getcpu: ::c_long = 168;\npub const SYS_gettimeofday: ::c_long = 169;\npub const SYS_settimeofday: ::c_long = 170;\npub const SYS_adjtimex: ::c_long = 171;\npub const SYS_getpid: ::c_long = 172;\npub const SYS_getppid: ::c_long = 173;\npub const SYS_getuid: ::c_long = 174;\npub const SYS_geteuid: ::c_long = 175;\npub const SYS_getgid: ::c_long = 176;\npub const SYS_getegid: ::c_long = 177;\npub const SYS_gettid: ::c_long = 178;\npub const SYS_sysinfo: ::c_long = 179;\npub const SYS_mq_open: ::c_long = 180;\npub const SYS_mq_unlink: ::c_long = 181;\npub const SYS_mq_timedsend: ::c_long = 182;\npub const SYS_mq_timedreceive: ::c_long = 183;\npub const SYS_mq_notify: ::c_long = 184;\npub const SYS_mq_getsetattr: ::c_long = 185;\npub const SYS_msgget: ::c_long = 186;\npub const SYS_msgctl: ::c_long = 187;\npub const SYS_msgrcv: ::c_long = 188;\npub const SYS_msgsnd: ::c_long = 189;\npub const SYS_semget: ::c_long = 190;\npub const SYS_semctl: ::c_long = 191;\npub const SYS_semtimedop: ::c_long = 192;\npub const SYS_semop: ::c_long = 193;\npub const SYS_shmget: ::c_long = 194;\npub const SYS_shmctl: ::c_long = 195;\npub const SYS_shmat: ::c_long = 196;\npub const SYS_shmdt: ::c_long = 197;\npub const SYS_socket: ::c_long = 198;\npub const SYS_socketpair: ::c_long = 199;\npub const SYS_bind: ::c_long = 200;\npub const SYS_listen: ::c_long = 201;\npub const SYS_accept: ::c_long = 202;\npub const SYS_connect: ::c_long = 203;\npub const SYS_getsockname: ::c_long = 204;\npub const SYS_getpeername: ::c_long = 205;\npub const SYS_sendto: ::c_long = 206;\npub const SYS_recvfrom: ::c_long = 207;\npub const SYS_setsockopt: ::c_long = 208;\npub const SYS_getsockopt: ::c_long = 209;\npub const SYS_shutdown: ::c_long = 210;\npub const SYS_sendmsg: ::c_long = 211;\npub const SYS_recvmsg: ::c_long = 212;\npub const SYS_readahead: ::c_long = 213;\npub const SYS_brk: ::c_long = 214;\npub const SYS_munmap: ::c_long = 215;\npub const SYS_mremap: ::c_long = 216;\npub const SYS_add_key: ::c_long = 217;\npub const SYS_request_key: ::c_long = 218;\npub const SYS_keyctl: ::c_long = 219;\npub const SYS_clone: ::c_long = 220;\npub const SYS_execve: ::c_long = 221;\npub const SYS_mmap: ::c_long = 222;\npub const SYS_swapon: ::c_long = 224;\npub const SYS_swapoff: ::c_long = 225;\npub const SYS_mprotect: ::c_long = 226;\npub const SYS_msync: ::c_long = 227;\npub const SYS_mlock: ::c_long = 228;\npub const SYS_munlock: ::c_long = 229;\npub const SYS_mlockall: ::c_long = 230;\npub const SYS_munlockall: ::c_long = 231;\npub const SYS_mincore: ::c_long = 232;\npub const SYS_madvise: ::c_long = 233;\npub const SYS_remap_file_pages: ::c_long = 234;\npub const SYS_mbind: ::c_long = 235;\npub const SYS_get_mempolicy: ::c_long = 236;\npub const SYS_set_mempolicy: ::c_long = 237;\npub const SYS_migrate_pages: ::c_long = 238;\npub const SYS_move_pages: ::c_long = 239;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 240;\npub const SYS_perf_event_open: ::c_long = 241;\npub const SYS_accept4: ::c_long = 242;\npub const SYS_recvmmsg: ::c_long = 243;\npub const SYS_wait4: ::c_long = 260;\npub const SYS_prlimit64: ::c_long = 261;\npub const SYS_fanotify_init: ::c_long = 262;\npub const SYS_fanotify_mark: ::c_long = 263;\npub const SYS_name_to_handle_at: ::c_long = 264;\npub const SYS_open_by_handle_at: ::c_long = 265;\npub const SYS_clock_adjtime: ::c_long = 266;\npub const SYS_syncfs: ::c_long = 267;\npub const SYS_setns: ::c_long = 268;\npub const SYS_sendmmsg: ::c_long = 269;\npub const SYS_process_vm_readv: ::c_long = 270;\npub const SYS_process_vm_writev: ::c_long = 271;\npub const SYS_kcmp: ::c_long = 272;\npub const SYS_finit_module: ::c_long = 273;\npub const SYS_sched_setattr: ::c_long = 274;\npub const SYS_sched_getattr: ::c_long = 275;\npub const SYS_renameat2: ::c_long = 276;\npub const SYS_seccomp: ::c_long = 277;\npub const SYS_getrandom: ::c_long = 278;\npub const SYS_memfd_create: ::c_long = 279;\npub const SYS_bpf: ::c_long = 280;\npub const SYS_execveat: ::c_long = 281;\npub const SYS_userfaultfd: ::c_long = 282;\npub const SYS_membarrier: ::c_long = 283;\npub const SYS_mlock2: ::c_long = 284;\npub const SYS_copy_file_range: ::c_long = 285;\npub const SYS_preadv2: ::c_long = 286;\npub const SYS_pwritev2: ::c_long = 287;\npub const SYS_pkey_mprotect: ::c_long = 288;\npub const SYS_pkey_alloc: ::c_long = 289;\npub const SYS_pkey_free: ::c_long = 290;\npub const SYS_statx: ::c_long = 291;\npub const SYS_pidfd_send_signal: ::c_long = 424;\npub const SYS_io_uring_setup: ::c_long = 425;\npub const SYS_io_uring_enter: ::c_long = 426;\npub const SYS_io_uring_register: ::c_long = 427;\npub const SYS_open_tree: ::c_long = 428;\npub const SYS_move_mount: ::c_long = 429;\npub const SYS_fsopen: ::c_long = 430;\npub const SYS_fsconfig: ::c_long = 431;\npub const SYS_fsmount: ::c_long = 432;\npub const SYS_fspick: ::c_long = 433;\npub const SYS_pidfd_open: ::c_long = 434;\npub const SYS_clone3: ::c_long = 435;\npub const SYS_close_range: ::c_long = 436;\npub const SYS_openat2: ::c_long = 437;\npub const SYS_pidfd_getfd: ::c_long = 438;\npub const SYS_faccessat2: ::c_long = 439;\npub const SYS_process_madvise: ::c_long = 440;\npub const SYS_epoll_pwait2: ::c_long = 441;\npub const SYS_mount_setattr: ::c_long = 442;\n\nextern \"C\" {\n    pub fn sysctl(\n        name: *mut ::c_int,\n        namelen: ::c_int,\n        oldp: *mut ::c_void,\n        oldlenp: *mut ::size_t,\n        newp: *mut ::c_void,\n        newlen: ::size_t,\n    ) -> ::c_int;\n}\n\ncfg_if! {\n    if #[cfg(target_pointer_width = \"32\")] {\n        mod ilp32;\n        pub use self::ilp32::*;\n    } else {\n        mod lp64;\n        pub use self::lp64::*;\n    }\n}\n\ncfg_if! {\n    if #[cfg(libc_align)] {\n        mod align;\n        pub use self::align::*;\n    }\n}\n"],["1170","use pthread_mutex_t;\n\npub type c_long = i32;\npub type c_ulong = u32;\n\ns! {\n    pub struct statvfs {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_favail: ::fsfilcnt_t,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n}\n\npub const __SIZEOF_PTHREAD_MUTEX_T: usize = 32;\npub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 44;\n\nalign_const! {\n    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n}\n\n// Syscall table\n\npub const __X32_SYSCALL_BIT: ::c_long = 0x40000000;\n\npub const SYS_read: ::c_long = __X32_SYSCALL_BIT + 0;\npub const SYS_write: ::c_long = __X32_SYSCALL_BIT + 1;\npub const SYS_open: ::c_long = __X32_SYSCALL_BIT + 2;\npub const SYS_close: ::c_long = __X32_SYSCALL_BIT + 3;\npub const SYS_stat: ::c_long = __X32_SYSCALL_BIT + 4;\npub const SYS_fstat: ::c_long = __X32_SYSCALL_BIT + 5;\npub const SYS_lstat: ::c_long = __X32_SYSCALL_BIT + 6;\npub const SYS_poll: ::c_long = __X32_SYSCALL_BIT + 7;\npub const SYS_lseek: ::c_long = __X32_SYSCALL_BIT + 8;\npub const SYS_mmap: ::c_long = __X32_SYSCALL_BIT + 9;\npub const SYS_mprotect: ::c_long = __X32_SYSCALL_BIT + 10;\npub const SYS_munmap: ::c_long = __X32_SYSCALL_BIT + 11;\npub const SYS_brk: ::c_long = __X32_SYSCALL_BIT + 12;\npub const SYS_rt_sigprocmask: ::c_long = __X32_SYSCALL_BIT + 14;\npub const SYS_pread64: ::c_long = __X32_SYSCALL_BIT + 17;\npub const SYS_pwrite64: ::c_long = __X32_SYSCALL_BIT + 18;\npub const SYS_access: ::c_long = __X32_SYSCALL_BIT + 21;\npub const SYS_pipe: ::c_long = __X32_SYSCALL_BIT + 22;\npub const SYS_select: ::c_long = __X32_SYSCALL_BIT + 23;\npub const SYS_sched_yield: ::c_long = __X32_SYSCALL_BIT + 24;\npub const SYS_mremap: ::c_long = __X32_SYSCALL_BIT + 25;\npub const SYS_msync: ::c_long = __X32_SYSCALL_BIT + 26;\npub const SYS_mincore: ::c_long = __X32_SYSCALL_BIT + 27;\npub const SYS_madvise: ::c_long = __X32_SYSCALL_BIT + 28;\npub const SYS_shmget: ::c_long = __X32_SYSCALL_BIT + 29;\npub const SYS_shmat: ::c_long = __X32_SYSCALL_BIT + 30;\npub const SYS_shmctl: ::c_long = __X32_SYSCALL_BIT + 31;\npub const SYS_dup: ::c_long = __X32_SYSCALL_BIT + 32;\npub const SYS_dup2: ::c_long = __X32_SYSCALL_BIT + 33;\npub const SYS_pause: ::c_long = __X32_SYSCALL_BIT + 34;\npub const SYS_nanosleep: ::c_long = __X32_SYSCALL_BIT + 35;\npub const SYS_getitimer: ::c_long = __X32_SYSCALL_BIT + 36;\npub const SYS_alarm: ::c_long = __X32_SYSCALL_BIT + 37;\npub const SYS_setitimer: ::c_long = __X32_SYSCALL_BIT + 38;\npub const SYS_getpid: ::c_long = __X32_SYSCALL_BIT + 39;\npub const SYS_sendfile: ::c_long = __X32_SYSCALL_BIT + 40;\npub const SYS_socket: ::c_long = __X32_SYSCALL_BIT + 41;\npub const SYS_connect: ::c_long = __X32_SYSCALL_BIT + 42;\npub const SYS_accept: ::c_long = __X32_SYSCALL_BIT + 43;\npub const SYS_sendto: ::c_long = __X32_SYSCALL_BIT + 44;\npub const SYS_shutdown: ::c_long = __X32_SYSCALL_BIT + 48;\npub const SYS_bind: ::c_long = __X32_SYSCALL_BIT + 49;\npub const SYS_listen: ::c_long = __X32_SYSCALL_BIT + 50;\npub const SYS_getsockname: ::c_long = __X32_SYSCALL_BIT + 51;\npub const SYS_getpeername: ::c_long = __X32_SYSCALL_BIT + 52;\npub const SYS_socketpair: ::c_long = __X32_SYSCALL_BIT + 53;\npub const SYS_clone: ::c_long = __X32_SYSCALL_BIT + 56;\npub const SYS_fork: ::c_long = __X32_SYSCALL_BIT + 57;\npub const SYS_vfork: ::c_long = __X32_SYSCALL_BIT + 58;\npub const SYS_exit: ::c_long = __X32_SYSCALL_BIT + 60;\npub const SYS_wait4: ::c_long = __X32_SYSCALL_BIT + 61;\npub const SYS_kill: ::c_long = __X32_SYSCALL_BIT + 62;\npub const SYS_uname: ::c_long = __X32_SYSCALL_BIT + 63;\npub const SYS_semget: ::c_long = __X32_SYSCALL_BIT + 64;\npub const SYS_semop: ::c_long = __X32_SYSCALL_BIT + 65;\npub const SYS_semctl: ::c_long = __X32_SYSCALL_BIT + 66;\npub const SYS_shmdt: ::c_long = __X32_SYSCALL_BIT + 67;\npub const SYS_msgget: ::c_long = __X32_SYSCALL_BIT + 68;\npub const SYS_msgsnd: ::c_long = __X32_SYSCALL_BIT + 69;\npub const SYS_msgrcv: ::c_long = __X32_SYSCALL_BIT + 70;\npub const SYS_msgctl: ::c_long = __X32_SYSCALL_BIT + 71;\npub const SYS_fcntl: ::c_long = __X32_SYSCALL_BIT + 72;\npub const SYS_flock: ::c_long = __X32_SYSCALL_BIT + 73;\npub const SYS_fsync: ::c_long = __X32_SYSCALL_BIT + 74;\npub const SYS_fdatasync: ::c_long = __X32_SYSCALL_BIT + 75;\npub const SYS_truncate: ::c_long = __X32_SYSCALL_BIT + 76;\npub const SYS_ftruncate: ::c_long = __X32_SYSCALL_BIT + 77;\npub const SYS_getdents: ::c_long = __X32_SYSCALL_BIT + 78;\npub const SYS_getcwd: ::c_long = __X32_SYSCALL_BIT + 79;\npub const SYS_chdir: ::c_long = __X32_SYSCALL_BIT + 80;\npub const SYS_fchdir: ::c_long = __X32_SYSCALL_BIT + 81;\npub const SYS_rename: ::c_long = __X32_SYSCALL_BIT + 82;\npub const SYS_mkdir: ::c_long = __X32_SYSCALL_BIT + 83;\npub const SYS_rmdir: ::c_long = __X32_SYSCALL_BIT + 84;\npub const SYS_creat: ::c_long = __X32_SYSCALL_BIT + 85;\npub const SYS_link: ::c_long = __X32_SYSCALL_BIT + 86;\npub const SYS_unlink: ::c_long = __X32_SYSCALL_BIT + 87;\npub const SYS_symlink: ::c_long = __X32_SYSCALL_BIT + 88;\npub const SYS_readlink: ::c_long = __X32_SYSCALL_BIT + 89;\npub const SYS_chmod: ::c_long = __X32_SYSCALL_BIT + 90;\npub const SYS_fchmod: ::c_long = __X32_SYSCALL_BIT + 91;\npub const SYS_chown: ::c_long = __X32_SYSCALL_BIT + 92;\npub const SYS_fchown: ::c_long = __X32_SYSCALL_BIT + 93;\npub const SYS_lchown: ::c_long = __X32_SYSCALL_BIT + 94;\npub const SYS_umask: ::c_long = __X32_SYSCALL_BIT + 95;\npub const SYS_gettimeofday: ::c_long = __X32_SYSCALL_BIT + 96;\npub const SYS_getrlimit: ::c_long = __X32_SYSCALL_BIT + 97;\npub const SYS_getrusage: ::c_long = __X32_SYSCALL_BIT + 98;\npub const SYS_sysinfo: ::c_long = __X32_SYSCALL_BIT + 99;\npub const SYS_times: ::c_long = __X32_SYSCALL_BIT + 100;\npub const SYS_getuid: ::c_long = __X32_SYSCALL_BIT + 102;\npub const SYS_syslog: ::c_long = __X32_SYSCALL_BIT + 103;\npub const SYS_getgid: ::c_long = __X32_SYSCALL_BIT + 104;\npub const SYS_setuid: ::c_long = __X32_SYSCALL_BIT + 105;\npub const SYS_setgid: ::c_long = __X32_SYSCALL_BIT + 106;\npub const SYS_geteuid: ::c_long = __X32_SYSCALL_BIT + 107;\npub const SYS_getegid: ::c_long = __X32_SYSCALL_BIT + 108;\npub const SYS_setpgid: ::c_long = __X32_SYSCALL_BIT + 109;\npub const SYS_getppid: ::c_long = __X32_SYSCALL_BIT + 110;\npub const SYS_getpgrp: ::c_long = __X32_SYSCALL_BIT + 111;\npub const SYS_setsid: ::c_long = __X32_SYSCALL_BIT + 112;\npub const SYS_setreuid: ::c_long = __X32_SYSCALL_BIT + 113;\npub const SYS_setregid: ::c_long = __X32_SYSCALL_BIT + 114;\npub const SYS_getgroups: ::c_long = __X32_SYSCALL_BIT + 115;\npub const SYS_setgroups: ::c_long = __X32_SYSCALL_BIT + 116;\npub const SYS_setresuid: ::c_long = __X32_SYSCALL_BIT + 117;\npub const SYS_getresuid: ::c_long = __X32_SYSCALL_BIT + 118;\npub const SYS_setresgid: ::c_long = __X32_SYSCALL_BIT + 119;\npub const SYS_getresgid: ::c_long = __X32_SYSCALL_BIT + 120;\npub const SYS_getpgid: ::c_long = __X32_SYSCALL_BIT + 121;\npub const SYS_setfsuid: ::c_long = __X32_SYSCALL_BIT + 122;\npub const SYS_setfsgid: ::c_long = __X32_SYSCALL_BIT + 123;\npub const SYS_getsid: ::c_long = __X32_SYSCALL_BIT + 124;\npub const SYS_capget: ::c_long = __X32_SYSCALL_BIT + 125;\npub const SYS_capset: ::c_long = __X32_SYSCALL_BIT + 126;\npub const SYS_rt_sigsuspend: ::c_long = __X32_SYSCALL_BIT + 130;\npub const SYS_utime: ::c_long = __X32_SYSCALL_BIT + 132;\npub const SYS_mknod: ::c_long = __X32_SYSCALL_BIT + 133;\npub const SYS_personality: ::c_long = __X32_SYSCALL_BIT + 135;\npub const SYS_ustat: ::c_long = __X32_SYSCALL_BIT + 136;\npub const SYS_statfs: ::c_long = __X32_SYSCALL_BIT + 137;\npub const SYS_fstatfs: ::c_long = __X32_SYSCALL_BIT + 138;\npub const SYS_sysfs: ::c_long = __X32_SYSCALL_BIT + 139;\npub const SYS_getpriority: ::c_long = __X32_SYSCALL_BIT + 140;\npub const SYS_setpriority: ::c_long = __X32_SYSCALL_BIT + 141;\npub const SYS_sched_setparam: ::c_long = __X32_SYSCALL_BIT + 142;\npub const SYS_sched_getparam: ::c_long = __X32_SYSCALL_BIT + 143;\npub const SYS_sched_setscheduler: ::c_long = __X32_SYSCALL_BIT + 144;\npub const SYS_sched_getscheduler: ::c_long = __X32_SYSCALL_BIT + 145;\npub const SYS_sched_get_priority_max: ::c_long = __X32_SYSCALL_BIT + 146;\npub const SYS_sched_get_priority_min: ::c_long = __X32_SYSCALL_BIT + 147;\npub const SYS_sched_rr_get_interval: ::c_long = __X32_SYSCALL_BIT + 148;\npub const SYS_mlock: ::c_long = __X32_SYSCALL_BIT + 149;\npub const SYS_munlock: ::c_long = __X32_SYSCALL_BIT + 150;\npub const SYS_mlockall: ::c_long = __X32_SYSCALL_BIT + 151;\npub const SYS_munlockall: ::c_long = __X32_SYSCALL_BIT + 152;\npub const SYS_vhangup: ::c_long = __X32_SYSCALL_BIT + 153;\npub const SYS_modify_ldt: ::c_long = __X32_SYSCALL_BIT + 154;\npub const SYS_pivot_root: ::c_long = __X32_SYSCALL_BIT + 155;\npub const SYS_prctl: ::c_long = __X32_SYSCALL_BIT + 157;\npub const SYS_arch_prctl: ::c_long = __X32_SYSCALL_BIT + 158;\npub const SYS_adjtimex: ::c_long = __X32_SYSCALL_BIT + 159;\npub const SYS_setrlimit: ::c_long = __X32_SYSCALL_BIT + 160;\npub const SYS_chroot: ::c_long = __X32_SYSCALL_BIT + 161;\npub const SYS_sync: ::c_long = __X32_SYSCALL_BIT + 162;\npub const SYS_acct: ::c_long = __X32_SYSCALL_BIT + 163;\npub const SYS_settimeofday: ::c_long = __X32_SYSCALL_BIT + 164;\npub const SYS_mount: ::c_long = __X32_SYSCALL_BIT + 165;\npub const SYS_umount2: ::c_long = __X32_SYSCALL_BIT + 166;\npub const SYS_swapon: ::c_long = __X32_SYSCALL_BIT + 167;\npub const SYS_swapoff: ::c_long = __X32_SYSCALL_BIT + 168;\npub const SYS_reboot: ::c_long = __X32_SYSCALL_BIT + 169;\npub const SYS_sethostname: ::c_long = __X32_SYSCALL_BIT + 170;\npub const SYS_setdomainname: ::c_long = __X32_SYSCALL_BIT + 171;\npub const SYS_iopl: ::c_long = __X32_SYSCALL_BIT + 172;\npub const SYS_ioperm: ::c_long = __X32_SYSCALL_BIT + 173;\npub const SYS_init_module: ::c_long = __X32_SYSCALL_BIT + 175;\npub const SYS_delete_module: ::c_long = __X32_SYSCALL_BIT + 176;\npub const SYS_quotactl: ::c_long = __X32_SYSCALL_BIT + 179;\npub const SYS_getpmsg: ::c_long = __X32_SYSCALL_BIT + 181;\npub const SYS_putpmsg: ::c_long = __X32_SYSCALL_BIT + 182;\npub const SYS_afs_syscall: ::c_long = __X32_SYSCALL_BIT + 183;\npub const SYS_tuxcall: ::c_long = __X32_SYSCALL_BIT + 184;\npub const SYS_security: ::c_long = __X32_SYSCALL_BIT + 185;\npub const SYS_gettid: ::c_long = __X32_SYSCALL_BIT + 186;\npub const SYS_readahead: ::c_long = __X32_SYSCALL_BIT + 187;\npub const SYS_setxattr: ::c_long = __X32_SYSCALL_BIT + 188;\npub const SYS_lsetxattr: ::c_long = __X32_SYSCALL_BIT + 189;\npub const SYS_fsetxattr: ::c_long = __X32_SYSCALL_BIT + 190;\npub const SYS_getxattr: ::c_long = __X32_SYSCALL_BIT + 191;\npub const SYS_lgetxattr: ::c_long = __X32_SYSCALL_BIT + 192;\npub const SYS_fgetxattr: ::c_long = __X32_SYSCALL_BIT + 193;\npub const SYS_listxattr: ::c_long = __X32_SYSCALL_BIT + 194;\npub const SYS_llistxattr: ::c_long = __X32_SYSCALL_BIT + 195;\npub const SYS_flistxattr: ::c_long = __X32_SYSCALL_BIT + 196;\npub const SYS_removexattr: ::c_long = __X32_SYSCALL_BIT + 197;\npub const SYS_lremovexattr: ::c_long = __X32_SYSCALL_BIT + 198;\npub const SYS_fremovexattr: ::c_long = __X32_SYSCALL_BIT + 199;\npub const SYS_tkill: ::c_long = __X32_SYSCALL_BIT + 200;\npub const SYS_time: ::c_long = __X32_SYSCALL_BIT + 201;\npub const SYS_futex: ::c_long = __X32_SYSCALL_BIT + 202;\npub const SYS_sched_setaffinity: ::c_long = __X32_SYSCALL_BIT + 203;\npub const SYS_sched_getaffinity: ::c_long = __X32_SYSCALL_BIT + 204;\npub const SYS_io_destroy: ::c_long = __X32_SYSCALL_BIT + 207;\npub const SYS_io_getevents: ::c_long = __X32_SYSCALL_BIT + 208;\npub const SYS_io_cancel: ::c_long = __X32_SYSCALL_BIT + 210;\npub const SYS_lookup_dcookie: ::c_long = __X32_SYSCALL_BIT + 212;\npub const SYS_epoll_create: ::c_long = __X32_SYSCALL_BIT + 213;\npub const SYS_remap_file_pages: ::c_long = __X32_SYSCALL_BIT + 216;\npub const SYS_getdents64: ::c_long = __X32_SYSCALL_BIT + 217;\npub const SYS_set_tid_address: ::c_long = __X32_SYSCALL_BIT + 218;\npub const SYS_restart_syscall: ::c_long = __X32_SYSCALL_BIT + 219;\npub const SYS_semtimedop: ::c_long = __X32_SYSCALL_BIT + 220;\npub const SYS_fadvise64: ::c_long = __X32_SYSCALL_BIT + 221;\npub const SYS_timer_settime: ::c_long = __X32_SYSCALL_BIT + 223;\npub const SYS_timer_gettime: ::c_long = __X32_SYSCALL_BIT + 224;\npub const SYS_timer_getoverrun: ::c_long = __X32_SYSCALL_BIT + 225;\npub const SYS_timer_delete: ::c_long = __X32_SYSCALL_BIT + 226;\npub const SYS_clock_settime: ::c_long = __X32_SYSCALL_BIT + 227;\npub const SYS_clock_gettime: ::c_long = __X32_SYSCALL_BIT + 228;\npub const SYS_clock_getres: ::c_long = __X32_SYSCALL_BIT + 229;\npub const SYS_clock_nanosleep: ::c_long = __X32_SYSCALL_BIT + 230;\npub const SYS_exit_group: ::c_long = __X32_SYSCALL_BIT + 231;\npub const SYS_epoll_wait: ::c_long = __X32_SYSCALL_BIT + 232;\npub const SYS_epoll_ctl: ::c_long = __X32_SYSCALL_BIT + 233;\npub const SYS_tgkill: ::c_long = __X32_SYSCALL_BIT + 234;\npub const SYS_utimes: ::c_long = __X32_SYSCALL_BIT + 235;\npub const SYS_mbind: ::c_long = __X32_SYSCALL_BIT + 237;\npub const SYS_set_mempolicy: ::c_long = __X32_SYSCALL_BIT + 238;\npub const SYS_get_mempolicy: ::c_long = __X32_SYSCALL_BIT + 239;\npub const SYS_mq_open: ::c_long = __X32_SYSCALL_BIT + 240;\npub const SYS_mq_unlink: ::c_long = __X32_SYSCALL_BIT + 241;\npub const SYS_mq_timedsend: ::c_long = __X32_SYSCALL_BIT + 242;\npub const SYS_mq_timedreceive: ::c_long = __X32_SYSCALL_BIT + 243;\npub const SYS_mq_getsetattr: ::c_long = __X32_SYSCALL_BIT + 245;\npub const SYS_add_key: ::c_long = __X32_SYSCALL_BIT + 248;\npub const SYS_request_key: ::c_long = __X32_SYSCALL_BIT + 249;\npub const SYS_keyctl: ::c_long = __X32_SYSCALL_BIT + 250;\npub const SYS_ioprio_set: ::c_long = __X32_SYSCALL_BIT + 251;\npub const SYS_ioprio_get: ::c_long = __X32_SYSCALL_BIT + 252;\npub const SYS_inotify_init: ::c_long = __X32_SYSCALL_BIT + 253;\npub const SYS_inotify_add_watch: ::c_long = __X32_SYSCALL_BIT + 254;\npub const SYS_inotify_rm_watch: ::c_long = __X32_SYSCALL_BIT + 255;\npub const SYS_migrate_pages: ::c_long = __X32_SYSCALL_BIT + 256;\npub const SYS_openat: ::c_long = __X32_SYSCALL_BIT + 257;\npub const SYS_mkdirat: ::c_long = __X32_SYSCALL_BIT + 258;\npub const SYS_mknodat: ::c_long = __X32_SYSCALL_BIT + 259;\npub const SYS_fchownat: ::c_long = __X32_SYSCALL_BIT + 260;\npub const SYS_futimesat: ::c_long = __X32_SYSCALL_BIT + 261;\npub const SYS_newfstatat: ::c_long = __X32_SYSCALL_BIT + 262;\npub const SYS_unlinkat: ::c_long = __X32_SYSCALL_BIT + 263;\npub const SYS_renameat: ::c_long = __X32_SYSCALL_BIT + 264;\npub const SYS_linkat: ::c_long = __X32_SYSCALL_BIT + 265;\npub const SYS_symlinkat: ::c_long = __X32_SYSCALL_BIT + 266;\npub const SYS_readlinkat: ::c_long = __X32_SYSCALL_BIT + 267;\npub const SYS_fchmodat: ::c_long = __X32_SYSCALL_BIT + 268;\npub const SYS_faccessat: ::c_long = __X32_SYSCALL_BIT + 269;\npub const SYS_pselect6: ::c_long = __X32_SYSCALL_BIT + 270;\npub const SYS_ppoll: ::c_long = __X32_SYSCALL_BIT + 271;\npub const SYS_unshare: ::c_long = __X32_SYSCALL_BIT + 272;\npub const SYS_splice: ::c_long = __X32_SYSCALL_BIT + 275;\npub const SYS_tee: ::c_long = __X32_SYSCALL_BIT + 276;\npub const SYS_sync_file_range: ::c_long = __X32_SYSCALL_BIT + 277;\npub const SYS_utimensat: ::c_long = __X32_SYSCALL_BIT + 280;\npub const SYS_epoll_pwait: ::c_long = __X32_SYSCALL_BIT + 281;\npub const SYS_signalfd: ::c_long = __X32_SYSCALL_BIT + 282;\npub const SYS_timerfd_create: ::c_long = __X32_SYSCALL_BIT + 283;\npub const SYS_eventfd: ::c_long = __X32_SYSCALL_BIT + 284;\npub const SYS_fallocate: ::c_long = __X32_SYSCALL_BIT + 285;\npub const SYS_timerfd_settime: ::c_long = __X32_SYSCALL_BIT + 286;\npub const SYS_timerfd_gettime: ::c_long = __X32_SYSCALL_BIT + 287;\npub const SYS_accept4: ::c_long = __X32_SYSCALL_BIT + 288;\npub const SYS_signalfd4: ::c_long = __X32_SYSCALL_BIT + 289;\npub const SYS_eventfd2: ::c_long = __X32_SYSCALL_BIT + 290;\npub const SYS_epoll_create1: ::c_long = __X32_SYSCALL_BIT + 291;\npub const SYS_dup3: ::c_long = __X32_SYSCALL_BIT + 292;\npub const SYS_pipe2: ::c_long = __X32_SYSCALL_BIT + 293;\npub const SYS_inotify_init1: ::c_long = __X32_SYSCALL_BIT + 294;\npub const SYS_perf_event_open: ::c_long = __X32_SYSCALL_BIT + 298;\npub const SYS_fanotify_init: ::c_long = __X32_SYSCALL_BIT + 300;\npub const SYS_fanotify_mark: ::c_long = __X32_SYSCALL_BIT + 301;\npub const SYS_prlimit64: ::c_long = __X32_SYSCALL_BIT + 302;\npub const SYS_name_to_handle_at: ::c_long = __X32_SYSCALL_BIT + 303;\npub const SYS_open_by_handle_at: ::c_long = __X32_SYSCALL_BIT + 304;\npub const SYS_clock_adjtime: ::c_long = __X32_SYSCALL_BIT + 305;\npub const SYS_syncfs: ::c_long = __X32_SYSCALL_BIT + 306;\npub const SYS_setns: ::c_long = __X32_SYSCALL_BIT + 308;\npub const SYS_getcpu: ::c_long = __X32_SYSCALL_BIT + 309;\npub const SYS_kcmp: ::c_long = __X32_SYSCALL_BIT + 312;\npub const SYS_finit_module: ::c_long = __X32_SYSCALL_BIT + 313;\npub const SYS_sched_setattr: ::c_long = __X32_SYSCALL_BIT + 314;\npub const SYS_sched_getattr: ::c_long = __X32_SYSCALL_BIT + 315;\npub const SYS_renameat2: ::c_long = __X32_SYSCALL_BIT + 316;\npub const SYS_seccomp: ::c_long = __X32_SYSCALL_BIT + 317;\npub const SYS_getrandom: ::c_long = __X32_SYSCALL_BIT + 318;\npub const SYS_memfd_create: ::c_long = __X32_SYSCALL_BIT + 319;\npub const SYS_kexec_file_load: ::c_long = __X32_SYSCALL_BIT + 320;\npub const SYS_bpf: ::c_long = __X32_SYSCALL_BIT + 321;\npub const SYS_userfaultfd: ::c_long = __X32_SYSCALL_BIT + 323;\npub const SYS_membarrier: ::c_long = __X32_SYSCALL_BIT + 324;\npub const SYS_mlock2: ::c_long = __X32_SYSCALL_BIT + 325;\npub const SYS_copy_file_range: ::c_long = __X32_SYSCALL_BIT + 326;\npub const SYS_pkey_mprotect: ::c_long = __X32_SYSCALL_BIT + 329;\npub const SYS_pkey_alloc: ::c_long = __X32_SYSCALL_BIT + 330;\npub const SYS_pkey_free: ::c_long = __X32_SYSCALL_BIT + 331;\npub const SYS_statx: ::c_long = __X32_SYSCALL_BIT + 332;\npub const SYS_pidfd_send_signal: ::c_long = __X32_SYSCALL_BIT + 424;\npub const SYS_io_uring_setup: ::c_long = __X32_SYSCALL_BIT + 425;\npub const SYS_io_uring_enter: ::c_long = __X32_SYSCALL_BIT + 426;\npub const SYS_io_uring_register: ::c_long = __X32_SYSCALL_BIT + 427;\npub const SYS_open_tree: ::c_long = __X32_SYSCALL_BIT + 428;\npub const SYS_move_mount: ::c_long = __X32_SYSCALL_BIT + 429;\npub const SYS_fsopen: ::c_long = __X32_SYSCALL_BIT + 430;\npub const SYS_fsconfig: ::c_long = __X32_SYSCALL_BIT + 431;\npub const SYS_fsmount: ::c_long = __X32_SYSCALL_BIT + 432;\npub const SYS_fspick: ::c_long = __X32_SYSCALL_BIT + 433;\npub const SYS_pidfd_open: ::c_long = __X32_SYSCALL_BIT + 434;\npub const SYS_clone3: ::c_long = __X32_SYSCALL_BIT + 435;\npub const SYS_close_range: ::c_long = __X32_SYSCALL_BIT + 436;\npub const SYS_openat2: ::c_long = __X32_SYSCALL_BIT + 437;\npub const SYS_pidfd_getfd: ::c_long = __X32_SYSCALL_BIT + 438;\npub const SYS_faccessat2: ::c_long = __X32_SYSCALL_BIT + 439;\npub const SYS_process_madvise: ::c_long = __X32_SYSCALL_BIT + 440;\npub const SYS_epoll_pwait2: ::c_long = __X32_SYSCALL_BIT + 441;\npub const SYS_mount_setattr: ::c_long = __X32_SYSCALL_BIT + 442;\npub const SYS_rt_sigaction: ::c_long = __X32_SYSCALL_BIT + 512;\npub const SYS_rt_sigreturn: ::c_long = __X32_SYSCALL_BIT + 513;\npub const SYS_ioctl: ::c_long = __X32_SYSCALL_BIT + 514;\npub const SYS_readv: ::c_long = __X32_SYSCALL_BIT + 515;\npub const SYS_writev: ::c_long = __X32_SYSCALL_BIT + 516;\npub const SYS_recvfrom: ::c_long = __X32_SYSCALL_BIT + 517;\npub const SYS_sendmsg: ::c_long = __X32_SYSCALL_BIT + 518;\npub const SYS_recvmsg: ::c_long = __X32_SYSCALL_BIT + 519;\npub const SYS_execve: ::c_long = __X32_SYSCALL_BIT + 520;\npub const SYS_ptrace: ::c_long = __X32_SYSCALL_BIT + 521;\npub const SYS_rt_sigpending: ::c_long = __X32_SYSCALL_BIT + 522;\npub const SYS_rt_sigtimedwait: ::c_long = __X32_SYSCALL_BIT + 523;\npub const SYS_rt_sigqueueinfo: ::c_long = __X32_SYSCALL_BIT + 524;\npub const SYS_sigaltstack: ::c_long = __X32_SYSCALL_BIT + 525;\npub const SYS_timer_create: ::c_long = __X32_SYSCALL_BIT + 526;\npub const SYS_mq_notify: ::c_long = __X32_SYSCALL_BIT + 527;\npub const SYS_kexec_load: ::c_long = __X32_SYSCALL_BIT + 528;\npub const SYS_waitid: ::c_long = __X32_SYSCALL_BIT + 529;\npub const SYS_set_robust_list: ::c_long = __X32_SYSCALL_BIT + 530;\npub const SYS_get_robust_list: ::c_long = __X32_SYSCALL_BIT + 531;\npub const SYS_vmsplice: ::c_long = __X32_SYSCALL_BIT + 532;\npub const SYS_move_pages: ::c_long = __X32_SYSCALL_BIT + 533;\npub const SYS_preadv: ::c_long = __X32_SYSCALL_BIT + 534;\npub const SYS_pwritev: ::c_long = __X32_SYSCALL_BIT + 535;\npub const SYS_rt_tgsigqueueinfo: ::c_long = __X32_SYSCALL_BIT + 536;\npub const SYS_recvmmsg: ::c_long = __X32_SYSCALL_BIT + 537;\npub const SYS_sendmmsg: ::c_long = __X32_SYSCALL_BIT + 538;\npub const SYS_process_vm_readv: ::c_long = __X32_SYSCALL_BIT + 539;\npub const SYS_process_vm_writev: ::c_long = __X32_SYSCALL_BIT + 540;\npub const SYS_setsockopt: ::c_long = __X32_SYSCALL_BIT + 541;\npub const SYS_getsockopt: ::c_long = __X32_SYSCALL_BIT + 542;\npub const SYS_io_setup: ::c_long = __X32_SYSCALL_BIT + 543;\npub const SYS_io_submit: ::c_long = __X32_SYSCALL_BIT + 544;\npub const SYS_execveat: ::c_long = __X32_SYSCALL_BIT + 545;\npub const SYS_preadv2: ::c_long = __X32_SYSCALL_BIT + 546;\npub const SYS_pwritev2: ::c_long = __X32_SYSCALL_BIT + 547;\n"],["1171","use pthread_mutex_t;\n\npub type c_long = i64;\npub type c_ulong = u64;\n\ns! {\n    pub struct statvfs {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_favail: ::fsfilcnt_t,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n}\n\npub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;\npub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;\n\nalign_const! {\n    #[cfg(target_endian = \"little\")]\n    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"little\")]\n    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"little\")]\n    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"big\")]\n    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"big\")]\n    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"big\")]\n    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n}\n\n// Syscall table\n\npub const SYS_read: ::c_long = 0;\npub const SYS_write: ::c_long = 1;\npub const SYS_open: ::c_long = 2;\npub const SYS_close: ::c_long = 3;\npub const SYS_stat: ::c_long = 4;\npub const SYS_fstat: ::c_long = 5;\npub const SYS_lstat: ::c_long = 6;\npub const SYS_poll: ::c_long = 7;\npub const SYS_lseek: ::c_long = 8;\npub const SYS_mmap: ::c_long = 9;\npub const SYS_mprotect: ::c_long = 10;\npub const SYS_munmap: ::c_long = 11;\npub const SYS_brk: ::c_long = 12;\npub const SYS_rt_sigaction: ::c_long = 13;\npub const SYS_rt_sigprocmask: ::c_long = 14;\npub const SYS_rt_sigreturn: ::c_long = 15;\npub const SYS_ioctl: ::c_long = 16;\npub const SYS_pread64: ::c_long = 17;\npub const SYS_pwrite64: ::c_long = 18;\npub const SYS_readv: ::c_long = 19;\npub const SYS_writev: ::c_long = 20;\npub const SYS_access: ::c_long = 21;\npub const SYS_pipe: ::c_long = 22;\npub const SYS_select: ::c_long = 23;\npub const SYS_sched_yield: ::c_long = 24;\npub const SYS_mremap: ::c_long = 25;\npub const SYS_msync: ::c_long = 26;\npub const SYS_mincore: ::c_long = 27;\npub const SYS_madvise: ::c_long = 28;\npub const SYS_shmget: ::c_long = 29;\npub const SYS_shmat: ::c_long = 30;\npub const SYS_shmctl: ::c_long = 31;\npub const SYS_dup: ::c_long = 32;\npub const SYS_dup2: ::c_long = 33;\npub const SYS_pause: ::c_long = 34;\npub const SYS_nanosleep: ::c_long = 35;\npub const SYS_getitimer: ::c_long = 36;\npub const SYS_alarm: ::c_long = 37;\npub const SYS_setitimer: ::c_long = 38;\npub const SYS_getpid: ::c_long = 39;\npub const SYS_sendfile: ::c_long = 40;\npub const SYS_socket: ::c_long = 41;\npub const SYS_connect: ::c_long = 42;\npub const SYS_accept: ::c_long = 43;\npub const SYS_sendto: ::c_long = 44;\npub const SYS_recvfrom: ::c_long = 45;\npub const SYS_sendmsg: ::c_long = 46;\npub const SYS_recvmsg: ::c_long = 47;\npub const SYS_shutdown: ::c_long = 48;\npub const SYS_bind: ::c_long = 49;\npub const SYS_listen: ::c_long = 50;\npub const SYS_getsockname: ::c_long = 51;\npub const SYS_getpeername: ::c_long = 52;\npub const SYS_socketpair: ::c_long = 53;\npub const SYS_setsockopt: ::c_long = 54;\npub const SYS_getsockopt: ::c_long = 55;\npub const SYS_clone: ::c_long = 56;\npub const SYS_fork: ::c_long = 57;\npub const SYS_vfork: ::c_long = 58;\npub const SYS_execve: ::c_long = 59;\npub const SYS_exit: ::c_long = 60;\npub const SYS_wait4: ::c_long = 61;\npub const SYS_kill: ::c_long = 62;\npub const SYS_uname: ::c_long = 63;\npub const SYS_semget: ::c_long = 64;\npub const SYS_semop: ::c_long = 65;\npub const SYS_semctl: ::c_long = 66;\npub const SYS_shmdt: ::c_long = 67;\npub const SYS_msgget: ::c_long = 68;\npub const SYS_msgsnd: ::c_long = 69;\npub const SYS_msgrcv: ::c_long = 70;\npub const SYS_msgctl: ::c_long = 71;\npub const SYS_fcntl: ::c_long = 72;\npub const SYS_flock: ::c_long = 73;\npub const SYS_fsync: ::c_long = 74;\npub const SYS_fdatasync: ::c_long = 75;\npub const SYS_truncate: ::c_long = 76;\npub const SYS_ftruncate: ::c_long = 77;\npub const SYS_getdents: ::c_long = 78;\npub const SYS_getcwd: ::c_long = 79;\npub const SYS_chdir: ::c_long = 80;\npub const SYS_fchdir: ::c_long = 81;\npub const SYS_rename: ::c_long = 82;\npub const SYS_mkdir: ::c_long = 83;\npub const SYS_rmdir: ::c_long = 84;\npub const SYS_creat: ::c_long = 85;\npub const SYS_link: ::c_long = 86;\npub const SYS_unlink: ::c_long = 87;\npub const SYS_symlink: ::c_long = 88;\npub const SYS_readlink: ::c_long = 89;\npub const SYS_chmod: ::c_long = 90;\npub const SYS_fchmod: ::c_long = 91;\npub const SYS_chown: ::c_long = 92;\npub const SYS_fchown: ::c_long = 93;\npub const SYS_lchown: ::c_long = 94;\npub const SYS_umask: ::c_long = 95;\npub const SYS_gettimeofday: ::c_long = 96;\npub const SYS_getrlimit: ::c_long = 97;\npub const SYS_getrusage: ::c_long = 98;\npub const SYS_sysinfo: ::c_long = 99;\npub const SYS_times: ::c_long = 100;\npub const SYS_ptrace: ::c_long = 101;\npub const SYS_getuid: ::c_long = 102;\npub const SYS_syslog: ::c_long = 103;\npub const SYS_getgid: ::c_long = 104;\npub const SYS_setuid: ::c_long = 105;\npub const SYS_setgid: ::c_long = 106;\npub const SYS_geteuid: ::c_long = 107;\npub const SYS_getegid: ::c_long = 108;\npub const SYS_setpgid: ::c_long = 109;\npub const SYS_getppid: ::c_long = 110;\npub const SYS_getpgrp: ::c_long = 111;\npub const SYS_setsid: ::c_long = 112;\npub const SYS_setreuid: ::c_long = 113;\npub const SYS_setregid: ::c_long = 114;\npub const SYS_getgroups: ::c_long = 115;\npub const SYS_setgroups: ::c_long = 116;\npub const SYS_setresuid: ::c_long = 117;\npub const SYS_getresuid: ::c_long = 118;\npub const SYS_setresgid: ::c_long = 119;\npub const SYS_getresgid: ::c_long = 120;\npub const SYS_getpgid: ::c_long = 121;\npub const SYS_setfsuid: ::c_long = 122;\npub const SYS_setfsgid: ::c_long = 123;\npub const SYS_getsid: ::c_long = 124;\npub const SYS_capget: ::c_long = 125;\npub const SYS_capset: ::c_long = 126;\npub const SYS_rt_sigpending: ::c_long = 127;\npub const SYS_rt_sigtimedwait: ::c_long = 128;\npub const SYS_rt_sigqueueinfo: ::c_long = 129;\npub const SYS_rt_sigsuspend: ::c_long = 130;\npub const SYS_sigaltstack: ::c_long = 131;\npub const SYS_utime: ::c_long = 132;\npub const SYS_mknod: ::c_long = 133;\npub const SYS_uselib: ::c_long = 134;\npub const SYS_personality: ::c_long = 135;\npub const SYS_ustat: ::c_long = 136;\npub const SYS_statfs: ::c_long = 137;\npub const SYS_fstatfs: ::c_long = 138;\npub const SYS_sysfs: ::c_long = 139;\npub const SYS_getpriority: ::c_long = 140;\npub const SYS_setpriority: ::c_long = 141;\npub const SYS_sched_setparam: ::c_long = 142;\npub const SYS_sched_getparam: ::c_long = 143;\npub const SYS_sched_setscheduler: ::c_long = 144;\npub const SYS_sched_getscheduler: ::c_long = 145;\npub const SYS_sched_get_priority_max: ::c_long = 146;\npub const SYS_sched_get_priority_min: ::c_long = 147;\npub const SYS_sched_rr_get_interval: ::c_long = 148;\npub const SYS_mlock: ::c_long = 149;\npub const SYS_munlock: ::c_long = 150;\npub const SYS_mlockall: ::c_long = 151;\npub const SYS_munlockall: ::c_long = 152;\npub const SYS_vhangup: ::c_long = 153;\npub const SYS_modify_ldt: ::c_long = 154;\npub const SYS_pivot_root: ::c_long = 155;\npub const SYS__sysctl: ::c_long = 156;\npub const SYS_prctl: ::c_long = 157;\npub const SYS_arch_prctl: ::c_long = 158;\npub const SYS_adjtimex: ::c_long = 159;\npub const SYS_setrlimit: ::c_long = 160;\npub const SYS_chroot: ::c_long = 161;\npub const SYS_sync: ::c_long = 162;\npub const SYS_acct: ::c_long = 163;\npub const SYS_settimeofday: ::c_long = 164;\npub const SYS_mount: ::c_long = 165;\npub const SYS_umount2: ::c_long = 166;\npub const SYS_swapon: ::c_long = 167;\npub const SYS_swapoff: ::c_long = 168;\npub const SYS_reboot: ::c_long = 169;\npub const SYS_sethostname: ::c_long = 170;\npub const SYS_setdomainname: ::c_long = 171;\npub const SYS_iopl: ::c_long = 172;\npub const SYS_ioperm: ::c_long = 173;\npub const SYS_create_module: ::c_long = 174;\npub const SYS_init_module: ::c_long = 175;\npub const SYS_delete_module: ::c_long = 176;\npub const SYS_get_kernel_syms: ::c_long = 177;\npub const SYS_query_module: ::c_long = 178;\npub const SYS_quotactl: ::c_long = 179;\npub const SYS_nfsservctl: ::c_long = 180;\npub const SYS_getpmsg: ::c_long = 181;\npub const SYS_putpmsg: ::c_long = 182;\npub const SYS_afs_syscall: ::c_long = 183;\npub const SYS_tuxcall: ::c_long = 184;\npub const SYS_security: ::c_long = 185;\npub const SYS_gettid: ::c_long = 186;\npub const SYS_readahead: ::c_long = 187;\npub const SYS_setxattr: ::c_long = 188;\npub const SYS_lsetxattr: ::c_long = 189;\npub const SYS_fsetxattr: ::c_long = 190;\npub const SYS_getxattr: ::c_long = 191;\npub const SYS_lgetxattr: ::c_long = 192;\npub const SYS_fgetxattr: ::c_long = 193;\npub const SYS_listxattr: ::c_long = 194;\npub const SYS_llistxattr: ::c_long = 195;\npub const SYS_flistxattr: ::c_long = 196;\npub const SYS_removexattr: ::c_long = 197;\npub const SYS_lremovexattr: ::c_long = 198;\npub const SYS_fremovexattr: ::c_long = 199;\npub const SYS_tkill: ::c_long = 200;\npub const SYS_time: ::c_long = 201;\npub const SYS_futex: ::c_long = 202;\npub const SYS_sched_setaffinity: ::c_long = 203;\npub const SYS_sched_getaffinity: ::c_long = 204;\npub const SYS_set_thread_area: ::c_long = 205;\npub const SYS_io_setup: ::c_long = 206;\npub const SYS_io_destroy: ::c_long = 207;\npub const SYS_io_getevents: ::c_long = 208;\npub const SYS_io_submit: ::c_long = 209;\npub const SYS_io_cancel: ::c_long = 210;\npub const SYS_get_thread_area: ::c_long = 211;\npub const SYS_lookup_dcookie: ::c_long = 212;\npub const SYS_epoll_create: ::c_long = 213;\npub const SYS_epoll_ctl_old: ::c_long = 214;\npub const SYS_epoll_wait_old: ::c_long = 215;\npub const SYS_remap_file_pages: ::c_long = 216;\npub const SYS_getdents64: ::c_long = 217;\npub const SYS_set_tid_address: ::c_long = 218;\npub const SYS_restart_syscall: ::c_long = 219;\npub const SYS_semtimedop: ::c_long = 220;\npub const SYS_fadvise64: ::c_long = 221;\npub const SYS_timer_create: ::c_long = 222;\npub const SYS_timer_settime: ::c_long = 223;\npub const SYS_timer_gettime: ::c_long = 224;\npub const SYS_timer_getoverrun: ::c_long = 225;\npub const SYS_timer_delete: ::c_long = 226;\npub const SYS_clock_settime: ::c_long = 227;\npub const SYS_clock_gettime: ::c_long = 228;\npub const SYS_clock_getres: ::c_long = 229;\npub const SYS_clock_nanosleep: ::c_long = 230;\npub const SYS_exit_group: ::c_long = 231;\npub const SYS_epoll_wait: ::c_long = 232;\npub const SYS_epoll_ctl: ::c_long = 233;\npub const SYS_tgkill: ::c_long = 234;\npub const SYS_utimes: ::c_long = 235;\npub const SYS_vserver: ::c_long = 236;\npub const SYS_mbind: ::c_long = 237;\npub const SYS_set_mempolicy: ::c_long = 238;\npub const SYS_get_mempolicy: ::c_long = 239;\npub const SYS_mq_open: ::c_long = 240;\npub const SYS_mq_unlink: ::c_long = 241;\npub const SYS_mq_timedsend: ::c_long = 242;\npub const SYS_mq_timedreceive: ::c_long = 243;\npub const SYS_mq_notify: ::c_long = 244;\npub const SYS_mq_getsetattr: ::c_long = 245;\npub const SYS_kexec_load: ::c_long = 246;\npub const SYS_waitid: ::c_long = 247;\npub const SYS_add_key: ::c_long = 248;\npub const SYS_request_key: ::c_long = 249;\npub const SYS_keyctl: ::c_long = 250;\npub const SYS_ioprio_set: ::c_long = 251;\npub const SYS_ioprio_get: ::c_long = 252;\npub const SYS_inotify_init: ::c_long = 253;\npub const SYS_inotify_add_watch: ::c_long = 254;\npub const SYS_inotify_rm_watch: ::c_long = 255;\npub const SYS_migrate_pages: ::c_long = 256;\npub const SYS_openat: ::c_long = 257;\npub const SYS_mkdirat: ::c_long = 258;\npub const SYS_mknodat: ::c_long = 259;\npub const SYS_fchownat: ::c_long = 260;\npub const SYS_futimesat: ::c_long = 261;\npub const SYS_newfstatat: ::c_long = 262;\npub const SYS_unlinkat: ::c_long = 263;\npub const SYS_renameat: ::c_long = 264;\npub const SYS_linkat: ::c_long = 265;\npub const SYS_symlinkat: ::c_long = 266;\npub const SYS_readlinkat: ::c_long = 267;\npub const SYS_fchmodat: ::c_long = 268;\npub const SYS_faccessat: ::c_long = 269;\npub const SYS_pselect6: ::c_long = 270;\npub const SYS_ppoll: ::c_long = 271;\npub const SYS_unshare: ::c_long = 272;\npub const SYS_set_robust_list: ::c_long = 273;\npub const SYS_get_robust_list: ::c_long = 274;\npub const SYS_splice: ::c_long = 275;\npub const SYS_tee: ::c_long = 276;\npub const SYS_sync_file_range: ::c_long = 277;\npub const SYS_vmsplice: ::c_long = 278;\npub const SYS_move_pages: ::c_long = 279;\npub const SYS_utimensat: ::c_long = 280;\npub const SYS_epoll_pwait: ::c_long = 281;\npub const SYS_signalfd: ::c_long = 282;\npub const SYS_timerfd_create: ::c_long = 283;\npub const SYS_eventfd: ::c_long = 284;\npub const SYS_fallocate: ::c_long = 285;\npub const SYS_timerfd_settime: ::c_long = 286;\npub const SYS_timerfd_gettime: ::c_long = 287;\npub const SYS_accept4: ::c_long = 288;\npub const SYS_signalfd4: ::c_long = 289;\npub const SYS_eventfd2: ::c_long = 290;\npub const SYS_epoll_create1: ::c_long = 291;\npub const SYS_dup3: ::c_long = 292;\npub const SYS_pipe2: ::c_long = 293;\npub const SYS_inotify_init1: ::c_long = 294;\npub const SYS_preadv: ::c_long = 295;\npub const SYS_pwritev: ::c_long = 296;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 297;\npub const SYS_perf_event_open: ::c_long = 298;\npub const SYS_recvmmsg: ::c_long = 299;\npub const SYS_fanotify_init: ::c_long = 300;\npub const SYS_fanotify_mark: ::c_long = 301;\npub const SYS_prlimit64: ::c_long = 302;\npub const SYS_name_to_handle_at: ::c_long = 303;\npub const SYS_open_by_handle_at: ::c_long = 304;\npub const SYS_clock_adjtime: ::c_long = 305;\npub const SYS_syncfs: ::c_long = 306;\npub const SYS_sendmmsg: ::c_long = 307;\npub const SYS_setns: ::c_long = 308;\npub const SYS_getcpu: ::c_long = 309;\npub const SYS_process_vm_readv: ::c_long = 310;\npub const SYS_process_vm_writev: ::c_long = 311;\npub const SYS_kcmp: ::c_long = 312;\npub const SYS_finit_module: ::c_long = 313;\npub const SYS_sched_setattr: ::c_long = 314;\npub const SYS_sched_getattr: ::c_long = 315;\npub const SYS_renameat2: ::c_long = 316;\npub const SYS_seccomp: ::c_long = 317;\npub const SYS_getrandom: ::c_long = 318;\npub const SYS_memfd_create: ::c_long = 319;\npub const SYS_kexec_file_load: ::c_long = 320;\npub const SYS_bpf: ::c_long = 321;\npub const SYS_execveat: ::c_long = 322;\npub const SYS_userfaultfd: ::c_long = 323;\npub const SYS_membarrier: ::c_long = 324;\npub const SYS_mlock2: ::c_long = 325;\npub const SYS_copy_file_range: ::c_long = 326;\npub const SYS_preadv2: ::c_long = 327;\npub const SYS_pwritev2: ::c_long = 328;\npub const SYS_pkey_mprotect: ::c_long = 329;\npub const SYS_pkey_alloc: ::c_long = 330;\npub const SYS_pkey_free: ::c_long = 331;\npub const SYS_statx: ::c_long = 332;\npub const SYS_pidfd_send_signal: ::c_long = 424;\npub const SYS_io_uring_setup: ::c_long = 425;\npub const SYS_io_uring_enter: ::c_long = 426;\npub const SYS_io_uring_register: ::c_long = 427;\npub const SYS_open_tree: ::c_long = 428;\npub const SYS_move_mount: ::c_long = 429;\npub const SYS_fsopen: ::c_long = 430;\npub const SYS_fsconfig: ::c_long = 431;\npub const SYS_fsmount: ::c_long = 432;\npub const SYS_fspick: ::c_long = 433;\npub const SYS_pidfd_open: ::c_long = 434;\npub const SYS_clone3: ::c_long = 435;\npub const SYS_close_range: ::c_long = 436;\npub const SYS_openat2: ::c_long = 437;\npub const SYS_pidfd_getfd: ::c_long = 438;\npub const SYS_faccessat2: ::c_long = 439;\npub const SYS_process_madvise: ::c_long = 440;\npub const SYS_epoll_pwait2: ::c_long = 441;\npub const SYS_mount_setattr: ::c_long = 442;\n\nextern \"C\" {\n    pub fn sysctl(\n        name: *mut ::c_int,\n        namelen: ::c_int,\n        oldp: *mut ::c_void,\n        oldlenp: *mut ::size_t,\n        newp: *mut ::c_void,\n        newlen: ::size_t,\n    ) -> ::c_int;\n}\n"],["1172","s_no_extra_traits! {\n    #[allow(missing_debug_implementations)]\n    #[repr(align(16))]\n    pub struct max_align_t {\n        priv_: [f64; 4]\n    }\n}\n"],["1173","//! x86_64-specific definitions for 64-bit linux-like values\n\npub type c_char = i8;\npub type wchar_t = i32;\npub type nlink_t = u64;\npub type blksize_t = i64;\npub type greg_t = i64;\npub type suseconds_t = i64;\npub type __u64 = ::c_ulonglong;\n\ns! {\n    pub struct sigaction {\n        pub sa_sigaction: ::sighandler_t,\n        pub sa_mask: ::sigset_t,\n        #[cfg(target_arch = \"sparc64\")]\n        __reserved0: ::c_int,\n        pub sa_flags: ::c_int,\n        pub sa_restorer: ::Option<extern fn()>,\n    }\n\n    pub struct statfs {\n        pub f_type: ::__fsword_t,\n        pub f_bsize: ::__fsword_t,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n\n        pub f_namelen: ::__fsword_t,\n        pub f_frsize: ::__fsword_t,\n        f_spare: [::__fsword_t; 5],\n    }\n\n    pub struct flock {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off_t,\n        pub l_len: ::off_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct flock64 {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off64_t,\n        pub l_len: ::off64_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_errno: ::c_int,\n        pub si_code: ::c_int,\n        #[doc(hidden)]\n        #[deprecated(\n            since=\"0.2.54\",\n            note=\"Please leave a comment on \\\n                  https://github.com/rust-lang/libc/pull/1316 if you're using \\\n                  this field\"\n        )]\n        pub _pad: [::c_int; 29],\n        _align: [u64; 0],\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_flags: ::c_int,\n        pub ss_size: ::size_t\n    }\n\n    pub struct stat {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino_t,\n        pub st_nlink: ::nlink_t,\n        pub st_mode: ::mode_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        __pad0: ::c_int,\n        pub st_rdev: ::dev_t,\n        pub st_size: ::off_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: i64,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: i64,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: i64,\n        __unused: [i64; 3],\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino64_t,\n        pub st_nlink: ::nlink_t,\n        pub st_mode: ::mode_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        __pad0: ::c_int,\n        pub st_rdev: ::dev_t,\n        pub st_size: ::off_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt64_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: i64,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: i64,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: i64,\n        __reserved: [i64; 3],\n    }\n\n    pub struct statfs64 {\n        pub f_type: ::__fsword_t,\n        pub f_bsize: ::__fsword_t,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::__fsword_t,\n        pub f_frsize: ::__fsword_t,\n        pub f_flags: ::__fsword_t,\n        pub f_spare: [::__fsword_t; 4],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_favail: u64,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct pthread_attr_t {\n        #[cfg(target_pointer_width = \"32\")]\n        __size: [u32; 8],\n        #[cfg(target_pointer_width = \"64\")]\n        __size: [u64; 7]\n    }\n\n    pub struct _libc_fpxreg {\n        pub significand: [u16; 4],\n        pub exponent: u16,\n        __private: [u16; 3],\n    }\n\n    pub struct _libc_xmmreg {\n        pub element: [u32; 4],\n    }\n\n    pub struct _libc_fpstate {\n        pub cwd: u16,\n        pub swd: u16,\n        pub ftw: u16,\n        pub fop: u16,\n        pub rip: u64,\n        pub rdp: u64,\n        pub mxcsr: u32,\n        pub mxcr_mask: u32,\n        pub _st: [_libc_fpxreg; 8],\n        pub _xmm: [_libc_xmmreg; 16],\n        __private: [u64; 12],\n    }\n\n    pub struct user_regs_struct {\n        pub r15: ::c_ulonglong,\n        pub r14: ::c_ulonglong,\n        pub r13: ::c_ulonglong,\n        pub r12: ::c_ulonglong,\n        pub rbp: ::c_ulonglong,\n        pub rbx: ::c_ulonglong,\n        pub r11: ::c_ulonglong,\n        pub r10: ::c_ulonglong,\n        pub r9: ::c_ulonglong,\n        pub r8: ::c_ulonglong,\n        pub rax: ::c_ulonglong,\n        pub rcx: ::c_ulonglong,\n        pub rdx: ::c_ulonglong,\n        pub rsi: ::c_ulonglong,\n        pub rdi: ::c_ulonglong,\n        pub orig_rax: ::c_ulonglong,\n        pub rip: ::c_ulonglong,\n        pub cs: ::c_ulonglong,\n        pub eflags: ::c_ulonglong,\n        pub rsp: ::c_ulonglong,\n        pub ss: ::c_ulonglong,\n        pub fs_base: ::c_ulonglong,\n        pub gs_base: ::c_ulonglong,\n        pub ds: ::c_ulonglong,\n        pub es: ::c_ulonglong,\n        pub fs: ::c_ulonglong,\n        pub gs: ::c_ulonglong,\n    }\n\n    pub struct user {\n        pub regs: user_regs_struct,\n        pub u_fpvalid: ::c_int,\n        pub i387: user_fpregs_struct,\n        pub u_tsize: ::c_ulonglong,\n        pub u_dsize: ::c_ulonglong,\n        pub u_ssize: ::c_ulonglong,\n        pub start_code: ::c_ulonglong,\n        pub start_stack: ::c_ulonglong,\n        pub signal: ::c_longlong,\n        __reserved: ::c_int,\n        #[cfg(target_pointer_width = \"32\")]\n        __pad1: u32,\n        pub u_ar0: *mut user_regs_struct,\n        #[cfg(target_pointer_width = \"32\")]\n        __pad2: u32,\n        pub u_fpstate: *mut user_fpregs_struct,\n        pub magic: ::c_ulonglong,\n        pub u_comm: [::c_char; 32],\n        pub u_debugreg: [::c_ulonglong; 8],\n    }\n\n    pub struct mcontext_t {\n        pub gregs: [greg_t; 23],\n        pub fpregs: *mut _libc_fpstate,\n        __private: [u64; 8],\n    }\n\n    pub struct ipc_perm {\n        pub __key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::c_ushort,\n        __pad1: ::c_ushort,\n        pub __seq: ::c_ushort,\n        __pad2: ::c_ushort,\n        __unused1: u64,\n        __unused2: u64\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        pub shm_segsz: ::size_t,\n        pub shm_atime: ::time_t,\n        pub shm_dtime: ::time_t,\n        pub shm_ctime: ::time_t,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::shmatt_t,\n        __unused4: u64,\n        __unused5: u64\n    }\n\n    pub struct termios2 {\n        pub c_iflag: ::tcflag_t,\n        pub c_oflag: ::tcflag_t,\n        pub c_cflag: ::tcflag_t,\n        pub c_lflag: ::tcflag_t,\n        pub c_line: ::cc_t,\n        pub c_cc: [::cc_t; 19],\n        pub c_ispeed: ::speed_t,\n        pub c_ospeed: ::speed_t,\n    }\n\n    pub struct ip_mreqn {\n        pub imr_multiaddr: ::in_addr,\n        pub imr_address: ::in_addr,\n        pub imr_ifindex: ::c_int,\n    }\n}\n\ns_no_extra_traits! {\n    pub struct user_fpregs_struct {\n        pub cwd: ::c_ushort,\n        pub swd: ::c_ushort,\n        pub ftw: ::c_ushort,\n        pub fop: ::c_ushort,\n        pub rip: ::c_ulonglong,\n        pub rdp: ::c_ulonglong,\n        pub mxcsr: ::c_uint,\n        pub mxcr_mask: ::c_uint,\n        pub st_space: [::c_uint; 32],\n        pub xmm_space: [::c_uint; 64],\n        padding: [::c_uint; 24],\n    }\n\n    pub struct ucontext_t {\n        pub uc_flags: ::c_ulong,\n        pub uc_link: *mut ucontext_t,\n        pub uc_stack: ::stack_t,\n        pub uc_mcontext: mcontext_t,\n        pub uc_sigmask: ::sigset_t,\n        __private: [u8; 512],\n        // FIXME: the shadow stack field requires glibc >= 2.28.\n        // Re-add once we drop compatibility with glibc versions older than\n        // 2.28.\n        //\n        // __ssp: [::c_ulonglong; 4],\n    }\n}\n\ncfg_if! {\n    if #[cfg(feature = \"extra_traits\")] {\n        impl PartialEq for user_fpregs_struct {\n            fn eq(&self, other: &user_fpregs_struct) -> bool {\n                self.cwd == other.cwd\n                    && self.swd == other.swd\n                    && self.ftw == other.ftw\n                    && self.fop == other.fop\n                    && self.rip == other.rip\n                    && self.rdp == other.rdp\n                    && self.mxcsr == other.mxcsr\n                    && self.mxcr_mask == other.mxcr_mask\n                    && self.st_space == other.st_space\n                    && self\n                    .xmm_space\n                    .iter()\n                    .zip(other.xmm_space.iter())\n                    .all(|(a,b)| a == b)\n                // Ignore padding field\n            }\n        }\n\n        impl Eq for user_fpregs_struct {}\n\n        impl ::fmt::Debug for user_fpregs_struct {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"user_fpregs_struct\")\n                    .field(\"cwd\", &self.cwd)\n                    .field(\"ftw\", &self.ftw)\n                    .field(\"fop\", &self.fop)\n                    .field(\"rip\", &self.rip)\n                    .field(\"rdp\", &self.rdp)\n                    .field(\"mxcsr\", &self.mxcsr)\n                    .field(\"mxcr_mask\", &self.mxcr_mask)\n                    .field(\"st_space\", &self.st_space)\n                // FIXME: .field(\"xmm_space\", &self.xmm_space)\n                // Ignore padding field\n                    .finish()\n            }\n        }\n\n        impl ::hash::Hash for user_fpregs_struct {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.cwd.hash(state);\n                self.ftw.hash(state);\n                self.fop.hash(state);\n                self.rip.hash(state);\n                self.rdp.hash(state);\n                self.mxcsr.hash(state);\n                self.mxcr_mask.hash(state);\n                self.st_space.hash(state);\n                self.xmm_space.hash(state);\n                // Ignore padding field\n            }\n        }\n\n        impl PartialEq for ucontext_t {\n            fn eq(&self, other: &ucontext_t) -> bool {\n                self.uc_flags == other.uc_flags\n                    && self.uc_link == other.uc_link\n                    && self.uc_stack == other.uc_stack\n                    && self.uc_mcontext == other.uc_mcontext\n                    && self.uc_sigmask == other.uc_sigmask\n                // Ignore __private field\n            }\n        }\n\n        impl Eq for ucontext_t {}\n\n        impl ::fmt::Debug for ucontext_t {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"ucontext_t\")\n                    .field(\"uc_flags\", &self.uc_flags)\n                    .field(\"uc_link\", &self.uc_link)\n                    .field(\"uc_stack\", &self.uc_stack)\n                    .field(\"uc_mcontext\", &self.uc_mcontext)\n                    .field(\"uc_sigmask\", &self.uc_sigmask)\n                // Ignore __private field\n                    .finish()\n            }\n        }\n\n        impl ::hash::Hash for ucontext_t {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.uc_flags.hash(state);\n                self.uc_link.hash(state);\n                self.uc_stack.hash(state);\n                self.uc_mcontext.hash(state);\n                self.uc_sigmask.hash(state);\n                // Ignore __private field\n            }\n        }\n    }\n}\n\npub const POSIX_FADV_DONTNEED: ::c_int = 4;\npub const POSIX_FADV_NOREUSE: ::c_int = 5;\n\npub const VEOF: usize = 4;\npub const RTLD_DEEPBIND: ::c_int = 0x8;\npub const RTLD_GLOBAL: ::c_int = 0x100;\npub const RTLD_NOLOAD: ::c_int = 0x4;\npub const TIOCGSOFTCAR: ::c_ulong = 0x5419;\npub const TIOCSSOFTCAR: ::c_ulong = 0x541A;\npub const TIOCGRS485: ::c_int = 0x542E;\npub const TIOCSRS485: ::c_int = 0x542F;\n\npub const RLIMIT_RSS: ::__rlimit_resource_t = 5;\npub const RLIMIT_AS: ::__rlimit_resource_t = 9;\npub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 8;\npub const RLIMIT_NOFILE: ::__rlimit_resource_t = 7;\npub const RLIMIT_NPROC: ::__rlimit_resource_t = 6;\n\npub const O_APPEND: ::c_int = 1024;\npub const O_CREAT: ::c_int = 64;\npub const O_EXCL: ::c_int = 128;\npub const O_NOCTTY: ::c_int = 256;\npub const O_NONBLOCK: ::c_int = 2048;\npub const O_SYNC: ::c_int = 1052672;\npub const O_RSYNC: ::c_int = 1052672;\npub const O_DSYNC: ::c_int = 4096;\npub const O_FSYNC: ::c_int = 0x101000;\npub const O_NOATIME: ::c_int = 0o1000000;\npub const O_PATH: ::c_int = 0o10000000;\npub const O_TMPFILE: ::c_int = 0o20000000 | O_DIRECTORY;\n\npub const MADV_SOFT_OFFLINE: ::c_int = 101;\npub const MAP_GROWSDOWN: ::c_int = 0x0100;\n\npub const EDEADLK: ::c_int = 35;\npub const ENAMETOOLONG: ::c_int = 36;\npub const ENOLCK: ::c_int = 37;\npub const ENOSYS: ::c_int = 38;\npub const ENOTEMPTY: ::c_int = 39;\npub const ELOOP: ::c_int = 40;\npub const ENOMSG: ::c_int = 42;\npub const EIDRM: ::c_int = 43;\npub const ECHRNG: ::c_int = 44;\npub const EL2NSYNC: ::c_int = 45;\npub const EL3HLT: ::c_int = 46;\npub const EL3RST: ::c_int = 47;\npub const ELNRNG: ::c_int = 48;\npub const EUNATCH: ::c_int = 49;\npub const ENOCSI: ::c_int = 50;\npub const EL2HLT: ::c_int = 51;\npub const EBADE: ::c_int = 52;\npub const EBADR: ::c_int = 53;\npub const EXFULL: ::c_int = 54;\npub const ENOANO: ::c_int = 55;\npub const EBADRQC: ::c_int = 56;\npub const EBADSLT: ::c_int = 57;\npub const EMULTIHOP: ::c_int = 72;\npub const EOVERFLOW: ::c_int = 75;\npub const ENOTUNIQ: ::c_int = 76;\npub const EBADFD: ::c_int = 77;\npub const EBADMSG: ::c_int = 74;\npub const EREMCHG: ::c_int = 78;\npub const ELIBACC: ::c_int = 79;\npub const ELIBBAD: ::c_int = 80;\npub const ELIBSCN: ::c_int = 81;\npub const ELIBMAX: ::c_int = 82;\npub const ELIBEXEC: ::c_int = 83;\npub const EILSEQ: ::c_int = 84;\npub const ERESTART: ::c_int = 85;\npub const ESTRPIPE: ::c_int = 86;\npub const EUSERS: ::c_int = 87;\npub const ENOTSOCK: ::c_int = 88;\npub const EDESTADDRREQ: ::c_int = 89;\npub const EMSGSIZE: ::c_int = 90;\npub const EPROTOTYPE: ::c_int = 91;\npub const ENOPROTOOPT: ::c_int = 92;\npub const EPROTONOSUPPORT: ::c_int = 93;\npub const ESOCKTNOSUPPORT: ::c_int = 94;\npub const EOPNOTSUPP: ::c_int = 95;\npub const EPFNOSUPPORT: ::c_int = 96;\npub const EAFNOSUPPORT: ::c_int = 97;\npub const EADDRINUSE: ::c_int = 98;\npub const EADDRNOTAVAIL: ::c_int = 99;\npub const ENETDOWN: ::c_int = 100;\npub const ENETUNREACH: ::c_int = 101;\npub const ENETRESET: ::c_int = 102;\npub const ECONNABORTED: ::c_int = 103;\npub const ECONNRESET: ::c_int = 104;\npub const ENOBUFS: ::c_int = 105;\npub const EISCONN: ::c_int = 106;\npub const ENOTCONN: ::c_int = 107;\npub const ESHUTDOWN: ::c_int = 108;\npub const ETOOMANYREFS: ::c_int = 109;\npub const ETIMEDOUT: ::c_int = 110;\npub const ECONNREFUSED: ::c_int = 111;\npub const EHOSTDOWN: ::c_int = 112;\npub const EHOSTUNREACH: ::c_int = 113;\npub const EALREADY: ::c_int = 114;\npub const EINPROGRESS: ::c_int = 115;\npub const ESTALE: ::c_int = 116;\npub const EDQUOT: ::c_int = 122;\npub const ENOMEDIUM: ::c_int = 123;\npub const EMEDIUMTYPE: ::c_int = 124;\npub const ECANCELED: ::c_int = 125;\npub const ENOKEY: ::c_int = 126;\npub const EKEYEXPIRED: ::c_int = 127;\npub const EKEYREVOKED: ::c_int = 128;\npub const EKEYREJECTED: ::c_int = 129;\npub const EOWNERDEAD: ::c_int = 130;\npub const ENOTRECOVERABLE: ::c_int = 131;\npub const EHWPOISON: ::c_int = 133;\npub const ERFKILL: ::c_int = 132;\n\npub const SOCK_STREAM: ::c_int = 1;\npub const SOCK_DGRAM: ::c_int = 2;\n\npub const SA_ONSTACK: ::c_int = 0x08000000;\npub const SA_SIGINFO: ::c_int = 0x00000004;\npub const SA_NOCLDWAIT: ::c_int = 0x00000002;\n\npub const SIGTTIN: ::c_int = 21;\npub const SIGTTOU: ::c_int = 22;\npub const SIGXCPU: ::c_int = 24;\npub const SIGXFSZ: ::c_int = 25;\npub const SIGVTALRM: ::c_int = 26;\npub const SIGPROF: ::c_int = 27;\npub const SIGWINCH: ::c_int = 28;\npub const SIGCHLD: ::c_int = 17;\npub const SIGBUS: ::c_int = 7;\npub const SIGUSR1: ::c_int = 10;\npub const SIGUSR2: ::c_int = 12;\npub const SIGCONT: ::c_int = 18;\npub const SIGSTOP: ::c_int = 19;\npub const SIGTSTP: ::c_int = 20;\npub const SIGURG: ::c_int = 23;\npub const SIGIO: ::c_int = 29;\npub const SIGSYS: ::c_int = 31;\npub const SIGSTKFLT: ::c_int = 16;\n#[deprecated(since = \"0.2.55\", note = \"Use SIGSYS instead\")]\npub const SIGUNUSED: ::c_int = 31;\npub const SIGPOLL: ::c_int = 29;\npub const SIGPWR: ::c_int = 30;\npub const SIG_SETMASK: ::c_int = 2;\npub const SIG_BLOCK: ::c_int = 0x000000;\npub const SIG_UNBLOCK: ::c_int = 0x01;\n\npub const POLLWRNORM: ::c_short = 0x100;\npub const POLLWRBAND: ::c_short = 0x200;\n\npub const O_ASYNC: ::c_int = 0x2000;\npub const O_NDELAY: ::c_int = 0x800;\n\npub const PTRACE_DETACH: ::c_uint = 17;\n\npub const EFD_NONBLOCK: ::c_int = 0x800;\n\npub const F_GETLK: ::c_int = 5;\npub const F_GETOWN: ::c_int = 9;\npub const F_SETOWN: ::c_int = 8;\npub const F_SETLK: ::c_int = 6;\npub const F_SETLKW: ::c_int = 7;\npub const F_OFD_GETLK: ::c_int = 36;\npub const F_OFD_SETLK: ::c_int = 37;\npub const F_OFD_SETLKW: ::c_int = 38;\n\npub const F_RDLCK: ::c_int = 0;\npub const F_WRLCK: ::c_int = 1;\npub const F_UNLCK: ::c_int = 2;\n\npub const SFD_NONBLOCK: ::c_int = 0x0800;\n\npub const TCSANOW: ::c_int = 0;\npub const TCSADRAIN: ::c_int = 1;\npub const TCSAFLUSH: ::c_int = 2;\n\npub const TIOCLINUX: ::c_ulong = 0x541C;\npub const TIOCGSERIAL: ::c_ulong = 0x541E;\npub const TIOCEXCL: ::c_ulong = 0x540C;\npub const TIOCNXCL: ::c_ulong = 0x540D;\npub const TIOCSCTTY: ::c_ulong = 0x540E;\npub const TIOCSTI: ::c_ulong = 0x5412;\npub const TIOCMGET: ::c_ulong = 0x5415;\npub const TIOCMBIS: ::c_ulong = 0x5416;\npub const TIOCMBIC: ::c_ulong = 0x5417;\npub const TIOCMSET: ::c_ulong = 0x5418;\npub const TIOCCONS: ::c_ulong = 0x541D;\n\npub const TIOCM_ST: ::c_int = 0x008;\npub const TIOCM_SR: ::c_int = 0x010;\npub const TIOCM_CTS: ::c_int = 0x020;\npub const TIOCM_CAR: ::c_int = 0x040;\npub const TIOCM_RNG: ::c_int = 0x080;\npub const TIOCM_DSR: ::c_int = 0x100;\n\npub const SFD_CLOEXEC: ::c_int = 0x080000;\n\npub const NCCS: usize = 32;\n\npub const O_TRUNC: ::c_int = 512;\n\npub const O_CLOEXEC: ::c_int = 0x80000;\n\npub const EBFONT: ::c_int = 59;\npub const ENOSTR: ::c_int = 60;\npub const ENODATA: ::c_int = 61;\npub const ETIME: ::c_int = 62;\npub const ENOSR: ::c_int = 63;\npub const ENONET: ::c_int = 64;\npub const ENOPKG: ::c_int = 65;\npub const EREMOTE: ::c_int = 66;\npub const ENOLINK: ::c_int = 67;\npub const EADV: ::c_int = 68;\npub const ESRMNT: ::c_int = 69;\npub const ECOMM: ::c_int = 70;\npub const EPROTO: ::c_int = 71;\npub const EDOTDOT: ::c_int = 73;\n\npub const SA_NODEFER: ::c_int = 0x40000000;\npub const SA_RESETHAND: ::c_int = 0x80000000;\npub const SA_RESTART: ::c_int = 0x10000000;\npub const SA_NOCLDSTOP: ::c_int = 0x00000001;\n\npub const EPOLL_CLOEXEC: ::c_int = 0x80000;\n\npub const EFD_CLOEXEC: ::c_int = 0x80000;\n\npub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;\npub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;\n\npub const O_DIRECT: ::c_int = 0x4000;\npub const O_DIRECTORY: ::c_int = 0x10000;\npub const O_NOFOLLOW: ::c_int = 0x20000;\n\npub const MAP_HUGETLB: ::c_int = 0x040000;\npub const MAP_LOCKED: ::c_int = 0x02000;\npub const MAP_NORESERVE: ::c_int = 0x04000;\npub const MAP_32BIT: ::c_int = 0x0040;\npub const MAP_ANON: ::c_int = 0x0020;\npub const MAP_ANONYMOUS: ::c_int = 0x0020;\npub const MAP_DENYWRITE: ::c_int = 0x0800;\npub const MAP_EXECUTABLE: ::c_int = 0x01000;\npub const MAP_POPULATE: ::c_int = 0x08000;\npub const MAP_NONBLOCK: ::c_int = 0x010000;\npub const MAP_STACK: ::c_int = 0x020000;\npub const MAP_SYNC: ::c_int = 0x080000;\n\npub const EDEADLOCK: ::c_int = 35;\npub const EUCLEAN: ::c_int = 117;\npub const ENOTNAM: ::c_int = 118;\npub const ENAVAIL: ::c_int = 119;\npub const EISNAM: ::c_int = 120;\npub const EREMOTEIO: ::c_int = 121;\n\npub const FIOCLEX: ::c_ulong = 0x5451;\npub const FIONCLEX: ::c_ulong = 0x5450;\npub const FIONBIO: ::c_ulong = 0x5421;\n\npub const PTRACE_GETFPREGS: ::c_uint = 14;\npub const PTRACE_SETFPREGS: ::c_uint = 15;\npub const PTRACE_GETFPXREGS: ::c_uint = 18;\npub const PTRACE_SETFPXREGS: ::c_uint = 19;\npub const PTRACE_GETREGS: ::c_uint = 12;\npub const PTRACE_SETREGS: ::c_uint = 13;\npub const PTRACE_PEEKSIGINFO_SHARED: ::c_uint = 1;\npub const PTRACE_SYSEMU: ::c_uint = 31;\npub const PTRACE_SYSEMU_SINGLESTEP: ::c_uint = 32;\n\npub const MCL_CURRENT: ::c_int = 0x0001;\npub const MCL_FUTURE: ::c_int = 0x0002;\n\npub const SIGSTKSZ: ::size_t = 8192;\npub const MINSIGSTKSZ: ::size_t = 2048;\npub const CBAUD: ::tcflag_t = 0o0010017;\npub const TAB1: ::tcflag_t = 0x00000800;\npub const TAB2: ::tcflag_t = 0x00001000;\npub const TAB3: ::tcflag_t = 0x00001800;\npub const CR1: ::tcflag_t = 0x00000200;\npub const CR2: ::tcflag_t = 0x00000400;\npub const CR3: ::tcflag_t = 0x00000600;\npub const FF1: ::tcflag_t = 0x00008000;\npub const BS1: ::tcflag_t = 0x00002000;\npub const VT1: ::tcflag_t = 0x00004000;\npub const VWERASE: usize = 14;\npub const VREPRINT: usize = 12;\npub const VSUSP: usize = 10;\npub const VSTART: usize = 8;\npub const VSTOP: usize = 9;\npub const VDISCARD: usize = 13;\npub const VTIME: usize = 5;\npub const IXON: ::tcflag_t = 0x00000400;\npub const IXOFF: ::tcflag_t = 0x00001000;\npub const ONLCR: ::tcflag_t = 0x4;\npub const CSIZE: ::tcflag_t = 0x00000030;\npub const CS6: ::tcflag_t = 0x00000010;\npub const CS7: ::tcflag_t = 0x00000020;\npub const CS8: ::tcflag_t = 0x00000030;\npub const CSTOPB: ::tcflag_t = 0x00000040;\npub const CREAD: ::tcflag_t = 0x00000080;\npub const PARENB: ::tcflag_t = 0x00000100;\npub const PARODD: ::tcflag_t = 0x00000200;\npub const HUPCL: ::tcflag_t = 0x00000400;\npub const CLOCAL: ::tcflag_t = 0x00000800;\npub const ECHOKE: ::tcflag_t = 0x00000800;\npub const ECHOE: ::tcflag_t = 0x00000010;\npub const ECHOK: ::tcflag_t = 0x00000020;\npub const ECHONL: ::tcflag_t = 0x00000040;\npub const ECHOPRT: ::tcflag_t = 0x00000400;\npub const ECHOCTL: ::tcflag_t = 0x00000200;\npub const ISIG: ::tcflag_t = 0x00000001;\npub const ICANON: ::tcflag_t = 0x00000002;\npub const PENDIN: ::tcflag_t = 0x00004000;\npub const NOFLSH: ::tcflag_t = 0x00000080;\npub const CIBAUD: ::tcflag_t = 0o02003600000;\npub const CBAUDEX: ::tcflag_t = 0o010000;\npub const VSWTC: usize = 7;\npub const OLCUC: ::tcflag_t = 0o000002;\npub const NLDLY: ::tcflag_t = 0o000400;\npub const CRDLY: ::tcflag_t = 0o003000;\npub const TABDLY: ::tcflag_t = 0o014000;\npub const BSDLY: ::tcflag_t = 0o020000;\npub const FFDLY: ::tcflag_t = 0o100000;\npub const VTDLY: ::tcflag_t = 0o040000;\npub const XTABS: ::tcflag_t = 0o014000;\n\npub const B0: ::speed_t = 0o000000;\npub const B50: ::speed_t = 0o000001;\npub const B75: ::speed_t = 0o000002;\npub const B110: ::speed_t = 0o000003;\npub const B134: ::speed_t = 0o000004;\npub const B150: ::speed_t = 0o000005;\npub const B200: ::speed_t = 0o000006;\npub const B300: ::speed_t = 0o000007;\npub const B600: ::speed_t = 0o000010;\npub const B1200: ::speed_t = 0o000011;\npub const B1800: ::speed_t = 0o000012;\npub const B2400: ::speed_t = 0o000013;\npub const B4800: ::speed_t = 0o000014;\npub const B9600: ::speed_t = 0o000015;\npub const B19200: ::speed_t = 0o000016;\npub const B38400: ::speed_t = 0o000017;\npub const EXTA: ::speed_t = B19200;\npub const EXTB: ::speed_t = B38400;\npub const BOTHER: ::speed_t = 0o010000;\npub const B57600: ::speed_t = 0o010001;\npub const B115200: ::speed_t = 0o010002;\npub const B230400: ::speed_t = 0o010003;\npub const B460800: ::speed_t = 0o010004;\npub const B500000: ::speed_t = 0o010005;\npub const B576000: ::speed_t = 0o010006;\npub const B921600: ::speed_t = 0o010007;\npub const B1000000: ::speed_t = 0o010010;\npub const B1152000: ::speed_t = 0o010011;\npub const B1500000: ::speed_t = 0o010012;\npub const B2000000: ::speed_t = 0o010013;\npub const B2500000: ::speed_t = 0o010014;\npub const B3000000: ::speed_t = 0o010015;\npub const B3500000: ::speed_t = 0o010016;\npub const B4000000: ::speed_t = 0o010017;\n\npub const VEOL: usize = 11;\npub const VEOL2: usize = 16;\npub const VMIN: usize = 6;\npub const IEXTEN: ::tcflag_t = 0x00008000;\npub const TOSTOP: ::tcflag_t = 0x00000100;\npub const FLUSHO: ::tcflag_t = 0x00001000;\npub const EXTPROC: ::tcflag_t = 0x00010000;\npub const TCGETS: ::c_ulong = 0x5401;\npub const TCSETS: ::c_ulong = 0x5402;\npub const TCSETSW: ::c_ulong = 0x5403;\npub const TCSETSF: ::c_ulong = 0x5404;\npub const TCGETA: ::c_ulong = 0x5405;\npub const TCSETA: ::c_ulong = 0x5406;\npub const TCSETAW: ::c_ulong = 0x5407;\npub const TCSETAF: ::c_ulong = 0x5408;\npub const TCSBRK: ::c_ulong = 0x5409;\npub const TCXONC: ::c_ulong = 0x540A;\npub const TCFLSH: ::c_ulong = 0x540B;\npub const TIOCINQ: ::c_ulong = 0x541B;\npub const TIOCGPGRP: ::c_ulong = 0x540F;\npub const TIOCSPGRP: ::c_ulong = 0x5410;\npub const TIOCOUTQ: ::c_ulong = 0x5411;\npub const TIOCGWINSZ: ::c_ulong = 0x5413;\npub const TIOCSWINSZ: ::c_ulong = 0x5414;\npub const FIONREAD: ::c_ulong = 0x541B;\npub const TIOCSBRK: ::c_ulong = 0x5427;\npub const TIOCCBRK: ::c_ulong = 0x5428;\n\n// offsets in user_regs_structs, from sys/reg.h\npub const R15: ::c_int = 0;\npub const R14: ::c_int = 1;\npub const R13: ::c_int = 2;\npub const R12: ::c_int = 3;\npub const RBP: ::c_int = 4;\npub const RBX: ::c_int = 5;\npub const R11: ::c_int = 6;\npub const R10: ::c_int = 7;\npub const R9: ::c_int = 8;\npub const R8: ::c_int = 9;\npub const RAX: ::c_int = 10;\npub const RCX: ::c_int = 11;\npub const RDX: ::c_int = 12;\npub const RSI: ::c_int = 13;\npub const RDI: ::c_int = 14;\npub const ORIG_RAX: ::c_int = 15;\npub const RIP: ::c_int = 16;\npub const CS: ::c_int = 17;\npub const EFLAGS: ::c_int = 18;\npub const RSP: ::c_int = 19;\npub const SS: ::c_int = 20;\npub const FS_BASE: ::c_int = 21;\npub const GS_BASE: ::c_int = 22;\npub const DS: ::c_int = 23;\npub const ES: ::c_int = 24;\npub const FS: ::c_int = 25;\npub const GS: ::c_int = 26;\n\n// offsets in mcontext_t.gregs from sys/ucontext.h\npub const REG_R8: ::c_int = 0;\npub const REG_R9: ::c_int = 1;\npub const REG_R10: ::c_int = 2;\npub const REG_R11: ::c_int = 3;\npub const REG_R12: ::c_int = 4;\npub const REG_R13: ::c_int = 5;\npub const REG_R14: ::c_int = 6;\npub const REG_R15: ::c_int = 7;\npub const REG_RDI: ::c_int = 8;\npub const REG_RSI: ::c_int = 9;\npub const REG_RBP: ::c_int = 10;\npub const REG_RBX: ::c_int = 11;\npub const REG_RDX: ::c_int = 12;\npub const REG_RAX: ::c_int = 13;\npub const REG_RCX: ::c_int = 14;\npub const REG_RSP: ::c_int = 15;\npub const REG_RIP: ::c_int = 16;\npub const REG_EFL: ::c_int = 17;\npub const REG_CSGSFS: ::c_int = 18;\npub const REG_ERR: ::c_int = 19;\npub const REG_TRAPNO: ::c_int = 20;\npub const REG_OLDMASK: ::c_int = 21;\npub const REG_CR2: ::c_int = 22;\n\nextern \"C\" {\n    pub fn getcontext(ucp: *mut ucontext_t) -> ::c_int;\n    pub fn setcontext(ucp: *const ucontext_t) -> ::c_int;\n    pub fn makecontext(ucp: *mut ucontext_t, func: extern \"C\" fn(), argc: ::c_int, ...);\n    pub fn swapcontext(uocp: *mut ucontext_t, ucp: *const ucontext_t) -> ::c_int;\n    pub fn iopl(level: ::c_int) -> ::c_int;\n    pub fn ioperm(from: ::c_ulong, num: ::c_ulong, turn_on: ::c_int) -> ::c_int;\n}\n\ncfg_if! {\n    if #[cfg(target_pointer_width = \"32\")] {\n        mod x32;\n        pub use self::x32::*;\n    } else {\n        mod not_x32;\n        pub use self::not_x32::*;\n    }\n}\n\ncfg_if! {\n    if #[cfg(libc_align)] {\n        mod align;\n        pub use self::align::*;\n    }\n}\n"],["1174","//! s390x\n\nuse pthread_mutex_t;\n\npub type blksize_t = i64;\npub type c_char = u8;\npub type c_long = i64;\npub type c_ulong = u64;\npub type nlink_t = u64;\npub type suseconds_t = i64;\npub type wchar_t = i32;\npub type greg_t = u64;\npub type __u64 = u64;\n\ns! {\n    pub struct sigaction {\n        pub sa_sigaction: ::sighandler_t,\n        __glibc_reserved0: ::c_int,\n        pub sa_flags: ::c_int,\n        pub sa_restorer: ::Option<extern fn()>,\n        pub sa_mask: ::sigset_t,\n    }\n\n    pub struct statfs {\n        pub f_type: ::c_uint,\n        pub f_bsize: ::c_uint,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_uint,\n        pub f_frsize: ::c_uint,\n        pub f_flags: ::c_uint,\n        f_spare: [::c_uint; 4],\n    }\n\n    pub struct flock {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off_t,\n        pub l_len: ::off_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct flock64 {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off64_t,\n        pub l_len: ::off64_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_errno: ::c_int,\n        pub si_code: ::c_int,\n        _pad: ::c_int,\n        _pad2: [::c_long; 14],\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_flags: ::c_int,\n        pub ss_size: ::size_t\n    }\n\n    pub struct stat {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino_t,\n        pub st_nlink: ::nlink_t,\n        pub st_mode: ::mode_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        st_pad0: ::c_int,\n        pub st_rdev: ::dev_t,\n        pub st_size: ::off_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt_t,\n        __glibc_reserved: [::c_long; 3],\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino64_t,\n        pub st_nlink: ::nlink_t,\n        pub st_mode: ::mode_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        st_pad0: ::c_int,\n        pub st_rdev: ::dev_t,\n        pub st_size: ::off_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt64_t,\n        __glibc_reserved: [::c_long; 3],\n    }\n\n    pub struct pthread_attr_t {\n        __size: [::c_ulong; 7]\n    }\n\n    pub struct ipc_perm {\n        pub __key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::mode_t,\n        pub __seq: ::c_ushort,\n        __pad1: ::c_ushort,\n        __unused1: ::c_ulong,\n        __unused2: ::c_ulong\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        pub shm_segsz: ::size_t,\n        pub shm_atime: ::time_t,\n        pub shm_dtime: ::time_t,\n        pub shm_ctime: ::time_t,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::shmatt_t,\n        __unused4: ::c_ulong,\n        __unused5: ::c_ulong\n    }\n\n    pub struct statvfs {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_favail: ::fsfilcnt_t,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct termios2 {\n        pub c_iflag: ::tcflag_t,\n        pub c_oflag: ::tcflag_t,\n        pub c_cflag: ::tcflag_t,\n        pub c_lflag: ::tcflag_t,\n        pub c_line: ::cc_t,\n        pub c_cc: [::cc_t; 19],\n        pub c_ispeed: ::speed_t,\n        pub c_ospeed: ::speed_t,\n    }\n\n    pub struct __psw_t {\n        pub mask: u64,\n        pub addr: u64,\n    }\n\n    pub struct fpregset_t {\n        pub fpc: u32,\n        __pad: u32,\n        pub fprs: [fpreg_t; 16],\n    }\n\n    pub struct mcontext_t {\n        pub psw: __psw_t,\n        pub gregs: [u64; 16],\n        pub aregs: [u32; 16],\n        pub fpregs: fpregset_t,\n    }\n\n    pub struct ucontext_t {\n        pub uc_flags: ::c_ulong,\n        pub uc_link: *mut ucontext_t,\n        pub uc_stack: ::stack_t,\n        pub uc_mcontext: mcontext_t,\n        pub uc_sigmask: ::sigset_t,\n    }\n\n    pub struct statfs64 {\n        pub f_type: ::c_uint,\n        pub f_bsize: ::c_uint,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_uint,\n        pub f_frsize: ::c_uint,\n        pub f_flags: ::c_uint,\n        pub f_spare: [::c_uint; 4],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_favail: u64,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n}\n\ns_no_extra_traits! {\n    // FIXME: This is actually a union.\n    pub struct fpreg_t {\n        pub d: ::c_double,\n        // f: ::c_float,\n    }\n}\n\ncfg_if! {\n    if #[cfg(feature = \"extra_traits\")] {\n        impl PartialEq for fpreg_t {\n            fn eq(&self, other: &fpreg_t) -> bool {\n                self.d == other.d\n            }\n        }\n\n        impl Eq for fpreg_t {}\n\n        impl ::fmt::Debug for fpreg_t {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"fpreg_t\")\n                    .field(\"d\", &self.d)\n                    .finish()\n            }\n        }\n\n        impl ::hash::Hash for fpreg_t {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                let d: u64 = unsafe { ::mem::transmute(self.d) };\n                d.hash(state);\n            }\n        }\n    }\n}\n\npub const POSIX_FADV_DONTNEED: ::c_int = 6;\npub const POSIX_FADV_NOREUSE: ::c_int = 7;\n\npub const VEOF: usize = 4;\npub const RTLD_DEEPBIND: ::c_int = 0x8;\npub const RTLD_GLOBAL: ::c_int = 0x100;\npub const RTLD_NOLOAD: ::c_int = 0x4;\npub const SFD_CLOEXEC: ::c_int = 0x080000;\n\npub const NCCS: usize = 32;\n\npub const O_TRUNC: ::c_int = 512;\npub const O_NOATIME: ::c_int = 0o1000000;\npub const O_CLOEXEC: ::c_int = 0x80000;\npub const O_PATH: ::c_int = 0o10000000;\npub const O_TMPFILE: ::c_int = 0o20000000 | O_DIRECTORY;\n\npub const EBFONT: ::c_int = 59;\npub const ENOSTR: ::c_int = 60;\npub const ENODATA: ::c_int = 61;\npub const ETIME: ::c_int = 62;\npub const ENOSR: ::c_int = 63;\npub const ENONET: ::c_int = 64;\npub const ENOPKG: ::c_int = 65;\npub const EREMOTE: ::c_int = 66;\npub const ENOLINK: ::c_int = 67;\npub const EADV: ::c_int = 68;\npub const ESRMNT: ::c_int = 69;\npub const ECOMM: ::c_int = 70;\npub const EPROTO: ::c_int = 71;\npub const EDOTDOT: ::c_int = 73;\n\npub const SA_NODEFER: ::c_int = 0x40000000;\npub const SA_RESETHAND: ::c_int = 0x80000000;\npub const SA_RESTART: ::c_int = 0x10000000;\npub const SA_NOCLDSTOP: ::c_int = 0x00000001;\n\npub const EPOLL_CLOEXEC: ::c_int = 0x80000;\n\npub const EFD_CLOEXEC: ::c_int = 0x80000;\n\npub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;\npub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;\npub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;\npub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;\n\nalign_const! {\n    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n}\n\npub const EUCLEAN: ::c_int = 117;\npub const ENOTNAM: ::c_int = 118;\npub const ENAVAIL: ::c_int = 119;\npub const EISNAM: ::c_int = 120;\npub const EREMOTEIO: ::c_int = 121;\npub const EADDRINUSE: ::c_int = 98;\npub const EADDRNOTAVAIL: ::c_int = 99;\npub const ECONNABORTED: ::c_int = 103;\npub const ECONNREFUSED: ::c_int = 111;\npub const ECONNRESET: ::c_int = 104;\npub const EDEADLK: ::c_int = 35;\npub const ENOSYS: ::c_int = 38;\npub const ENOTCONN: ::c_int = 107;\npub const ETIMEDOUT: ::c_int = 110;\npub const FIOCLEX: ::c_ulong = 0x5451;\npub const FIONCLEX: ::c_ulong = 0x5450;\npub const FIONBIO: ::c_ulong = 0x5421;\npub const O_APPEND: ::c_int = 1024;\npub const O_CREAT: ::c_int = 64;\npub const O_EXCL: ::c_int = 128;\npub const O_NONBLOCK: ::c_int = 2048;\npub const SA_NOCLDWAIT: ::c_int = 2;\npub const SA_ONSTACK: ::c_int = 0x08000000;\npub const SA_SIGINFO: ::c_int = 4;\npub const SIGBUS: ::c_int = 7;\npub const SIGSTKSZ: ::size_t = 0x2000;\npub const MINSIGSTKSZ: ::size_t = 2048;\npub const SIG_SETMASK: ::c_int = 2;\n\npub const SOCK_STREAM: ::c_int = 1;\npub const SOCK_DGRAM: ::c_int = 2;\n\npub const RLIMIT_RSS: ::__rlimit_resource_t = 5;\npub const RLIMIT_AS: ::__rlimit_resource_t = 9;\npub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 8;\npub const RLIMIT_NOFILE: ::__rlimit_resource_t = 7;\npub const RLIMIT_NPROC: ::__rlimit_resource_t = 6;\n\npub const O_NOCTTY: ::c_int = 256;\npub const O_SYNC: ::c_int = 1052672;\npub const O_RSYNC: ::c_int = 1052672;\npub const O_DSYNC: ::c_int = 4096;\npub const O_FSYNC: ::c_int = 0x101000;\npub const O_DIRECT: ::c_int = 0x4000;\npub const O_DIRECTORY: ::c_int = 0x10000;\npub const O_NOFOLLOW: ::c_int = 0x20000;\n\npub const MADV_SOFT_OFFLINE: ::c_int = 101;\npub const MAP_GROWSDOWN: ::c_int = 0x0100;\npub const MAP_LOCKED: ::c_int = 0x02000;\npub const MAP_NORESERVE: ::c_int = 0x04000;\npub const MAP_ANON: ::c_int = 0x0020;\npub const MAP_ANONYMOUS: ::c_int = 0x0020;\npub const MAP_DENYWRITE: ::c_int = 0x0800;\npub const MAP_EXECUTABLE: ::c_int = 0x01000;\npub const MAP_POPULATE: ::c_int = 0x08000;\npub const MAP_NONBLOCK: ::c_int = 0x010000;\npub const MAP_STACK: ::c_int = 0x020000;\npub const MAP_HUGETLB: ::c_int = 0x040000;\n\npub const EDEADLOCK: ::c_int = 35;\npub const ENAMETOOLONG: ::c_int = 36;\npub const ENOLCK: ::c_int = 37;\npub const ENOTEMPTY: ::c_int = 39;\npub const ELOOP: ::c_int = 40;\npub const ENOMSG: ::c_int = 42;\npub const EIDRM: ::c_int = 43;\npub const ECHRNG: ::c_int = 44;\npub const EL2NSYNC: ::c_int = 45;\npub const EL3HLT: ::c_int = 46;\npub const EL3RST: ::c_int = 47;\npub const ELNRNG: ::c_int = 48;\npub const EUNATCH: ::c_int = 49;\npub const ENOCSI: ::c_int = 50;\npub const EL2HLT: ::c_int = 51;\npub const EBADE: ::c_int = 52;\npub const EBADR: ::c_int = 53;\npub const EXFULL: ::c_int = 54;\npub const ENOANO: ::c_int = 55;\npub const EBADRQC: ::c_int = 56;\npub const EBADSLT: ::c_int = 57;\npub const EMULTIHOP: ::c_int = 72;\npub const EOVERFLOW: ::c_int = 75;\npub const ENOTUNIQ: ::c_int = 76;\npub const EBADFD: ::c_int = 77;\npub const EBADMSG: ::c_int = 74;\npub const EREMCHG: ::c_int = 78;\npub const ELIBACC: ::c_int = 79;\npub const ELIBBAD: ::c_int = 80;\npub const ELIBSCN: ::c_int = 81;\npub const ELIBMAX: ::c_int = 82;\npub const ELIBEXEC: ::c_int = 83;\npub const EILSEQ: ::c_int = 84;\npub const ERESTART: ::c_int = 85;\npub const ESTRPIPE: ::c_int = 86;\npub const EUSERS: ::c_int = 87;\npub const ENOTSOCK: ::c_int = 88;\npub const EDESTADDRREQ: ::c_int = 89;\npub const EMSGSIZE: ::c_int = 90;\npub const EPROTOTYPE: ::c_int = 91;\npub const ENOPROTOOPT: ::c_int = 92;\npub const EPROTONOSUPPORT: ::c_int = 93;\npub const ESOCKTNOSUPPORT: ::c_int = 94;\npub const EOPNOTSUPP: ::c_int = 95;\npub const EPFNOSUPPORT: ::c_int = 96;\npub const EAFNOSUPPORT: ::c_int = 97;\npub const ENETDOWN: ::c_int = 100;\npub const ENETUNREACH: ::c_int = 101;\npub const ENETRESET: ::c_int = 102;\npub const ENOBUFS: ::c_int = 105;\npub const EISCONN: ::c_int = 106;\npub const ESHUTDOWN: ::c_int = 108;\npub const ETOOMANYREFS: ::c_int = 109;\npub const EHOSTDOWN: ::c_int = 112;\npub const EHOSTUNREACH: ::c_int = 113;\npub const EALREADY: ::c_int = 114;\npub const EINPROGRESS: ::c_int = 115;\npub const ESTALE: ::c_int = 116;\npub const EDQUOT: ::c_int = 122;\npub const ENOMEDIUM: ::c_int = 123;\npub const EMEDIUMTYPE: ::c_int = 124;\npub const ECANCELED: ::c_int = 125;\npub const ENOKEY: ::c_int = 126;\npub const EKEYEXPIRED: ::c_int = 127;\npub const EKEYREVOKED: ::c_int = 128;\npub const EKEYREJECTED: ::c_int = 129;\npub const EOWNERDEAD: ::c_int = 130;\npub const ENOTRECOVERABLE: ::c_int = 131;\npub const EHWPOISON: ::c_int = 133;\npub const ERFKILL: ::c_int = 132;\n\npub const SIGTTIN: ::c_int = 21;\npub const SIGTTOU: ::c_int = 22;\npub const SIGXCPU: ::c_int = 24;\npub const SIGXFSZ: ::c_int = 25;\npub const SIGVTALRM: ::c_int = 26;\npub const SIGPROF: ::c_int = 27;\npub const SIGWINCH: ::c_int = 28;\npub const SIGCHLD: ::c_int = 17;\npub const SIGUSR1: ::c_int = 10;\npub const SIGUSR2: ::c_int = 12;\npub const SIGCONT: ::c_int = 18;\npub const SIGSTOP: ::c_int = 19;\npub const SIGTSTP: ::c_int = 20;\npub const SIGURG: ::c_int = 23;\npub const SIGIO: ::c_int = 29;\npub const SIGSYS: ::c_int = 31;\npub const SIGSTKFLT: ::c_int = 16;\n#[deprecated(since = \"0.2.55\", note = \"Use SIGSYS instead\")]\npub const SIGUNUSED: ::c_int = 31;\npub const SIGPOLL: ::c_int = 29;\npub const SIGPWR: ::c_int = 30;\npub const SIG_BLOCK: ::c_int = 0x000000;\npub const SIG_UNBLOCK: ::c_int = 0x01;\n\npub const O_ASYNC: ::c_int = 0x2000;\npub const O_NDELAY: ::c_int = 0x800;\n\npub const VEOL: usize = 11;\npub const VEOL2: usize = 16;\npub const VMIN: usize = 6;\npub const IEXTEN: ::tcflag_t = 0x00008000;\npub const TOSTOP: ::tcflag_t = 0x00000100;\npub const FLUSHO: ::tcflag_t = 0x00001000;\n\npub const EXTPROC: ::tcflag_t = 0x00010000;\n\npub const PTRACE_DETACH: ::c_uint = 17;\n\npub const MCL_CURRENT: ::c_int = 0x0001;\npub const MCL_FUTURE: ::c_int = 0x0002;\n\npub const EFD_NONBLOCK: ::c_int = 0x800;\n\npub const F_RDLCK: ::c_int = 0;\npub const F_WRLCK: ::c_int = 1;\npub const F_UNLCK: ::c_int = 2;\npub const F_GETLK: ::c_int = 5;\npub const F_GETOWN: ::c_int = 9;\npub const F_SETOWN: ::c_int = 8;\npub const F_SETLK: ::c_int = 6;\npub const F_SETLKW: ::c_int = 7;\npub const F_OFD_GETLK: ::c_int = 36;\npub const F_OFD_SETLK: ::c_int = 37;\npub const F_OFD_SETLKW: ::c_int = 38;\n\npub const SFD_NONBLOCK: ::c_int = 0x0800;\n\npub const TCGETS: ::c_ulong = 0x5401;\npub const TCSETS: ::c_ulong = 0x5402;\npub const TCSETSW: ::c_ulong = 0x5403;\npub const TCSETSF: ::c_ulong = 0x5404;\npub const TCGETA: ::c_ulong = 0x5405;\npub const TCSETA: ::c_ulong = 0x5406;\npub const TCSETAW: ::c_ulong = 0x5407;\npub const TCSETAF: ::c_ulong = 0x5408;\npub const TCSBRK: ::c_ulong = 0x5409;\npub const TCXONC: ::c_ulong = 0x540A;\npub const TCFLSH: ::c_ulong = 0x540B;\npub const TIOCGSOFTCAR: ::c_ulong = 0x5419;\npub const TIOCSSOFTCAR: ::c_ulong = 0x541A;\npub const TIOCINQ: ::c_ulong = 0x541B;\npub const TIOCEXCL: ::c_ulong = 0x540C;\npub const TIOCNXCL: ::c_ulong = 0x540D;\npub const TIOCSCTTY: ::c_ulong = 0x540E;\npub const TIOCGPGRP: ::c_ulong = 0x540F;\npub const TIOCSPGRP: ::c_ulong = 0x5410;\npub const TIOCOUTQ: ::c_ulong = 0x5411;\npub const TIOCSTI: ::c_ulong = 0x5412;\npub const TIOCGWINSZ: ::c_ulong = 0x5413;\npub const TIOCSWINSZ: ::c_ulong = 0x5414;\npub const TIOCMGET: ::c_ulong = 0x5415;\npub const TIOCMBIS: ::c_ulong = 0x5416;\npub const TIOCMBIC: ::c_ulong = 0x5417;\npub const TIOCMSET: ::c_ulong = 0x5418;\npub const FIONREAD: ::c_ulong = 0x541B;\npub const TIOCCONS: ::c_ulong = 0x541D;\npub const TIOCSBRK: ::c_ulong = 0x5427;\npub const TIOCCBRK: ::c_ulong = 0x5428;\n\npub const TCSANOW: ::c_int = 0;\npub const TCSADRAIN: ::c_int = 1;\npub const TCSAFLUSH: ::c_int = 2;\n\npub const TIOCLINUX: ::c_ulong = 0x541C;\npub const TIOCGSERIAL: ::c_ulong = 0x541E;\npub const TIOCM_ST: ::c_int = 0x008;\npub const TIOCM_SR: ::c_int = 0x010;\npub const TIOCM_CTS: ::c_int = 0x020;\npub const TIOCM_CAR: ::c_int = 0x040;\npub const TIOCM_RNG: ::c_int = 0x080;\npub const TIOCM_DSR: ::c_int = 0x100;\n\npub const VTIME: usize = 5;\npub const VSWTC: usize = 7;\npub const VSTART: usize = 8;\npub const VSTOP: usize = 9;\npub const VSUSP: usize = 10;\npub const VREPRINT: usize = 12;\npub const VDISCARD: usize = 13;\npub const VWERASE: usize = 14;\npub const OLCUC: ::tcflag_t = 0o000002;\npub const ONLCR: ::tcflag_t = 0o000004;\npub const NLDLY: ::tcflag_t = 0o000400;\npub const CRDLY: ::tcflag_t = 0o003000;\npub const CR1: ::tcflag_t = 0x00000200;\npub const CR2: ::tcflag_t = 0x00000400;\npub const CR3: ::tcflag_t = 0x00000600;\npub const TABDLY: ::tcflag_t = 0o014000;\npub const TAB1: ::tcflag_t = 0x00000800;\npub const TAB2: ::tcflag_t = 0x00001000;\npub const TAB3: ::tcflag_t = 0x00001800;\npub const BSDLY: ::tcflag_t = 0o020000;\npub const BS1: ::tcflag_t = 0x00002000;\npub const FFDLY: ::tcflag_t = 0o100000;\npub const FF1: ::tcflag_t = 0x00008000;\npub const VTDLY: ::tcflag_t = 0o040000;\npub const VT1: ::tcflag_t = 0x00004000;\npub const XTABS: ::tcflag_t = 0o014000;\n\npub const CBAUD: ::speed_t = 0o010017;\npub const B0: ::speed_t = 0o000000;\npub const B50: ::speed_t = 0o000001;\npub const B75: ::speed_t = 0o000002;\npub const B110: ::speed_t = 0o000003;\npub const B134: ::speed_t = 0o000004;\npub const B150: ::speed_t = 0o000005;\npub const B200: ::speed_t = 0o000006;\npub const B300: ::speed_t = 0o000007;\npub const B600: ::speed_t = 0o000010;\npub const B1200: ::speed_t = 0o000011;\npub const B1800: ::speed_t = 0o000012;\npub const B2400: ::speed_t = 0o000013;\npub const B4800: ::speed_t = 0o000014;\npub const B9600: ::speed_t = 0o000015;\npub const B19200: ::speed_t = 0o000016;\npub const B38400: ::speed_t = 0o000017;\npub const EXTA: ::speed_t = B19200;\npub const EXTB: ::speed_t = B38400;\npub const CSIZE: ::tcflag_t = 0o000060;\npub const CS6: ::tcflag_t = 0o000020;\npub const CS7: ::tcflag_t = 0o000040;\npub const CS8: ::tcflag_t = 0o000060;\npub const CSTOPB: ::tcflag_t = 0o000100;\npub const CREAD: ::tcflag_t = 0o000200;\npub const PARENB: ::tcflag_t = 0o000400;\npub const PARODD: ::tcflag_t = 0o001000;\npub const HUPCL: ::tcflag_t = 0o002000;\npub const CLOCAL: ::tcflag_t = 0o004000;\npub const CBAUDEX: ::tcflag_t = 0o010000;\npub const BOTHER: ::speed_t = 0o010000;\npub const B57600: ::speed_t = 0o010001;\npub const B115200: ::speed_t = 0o010002;\npub const B230400: ::speed_t = 0o010003;\npub const B460800: ::speed_t = 0o010004;\npub const B500000: ::speed_t = 0o010005;\npub const B576000: ::speed_t = 0o010006;\npub const B921600: ::speed_t = 0o010007;\npub const B1000000: ::speed_t = 0o010010;\npub const B1152000: ::speed_t = 0o010011;\npub const B1500000: ::speed_t = 0o010012;\npub const B2000000: ::speed_t = 0o010013;\npub const B2500000: ::speed_t = 0o010014;\npub const B3000000: ::speed_t = 0o010015;\npub const B3500000: ::speed_t = 0o010016;\npub const B4000000: ::speed_t = 0o010017;\npub const CIBAUD: ::tcflag_t = 0o02003600000;\n\npub const ISIG: ::tcflag_t = 0o000001;\npub const ICANON: ::tcflag_t = 0o000002;\npub const XCASE: ::tcflag_t = 0o000004;\npub const ECHOE: ::tcflag_t = 0o000020;\npub const ECHOK: ::tcflag_t = 0o000040;\npub const ECHONL: ::tcflag_t = 0o000100;\npub const NOFLSH: ::tcflag_t = 0o000200;\npub const ECHOCTL: ::tcflag_t = 0o001000;\npub const ECHOPRT: ::tcflag_t = 0o002000;\npub const ECHOKE: ::tcflag_t = 0o004000;\npub const PENDIN: ::tcflag_t = 0o040000;\n\npub const POLLWRNORM: ::c_short = 0x100;\npub const POLLWRBAND: ::c_short = 0x200;\n\npub const IXON: ::tcflag_t = 0o002000;\npub const IXOFF: ::tcflag_t = 0o010000;\n\npub const SYS_exit: ::c_long = 1;\npub const SYS_fork: ::c_long = 2;\npub const SYS_read: ::c_long = 3;\npub const SYS_write: ::c_long = 4;\npub const SYS_open: ::c_long = 5;\npub const SYS_close: ::c_long = 6;\npub const SYS_restart_syscall: ::c_long = 7;\npub const SYS_creat: ::c_long = 8;\npub const SYS_link: ::c_long = 9;\npub const SYS_unlink: ::c_long = 10;\npub const SYS_execve: ::c_long = 11;\npub const SYS_chdir: ::c_long = 12;\npub const SYS_mknod: ::c_long = 14;\npub const SYS_chmod: ::c_long = 15;\npub const SYS_lseek: ::c_long = 19;\npub const SYS_getpid: ::c_long = 20;\npub const SYS_mount: ::c_long = 21;\npub const SYS_umount: ::c_long = 22;\npub const SYS_ptrace: ::c_long = 26;\npub const SYS_alarm: ::c_long = 27;\npub const SYS_pause: ::c_long = 29;\npub const SYS_utime: ::c_long = 30;\npub const SYS_access: ::c_long = 33;\npub const SYS_nice: ::c_long = 34;\npub const SYS_sync: ::c_long = 36;\npub const SYS_kill: ::c_long = 37;\npub const SYS_rename: ::c_long = 38;\npub const SYS_mkdir: ::c_long = 39;\npub const SYS_rmdir: ::c_long = 40;\npub const SYS_dup: ::c_long = 41;\npub const SYS_pipe: ::c_long = 42;\npub const SYS_times: ::c_long = 43;\npub const SYS_brk: ::c_long = 45;\npub const SYS_signal: ::c_long = 48;\npub const SYS_acct: ::c_long = 51;\npub const SYS_umount2: ::c_long = 52;\npub const SYS_ioctl: ::c_long = 54;\npub const SYS_fcntl: ::c_long = 55;\npub const SYS_setpgid: ::c_long = 57;\npub const SYS_umask: ::c_long = 60;\npub const SYS_chroot: ::c_long = 61;\npub const SYS_ustat: ::c_long = 62;\npub const SYS_dup2: ::c_long = 63;\npub const SYS_getppid: ::c_long = 64;\npub const SYS_getpgrp: ::c_long = 65;\npub const SYS_setsid: ::c_long = 66;\npub const SYS_sigaction: ::c_long = 67;\npub const SYS_sigsuspend: ::c_long = 72;\npub const SYS_sigpending: ::c_long = 73;\npub const SYS_sethostname: ::c_long = 74;\npub const SYS_setrlimit: ::c_long = 75;\npub const SYS_getrusage: ::c_long = 77;\npub const SYS_gettimeofday: ::c_long = 78;\npub const SYS_settimeofday: ::c_long = 79;\npub const SYS_symlink: ::c_long = 83;\npub const SYS_readlink: ::c_long = 85;\npub const SYS_uselib: ::c_long = 86;\npub const SYS_swapon: ::c_long = 87;\npub const SYS_reboot: ::c_long = 88;\npub const SYS_readdir: ::c_long = 89;\npub const SYS_mmap: ::c_long = 90;\npub const SYS_munmap: ::c_long = 91;\npub const SYS_truncate: ::c_long = 92;\npub const SYS_ftruncate: ::c_long = 93;\npub const SYS_fchmod: ::c_long = 94;\npub const SYS_getpriority: ::c_long = 96;\npub const SYS_setpriority: ::c_long = 97;\npub const SYS_statfs: ::c_long = 99;\npub const SYS_fstatfs: ::c_long = 100;\npub const SYS_socketcall: ::c_long = 102;\npub const SYS_syslog: ::c_long = 103;\npub const SYS_setitimer: ::c_long = 104;\npub const SYS_getitimer: ::c_long = 105;\npub const SYS_stat: ::c_long = 106;\npub const SYS_lstat: ::c_long = 107;\npub const SYS_fstat: ::c_long = 108;\npub const SYS_lookup_dcookie: ::c_long = 110;\npub const SYS_vhangup: ::c_long = 111;\npub const SYS_idle: ::c_long = 112;\npub const SYS_wait4: ::c_long = 114;\npub const SYS_swapoff: ::c_long = 115;\npub const SYS_sysinfo: ::c_long = 116;\npub const SYS_ipc: ::c_long = 117;\npub const SYS_fsync: ::c_long = 118;\npub const SYS_sigreturn: ::c_long = 119;\npub const SYS_clone: ::c_long = 120;\npub const SYS_setdomainname: ::c_long = 121;\npub const SYS_uname: ::c_long = 122;\npub const SYS_adjtimex: ::c_long = 124;\npub const SYS_mprotect: ::c_long = 125;\npub const SYS_sigprocmask: ::c_long = 126;\npub const SYS_create_module: ::c_long = 127;\npub const SYS_init_module: ::c_long = 128;\npub const SYS_delete_module: ::c_long = 129;\npub const SYS_get_kernel_syms: ::c_long = 130;\npub const SYS_quotactl: ::c_long = 131;\npub const SYS_getpgid: ::c_long = 132;\npub const SYS_fchdir: ::c_long = 133;\npub const SYS_bdflush: ::c_long = 134;\npub const SYS_sysfs: ::c_long = 135;\npub const SYS_personality: ::c_long = 136;\npub const SYS_afs_syscall: ::c_long = 137; /* Syscall for Andrew File System */\npub const SYS_getdents: ::c_long = 141;\npub const SYS_flock: ::c_long = 143;\npub const SYS_msync: ::c_long = 144;\npub const SYS_readv: ::c_long = 145;\npub const SYS_writev: ::c_long = 146;\npub const SYS_getsid: ::c_long = 147;\npub const SYS_fdatasync: ::c_long = 148;\npub const SYS__sysctl: ::c_long = 149;\npub const SYS_mlock: ::c_long = 150;\npub const SYS_munlock: ::c_long = 151;\npub const SYS_mlockall: ::c_long = 152;\npub const SYS_munlockall: ::c_long = 153;\npub const SYS_sched_setparam: ::c_long = 154;\npub const SYS_sched_getparam: ::c_long = 155;\npub const SYS_sched_setscheduler: ::c_long = 156;\npub const SYS_sched_getscheduler: ::c_long = 157;\npub const SYS_sched_yield: ::c_long = 158;\npub const SYS_sched_get_priority_max: ::c_long = 159;\npub const SYS_sched_get_priority_min: ::c_long = 160;\npub const SYS_sched_rr_get_interval: ::c_long = 161;\npub const SYS_nanosleep: ::c_long = 162;\npub const SYS_mremap: ::c_long = 163;\npub const SYS_query_module: ::c_long = 167;\npub const SYS_poll: ::c_long = 168;\npub const SYS_nfsservctl: ::c_long = 169;\npub const SYS_prctl: ::c_long = 172;\npub const SYS_rt_sigreturn: ::c_long = 173;\npub const SYS_rt_sigaction: ::c_long = 174;\npub const SYS_rt_sigprocmask: ::c_long = 175;\npub const SYS_rt_sigpending: ::c_long = 176;\npub const SYS_rt_sigtimedwait: ::c_long = 177;\npub const SYS_rt_sigqueueinfo: ::c_long = 178;\npub const SYS_rt_sigsuspend: ::c_long = 179;\npub const SYS_pread64: ::c_long = 180;\npub const SYS_pwrite64: ::c_long = 181;\npub const SYS_getcwd: ::c_long = 183;\npub const SYS_capget: ::c_long = 184;\npub const SYS_capset: ::c_long = 185;\npub const SYS_sigaltstack: ::c_long = 186;\npub const SYS_sendfile: ::c_long = 187;\npub const SYS_getpmsg: ::c_long = 188;\npub const SYS_putpmsg: ::c_long = 189;\npub const SYS_vfork: ::c_long = 190;\npub const SYS_pivot_root: ::c_long = 217;\npub const SYS_mincore: ::c_long = 218;\npub const SYS_madvise: ::c_long = 219;\npub const SYS_getdents64: ::c_long = 220;\npub const SYS_readahead: ::c_long = 222;\npub const SYS_setxattr: ::c_long = 224;\npub const SYS_lsetxattr: ::c_long = 225;\npub const SYS_fsetxattr: ::c_long = 226;\npub const SYS_getxattr: ::c_long = 227;\npub const SYS_lgetxattr: ::c_long = 228;\npub const SYS_fgetxattr: ::c_long = 229;\npub const SYS_listxattr: ::c_long = 230;\npub const SYS_llistxattr: ::c_long = 231;\npub const SYS_flistxattr: ::c_long = 232;\npub const SYS_removexattr: ::c_long = 233;\npub const SYS_lremovexattr: ::c_long = 234;\npub const SYS_fremovexattr: ::c_long = 235;\npub const SYS_gettid: ::c_long = 236;\npub const SYS_tkill: ::c_long = 237;\npub const SYS_futex: ::c_long = 238;\npub const SYS_sched_setaffinity: ::c_long = 239;\npub const SYS_sched_getaffinity: ::c_long = 240;\npub const SYS_tgkill: ::c_long = 241;\npub const SYS_io_setup: ::c_long = 243;\npub const SYS_io_destroy: ::c_long = 244;\npub const SYS_io_getevents: ::c_long = 245;\npub const SYS_io_submit: ::c_long = 246;\npub const SYS_io_cancel: ::c_long = 247;\npub const SYS_exit_group: ::c_long = 248;\npub const SYS_epoll_create: ::c_long = 249;\npub const SYS_epoll_ctl: ::c_long = 250;\npub const SYS_epoll_wait: ::c_long = 251;\npub const SYS_set_tid_address: ::c_long = 252;\npub const SYS_fadvise64: ::c_long = 253;\npub const SYS_timer_create: ::c_long = 254;\npub const SYS_timer_settime: ::c_long = 255;\npub const SYS_timer_gettime: ::c_long = 256;\npub const SYS_timer_getoverrun: ::c_long = 257;\npub const SYS_timer_delete: ::c_long = 258;\npub const SYS_clock_settime: ::c_long = 259;\npub const SYS_clock_gettime: ::c_long = 260;\npub const SYS_clock_getres: ::c_long = 261;\npub const SYS_clock_nanosleep: ::c_long = 262;\npub const SYS_statfs64: ::c_long = 265;\npub const SYS_fstatfs64: ::c_long = 266;\npub const SYS_remap_file_pages: ::c_long = 267;\npub const SYS_mbind: ::c_long = 268;\npub const SYS_get_mempolicy: ::c_long = 269;\npub const SYS_set_mempolicy: ::c_long = 270;\npub const SYS_mq_open: ::c_long = 271;\npub const SYS_mq_unlink: ::c_long = 272;\npub const SYS_mq_timedsend: ::c_long = 273;\npub const SYS_mq_timedreceive: ::c_long = 274;\npub const SYS_mq_notify: ::c_long = 275;\npub const SYS_mq_getsetattr: ::c_long = 276;\npub const SYS_kexec_load: ::c_long = 277;\npub const SYS_add_key: ::c_long = 278;\npub const SYS_request_key: ::c_long = 279;\npub const SYS_keyctl: ::c_long = 280;\npub const SYS_waitid: ::c_long = 281;\npub const SYS_ioprio_set: ::c_long = 282;\npub const SYS_ioprio_get: ::c_long = 283;\npub const SYS_inotify_init: ::c_long = 284;\npub const SYS_inotify_add_watch: ::c_long = 285;\npub const SYS_inotify_rm_watch: ::c_long = 286;\npub const SYS_migrate_pages: ::c_long = 287;\npub const SYS_openat: ::c_long = 288;\npub const SYS_mkdirat: ::c_long = 289;\npub const SYS_mknodat: ::c_long = 290;\npub const SYS_fchownat: ::c_long = 291;\npub const SYS_futimesat: ::c_long = 292;\npub const SYS_unlinkat: ::c_long = 294;\npub const SYS_renameat: ::c_long = 295;\npub const SYS_linkat: ::c_long = 296;\npub const SYS_symlinkat: ::c_long = 297;\npub const SYS_readlinkat: ::c_long = 298;\npub const SYS_fchmodat: ::c_long = 299;\npub const SYS_faccessat: ::c_long = 300;\npub const SYS_pselect6: ::c_long = 301;\npub const SYS_ppoll: ::c_long = 302;\npub const SYS_unshare: ::c_long = 303;\npub const SYS_set_robust_list: ::c_long = 304;\npub const SYS_get_robust_list: ::c_long = 305;\npub const SYS_splice: ::c_long = 306;\npub const SYS_sync_file_range: ::c_long = 307;\npub const SYS_tee: ::c_long = 308;\npub const SYS_vmsplice: ::c_long = 309;\npub const SYS_move_pages: ::c_long = 310;\npub const SYS_getcpu: ::c_long = 311;\npub const SYS_epoll_pwait: ::c_long = 312;\npub const SYS_utimes: ::c_long = 313;\npub const SYS_fallocate: ::c_long = 314;\npub const SYS_utimensat: ::c_long = 315;\npub const SYS_signalfd: ::c_long = 316;\npub const SYS_timerfd: ::c_long = 317;\npub const SYS_eventfd: ::c_long = 318;\npub const SYS_timerfd_create: ::c_long = 319;\npub const SYS_timerfd_settime: ::c_long = 320;\npub const SYS_timerfd_gettime: ::c_long = 321;\npub const SYS_signalfd4: ::c_long = 322;\npub const SYS_eventfd2: ::c_long = 323;\npub const SYS_inotify_init1: ::c_long = 324;\npub const SYS_pipe2: ::c_long = 325;\npub const SYS_dup3: ::c_long = 326;\npub const SYS_epoll_create1: ::c_long = 327;\npub const SYS_preadv: ::c_long = 328;\npub const SYS_pwritev: ::c_long = 329;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 330;\npub const SYS_perf_event_open: ::c_long = 331;\npub const SYS_fanotify_init: ::c_long = 332;\npub const SYS_fanotify_mark: ::c_long = 333;\npub const SYS_prlimit64: ::c_long = 334;\npub const SYS_name_to_handle_at: ::c_long = 335;\npub const SYS_open_by_handle_at: ::c_long = 336;\npub const SYS_clock_adjtime: ::c_long = 337;\npub const SYS_syncfs: ::c_long = 338;\npub const SYS_setns: ::c_long = 339;\npub const SYS_process_vm_readv: ::c_long = 340;\npub const SYS_process_vm_writev: ::c_long = 341;\npub const SYS_s390_runtime_instr: ::c_long = 342;\npub const SYS_kcmp: ::c_long = 343;\npub const SYS_finit_module: ::c_long = 344;\npub const SYS_sched_setattr: ::c_long = 345;\npub const SYS_sched_getattr: ::c_long = 346;\npub const SYS_renameat2: ::c_long = 347;\npub const SYS_seccomp: ::c_long = 348;\npub const SYS_getrandom: ::c_long = 349;\npub const SYS_memfd_create: ::c_long = 350;\npub const SYS_bpf: ::c_long = 351;\npub const SYS_s390_pci_mmio_write: ::c_long = 352;\npub const SYS_s390_pci_mmio_read: ::c_long = 353;\npub const SYS_execveat: ::c_long = 354;\npub const SYS_userfaultfd: ::c_long = 355;\npub const SYS_membarrier: ::c_long = 356;\npub const SYS_recvmmsg: ::c_long = 357;\npub const SYS_sendmmsg: ::c_long = 358;\npub const SYS_socket: ::c_long = 359;\npub const SYS_socketpair: ::c_long = 360;\npub const SYS_bind: ::c_long = 361;\npub const SYS_connect: ::c_long = 362;\npub const SYS_listen: ::c_long = 363;\npub const SYS_accept4: ::c_long = 364;\npub const SYS_getsockopt: ::c_long = 365;\npub const SYS_setsockopt: ::c_long = 366;\npub const SYS_getsockname: ::c_long = 367;\npub const SYS_getpeername: ::c_long = 368;\npub const SYS_sendto: ::c_long = 369;\npub const SYS_sendmsg: ::c_long = 370;\npub const SYS_recvfrom: ::c_long = 371;\npub const SYS_recvmsg: ::c_long = 372;\npub const SYS_shutdown: ::c_long = 373;\npub const SYS_mlock2: ::c_long = 374;\npub const SYS_copy_file_range: ::c_long = 375;\npub const SYS_preadv2: ::c_long = 376;\npub const SYS_pwritev2: ::c_long = 377;\npub const SYS_lchown: ::c_long = 198;\npub const SYS_setuid: ::c_long = 213;\npub const SYS_getuid: ::c_long = 199;\npub const SYS_setgid: ::c_long = 214;\npub const SYS_getgid: ::c_long = 200;\npub const SYS_geteuid: ::c_long = 201;\npub const SYS_setreuid: ::c_long = 203;\npub const SYS_setregid: ::c_long = 204;\npub const SYS_getrlimit: ::c_long = 191;\npub const SYS_getgroups: ::c_long = 205;\npub const SYS_fchown: ::c_long = 207;\npub const SYS_setresuid: ::c_long = 208;\npub const SYS_setresgid: ::c_long = 210;\npub const SYS_getresgid: ::c_long = 211;\npub const SYS_select: ::c_long = 142;\npub const SYS_getegid: ::c_long = 202;\npub const SYS_setgroups: ::c_long = 206;\npub const SYS_getresuid: ::c_long = 209;\npub const SYS_chown: ::c_long = 212;\npub const SYS_setfsuid: ::c_long = 215;\npub const SYS_setfsgid: ::c_long = 216;\npub const SYS_newfstatat: ::c_long = 293;\npub const SYS_statx: ::c_long = 379;\npub const SYS_pidfd_send_signal: ::c_long = 424;\npub const SYS_io_uring_setup: ::c_long = 425;\npub const SYS_io_uring_enter: ::c_long = 426;\npub const SYS_io_uring_register: ::c_long = 427;\npub const SYS_open_tree: ::c_long = 428;\npub const SYS_move_mount: ::c_long = 429;\npub const SYS_fsopen: ::c_long = 430;\npub const SYS_fsconfig: ::c_long = 431;\npub const SYS_fsmount: ::c_long = 432;\npub const SYS_fspick: ::c_long = 433;\npub const SYS_pidfd_open: ::c_long = 434;\npub const SYS_clone3: ::c_long = 435;\npub const SYS_close_range: ::c_long = 436;\npub const SYS_openat2: ::c_long = 437;\npub const SYS_pidfd_getfd: ::c_long = 438;\npub const SYS_faccessat2: ::c_long = 439;\npub const SYS_process_madvise: ::c_long = 440;\npub const SYS_epoll_pwait2: ::c_long = 441;\npub const SYS_mount_setattr: ::c_long = 442;\n\nextern \"C\" {\n\n    pub fn sysctl(\n        name: *mut ::c_int,\n        namelen: ::c_int,\n        oldp: *mut ::c_void,\n        oldlenp: *mut ::size_t,\n        newp: *mut ::c_void,\n        newlen: ::size_t,\n    ) -> ::c_int;\n    pub fn getcontext(ucp: *mut ::ucontext_t) -> ::c_int;\n    pub fn setcontext(ucp: *const ::ucontext_t) -> ::c_int;\n    pub fn makecontext(ucp: *mut ::ucontext_t, func: extern \"C\" fn(), argc: ::c_int, ...);\n    pub fn swapcontext(uocp: *mut ::ucontext_t, ucp: *const ::ucontext_t) -> ::c_int;\n}\n"],["1175","//! PowerPC64-specific definitions for 64-bit linux-like values\n\nuse pthread_mutex_t;\n\npub type c_long = i64;\npub type c_ulong = u64;\npub type c_char = u8;\npub type wchar_t = i32;\npub type nlink_t = u64;\npub type blksize_t = i64;\npub type suseconds_t = i64;\npub type __u64 = ::c_ulong;\n\ns! {\n    pub struct sigaction {\n        pub sa_sigaction: ::sighandler_t,\n        pub sa_mask: ::sigset_t,\n        #[cfg(target_arch = \"sparc64\")]\n        __reserved0: ::c_int,\n        pub sa_flags: ::c_int,\n        pub sa_restorer: ::Option<extern fn()>,\n    }\n\n    pub struct statfs {\n        pub f_type: ::__fsword_t,\n        pub f_bsize: ::__fsword_t,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n\n        pub f_namelen: ::__fsword_t,\n        pub f_frsize: ::__fsword_t,\n        f_spare: [::__fsword_t; 5],\n    }\n\n    pub struct flock {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off_t,\n        pub l_len: ::off_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct flock64 {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off64_t,\n        pub l_len: ::off64_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct stat {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino_t,\n        pub st_nlink: ::nlink_t,\n        pub st_mode: ::mode_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        __pad0: ::c_int,\n        pub st_rdev: ::dev_t,\n        pub st_size: ::off_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __unused: [::c_long; 3],\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino64_t,\n        pub st_nlink: ::nlink_t,\n        pub st_mode: ::mode_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        __pad0: ::c_int,\n        pub st_rdev: ::dev_t,\n        pub st_size: ::off64_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt64_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __reserved: [::c_long; 3],\n    }\n\n    pub struct statfs64 {\n        pub f_type: ::__fsword_t,\n        pub f_bsize: ::__fsword_t,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::__fsword_t,\n        pub f_frsize: ::__fsword_t,\n        pub f_flags: ::__fsword_t,\n        pub f_spare: [::__fsword_t; 4],\n    }\n\n    pub struct statvfs {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_favail: ::fsfilcnt_t,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_favail: u64,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct pthread_attr_t {\n        __size: [u64; 7]\n    }\n\n    pub struct ipc_perm {\n        pub __key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::mode_t,\n        pub __seq: u32,\n        __pad1: u32,\n        __unused1: u64,\n        __unused2: ::c_ulong,\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        pub shm_atime: ::time_t,\n        pub shm_dtime: ::time_t,\n        pub shm_ctime: ::time_t,\n        pub shm_segsz: ::size_t,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::shmatt_t,\n        __unused4: ::c_ulong,\n        __unused5: ::c_ulong\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_errno: ::c_int,\n        pub si_code: ::c_int,\n        #[doc(hidden)]\n        #[deprecated(\n            since=\"0.2.54\",\n            note=\"Please leave a comment on \\\n                  https://github.com/rust-lang/libc/pull/1316 if you're using \\\n                  this field\"\n        )]\n        pub _pad: [::c_int; 29],\n        _align: [usize; 0],\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_flags: ::c_int,\n        pub ss_size: ::size_t\n    }\n\n    pub struct ip_mreqn {\n        pub imr_multiaddr: ::in_addr,\n        pub imr_address: ::in_addr,\n        pub imr_ifindex: ::c_int,\n    }\n}\n\npub const POSIX_FADV_DONTNEED: ::c_int = 4;\npub const POSIX_FADV_NOREUSE: ::c_int = 5;\n\npub const RTLD_DEEPBIND: ::c_int = 0x8;\npub const RTLD_GLOBAL: ::c_int = 0x100;\npub const RTLD_NOLOAD: ::c_int = 0x4;\npub const VEOF: usize = 4;\npub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;\n\npub const TIOCGSOFTCAR: ::c_ulong = 0x5419;\npub const TIOCSSOFTCAR: ::c_ulong = 0x541A;\n\npub const RLIMIT_RSS: ::__rlimit_resource_t = 5;\npub const RLIMIT_AS: ::__rlimit_resource_t = 9;\npub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 8;\npub const RLIMIT_NOFILE: ::__rlimit_resource_t = 7;\npub const RLIMIT_NPROC: ::__rlimit_resource_t = 6;\n\npub const O_APPEND: ::c_int = 1024;\npub const O_CREAT: ::c_int = 64;\npub const O_EXCL: ::c_int = 128;\npub const O_NOCTTY: ::c_int = 256;\npub const O_NONBLOCK: ::c_int = 2048;\npub const O_SYNC: ::c_int = 1052672;\npub const O_RSYNC: ::c_int = 1052672;\npub const O_DSYNC: ::c_int = 4096;\npub const O_FSYNC: ::c_int = 0x101000;\npub const O_NOATIME: ::c_int = 0o1000000;\npub const O_PATH: ::c_int = 0o10000000;\npub const O_TMPFILE: ::c_int = 0o20000000 | O_DIRECTORY;\n\npub const MADV_SOFT_OFFLINE: ::c_int = 101;\npub const MAP_GROWSDOWN: ::c_int = 0x0100;\npub const MAP_ANON: ::c_int = 0x0020;\npub const MAP_ANONYMOUS: ::c_int = 0x0020;\npub const MAP_DENYWRITE: ::c_int = 0x0800;\npub const MAP_EXECUTABLE: ::c_int = 0x01000;\npub const MAP_POPULATE: ::c_int = 0x08000;\npub const MAP_NONBLOCK: ::c_int = 0x010000;\npub const MAP_STACK: ::c_int = 0x020000;\npub const MAP_HUGETLB: ::c_int = 0x040000;\n\npub const EDEADLK: ::c_int = 35;\npub const ENAMETOOLONG: ::c_int = 36;\npub const ENOLCK: ::c_int = 37;\npub const ENOSYS: ::c_int = 38;\npub const ENOTEMPTY: ::c_int = 39;\npub const ELOOP: ::c_int = 40;\npub const ENOMSG: ::c_int = 42;\npub const EIDRM: ::c_int = 43;\npub const ECHRNG: ::c_int = 44;\npub const EL2NSYNC: ::c_int = 45;\npub const EL3HLT: ::c_int = 46;\npub const EL3RST: ::c_int = 47;\npub const ELNRNG: ::c_int = 48;\npub const EUNATCH: ::c_int = 49;\npub const ENOCSI: ::c_int = 50;\npub const EL2HLT: ::c_int = 51;\npub const EBADE: ::c_int = 52;\npub const EBADR: ::c_int = 53;\npub const EXFULL: ::c_int = 54;\npub const ENOANO: ::c_int = 55;\npub const EBADRQC: ::c_int = 56;\npub const EBADSLT: ::c_int = 57;\npub const EMULTIHOP: ::c_int = 72;\npub const EOVERFLOW: ::c_int = 75;\npub const ENOTUNIQ: ::c_int = 76;\npub const EBADFD: ::c_int = 77;\npub const EBADMSG: ::c_int = 74;\npub const EREMCHG: ::c_int = 78;\npub const ELIBACC: ::c_int = 79;\npub const ELIBBAD: ::c_int = 80;\npub const ELIBSCN: ::c_int = 81;\npub const ELIBMAX: ::c_int = 82;\npub const ELIBEXEC: ::c_int = 83;\npub const EILSEQ: ::c_int = 84;\npub const ERESTART: ::c_int = 85;\npub const ESTRPIPE: ::c_int = 86;\npub const EUSERS: ::c_int = 87;\npub const ENOTSOCK: ::c_int = 88;\npub const EDESTADDRREQ: ::c_int = 89;\npub const EMSGSIZE: ::c_int = 90;\npub const EPROTOTYPE: ::c_int = 91;\npub const ENOPROTOOPT: ::c_int = 92;\npub const EPROTONOSUPPORT: ::c_int = 93;\npub const ESOCKTNOSUPPORT: ::c_int = 94;\npub const EOPNOTSUPP: ::c_int = 95;\npub const EPFNOSUPPORT: ::c_int = 96;\npub const EAFNOSUPPORT: ::c_int = 97;\npub const EADDRINUSE: ::c_int = 98;\npub const EADDRNOTAVAIL: ::c_int = 99;\npub const ENETDOWN: ::c_int = 100;\npub const ENETUNREACH: ::c_int = 101;\npub const ENETRESET: ::c_int = 102;\npub const ECONNABORTED: ::c_int = 103;\npub const ECONNRESET: ::c_int = 104;\npub const ENOBUFS: ::c_int = 105;\npub const EISCONN: ::c_int = 106;\npub const ENOTCONN: ::c_int = 107;\npub const ESHUTDOWN: ::c_int = 108;\npub const ETOOMANYREFS: ::c_int = 109;\npub const ETIMEDOUT: ::c_int = 110;\npub const ECONNREFUSED: ::c_int = 111;\npub const EHOSTDOWN: ::c_int = 112;\npub const EHOSTUNREACH: ::c_int = 113;\npub const EALREADY: ::c_int = 114;\npub const EINPROGRESS: ::c_int = 115;\npub const ESTALE: ::c_int = 116;\npub const EDQUOT: ::c_int = 122;\npub const ENOMEDIUM: ::c_int = 123;\npub const EMEDIUMTYPE: ::c_int = 124;\npub const ECANCELED: ::c_int = 125;\npub const ENOKEY: ::c_int = 126;\npub const EKEYEXPIRED: ::c_int = 127;\npub const EKEYREVOKED: ::c_int = 128;\npub const EKEYREJECTED: ::c_int = 129;\npub const EOWNERDEAD: ::c_int = 130;\npub const ENOTRECOVERABLE: ::c_int = 131;\npub const EHWPOISON: ::c_int = 133;\npub const ERFKILL: ::c_int = 132;\n\npub const SOCK_STREAM: ::c_int = 1;\npub const SOCK_DGRAM: ::c_int = 2;\n\npub const SA_ONSTACK: ::c_int = 0x08000000;\npub const SA_SIGINFO: ::c_int = 0x00000004;\npub const SA_NOCLDWAIT: ::c_int = 0x00000002;\n\npub const SIGTTIN: ::c_int = 21;\npub const SIGTTOU: ::c_int = 22;\npub const SIGXCPU: ::c_int = 24;\npub const SIGXFSZ: ::c_int = 25;\npub const SIGVTALRM: ::c_int = 26;\npub const SIGPROF: ::c_int = 27;\npub const SIGWINCH: ::c_int = 28;\npub const SIGCHLD: ::c_int = 17;\npub const SIGBUS: ::c_int = 7;\npub const SIGUSR1: ::c_int = 10;\npub const SIGUSR2: ::c_int = 12;\npub const SIGCONT: ::c_int = 18;\npub const SIGSTOP: ::c_int = 19;\npub const SIGTSTP: ::c_int = 20;\npub const SIGURG: ::c_int = 23;\npub const SIGIO: ::c_int = 29;\npub const SIGSYS: ::c_int = 31;\npub const SIGSTKFLT: ::c_int = 16;\n#[deprecated(since = \"0.2.55\", note = \"Use SIGSYS instead\")]\npub const SIGUNUSED: ::c_int = 31;\npub const SIGPOLL: ::c_int = 29;\npub const SIGPWR: ::c_int = 30;\npub const SIG_SETMASK: ::c_int = 2;\npub const SIG_BLOCK: ::c_int = 0x000000;\npub const SIG_UNBLOCK: ::c_int = 0x01;\n\npub const POLLWRNORM: ::c_short = 0x100;\npub const POLLWRBAND: ::c_short = 0x200;\n\npub const O_ASYNC: ::c_int = 0x2000;\npub const O_NDELAY: ::c_int = 0x800;\n\npub const PTRACE_DETACH: ::c_uint = 17;\n\npub const EFD_NONBLOCK: ::c_int = 0x800;\n\npub const F_GETLK: ::c_int = 5;\npub const F_GETOWN: ::c_int = 9;\npub const F_SETOWN: ::c_int = 8;\npub const F_SETLK: ::c_int = 6;\npub const F_SETLKW: ::c_int = 7;\npub const F_OFD_GETLK: ::c_int = 36;\npub const F_OFD_SETLK: ::c_int = 37;\npub const F_OFD_SETLKW: ::c_int = 38;\n\npub const F_RDLCK: ::c_int = 0;\npub const F_WRLCK: ::c_int = 1;\npub const F_UNLCK: ::c_int = 2;\n\npub const SFD_NONBLOCK: ::c_int = 0x0800;\n\npub const TCSANOW: ::c_int = 0;\npub const TCSADRAIN: ::c_int = 1;\npub const TCSAFLUSH: ::c_int = 2;\n\npub const TIOCLINUX: ::c_ulong = 0x541C;\npub const TIOCGSERIAL: ::c_ulong = 0x541E;\npub const TIOCEXCL: ::c_ulong = 0x540C;\npub const TIOCNXCL: ::c_ulong = 0x540D;\npub const TIOCSCTTY: ::c_ulong = 0x540E;\npub const TIOCSTI: ::c_ulong = 0x5412;\npub const TIOCMGET: ::c_ulong = 0x5415;\npub const TIOCMBIS: ::c_ulong = 0x5416;\npub const TIOCMBIC: ::c_ulong = 0x5417;\npub const TIOCMSET: ::c_ulong = 0x5418;\npub const TIOCCONS: ::c_ulong = 0x541D;\npub const TIOCSBRK: ::c_ulong = 0x5427;\npub const TIOCCBRK: ::c_ulong = 0x5428;\npub const TIOCGRS485: ::c_int = 0x542E;\npub const TIOCSRS485: ::c_int = 0x542F;\n\npub const TIOCM_ST: ::c_int = 0x008;\npub const TIOCM_SR: ::c_int = 0x010;\npub const TIOCM_CTS: ::c_int = 0x020;\npub const TIOCM_CAR: ::c_int = 0x040;\npub const TIOCM_RNG: ::c_int = 0x080;\npub const TIOCM_DSR: ::c_int = 0x100;\n\npub const SFD_CLOEXEC: ::c_int = 0x080000;\n\npub const NCCS: usize = 32;\n\npub const O_TRUNC: ::c_int = 512;\n\npub const O_CLOEXEC: ::c_int = 0x80000;\n\npub const EBFONT: ::c_int = 59;\npub const ENOSTR: ::c_int = 60;\npub const ENODATA: ::c_int = 61;\npub const ETIME: ::c_int = 62;\npub const ENOSR: ::c_int = 63;\npub const ENONET: ::c_int = 64;\npub const ENOPKG: ::c_int = 65;\npub const EREMOTE: ::c_int = 66;\npub const ENOLINK: ::c_int = 67;\npub const EADV: ::c_int = 68;\npub const ESRMNT: ::c_int = 69;\npub const ECOMM: ::c_int = 70;\npub const EPROTO: ::c_int = 71;\npub const EDOTDOT: ::c_int = 73;\n\npub const SA_NODEFER: ::c_int = 0x40000000;\npub const SA_RESETHAND: ::c_int = 0x80000000;\npub const SA_RESTART: ::c_int = 0x10000000;\npub const SA_NOCLDSTOP: ::c_int = 0x00000001;\n\npub const EPOLL_CLOEXEC: ::c_int = 0x80000;\n\npub const EFD_CLOEXEC: ::c_int = 0x80000;\n\npub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;\npub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;\npub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;\n\nalign_const! {\n    #[cfg(target_endian = \"little\")]\n    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"little\")]\n    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"little\")]\n    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"big\")]\n    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"big\")]\n    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"big\")]\n    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n}\n\npub const O_DIRECTORY: ::c_int = 0x4000;\npub const O_NOFOLLOW: ::c_int = 0x8000;\npub const O_DIRECT: ::c_int = 0x20000;\n\npub const MAP_LOCKED: ::c_int = 0x00080;\npub const MAP_NORESERVE: ::c_int = 0x00040;\npub const MAP_SYNC: ::c_int = 0x080000;\n\npub const EDEADLOCK: ::c_int = 58;\npub const EUCLEAN: ::c_int = 117;\npub const ENOTNAM: ::c_int = 118;\npub const ENAVAIL: ::c_int = 119;\npub const EISNAM: ::c_int = 120;\npub const EREMOTEIO: ::c_int = 121;\n\npub const FIOCLEX: ::c_ulong = 0x20006601;\npub const FIONCLEX: ::c_ulong = 0x20006602;\npub const FIONBIO: ::c_ulong = 0x8004667e;\n\npub const MCL_CURRENT: ::c_int = 0x2000;\npub const MCL_FUTURE: ::c_int = 0x4000;\n\npub const SIGSTKSZ: ::size_t = 0x4000;\npub const MINSIGSTKSZ: ::size_t = 4096;\npub const CBAUD: ::tcflag_t = 0xff;\npub const TAB1: ::tcflag_t = 0x400;\npub const TAB2: ::tcflag_t = 0x800;\npub const TAB3: ::tcflag_t = 0xc00;\npub const CR1: ::tcflag_t = 0x1000;\npub const CR2: ::tcflag_t = 0x2000;\npub const CR3: ::tcflag_t = 0x3000;\npub const FF1: ::tcflag_t = 0x4000;\npub const BS1: ::tcflag_t = 0x8000;\npub const VT1: ::tcflag_t = 0x10000;\npub const VWERASE: usize = 0xa;\npub const VREPRINT: usize = 0xb;\npub const VSUSP: usize = 0xc;\npub const VSTART: usize = 0xd;\npub const VSTOP: usize = 0xe;\npub const VDISCARD: usize = 0x10;\npub const VTIME: usize = 0x7;\npub const IXON: ::tcflag_t = 0x200;\npub const IXOFF: ::tcflag_t = 0x400;\npub const ONLCR: ::tcflag_t = 0x2;\npub const CSIZE: ::tcflag_t = 0x300;\npub const CS6: ::tcflag_t = 0x100;\npub const CS7: ::tcflag_t = 0x200;\npub const CS8: ::tcflag_t = 0x300;\npub const CSTOPB: ::tcflag_t = 0x400;\npub const CREAD: ::tcflag_t = 0x800;\npub const PARENB: ::tcflag_t = 0x1000;\npub const PARODD: ::tcflag_t = 0x2000;\npub const HUPCL: ::tcflag_t = 0x4000;\npub const CLOCAL: ::tcflag_t = 0x8000;\npub const ECHOKE: ::tcflag_t = 0x1;\npub const ECHOE: ::tcflag_t = 0x2;\npub const ECHOK: ::tcflag_t = 0x4;\npub const ECHONL: ::tcflag_t = 0x10;\npub const ECHOPRT: ::tcflag_t = 0x20;\npub const ECHOCTL: ::tcflag_t = 0x40;\npub const ISIG: ::tcflag_t = 0x80;\npub const ICANON: ::tcflag_t = 0x100;\npub const PENDIN: ::tcflag_t = 0x20000000;\npub const NOFLSH: ::tcflag_t = 0x80000000;\npub const VSWTC: usize = 9;\npub const OLCUC: ::tcflag_t = 0o000004;\npub const NLDLY: ::tcflag_t = 0o001400;\npub const CRDLY: ::tcflag_t = 0o030000;\npub const TABDLY: ::tcflag_t = 0o006000;\npub const BSDLY: ::tcflag_t = 0o100000;\npub const FFDLY: ::tcflag_t = 0o040000;\npub const VTDLY: ::tcflag_t = 0o200000;\npub const XTABS: ::tcflag_t = 0o006000;\n\npub const B0: ::speed_t = 0o000000;\npub const B50: ::speed_t = 0o000001;\npub const B75: ::speed_t = 0o000002;\npub const B110: ::speed_t = 0o000003;\npub const B134: ::speed_t = 0o000004;\npub const B150: ::speed_t = 0o000005;\npub const B200: ::speed_t = 0o000006;\npub const B300: ::speed_t = 0o000007;\npub const B600: ::speed_t = 0o000010;\npub const B1200: ::speed_t = 0o000011;\npub const B1800: ::speed_t = 0o000012;\npub const B2400: ::speed_t = 0o000013;\npub const B4800: ::speed_t = 0o000014;\npub const B9600: ::speed_t = 0o000015;\npub const B19200: ::speed_t = 0o000016;\npub const B38400: ::speed_t = 0o000017;\npub const EXTA: ::speed_t = B19200;\npub const EXTB: ::speed_t = B38400;\npub const CBAUDEX: ::speed_t = 0o000020;\npub const B57600: ::speed_t = 0o0020;\npub const B115200: ::speed_t = 0o0021;\npub const B230400: ::speed_t = 0o0022;\npub const B460800: ::speed_t = 0o0023;\npub const B500000: ::speed_t = 0o0024;\npub const B576000: ::speed_t = 0o0025;\npub const B921600: ::speed_t = 0o0026;\npub const B1000000: ::speed_t = 0o0027;\npub const B1152000: ::speed_t = 0o0030;\npub const B1500000: ::speed_t = 0o0031;\npub const B2000000: ::speed_t = 0o0032;\npub const B2500000: ::speed_t = 0o0033;\npub const B3000000: ::speed_t = 0o0034;\npub const B3500000: ::speed_t = 0o0035;\npub const B4000000: ::speed_t = 0o0036;\npub const BOTHER: ::speed_t = 0o0037;\n\npub const VEOL: usize = 6;\npub const VEOL2: usize = 8;\npub const VMIN: usize = 5;\npub const IEXTEN: ::tcflag_t = 0x400;\npub const TOSTOP: ::tcflag_t = 0x400000;\npub const FLUSHO: ::tcflag_t = 0x800000;\npub const EXTPROC: ::tcflag_t = 0x10000000;\npub const TCGETS: ::c_ulong = 0x403c7413;\npub const TCSETS: ::c_ulong = 0x803c7414;\npub const TCSETSW: ::c_ulong = 0x803c7415;\npub const TCSETSF: ::c_ulong = 0x803c7416;\npub const TCGETA: ::c_ulong = 0x40147417;\npub const TCSETA: ::c_ulong = 0x80147418;\npub const TCSETAW: ::c_ulong = 0x80147419;\npub const TCSETAF: ::c_ulong = 0x8014741c;\npub const TCSBRK: ::c_ulong = 0x2000741d;\npub const TCXONC: ::c_ulong = 0x2000741e;\npub const TCFLSH: ::c_ulong = 0x2000741f;\npub const TIOCINQ: ::c_ulong = 0x4004667f;\npub const TIOCGPGRP: ::c_ulong = 0x40047477;\npub const TIOCSPGRP: ::c_ulong = 0x80047476;\npub const TIOCOUTQ: ::c_ulong = 0x40047473;\npub const TIOCGWINSZ: ::c_ulong = 0x40087468;\npub const TIOCSWINSZ: ::c_ulong = 0x80087467;\npub const FIONREAD: ::c_ulong = 0x4004667f;\n\n// Syscall table\npub const SYS_restart_syscall: ::c_long = 0;\npub const SYS_exit: ::c_long = 1;\npub const SYS_fork: ::c_long = 2;\npub const SYS_read: ::c_long = 3;\npub const SYS_write: ::c_long = 4;\npub const SYS_open: ::c_long = 5;\npub const SYS_close: ::c_long = 6;\npub const SYS_waitpid: ::c_long = 7;\npub const SYS_creat: ::c_long = 8;\npub const SYS_link: ::c_long = 9;\npub const SYS_unlink: ::c_long = 10;\npub const SYS_execve: ::c_long = 11;\npub const SYS_chdir: ::c_long = 12;\npub const SYS_time: ::c_long = 13;\npub const SYS_mknod: ::c_long = 14;\npub const SYS_chmod: ::c_long = 15;\npub const SYS_lchown: ::c_long = 16;\npub const SYS_break: ::c_long = 17;\npub const SYS_oldstat: ::c_long = 18;\npub const SYS_lseek: ::c_long = 19;\npub const SYS_getpid: ::c_long = 20;\npub const SYS_mount: ::c_long = 21;\npub const SYS_umount: ::c_long = 22;\npub const SYS_setuid: ::c_long = 23;\npub const SYS_getuid: ::c_long = 24;\npub const SYS_stime: ::c_long = 25;\npub const SYS_ptrace: ::c_long = 26;\npub const SYS_alarm: ::c_long = 27;\npub const SYS_oldfstat: ::c_long = 28;\npub const SYS_pause: ::c_long = 29;\npub const SYS_utime: ::c_long = 30;\npub const SYS_stty: ::c_long = 31;\npub const SYS_gtty: ::c_long = 32;\npub const SYS_access: ::c_long = 33;\npub const SYS_nice: ::c_long = 34;\npub const SYS_ftime: ::c_long = 35;\npub const SYS_sync: ::c_long = 36;\npub const SYS_kill: ::c_long = 37;\npub const SYS_rename: ::c_long = 38;\npub const SYS_mkdir: ::c_long = 39;\npub const SYS_rmdir: ::c_long = 40;\npub const SYS_dup: ::c_long = 41;\npub const SYS_pipe: ::c_long = 42;\npub const SYS_times: ::c_long = 43;\npub const SYS_prof: ::c_long = 44;\npub const SYS_brk: ::c_long = 45;\npub const SYS_setgid: ::c_long = 46;\npub const SYS_getgid: ::c_long = 47;\npub const SYS_signal: ::c_long = 48;\npub const SYS_geteuid: ::c_long = 49;\npub const SYS_getegid: ::c_long = 50;\npub const SYS_acct: ::c_long = 51;\npub const SYS_umount2: ::c_long = 52;\npub const SYS_lock: ::c_long = 53;\npub const SYS_ioctl: ::c_long = 54;\npub const SYS_fcntl: ::c_long = 55;\npub const SYS_mpx: ::c_long = 56;\npub const SYS_setpgid: ::c_long = 57;\npub const SYS_ulimit: ::c_long = 58;\npub const SYS_oldolduname: ::c_long = 59;\npub const SYS_umask: ::c_long = 60;\npub const SYS_chroot: ::c_long = 61;\npub const SYS_ustat: ::c_long = 62;\npub const SYS_dup2: ::c_long = 63;\npub const SYS_getppid: ::c_long = 64;\npub const SYS_getpgrp: ::c_long = 65;\npub const SYS_setsid: ::c_long = 66;\npub const SYS_sigaction: ::c_long = 67;\npub const SYS_sgetmask: ::c_long = 68;\npub const SYS_ssetmask: ::c_long = 69;\npub const SYS_setreuid: ::c_long = 70;\npub const SYS_setregid: ::c_long = 71;\npub const SYS_sigsuspend: ::c_long = 72;\npub const SYS_sigpending: ::c_long = 73;\npub const SYS_sethostname: ::c_long = 74;\npub const SYS_setrlimit: ::c_long = 75;\npub const SYS_getrlimit: ::c_long = 76;\npub const SYS_getrusage: ::c_long = 77;\npub const SYS_gettimeofday: ::c_long = 78;\npub const SYS_settimeofday: ::c_long = 79;\npub const SYS_getgroups: ::c_long = 80;\npub const SYS_setgroups: ::c_long = 81;\npub const SYS_select: ::c_long = 82;\npub const SYS_symlink: ::c_long = 83;\npub const SYS_oldlstat: ::c_long = 84;\npub const SYS_readlink: ::c_long = 85;\npub const SYS_uselib: ::c_long = 86;\npub const SYS_swapon: ::c_long = 87;\npub const SYS_reboot: ::c_long = 88;\npub const SYS_readdir: ::c_long = 89;\npub const SYS_mmap: ::c_long = 90;\npub const SYS_munmap: ::c_long = 91;\npub const SYS_truncate: ::c_long = 92;\npub const SYS_ftruncate: ::c_long = 93;\npub const SYS_fchmod: ::c_long = 94;\npub const SYS_fchown: ::c_long = 95;\npub const SYS_getpriority: ::c_long = 96;\npub const SYS_setpriority: ::c_long = 97;\npub const SYS_profil: ::c_long = 98;\npub const SYS_statfs: ::c_long = 99;\npub const SYS_fstatfs: ::c_long = 100;\npub const SYS_ioperm: ::c_long = 101;\npub const SYS_socketcall: ::c_long = 102;\npub const SYS_syslog: ::c_long = 103;\npub const SYS_setitimer: ::c_long = 104;\npub const SYS_getitimer: ::c_long = 105;\npub const SYS_stat: ::c_long = 106;\npub const SYS_lstat: ::c_long = 107;\npub const SYS_fstat: ::c_long = 108;\npub const SYS_olduname: ::c_long = 109;\npub const SYS_iopl: ::c_long = 110;\npub const SYS_vhangup: ::c_long = 111;\npub const SYS_idle: ::c_long = 112;\npub const SYS_vm86: ::c_long = 113;\npub const SYS_wait4: ::c_long = 114;\npub const SYS_swapoff: ::c_long = 115;\npub const SYS_sysinfo: ::c_long = 116;\npub const SYS_ipc: ::c_long = 117;\npub const SYS_fsync: ::c_long = 118;\npub const SYS_sigreturn: ::c_long = 119;\npub const SYS_clone: ::c_long = 120;\npub const SYS_setdomainname: ::c_long = 121;\npub const SYS_uname: ::c_long = 122;\npub const SYS_modify_ldt: ::c_long = 123;\npub const SYS_adjtimex: ::c_long = 124;\npub const SYS_mprotect: ::c_long = 125;\npub const SYS_sigprocmask: ::c_long = 126;\npub const SYS_create_module: ::c_long = 127;\npub const SYS_init_module: ::c_long = 128;\npub const SYS_delete_module: ::c_long = 129;\npub const SYS_get_kernel_syms: ::c_long = 130;\npub const SYS_quotactl: ::c_long = 131;\npub const SYS_getpgid: ::c_long = 132;\npub const SYS_fchdir: ::c_long = 133;\npub const SYS_bdflush: ::c_long = 134;\npub const SYS_sysfs: ::c_long = 135;\npub const SYS_personality: ::c_long = 136;\npub const SYS_afs_syscall: ::c_long = 137; /* Syscall for Andrew File System */\npub const SYS_setfsuid: ::c_long = 138;\npub const SYS_setfsgid: ::c_long = 139;\npub const SYS__llseek: ::c_long = 140;\npub const SYS_getdents: ::c_long = 141;\npub const SYS__newselect: ::c_long = 142;\npub const SYS_flock: ::c_long = 143;\npub const SYS_msync: ::c_long = 144;\npub const SYS_readv: ::c_long = 145;\npub const SYS_writev: ::c_long = 146;\npub const SYS_getsid: ::c_long = 147;\npub const SYS_fdatasync: ::c_long = 148;\npub const SYS__sysctl: ::c_long = 149;\npub const SYS_mlock: ::c_long = 150;\npub const SYS_munlock: ::c_long = 151;\npub const SYS_mlockall: ::c_long = 152;\npub const SYS_munlockall: ::c_long = 153;\npub const SYS_sched_setparam: ::c_long = 154;\npub const SYS_sched_getparam: ::c_long = 155;\npub const SYS_sched_setscheduler: ::c_long = 156;\npub const SYS_sched_getscheduler: ::c_long = 157;\npub const SYS_sched_yield: ::c_long = 158;\npub const SYS_sched_get_priority_max: ::c_long = 159;\npub const SYS_sched_get_priority_min: ::c_long = 160;\npub const SYS_sched_rr_get_interval: ::c_long = 161;\npub const SYS_nanosleep: ::c_long = 162;\npub const SYS_mremap: ::c_long = 163;\npub const SYS_setresuid: ::c_long = 164;\npub const SYS_getresuid: ::c_long = 165;\npub const SYS_query_module: ::c_long = 166;\npub const SYS_poll: ::c_long = 167;\npub const SYS_nfsservctl: ::c_long = 168;\npub const SYS_setresgid: ::c_long = 169;\npub const SYS_getresgid: ::c_long = 170;\npub const SYS_prctl: ::c_long = 171;\npub const SYS_rt_sigreturn: ::c_long = 172;\npub const SYS_rt_sigaction: ::c_long = 173;\npub const SYS_rt_sigprocmask: ::c_long = 174;\npub const SYS_rt_sigpending: ::c_long = 175;\npub const SYS_rt_sigtimedwait: ::c_long = 176;\npub const SYS_rt_sigqueueinfo: ::c_long = 177;\npub const SYS_rt_sigsuspend: ::c_long = 178;\npub const SYS_pread64: ::c_long = 179;\npub const SYS_pwrite64: ::c_long = 180;\npub const SYS_chown: ::c_long = 181;\npub const SYS_getcwd: ::c_long = 182;\npub const SYS_capget: ::c_long = 183;\npub const SYS_capset: ::c_long = 184;\npub const SYS_sigaltstack: ::c_long = 185;\npub const SYS_sendfile: ::c_long = 186;\npub const SYS_getpmsg: ::c_long = 187; /* some people actually want streams */\npub const SYS_putpmsg: ::c_long = 188; /* some people actually want streams */\npub const SYS_vfork: ::c_long = 189;\npub const SYS_ugetrlimit: ::c_long = 190; /* SuS compliant getrlimit */\npub const SYS_readahead: ::c_long = 191;\npub const SYS_pciconfig_read: ::c_long = 198;\npub const SYS_pciconfig_write: ::c_long = 199;\npub const SYS_pciconfig_iobase: ::c_long = 200;\npub const SYS_multiplexer: ::c_long = 201;\npub const SYS_getdents64: ::c_long = 202;\npub const SYS_pivot_root: ::c_long = 203;\npub const SYS_madvise: ::c_long = 205;\npub const SYS_mincore: ::c_long = 206;\npub const SYS_gettid: ::c_long = 207;\npub const SYS_tkill: ::c_long = 208;\npub const SYS_setxattr: ::c_long = 209;\npub const SYS_lsetxattr: ::c_long = 210;\npub const SYS_fsetxattr: ::c_long = 211;\npub const SYS_getxattr: ::c_long = 212;\npub const SYS_lgetxattr: ::c_long = 213;\npub const SYS_fgetxattr: ::c_long = 214;\npub const SYS_listxattr: ::c_long = 215;\npub const SYS_llistxattr: ::c_long = 216;\npub const SYS_flistxattr: ::c_long = 217;\npub const SYS_removexattr: ::c_long = 218;\npub const SYS_lremovexattr: ::c_long = 219;\npub const SYS_fremovexattr: ::c_long = 220;\npub const SYS_futex: ::c_long = 221;\npub const SYS_sched_setaffinity: ::c_long = 222;\npub const SYS_sched_getaffinity: ::c_long = 223;\npub const SYS_tuxcall: ::c_long = 225;\npub const SYS_io_setup: ::c_long = 227;\npub const SYS_io_destroy: ::c_long = 228;\npub const SYS_io_getevents: ::c_long = 229;\npub const SYS_io_submit: ::c_long = 230;\npub const SYS_io_cancel: ::c_long = 231;\npub const SYS_set_tid_address: ::c_long = 232;\npub const SYS_exit_group: ::c_long = 234;\npub const SYS_lookup_dcookie: ::c_long = 235;\npub const SYS_epoll_create: ::c_long = 236;\npub const SYS_epoll_ctl: ::c_long = 237;\npub const SYS_epoll_wait: ::c_long = 238;\npub const SYS_remap_file_pages: ::c_long = 239;\npub const SYS_timer_create: ::c_long = 240;\npub const SYS_timer_settime: ::c_long = 241;\npub const SYS_timer_gettime: ::c_long = 242;\npub const SYS_timer_getoverrun: ::c_long = 243;\npub const SYS_timer_delete: ::c_long = 244;\npub const SYS_clock_settime: ::c_long = 245;\npub const SYS_clock_gettime: ::c_long = 246;\npub const SYS_clock_getres: ::c_long = 247;\npub const SYS_clock_nanosleep: ::c_long = 248;\npub const SYS_swapcontext: ::c_long = 249;\npub const SYS_tgkill: ::c_long = 250;\npub const SYS_utimes: ::c_long = 251;\npub const SYS_statfs64: ::c_long = 252;\npub const SYS_fstatfs64: ::c_long = 253;\npub const SYS_rtas: ::c_long = 255;\npub const SYS_sys_debug_setcontext: ::c_long = 256;\npub const SYS_migrate_pages: ::c_long = 258;\npub const SYS_mbind: ::c_long = 259;\npub const SYS_get_mempolicy: ::c_long = 260;\npub const SYS_set_mempolicy: ::c_long = 261;\npub const SYS_mq_open: ::c_long = 262;\npub const SYS_mq_unlink: ::c_long = 263;\npub const SYS_mq_timedsend: ::c_long = 264;\npub const SYS_mq_timedreceive: ::c_long = 265;\npub const SYS_mq_notify: ::c_long = 266;\npub const SYS_mq_getsetattr: ::c_long = 267;\npub const SYS_kexec_load: ::c_long = 268;\npub const SYS_add_key: ::c_long = 269;\npub const SYS_request_key: ::c_long = 270;\npub const SYS_keyctl: ::c_long = 271;\npub const SYS_waitid: ::c_long = 272;\npub const SYS_ioprio_set: ::c_long = 273;\npub const SYS_ioprio_get: ::c_long = 274;\npub const SYS_inotify_init: ::c_long = 275;\npub const SYS_inotify_add_watch: ::c_long = 276;\npub const SYS_inotify_rm_watch: ::c_long = 277;\npub const SYS_spu_run: ::c_long = 278;\npub const SYS_spu_create: ::c_long = 279;\npub const SYS_pselect6: ::c_long = 280;\npub const SYS_ppoll: ::c_long = 281;\npub const SYS_unshare: ::c_long = 282;\npub const SYS_splice: ::c_long = 283;\npub const SYS_tee: ::c_long = 284;\npub const SYS_vmsplice: ::c_long = 285;\npub const SYS_openat: ::c_long = 286;\npub const SYS_mkdirat: ::c_long = 287;\npub const SYS_mknodat: ::c_long = 288;\npub const SYS_fchownat: ::c_long = 289;\npub const SYS_futimesat: ::c_long = 290;\npub const SYS_newfstatat: ::c_long = 291;\npub const SYS_unlinkat: ::c_long = 292;\npub const SYS_renameat: ::c_long = 293;\npub const SYS_linkat: ::c_long = 294;\npub const SYS_symlinkat: ::c_long = 295;\npub const SYS_readlinkat: ::c_long = 296;\npub const SYS_fchmodat: ::c_long = 297;\npub const SYS_faccessat: ::c_long = 298;\npub const SYS_get_robust_list: ::c_long = 299;\npub const SYS_set_robust_list: ::c_long = 300;\npub const SYS_move_pages: ::c_long = 301;\npub const SYS_getcpu: ::c_long = 302;\npub const SYS_epoll_pwait: ::c_long = 303;\npub const SYS_utimensat: ::c_long = 304;\npub const SYS_signalfd: ::c_long = 305;\npub const SYS_timerfd_create: ::c_long = 306;\npub const SYS_eventfd: ::c_long = 307;\npub const SYS_sync_file_range2: ::c_long = 308;\npub const SYS_fallocate: ::c_long = 309;\npub const SYS_subpage_prot: ::c_long = 310;\npub const SYS_timerfd_settime: ::c_long = 311;\npub const SYS_timerfd_gettime: ::c_long = 312;\npub const SYS_signalfd4: ::c_long = 313;\npub const SYS_eventfd2: ::c_long = 314;\npub const SYS_epoll_create1: ::c_long = 315;\npub const SYS_dup3: ::c_long = 316;\npub const SYS_pipe2: ::c_long = 317;\npub const SYS_inotify_init1: ::c_long = 318;\npub const SYS_perf_event_open: ::c_long = 319;\npub const SYS_preadv: ::c_long = 320;\npub const SYS_pwritev: ::c_long = 321;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 322;\npub const SYS_fanotify_init: ::c_long = 323;\npub const SYS_fanotify_mark: ::c_long = 324;\npub const SYS_prlimit64: ::c_long = 325;\npub const SYS_socket: ::c_long = 326;\npub const SYS_bind: ::c_long = 327;\npub const SYS_connect: ::c_long = 328;\npub const SYS_listen: ::c_long = 329;\npub const SYS_accept: ::c_long = 330;\npub const SYS_getsockname: ::c_long = 331;\npub const SYS_getpeername: ::c_long = 332;\npub const SYS_socketpair: ::c_long = 333;\npub const SYS_send: ::c_long = 334;\npub const SYS_sendto: ::c_long = 335;\npub const SYS_recv: ::c_long = 336;\npub const SYS_recvfrom: ::c_long = 337;\npub const SYS_shutdown: ::c_long = 338;\npub const SYS_setsockopt: ::c_long = 339;\npub const SYS_getsockopt: ::c_long = 340;\npub const SYS_sendmsg: ::c_long = 341;\npub const SYS_recvmsg: ::c_long = 342;\npub const SYS_recvmmsg: ::c_long = 343;\npub const SYS_accept4: ::c_long = 344;\npub const SYS_name_to_handle_at: ::c_long = 345;\npub const SYS_open_by_handle_at: ::c_long = 346;\npub const SYS_clock_adjtime: ::c_long = 347;\npub const SYS_syncfs: ::c_long = 348;\npub const SYS_sendmmsg: ::c_long = 349;\npub const SYS_setns: ::c_long = 350;\npub const SYS_process_vm_readv: ::c_long = 351;\npub const SYS_process_vm_writev: ::c_long = 352;\npub const SYS_finit_module: ::c_long = 353;\npub const SYS_kcmp: ::c_long = 354;\npub const SYS_sched_setattr: ::c_long = 355;\npub const SYS_sched_getattr: ::c_long = 356;\npub const SYS_renameat2: ::c_long = 357;\npub const SYS_seccomp: ::c_long = 358;\npub const SYS_getrandom: ::c_long = 359;\npub const SYS_memfd_create: ::c_long = 360;\npub const SYS_bpf: ::c_long = 361;\npub const SYS_execveat: ::c_long = 362;\npub const SYS_switch_endian: ::c_long = 363;\npub const SYS_userfaultfd: ::c_long = 364;\npub const SYS_membarrier: ::c_long = 365;\npub const SYS_mlock2: ::c_long = 378;\npub const SYS_copy_file_range: ::c_long = 379;\npub const SYS_preadv2: ::c_long = 380;\npub const SYS_pwritev2: ::c_long = 381;\npub const SYS_kexec_file_load: ::c_long = 382;\npub const SYS_statx: ::c_long = 383;\npub const SYS_pidfd_send_signal: ::c_long = 424;\npub const SYS_io_uring_setup: ::c_long = 425;\npub const SYS_io_uring_enter: ::c_long = 426;\npub const SYS_io_uring_register: ::c_long = 427;\npub const SYS_open_tree: ::c_long = 428;\npub const SYS_move_mount: ::c_long = 429;\npub const SYS_fsopen: ::c_long = 430;\npub const SYS_fsconfig: ::c_long = 431;\npub const SYS_fsmount: ::c_long = 432;\npub const SYS_fspick: ::c_long = 433;\npub const SYS_pidfd_open: ::c_long = 434;\npub const SYS_clone3: ::c_long = 435;\npub const SYS_close_range: ::c_long = 436;\npub const SYS_openat2: ::c_long = 437;\npub const SYS_pidfd_getfd: ::c_long = 438;\npub const SYS_faccessat2: ::c_long = 439;\npub const SYS_process_madvise: ::c_long = 440;\npub const SYS_epoll_pwait2: ::c_long = 441;\npub const SYS_mount_setattr: ::c_long = 442;\n\nextern \"C\" {\n    pub fn sysctl(\n        name: *mut ::c_int,\n        namelen: ::c_int,\n        oldp: *mut ::c_void,\n        oldlenp: *mut ::size_t,\n        newp: *mut ::c_void,\n        newlen: ::size_t,\n    ) -> ::c_int;\n}\n\ncfg_if! {\n    if #[cfg(libc_align)] {\n        mod align;\n        pub use self::align::*;\n    }\n}\n"],["1176","s_no_extra_traits! {\n    #[allow(missing_debug_implementations)]\n    #[repr(align(16))]\n    pub struct max_align_t {\n        priv_: [i64; 4]\n    }\n}\n"],["1177","//! RISC-V-specific definitions for 64-bit linux-like values\n\npub type c_char = u8;\npub type c_long = i64;\npub type c_ulong = u64;\npub type wchar_t = ::c_int;\n\npub type nlink_t = ::c_uint;\npub type blksize_t = ::c_int;\npub type fsblkcnt64_t = ::c_ulong;\npub type fsfilcnt64_t = ::c_ulong;\npub type suseconds_t = i64;\npub type __u64 = ::c_ulonglong;\n\ns! {\n    pub struct pthread_attr_t {\n        __size: [::c_ulong; 7],\n    }\n\n    pub struct stat {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        pub __pad1: ::dev_t,\n        pub st_size: ::off_t,\n        pub st_blksize: ::blksize_t,\n        pub __pad2: ::c_int,\n        pub st_blocks: ::blkcnt_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __unused: [::c_int; 2usize],\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino64_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        pub __pad1: ::dev_t,\n        pub st_size: ::off64_t,\n        pub st_blksize: ::blksize_t,\n        pub __pad2: ::c_int,\n        pub st_blocks: ::blkcnt_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __unused: [::c_int; 2],\n    }\n\n    pub struct statfs {\n        pub f_type: ::c_long,\n        pub f_bsize: ::c_long,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_long,\n        pub f_frsize: ::c_long,\n        pub f_flags: ::c_long,\n        pub f_spare: [::c_long; 4],\n    }\n\n    pub struct statfs64 {\n        pub f_type: ::c_long,\n        pub f_bsize: ::c_long,\n        pub f_blocks: ::fsblkcnt64_t,\n        pub f_bfree: ::fsblkcnt64_t,\n        pub f_bavail: ::fsblkcnt64_t,\n        pub f_files: ::fsfilcnt64_t,\n        pub f_ffree: ::fsfilcnt64_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_long,\n        pub f_frsize: ::c_long,\n        pub f_flags: ::c_long,\n        pub f_spare: [::c_long; 4],\n    }\n\n    pub struct statvfs {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_favail: ::fsfilcnt_t,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        pub __f_spare: [::c_int; 6],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt64_t,\n        pub f_bfree: ::fsblkcnt64_t,\n        pub f_bavail: ::fsblkcnt64_t,\n        pub f_files: ::fsfilcnt64_t,\n        pub f_ffree: ::fsfilcnt64_t,\n        pub f_favail: ::fsfilcnt64_t,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        pub __f_spare: [::c_int; 6],\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_errno: ::c_int,\n        pub si_code: ::c_int,\n        #[doc(hidden)]\n        #[deprecated(\n            since=\"0.2.54\",\n            note=\"Please leave a comment on \\\n                  https://github.com/rust-lang/libc/pull/1316 if you're using \\\n                  this field\"\n        )]\n        pub _pad: [::c_int; 29],\n        _align: [u64; 0],\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_flags: ::c_int,\n        pub ss_size: ::size_t,\n    }\n\n    pub struct sigaction {\n        pub sa_sigaction: ::sighandler_t,\n        pub sa_mask: ::sigset_t,\n        pub sa_flags: ::c_int,\n        pub sa_restorer: ::Option<unsafe extern \"C\" fn()>,\n    }\n\n    pub struct ipc_perm {\n        pub __key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::c_ushort,\n        __pad1: ::c_ushort,\n        pub __seq: ::c_ushort,\n        __pad2: ::c_ushort,\n        __unused1: ::c_ulong,\n        __unused2: ::c_ulong,\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        pub shm_segsz: ::size_t,\n        pub shm_atime: ::time_t,\n        pub shm_dtime: ::time_t,\n        pub shm_ctime: ::time_t,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::shmatt_t,\n        __unused5: ::c_ulong,\n        __unused6: ::c_ulong,\n    }\n\n    pub struct flock {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off_t,\n        pub l_len: ::off_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct flock64 {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off64_t,\n        pub l_len: ::off64_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct ip_mreqn {\n        pub imr_multiaddr: ::in_addr,\n        pub imr_address: ::in_addr,\n        pub imr_ifindex: ::c_int,\n    }\n}\n\npub const POSIX_FADV_DONTNEED: ::c_int = 4;\npub const POSIX_FADV_NOREUSE: ::c_int = 5;\npub const VEOF: usize = 4;\npub const RTLD_DEEPBIND: ::c_int = 0x8;\npub const RTLD_GLOBAL: ::c_int = 0x100;\npub const RTLD_NOLOAD: ::c_int = 0x4;\npub const TIOCGSOFTCAR: ::c_ulong = 21529;\npub const TIOCSSOFTCAR: ::c_ulong = 21530;\npub const TIOCGRS485: ::c_int = 21550;\npub const TIOCSRS485: ::c_int = 21551;\npub const RLIMIT_RSS: ::__rlimit_resource_t = 5;\npub const RLIMIT_AS: ::__rlimit_resource_t = 9;\npub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 8;\npub const RLIMIT_NOFILE: ::__rlimit_resource_t = 7;\npub const RLIMIT_NPROC: ::__rlimit_resource_t = 6;\npub const O_APPEND: ::c_int = 1024;\npub const O_CREAT: ::c_int = 64;\npub const O_EXCL: ::c_int = 128;\npub const O_NOCTTY: ::c_int = 256;\npub const O_NONBLOCK: ::c_int = 2048;\npub const O_SYNC: ::c_int = 1052672;\npub const O_RSYNC: ::c_int = 1052672;\npub const O_DSYNC: ::c_int = 4096;\npub const O_FSYNC: ::c_int = 1052672;\npub const O_NOATIME: ::c_int = 262144;\npub const O_PATH: ::c_int = 2097152;\npub const O_TMPFILE: ::c_int = 4259840;\npub const MAP_GROWSDOWN: ::c_int = 256;\npub const EDEADLK: ::c_int = 35;\npub const ENAMETOOLONG: ::c_int = 36;\npub const ENOLCK: ::c_int = 37;\npub const ENOSYS: ::c_int = 38;\npub const ENOTEMPTY: ::c_int = 39;\npub const ELOOP: ::c_int = 40;\npub const ENOMSG: ::c_int = 42;\npub const EIDRM: ::c_int = 43;\npub const ECHRNG: ::c_int = 44;\npub const EL2NSYNC: ::c_int = 45;\npub const EL3HLT: ::c_int = 46;\npub const EL3RST: ::c_int = 47;\npub const ELNRNG: ::c_int = 48;\npub const EUNATCH: ::c_int = 49;\npub const ENOCSI: ::c_int = 50;\npub const EL2HLT: ::c_int = 51;\npub const EBADE: ::c_int = 52;\npub const EBADR: ::c_int = 53;\npub const EXFULL: ::c_int = 54;\npub const ENOANO: ::c_int = 55;\npub const EBADRQC: ::c_int = 56;\npub const EBADSLT: ::c_int = 57;\npub const EMULTIHOP: ::c_int = 72;\npub const EOVERFLOW: ::c_int = 75;\npub const ENOTUNIQ: ::c_int = 76;\npub const EBADFD: ::c_int = 77;\npub const EBADMSG: ::c_int = 74;\npub const EREMCHG: ::c_int = 78;\npub const ELIBACC: ::c_int = 79;\npub const ELIBBAD: ::c_int = 80;\npub const ELIBSCN: ::c_int = 81;\npub const ELIBMAX: ::c_int = 82;\npub const ELIBEXEC: ::c_int = 83;\npub const EILSEQ: ::c_int = 84;\npub const ERESTART: ::c_int = 85;\npub const ESTRPIPE: ::c_int = 86;\npub const EUSERS: ::c_int = 87;\npub const ENOTSOCK: ::c_int = 88;\npub const EDESTADDRREQ: ::c_int = 89;\npub const EMSGSIZE: ::c_int = 90;\npub const EPROTOTYPE: ::c_int = 91;\npub const ENOPROTOOPT: ::c_int = 92;\npub const EPROTONOSUPPORT: ::c_int = 93;\npub const ESOCKTNOSUPPORT: ::c_int = 94;\npub const EOPNOTSUPP: ::c_int = 95;\npub const EPFNOSUPPORT: ::c_int = 96;\npub const EAFNOSUPPORT: ::c_int = 97;\npub const EADDRINUSE: ::c_int = 98;\npub const EADDRNOTAVAIL: ::c_int = 99;\npub const ENETDOWN: ::c_int = 100;\npub const ENETUNREACH: ::c_int = 101;\npub const ENETRESET: ::c_int = 102;\npub const ECONNABORTED: ::c_int = 103;\npub const ECONNRESET: ::c_int = 104;\npub const ENOBUFS: ::c_int = 105;\npub const EISCONN: ::c_int = 106;\npub const ENOTCONN: ::c_int = 107;\npub const ESHUTDOWN: ::c_int = 108;\npub const ETOOMANYREFS: ::c_int = 109;\npub const ETIMEDOUT: ::c_int = 110;\npub const ECONNREFUSED: ::c_int = 111;\npub const EHOSTDOWN: ::c_int = 112;\npub const EHOSTUNREACH: ::c_int = 113;\npub const EALREADY: ::c_int = 114;\npub const EINPROGRESS: ::c_int = 115;\npub const ESTALE: ::c_int = 116;\npub const EDQUOT: ::c_int = 122;\npub const ENOMEDIUM: ::c_int = 123;\npub const EMEDIUMTYPE: ::c_int = 124;\npub const ECANCELED: ::c_int = 125;\npub const ENOKEY: ::c_int = 126;\npub const EKEYEXPIRED: ::c_int = 127;\npub const EKEYREVOKED: ::c_int = 128;\npub const EKEYREJECTED: ::c_int = 129;\npub const EOWNERDEAD: ::c_int = 130;\npub const ENOTRECOVERABLE: ::c_int = 131;\npub const EHWPOISON: ::c_int = 133;\npub const ERFKILL: ::c_int = 132;\n\npub const SOCK_STREAM: ::c_int = 1;\npub const SOCK_DGRAM: ::c_int = 2;\npub const SA_ONSTACK: ::c_int = 134217728;\npub const SA_SIGINFO: ::c_int = 4;\npub const SA_NOCLDWAIT: ::c_int = 2;\npub const SIGTTIN: ::c_int = 21;\npub const SIGTTOU: ::c_int = 22;\npub const SIGXCPU: ::c_int = 24;\npub const SIGXFSZ: ::c_int = 25;\npub const SIGVTALRM: ::c_int = 26;\npub const SIGPROF: ::c_int = 27;\npub const SIGWINCH: ::c_int = 28;\npub const SIGCHLD: ::c_int = 17;\npub const SIGBUS: ::c_int = 7;\npub const SIGUSR1: ::c_int = 10;\npub const SIGUSR2: ::c_int = 12;\npub const SIGCONT: ::c_int = 18;\npub const SIGSTOP: ::c_int = 19;\npub const SIGTSTP: ::c_int = 20;\npub const SIGURG: ::c_int = 23;\npub const SIGIO: ::c_int = 29;\npub const SIGSYS: ::c_int = 31;\npub const SIGSTKFLT: ::c_int = 16;\npub const SIGPOLL: ::c_int = 29;\npub const SIGPWR: ::c_int = 30;\npub const SIG_SETMASK: ::c_int = 2;\npub const SIG_BLOCK: ::c_int = 0;\npub const SIG_UNBLOCK: ::c_int = 1;\npub const POLLWRNORM: ::c_short = 256;\npub const POLLWRBAND: ::c_short = 512;\npub const O_ASYNC: ::c_int = 8192;\npub const O_NDELAY: ::c_int = 2048;\npub const PTRACE_DETACH: ::c_uint = 17;\npub const EFD_NONBLOCK: ::c_int = 2048;\npub const F_GETLK: ::c_int = 5;\npub const F_GETOWN: ::c_int = 9;\npub const F_SETOWN: ::c_int = 8;\npub const F_SETLK: ::c_int = 6;\npub const F_SETLKW: ::c_int = 7;\npub const F_RDLCK: ::c_int = 0;\npub const F_WRLCK: ::c_int = 1;\npub const F_UNLCK: ::c_int = 2;\npub const F_OFD_GETLK: ::c_int = 36;\npub const F_OFD_SETLK: ::c_int = 37;\npub const F_OFD_SETLKW: ::c_int = 38;\npub const SFD_NONBLOCK: ::c_int = 2048;\npub const TCSANOW: ::c_int = 0;\npub const TCSADRAIN: ::c_int = 1;\npub const TCSAFLUSH: ::c_int = 2;\npub const TIOCLINUX: ::c_ulong = 21532;\npub const TIOCGSERIAL: ::c_ulong = 21534;\npub const TIOCEXCL: ::c_ulong = 21516;\npub const TIOCNXCL: ::c_ulong = 21517;\npub const TIOCSCTTY: ::c_ulong = 21518;\npub const TIOCSTI: ::c_ulong = 21522;\npub const TIOCMGET: ::c_ulong = 21525;\npub const TIOCMBIS: ::c_ulong = 21526;\npub const TIOCMBIC: ::c_ulong = 21527;\npub const TIOCMSET: ::c_ulong = 21528;\npub const TIOCCONS: ::c_ulong = 21533;\npub const TIOCM_ST: ::c_int = 8;\npub const TIOCM_SR: ::c_int = 16;\npub const TIOCM_CTS: ::c_int = 32;\npub const TIOCM_CAR: ::c_int = 64;\npub const TIOCM_RNG: ::c_int = 128;\npub const TIOCM_DSR: ::c_int = 256;\npub const SFD_CLOEXEC: ::c_int = 524288;\npub const NCCS: usize = 32;\npub const O_TRUNC: ::c_int = 512;\npub const O_CLOEXEC: ::c_int = 524288;\npub const EBFONT: ::c_int = 59;\npub const ENOSTR: ::c_int = 60;\npub const ENODATA: ::c_int = 61;\npub const ETIME: ::c_int = 62;\npub const ENOSR: ::c_int = 63;\npub const ENONET: ::c_int = 64;\npub const ENOPKG: ::c_int = 65;\npub const EREMOTE: ::c_int = 66;\npub const ENOLINK: ::c_int = 67;\npub const EADV: ::c_int = 68;\npub const ESRMNT: ::c_int = 69;\npub const ECOMM: ::c_int = 70;\npub const EPROTO: ::c_int = 71;\npub const EDOTDOT: ::c_int = 73;\npub const SA_NODEFER: ::c_int = 1073741824;\npub const SA_RESETHAND: ::c_int = -2147483648;\npub const SA_RESTART: ::c_int = 268435456;\npub const SA_NOCLDSTOP: ::c_int = 1;\npub const EPOLL_CLOEXEC: ::c_int = 524288;\npub const EFD_CLOEXEC: ::c_int = 524288;\npub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;\npub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;\npub const O_DIRECT: ::c_int = 16384;\npub const O_DIRECTORY: ::c_int = 65536;\npub const O_NOFOLLOW: ::c_int = 131072;\npub const MAP_HUGETLB: ::c_int = 262144;\npub const MAP_LOCKED: ::c_int = 8192;\npub const MAP_NORESERVE: ::c_int = 16384;\npub const MAP_ANON: ::c_int = 32;\npub const MAP_ANONYMOUS: ::c_int = 32;\npub const MAP_DENYWRITE: ::c_int = 2048;\npub const MAP_EXECUTABLE: ::c_int = 4096;\npub const MAP_POPULATE: ::c_int = 32768;\npub const MAP_NONBLOCK: ::c_int = 65536;\npub const MAP_STACK: ::c_int = 131072;\npub const MAP_SYNC: ::c_int = 0x080000;\npub const EDEADLOCK: ::c_int = 35;\npub const EUCLEAN: ::c_int = 117;\npub const ENOTNAM: ::c_int = 118;\npub const ENAVAIL: ::c_int = 119;\npub const EISNAM: ::c_int = 120;\npub const EREMOTEIO: ::c_int = 121;\npub const FIOCLEX: ::c_ulong = 21585;\npub const FIONCLEX: ::c_ulong = 21584;\npub const FIONBIO: ::c_ulong = 21537;\npub const MCL_CURRENT: ::c_int = 1;\npub const MCL_FUTURE: ::c_int = 2;\npub const SIGSTKSZ: ::size_t = 8192;\npub const MINSIGSTKSZ: ::size_t = 2048;\npub const CBAUD: ::tcflag_t = 4111;\npub const TAB1: ::tcflag_t = 2048;\npub const TAB2: ::tcflag_t = 4096;\npub const TAB3: ::tcflag_t = 6144;\npub const CR1: ::tcflag_t = 512;\npub const CR2: ::tcflag_t = 1024;\npub const CR3: ::tcflag_t = 1536;\npub const FF1: ::tcflag_t = 32768;\npub const BS1: ::tcflag_t = 8192;\npub const VT1: ::tcflag_t = 16384;\npub const VWERASE: usize = 14;\npub const VREPRINT: usize = 12;\npub const VSUSP: usize = 10;\npub const VSTART: usize = 8;\npub const VSTOP: usize = 9;\npub const VDISCARD: usize = 13;\npub const VTIME: usize = 5;\npub const IXON: ::tcflag_t = 1024;\npub const IXOFF: ::tcflag_t = 4096;\npub const ONLCR: ::tcflag_t = 4;\npub const CSIZE: ::tcflag_t = 48;\npub const CS6: ::tcflag_t = 16;\npub const CS7: ::tcflag_t = 32;\npub const CS8: ::tcflag_t = 48;\npub const CSTOPB: ::tcflag_t = 64;\npub const CREAD: ::tcflag_t = 128;\npub const PARENB: ::tcflag_t = 256;\npub const PARODD: ::tcflag_t = 512;\npub const HUPCL: ::tcflag_t = 1024;\npub const CLOCAL: ::tcflag_t = 2048;\npub const ECHOKE: ::tcflag_t = 2048;\npub const ECHOE: ::tcflag_t = 16;\npub const ECHOK: ::tcflag_t = 32;\npub const ECHONL: ::tcflag_t = 64;\npub const ECHOPRT: ::tcflag_t = 1024;\npub const ECHOCTL: ::tcflag_t = 512;\npub const ISIG: ::tcflag_t = 1;\npub const ICANON: ::tcflag_t = 2;\npub const PENDIN: ::tcflag_t = 16384;\npub const NOFLSH: ::tcflag_t = 128;\npub const CIBAUD: ::tcflag_t = 269418496;\npub const CBAUDEX: ::tcflag_t = 4096;\npub const VSWTC: usize = 7;\npub const OLCUC: ::tcflag_t = 2;\npub const NLDLY: ::tcflag_t = 256;\npub const CRDLY: ::tcflag_t = 1536;\npub const TABDLY: ::tcflag_t = 6144;\npub const BSDLY: ::tcflag_t = 8192;\npub const FFDLY: ::tcflag_t = 32768;\npub const VTDLY: ::tcflag_t = 16384;\npub const XTABS: ::tcflag_t = 6144;\npub const B0: ::speed_t = 0;\npub const B50: ::speed_t = 1;\npub const B75: ::speed_t = 2;\npub const B110: ::speed_t = 3;\npub const B134: ::speed_t = 4;\npub const B150: ::speed_t = 5;\npub const B200: ::speed_t = 6;\npub const B300: ::speed_t = 7;\npub const B600: ::speed_t = 8;\npub const B1200: ::speed_t = 9;\npub const B1800: ::speed_t = 10;\npub const B2400: ::speed_t = 11;\npub const B4800: ::speed_t = 12;\npub const B9600: ::speed_t = 13;\npub const B19200: ::speed_t = 14;\npub const B38400: ::speed_t = 15;\npub const EXTA: ::speed_t = 14;\npub const EXTB: ::speed_t = 15;\npub const B57600: ::speed_t = 4097;\npub const B115200: ::speed_t = 4098;\npub const B230400: ::speed_t = 4099;\npub const B460800: ::speed_t = 4100;\npub const B500000: ::speed_t = 4101;\npub const B576000: ::speed_t = 4102;\npub const B921600: ::speed_t = 4103;\npub const B1000000: ::speed_t = 4104;\npub const B1152000: ::speed_t = 4105;\npub const B1500000: ::speed_t = 4106;\npub const B2000000: ::speed_t = 4107;\npub const B2500000: ::speed_t = 4108;\npub const B3000000: ::speed_t = 4109;\npub const B3500000: ::speed_t = 4110;\npub const B4000000: ::speed_t = 4111;\npub const VEOL: usize = 11;\npub const VEOL2: usize = 16;\npub const VMIN: usize = 6;\npub const IEXTEN: ::tcflag_t = 32768;\npub const TOSTOP: ::tcflag_t = 256;\npub const FLUSHO: ::tcflag_t = 4096;\npub const EXTPROC: ::tcflag_t = 65536;\npub const TCGETS: ::c_ulong = 21505;\npub const TCSETS: ::c_ulong = 21506;\npub const TCSETSW: ::c_ulong = 21507;\npub const TCSETSF: ::c_ulong = 21508;\npub const TCGETA: ::c_ulong = 21509;\npub const TCSETA: ::c_ulong = 21510;\npub const TCSETAW: ::c_ulong = 21511;\npub const TCSETAF: ::c_ulong = 21512;\npub const TCSBRK: ::c_ulong = 21513;\npub const TCXONC: ::c_ulong = 21514;\npub const TCFLSH: ::c_ulong = 21515;\npub const TIOCINQ: ::c_ulong = 21531;\npub const TIOCGPGRP: ::c_ulong = 21519;\npub const TIOCSPGRP: ::c_ulong = 21520;\npub const TIOCOUTQ: ::c_ulong = 21521;\npub const TIOCGWINSZ: ::c_ulong = 21523;\npub const TIOCSWINSZ: ::c_ulong = 21524;\npub const FIONREAD: ::c_ulong = 21531;\npub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;\npub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;\npub const SYS_read: ::c_long = 63;\npub const SYS_write: ::c_long = 64;\npub const SYS_close: ::c_long = 57;\npub const SYS_fstat: ::c_long = 80;\npub const SYS_lseek: ::c_long = 62;\npub const SYS_mmap: ::c_long = 222;\npub const SYS_mprotect: ::c_long = 226;\npub const SYS_munmap: ::c_long = 215;\npub const SYS_brk: ::c_long = 214;\npub const SYS_rt_sigaction: ::c_long = 134;\npub const SYS_rt_sigprocmask: ::c_long = 135;\npub const SYS_rt_sigreturn: ::c_long = 139;\npub const SYS_ioctl: ::c_long = 29;\npub const SYS_pread64: ::c_long = 67;\npub const SYS_pwrite64: ::c_long = 68;\npub const SYS_readv: ::c_long = 65;\npub const SYS_writev: ::c_long = 66;\npub const SYS_sched_yield: ::c_long = 124;\npub const SYS_mremap: ::c_long = 216;\npub const SYS_msync: ::c_long = 227;\npub const SYS_mincore: ::c_long = 232;\npub const SYS_madvise: ::c_long = 233;\npub const SYS_shmget: ::c_long = 194;\npub const SYS_shmat: ::c_long = 196;\npub const SYS_shmctl: ::c_long = 195;\npub const SYS_dup: ::c_long = 23;\npub const SYS_nanosleep: ::c_long = 101;\npub const SYS_getitimer: ::c_long = 102;\npub const SYS_setitimer: ::c_long = 103;\npub const SYS_getpid: ::c_long = 172;\npub const SYS_sendfile: ::c_long = 71;\npub const SYS_socket: ::c_long = 198;\npub const SYS_connect: ::c_long = 203;\npub const SYS_accept: ::c_long = 202;\npub const SYS_sendto: ::c_long = 206;\npub const SYS_recvfrom: ::c_long = 207;\npub const SYS_sendmsg: ::c_long = 211;\npub const SYS_recvmsg: ::c_long = 212;\npub const SYS_shutdown: ::c_long = 210;\npub const SYS_bind: ::c_long = 200;\npub const SYS_listen: ::c_long = 201;\npub const SYS_getsockname: ::c_long = 204;\npub const SYS_getpeername: ::c_long = 205;\npub const SYS_socketpair: ::c_long = 199;\npub const SYS_setsockopt: ::c_long = 208;\npub const SYS_getsockopt: ::c_long = 209;\npub const SYS_clone: ::c_long = 220;\npub const SYS_execve: ::c_long = 221;\npub const SYS_exit: ::c_long = 93;\npub const SYS_wait4: ::c_long = 260;\npub const SYS_kill: ::c_long = 129;\npub const SYS_uname: ::c_long = 160;\npub const SYS_semget: ::c_long = 190;\npub const SYS_semop: ::c_long = 193;\npub const SYS_semctl: ::c_long = 191;\npub const SYS_shmdt: ::c_long = 197;\npub const SYS_msgget: ::c_long = 186;\npub const SYS_msgsnd: ::c_long = 189;\npub const SYS_msgrcv: ::c_long = 188;\npub const SYS_msgctl: ::c_long = 187;\npub const SYS_fcntl: ::c_long = 25;\npub const SYS_flock: ::c_long = 32;\npub const SYS_fsync: ::c_long = 82;\npub const SYS_fdatasync: ::c_long = 83;\npub const SYS_truncate: ::c_long = 45;\npub const SYS_ftruncate: ::c_long = 46;\npub const SYS_getcwd: ::c_long = 17;\npub const SYS_chdir: ::c_long = 49;\npub const SYS_fchdir: ::c_long = 50;\npub const SYS_fchmod: ::c_long = 52;\npub const SYS_fchown: ::c_long = 55;\npub const SYS_umask: ::c_long = 166;\npub const SYS_gettimeofday: ::c_long = 169;\npub const SYS_getrlimit: ::c_long = 163;\npub const SYS_getrusage: ::c_long = 165;\npub const SYS_sysinfo: ::c_long = 179;\npub const SYS_times: ::c_long = 153;\npub const SYS_ptrace: ::c_long = 117;\npub const SYS_getuid: ::c_long = 174;\npub const SYS_syslog: ::c_long = 116;\npub const SYS_getgid: ::c_long = 176;\npub const SYS_setuid: ::c_long = 146;\npub const SYS_setgid: ::c_long = 144;\npub const SYS_geteuid: ::c_long = 175;\npub const SYS_getegid: ::c_long = 177;\npub const SYS_setpgid: ::c_long = 154;\npub const SYS_getppid: ::c_long = 173;\npub const SYS_setsid: ::c_long = 157;\npub const SYS_setreuid: ::c_long = 145;\npub const SYS_setregid: ::c_long = 143;\npub const SYS_getgroups: ::c_long = 158;\npub const SYS_setgroups: ::c_long = 159;\npub const SYS_setresuid: ::c_long = 147;\npub const SYS_getresuid: ::c_long = 148;\npub const SYS_setresgid: ::c_long = 149;\npub const SYS_getresgid: ::c_long = 150;\npub const SYS_getpgid: ::c_long = 155;\npub const SYS_setfsuid: ::c_long = 151;\npub const SYS_setfsgid: ::c_long = 152;\npub const SYS_getsid: ::c_long = 156;\npub const SYS_capget: ::c_long = 90;\npub const SYS_capset: ::c_long = 91;\npub const SYS_rt_sigpending: ::c_long = 136;\npub const SYS_rt_sigtimedwait: ::c_long = 137;\npub const SYS_rt_sigqueueinfo: ::c_long = 138;\npub const SYS_rt_sigsuspend: ::c_long = 133;\npub const SYS_sigaltstack: ::c_long = 132;\npub const SYS_personality: ::c_long = 92;\npub const SYS_statfs: ::c_long = 43;\npub const SYS_fstatfs: ::c_long = 44;\npub const SYS_getpriority: ::c_long = 141;\npub const SYS_setpriority: ::c_long = 140;\npub const SYS_sched_setparam: ::c_long = 118;\npub const SYS_sched_getparam: ::c_long = 121;\npub const SYS_sched_setscheduler: ::c_long = 119;\npub const SYS_sched_getscheduler: ::c_long = 120;\npub const SYS_sched_get_priority_max: ::c_long = 125;\npub const SYS_sched_get_priority_min: ::c_long = 126;\npub const SYS_sched_rr_get_interval: ::c_long = 127;\npub const SYS_mlock: ::c_long = 228;\npub const SYS_munlock: ::c_long = 229;\npub const SYS_mlockall: ::c_long = 230;\npub const SYS_munlockall: ::c_long = 231;\npub const SYS_vhangup: ::c_long = 58;\npub const SYS_pivot_root: ::c_long = 41;\npub const SYS_prctl: ::c_long = 167;\npub const SYS_adjtimex: ::c_long = 171;\npub const SYS_setrlimit: ::c_long = 164;\npub const SYS_chroot: ::c_long = 51;\npub const SYS_sync: ::c_long = 81;\npub const SYS_acct: ::c_long = 89;\npub const SYS_settimeofday: ::c_long = 170;\npub const SYS_mount: ::c_long = 40;\npub const SYS_umount2: ::c_long = 39;\npub const SYS_swapon: ::c_long = 224;\npub const SYS_swapoff: ::c_long = 225;\npub const SYS_reboot: ::c_long = 142;\npub const SYS_sethostname: ::c_long = 161;\npub const SYS_setdomainname: ::c_long = 162;\npub const SYS_init_module: ::c_long = 105;\npub const SYS_delete_module: ::c_long = 106;\npub const SYS_quotactl: ::c_long = 60;\npub const SYS_nfsservctl: ::c_long = 42;\npub const SYS_gettid: ::c_long = 178;\npub const SYS_readahead: ::c_long = 213;\npub const SYS_setxattr: ::c_long = 5;\npub const SYS_lsetxattr: ::c_long = 6;\npub const SYS_fsetxattr: ::c_long = 7;\npub const SYS_getxattr: ::c_long = 8;\npub const SYS_lgetxattr: ::c_long = 9;\npub const SYS_fgetxattr: ::c_long = 10;\npub const SYS_listxattr: ::c_long = 11;\npub const SYS_llistxattr: ::c_long = 12;\npub const SYS_flistxattr: ::c_long = 13;\npub const SYS_removexattr: ::c_long = 14;\npub const SYS_lremovexattr: ::c_long = 15;\npub const SYS_fremovexattr: ::c_long = 16;\npub const SYS_tkill: ::c_long = 130;\npub const SYS_futex: ::c_long = 98;\npub const SYS_sched_setaffinity: ::c_long = 122;\npub const SYS_sched_getaffinity: ::c_long = 123;\npub const SYS_io_setup: ::c_long = 0;\npub const SYS_io_destroy: ::c_long = 1;\npub const SYS_io_getevents: ::c_long = 4;\npub const SYS_io_submit: ::c_long = 2;\npub const SYS_io_cancel: ::c_long = 3;\npub const SYS_lookup_dcookie: ::c_long = 18;\npub const SYS_remap_file_pages: ::c_long = 234;\npub const SYS_getdents64: ::c_long = 61;\npub const SYS_set_tid_address: ::c_long = 96;\npub const SYS_restart_syscall: ::c_long = 128;\npub const SYS_semtimedop: ::c_long = 192;\npub const SYS_fadvise64: ::c_long = 223;\npub const SYS_timer_create: ::c_long = 107;\npub const SYS_timer_settime: ::c_long = 110;\npub const SYS_timer_gettime: ::c_long = 108;\npub const SYS_timer_getoverrun: ::c_long = 109;\npub const SYS_timer_delete: ::c_long = 111;\npub const SYS_clock_settime: ::c_long = 112;\npub const SYS_clock_gettime: ::c_long = 113;\npub const SYS_clock_getres: ::c_long = 114;\npub const SYS_clock_nanosleep: ::c_long = 115;\npub const SYS_exit_group: ::c_long = 94;\npub const SYS_epoll_ctl: ::c_long = 21;\npub const SYS_tgkill: ::c_long = 131;\npub const SYS_mbind: ::c_long = 235;\npub const SYS_set_mempolicy: ::c_long = 237;\npub const SYS_get_mempolicy: ::c_long = 236;\npub const SYS_mq_open: ::c_long = 180;\npub const SYS_mq_unlink: ::c_long = 181;\npub const SYS_mq_timedsend: ::c_long = 182;\npub const SYS_mq_timedreceive: ::c_long = 183;\npub const SYS_mq_notify: ::c_long = 184;\npub const SYS_mq_getsetattr: ::c_long = 185;\npub const SYS_kexec_load: ::c_long = 104;\npub const SYS_waitid: ::c_long = 95;\npub const SYS_add_key: ::c_long = 217;\npub const SYS_request_key: ::c_long = 218;\npub const SYS_keyctl: ::c_long = 219;\npub const SYS_ioprio_set: ::c_long = 30;\npub const SYS_ioprio_get: ::c_long = 31;\npub const SYS_inotify_add_watch: ::c_long = 27;\npub const SYS_inotify_rm_watch: ::c_long = 28;\npub const SYS_migrate_pages: ::c_long = 238;\npub const SYS_openat: ::c_long = 56;\npub const SYS_mkdirat: ::c_long = 34;\npub const SYS_mknodat: ::c_long = 33;\npub const SYS_fchownat: ::c_long = 54;\npub const SYS_newfstatat: ::c_long = 79;\npub const SYS_unlinkat: ::c_long = 35;\npub const SYS_linkat: ::c_long = 37;\npub const SYS_symlinkat: ::c_long = 36;\npub const SYS_readlinkat: ::c_long = 78;\npub const SYS_fchmodat: ::c_long = 53;\npub const SYS_faccessat: ::c_long = 48;\npub const SYS_pselect6: ::c_long = 72;\npub const SYS_ppoll: ::c_long = 73;\npub const SYS_unshare: ::c_long = 97;\npub const SYS_set_robust_list: ::c_long = 99;\npub const SYS_get_robust_list: ::c_long = 100;\npub const SYS_splice: ::c_long = 76;\npub const SYS_tee: ::c_long = 77;\npub const SYS_sync_file_range: ::c_long = 84;\npub const SYS_vmsplice: ::c_long = 75;\npub const SYS_move_pages: ::c_long = 239;\npub const SYS_utimensat: ::c_long = 88;\npub const SYS_epoll_pwait: ::c_long = 22;\npub const SYS_timerfd_create: ::c_long = 85;\npub const SYS_fallocate: ::c_long = 47;\npub const SYS_timerfd_settime: ::c_long = 86;\npub const SYS_timerfd_gettime: ::c_long = 87;\npub const SYS_accept4: ::c_long = 242;\npub const SYS_signalfd4: ::c_long = 74;\npub const SYS_eventfd2: ::c_long = 19;\npub const SYS_epoll_create1: ::c_long = 20;\npub const SYS_dup3: ::c_long = 24;\npub const SYS_pipe2: ::c_long = 59;\npub const SYS_inotify_init1: ::c_long = 26;\npub const SYS_preadv: ::c_long = 69;\npub const SYS_pwritev: ::c_long = 70;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 240;\npub const SYS_perf_event_open: ::c_long = 241;\npub const SYS_recvmmsg: ::c_long = 243;\npub const SYS_fanotify_init: ::c_long = 262;\npub const SYS_fanotify_mark: ::c_long = 263;\npub const SYS_prlimit64: ::c_long = 261;\npub const SYS_name_to_handle_at: ::c_long = 264;\npub const SYS_open_by_handle_at: ::c_long = 265;\npub const SYS_clock_adjtime: ::c_long = 266;\npub const SYS_syncfs: ::c_long = 267;\npub const SYS_sendmmsg: ::c_long = 269;\npub const SYS_setns: ::c_long = 268;\npub const SYS_getcpu: ::c_long = 168;\npub const SYS_process_vm_readv: ::c_long = 270;\npub const SYS_process_vm_writev: ::c_long = 271;\npub const SYS_kcmp: ::c_long = 272;\npub const SYS_finit_module: ::c_long = 273;\npub const SYS_sched_setattr: ::c_long = 274;\npub const SYS_sched_getattr: ::c_long = 275;\npub const SYS_renameat2: ::c_long = 276;\npub const SYS_seccomp: ::c_long = 277;\npub const SYS_getrandom: ::c_long = 278;\npub const SYS_memfd_create: ::c_long = 279;\npub const SYS_bpf: ::c_long = 280;\npub const SYS_execveat: ::c_long = 281;\npub const SYS_userfaultfd: ::c_long = 282;\npub const SYS_membarrier: ::c_long = 283;\npub const SYS_mlock2: ::c_long = 284;\npub const SYS_copy_file_range: ::c_long = 285;\npub const SYS_preadv2: ::c_long = 286;\npub const SYS_pwritev2: ::c_long = 287;\npub const SYS_pkey_mprotect: ::c_long = 288;\npub const SYS_pkey_alloc: ::c_long = 289;\npub const SYS_pkey_free: ::c_long = 290;\npub const SYS_statx: ::c_long = 291;\npub const SYS_pidfd_send_signal: ::c_long = 424;\npub const SYS_io_uring_setup: ::c_long = 425;\npub const SYS_io_uring_enter: ::c_long = 426;\npub const SYS_io_uring_register: ::c_long = 427;\npub const SYS_open_tree: ::c_long = 428;\npub const SYS_move_mount: ::c_long = 429;\npub const SYS_fsopen: ::c_long = 430;\npub const SYS_fsconfig: ::c_long = 431;\npub const SYS_fsmount: ::c_long = 432;\npub const SYS_fspick: ::c_long = 433;\npub const SYS_pidfd_open: ::c_long = 434;\npub const SYS_clone3: ::c_long = 435;\npub const SYS_close_range: ::c_long = 436;\npub const SYS_openat2: ::c_long = 437;\npub const SYS_pidfd_getfd: ::c_long = 438;\npub const SYS_faccessat2: ::c_long = 439;\npub const SYS_process_madvise: ::c_long = 440;\npub const SYS_epoll_pwait2: ::c_long = 441;\npub const SYS_mount_setattr: ::c_long = 442;\n"],["1178","//! 64-bit specific definitions for linux-like values\n\npub type ino_t = u64;\npub type off_t = i64;\npub type blkcnt_t = i64;\npub type shmatt_t = u64;\npub type msgqnum_t = u64;\npub type msglen_t = u64;\npub type fsblkcnt_t = u64;\npub type fsfilcnt_t = u64;\npub type rlim_t = u64;\ncfg_if! {\n    if #[cfg(all(target_arch = \"aarch64\", target_pointer_width = \"32\"))] {\n        pub type clock_t = i32;\n        pub type time_t = i32;\n        pub type __fsword_t = i32;\n    } else {\n        pub type __fsword_t = i64;\n        pub type clock_t = i64;\n        pub type time_t = i64;\n    }\n}\n\ns! {\n    pub struct sigset_t {\n        #[cfg(target_pointer_width = \"32\")]\n        __val: [u32; 32],\n        #[cfg(target_pointer_width = \"64\")]\n        __val: [u64; 16],\n    }\n\n    pub struct sysinfo {\n        pub uptime: i64,\n        pub loads: [u64; 3],\n        pub totalram: u64,\n        pub freeram: u64,\n        pub sharedram: u64,\n        pub bufferram: u64,\n        pub totalswap: u64,\n        pub freeswap: u64,\n        pub procs: ::c_ushort,\n        pub pad: ::c_ushort,\n        pub totalhigh: u64,\n        pub freehigh: u64,\n        pub mem_unit: ::c_uint,\n        pub _f: [::c_char; 0],\n    }\n\n    pub struct msqid_ds {\n        pub msg_perm: ::ipc_perm,\n        pub msg_stime: ::time_t,\n        pub msg_rtime: ::time_t,\n        pub msg_ctime: ::time_t,\n        __msg_cbytes: u64,\n        pub msg_qnum: ::msgqnum_t,\n        pub msg_qbytes: ::msglen_t,\n        pub msg_lspid: ::pid_t,\n        pub msg_lrpid: ::pid_t,\n        __glibc_reserved4: u64,\n        __glibc_reserved5: u64,\n    }\n\n}\n\npub const RLIM_INFINITY: ::rlim_t = !0;\npub const __SIZEOF_PTHREAD_RWLOCKATTR_T: usize = 8;\n\npub const O_LARGEFILE: ::c_int = 0;\n\ncfg_if! {\n    if #[cfg(target_arch = \"aarch64\")] {\n        mod aarch64;\n        pub use self::aarch64::*;\n    } else if #[cfg(any(target_arch = \"powerpc64\"))] {\n        mod powerpc64;\n        pub use self::powerpc64::*;\n    } else if #[cfg(any(target_arch = \"sparc64\"))] {\n        mod sparc64;\n        pub use self::sparc64::*;\n    } else if #[cfg(any(target_arch = \"mips64\"))] {\n        mod mips64;\n        pub use self::mips64::*;\n    } else if #[cfg(any(target_arch = \"s390x\"))] {\n        mod s390x;\n        pub use self::s390x::*;\n    } else if #[cfg(any(target_arch = \"x86_64\"))] {\n        mod x86_64;\n        pub use self::x86_64::*;\n    } else if #[cfg(any(target_arch = \"riscv64\"))] {\n        mod riscv64;\n        pub use self::riscv64::*;\n    } else {\n        // Unknown target_arch\n    }\n}\n"],["1179","use pthread_mutex_t;\n\npub type blksize_t = i64;\npub type c_char = i8;\npub type c_long = i64;\npub type c_ulong = u64;\npub type nlink_t = u64;\npub type suseconds_t = i64;\npub type wchar_t = i32;\npub type __u64 = ::c_ulong;\n\ns! {\n    pub struct stat {\n        pub st_dev: ::c_ulong,\n        st_pad1: [::c_long; 2],\n        pub st_ino: ::ino_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::c_ulong,\n        st_pad2: [::c_ulong; 1],\n        pub st_size: ::off_t,\n        st_pad3: ::c_long,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        pub st_blksize: ::blksize_t,\n        st_pad4: ::c_long,\n        pub st_blocks: ::blkcnt_t,\n        st_pad5: [::c_long; 7],\n    }\n\n    pub struct statfs {\n        pub f_type: ::c_long,\n        pub f_bsize: ::c_long,\n        pub f_frsize: ::c_long,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_files: ::fsblkcnt_t,\n        pub f_ffree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_fsid: ::fsid_t,\n\n        pub f_namelen: ::c_long,\n        f_spare: [::c_long; 6],\n    }\n\n    pub struct flock {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off_t,\n        pub l_len: ::off_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct flock64 {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off64_t,\n        pub l_len: ::off64_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::c_ulong,\n        st_pad1: [::c_long; 2],\n        pub st_ino: ::ino64_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::c_ulong,\n        st_pad2: [::c_long; 2],\n        pub st_size: ::off64_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        pub st_blksize: ::blksize_t,\n        st_pad3: ::c_long,\n        pub st_blocks: ::blkcnt64_t,\n        st_pad5: [::c_long; 7],\n    }\n\n    pub struct statfs64 {\n        pub f_type: ::c_long,\n        pub f_bsize: ::c_long,\n        pub f_frsize: ::c_long,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_bavail: u64,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_long,\n        pub f_flags: ::c_long,\n        pub f_spare: [::c_long; 5],\n    }\n\n    pub struct statvfs {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_favail: ::fsfilcnt_t,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_favail: u64,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct pthread_attr_t {\n        __size: [::c_ulong; 7]\n    }\n\n    pub struct sigaction {\n        pub sa_flags: ::c_int,\n        pub sa_sigaction: ::sighandler_t,\n        pub sa_mask: ::sigset_t,\n        pub sa_restorer: ::Option<extern fn()>,\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_size: ::size_t,\n        pub ss_flags: ::c_int,\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_code: ::c_int,\n        pub si_errno: ::c_int,\n        _pad: ::c_int,\n        _pad2: [::c_long; 14],\n    }\n\n    pub struct ipc_perm {\n        pub __key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::c_uint,\n        pub __seq: ::c_ushort,\n        __pad1: ::c_ushort,\n        __unused1: ::c_ulong,\n        __unused2: ::c_ulong\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        pub shm_segsz: ::size_t,\n        pub shm_atime: ::time_t,\n        pub shm_dtime: ::time_t,\n        pub shm_ctime: ::time_t,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::shmatt_t,\n        __unused4: ::c_ulong,\n        __unused5: ::c_ulong\n    }\n\n    pub struct termios2 {\n        pub c_iflag: ::tcflag_t,\n        pub c_oflag: ::tcflag_t,\n        pub c_cflag: ::tcflag_t,\n        pub c_lflag: ::tcflag_t,\n        pub c_line: ::cc_t,\n        pub c_cc: [::cc_t; 23],\n        pub c_ispeed: ::speed_t,\n        pub c_ospeed: ::speed_t,\n    }\n}\n\npub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;\npub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;\npub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;\npub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;\n\nalign_const! {\n    #[cfg(target_endian = \"little\")]\n    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"little\")]\n    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"little\")]\n    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"big\")]\n    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"big\")]\n    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"big\")]\n    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n}\n\npub const SYS_read: ::c_long = 5000 + 0;\npub const SYS_write: ::c_long = 5000 + 1;\npub const SYS_open: ::c_long = 5000 + 2;\npub const SYS_close: ::c_long = 5000 + 3;\npub const SYS_stat: ::c_long = 5000 + 4;\npub const SYS_fstat: ::c_long = 5000 + 5;\npub const SYS_lstat: ::c_long = 5000 + 6;\npub const SYS_poll: ::c_long = 5000 + 7;\npub const SYS_lseek: ::c_long = 5000 + 8;\npub const SYS_mmap: ::c_long = 5000 + 9;\npub const SYS_mprotect: ::c_long = 5000 + 10;\npub const SYS_munmap: ::c_long = 5000 + 11;\npub const SYS_brk: ::c_long = 5000 + 12;\npub const SYS_rt_sigaction: ::c_long = 5000 + 13;\npub const SYS_rt_sigprocmask: ::c_long = 5000 + 14;\npub const SYS_ioctl: ::c_long = 5000 + 15;\npub const SYS_pread64: ::c_long = 5000 + 16;\npub const SYS_pwrite64: ::c_long = 5000 + 17;\npub const SYS_readv: ::c_long = 5000 + 18;\npub const SYS_writev: ::c_long = 5000 + 19;\npub const SYS_access: ::c_long = 5000 + 20;\npub const SYS_pipe: ::c_long = 5000 + 21;\npub const SYS__newselect: ::c_long = 5000 + 22;\npub const SYS_sched_yield: ::c_long = 5000 + 23;\npub const SYS_mremap: ::c_long = 5000 + 24;\npub const SYS_msync: ::c_long = 5000 + 25;\npub const SYS_mincore: ::c_long = 5000 + 26;\npub const SYS_madvise: ::c_long = 5000 + 27;\npub const SYS_shmget: ::c_long = 5000 + 28;\npub const SYS_shmat: ::c_long = 5000 + 29;\npub const SYS_shmctl: ::c_long = 5000 + 30;\npub const SYS_dup: ::c_long = 5000 + 31;\npub const SYS_dup2: ::c_long = 5000 + 32;\npub const SYS_pause: ::c_long = 5000 + 33;\npub const SYS_nanosleep: ::c_long = 5000 + 34;\npub const SYS_getitimer: ::c_long = 5000 + 35;\npub const SYS_setitimer: ::c_long = 5000 + 36;\npub const SYS_alarm: ::c_long = 5000 + 37;\npub const SYS_getpid: ::c_long = 5000 + 38;\npub const SYS_sendfile: ::c_long = 5000 + 39;\npub const SYS_socket: ::c_long = 5000 + 40;\npub const SYS_connect: ::c_long = 5000 + 41;\npub const SYS_accept: ::c_long = 5000 + 42;\npub const SYS_sendto: ::c_long = 5000 + 43;\npub const SYS_recvfrom: ::c_long = 5000 + 44;\npub const SYS_sendmsg: ::c_long = 5000 + 45;\npub const SYS_recvmsg: ::c_long = 5000 + 46;\npub const SYS_shutdown: ::c_long = 5000 + 47;\npub const SYS_bind: ::c_long = 5000 + 48;\npub const SYS_listen: ::c_long = 5000 + 49;\npub const SYS_getsockname: ::c_long = 5000 + 50;\npub const SYS_getpeername: ::c_long = 5000 + 51;\npub const SYS_socketpair: ::c_long = 5000 + 52;\npub const SYS_setsockopt: ::c_long = 5000 + 53;\npub const SYS_getsockopt: ::c_long = 5000 + 54;\npub const SYS_clone: ::c_long = 5000 + 55;\npub const SYS_fork: ::c_long = 5000 + 56;\npub const SYS_execve: ::c_long = 5000 + 57;\npub const SYS_exit: ::c_long = 5000 + 58;\npub const SYS_wait4: ::c_long = 5000 + 59;\npub const SYS_kill: ::c_long = 5000 + 60;\npub const SYS_uname: ::c_long = 5000 + 61;\npub const SYS_semget: ::c_long = 5000 + 62;\npub const SYS_semop: ::c_long = 5000 + 63;\npub const SYS_semctl: ::c_long = 5000 + 64;\npub const SYS_shmdt: ::c_long = 5000 + 65;\npub const SYS_msgget: ::c_long = 5000 + 66;\npub const SYS_msgsnd: ::c_long = 5000 + 67;\npub const SYS_msgrcv: ::c_long = 5000 + 68;\npub const SYS_msgctl: ::c_long = 5000 + 69;\npub const SYS_fcntl: ::c_long = 5000 + 70;\npub const SYS_flock: ::c_long = 5000 + 71;\npub const SYS_fsync: ::c_long = 5000 + 72;\npub const SYS_fdatasync: ::c_long = 5000 + 73;\npub const SYS_truncate: ::c_long = 5000 + 74;\npub const SYS_ftruncate: ::c_long = 5000 + 75;\npub const SYS_getdents: ::c_long = 5000 + 76;\npub const SYS_getcwd: ::c_long = 5000 + 77;\npub const SYS_chdir: ::c_long = 5000 + 78;\npub const SYS_fchdir: ::c_long = 5000 + 79;\npub const SYS_rename: ::c_long = 5000 + 80;\npub const SYS_mkdir: ::c_long = 5000 + 81;\npub const SYS_rmdir: ::c_long = 5000 + 82;\npub const SYS_creat: ::c_long = 5000 + 83;\npub const SYS_link: ::c_long = 5000 + 84;\npub const SYS_unlink: ::c_long = 5000 + 85;\npub const SYS_symlink: ::c_long = 5000 + 86;\npub const SYS_readlink: ::c_long = 5000 + 87;\npub const SYS_chmod: ::c_long = 5000 + 88;\npub const SYS_fchmod: ::c_long = 5000 + 89;\npub const SYS_chown: ::c_long = 5000 + 90;\npub const SYS_fchown: ::c_long = 5000 + 91;\npub const SYS_lchown: ::c_long = 5000 + 92;\npub const SYS_umask: ::c_long = 5000 + 93;\npub const SYS_gettimeofday: ::c_long = 5000 + 94;\npub const SYS_getrlimit: ::c_long = 5000 + 95;\npub const SYS_getrusage: ::c_long = 5000 + 96;\npub const SYS_sysinfo: ::c_long = 5000 + 97;\npub const SYS_times: ::c_long = 5000 + 98;\npub const SYS_ptrace: ::c_long = 5000 + 99;\npub const SYS_getuid: ::c_long = 5000 + 100;\npub const SYS_syslog: ::c_long = 5000 + 101;\npub const SYS_getgid: ::c_long = 5000 + 102;\npub const SYS_setuid: ::c_long = 5000 + 103;\npub const SYS_setgid: ::c_long = 5000 + 104;\npub const SYS_geteuid: ::c_long = 5000 + 105;\npub const SYS_getegid: ::c_long = 5000 + 106;\npub const SYS_setpgid: ::c_long = 5000 + 107;\npub const SYS_getppid: ::c_long = 5000 + 108;\npub const SYS_getpgrp: ::c_long = 5000 + 109;\npub const SYS_setsid: ::c_long = 5000 + 110;\npub const SYS_setreuid: ::c_long = 5000 + 111;\npub const SYS_setregid: ::c_long = 5000 + 112;\npub const SYS_getgroups: ::c_long = 5000 + 113;\npub const SYS_setgroups: ::c_long = 5000 + 114;\npub const SYS_setresuid: ::c_long = 5000 + 115;\npub const SYS_getresuid: ::c_long = 5000 + 116;\npub const SYS_setresgid: ::c_long = 5000 + 117;\npub const SYS_getresgid: ::c_long = 5000 + 118;\npub const SYS_getpgid: ::c_long = 5000 + 119;\npub const SYS_setfsuid: ::c_long = 5000 + 120;\npub const SYS_setfsgid: ::c_long = 5000 + 121;\npub const SYS_getsid: ::c_long = 5000 + 122;\npub const SYS_capget: ::c_long = 5000 + 123;\npub const SYS_capset: ::c_long = 5000 + 124;\npub const SYS_rt_sigpending: ::c_long = 5000 + 125;\npub const SYS_rt_sigtimedwait: ::c_long = 5000 + 126;\npub const SYS_rt_sigqueueinfo: ::c_long = 5000 + 127;\npub const SYS_rt_sigsuspend: ::c_long = 5000 + 128;\npub const SYS_sigaltstack: ::c_long = 5000 + 129;\npub const SYS_utime: ::c_long = 5000 + 130;\npub const SYS_mknod: ::c_long = 5000 + 131;\npub const SYS_personality: ::c_long = 5000 + 132;\npub const SYS_ustat: ::c_long = 5000 + 133;\npub const SYS_statfs: ::c_long = 5000 + 134;\npub const SYS_fstatfs: ::c_long = 5000 + 135;\npub const SYS_sysfs: ::c_long = 5000 + 136;\npub const SYS_getpriority: ::c_long = 5000 + 137;\npub const SYS_setpriority: ::c_long = 5000 + 138;\npub const SYS_sched_setparam: ::c_long = 5000 + 139;\npub const SYS_sched_getparam: ::c_long = 5000 + 140;\npub const SYS_sched_setscheduler: ::c_long = 5000 + 141;\npub const SYS_sched_getscheduler: ::c_long = 5000 + 142;\npub const SYS_sched_get_priority_max: ::c_long = 5000 + 143;\npub const SYS_sched_get_priority_min: ::c_long = 5000 + 144;\npub const SYS_sched_rr_get_interval: ::c_long = 5000 + 145;\npub const SYS_mlock: ::c_long = 5000 + 146;\npub const SYS_munlock: ::c_long = 5000 + 147;\npub const SYS_mlockall: ::c_long = 5000 + 148;\npub const SYS_munlockall: ::c_long = 5000 + 149;\npub const SYS_vhangup: ::c_long = 5000 + 150;\npub const SYS_pivot_root: ::c_long = 5000 + 151;\npub const SYS__sysctl: ::c_long = 5000 + 152;\npub const SYS_prctl: ::c_long = 5000 + 153;\npub const SYS_adjtimex: ::c_long = 5000 + 154;\npub const SYS_setrlimit: ::c_long = 5000 + 155;\npub const SYS_chroot: ::c_long = 5000 + 156;\npub const SYS_sync: ::c_long = 5000 + 157;\npub const SYS_acct: ::c_long = 5000 + 158;\npub const SYS_settimeofday: ::c_long = 5000 + 159;\npub const SYS_mount: ::c_long = 5000 + 160;\npub const SYS_umount2: ::c_long = 5000 + 161;\npub const SYS_swapon: ::c_long = 5000 + 162;\npub const SYS_swapoff: ::c_long = 5000 + 163;\npub const SYS_reboot: ::c_long = 5000 + 164;\npub const SYS_sethostname: ::c_long = 5000 + 165;\npub const SYS_setdomainname: ::c_long = 5000 + 166;\npub const SYS_create_module: ::c_long = 5000 + 167;\npub const SYS_init_module: ::c_long = 5000 + 168;\npub const SYS_delete_module: ::c_long = 5000 + 169;\npub const SYS_get_kernel_syms: ::c_long = 5000 + 170;\npub const SYS_query_module: ::c_long = 5000 + 171;\npub const SYS_quotactl: ::c_long = 5000 + 172;\npub const SYS_nfsservctl: ::c_long = 5000 + 173;\npub const SYS_getpmsg: ::c_long = 5000 + 174;\npub const SYS_putpmsg: ::c_long = 5000 + 175;\npub const SYS_afs_syscall: ::c_long = 5000 + 176;\npub const SYS_gettid: ::c_long = 5000 + 178;\npub const SYS_readahead: ::c_long = 5000 + 179;\npub const SYS_setxattr: ::c_long = 5000 + 180;\npub const SYS_lsetxattr: ::c_long = 5000 + 181;\npub const SYS_fsetxattr: ::c_long = 5000 + 182;\npub const SYS_getxattr: ::c_long = 5000 + 183;\npub const SYS_lgetxattr: ::c_long = 5000 + 184;\npub const SYS_fgetxattr: ::c_long = 5000 + 185;\npub const SYS_listxattr: ::c_long = 5000 + 186;\npub const SYS_llistxattr: ::c_long = 5000 + 187;\npub const SYS_flistxattr: ::c_long = 5000 + 188;\npub const SYS_removexattr: ::c_long = 5000 + 189;\npub const SYS_lremovexattr: ::c_long = 5000 + 190;\npub const SYS_fremovexattr: ::c_long = 5000 + 191;\npub const SYS_tkill: ::c_long = 5000 + 192;\npub const SYS_futex: ::c_long = 5000 + 194;\npub const SYS_sched_setaffinity: ::c_long = 5000 + 195;\npub const SYS_sched_getaffinity: ::c_long = 5000 + 196;\npub const SYS_cacheflush: ::c_long = 5000 + 197;\npub const SYS_cachectl: ::c_long = 5000 + 198;\npub const SYS_sysmips: ::c_long = 5000 + 199;\npub const SYS_io_setup: ::c_long = 5000 + 200;\npub const SYS_io_destroy: ::c_long = 5000 + 201;\npub const SYS_io_getevents: ::c_long = 5000 + 202;\npub const SYS_io_submit: ::c_long = 5000 + 203;\npub const SYS_io_cancel: ::c_long = 5000 + 204;\npub const SYS_exit_group: ::c_long = 5000 + 205;\npub const SYS_lookup_dcookie: ::c_long = 5000 + 206;\npub const SYS_epoll_create: ::c_long = 5000 + 207;\npub const SYS_epoll_ctl: ::c_long = 5000 + 208;\npub const SYS_epoll_wait: ::c_long = 5000 + 209;\npub const SYS_remap_file_pages: ::c_long = 5000 + 210;\npub const SYS_rt_sigreturn: ::c_long = 5000 + 211;\npub const SYS_set_tid_address: ::c_long = 5000 + 212;\npub const SYS_restart_syscall: ::c_long = 5000 + 213;\npub const SYS_semtimedop: ::c_long = 5000 + 214;\npub const SYS_fadvise64: ::c_long = 5000 + 215;\npub const SYS_timer_create: ::c_long = 5000 + 216;\npub const SYS_timer_settime: ::c_long = 5000 + 217;\npub const SYS_timer_gettime: ::c_long = 5000 + 218;\npub const SYS_timer_getoverrun: ::c_long = 5000 + 219;\npub const SYS_timer_delete: ::c_long = 5000 + 220;\npub const SYS_clock_settime: ::c_long = 5000 + 221;\npub const SYS_clock_gettime: ::c_long = 5000 + 222;\npub const SYS_clock_getres: ::c_long = 5000 + 223;\npub const SYS_clock_nanosleep: ::c_long = 5000 + 224;\npub const SYS_tgkill: ::c_long = 5000 + 225;\npub const SYS_utimes: ::c_long = 5000 + 226;\npub const SYS_mbind: ::c_long = 5000 + 227;\npub const SYS_get_mempolicy: ::c_long = 5000 + 228;\npub const SYS_set_mempolicy: ::c_long = 5000 + 229;\npub const SYS_mq_open: ::c_long = 5000 + 230;\npub const SYS_mq_unlink: ::c_long = 5000 + 231;\npub const SYS_mq_timedsend: ::c_long = 5000 + 232;\npub const SYS_mq_timedreceive: ::c_long = 5000 + 233;\npub const SYS_mq_notify: ::c_long = 5000 + 234;\npub const SYS_mq_getsetattr: ::c_long = 5000 + 235;\npub const SYS_vserver: ::c_long = 5000 + 236;\npub const SYS_waitid: ::c_long = 5000 + 237;\n/* pub const SYS_sys_setaltroot: ::c_long = 5000 + 238; */\npub const SYS_add_key: ::c_long = 5000 + 239;\npub const SYS_request_key: ::c_long = 5000 + 240;\npub const SYS_keyctl: ::c_long = 5000 + 241;\npub const SYS_set_thread_area: ::c_long = 5000 + 242;\npub const SYS_inotify_init: ::c_long = 5000 + 243;\npub const SYS_inotify_add_watch: ::c_long = 5000 + 244;\npub const SYS_inotify_rm_watch: ::c_long = 5000 + 245;\npub const SYS_migrate_pages: ::c_long = 5000 + 246;\npub const SYS_openat: ::c_long = 5000 + 247;\npub const SYS_mkdirat: ::c_long = 5000 + 248;\npub const SYS_mknodat: ::c_long = 5000 + 249;\npub const SYS_fchownat: ::c_long = 5000 + 250;\npub const SYS_futimesat: ::c_long = 5000 + 251;\npub const SYS_newfstatat: ::c_long = 5000 + 252;\npub const SYS_unlinkat: ::c_long = 5000 + 253;\npub const SYS_renameat: ::c_long = 5000 + 254;\npub const SYS_linkat: ::c_long = 5000 + 255;\npub const SYS_symlinkat: ::c_long = 5000 + 256;\npub const SYS_readlinkat: ::c_long = 5000 + 257;\npub const SYS_fchmodat: ::c_long = 5000 + 258;\npub const SYS_faccessat: ::c_long = 5000 + 259;\npub const SYS_pselect6: ::c_long = 5000 + 260;\npub const SYS_ppoll: ::c_long = 5000 + 261;\npub const SYS_unshare: ::c_long = 5000 + 262;\npub const SYS_splice: ::c_long = 5000 + 263;\npub const SYS_sync_file_range: ::c_long = 5000 + 264;\npub const SYS_tee: ::c_long = 5000 + 265;\npub const SYS_vmsplice: ::c_long = 5000 + 266;\npub const SYS_move_pages: ::c_long = 5000 + 267;\npub const SYS_set_robust_list: ::c_long = 5000 + 268;\npub const SYS_get_robust_list: ::c_long = 5000 + 269;\npub const SYS_kexec_load: ::c_long = 5000 + 270;\npub const SYS_getcpu: ::c_long = 5000 + 271;\npub const SYS_epoll_pwait: ::c_long = 5000 + 272;\npub const SYS_ioprio_set: ::c_long = 5000 + 273;\npub const SYS_ioprio_get: ::c_long = 5000 + 274;\npub const SYS_utimensat: ::c_long = 5000 + 275;\npub const SYS_signalfd: ::c_long = 5000 + 276;\npub const SYS_timerfd: ::c_long = 5000 + 277;\npub const SYS_eventfd: ::c_long = 5000 + 278;\npub const SYS_fallocate: ::c_long = 5000 + 279;\npub const SYS_timerfd_create: ::c_long = 5000 + 280;\npub const SYS_timerfd_gettime: ::c_long = 5000 + 281;\npub const SYS_timerfd_settime: ::c_long = 5000 + 282;\npub const SYS_signalfd4: ::c_long = 5000 + 283;\npub const SYS_eventfd2: ::c_long = 5000 + 284;\npub const SYS_epoll_create1: ::c_long = 5000 + 285;\npub const SYS_dup3: ::c_long = 5000 + 286;\npub const SYS_pipe2: ::c_long = 5000 + 287;\npub const SYS_inotify_init1: ::c_long = 5000 + 288;\npub const SYS_preadv: ::c_long = 5000 + 289;\npub const SYS_pwritev: ::c_long = 5000 + 290;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 5000 + 291;\npub const SYS_perf_event_open: ::c_long = 5000 + 292;\npub const SYS_accept4: ::c_long = 5000 + 293;\npub const SYS_recvmmsg: ::c_long = 5000 + 294;\npub const SYS_fanotify_init: ::c_long = 5000 + 295;\npub const SYS_fanotify_mark: ::c_long = 5000 + 296;\npub const SYS_prlimit64: ::c_long = 5000 + 297;\npub const SYS_name_to_handle_at: ::c_long = 5000 + 298;\npub const SYS_open_by_handle_at: ::c_long = 5000 + 299;\npub const SYS_clock_adjtime: ::c_long = 5000 + 300;\npub const SYS_syncfs: ::c_long = 5000 + 301;\npub const SYS_sendmmsg: ::c_long = 5000 + 302;\npub const SYS_setns: ::c_long = 5000 + 303;\npub const SYS_process_vm_readv: ::c_long = 5000 + 304;\npub const SYS_process_vm_writev: ::c_long = 5000 + 305;\npub const SYS_kcmp: ::c_long = 5000 + 306;\npub const SYS_finit_module: ::c_long = 5000 + 307;\npub const SYS_getdents64: ::c_long = 5000 + 308;\npub const SYS_sched_setattr: ::c_long = 5000 + 309;\npub const SYS_sched_getattr: ::c_long = 5000 + 310;\npub const SYS_renameat2: ::c_long = 5000 + 311;\npub const SYS_seccomp: ::c_long = 5000 + 312;\npub const SYS_getrandom: ::c_long = 5000 + 313;\npub const SYS_memfd_create: ::c_long = 5000 + 314;\npub const SYS_bpf: ::c_long = 5000 + 315;\npub const SYS_execveat: ::c_long = 5000 + 316;\npub const SYS_userfaultfd: ::c_long = 5000 + 317;\npub const SYS_membarrier: ::c_long = 5000 + 318;\npub const SYS_mlock2: ::c_long = 5000 + 319;\npub const SYS_copy_file_range: ::c_long = 5000 + 320;\npub const SYS_preadv2: ::c_long = 5000 + 321;\npub const SYS_pwritev2: ::c_long = 5000 + 322;\npub const SYS_pkey_mprotect: ::c_long = 5000 + 323;\npub const SYS_pkey_alloc: ::c_long = 5000 + 324;\npub const SYS_pkey_free: ::c_long = 5000 + 325;\npub const SYS_statx: ::c_long = 5000 + 326;\npub const SYS_pidfd_send_signal: ::c_long = 5000 + 424;\npub const SYS_io_uring_setup: ::c_long = 5000 + 425;\npub const SYS_io_uring_enter: ::c_long = 5000 + 426;\npub const SYS_io_uring_register: ::c_long = 5000 + 427;\npub const SYS_open_tree: ::c_long = 5000 + 428;\npub const SYS_move_mount: ::c_long = 5000 + 429;\npub const SYS_fsopen: ::c_long = 5000 + 430;\npub const SYS_fsconfig: ::c_long = 5000 + 431;\npub const SYS_fsmount: ::c_long = 5000 + 432;\npub const SYS_fspick: ::c_long = 5000 + 433;\npub const SYS_pidfd_open: ::c_long = 5000 + 434;\npub const SYS_clone3: ::c_long = 5000 + 435;\npub const SYS_close_range: ::c_long = 5000 + 436;\npub const SYS_openat2: ::c_long = 5000 + 437;\npub const SYS_pidfd_getfd: ::c_long = 5000 + 438;\npub const SYS_faccessat2: ::c_long = 5000 + 439;\npub const SYS_process_madvise: ::c_long = 5000 + 440;\npub const SYS_epoll_pwait2: ::c_long = 5000 + 441;\npub const SYS_mount_setattr: ::c_long = 5000 + 442;\n\npub const SFD_CLOEXEC: ::c_int = 0x080000;\n\npub const NCCS: usize = 32;\n\npub const O_TRUNC: ::c_int = 512;\n\npub const O_NOATIME: ::c_int = 0o1000000;\npub const O_CLOEXEC: ::c_int = 0x80000;\npub const O_PATH: ::c_int = 0o10000000;\npub const O_TMPFILE: ::c_int = 0o20000000 | O_DIRECTORY;\n\npub const EBFONT: ::c_int = 59;\npub const ENOSTR: ::c_int = 60;\npub const ENODATA: ::c_int = 61;\npub const ETIME: ::c_int = 62;\npub const ENOSR: ::c_int = 63;\npub const ENONET: ::c_int = 64;\npub const ENOPKG: ::c_int = 65;\npub const EREMOTE: ::c_int = 66;\npub const ENOLINK: ::c_int = 67;\npub const EADV: ::c_int = 68;\npub const ESRMNT: ::c_int = 69;\npub const ECOMM: ::c_int = 70;\npub const EPROTO: ::c_int = 71;\npub const EDOTDOT: ::c_int = 73;\n\npub const SA_NODEFER: ::c_int = 0x40000000;\npub const SA_RESETHAND: ::c_int = 0x80000000;\npub const SA_RESTART: ::c_int = 0x10000000;\npub const SA_NOCLDSTOP: ::c_int = 0x00000001;\n\npub const POSIX_FADV_DONTNEED: ::c_int = 4;\npub const POSIX_FADV_NOREUSE: ::c_int = 5;\n\npub const EPOLL_CLOEXEC: ::c_int = 0x80000;\n\npub const EFD_CLOEXEC: ::c_int = 0x80000;\n\npub const O_DIRECT: ::c_int = 0x8000;\npub const O_DIRECTORY: ::c_int = 0x10000;\npub const O_NOFOLLOW: ::c_int = 0x20000;\n\npub const RLIMIT_NOFILE: ::__rlimit_resource_t = 5;\npub const RLIMIT_AS: ::__rlimit_resource_t = 6;\npub const RLIMIT_RSS: ::__rlimit_resource_t = 7;\npub const RLIMIT_NPROC: ::__rlimit_resource_t = 8;\npub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 9;\n\npub const O_APPEND: ::c_int = 8;\npub const O_CREAT: ::c_int = 256;\npub const O_EXCL: ::c_int = 1024;\npub const O_NOCTTY: ::c_int = 2048;\npub const O_NONBLOCK: ::c_int = 128;\npub const O_SYNC: ::c_int = 0x4010;\npub const O_RSYNC: ::c_int = 0x4010;\npub const O_DSYNC: ::c_int = 0x10;\npub const O_FSYNC: ::c_int = 0x4010;\npub const O_ASYNC: ::c_int = 0x1000;\npub const O_NDELAY: ::c_int = 0x80;\n\npub const EDEADLK: ::c_int = 45;\npub const ENAMETOOLONG: ::c_int = 78;\npub const ENOLCK: ::c_int = 46;\npub const ENOSYS: ::c_int = 89;\npub const ENOTEMPTY: ::c_int = 93;\npub const ELOOP: ::c_int = 90;\npub const ENOMSG: ::c_int = 35;\npub const EIDRM: ::c_int = 36;\npub const ECHRNG: ::c_int = 37;\npub const EL2NSYNC: ::c_int = 38;\npub const EL3HLT: ::c_int = 39;\npub const EL3RST: ::c_int = 40;\npub const ELNRNG: ::c_int = 41;\npub const EUNATCH: ::c_int = 42;\npub const ENOCSI: ::c_int = 43;\npub const EL2HLT: ::c_int = 44;\npub const EBADE: ::c_int = 50;\npub const EBADR: ::c_int = 51;\npub const EXFULL: ::c_int = 52;\npub const ENOANO: ::c_int = 53;\npub const EBADRQC: ::c_int = 54;\npub const EBADSLT: ::c_int = 55;\npub const EDEADLOCK: ::c_int = 56;\npub const EMULTIHOP: ::c_int = 74;\npub const EOVERFLOW: ::c_int = 79;\npub const ENOTUNIQ: ::c_int = 80;\npub const EBADFD: ::c_int = 81;\npub const EBADMSG: ::c_int = 77;\npub const EREMCHG: ::c_int = 82;\npub const ELIBACC: ::c_int = 83;\npub const ELIBBAD: ::c_int = 84;\npub const ELIBSCN: ::c_int = 85;\npub const ELIBMAX: ::c_int = 86;\npub const ELIBEXEC: ::c_int = 87;\npub const EILSEQ: ::c_int = 88;\npub const ERESTART: ::c_int = 91;\npub const ESTRPIPE: ::c_int = 92;\npub const EUSERS: ::c_int = 94;\npub const ENOTSOCK: ::c_int = 95;\npub const EDESTADDRREQ: ::c_int = 96;\npub const EMSGSIZE: ::c_int = 97;\npub const EPROTOTYPE: ::c_int = 98;\npub const ENOPROTOOPT: ::c_int = 99;\npub const EPROTONOSUPPORT: ::c_int = 120;\npub const ESOCKTNOSUPPORT: ::c_int = 121;\npub const EOPNOTSUPP: ::c_int = 122;\npub const EPFNOSUPPORT: ::c_int = 123;\npub const EAFNOSUPPORT: ::c_int = 124;\npub const EADDRINUSE: ::c_int = 125;\npub const EADDRNOTAVAIL: ::c_int = 126;\npub const ENETDOWN: ::c_int = 127;\npub const ENETUNREACH: ::c_int = 128;\npub const ENETRESET: ::c_int = 129;\npub const ECONNABORTED: ::c_int = 130;\npub const ECONNRESET: ::c_int = 131;\npub const ENOBUFS: ::c_int = 132;\npub const EISCONN: ::c_int = 133;\npub const ENOTCONN: ::c_int = 134;\npub const ESHUTDOWN: ::c_int = 143;\npub const ETOOMANYREFS: ::c_int = 144;\npub const ETIMEDOUT: ::c_int = 145;\npub const ECONNREFUSED: ::c_int = 146;\npub const EHOSTDOWN: ::c_int = 147;\npub const EHOSTUNREACH: ::c_int = 148;\npub const EALREADY: ::c_int = 149;\npub const EINPROGRESS: ::c_int = 150;\npub const ESTALE: ::c_int = 151;\npub const EUCLEAN: ::c_int = 135;\npub const ENOTNAM: ::c_int = 137;\npub const ENAVAIL: ::c_int = 138;\npub const EISNAM: ::c_int = 139;\npub const EREMOTEIO: ::c_int = 140;\npub const EDQUOT: ::c_int = 1133;\npub const ENOMEDIUM: ::c_int = 159;\npub const EMEDIUMTYPE: ::c_int = 160;\npub const ECANCELED: ::c_int = 158;\npub const ENOKEY: ::c_int = 161;\npub const EKEYEXPIRED: ::c_int = 162;\npub const EKEYREVOKED: ::c_int = 163;\npub const EKEYREJECTED: ::c_int = 164;\npub const EOWNERDEAD: ::c_int = 165;\npub const ENOTRECOVERABLE: ::c_int = 166;\npub const ERFKILL: ::c_int = 167;\n\npub const MAP_NORESERVE: ::c_int = 0x400;\npub const MAP_ANON: ::c_int = 0x800;\npub const MAP_ANONYMOUS: ::c_int = 0x800;\npub const MAP_GROWSDOWN: ::c_int = 0x1000;\npub const MAP_DENYWRITE: ::c_int = 0x2000;\npub const MAP_EXECUTABLE: ::c_int = 0x4000;\npub const MAP_LOCKED: ::c_int = 0x8000;\npub const MAP_POPULATE: ::c_int = 0x10000;\npub const MAP_NONBLOCK: ::c_int = 0x20000;\npub const MAP_STACK: ::c_int = 0x40000;\npub const MAP_HUGETLB: ::c_int = 0x080000;\n\npub const SOCK_STREAM: ::c_int = 2;\npub const SOCK_DGRAM: ::c_int = 1;\n\npub const FIOCLEX: ::c_ulong = 0x6601;\npub const FIONCLEX: ::c_ulong = 0x6602;\npub const FIONBIO: ::c_ulong = 0x667e;\n\npub const SA_ONSTACK: ::c_int = 0x08000000;\npub const SA_SIGINFO: ::c_int = 0x00000008;\npub const SA_NOCLDWAIT: ::c_int = 0x00010000;\n\npub const SIGCHLD: ::c_int = 18;\npub const SIGBUS: ::c_int = 10;\npub const SIGTTIN: ::c_int = 26;\npub const SIGTTOU: ::c_int = 27;\npub const SIGXCPU: ::c_int = 30;\npub const SIGXFSZ: ::c_int = 31;\npub const SIGVTALRM: ::c_int = 28;\npub const SIGPROF: ::c_int = 29;\npub const SIGWINCH: ::c_int = 20;\npub const SIGUSR1: ::c_int = 16;\npub const SIGUSR2: ::c_int = 17;\npub const SIGCONT: ::c_int = 25;\npub const SIGSTOP: ::c_int = 23;\npub const SIGTSTP: ::c_int = 24;\npub const SIGURG: ::c_int = 21;\npub const SIGIO: ::c_int = 22;\npub const SIGSYS: ::c_int = 12;\npub const SIGPOLL: ::c_int = 22;\npub const SIGPWR: ::c_int = 19;\npub const SIG_SETMASK: ::c_int = 3;\npub const SIG_BLOCK: ::c_int = 0x1;\npub const SIG_UNBLOCK: ::c_int = 0x2;\n\npub const POLLWRNORM: ::c_short = 0x004;\npub const POLLWRBAND: ::c_short = 0x100;\n\npub const VEOF: usize = 16;\npub const VEOL: usize = 17;\npub const VEOL2: usize = 6;\npub const VMIN: usize = 4;\npub const IEXTEN: ::tcflag_t = 0x00000100;\npub const TOSTOP: ::tcflag_t = 0x00008000;\npub const FLUSHO: ::tcflag_t = 0x00002000;\npub const EXTPROC: ::tcflag_t = 0o200000;\npub const TCSANOW: ::c_int = 0x540e;\npub const TCSADRAIN: ::c_int = 0x540f;\npub const TCSAFLUSH: ::c_int = 0x5410;\n\npub const PTRACE_GETFPREGS: ::c_uint = 14;\npub const PTRACE_SETFPREGS: ::c_uint = 15;\npub const PTRACE_DETACH: ::c_uint = 17;\npub const PTRACE_GETFPXREGS: ::c_uint = 18;\npub const PTRACE_SETFPXREGS: ::c_uint = 19;\npub const PTRACE_GETREGS: ::c_uint = 12;\npub const PTRACE_SETREGS: ::c_uint = 13;\n\npub const EFD_NONBLOCK: ::c_int = 0x80;\n\npub const F_RDLCK: ::c_int = 0;\npub const F_WRLCK: ::c_int = 1;\npub const F_UNLCK: ::c_int = 2;\npub const F_GETLK: ::c_int = 14;\npub const F_GETOWN: ::c_int = 23;\npub const F_SETOWN: ::c_int = 24;\npub const F_SETLK: ::c_int = 6;\npub const F_SETLKW: ::c_int = 7;\npub const F_OFD_GETLK: ::c_int = 36;\npub const F_OFD_SETLK: ::c_int = 37;\npub const F_OFD_SETLKW: ::c_int = 38;\n\npub const SFD_NONBLOCK: ::c_int = 0x80;\n\npub const TCGETS: ::c_ulong = 0x540d;\npub const TCSETS: ::c_ulong = 0x540e;\npub const TCSETSW: ::c_ulong = 0x540f;\npub const TCSETSF: ::c_ulong = 0x5410;\npub const TCGETA: ::c_ulong = 0x5401;\npub const TCSETA: ::c_ulong = 0x5402;\npub const TCSETAW: ::c_ulong = 0x5403;\npub const TCSETAF: ::c_ulong = 0x5404;\npub const TCSBRK: ::c_ulong = 0x5405;\npub const TCXONC: ::c_ulong = 0x5406;\npub const TCFLSH: ::c_ulong = 0x5407;\npub const TIOCSBRK: ::c_ulong = 0x5427;\npub const TIOCCBRK: ::c_ulong = 0x5428;\npub const TIOCGSOFTCAR: ::c_ulong = 0x5481;\npub const TIOCSSOFTCAR: ::c_ulong = 0x5482;\npub const TIOCINQ: ::c_ulong = 0x467f;\npub const TIOCLINUX: ::c_ulong = 0x5483;\npub const TIOCGSERIAL: ::c_ulong = 0x5484;\npub const TIOCEXCL: ::c_ulong = 0x740d;\npub const TIOCNXCL: ::c_ulong = 0x740e;\npub const TIOCSCTTY: ::c_ulong = 0x5480;\npub const TIOCGPGRP: ::c_ulong = 0x40047477;\npub const TIOCSPGRP: ::c_ulong = 0x80047476;\npub const TIOCOUTQ: ::c_ulong = 0x7472;\npub const TIOCSTI: ::c_ulong = 0x5472;\npub const TIOCGWINSZ: ::c_ulong = 0x40087468;\npub const TIOCSWINSZ: ::c_ulong = 0x80087467;\npub const TIOCMGET: ::c_ulong = 0x741d;\npub const TIOCMBIS: ::c_ulong = 0x741b;\npub const TIOCMBIC: ::c_ulong = 0x741c;\npub const TIOCMSET: ::c_ulong = 0x741a;\npub const FIONREAD: ::c_ulong = 0x467f;\npub const TIOCCONS: ::c_ulong = 0x80047478;\n\npub const RTLD_DEEPBIND: ::c_int = 0x10;\npub const RTLD_GLOBAL: ::c_int = 0x4;\npub const RTLD_NOLOAD: ::c_int = 0x8;\n\npub const MCL_CURRENT: ::c_int = 0x0001;\npub const MCL_FUTURE: ::c_int = 0x0002;\n\npub const SIGSTKSZ: ::size_t = 8192;\npub const MINSIGSTKSZ: ::size_t = 2048;\npub const CBAUD: ::tcflag_t = 0o0010017;\npub const TAB1: ::tcflag_t = 0x00000800;\npub const TAB2: ::tcflag_t = 0x00001000;\npub const TAB3: ::tcflag_t = 0x00001800;\npub const CR1: ::tcflag_t = 0x00000200;\npub const CR2: ::tcflag_t = 0x00000400;\npub const CR3: ::tcflag_t = 0x00000600;\npub const FF1: ::tcflag_t = 0x00008000;\npub const BS1: ::tcflag_t = 0x00002000;\npub const VT1: ::tcflag_t = 0x00004000;\npub const VWERASE: usize = 14;\npub const VREPRINT: usize = 12;\npub const VSUSP: usize = 10;\npub const VSTART: usize = 8;\npub const VSTOP: usize = 9;\npub const VDISCARD: usize = 13;\npub const VTIME: usize = 5;\npub const IXON: ::tcflag_t = 0x00000400;\npub const IXOFF: ::tcflag_t = 0x00001000;\npub const ONLCR: ::tcflag_t = 0x4;\npub const CSIZE: ::tcflag_t = 0x00000030;\npub const CS6: ::tcflag_t = 0x00000010;\npub const CS7: ::tcflag_t = 0x00000020;\npub const CS8: ::tcflag_t = 0x00000030;\npub const CSTOPB: ::tcflag_t = 0x00000040;\npub const CREAD: ::tcflag_t = 0x00000080;\npub const PARENB: ::tcflag_t = 0x00000100;\npub const PARODD: ::tcflag_t = 0x00000200;\npub const HUPCL: ::tcflag_t = 0x00000400;\npub const CLOCAL: ::tcflag_t = 0x00000800;\npub const ECHOKE: ::tcflag_t = 0x00000800;\npub const ECHOE: ::tcflag_t = 0x00000010;\npub const ECHOK: ::tcflag_t = 0x00000020;\npub const ECHONL: ::tcflag_t = 0x00000040;\npub const ECHOPRT: ::tcflag_t = 0x00000400;\npub const ECHOCTL: ::tcflag_t = 0x00000200;\npub const ISIG: ::tcflag_t = 0x00000001;\npub const ICANON: ::tcflag_t = 0x00000002;\npub const PENDIN: ::tcflag_t = 0x00004000;\npub const NOFLSH: ::tcflag_t = 0x00000080;\npub const CIBAUD: ::tcflag_t = 0o02003600000;\npub const CBAUDEX: ::tcflag_t = 0o010000;\npub const VSWTC: usize = 7;\npub const OLCUC: ::tcflag_t = 0o000002;\npub const NLDLY: ::tcflag_t = 0o000400;\npub const CRDLY: ::tcflag_t = 0o003000;\npub const TABDLY: ::tcflag_t = 0o014000;\npub const BSDLY: ::tcflag_t = 0o020000;\npub const FFDLY: ::tcflag_t = 0o100000;\npub const VTDLY: ::tcflag_t = 0o040000;\npub const XTABS: ::tcflag_t = 0o014000;\n\npub const B0: ::speed_t = 0o000000;\npub const B50: ::speed_t = 0o000001;\npub const B75: ::speed_t = 0o000002;\npub const B110: ::speed_t = 0o000003;\npub const B134: ::speed_t = 0o000004;\npub const B150: ::speed_t = 0o000005;\npub const B200: ::speed_t = 0o000006;\npub const B300: ::speed_t = 0o000007;\npub const B600: ::speed_t = 0o000010;\npub const B1200: ::speed_t = 0o000011;\npub const B1800: ::speed_t = 0o000012;\npub const B2400: ::speed_t = 0o000013;\npub const B4800: ::speed_t = 0o000014;\npub const B9600: ::speed_t = 0o000015;\npub const B19200: ::speed_t = 0o000016;\npub const B38400: ::speed_t = 0o000017;\npub const EXTA: ::speed_t = B19200;\npub const EXTB: ::speed_t = B38400;\npub const BOTHER: ::speed_t = 0o010000;\npub const B57600: ::speed_t = 0o010001;\npub const B115200: ::speed_t = 0o010002;\npub const B230400: ::speed_t = 0o010003;\npub const B460800: ::speed_t = 0o010004;\npub const B500000: ::speed_t = 0o010005;\npub const B576000: ::speed_t = 0o010006;\npub const B921600: ::speed_t = 0o010007;\npub const B1000000: ::speed_t = 0o010010;\npub const B1152000: ::speed_t = 0o010011;\npub const B1500000: ::speed_t = 0o010012;\npub const B2000000: ::speed_t = 0o010013;\npub const B2500000: ::speed_t = 0o010014;\npub const B3000000: ::speed_t = 0o010015;\npub const B3500000: ::speed_t = 0o010016;\npub const B4000000: ::speed_t = 0o010017;\n\npub const TIOCM_ST: ::c_int = 0x010;\npub const TIOCM_SR: ::c_int = 0x020;\npub const TIOCM_CTS: ::c_int = 0x040;\npub const TIOCM_CAR: ::c_int = 0x100;\npub const TIOCM_RNG: ::c_int = 0x200;\npub const TIOCM_DSR: ::c_int = 0x400;\n\npub const EHWPOISON: ::c_int = 168;\n\nextern \"C\" {\n    pub fn sysctl(\n        name: *mut ::c_int,\n        namelen: ::c_int,\n        oldp: *mut ::c_void,\n        oldlenp: *mut ::size_t,\n        newp: *mut ::c_void,\n        newlen: ::size_t,\n    ) -> ::c_int;\n}\n\ncfg_if! {\n    if #[cfg(libc_align)] {\n        mod align;\n        pub use self::align::*;\n    }\n}\n"],["1180","s_no_extra_traits! {\n    #[allow(missing_debug_implementations)]\n    #[repr(align(16))]\n    pub struct max_align_t {\n        priv_: [f64; 4]\n    }\n}\n"],["1181","s_no_extra_traits! {\n    #[allow(missing_debug_implementations)]\n    #[repr(align(16))]\n    pub struct max_align_t {\n        priv_: [i64; 4]\n    }\n}\n"],["1182","//! SPARC64-specific definitions for 64-bit linux-like values\n\nuse pthread_mutex_t;\n\npub type c_long = i64;\npub type c_ulong = u64;\npub type c_char = i8;\npub type wchar_t = i32;\npub type nlink_t = u32;\npub type blksize_t = i64;\npub type suseconds_t = i32;\npub type __u64 = ::c_ulonglong;\n\ns! {\n    pub struct sigaction {\n        pub sa_sigaction: ::sighandler_t,\n        pub sa_mask: ::sigset_t,\n        #[cfg(target_arch = \"sparc64\")]\n        __reserved0: ::c_int,\n        pub sa_flags: ::c_int,\n        pub sa_restorer: ::Option<extern fn()>,\n    }\n\n    pub struct statfs {\n        pub f_type: ::__fsword_t,\n        pub f_bsize: ::__fsword_t,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n\n        pub f_namelen: ::__fsword_t,\n        pub f_frsize: ::__fsword_t,\n        f_spare: [::__fsword_t; 5],\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_errno: ::c_int,\n        pub si_code: ::c_int,\n        #[doc(hidden)]\n        #[deprecated(\n            since=\"0.2.54\",\n            note=\"Please leave a comment on \\\n                  https://github.com/rust-lang/libc/pull/1316 if you're using \\\n                  this field\"\n        )]\n        pub _pad: [::c_int; 29],\n        _align: [usize; 0],\n    }\n\n    pub struct flock {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off_t,\n        pub l_len: ::off_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct flock64 {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off64_t,\n        pub l_len: ::off64_t,\n        pub l_pid: ::pid_t,\n        __reserved:  ::c_short,\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_flags: ::c_int,\n        pub ss_size: ::size_t\n    }\n\n    pub struct stat {\n        pub st_dev: ::dev_t,\n        __pad0: u64,\n        pub st_ino: ::ino_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        __pad1: u64,\n        pub st_size: ::off_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __unused: [::c_long; 2],\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::dev_t,\n        __pad0: u64,\n        pub st_ino: ::ino64_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        __pad2: ::c_int,\n        pub st_size: ::off64_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt64_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __reserved: [::c_long; 2],\n    }\n\n    pub struct statfs64 {\n        pub f_type: ::__fsword_t,\n        pub f_bsize: ::__fsword_t,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::__fsword_t,\n        pub f_frsize: ::__fsword_t,\n        pub f_flags: ::__fsword_t,\n        pub f_spare: [::__fsword_t; 4],\n    }\n\n    pub struct statvfs {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_favail: ::fsfilcnt_t,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_favail: u64,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct pthread_attr_t {\n        __size: [u64; 7]\n    }\n\n    pub struct ipc_perm {\n        pub __key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::mode_t,\n        __pad0: u16,\n        pub __seq: ::c_ushort,\n        __unused1: ::c_ulonglong,\n        __unused2: ::c_ulonglong,\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        pub shm_atime: ::time_t,\n        pub shm_dtime: ::time_t,\n        pub shm_ctime: ::time_t,\n        pub shm_segsz: ::size_t,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::shmatt_t,\n        __reserved1: ::c_ulong,\n        __reserved2: ::c_ulong\n    }\n\n    pub struct termios2 {\n        pub c_iflag: ::tcflag_t,\n        pub c_oflag: ::tcflag_t,\n        pub c_cflag: ::tcflag_t,\n        pub c_lflag: ::tcflag_t,\n        pub c_line: ::cc_t,\n        pub c_cc: [::cc_t; 19],\n        pub c_ispeed: ::speed_t,\n        pub c_ospeed: ::speed_t,\n    }\n}\n\npub const POSIX_FADV_DONTNEED: ::c_int = 4;\npub const POSIX_FADV_NOREUSE: ::c_int = 5;\n\npub const VEOF: usize = 4;\npub const RTLD_DEEPBIND: ::c_int = 0x8;\npub const RTLD_GLOBAL: ::c_int = 0x100;\npub const RTLD_NOLOAD: ::c_int = 0x4;\npub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;\n\npub const TIOCGSOFTCAR: ::c_ulong = 0x40047464;\npub const TIOCSSOFTCAR: ::c_ulong = 0x80047465;\n\npub const RLIMIT_RSS: ::__rlimit_resource_t = 5;\npub const RLIMIT_AS: ::__rlimit_resource_t = 9;\npub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 8;\npub const RLIMIT_NOFILE: ::__rlimit_resource_t = 6;\npub const RLIMIT_NPROC: ::__rlimit_resource_t = 7;\n\npub const O_APPEND: ::c_int = 0x8;\npub const O_CREAT: ::c_int = 0x200;\npub const O_EXCL: ::c_int = 0x800;\npub const O_NOCTTY: ::c_int = 0x8000;\npub const O_NONBLOCK: ::c_int = 0x4000;\npub const O_SYNC: ::c_int = 0x802000;\npub const O_RSYNC: ::c_int = 0x802000;\npub const O_DSYNC: ::c_int = 0x2000;\npub const O_FSYNC: ::c_int = 0x802000;\npub const O_NOATIME: ::c_int = 0x200000;\npub const O_PATH: ::c_int = 0x1000000;\npub const O_TMPFILE: ::c_int = 0x2000000 | O_DIRECTORY;\n\npub const MADV_SOFT_OFFLINE: ::c_int = 101;\npub const MAP_GROWSDOWN: ::c_int = 0x0200;\npub const MAP_ANON: ::c_int = 0x0020;\npub const MAP_ANONYMOUS: ::c_int = 0x0020;\npub const MAP_DENYWRITE: ::c_int = 0x0800;\npub const MAP_EXECUTABLE: ::c_int = 0x01000;\npub const MAP_POPULATE: ::c_int = 0x08000;\npub const MAP_NONBLOCK: ::c_int = 0x010000;\npub const MAP_STACK: ::c_int = 0x020000;\npub const MAP_HUGETLB: ::c_int = 0x040000;\npub const MAP_SYNC: ::c_int = 0x080000;\n\npub const EDEADLK: ::c_int = 78;\npub const ENAMETOOLONG: ::c_int = 63;\npub const ENOLCK: ::c_int = 79;\npub const ENOSYS: ::c_int = 90;\npub const ENOTEMPTY: ::c_int = 66;\npub const ELOOP: ::c_int = 62;\npub const ENOMSG: ::c_int = 75;\npub const EIDRM: ::c_int = 77;\npub const ECHRNG: ::c_int = 94;\npub const EL2NSYNC: ::c_int = 95;\npub const EL3HLT: ::c_int = 96;\npub const EL3RST: ::c_int = 97;\npub const ELNRNG: ::c_int = 98;\npub const EUNATCH: ::c_int = 99;\npub const ENOCSI: ::c_int = 100;\npub const EL2HLT: ::c_int = 101;\npub const EBADE: ::c_int = 102;\npub const EBADR: ::c_int = 103;\npub const EXFULL: ::c_int = 104;\npub const ENOANO: ::c_int = 105;\npub const EBADRQC: ::c_int = 106;\npub const EBADSLT: ::c_int = 107;\npub const EMULTIHOP: ::c_int = 87;\npub const EOVERFLOW: ::c_int = 92;\npub const ENOTUNIQ: ::c_int = 115;\npub const EBADFD: ::c_int = 93;\npub const EBADMSG: ::c_int = 76;\npub const EREMCHG: ::c_int = 89;\npub const ELIBACC: ::c_int = 114;\npub const ELIBBAD: ::c_int = 112;\npub const ELIBSCN: ::c_int = 124;\npub const ELIBMAX: ::c_int = 123;\npub const ELIBEXEC: ::c_int = 110;\npub const EILSEQ: ::c_int = 122;\npub const ERESTART: ::c_int = 116;\npub const ESTRPIPE: ::c_int = 91;\npub const EUSERS: ::c_int = 68;\npub const ENOTSOCK: ::c_int = 38;\npub const EDESTADDRREQ: ::c_int = 39;\npub const EMSGSIZE: ::c_int = 40;\npub const EPROTOTYPE: ::c_int = 41;\npub const ENOPROTOOPT: ::c_int = 42;\npub const EPROTONOSUPPORT: ::c_int = 43;\npub const ESOCKTNOSUPPORT: ::c_int = 44;\npub const EOPNOTSUPP: ::c_int = 45;\npub const EPFNOSUPPORT: ::c_int = 46;\npub const EAFNOSUPPORT: ::c_int = 47;\npub const EADDRINUSE: ::c_int = 48;\npub const EADDRNOTAVAIL: ::c_int = 49;\npub const ENETDOWN: ::c_int = 50;\npub const ENETUNREACH: ::c_int = 51;\npub const ENETRESET: ::c_int = 52;\npub const ECONNABORTED: ::c_int = 53;\npub const ECONNRESET: ::c_int = 54;\npub const ENOBUFS: ::c_int = 55;\npub const EISCONN: ::c_int = 56;\npub const ENOTCONN: ::c_int = 57;\npub const ESHUTDOWN: ::c_int = 58;\npub const ETOOMANYREFS: ::c_int = 59;\npub const ETIMEDOUT: ::c_int = 60;\npub const ECONNREFUSED: ::c_int = 61;\npub const EHOSTDOWN: ::c_int = 64;\npub const EHOSTUNREACH: ::c_int = 65;\npub const EALREADY: ::c_int = 37;\npub const EINPROGRESS: ::c_int = 36;\npub const ESTALE: ::c_int = 70;\npub const EDQUOT: ::c_int = 69;\npub const ENOMEDIUM: ::c_int = 125;\npub const EMEDIUMTYPE: ::c_int = 126;\npub const ECANCELED: ::c_int = 127;\npub const ENOKEY: ::c_int = 128;\npub const EKEYEXPIRED: ::c_int = 129;\npub const EKEYREVOKED: ::c_int = 130;\npub const EKEYREJECTED: ::c_int = 131;\npub const EOWNERDEAD: ::c_int = 132;\npub const ENOTRECOVERABLE: ::c_int = 133;\npub const EHWPOISON: ::c_int = 135;\npub const ERFKILL: ::c_int = 134;\n\npub const SOCK_STREAM: ::c_int = 1;\npub const SOCK_DGRAM: ::c_int = 2;\n\npub const SA_ONSTACK: ::c_int = 1;\npub const SA_SIGINFO: ::c_int = 0x200;\npub const SA_NOCLDWAIT: ::c_int = 0x100;\n\npub const SIGTTIN: ::c_int = 21;\npub const SIGTTOU: ::c_int = 22;\npub const SIGXCPU: ::c_int = 24;\npub const SIGXFSZ: ::c_int = 25;\npub const SIGVTALRM: ::c_int = 26;\npub const SIGPROF: ::c_int = 27;\npub const SIGWINCH: ::c_int = 28;\npub const SIGCHLD: ::c_int = 20;\npub const SIGBUS: ::c_int = 10;\npub const SIGUSR1: ::c_int = 30;\npub const SIGUSR2: ::c_int = 31;\npub const SIGCONT: ::c_int = 19;\npub const SIGSTOP: ::c_int = 17;\npub const SIGTSTP: ::c_int = 18;\npub const SIGURG: ::c_int = 16;\npub const SIGIO: ::c_int = 23;\npub const SIGSYS: ::c_int = 12;\npub const SIGPOLL: ::c_int = 23;\npub const SIGPWR: ::c_int = 29;\npub const SIG_SETMASK: ::c_int = 4;\npub const SIG_BLOCK: ::c_int = 1;\npub const SIG_UNBLOCK: ::c_int = 2;\n\npub const POLLWRNORM: ::c_short = 4;\npub const POLLWRBAND: ::c_short = 0x100;\n\npub const O_ASYNC: ::c_int = 0x40;\npub const O_NDELAY: ::c_int = 0x4004;\n\npub const PTRACE_DETACH: ::c_uint = 11;\n\npub const EFD_NONBLOCK: ::c_int = 0x4000;\n\npub const F_GETLK: ::c_int = 7;\npub const F_GETOWN: ::c_int = 5;\npub const F_SETOWN: ::c_int = 6;\npub const F_SETLK: ::c_int = 8;\npub const F_SETLKW: ::c_int = 9;\npub const F_OFD_GETLK: ::c_int = 36;\npub const F_OFD_SETLK: ::c_int = 37;\npub const F_OFD_SETLKW: ::c_int = 38;\n\npub const F_RDLCK: ::c_int = 1;\npub const F_WRLCK: ::c_int = 2;\npub const F_UNLCK: ::c_int = 3;\n\npub const SFD_NONBLOCK: ::c_int = 0x4000;\n\npub const TCSANOW: ::c_int = 0;\npub const TCSADRAIN: ::c_int = 1;\npub const TCSAFLUSH: ::c_int = 2;\n\npub const TIOCLINUX: ::c_ulong = 0x541C;\npub const TIOCGSERIAL: ::c_ulong = 0x541E;\npub const TIOCEXCL: ::c_ulong = 0x2000740d;\npub const TIOCNXCL: ::c_ulong = 0x2000740e;\npub const TIOCCONS: ::c_ulong = 0x20007424;\npub const TIOCMGET: ::c_ulong = 0x4004746a;\npub const TIOCMBIC: ::c_ulong = 0x8004746b;\npub const TIOCMBIS: ::c_ulong = 0x8004746c;\npub const TIOCMSET: ::c_ulong = 0x8004746d;\npub const TIOCSTI: ::c_ulong = 0x80017472;\npub const TIOCCBRK: ::c_ulong = 0x2000747a;\npub const TIOCSBRK: ::c_ulong = 0x2000747b;\npub const TIOCSCTTY: ::c_ulong = 0x20007484;\n\npub const TIOCM_ST: ::c_int = 0x008;\npub const TIOCM_SR: ::c_int = 0x010;\npub const TIOCM_CTS: ::c_int = 0x020;\npub const TIOCM_CAR: ::c_int = 0x040;\npub const TIOCM_RNG: ::c_int = 0x080;\npub const TIOCM_DSR: ::c_int = 0x100;\n\npub const SFD_CLOEXEC: ::c_int = 0x400000;\n\npub const NCCS: usize = 17;\npub const O_TRUNC: ::c_int = 0x400;\n\npub const O_CLOEXEC: ::c_int = 0x400000;\n\npub const EBFONT: ::c_int = 109;\npub const ENOSTR: ::c_int = 72;\npub const ENODATA: ::c_int = 111;\npub const ETIME: ::c_int = 73;\npub const ENOSR: ::c_int = 74;\npub const ENONET: ::c_int = 80;\npub const ENOPKG: ::c_int = 113;\npub const EREMOTE: ::c_int = 71;\npub const ENOLINK: ::c_int = 82;\npub const EADV: ::c_int = 83;\npub const ESRMNT: ::c_int = 84;\npub const ECOMM: ::c_int = 85;\npub const EPROTO: ::c_int = 86;\npub const EDOTDOT: ::c_int = 88;\n\npub const SA_NODEFER: ::c_int = 0x20;\npub const SA_RESETHAND: ::c_int = 0x4;\npub const SA_RESTART: ::c_int = 0x2;\npub const SA_NOCLDSTOP: ::c_int = 0x00000008;\n\npub const EPOLL_CLOEXEC: ::c_int = 0x400000;\n\npub const EFD_CLOEXEC: ::c_int = 0x400000;\npub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;\npub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;\npub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;\n\nalign_const! {\n    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        };\n}\n\npub const O_DIRECTORY: ::c_int = 0o200000;\npub const O_NOFOLLOW: ::c_int = 0o400000;\npub const O_DIRECT: ::c_int = 0x100000;\n\npub const MAP_LOCKED: ::c_int = 0x0100;\npub const MAP_NORESERVE: ::c_int = 0x00040;\n\npub const EDEADLOCK: ::c_int = 108;\npub const EUCLEAN: ::c_int = 117;\npub const ENOTNAM: ::c_int = 118;\npub const ENAVAIL: ::c_int = 119;\npub const EISNAM: ::c_int = 120;\npub const EREMOTEIO: ::c_int = 121;\n\npub const FIOCLEX: ::c_ulong = 0x20006601;\npub const FIONCLEX: ::c_ulong = 0x20006602;\npub const FIONBIO: ::c_ulong = 0x8004667e;\n\npub const MCL_CURRENT: ::c_int = 0x2000;\npub const MCL_FUTURE: ::c_int = 0x4000;\n\npub const SIGSTKSZ: ::size_t = 16384;\npub const MINSIGSTKSZ: ::size_t = 4096;\npub const CBAUD: ::tcflag_t = 0x0000100f;\npub const TAB1: ::tcflag_t = 0x800;\npub const TAB2: ::tcflag_t = 0x1000;\npub const TAB3: ::tcflag_t = 0x1800;\npub const CR1: ::tcflag_t = 0x200;\npub const CR2: ::tcflag_t = 0x400;\npub const CR3: ::tcflag_t = 0x600;\npub const FF1: ::tcflag_t = 0x8000;\npub const BS1: ::tcflag_t = 0x2000;\npub const VT1: ::tcflag_t = 0x4000;\npub const VWERASE: usize = 0xe;\npub const VREPRINT: usize = 0xc;\npub const VSUSP: usize = 0xa;\npub const VSTART: usize = 0x8;\npub const VSTOP: usize = 0x9;\npub const VDISCARD: usize = 0xd;\npub const VTIME: usize = 0x5;\npub const IXON: ::tcflag_t = 0x400;\npub const IXOFF: ::tcflag_t = 0x1000;\npub const ONLCR: ::tcflag_t = 0x4;\npub const CSIZE: ::tcflag_t = 0x30;\npub const CS6: ::tcflag_t = 0x10;\npub const CS7: ::tcflag_t = 0x20;\npub const CS8: ::tcflag_t = 0x30;\npub const CSTOPB: ::tcflag_t = 0x40;\npub const CREAD: ::tcflag_t = 0x80;\npub const PARENB: ::tcflag_t = 0x100;\npub const PARODD: ::tcflag_t = 0x200;\npub const HUPCL: ::tcflag_t = 0x400;\npub const CLOCAL: ::tcflag_t = 0x800;\npub const ECHOKE: ::tcflag_t = 0x800;\npub const ECHOE: ::tcflag_t = 0x10;\npub const ECHOK: ::tcflag_t = 0x20;\npub const ECHONL: ::tcflag_t = 0x40;\npub const ECHOPRT: ::tcflag_t = 0x400;\npub const ECHOCTL: ::tcflag_t = 0x200;\npub const ISIG: ::tcflag_t = 0x1;\npub const ICANON: ::tcflag_t = 0x2;\npub const PENDIN: ::tcflag_t = 0x4000;\npub const NOFLSH: ::tcflag_t = 0x80;\npub const CIBAUD: ::tcflag_t = 0o02003600000;\npub const CBAUDEX: ::tcflag_t = 0x00001000;\npub const VSWTC: usize = 7;\npub const OLCUC: ::tcflag_t = 0o000002;\npub const NLDLY: ::tcflag_t = 0o000400;\npub const CRDLY: ::tcflag_t = 0o003000;\npub const TABDLY: ::tcflag_t = 0o014000;\npub const BSDLY: ::tcflag_t = 0o020000;\npub const FFDLY: ::tcflag_t = 0o100000;\npub const VTDLY: ::tcflag_t = 0o040000;\npub const XTABS: ::tcflag_t = 0o014000;\n\npub const B0: ::speed_t = 0o000000;\npub const B50: ::speed_t = 0o000001;\npub const B75: ::speed_t = 0o000002;\npub const B110: ::speed_t = 0o000003;\npub const B134: ::speed_t = 0o000004;\npub const B150: ::speed_t = 0o000005;\npub const B200: ::speed_t = 0o000006;\npub const B300: ::speed_t = 0o000007;\npub const B600: ::speed_t = 0o000010;\npub const B1200: ::speed_t = 0o000011;\npub const B1800: ::speed_t = 0o000012;\npub const B2400: ::speed_t = 0o000013;\npub const B4800: ::speed_t = 0o000014;\npub const B9600: ::speed_t = 0o000015;\npub const B19200: ::speed_t = 0o000016;\npub const B38400: ::speed_t = 0o000017;\npub const EXTA: ::speed_t = B19200;\npub const EXTB: ::speed_t = B38400;\npub const BOTHER: ::speed_t = 0x1000;\npub const B57600: ::speed_t = 0x1001;\npub const B115200: ::speed_t = 0x1002;\npub const B230400: ::speed_t = 0x1003;\npub const B460800: ::speed_t = 0x1004;\npub const B76800: ::speed_t = 0x1005;\npub const B153600: ::speed_t = 0x1006;\npub const B307200: ::speed_t = 0x1007;\npub const B614400: ::speed_t = 0x1008;\npub const B921600: ::speed_t = 0x1009;\npub const B500000: ::speed_t = 0x100a;\npub const B576000: ::speed_t = 0x100b;\npub const B1000000: ::speed_t = 0x100c;\npub const B1152000: ::speed_t = 0x100d;\npub const B1500000: ::speed_t = 0x100e;\npub const B2000000: ::speed_t = 0x100f;\n\npub const VEOL: usize = 5;\npub const VEOL2: usize = 6;\npub const VMIN: usize = 4;\npub const IEXTEN: ::tcflag_t = 0x8000;\npub const TOSTOP: ::tcflag_t = 0x100;\npub const FLUSHO: ::tcflag_t = 0x1000;\npub const EXTPROC: ::tcflag_t = 0x10000;\npub const TCGETS: ::c_ulong = 0x40245408;\npub const TCSETS: ::c_ulong = 0x80245409;\npub const TCSETSW: ::c_ulong = 0x8024540a;\npub const TCSETSF: ::c_ulong = 0x8024540b;\npub const TCGETA: ::c_ulong = 0x40125401;\npub const TCSETA: ::c_ulong = 0x80125402;\npub const TCSETAW: ::c_ulong = 0x80125403;\npub const TCSETAF: ::c_ulong = 0x80125404;\npub const TCSBRK: ::c_ulong = 0x20005405;\npub const TCXONC: ::c_ulong = 0x20005406;\npub const TCFLSH: ::c_ulong = 0x20005407;\npub const TIOCINQ: ::c_ulong = 0x4004667f;\npub const TIOCGPGRP: ::c_ulong = 0x40047483;\npub const TIOCSPGRP: ::c_ulong = 0x80047482;\npub const TIOCOUTQ: ::c_ulong = 0x40047473;\npub const TIOCGWINSZ: ::c_ulong = 0x40087468;\npub const TIOCSWINSZ: ::c_ulong = 0x80087467;\npub const FIONREAD: ::c_ulong = 0x4004667f;\n\npub const SYS_restart_syscall: ::c_long = 0;\npub const SYS_exit: ::c_long = 1;\npub const SYS_fork: ::c_long = 2;\npub const SYS_read: ::c_long = 3;\npub const SYS_write: ::c_long = 4;\npub const SYS_open: ::c_long = 5;\npub const SYS_close: ::c_long = 6;\npub const SYS_wait4: ::c_long = 7;\npub const SYS_creat: ::c_long = 8;\npub const SYS_link: ::c_long = 9;\npub const SYS_unlink: ::c_long = 10;\npub const SYS_execv: ::c_long = 11;\npub const SYS_chdir: ::c_long = 12;\npub const SYS_chown: ::c_long = 13;\npub const SYS_mknod: ::c_long = 14;\npub const SYS_chmod: ::c_long = 15;\npub const SYS_lchown: ::c_long = 16;\npub const SYS_brk: ::c_long = 17;\npub const SYS_perfctr: ::c_long = 18;\npub const SYS_lseek: ::c_long = 19;\npub const SYS_getpid: ::c_long = 20;\npub const SYS_capget: ::c_long = 21;\npub const SYS_capset: ::c_long = 22;\npub const SYS_setuid: ::c_long = 23;\npub const SYS_getuid: ::c_long = 24;\npub const SYS_vmsplice: ::c_long = 25;\npub const SYS_ptrace: ::c_long = 26;\npub const SYS_alarm: ::c_long = 27;\npub const SYS_sigaltstack: ::c_long = 28;\npub const SYS_pause: ::c_long = 29;\npub const SYS_utime: ::c_long = 30;\npub const SYS_access: ::c_long = 33;\npub const SYS_nice: ::c_long = 34;\npub const SYS_sync: ::c_long = 36;\npub const SYS_kill: ::c_long = 37;\npub const SYS_stat: ::c_long = 38;\npub const SYS_sendfile: ::c_long = 39;\npub const SYS_lstat: ::c_long = 40;\npub const SYS_dup: ::c_long = 41;\npub const SYS_pipe: ::c_long = 42;\npub const SYS_times: ::c_long = 43;\npub const SYS_umount2: ::c_long = 45;\npub const SYS_setgid: ::c_long = 46;\npub const SYS_getgid: ::c_long = 47;\npub const SYS_signal: ::c_long = 48;\npub const SYS_geteuid: ::c_long = 49;\npub const SYS_getegid: ::c_long = 50;\npub const SYS_acct: ::c_long = 51;\npub const SYS_memory_ordering: ::c_long = 52;\npub const SYS_ioctl: ::c_long = 54;\npub const SYS_reboot: ::c_long = 55;\npub const SYS_symlink: ::c_long = 57;\npub const SYS_readlink: ::c_long = 58;\npub const SYS_execve: ::c_long = 59;\npub const SYS_umask: ::c_long = 60;\npub const SYS_chroot: ::c_long = 61;\npub const SYS_fstat: ::c_long = 62;\npub const SYS_fstat64: ::c_long = 63;\npub const SYS_getpagesize: ::c_long = 64;\npub const SYS_msync: ::c_long = 65;\npub const SYS_vfork: ::c_long = 66;\npub const SYS_pread64: ::c_long = 67;\npub const SYS_pwrite64: ::c_long = 68;\npub const SYS_mmap: ::c_long = 71;\npub const SYS_munmap: ::c_long = 73;\npub const SYS_mprotect: ::c_long = 74;\npub const SYS_madvise: ::c_long = 75;\npub const SYS_vhangup: ::c_long = 76;\npub const SYS_mincore: ::c_long = 78;\npub const SYS_getgroups: ::c_long = 79;\npub const SYS_setgroups: ::c_long = 80;\npub const SYS_getpgrp: ::c_long = 81;\npub const SYS_setitimer: ::c_long = 83;\npub const SYS_swapon: ::c_long = 85;\npub const SYS_getitimer: ::c_long = 86;\npub const SYS_sethostname: ::c_long = 88;\npub const SYS_dup2: ::c_long = 90;\npub const SYS_fcntl: ::c_long = 92;\npub const SYS_select: ::c_long = 93;\npub const SYS_fsync: ::c_long = 95;\npub const SYS_setpriority: ::c_long = 96;\npub const SYS_socket: ::c_long = 97;\npub const SYS_connect: ::c_long = 98;\npub const SYS_accept: ::c_long = 99;\npub const SYS_getpriority: ::c_long = 100;\npub const SYS_rt_sigreturn: ::c_long = 101;\npub const SYS_rt_sigaction: ::c_long = 102;\npub const SYS_rt_sigprocmask: ::c_long = 103;\npub const SYS_rt_sigpending: ::c_long = 104;\npub const SYS_rt_sigtimedwait: ::c_long = 105;\npub const SYS_rt_sigqueueinfo: ::c_long = 106;\npub const SYS_rt_sigsuspend: ::c_long = 107;\npub const SYS_setresuid: ::c_long = 108;\npub const SYS_getresuid: ::c_long = 109;\npub const SYS_setresgid: ::c_long = 110;\npub const SYS_getresgid: ::c_long = 111;\npub const SYS_recvmsg: ::c_long = 113;\npub const SYS_sendmsg: ::c_long = 114;\npub const SYS_gettimeofday: ::c_long = 116;\npub const SYS_getrusage: ::c_long = 117;\npub const SYS_getsockopt: ::c_long = 118;\npub const SYS_getcwd: ::c_long = 119;\npub const SYS_readv: ::c_long = 120;\npub const SYS_writev: ::c_long = 121;\npub const SYS_settimeofday: ::c_long = 122;\npub const SYS_fchown: ::c_long = 123;\npub const SYS_fchmod: ::c_long = 124;\npub const SYS_recvfrom: ::c_long = 125;\npub const SYS_setreuid: ::c_long = 126;\npub const SYS_setregid: ::c_long = 127;\npub const SYS_rename: ::c_long = 128;\npub const SYS_truncate: ::c_long = 129;\npub const SYS_ftruncate: ::c_long = 130;\npub const SYS_flock: ::c_long = 131;\npub const SYS_lstat64: ::c_long = 132;\npub const SYS_sendto: ::c_long = 133;\npub const SYS_shutdown: ::c_long = 134;\npub const SYS_socketpair: ::c_long = 135;\npub const SYS_mkdir: ::c_long = 136;\npub const SYS_rmdir: ::c_long = 137;\npub const SYS_utimes: ::c_long = 138;\npub const SYS_stat64: ::c_long = 139;\npub const SYS_sendfile64: ::c_long = 140;\npub const SYS_getpeername: ::c_long = 141;\npub const SYS_futex: ::c_long = 142;\npub const SYS_gettid: ::c_long = 143;\npub const SYS_getrlimit: ::c_long = 144;\npub const SYS_setrlimit: ::c_long = 145;\npub const SYS_pivot_root: ::c_long = 146;\npub const SYS_prctl: ::c_long = 147;\npub const SYS_pciconfig_read: ::c_long = 148;\npub const SYS_pciconfig_write: ::c_long = 149;\npub const SYS_getsockname: ::c_long = 150;\npub const SYS_inotify_init: ::c_long = 151;\npub const SYS_inotify_add_watch: ::c_long = 152;\npub const SYS_poll: ::c_long = 153;\npub const SYS_getdents64: ::c_long = 154;\npub const SYS_inotify_rm_watch: ::c_long = 156;\npub const SYS_statfs: ::c_long = 157;\npub const SYS_fstatfs: ::c_long = 158;\npub const SYS_umount: ::c_long = 159;\npub const SYS_sched_set_affinity: ::c_long = 160;\npub const SYS_sched_get_affinity: ::c_long = 161;\npub const SYS_getdomainname: ::c_long = 162;\npub const SYS_setdomainname: ::c_long = 163;\npub const SYS_utrap_install: ::c_long = 164;\npub const SYS_quotactl: ::c_long = 165;\npub const SYS_set_tid_address: ::c_long = 166;\npub const SYS_mount: ::c_long = 167;\npub const SYS_ustat: ::c_long = 168;\npub const SYS_setxattr: ::c_long = 169;\npub const SYS_lsetxattr: ::c_long = 170;\npub const SYS_fsetxattr: ::c_long = 171;\npub const SYS_getxattr: ::c_long = 172;\npub const SYS_lgetxattr: ::c_long = 173;\npub const SYS_getdents: ::c_long = 174;\npub const SYS_setsid: ::c_long = 175;\npub const SYS_fchdir: ::c_long = 176;\npub const SYS_fgetxattr: ::c_long = 177;\npub const SYS_listxattr: ::c_long = 178;\npub const SYS_llistxattr: ::c_long = 179;\npub const SYS_flistxattr: ::c_long = 180;\npub const SYS_removexattr: ::c_long = 181;\npub const SYS_lremovexattr: ::c_long = 182;\npub const SYS_sigpending: ::c_long = 183;\npub const SYS_query_module: ::c_long = 184;\npub const SYS_setpgid: ::c_long = 185;\npub const SYS_fremovexattr: ::c_long = 186;\npub const SYS_tkill: ::c_long = 187;\npub const SYS_exit_group: ::c_long = 188;\npub const SYS_uname: ::c_long = 189;\npub const SYS_init_module: ::c_long = 190;\npub const SYS_personality: ::c_long = 191;\npub const SYS_remap_file_pages: ::c_long = 192;\npub const SYS_epoll_create: ::c_long = 193;\npub const SYS_epoll_ctl: ::c_long = 194;\npub const SYS_epoll_wait: ::c_long = 195;\npub const SYS_ioprio_set: ::c_long = 196;\npub const SYS_getppid: ::c_long = 197;\npub const SYS_sigaction: ::c_long = 198;\npub const SYS_sgetmask: ::c_long = 199;\npub const SYS_ssetmask: ::c_long = 200;\npub const SYS_sigsuspend: ::c_long = 201;\npub const SYS_oldlstat: ::c_long = 202;\npub const SYS_uselib: ::c_long = 203;\npub const SYS_readdir: ::c_long = 204;\npub const SYS_readahead: ::c_long = 205;\npub const SYS_socketcall: ::c_long = 206;\npub const SYS_syslog: ::c_long = 207;\npub const SYS_lookup_dcookie: ::c_long = 208;\npub const SYS_fadvise64: ::c_long = 209;\npub const SYS_fadvise64_64: ::c_long = 210;\npub const SYS_tgkill: ::c_long = 211;\npub const SYS_waitpid: ::c_long = 212;\npub const SYS_swapoff: ::c_long = 213;\npub const SYS_sysinfo: ::c_long = 214;\npub const SYS_ipc: ::c_long = 215;\npub const SYS_sigreturn: ::c_long = 216;\npub const SYS_clone: ::c_long = 217;\npub const SYS_ioprio_get: ::c_long = 218;\npub const SYS_adjtimex: ::c_long = 219;\npub const SYS_sigprocmask: ::c_long = 220;\npub const SYS_create_module: ::c_long = 221;\npub const SYS_delete_module: ::c_long = 222;\npub const SYS_get_kernel_syms: ::c_long = 223;\npub const SYS_getpgid: ::c_long = 224;\npub const SYS_bdflush: ::c_long = 225;\npub const SYS_sysfs: ::c_long = 226;\npub const SYS_afs_syscall: ::c_long = 227;\npub const SYS_setfsuid: ::c_long = 228;\npub const SYS_setfsgid: ::c_long = 229;\npub const SYS__newselect: ::c_long = 230;\npub const SYS_splice: ::c_long = 232;\npub const SYS_stime: ::c_long = 233;\npub const SYS_statfs64: ::c_long = 234;\npub const SYS_fstatfs64: ::c_long = 235;\npub const SYS__llseek: ::c_long = 236;\npub const SYS_mlock: ::c_long = 237;\npub const SYS_munlock: ::c_long = 238;\npub const SYS_mlockall: ::c_long = 239;\npub const SYS_munlockall: ::c_long = 240;\npub const SYS_sched_setparam: ::c_long = 241;\npub const SYS_sched_getparam: ::c_long = 242;\npub const SYS_sched_setscheduler: ::c_long = 243;\npub const SYS_sched_getscheduler: ::c_long = 244;\npub const SYS_sched_yield: ::c_long = 245;\npub const SYS_sched_get_priority_max: ::c_long = 246;\npub const SYS_sched_get_priority_min: ::c_long = 247;\npub const SYS_sched_rr_get_interval: ::c_long = 248;\npub const SYS_nanosleep: ::c_long = 249;\npub const SYS_mremap: ::c_long = 250;\npub const SYS__sysctl: ::c_long = 251;\npub const SYS_getsid: ::c_long = 252;\npub const SYS_fdatasync: ::c_long = 253;\npub const SYS_nfsservctl: ::c_long = 254;\npub const SYS_sync_file_range: ::c_long = 255;\npub const SYS_clock_settime: ::c_long = 256;\npub const SYS_clock_gettime: ::c_long = 257;\npub const SYS_clock_getres: ::c_long = 258;\npub const SYS_clock_nanosleep: ::c_long = 259;\npub const SYS_sched_getaffinity: ::c_long = 260;\npub const SYS_sched_setaffinity: ::c_long = 261;\npub const SYS_timer_settime: ::c_long = 262;\npub const SYS_timer_gettime: ::c_long = 263;\npub const SYS_timer_getoverrun: ::c_long = 264;\npub const SYS_timer_delete: ::c_long = 265;\npub const SYS_timer_create: ::c_long = 266;\npub const SYS_io_setup: ::c_long = 268;\npub const SYS_io_destroy: ::c_long = 269;\npub const SYS_io_submit: ::c_long = 270;\npub const SYS_io_cancel: ::c_long = 271;\npub const SYS_io_getevents: ::c_long = 272;\npub const SYS_mq_open: ::c_long = 273;\npub const SYS_mq_unlink: ::c_long = 274;\npub const SYS_mq_timedsend: ::c_long = 275;\npub const SYS_mq_timedreceive: ::c_long = 276;\npub const SYS_mq_notify: ::c_long = 277;\npub const SYS_mq_getsetattr: ::c_long = 278;\npub const SYS_waitid: ::c_long = 279;\npub const SYS_tee: ::c_long = 280;\npub const SYS_add_key: ::c_long = 281;\npub const SYS_request_key: ::c_long = 282;\npub const SYS_keyctl: ::c_long = 283;\npub const SYS_openat: ::c_long = 284;\npub const SYS_mkdirat: ::c_long = 285;\npub const SYS_mknodat: ::c_long = 286;\npub const SYS_fchownat: ::c_long = 287;\npub const SYS_futimesat: ::c_long = 288;\npub const SYS_fstatat64: ::c_long = 289;\npub const SYS_unlinkat: ::c_long = 290;\npub const SYS_renameat: ::c_long = 291;\npub const SYS_linkat: ::c_long = 292;\npub const SYS_symlinkat: ::c_long = 293;\npub const SYS_readlinkat: ::c_long = 294;\npub const SYS_fchmodat: ::c_long = 295;\npub const SYS_faccessat: ::c_long = 296;\npub const SYS_pselect6: ::c_long = 297;\npub const SYS_ppoll: ::c_long = 298;\npub const SYS_unshare: ::c_long = 299;\npub const SYS_set_robust_list: ::c_long = 300;\npub const SYS_get_robust_list: ::c_long = 301;\npub const SYS_migrate_pages: ::c_long = 302;\npub const SYS_mbind: ::c_long = 303;\npub const SYS_get_mempolicy: ::c_long = 304;\npub const SYS_set_mempolicy: ::c_long = 305;\npub const SYS_kexec_load: ::c_long = 306;\npub const SYS_move_pages: ::c_long = 307;\npub const SYS_getcpu: ::c_long = 308;\npub const SYS_epoll_pwait: ::c_long = 309;\npub const SYS_utimensat: ::c_long = 310;\npub const SYS_signalfd: ::c_long = 311;\npub const SYS_timerfd_create: ::c_long = 312;\npub const SYS_eventfd: ::c_long = 313;\npub const SYS_fallocate: ::c_long = 314;\npub const SYS_timerfd_settime: ::c_long = 315;\npub const SYS_timerfd_gettime: ::c_long = 316;\npub const SYS_signalfd4: ::c_long = 317;\npub const SYS_eventfd2: ::c_long = 318;\npub const SYS_epoll_create1: ::c_long = 319;\npub const SYS_dup3: ::c_long = 320;\npub const SYS_pipe2: ::c_long = 321;\npub const SYS_inotify_init1: ::c_long = 322;\npub const SYS_accept4: ::c_long = 323;\npub const SYS_preadv: ::c_long = 324;\npub const SYS_pwritev: ::c_long = 325;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 326;\npub const SYS_perf_event_open: ::c_long = 327;\npub const SYS_recvmmsg: ::c_long = 328;\npub const SYS_fanotify_init: ::c_long = 329;\npub const SYS_fanotify_mark: ::c_long = 330;\npub const SYS_prlimit64: ::c_long = 331;\npub const SYS_name_to_handle_at: ::c_long = 332;\npub const SYS_open_by_handle_at: ::c_long = 333;\npub const SYS_clock_adjtime: ::c_long = 334;\npub const SYS_syncfs: ::c_long = 335;\npub const SYS_sendmmsg: ::c_long = 336;\npub const SYS_setns: ::c_long = 337;\npub const SYS_process_vm_readv: ::c_long = 338;\npub const SYS_process_vm_writev: ::c_long = 339;\npub const SYS_kern_features: ::c_long = 340;\npub const SYS_kcmp: ::c_long = 341;\npub const SYS_finit_module: ::c_long = 342;\npub const SYS_sched_setattr: ::c_long = 343;\npub const SYS_sched_getattr: ::c_long = 344;\npub const SYS_renameat2: ::c_long = 345;\npub const SYS_seccomp: ::c_long = 346;\npub const SYS_getrandom: ::c_long = 347;\npub const SYS_memfd_create: ::c_long = 348;\npub const SYS_bpf: ::c_long = 349;\npub const SYS_execveat: ::c_long = 350;\npub const SYS_membarrier: ::c_long = 351;\npub const SYS_userfaultfd: ::c_long = 352;\npub const SYS_bind: ::c_long = 353;\npub const SYS_listen: ::c_long = 354;\npub const SYS_setsockopt: ::c_long = 355;\npub const SYS_mlock2: ::c_long = 356;\npub const SYS_copy_file_range: ::c_long = 357;\npub const SYS_preadv2: ::c_long = 358;\npub const SYS_pwritev2: ::c_long = 359;\npub const SYS_statx: ::c_long = 360;\npub const SYS_pidfd_send_signal: ::c_long = 424;\npub const SYS_io_uring_setup: ::c_long = 425;\npub const SYS_io_uring_enter: ::c_long = 426;\npub const SYS_io_uring_register: ::c_long = 427;\npub const SYS_open_tree: ::c_long = 428;\npub const SYS_move_mount: ::c_long = 429;\npub const SYS_fsopen: ::c_long = 430;\npub const SYS_fsconfig: ::c_long = 431;\npub const SYS_fsmount: ::c_long = 432;\npub const SYS_fspick: ::c_long = 433;\npub const SYS_pidfd_open: ::c_long = 434;\n// Reserved in the kernel, but not actually implemented yet\npub const SYS_clone3: ::c_long = 435;\npub const SYS_close_range: ::c_long = 436;\npub const SYS_openat2: ::c_long = 437;\npub const SYS_pidfd_getfd: ::c_long = 438;\npub const SYS_faccessat2: ::c_long = 439;\npub const SYS_process_madvise: ::c_long = 440;\npub const SYS_epoll_pwait2: ::c_long = 441;\npub const SYS_mount_setattr: ::c_long = 442;\n\nextern \"C\" {\n    pub fn sysctl(\n        name: *mut ::c_int,\n        namelen: ::c_int,\n        oldp: *mut ::c_void,\n        oldlenp: *mut ::size_t,\n        newp: *mut ::c_void,\n        newlen: ::size_t,\n    ) -> ::c_int;\n}\n\ncfg_if! {\n    if #[cfg(libc_align)] {\n        mod align;\n        pub use self::align::*;\n    }\n}\n"],["1183","//! 32-bit specific definitions for linux-like values\n\nuse pthread_mutex_t;\n\npub type c_long = i32;\npub type c_ulong = u32;\npub type clock_t = i32;\n\npub type shmatt_t = ::c_ulong;\npub type msgqnum_t = ::c_ulong;\npub type msglen_t = ::c_ulong;\npub type nlink_t = u32;\npub type __u64 = ::c_ulonglong;\npub type __fsword_t = i32;\npub type fsblkcnt64_t = u64;\npub type fsfilcnt64_t = u64;\n\ncfg_if! {\n    if #[cfg(target_arch = \"riscv32\")] {\n        pub type time_t = i64;\n        pub type suseconds_t = i64;\n        pub type ino_t = u64;\n        pub type off_t = i64;\n        pub type blkcnt_t = i64;\n        pub type fsblkcnt_t = u64;\n        pub type fsfilcnt_t = u64;\n        pub type rlim_t = u64;\n        pub type blksize_t = i64;\n    } else {\n        pub type time_t = i32;\n        pub type suseconds_t = i32;\n        pub type ino_t = u32;\n        pub type off_t = i32;\n        pub type blkcnt_t = i32;\n        pub type fsblkcnt_t = ::c_ulong;\n        pub type fsfilcnt_t = ::c_ulong;\n        pub type rlim_t = c_ulong;\n        pub type blksize_t = i32;\n    }\n}\n\ns! {\n    pub struct stat {\n        #[cfg(not(target_arch = \"mips\"))]\n        pub st_dev: ::dev_t,\n        #[cfg(target_arch = \"mips\")]\n        pub st_dev: ::c_ulong,\n\n        #[cfg(not(target_arch = \"mips\"))]\n        __pad1: ::c_short,\n        #[cfg(target_arch = \"mips\")]\n        st_pad1: [::c_long; 3],\n        pub st_ino: ::ino_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        #[cfg(not(target_arch = \"mips\"))]\n        pub st_rdev: ::dev_t,\n        #[cfg(target_arch = \"mips\")]\n        pub st_rdev: ::c_ulong,\n        #[cfg(not(target_arch = \"mips\"))]\n        __pad2: ::c_short,\n        #[cfg(target_arch = \"mips\")]\n        st_pad2: [::c_long; 2],\n        pub st_size: ::off_t,\n        #[cfg(target_arch = \"mips\")]\n        st_pad3: ::c_long,\n        #[cfg(not(target_arch = \"mips\"))]\n        pub st_blksize: ::blksize_t,\n        #[cfg(not(target_arch = \"mips\"))]\n        pub st_blocks: ::blkcnt_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        #[cfg(not(target_arch = \"mips\"))]\n        __unused4: ::c_long,\n        #[cfg(not(target_arch = \"mips\"))]\n        __unused5: ::c_long,\n        #[cfg(target_arch = \"mips\")]\n        pub st_blksize: ::blksize_t,\n        #[cfg(target_arch = \"mips\")]\n        pub st_blocks: ::blkcnt_t,\n        #[cfg(target_arch = \"mips\")]\n        st_pad5: [::c_long; 14],\n    }\n\n    pub struct statvfs {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_favail: ::fsfilcnt_t,\n        pub f_fsid: ::c_ulong,\n        __f_unused: ::c_int,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct pthread_attr_t {\n        __size: [u32; 9]\n    }\n\n    pub struct sigset_t {\n        __val: [::c_ulong; 32],\n    }\n\n    pub struct sysinfo {\n        pub uptime: ::c_long,\n        pub loads: [::c_ulong; 3],\n        pub totalram: ::c_ulong,\n        pub freeram: ::c_ulong,\n        pub sharedram: ::c_ulong,\n        pub bufferram: ::c_ulong,\n        pub totalswap: ::c_ulong,\n        pub freeswap: ::c_ulong,\n        pub procs: ::c_ushort,\n        #[deprecated(\n            since = \"0.2.58\",\n            note = \"This padding field might become private in the future\"\n        )]\n        pub pad: ::c_ushort,\n        pub totalhigh: ::c_ulong,\n        pub freehigh: ::c_ulong,\n        pub mem_unit: ::c_uint,\n        pub _f: [::c_char; 8],\n    }\n\n    pub struct ip_mreqn {\n        pub imr_multiaddr: ::in_addr,\n        pub imr_address: ::in_addr,\n        pub imr_ifindex: ::c_int,\n    }\n}\n\npub const POSIX_FADV_DONTNEED: ::c_int = 4;\npub const POSIX_FADV_NOREUSE: ::c_int = 5;\n\npub const F_OFD_GETLK: ::c_int = 36;\npub const F_OFD_SETLK: ::c_int = 37;\npub const F_OFD_SETLKW: ::c_int = 38;\n\npub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;\npub const __SIZEOF_PTHREAD_MUTEX_T: usize = 24;\npub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 32;\npub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;\npub const __SIZEOF_PTHREAD_RWLOCKATTR_T: usize = 8;\n\ncfg_if! {\n    if #[cfg(target_arch = \"sparc\")] {\n        pub const O_NOATIME: ::c_int = 0x200000;\n        pub const O_PATH: ::c_int = 0x1000000;\n        pub const O_TMPFILE: ::c_int = 0x2000000 | O_DIRECTORY;\n\n        pub const SA_ONSTACK: ::c_int = 1;\n\n        pub const PTRACE_DETACH: ::c_uint = 11;\n\n        pub const F_SETLK: ::c_int = 8;\n        pub const F_SETLKW: ::c_int = 9;\n\n        pub const F_RDLCK: ::c_int = 1;\n        pub const F_WRLCK: ::c_int = 2;\n        pub const F_UNLCK: ::c_int = 3;\n\n        pub const SFD_CLOEXEC: ::c_int = 0x400000;\n\n        pub const NCCS: usize = 17;\n\n        pub const O_TRUNC: ::c_int = 0x400;\n        pub const O_CLOEXEC: ::c_int = 0x400000;\n\n        pub const EBFONT: ::c_int = 109;\n        pub const ENOSTR: ::c_int = 72;\n        pub const ENODATA: ::c_int = 111;\n        pub const ETIME: ::c_int = 73;\n        pub const ENOSR: ::c_int = 74;\n        pub const ENONET: ::c_int = 80;\n        pub const ENOPKG: ::c_int = 113;\n        pub const EREMOTE: ::c_int = 71;\n        pub const ENOLINK: ::c_int = 82;\n        pub const EADV: ::c_int = 83;\n        pub const ESRMNT: ::c_int = 84;\n        pub const ECOMM: ::c_int = 85;\n        pub const EPROTO: ::c_int = 86;\n        pub const EDOTDOT: ::c_int = 88;\n\n        pub const SA_NODEFER: ::c_int = 0x20;\n        pub const SA_RESETHAND: ::c_int = 0x4;\n        pub const SA_RESTART: ::c_int = 0x2;\n        pub const SA_NOCLDSTOP: ::c_int = 0x00000008;\n\n        pub const EPOLL_CLOEXEC: ::c_int = 0x400000;\n\n        pub const EFD_CLOEXEC: ::c_int = 0x400000;\n    } else {\n        pub const O_NOATIME: ::c_int = 0o1000000;\n        pub const O_PATH: ::c_int = 0o10000000;\n        pub const O_TMPFILE: ::c_int = 0o20000000 | O_DIRECTORY;\n\n        pub const SA_ONSTACK: ::c_int = 0x08000000;\n\n        pub const PTRACE_DETACH: ::c_uint = 17;\n\n        pub const F_SETLK: ::c_int = 6;\n        pub const F_SETLKW: ::c_int = 7;\n\n        pub const F_RDLCK: ::c_int = 0;\n        pub const F_WRLCK: ::c_int = 1;\n        pub const F_UNLCK: ::c_int = 2;\n\n        pub const SFD_CLOEXEC: ::c_int = 0x080000;\n\n        pub const NCCS: usize = 32;\n\n        pub const O_TRUNC: ::c_int = 512;\n        pub const O_CLOEXEC: ::c_int = 0x80000;\n        pub const EBFONT: ::c_int = 59;\n        pub const ENOSTR: ::c_int = 60;\n        pub const ENODATA: ::c_int = 61;\n        pub const ETIME: ::c_int = 62;\n        pub const ENOSR: ::c_int = 63;\n        pub const ENONET: ::c_int = 64;\n        pub const ENOPKG: ::c_int = 65;\n        pub const EREMOTE: ::c_int = 66;\n        pub const ENOLINK: ::c_int = 67;\n        pub const EADV: ::c_int = 68;\n        pub const ESRMNT: ::c_int = 69;\n        pub const ECOMM: ::c_int = 70;\n        pub const EPROTO: ::c_int = 71;\n        pub const EDOTDOT: ::c_int = 73;\n\n        pub const SA_NODEFER: ::c_int = 0x40000000;\n        pub const SA_RESETHAND: ::c_int = 0x80000000;\n        pub const SA_RESTART: ::c_int = 0x10000000;\n        pub const SA_NOCLDSTOP: ::c_int = 0x00000001;\n\n        pub const EPOLL_CLOEXEC: ::c_int = 0x80000;\n\n        pub const EFD_CLOEXEC: ::c_int = 0x80000;\n    }\n}\n\nalign_const! {\n    #[cfg(target_endian = \"little\")]\n    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"little\")]\n    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"little\")]\n    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"big\")]\n    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,\n                0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"big\")]\n    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0,\n                0, 0, 0,\n            ],\n        };\n    #[cfg(target_endian = \"big\")]\n    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =\n        pthread_mutex_t {\n            size: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n                0, 0, 0,\n            ],\n        };\n}\n\npub const PTRACE_GETFPREGS: ::c_uint = 14;\npub const PTRACE_SETFPREGS: ::c_uint = 15;\npub const PTRACE_GETREGS: ::c_uint = 12;\npub const PTRACE_SETREGS: ::c_uint = 13;\n\npub const TIOCSBRK: ::c_int = 0x5427;\npub const TIOCCBRK: ::c_int = 0x5428;\n\nextern \"C\" {\n    pub fn sysctl(\n        name: *mut ::c_int,\n        namelen: ::c_int,\n        oldp: *mut ::c_void,\n        oldlenp: *mut ::size_t,\n        newp: *mut ::c_void,\n        newlen: ::size_t,\n    ) -> ::c_int;\n}\n\ncfg_if! {\n    if #[cfg(target_arch = \"x86\")] {\n        mod x86;\n        pub use self::x86::*;\n    } else if #[cfg(target_arch = \"arm\")] {\n        mod arm;\n        pub use self::arm::*;\n    } else if #[cfg(target_arch = \"mips\")] {\n        mod mips;\n        pub use self::mips::*;\n    } else if #[cfg(target_arch = \"powerpc\")] {\n        mod powerpc;\n        pub use self::powerpc::*;\n    } else if #[cfg(target_arch = \"sparc\")] {\n        mod sparc;\n        pub use self::sparc::*;\n    } else if #[cfg(target_arch = \"riscv32\")] {\n        mod riscv32;\n        pub use self::riscv32::*;\n    } else {\n        // Unknown target_arch\n    }\n}\n"],["1184","s_no_extra_traits! {\n    #[allow(missing_debug_implementations)]\n    #[repr(align(16))]\n    pub struct max_align_t {\n        priv_: [f64; 6]\n    }\n}\n"],["1185","pub type c_char = i8;\npub type wchar_t = i32;\npub type greg_t = i32;\n\ns! {\n    pub struct sigaction {\n        pub sa_sigaction: ::sighandler_t,\n        pub sa_mask: ::sigset_t,\n        pub sa_flags: ::c_int,\n        pub sa_restorer: ::Option<extern fn()>,\n    }\n\n    pub struct statfs {\n        pub f_type: ::__fsword_t,\n        pub f_bsize: ::__fsword_t,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n\n        pub f_namelen: ::__fsword_t,\n        pub f_frsize: ::__fsword_t,\n        f_spare: [::__fsword_t; 5],\n    }\n\n    pub struct flock {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off_t,\n        pub l_len: ::off_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct flock64 {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off64_t,\n        pub l_len: ::off64_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct _libc_fpreg {\n        pub significand: [u16; 4],\n        pub exponent: u16,\n    }\n\n    pub struct _libc_fpstate {\n        pub cw: ::c_ulong,\n        pub sw: ::c_ulong,\n        pub tag: ::c_ulong,\n        pub ipoff: ::c_ulong,\n        pub cssel: ::c_ulong,\n        pub dataoff: ::c_ulong,\n        pub datasel: ::c_ulong,\n        pub _st: [_libc_fpreg; 8],\n        pub status: ::c_ulong,\n    }\n\n    pub struct user_fpregs_struct {\n        pub cwd: ::c_long,\n        pub swd: ::c_long,\n        pub twd: ::c_long,\n        pub fip: ::c_long,\n        pub fcs: ::c_long,\n        pub foo: ::c_long,\n        pub fos: ::c_long,\n        pub st_space: [::c_long; 20],\n    }\n\n    pub struct user_regs_struct {\n        pub ebx: ::c_long,\n        pub ecx: ::c_long,\n        pub edx: ::c_long,\n        pub esi: ::c_long,\n        pub edi: ::c_long,\n        pub ebp: ::c_long,\n        pub eax: ::c_long,\n        pub xds: ::c_long,\n        pub xes: ::c_long,\n        pub xfs: ::c_long,\n        pub xgs: ::c_long,\n        pub orig_eax: ::c_long,\n        pub eip: ::c_long,\n        pub xcs: ::c_long,\n        pub eflags: ::c_long,\n        pub esp: ::c_long,\n        pub xss: ::c_long,\n    }\n\n    pub struct user {\n        pub regs: user_regs_struct,\n        pub u_fpvalid: ::c_int,\n        pub i387: user_fpregs_struct,\n        pub u_tsize: ::c_ulong,\n        pub u_dsize: ::c_ulong,\n        pub u_ssize: ::c_ulong,\n        pub start_code: ::c_ulong,\n        pub start_stack: ::c_ulong,\n        pub signal: ::c_long,\n        __reserved: ::c_int,\n        pub u_ar0: *mut user_regs_struct,\n        pub u_fpstate: *mut user_fpregs_struct,\n        pub magic: ::c_ulong,\n        pub u_comm: [c_char; 32],\n        pub u_debugreg: [::c_int; 8],\n    }\n\n    pub struct mcontext_t {\n        pub gregs: [greg_t; 19],\n        pub fpregs: *mut _libc_fpstate,\n        pub oldmask: ::c_ulong,\n        pub cr2: ::c_ulong,\n    }\n\n    pub struct ipc_perm {\n        pub __key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::c_ushort,\n        __pad1: ::c_ushort,\n        pub __seq: ::c_ushort,\n        __pad2: ::c_ushort,\n        __unused1: ::c_ulong,\n        __unused2: ::c_ulong\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::dev_t,\n        __pad1: ::c_uint,\n        __st_ino: ::ino_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        __pad2: ::c_uint,\n        pub st_size: ::off64_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt64_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        pub st_ino: ::ino64_t,\n    }\n\n    pub struct statfs64 {\n        pub f_type: ::__fsword_t,\n        pub f_bsize: ::__fsword_t,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::__fsword_t,\n        pub f_frsize: ::__fsword_t,\n        pub f_flags: ::__fsword_t,\n        pub f_spare: [::__fsword_t; 4],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_favail: u64,\n        pub f_fsid: ::c_ulong,\n        __f_unused: ::c_int,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        pub shm_segsz: ::size_t,\n        pub shm_atime: ::time_t,\n        __unused1: ::c_ulong,\n        pub shm_dtime: ::time_t,\n        __unused2: ::c_ulong,\n        pub shm_ctime: ::time_t,\n        __unused3: ::c_ulong,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::shmatt_t,\n        __unused4: ::c_ulong,\n        __unused5: ::c_ulong\n    }\n\n    pub struct msqid_ds {\n        pub msg_perm: ::ipc_perm,\n        pub msg_stime: ::time_t,\n        __glibc_reserved1: ::c_ulong,\n        pub msg_rtime: ::time_t,\n        __glibc_reserved2: ::c_ulong,\n        pub msg_ctime: ::time_t,\n        __glibc_reserved3: ::c_ulong,\n        __msg_cbytes: ::c_ulong,\n        pub msg_qnum: ::msgqnum_t,\n        pub msg_qbytes: ::msglen_t,\n        pub msg_lspid: ::pid_t,\n        pub msg_lrpid: ::pid_t,\n        __glibc_reserved4: ::c_ulong,\n        __glibc_reserved5: ::c_ulong,\n    }\n\n    pub struct termios2 {\n        pub c_iflag: ::tcflag_t,\n        pub c_oflag: ::tcflag_t,\n        pub c_cflag: ::tcflag_t,\n        pub c_lflag: ::tcflag_t,\n        pub c_line: ::cc_t,\n        pub c_cc: [::cc_t; 19],\n        pub c_ispeed: ::speed_t,\n        pub c_ospeed: ::speed_t,\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_errno: ::c_int,\n        pub si_code: ::c_int,\n        #[doc(hidden)]\n        #[deprecated(\n            since=\"0.2.54\",\n            note=\"Please leave a comment on \\\n                  https://github.com/rust-lang/libc/pull/1316 if you're using \\\n                  this field\"\n        )]\n        pub _pad: [::c_int; 29],\n        _align: [usize; 0],\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_flags: ::c_int,\n        pub ss_size: ::size_t\n    }\n}\n\ns_no_extra_traits! {\n    pub struct user_fpxregs_struct {\n        pub cwd: ::c_ushort,\n        pub swd: ::c_ushort,\n        pub twd: ::c_ushort,\n        pub fop: ::c_ushort,\n        pub fip: ::c_long,\n        pub fcs: ::c_long,\n        pub foo: ::c_long,\n        pub fos: ::c_long,\n        pub mxcsr: ::c_long,\n        __reserved: ::c_long,\n        pub st_space: [::c_long; 32],\n        pub xmm_space: [::c_long; 32],\n        padding: [::c_long; 56],\n    }\n\n    pub struct ucontext_t {\n        pub uc_flags: ::c_ulong,\n        pub uc_link: *mut ucontext_t,\n        pub uc_stack: ::stack_t,\n        pub uc_mcontext: mcontext_t,\n        pub uc_sigmask: ::sigset_t,\n        __private: [u8; 112],\n        __ssp: [::c_ulong; 4],\n    }\n}\n\ncfg_if! {\n    if #[cfg(feature = \"extra_traits\")] {\n        impl PartialEq for user_fpxregs_struct {\n            fn eq(&self, other: &user_fpxregs_struct) -> bool {\n                self.cwd == other.cwd\n                    && self.swd == other.swd\n                    && self.twd == other.twd\n                    && self.fop == other.fop\n                    && self.fip == other.fip\n                    && self.fcs == other.fcs\n                    && self.foo == other.foo\n                    && self.fos == other.fos\n                    && self.mxcsr == other.mxcsr\n                // Ignore __reserved field\n                    && self.st_space == other.st_space\n                    && self.xmm_space == other.xmm_space\n                // Ignore padding field\n            }\n        }\n\n        impl Eq for user_fpxregs_struct {}\n\n        impl ::fmt::Debug for user_fpxregs_struct {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"user_fpxregs_struct\")\n                    .field(\"cwd\", &self.cwd)\n                    .field(\"swd\", &self.swd)\n                    .field(\"twd\", &self.twd)\n                    .field(\"fop\", &self.fop)\n                    .field(\"fip\", &self.fip)\n                    .field(\"fcs\", &self.fcs)\n                    .field(\"foo\", &self.foo)\n                    .field(\"fos\", &self.fos)\n                    .field(\"mxcsr\", &self.mxcsr)\n                // Ignore __reserved field\n                    .field(\"st_space\", &self.st_space)\n                    .field(\"xmm_space\", &self.xmm_space)\n                // Ignore padding field\n                    .finish()\n            }\n        }\n\n        impl ::hash::Hash for user_fpxregs_struct {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.cwd.hash(state);\n                self.swd.hash(state);\n                self.twd.hash(state);\n                self.fop.hash(state);\n                self.fip.hash(state);\n                self.fcs.hash(state);\n                self.foo.hash(state);\n                self.fos.hash(state);\n                self.mxcsr.hash(state);\n                // Ignore __reserved field\n                self.st_space.hash(state);\n                self.xmm_space.hash(state);\n                // Ignore padding field\n            }\n        }\n\n        impl PartialEq for ucontext_t {\n            fn eq(&self, other: &ucontext_t) -> bool {\n                self.uc_flags == other.uc_flags\n                    && self.uc_link == other.uc_link\n                    && self.uc_stack == other.uc_stack\n                    && self.uc_mcontext == other.uc_mcontext\n                    && self.uc_sigmask == other.uc_sigmask\n                // Ignore __private field\n            }\n        }\n\n        impl Eq for ucontext_t {}\n\n        impl ::fmt::Debug for ucontext_t {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"ucontext_t\")\n                    .field(\"uc_flags\", &self.uc_flags)\n                    .field(\"uc_link\", &self.uc_link)\n                    .field(\"uc_stack\", &self.uc_stack)\n                    .field(\"uc_mcontext\", &self.uc_mcontext)\n                    .field(\"uc_sigmask\", &self.uc_sigmask)\n                // Ignore __private field\n                    .finish()\n            }\n        }\n\n        impl ::hash::Hash for ucontext_t {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.uc_flags.hash(state);\n                self.uc_link.hash(state);\n                self.uc_stack.hash(state);\n                self.uc_mcontext.hash(state);\n                self.uc_sigmask.hash(state);\n                // Ignore __private field\n            }\n        }\n    }\n}\n\npub const RLIM_INFINITY: ::rlim_t = !0;\npub const VEOF: usize = 4;\npub const RTLD_DEEPBIND: ::c_int = 0x8;\npub const RTLD_GLOBAL: ::c_int = 0x100;\npub const RTLD_NOLOAD: ::c_int = 0x4;\npub const O_DIRECT: ::c_int = 0x4000;\npub const O_DIRECTORY: ::c_int = 0x10000;\npub const O_NOFOLLOW: ::c_int = 0x20000;\npub const O_LARGEFILE: ::c_int = 0o0100000;\npub const O_APPEND: ::c_int = 1024;\npub const O_CREAT: ::c_int = 64;\npub const O_EXCL: ::c_int = 128;\npub const O_NOCTTY: ::c_int = 256;\npub const O_NONBLOCK: ::c_int = 2048;\npub const O_SYNC: ::c_int = 1052672;\npub const O_RSYNC: ::c_int = 1052672;\npub const O_DSYNC: ::c_int = 4096;\npub const O_FSYNC: ::c_int = 0x101000;\npub const O_ASYNC: ::c_int = 0x2000;\npub const O_NDELAY: ::c_int = 0x800;\npub const RLIMIT_NOFILE: ::__rlimit_resource_t = 7;\npub const RLIMIT_NPROC: ::__rlimit_resource_t = 6;\npub const RLIMIT_RSS: ::__rlimit_resource_t = 5;\npub const RLIMIT_AS: ::__rlimit_resource_t = 9;\npub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 8;\n\npub const MADV_SOFT_OFFLINE: ::c_int = 101;\npub const MAP_LOCKED: ::c_int = 0x02000;\npub const MAP_NORESERVE: ::c_int = 0x04000;\npub const MAP_32BIT: ::c_int = 0x0040;\npub const MAP_ANON: ::c_int = 0x0020;\npub const MAP_ANONYMOUS: ::c_int = 0x0020;\npub const MAP_DENYWRITE: ::c_int = 0x0800;\npub const MAP_EXECUTABLE: ::c_int = 0x01000;\npub const MAP_POPULATE: ::c_int = 0x08000;\npub const MAP_NONBLOCK: ::c_int = 0x010000;\npub const MAP_STACK: ::c_int = 0x020000;\npub const MAP_HUGETLB: ::c_int = 0x040000;\npub const MAP_GROWSDOWN: ::c_int = 0x0100;\npub const MAP_SYNC: ::c_int = 0x080000;\n\npub const EDEADLOCK: ::c_int = 35;\npub const EUCLEAN: ::c_int = 117;\npub const ENOTNAM: ::c_int = 118;\npub const ENAVAIL: ::c_int = 119;\npub const EISNAM: ::c_int = 120;\npub const EREMOTEIO: ::c_int = 121;\npub const EDEADLK: ::c_int = 35;\npub const ENAMETOOLONG: ::c_int = 36;\npub const ENOLCK: ::c_int = 37;\npub const ENOSYS: ::c_int = 38;\npub const ENOTEMPTY: ::c_int = 39;\npub const ELOOP: ::c_int = 40;\npub const ENOMSG: ::c_int = 42;\npub const EIDRM: ::c_int = 43;\npub const ECHRNG: ::c_int = 44;\npub const EL2NSYNC: ::c_int = 45;\npub const EL3HLT: ::c_int = 46;\npub const EL3RST: ::c_int = 47;\npub const ELNRNG: ::c_int = 48;\npub const EUNATCH: ::c_int = 49;\npub const ENOCSI: ::c_int = 50;\npub const EL2HLT: ::c_int = 51;\npub const EBADE: ::c_int = 52;\npub const EBADR: ::c_int = 53;\npub const EXFULL: ::c_int = 54;\npub const ENOANO: ::c_int = 55;\npub const EBADRQC: ::c_int = 56;\npub const EBADSLT: ::c_int = 57;\npub const EMULTIHOP: ::c_int = 72;\npub const EOVERFLOW: ::c_int = 75;\npub const ENOTUNIQ: ::c_int = 76;\npub const EBADFD: ::c_int = 77;\npub const EBADMSG: ::c_int = 74;\npub const EREMCHG: ::c_int = 78;\npub const ELIBACC: ::c_int = 79;\npub const ELIBBAD: ::c_int = 80;\npub const ELIBSCN: ::c_int = 81;\npub const ELIBMAX: ::c_int = 82;\npub const ELIBEXEC: ::c_int = 83;\npub const EILSEQ: ::c_int = 84;\npub const ERESTART: ::c_int = 85;\npub const ESTRPIPE: ::c_int = 86;\npub const EUSERS: ::c_int = 87;\npub const ENOTSOCK: ::c_int = 88;\npub const EDESTADDRREQ: ::c_int = 89;\npub const EMSGSIZE: ::c_int = 90;\npub const EPROTOTYPE: ::c_int = 91;\npub const ENOPROTOOPT: ::c_int = 92;\npub const EPROTONOSUPPORT: ::c_int = 93;\npub const ESOCKTNOSUPPORT: ::c_int = 94;\npub const EOPNOTSUPP: ::c_int = 95;\npub const EPFNOSUPPORT: ::c_int = 96;\npub const EAFNOSUPPORT: ::c_int = 97;\npub const EADDRINUSE: ::c_int = 98;\npub const EADDRNOTAVAIL: ::c_int = 99;\npub const ENETDOWN: ::c_int = 100;\npub const ENETUNREACH: ::c_int = 101;\npub const ENETRESET: ::c_int = 102;\npub const ECONNABORTED: ::c_int = 103;\npub const ECONNRESET: ::c_int = 104;\npub const ENOBUFS: ::c_int = 105;\npub const EISCONN: ::c_int = 106;\npub const ENOTCONN: ::c_int = 107;\npub const ESHUTDOWN: ::c_int = 108;\npub const ETOOMANYREFS: ::c_int = 109;\npub const ETIMEDOUT: ::c_int = 110;\npub const ECONNREFUSED: ::c_int = 111;\npub const EHOSTDOWN: ::c_int = 112;\npub const EHOSTUNREACH: ::c_int = 113;\npub const EALREADY: ::c_int = 114;\npub const EINPROGRESS: ::c_int = 115;\npub const ESTALE: ::c_int = 116;\npub const EDQUOT: ::c_int = 122;\npub const ENOMEDIUM: ::c_int = 123;\npub const EMEDIUMTYPE: ::c_int = 124;\npub const ECANCELED: ::c_int = 125;\npub const ENOKEY: ::c_int = 126;\npub const EKEYEXPIRED: ::c_int = 127;\npub const EKEYREVOKED: ::c_int = 128;\npub const EKEYREJECTED: ::c_int = 129;\npub const EOWNERDEAD: ::c_int = 130;\npub const ENOTRECOVERABLE: ::c_int = 131;\npub const EHWPOISON: ::c_int = 133;\npub const ERFKILL: ::c_int = 132;\n\npub const SA_SIGINFO: ::c_int = 0x00000004;\npub const SA_NOCLDWAIT: ::c_int = 0x00000002;\n\npub const SOCK_STREAM: ::c_int = 1;\npub const SOCK_DGRAM: ::c_int = 2;\n\npub const F_GETLK: ::c_int = 5;\npub const F_GETOWN: ::c_int = 9;\npub const F_SETOWN: ::c_int = 8;\n\npub const FIOCLEX: ::c_ulong = 0x5451;\npub const FIONCLEX: ::c_ulong = 0x5450;\npub const FIONBIO: ::c_ulong = 0x5421;\n\npub const PTRACE_GETFPXREGS: ::c_uint = 18;\npub const PTRACE_SETFPXREGS: ::c_uint = 19;\npub const PTRACE_SYSEMU: ::c_uint = 31;\npub const PTRACE_SYSEMU_SINGLESTEP: ::c_uint = 32;\n\npub const MCL_CURRENT: ::c_int = 0x0001;\npub const MCL_FUTURE: ::c_int = 0x0002;\n\npub const POLLWRNORM: ::c_short = 0x100;\npub const POLLWRBAND: ::c_short = 0x200;\n\npub const EFD_NONBLOCK: ::c_int = 0x800;\npub const SFD_NONBLOCK: ::c_int = 0x0800;\n\npub const SIGCHLD: ::c_int = 17;\npub const SIGBUS: ::c_int = 7;\npub const SIGUSR1: ::c_int = 10;\npub const SIGUSR2: ::c_int = 12;\npub const SIGCONT: ::c_int = 18;\npub const SIGSTOP: ::c_int = 19;\npub const SIGTSTP: ::c_int = 20;\npub const SIGURG: ::c_int = 23;\npub const SIGIO: ::c_int = 29;\npub const SIGSYS: ::c_int = 31;\npub const SIGSTKFLT: ::c_int = 16;\n#[deprecated(since = \"0.2.55\", note = \"Use SIGSYS instead\")]\npub const SIGUNUSED: ::c_int = 31;\npub const SIGPOLL: ::c_int = 29;\npub const SIGPWR: ::c_int = 30;\npub const SIG_SETMASK: ::c_int = 2;\npub const SIG_BLOCK: ::c_int = 0x000000;\npub const SIG_UNBLOCK: ::c_int = 0x01;\npub const SIGTTIN: ::c_int = 21;\npub const SIGTTOU: ::c_int = 22;\npub const SIGXCPU: ::c_int = 24;\npub const SIGXFSZ: ::c_int = 25;\npub const SIGVTALRM: ::c_int = 26;\npub const SIGPROF: ::c_int = 27;\npub const SIGWINCH: ::c_int = 28;\npub const SIGSTKSZ: ::size_t = 8192;\npub const MINSIGSTKSZ: ::size_t = 2048;\npub const CBAUD: ::tcflag_t = 0o0010017;\npub const TAB1: ::tcflag_t = 0x00000800;\npub const TAB2: ::tcflag_t = 0x00001000;\npub const TAB3: ::tcflag_t = 0x00001800;\npub const CR1: ::tcflag_t = 0x00000200;\npub const CR2: ::tcflag_t = 0x00000400;\npub const CR3: ::tcflag_t = 0x00000600;\npub const FF1: ::tcflag_t = 0x00008000;\npub const BS1: ::tcflag_t = 0x00002000;\npub const VT1: ::tcflag_t = 0x00004000;\npub const VWERASE: usize = 14;\npub const VREPRINT: usize = 12;\npub const VSUSP: usize = 10;\npub const VSTART: usize = 8;\npub const VSTOP: usize = 9;\npub const VDISCARD: usize = 13;\npub const VTIME: usize = 5;\npub const IXON: ::tcflag_t = 0x00000400;\npub const IXOFF: ::tcflag_t = 0x00001000;\npub const ONLCR: ::tcflag_t = 0x4;\npub const CSIZE: ::tcflag_t = 0x00000030;\npub const CS6: ::tcflag_t = 0x00000010;\npub const CS7: ::tcflag_t = 0x00000020;\npub const CS8: ::tcflag_t = 0x00000030;\npub const CSTOPB: ::tcflag_t = 0x00000040;\npub const CREAD: ::tcflag_t = 0x00000080;\npub const PARENB: ::tcflag_t = 0x00000100;\npub const PARODD: ::tcflag_t = 0x00000200;\npub const HUPCL: ::tcflag_t = 0x00000400;\npub const CLOCAL: ::tcflag_t = 0x00000800;\npub const ECHOKE: ::tcflag_t = 0x00000800;\npub const ECHOE: ::tcflag_t = 0x00000010;\npub const ECHOK: ::tcflag_t = 0x00000020;\npub const ECHONL: ::tcflag_t = 0x00000040;\npub const ECHOPRT: ::tcflag_t = 0x00000400;\npub const ECHOCTL: ::tcflag_t = 0x00000200;\npub const ISIG: ::tcflag_t = 0x00000001;\npub const ICANON: ::tcflag_t = 0x00000002;\npub const PENDIN: ::tcflag_t = 0x00004000;\npub const NOFLSH: ::tcflag_t = 0x00000080;\npub const CIBAUD: ::tcflag_t = 0o02003600000;\npub const CBAUDEX: ::tcflag_t = 0o010000;\npub const VSWTC: usize = 7;\npub const OLCUC: ::tcflag_t = 0o000002;\npub const NLDLY: ::tcflag_t = 0o000400;\npub const CRDLY: ::tcflag_t = 0o003000;\npub const TABDLY: ::tcflag_t = 0o014000;\npub const BSDLY: ::tcflag_t = 0o020000;\npub const FFDLY: ::tcflag_t = 0o100000;\npub const VTDLY: ::tcflag_t = 0o040000;\npub const XTABS: ::tcflag_t = 0o014000;\n\npub const TIOCGSOFTCAR: ::c_ulong = 0x5419;\npub const TIOCSSOFTCAR: ::c_ulong = 0x541A;\npub const TIOCEXCL: ::c_ulong = 0x540C;\npub const TIOCNXCL: ::c_ulong = 0x540D;\npub const TIOCSCTTY: ::c_ulong = 0x540E;\npub const TIOCSTI: ::c_ulong = 0x5412;\npub const TIOCMGET: ::c_ulong = 0x5415;\npub const TIOCMBIS: ::c_ulong = 0x5416;\npub const TIOCMBIC: ::c_ulong = 0x5417;\npub const TIOCMSET: ::c_ulong = 0x5418;\npub const TIOCCONS: ::c_ulong = 0x541D;\n\npub const B0: ::speed_t = 0o000000;\npub const B50: ::speed_t = 0o000001;\npub const B75: ::speed_t = 0o000002;\npub const B110: ::speed_t = 0o000003;\npub const B134: ::speed_t = 0o000004;\npub const B150: ::speed_t = 0o000005;\npub const B200: ::speed_t = 0o000006;\npub const B300: ::speed_t = 0o000007;\npub const B600: ::speed_t = 0o000010;\npub const B1200: ::speed_t = 0o000011;\npub const B1800: ::speed_t = 0o000012;\npub const B2400: ::speed_t = 0o000013;\npub const B4800: ::speed_t = 0o000014;\npub const B9600: ::speed_t = 0o000015;\npub const B19200: ::speed_t = 0o000016;\npub const B38400: ::speed_t = 0o000017;\npub const EXTA: ::speed_t = B19200;\npub const EXTB: ::speed_t = B38400;\npub const BOTHER: ::speed_t = 0o010000;\npub const B57600: ::speed_t = 0o010001;\npub const B115200: ::speed_t = 0o010002;\npub const B230400: ::speed_t = 0o010003;\npub const B460800: ::speed_t = 0o010004;\npub const B500000: ::speed_t = 0o010005;\npub const B576000: ::speed_t = 0o010006;\npub const B921600: ::speed_t = 0o010007;\npub const B1000000: ::speed_t = 0o010010;\npub const B1152000: ::speed_t = 0o010011;\npub const B1500000: ::speed_t = 0o010012;\npub const B2000000: ::speed_t = 0o010013;\npub const B2500000: ::speed_t = 0o010014;\npub const B3000000: ::speed_t = 0o010015;\npub const B3500000: ::speed_t = 0o010016;\npub const B4000000: ::speed_t = 0o010017;\n\npub const VEOL: usize = 11;\npub const VEOL2: usize = 16;\npub const VMIN: usize = 6;\npub const IEXTEN: ::tcflag_t = 0x00008000;\npub const TOSTOP: ::tcflag_t = 0x00000100;\npub const FLUSHO: ::tcflag_t = 0x00001000;\npub const EXTPROC: ::tcflag_t = 0x00010000;\npub const TCGETS: ::c_ulong = 0x5401;\npub const TCSETS: ::c_ulong = 0x5402;\npub const TCSETSW: ::c_ulong = 0x5403;\npub const TCSETSF: ::c_ulong = 0x5404;\npub const TCGETA: ::c_ulong = 0x5405;\npub const TCSETA: ::c_ulong = 0x5406;\npub const TCSETAW: ::c_ulong = 0x5407;\npub const TCSETAF: ::c_ulong = 0x5408;\npub const TCSBRK: ::c_ulong = 0x5409;\npub const TCXONC: ::c_ulong = 0x540A;\npub const TCFLSH: ::c_ulong = 0x540B;\npub const TIOCINQ: ::c_ulong = 0x541B;\npub const TIOCGPGRP: ::c_ulong = 0x540F;\npub const TIOCSPGRP: ::c_ulong = 0x5410;\npub const TIOCOUTQ: ::c_ulong = 0x5411;\npub const TIOCGWINSZ: ::c_ulong = 0x5413;\npub const TIOCSWINSZ: ::c_ulong = 0x5414;\npub const TIOCGRS485: ::c_int = 0x542E;\npub const TIOCSRS485: ::c_int = 0x542F;\npub const FIONREAD: ::c_ulong = 0x541B;\n\npub const TCSANOW: ::c_int = 0;\npub const TCSADRAIN: ::c_int = 1;\npub const TCSAFLUSH: ::c_int = 2;\n\npub const TIOCLINUX: ::c_ulong = 0x541C;\npub const TIOCGSERIAL: ::c_ulong = 0x541E;\npub const TIOCM_ST: ::c_int = 0x008;\npub const TIOCM_SR: ::c_int = 0x010;\npub const TIOCM_CTS: ::c_int = 0x020;\npub const TIOCM_CAR: ::c_int = 0x040;\npub const TIOCM_RNG: ::c_int = 0x080;\npub const TIOCM_DSR: ::c_int = 0x100;\n\n// Syscall table\npub const SYS_restart_syscall: ::c_long = 0;\npub const SYS_exit: ::c_long = 1;\npub const SYS_fork: ::c_long = 2;\npub const SYS_read: ::c_long = 3;\npub const SYS_write: ::c_long = 4;\npub const SYS_open: ::c_long = 5;\npub const SYS_close: ::c_long = 6;\npub const SYS_waitpid: ::c_long = 7;\npub const SYS_creat: ::c_long = 8;\npub const SYS_link: ::c_long = 9;\npub const SYS_unlink: ::c_long = 10;\npub const SYS_execve: ::c_long = 11;\npub const SYS_chdir: ::c_long = 12;\npub const SYS_time: ::c_long = 13;\npub const SYS_mknod: ::c_long = 14;\npub const SYS_chmod: ::c_long = 15;\npub const SYS_lchown: ::c_long = 16;\npub const SYS_break: ::c_long = 17;\npub const SYS_oldstat: ::c_long = 18;\npub const SYS_lseek: ::c_long = 19;\npub const SYS_getpid: ::c_long = 20;\npub const SYS_mount: ::c_long = 21;\npub const SYS_umount: ::c_long = 22;\npub const SYS_setuid: ::c_long = 23;\npub const SYS_getuid: ::c_long = 24;\npub const SYS_stime: ::c_long = 25;\npub const SYS_ptrace: ::c_long = 26;\npub const SYS_alarm: ::c_long = 27;\npub const SYS_oldfstat: ::c_long = 28;\npub const SYS_pause: ::c_long = 29;\npub const SYS_utime: ::c_long = 30;\npub const SYS_stty: ::c_long = 31;\npub const SYS_gtty: ::c_long = 32;\npub const SYS_access: ::c_long = 33;\npub const SYS_nice: ::c_long = 34;\npub const SYS_ftime: ::c_long = 35;\npub const SYS_sync: ::c_long = 36;\npub const SYS_kill: ::c_long = 37;\npub const SYS_rename: ::c_long = 38;\npub const SYS_mkdir: ::c_long = 39;\npub const SYS_rmdir: ::c_long = 40;\npub const SYS_dup: ::c_long = 41;\npub const SYS_pipe: ::c_long = 42;\npub const SYS_times: ::c_long = 43;\npub const SYS_prof: ::c_long = 44;\npub const SYS_brk: ::c_long = 45;\npub const SYS_setgid: ::c_long = 46;\npub const SYS_getgid: ::c_long = 47;\npub const SYS_signal: ::c_long = 48;\npub const SYS_geteuid: ::c_long = 49;\npub const SYS_getegid: ::c_long = 50;\npub const SYS_acct: ::c_long = 51;\npub const SYS_umount2: ::c_long = 52;\npub const SYS_lock: ::c_long = 53;\npub const SYS_ioctl: ::c_long = 54;\npub const SYS_fcntl: ::c_long = 55;\npub const SYS_mpx: ::c_long = 56;\npub const SYS_setpgid: ::c_long = 57;\npub const SYS_ulimit: ::c_long = 58;\npub const SYS_oldolduname: ::c_long = 59;\npub const SYS_umask: ::c_long = 60;\npub const SYS_chroot: ::c_long = 61;\npub const SYS_ustat: ::c_long = 62;\npub const SYS_dup2: ::c_long = 63;\npub const SYS_getppid: ::c_long = 64;\npub const SYS_getpgrp: ::c_long = 65;\npub const SYS_setsid: ::c_long = 66;\npub const SYS_sigaction: ::c_long = 67;\npub const SYS_sgetmask: ::c_long = 68;\npub const SYS_ssetmask: ::c_long = 69;\npub const SYS_setreuid: ::c_long = 70;\npub const SYS_setregid: ::c_long = 71;\npub const SYS_sigsuspend: ::c_long = 72;\npub const SYS_sigpending: ::c_long = 73;\npub const SYS_sethostname: ::c_long = 74;\npub const SYS_setrlimit: ::c_long = 75;\npub const SYS_getrlimit: ::c_long = 76;\npub const SYS_getrusage: ::c_long = 77;\npub const SYS_gettimeofday: ::c_long = 78;\npub const SYS_settimeofday: ::c_long = 79;\npub const SYS_getgroups: ::c_long = 80;\npub const SYS_setgroups: ::c_long = 81;\npub const SYS_select: ::c_long = 82;\npub const SYS_symlink: ::c_long = 83;\npub const SYS_oldlstat: ::c_long = 84;\npub const SYS_readlink: ::c_long = 85;\npub const SYS_uselib: ::c_long = 86;\npub const SYS_swapon: ::c_long = 87;\npub const SYS_reboot: ::c_long = 88;\npub const SYS_readdir: ::c_long = 89;\npub const SYS_mmap: ::c_long = 90;\npub const SYS_munmap: ::c_long = 91;\npub const SYS_truncate: ::c_long = 92;\npub const SYS_ftruncate: ::c_long = 93;\npub const SYS_fchmod: ::c_long = 94;\npub const SYS_fchown: ::c_long = 95;\npub const SYS_getpriority: ::c_long = 96;\npub const SYS_setpriority: ::c_long = 97;\npub const SYS_profil: ::c_long = 98;\npub const SYS_statfs: ::c_long = 99;\npub const SYS_fstatfs: ::c_long = 100;\npub const SYS_ioperm: ::c_long = 101;\npub const SYS_socketcall: ::c_long = 102;\npub const SYS_syslog: ::c_long = 103;\npub const SYS_setitimer: ::c_long = 104;\npub const SYS_getitimer: ::c_long = 105;\npub const SYS_stat: ::c_long = 106;\npub const SYS_lstat: ::c_long = 107;\npub const SYS_fstat: ::c_long = 108;\npub const SYS_olduname: ::c_long = 109;\npub const SYS_iopl: ::c_long = 110;\npub const SYS_vhangup: ::c_long = 111;\npub const SYS_idle: ::c_long = 112;\npub const SYS_vm86old: ::c_long = 113;\npub const SYS_wait4: ::c_long = 114;\npub const SYS_swapoff: ::c_long = 115;\npub const SYS_sysinfo: ::c_long = 116;\npub const SYS_ipc: ::c_long = 117;\npub const SYS_fsync: ::c_long = 118;\npub const SYS_sigreturn: ::c_long = 119;\npub const SYS_clone: ::c_long = 120;\npub const SYS_setdomainname: ::c_long = 121;\npub const SYS_uname: ::c_long = 122;\npub const SYS_modify_ldt: ::c_long = 123;\npub const SYS_adjtimex: ::c_long = 124;\npub const SYS_mprotect: ::c_long = 125;\npub const SYS_sigprocmask: ::c_long = 126;\npub const SYS_create_module: ::c_long = 127;\npub const SYS_init_module: ::c_long = 128;\npub const SYS_delete_module: ::c_long = 129;\npub const SYS_get_kernel_syms: ::c_long = 130;\npub const SYS_quotactl: ::c_long = 131;\npub const SYS_getpgid: ::c_long = 132;\npub const SYS_fchdir: ::c_long = 133;\npub const SYS_bdflush: ::c_long = 134;\npub const SYS_sysfs: ::c_long = 135;\npub const SYS_personality: ::c_long = 136;\npub const SYS_afs_syscall: ::c_long = 137;\npub const SYS_setfsuid: ::c_long = 138;\npub const SYS_setfsgid: ::c_long = 139;\npub const SYS__llseek: ::c_long = 140;\npub const SYS_getdents: ::c_long = 141;\npub const SYS__newselect: ::c_long = 142;\npub const SYS_flock: ::c_long = 143;\npub const SYS_msync: ::c_long = 144;\npub const SYS_readv: ::c_long = 145;\npub const SYS_writev: ::c_long = 146;\npub const SYS_getsid: ::c_long = 147;\npub const SYS_fdatasync: ::c_long = 148;\npub const SYS__sysctl: ::c_long = 149;\npub const SYS_mlock: ::c_long = 150;\npub const SYS_munlock: ::c_long = 151;\npub const SYS_mlockall: ::c_long = 152;\npub const SYS_munlockall: ::c_long = 153;\npub const SYS_sched_setparam: ::c_long = 154;\npub const SYS_sched_getparam: ::c_long = 155;\npub const SYS_sched_setscheduler: ::c_long = 156;\npub const SYS_sched_getscheduler: ::c_long = 157;\npub const SYS_sched_yield: ::c_long = 158;\npub const SYS_sched_get_priority_max: ::c_long = 159;\npub const SYS_sched_get_priority_min: ::c_long = 160;\npub const SYS_sched_rr_get_interval: ::c_long = 161;\npub const SYS_nanosleep: ::c_long = 162;\npub const SYS_mremap: ::c_long = 163;\npub const SYS_setresuid: ::c_long = 164;\npub const SYS_getresuid: ::c_long = 165;\npub const SYS_vm86: ::c_long = 166;\npub const SYS_query_module: ::c_long = 167;\npub const SYS_poll: ::c_long = 168;\npub const SYS_nfsservctl: ::c_long = 169;\npub const SYS_setresgid: ::c_long = 170;\npub const SYS_getresgid: ::c_long = 171;\npub const SYS_prctl: ::c_long = 172;\npub const SYS_rt_sigreturn: ::c_long = 173;\npub const SYS_rt_sigaction: ::c_long = 174;\npub const SYS_rt_sigprocmask: ::c_long = 175;\npub const SYS_rt_sigpending: ::c_long = 176;\npub const SYS_rt_sigtimedwait: ::c_long = 177;\npub const SYS_rt_sigqueueinfo: ::c_long = 178;\npub const SYS_rt_sigsuspend: ::c_long = 179;\npub const SYS_pread64: ::c_long = 180;\npub const SYS_pwrite64: ::c_long = 181;\npub const SYS_chown: ::c_long = 182;\npub const SYS_getcwd: ::c_long = 183;\npub const SYS_capget: ::c_long = 184;\npub const SYS_capset: ::c_long = 185;\npub const SYS_sigaltstack: ::c_long = 186;\npub const SYS_sendfile: ::c_long = 187;\npub const SYS_getpmsg: ::c_long = 188;\npub const SYS_putpmsg: ::c_long = 189;\npub const SYS_vfork: ::c_long = 190;\npub const SYS_ugetrlimit: ::c_long = 191;\npub const SYS_mmap2: ::c_long = 192;\npub const SYS_truncate64: ::c_long = 193;\npub const SYS_ftruncate64: ::c_long = 194;\npub const SYS_stat64: ::c_long = 195;\npub const SYS_lstat64: ::c_long = 196;\npub const SYS_fstat64: ::c_long = 197;\npub const SYS_lchown32: ::c_long = 198;\npub const SYS_getuid32: ::c_long = 199;\npub const SYS_getgid32: ::c_long = 200;\npub const SYS_geteuid32: ::c_long = 201;\npub const SYS_getegid32: ::c_long = 202;\npub const SYS_setreuid32: ::c_long = 203;\npub const SYS_setregid32: ::c_long = 204;\npub const SYS_getgroups32: ::c_long = 205;\npub const SYS_setgroups32: ::c_long = 206;\npub const SYS_fchown32: ::c_long = 207;\npub const SYS_setresuid32: ::c_long = 208;\npub const SYS_getresuid32: ::c_long = 209;\npub const SYS_setresgid32: ::c_long = 210;\npub const SYS_getresgid32: ::c_long = 211;\npub const SYS_chown32: ::c_long = 212;\npub const SYS_setuid32: ::c_long = 213;\npub const SYS_setgid32: ::c_long = 214;\npub const SYS_setfsuid32: ::c_long = 215;\npub const SYS_setfsgid32: ::c_long = 216;\npub const SYS_pivot_root: ::c_long = 217;\npub const SYS_mincore: ::c_long = 218;\npub const SYS_madvise: ::c_long = 219;\npub const SYS_getdents64: ::c_long = 220;\npub const SYS_fcntl64: ::c_long = 221;\npub const SYS_gettid: ::c_long = 224;\npub const SYS_readahead: ::c_long = 225;\npub const SYS_setxattr: ::c_long = 226;\npub const SYS_lsetxattr: ::c_long = 227;\npub const SYS_fsetxattr: ::c_long = 228;\npub const SYS_getxattr: ::c_long = 229;\npub const SYS_lgetxattr: ::c_long = 230;\npub const SYS_fgetxattr: ::c_long = 231;\npub const SYS_listxattr: ::c_long = 232;\npub const SYS_llistxattr: ::c_long = 233;\npub const SYS_flistxattr: ::c_long = 234;\npub const SYS_removexattr: ::c_long = 235;\npub const SYS_lremovexattr: ::c_long = 236;\npub const SYS_fremovexattr: ::c_long = 237;\npub const SYS_tkill: ::c_long = 238;\npub const SYS_sendfile64: ::c_long = 239;\npub const SYS_futex: ::c_long = 240;\npub const SYS_sched_setaffinity: ::c_long = 241;\npub const SYS_sched_getaffinity: ::c_long = 242;\npub const SYS_set_thread_area: ::c_long = 243;\npub const SYS_get_thread_area: ::c_long = 244;\npub const SYS_io_setup: ::c_long = 245;\npub const SYS_io_destroy: ::c_long = 246;\npub const SYS_io_getevents: ::c_long = 247;\npub const SYS_io_submit: ::c_long = 248;\npub const SYS_io_cancel: ::c_long = 249;\npub const SYS_fadvise64: ::c_long = 250;\npub const SYS_exit_group: ::c_long = 252;\npub const SYS_lookup_dcookie: ::c_long = 253;\npub const SYS_epoll_create: ::c_long = 254;\npub const SYS_epoll_ctl: ::c_long = 255;\npub const SYS_epoll_wait: ::c_long = 256;\npub const SYS_remap_file_pages: ::c_long = 257;\npub const SYS_set_tid_address: ::c_long = 258;\npub const SYS_timer_create: ::c_long = 259;\npub const SYS_timer_settime: ::c_long = 260;\npub const SYS_timer_gettime: ::c_long = 261;\npub const SYS_timer_getoverrun: ::c_long = 262;\npub const SYS_timer_delete: ::c_long = 263;\npub const SYS_clock_settime: ::c_long = 264;\npub const SYS_clock_gettime: ::c_long = 265;\npub const SYS_clock_getres: ::c_long = 266;\npub const SYS_clock_nanosleep: ::c_long = 267;\npub const SYS_statfs64: ::c_long = 268;\npub const SYS_fstatfs64: ::c_long = 269;\npub const SYS_tgkill: ::c_long = 270;\npub const SYS_utimes: ::c_long = 271;\npub const SYS_fadvise64_64: ::c_long = 272;\npub const SYS_vserver: ::c_long = 273;\npub const SYS_mbind: ::c_long = 274;\npub const SYS_get_mempolicy: ::c_long = 275;\npub const SYS_set_mempolicy: ::c_long = 276;\npub const SYS_mq_open: ::c_long = 277;\npub const SYS_mq_unlink: ::c_long = 278;\npub const SYS_mq_timedsend: ::c_long = 279;\npub const SYS_mq_timedreceive: ::c_long = 280;\npub const SYS_mq_notify: ::c_long = 281;\npub const SYS_mq_getsetattr: ::c_long = 282;\npub const SYS_kexec_load: ::c_long = 283;\npub const SYS_waitid: ::c_long = 284;\npub const SYS_add_key: ::c_long = 286;\npub const SYS_request_key: ::c_long = 287;\npub const SYS_keyctl: ::c_long = 288;\npub const SYS_ioprio_set: ::c_long = 289;\npub const SYS_ioprio_get: ::c_long = 290;\npub const SYS_inotify_init: ::c_long = 291;\npub const SYS_inotify_add_watch: ::c_long = 292;\npub const SYS_inotify_rm_watch: ::c_long = 293;\npub const SYS_migrate_pages: ::c_long = 294;\npub const SYS_openat: ::c_long = 295;\npub const SYS_mkdirat: ::c_long = 296;\npub const SYS_mknodat: ::c_long = 297;\npub const SYS_fchownat: ::c_long = 298;\npub const SYS_futimesat: ::c_long = 299;\npub const SYS_fstatat64: ::c_long = 300;\npub const SYS_unlinkat: ::c_long = 301;\npub const SYS_renameat: ::c_long = 302;\npub const SYS_linkat: ::c_long = 303;\npub const SYS_symlinkat: ::c_long = 304;\npub const SYS_readlinkat: ::c_long = 305;\npub const SYS_fchmodat: ::c_long = 306;\npub const SYS_faccessat: ::c_long = 307;\npub const SYS_pselect6: ::c_long = 308;\npub const SYS_ppoll: ::c_long = 309;\npub const SYS_unshare: ::c_long = 310;\npub const SYS_set_robust_list: ::c_long = 311;\npub const SYS_get_robust_list: ::c_long = 312;\npub const SYS_splice: ::c_long = 313;\npub const SYS_sync_file_range: ::c_long = 314;\npub const SYS_tee: ::c_long = 315;\npub const SYS_vmsplice: ::c_long = 316;\npub const SYS_move_pages: ::c_long = 317;\npub const SYS_getcpu: ::c_long = 318;\npub const SYS_epoll_pwait: ::c_long = 319;\npub const SYS_utimensat: ::c_long = 320;\npub const SYS_signalfd: ::c_long = 321;\npub const SYS_timerfd_create: ::c_long = 322;\npub const SYS_eventfd: ::c_long = 323;\npub const SYS_fallocate: ::c_long = 324;\npub const SYS_timerfd_settime: ::c_long = 325;\npub const SYS_timerfd_gettime: ::c_long = 326;\npub const SYS_signalfd4: ::c_long = 327;\npub const SYS_eventfd2: ::c_long = 328;\npub const SYS_epoll_create1: ::c_long = 329;\npub const SYS_dup3: ::c_long = 330;\npub const SYS_pipe2: ::c_long = 331;\npub const SYS_inotify_init1: ::c_long = 332;\npub const SYS_preadv: ::c_long = 333;\npub const SYS_pwritev: ::c_long = 334;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 335;\npub const SYS_perf_event_open: ::c_long = 336;\npub const SYS_recvmmsg: ::c_long = 337;\npub const SYS_fanotify_init: ::c_long = 338;\npub const SYS_fanotify_mark: ::c_long = 339;\npub const SYS_prlimit64: ::c_long = 340;\npub const SYS_name_to_handle_at: ::c_long = 341;\npub const SYS_open_by_handle_at: ::c_long = 342;\npub const SYS_clock_adjtime: ::c_long = 343;\npub const SYS_syncfs: ::c_long = 344;\npub const SYS_sendmmsg: ::c_long = 345;\npub const SYS_setns: ::c_long = 346;\npub const SYS_process_vm_readv: ::c_long = 347;\npub const SYS_process_vm_writev: ::c_long = 348;\npub const SYS_kcmp: ::c_long = 349;\npub const SYS_finit_module: ::c_long = 350;\npub const SYS_sched_setattr: ::c_long = 351;\npub const SYS_sched_getattr: ::c_long = 352;\npub const SYS_renameat2: ::c_long = 353;\npub const SYS_seccomp: ::c_long = 354;\npub const SYS_getrandom: ::c_long = 355;\npub const SYS_memfd_create: ::c_long = 356;\npub const SYS_bpf: ::c_long = 357;\npub const SYS_execveat: ::c_long = 358;\npub const SYS_socket: ::c_long = 359;\npub const SYS_socketpair: ::c_long = 360;\npub const SYS_bind: ::c_long = 361;\npub const SYS_connect: ::c_long = 362;\npub const SYS_listen: ::c_long = 363;\npub const SYS_accept4: ::c_long = 364;\npub const SYS_getsockopt: ::c_long = 365;\npub const SYS_setsockopt: ::c_long = 366;\npub const SYS_getsockname: ::c_long = 367;\npub const SYS_getpeername: ::c_long = 368;\npub const SYS_sendto: ::c_long = 369;\npub const SYS_sendmsg: ::c_long = 370;\npub const SYS_recvfrom: ::c_long = 371;\npub const SYS_recvmsg: ::c_long = 372;\npub const SYS_shutdown: ::c_long = 373;\npub const SYS_userfaultfd: ::c_long = 374;\npub const SYS_membarrier: ::c_long = 375;\npub const SYS_mlock2: ::c_long = 376;\npub const SYS_copy_file_range: ::c_long = 377;\npub const SYS_preadv2: ::c_long = 378;\npub const SYS_pwritev2: ::c_long = 379;\npub const SYS_pkey_mprotect: ::c_long = 380;\npub const SYS_pkey_alloc: ::c_long = 381;\npub const SYS_pkey_free: ::c_long = 382;\npub const SYS_statx: ::c_long = 383;\npub const SYS_pidfd_send_signal: ::c_long = 424;\npub const SYS_io_uring_setup: ::c_long = 425;\npub const SYS_io_uring_enter: ::c_long = 426;\npub const SYS_io_uring_register: ::c_long = 427;\npub const SYS_open_tree: ::c_long = 428;\npub const SYS_move_mount: ::c_long = 429;\npub const SYS_fsopen: ::c_long = 430;\npub const SYS_fsconfig: ::c_long = 431;\npub const SYS_fsmount: ::c_long = 432;\npub const SYS_fspick: ::c_long = 433;\npub const SYS_pidfd_open: ::c_long = 434;\npub const SYS_clone3: ::c_long = 435;\npub const SYS_close_range: ::c_long = 436;\npub const SYS_openat2: ::c_long = 437;\npub const SYS_pidfd_getfd: ::c_long = 438;\npub const SYS_faccessat2: ::c_long = 439;\npub const SYS_process_madvise: ::c_long = 440;\npub const SYS_epoll_pwait2: ::c_long = 441;\npub const SYS_mount_setattr: ::c_long = 442;\n\n// offsets in user_regs_structs, from sys/reg.h\npub const EBX: ::c_int = 0;\npub const ECX: ::c_int = 1;\npub const EDX: ::c_int = 2;\npub const ESI: ::c_int = 3;\npub const EDI: ::c_int = 4;\npub const EBP: ::c_int = 5;\npub const EAX: ::c_int = 6;\npub const DS: ::c_int = 7;\npub const ES: ::c_int = 8;\npub const FS: ::c_int = 9;\npub const GS: ::c_int = 10;\npub const ORIG_EAX: ::c_int = 11;\npub const EIP: ::c_int = 12;\npub const CS: ::c_int = 13;\npub const EFL: ::c_int = 14;\npub const UESP: ::c_int = 15;\npub const SS: ::c_int = 16;\n\n// offsets in mcontext_t.gregs from sys/ucontext.h\npub const REG_GS: ::c_int = 0;\npub const REG_FS: ::c_int = 1;\npub const REG_ES: ::c_int = 2;\npub const REG_DS: ::c_int = 3;\npub const REG_EDI: ::c_int = 4;\npub const REG_ESI: ::c_int = 5;\npub const REG_EBP: ::c_int = 6;\npub const REG_ESP: ::c_int = 7;\npub const REG_EBX: ::c_int = 8;\npub const REG_EDX: ::c_int = 9;\npub const REG_ECX: ::c_int = 10;\npub const REG_EAX: ::c_int = 11;\npub const REG_TRAPNO: ::c_int = 12;\npub const REG_ERR: ::c_int = 13;\npub const REG_EIP: ::c_int = 14;\npub const REG_CS: ::c_int = 15;\npub const REG_EFL: ::c_int = 16;\npub const REG_UESP: ::c_int = 17;\npub const REG_SS: ::c_int = 18;\n\nextern \"C\" {\n    pub fn getcontext(ucp: *mut ucontext_t) -> ::c_int;\n    pub fn setcontext(ucp: *const ucontext_t) -> ::c_int;\n    pub fn makecontext(ucp: *mut ucontext_t, func: extern \"C\" fn(), argc: ::c_int, ...);\n    pub fn swapcontext(uocp: *mut ucontext_t, ucp: *const ucontext_t) -> ::c_int;\n}\n\ncfg_if! {\n    if #[cfg(libc_align)] {\n        mod align;\n        pub use self::align::*;\n    }\n}\n"],["1186","pub type c_char = u8;\npub type wchar_t = u32;\n\ns! {\n    pub struct sigaction {\n        pub sa_sigaction: ::sighandler_t,\n        pub sa_mask: ::sigset_t,\n        pub sa_flags: ::c_int,\n        pub sa_restorer: ::Option<extern fn()>,\n    }\n\n    pub struct statfs {\n        pub f_type: ::__fsword_t,\n        pub f_bsize: ::__fsword_t,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n\n        pub f_namelen: ::__fsword_t,\n        pub f_frsize: ::__fsword_t,\n        f_spare: [::__fsword_t; 5],\n    }\n\n    pub struct flock {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off_t,\n        pub l_len: ::off_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct flock64 {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off64_t,\n        pub l_len: ::off64_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct ipc_perm {\n        pub __key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::c_ushort,\n        __pad1: ::c_ushort,\n        pub __seq: ::c_ushort,\n        __pad2: ::c_ushort,\n        __unused1: ::c_ulong,\n        __unused2: ::c_ulong\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::dev_t,\n        __pad1: ::c_uint,\n        __st_ino: ::ino_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        __pad2: ::c_uint,\n        pub st_size: ::off64_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt64_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        pub st_ino: ::ino64_t,\n    }\n\n    pub struct statfs64 {\n        pub f_type: ::__fsword_t,\n        pub f_bsize: ::__fsword_t,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::__fsword_t,\n        pub f_frsize: ::__fsword_t,\n        pub f_flags: ::__fsword_t,\n        pub f_spare: [::__fsword_t; 4],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_favail: u64,\n        pub f_fsid: ::c_ulong,\n        __f_unused: ::c_int,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        pub shm_segsz: ::size_t,\n        pub shm_atime: ::time_t,\n        __unused1: ::c_ulong,\n        pub shm_dtime: ::time_t,\n        __unused2: ::c_ulong,\n        pub shm_ctime: ::time_t,\n        __unused3: ::c_ulong,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::shmatt_t,\n        __unused4: ::c_ulong,\n        __unused5: ::c_ulong\n    }\n\n    pub struct msqid_ds {\n        pub msg_perm: ::ipc_perm,\n        pub msg_stime: ::time_t,\n        __glibc_reserved1: ::c_ulong,\n        pub msg_rtime: ::time_t,\n        __glibc_reserved2: ::c_ulong,\n        pub msg_ctime: ::time_t,\n        __glibc_reserved3: ::c_ulong,\n        __msg_cbytes: ::c_ulong,\n        pub msg_qnum: ::msgqnum_t,\n        pub msg_qbytes: ::msglen_t,\n        pub msg_lspid: ::pid_t,\n        pub msg_lrpid: ::pid_t,\n        __glibc_reserved4: ::c_ulong,\n        __glibc_reserved5: ::c_ulong,\n    }\n\n    pub struct termios2 {\n        pub c_iflag: ::tcflag_t,\n        pub c_oflag: ::tcflag_t,\n        pub c_cflag: ::tcflag_t,\n        pub c_lflag: ::tcflag_t,\n        pub c_line: ::cc_t,\n        pub c_cc: [::cc_t; 19],\n        pub c_ispeed: ::speed_t,\n        pub c_ospeed: ::speed_t,\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_errno: ::c_int,\n        pub si_code: ::c_int,\n        #[doc(hidden)]\n        #[deprecated(\n            since=\"0.2.54\",\n            note=\"Please leave a comment on \\\n                  https://github.com/rust-lang/libc/pull/1316 if you're using \\\n                  this field\"\n        )]\n        pub _pad: [::c_int; 29],\n        _align: [usize; 0],\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_flags: ::c_int,\n        pub ss_size: ::size_t\n    }\n}\n\npub const RLIM_INFINITY: ::rlim_t = !0;\npub const VEOF: usize = 4;\npub const RTLD_DEEPBIND: ::c_int = 0x8;\npub const RTLD_GLOBAL: ::c_int = 0x100;\npub const RTLD_NOLOAD: ::c_int = 0x4;\npub const O_DIRECT: ::c_int = 0x10000;\npub const O_DIRECTORY: ::c_int = 0x4000;\npub const O_NOFOLLOW: ::c_int = 0x8000;\npub const O_LARGEFILE: ::c_int = 0o400000;\npub const O_APPEND: ::c_int = 1024;\npub const O_CREAT: ::c_int = 64;\npub const O_EXCL: ::c_int = 128;\npub const O_NOCTTY: ::c_int = 256;\npub const O_NONBLOCK: ::c_int = 2048;\npub const O_SYNC: ::c_int = 1052672;\npub const O_RSYNC: ::c_int = 1052672;\npub const O_DSYNC: ::c_int = 4096;\npub const O_FSYNC: ::c_int = 0x101000;\npub const O_ASYNC: ::c_int = 0x2000;\npub const O_NDELAY: ::c_int = 0x800;\npub const RLIMIT_NOFILE: ::__rlimit_resource_t = 7;\npub const RLIMIT_NPROC: ::__rlimit_resource_t = 6;\npub const RLIMIT_RSS: ::__rlimit_resource_t = 5;\npub const RLIMIT_AS: ::__rlimit_resource_t = 9;\npub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 8;\n\npub const MADV_SOFT_OFFLINE: ::c_int = 101;\npub const MAP_LOCKED: ::c_int = 0x02000;\npub const MAP_NORESERVE: ::c_int = 0x04000;\npub const MAP_ANON: ::c_int = 0x0020;\npub const MAP_ANONYMOUS: ::c_int = 0x0020;\npub const MAP_DENYWRITE: ::c_int = 0x0800;\npub const MAP_EXECUTABLE: ::c_int = 0x01000;\npub const MAP_POPULATE: ::c_int = 0x08000;\npub const MAP_NONBLOCK: ::c_int = 0x010000;\npub const MAP_STACK: ::c_int = 0x020000;\npub const MAP_HUGETLB: ::c_int = 0x040000;\npub const MAP_GROWSDOWN: ::c_int = 0x0100;\npub const MAP_SYNC: ::c_int = 0x080000;\n\npub const EDEADLOCK: ::c_int = 35;\npub const EUCLEAN: ::c_int = 117;\npub const ENOTNAM: ::c_int = 118;\npub const ENAVAIL: ::c_int = 119;\npub const EISNAM: ::c_int = 120;\npub const EREMOTEIO: ::c_int = 121;\npub const EDEADLK: ::c_int = 35;\npub const ENAMETOOLONG: ::c_int = 36;\npub const ENOLCK: ::c_int = 37;\npub const ENOSYS: ::c_int = 38;\npub const ENOTEMPTY: ::c_int = 39;\npub const ELOOP: ::c_int = 40;\npub const ENOMSG: ::c_int = 42;\npub const EIDRM: ::c_int = 43;\npub const ECHRNG: ::c_int = 44;\npub const EL2NSYNC: ::c_int = 45;\npub const EL3HLT: ::c_int = 46;\npub const EL3RST: ::c_int = 47;\npub const ELNRNG: ::c_int = 48;\npub const EUNATCH: ::c_int = 49;\npub const ENOCSI: ::c_int = 50;\npub const EL2HLT: ::c_int = 51;\npub const EBADE: ::c_int = 52;\npub const EBADR: ::c_int = 53;\npub const EXFULL: ::c_int = 54;\npub const ENOANO: ::c_int = 55;\npub const EBADRQC: ::c_int = 56;\npub const EBADSLT: ::c_int = 57;\npub const EMULTIHOP: ::c_int = 72;\npub const EOVERFLOW: ::c_int = 75;\npub const ENOTUNIQ: ::c_int = 76;\npub const EBADFD: ::c_int = 77;\npub const EBADMSG: ::c_int = 74;\npub const EREMCHG: ::c_int = 78;\npub const ELIBACC: ::c_int = 79;\npub const ELIBBAD: ::c_int = 80;\npub const ELIBSCN: ::c_int = 81;\npub const ELIBMAX: ::c_int = 82;\npub const ELIBEXEC: ::c_int = 83;\npub const EILSEQ: ::c_int = 84;\npub const ERESTART: ::c_int = 85;\npub const ESTRPIPE: ::c_int = 86;\npub const EUSERS: ::c_int = 87;\npub const ENOTSOCK: ::c_int = 88;\npub const EDESTADDRREQ: ::c_int = 89;\npub const EMSGSIZE: ::c_int = 90;\npub const EPROTOTYPE: ::c_int = 91;\npub const ENOPROTOOPT: ::c_int = 92;\npub const EPROTONOSUPPORT: ::c_int = 93;\npub const ESOCKTNOSUPPORT: ::c_int = 94;\npub const EOPNOTSUPP: ::c_int = 95;\npub const EPFNOSUPPORT: ::c_int = 96;\npub const EAFNOSUPPORT: ::c_int = 97;\npub const EADDRINUSE: ::c_int = 98;\npub const EADDRNOTAVAIL: ::c_int = 99;\npub const ENETDOWN: ::c_int = 100;\npub const ENETUNREACH: ::c_int = 101;\npub const ENETRESET: ::c_int = 102;\npub const ECONNABORTED: ::c_int = 103;\npub const ECONNRESET: ::c_int = 104;\npub const ENOBUFS: ::c_int = 105;\npub const EISCONN: ::c_int = 106;\npub const ENOTCONN: ::c_int = 107;\npub const ESHUTDOWN: ::c_int = 108;\npub const ETOOMANYREFS: ::c_int = 109;\npub const ETIMEDOUT: ::c_int = 110;\npub const ECONNREFUSED: ::c_int = 111;\npub const EHOSTDOWN: ::c_int = 112;\npub const EHOSTUNREACH: ::c_int = 113;\npub const EALREADY: ::c_int = 114;\npub const EINPROGRESS: ::c_int = 115;\npub const ESTALE: ::c_int = 116;\npub const EDQUOT: ::c_int = 122;\npub const ENOMEDIUM: ::c_int = 123;\npub const EMEDIUMTYPE: ::c_int = 124;\npub const ECANCELED: ::c_int = 125;\npub const ENOKEY: ::c_int = 126;\npub const EKEYEXPIRED: ::c_int = 127;\npub const EKEYREVOKED: ::c_int = 128;\npub const EKEYREJECTED: ::c_int = 129;\npub const EOWNERDEAD: ::c_int = 130;\npub const ENOTRECOVERABLE: ::c_int = 131;\npub const EHWPOISON: ::c_int = 133;\npub const ERFKILL: ::c_int = 132;\n\npub const SA_SIGINFO: ::c_int = 0x00000004;\npub const SA_NOCLDWAIT: ::c_int = 0x00000002;\n\npub const SOCK_STREAM: ::c_int = 1;\npub const SOCK_DGRAM: ::c_int = 2;\n\npub const FIOCLEX: ::c_ulong = 0x5451;\npub const FIONCLEX: ::c_ulong = 0x5450;\npub const FIONBIO: ::c_ulong = 0x5421;\n\npub const MCL_CURRENT: ::c_int = 0x0001;\npub const MCL_FUTURE: ::c_int = 0x0002;\n\npub const POLLWRNORM: ::c_short = 0x100;\npub const POLLWRBAND: ::c_short = 0x200;\n\npub const F_GETLK: ::c_int = 5;\npub const F_GETOWN: ::c_int = 9;\npub const F_SETOWN: ::c_int = 8;\n\npub const EFD_NONBLOCK: ::c_int = 0x800;\npub const SFD_NONBLOCK: ::c_int = 0x0800;\n\npub const SIGCHLD: ::c_int = 17;\npub const SIGBUS: ::c_int = 7;\npub const SIGUSR1: ::c_int = 10;\npub const SIGUSR2: ::c_int = 12;\npub const SIGCONT: ::c_int = 18;\npub const SIGSTOP: ::c_int = 19;\npub const SIGTSTP: ::c_int = 20;\npub const SIGURG: ::c_int = 23;\npub const SIGIO: ::c_int = 29;\npub const SIGSYS: ::c_int = 31;\npub const SIGSTKFLT: ::c_int = 16;\n#[deprecated(since = \"0.2.55\", note = \"Use SIGSYS instead\")]\npub const SIGUNUSED: ::c_int = 31;\npub const SIGPOLL: ::c_int = 29;\npub const SIGPWR: ::c_int = 30;\npub const SIG_SETMASK: ::c_int = 2;\npub const SIG_BLOCK: ::c_int = 0x000000;\npub const SIG_UNBLOCK: ::c_int = 0x01;\npub const SIGTTIN: ::c_int = 21;\npub const SIGTTOU: ::c_int = 22;\npub const SIGXCPU: ::c_int = 24;\npub const SIGXFSZ: ::c_int = 25;\npub const SIGVTALRM: ::c_int = 26;\npub const SIGPROF: ::c_int = 27;\npub const SIGWINCH: ::c_int = 28;\npub const SIGSTKSZ: ::size_t = 8192;\npub const MINSIGSTKSZ: ::size_t = 2048;\npub const CBAUD: ::tcflag_t = 0o0010017;\npub const TAB1: ::tcflag_t = 0x00000800;\npub const TAB2: ::tcflag_t = 0x00001000;\npub const TAB3: ::tcflag_t = 0x00001800;\npub const CR1: ::tcflag_t = 0x00000200;\npub const CR2: ::tcflag_t = 0x00000400;\npub const CR3: ::tcflag_t = 0x00000600;\npub const FF1: ::tcflag_t = 0x00008000;\npub const BS1: ::tcflag_t = 0x00002000;\npub const VT1: ::tcflag_t = 0x00004000;\npub const VWERASE: usize = 14;\npub const VREPRINT: usize = 12;\npub const VSUSP: usize = 10;\npub const VSTART: usize = 8;\npub const VSTOP: usize = 9;\npub const VDISCARD: usize = 13;\npub const VTIME: usize = 5;\npub const IXON: ::tcflag_t = 0x00000400;\npub const IXOFF: ::tcflag_t = 0x00001000;\npub const ONLCR: ::tcflag_t = 0x4;\npub const CSIZE: ::tcflag_t = 0x00000030;\npub const CS6: ::tcflag_t = 0x00000010;\npub const CS7: ::tcflag_t = 0x00000020;\npub const CS8: ::tcflag_t = 0x00000030;\npub const CSTOPB: ::tcflag_t = 0x00000040;\npub const CREAD: ::tcflag_t = 0x00000080;\npub const PARENB: ::tcflag_t = 0x00000100;\npub const PARODD: ::tcflag_t = 0x00000200;\npub const HUPCL: ::tcflag_t = 0x00000400;\npub const CLOCAL: ::tcflag_t = 0x00000800;\npub const ECHOKE: ::tcflag_t = 0x00000800;\npub const ECHOE: ::tcflag_t = 0x00000010;\npub const ECHOK: ::tcflag_t = 0x00000020;\npub const ECHONL: ::tcflag_t = 0x00000040;\npub const ECHOPRT: ::tcflag_t = 0x00000400;\npub const ECHOCTL: ::tcflag_t = 0x00000200;\npub const ISIG: ::tcflag_t = 0x00000001;\npub const ICANON: ::tcflag_t = 0x00000002;\npub const PENDIN: ::tcflag_t = 0x00004000;\npub const NOFLSH: ::tcflag_t = 0x00000080;\npub const CIBAUD: ::tcflag_t = 0o02003600000;\npub const CBAUDEX: ::tcflag_t = 0o010000;\npub const VSWTC: usize = 7;\npub const OLCUC: ::tcflag_t = 0o000002;\npub const NLDLY: ::tcflag_t = 0o000400;\npub const CRDLY: ::tcflag_t = 0o003000;\npub const TABDLY: ::tcflag_t = 0o014000;\npub const BSDLY: ::tcflag_t = 0o020000;\npub const FFDLY: ::tcflag_t = 0o100000;\npub const VTDLY: ::tcflag_t = 0o040000;\npub const XTABS: ::tcflag_t = 0o014000;\n\npub const B0: ::speed_t = 0o000000;\npub const B50: ::speed_t = 0o000001;\npub const B75: ::speed_t = 0o000002;\npub const B110: ::speed_t = 0o000003;\npub const B134: ::speed_t = 0o000004;\npub const B150: ::speed_t = 0o000005;\npub const B200: ::speed_t = 0o000006;\npub const B300: ::speed_t = 0o000007;\npub const B600: ::speed_t = 0o000010;\npub const B1200: ::speed_t = 0o000011;\npub const B1800: ::speed_t = 0o000012;\npub const B2400: ::speed_t = 0o000013;\npub const B4800: ::speed_t = 0o000014;\npub const B9600: ::speed_t = 0o000015;\npub const B19200: ::speed_t = 0o000016;\npub const B38400: ::speed_t = 0o000017;\npub const EXTA: ::speed_t = B19200;\npub const EXTB: ::speed_t = B38400;\npub const BOTHER: ::speed_t = 0o010000;\npub const B57600: ::speed_t = 0o010001;\npub const B115200: ::speed_t = 0o010002;\npub const B230400: ::speed_t = 0o010003;\npub const B460800: ::speed_t = 0o010004;\npub const B500000: ::speed_t = 0o010005;\npub const B576000: ::speed_t = 0o010006;\npub const B921600: ::speed_t = 0o010007;\npub const B1000000: ::speed_t = 0o010010;\npub const B1152000: ::speed_t = 0o010011;\npub const B1500000: ::speed_t = 0o010012;\npub const B2000000: ::speed_t = 0o010013;\npub const B2500000: ::speed_t = 0o010014;\npub const B3000000: ::speed_t = 0o010015;\npub const B3500000: ::speed_t = 0o010016;\npub const B4000000: ::speed_t = 0o010017;\n\npub const VEOL: usize = 11;\npub const VEOL2: usize = 16;\npub const VMIN: usize = 6;\npub const IEXTEN: ::tcflag_t = 0x00008000;\npub const TOSTOP: ::tcflag_t = 0x00000100;\npub const FLUSHO: ::tcflag_t = 0x00001000;\npub const EXTPROC: ::tcflag_t = 0x00010000;\npub const TCGETS: ::c_ulong = 0x5401;\npub const TCSETS: ::c_ulong = 0x5402;\npub const TCSETSW: ::c_ulong = 0x5403;\npub const TCSETSF: ::c_ulong = 0x5404;\npub const TCGETA: ::c_ulong = 0x5405;\npub const TCSETA: ::c_ulong = 0x5406;\npub const TCSETAW: ::c_ulong = 0x5407;\npub const TCSETAF: ::c_ulong = 0x5408;\npub const TCSBRK: ::c_ulong = 0x5409;\npub const TCXONC: ::c_ulong = 0x540A;\npub const TCFLSH: ::c_ulong = 0x540B;\npub const TIOCINQ: ::c_ulong = 0x541B;\npub const TIOCGPGRP: ::c_ulong = 0x540F;\npub const TIOCSPGRP: ::c_ulong = 0x5410;\npub const TIOCOUTQ: ::c_ulong = 0x5411;\npub const TIOCGWINSZ: ::c_ulong = 0x5413;\npub const TIOCSWINSZ: ::c_ulong = 0x5414;\npub const TIOCGRS485: ::c_int = 0x542E;\npub const TIOCSRS485: ::c_int = 0x542F;\npub const FIONREAD: ::c_ulong = 0x541B;\n\npub const TIOCGSOFTCAR: ::c_ulong = 0x5419;\npub const TIOCSSOFTCAR: ::c_ulong = 0x541A;\npub const TIOCEXCL: ::c_ulong = 0x540C;\npub const TIOCNXCL: ::c_ulong = 0x540D;\npub const TIOCSCTTY: ::c_ulong = 0x540E;\npub const TIOCSTI: ::c_ulong = 0x5412;\npub const TIOCMGET: ::c_ulong = 0x5415;\npub const TIOCMBIS: ::c_ulong = 0x5416;\npub const TIOCMBIC: ::c_ulong = 0x5417;\npub const TIOCMSET: ::c_ulong = 0x5418;\npub const TIOCCONS: ::c_ulong = 0x541D;\n\npub const TCSANOW: ::c_int = 0;\npub const TCSADRAIN: ::c_int = 1;\npub const TCSAFLUSH: ::c_int = 2;\n\npub const TIOCLINUX: ::c_ulong = 0x541C;\npub const TIOCGSERIAL: ::c_ulong = 0x541E;\npub const TIOCM_ST: ::c_int = 0x008;\npub const TIOCM_SR: ::c_int = 0x010;\npub const TIOCM_CTS: ::c_int = 0x020;\npub const TIOCM_CAR: ::c_int = 0x040;\npub const TIOCM_RNG: ::c_int = 0x080;\npub const TIOCM_DSR: ::c_int = 0x100;\n\n// Syscall table\npub const SYS_restart_syscall: ::c_long = 0;\npub const SYS_exit: ::c_long = 1;\npub const SYS_fork: ::c_long = 2;\npub const SYS_read: ::c_long = 3;\npub const SYS_write: ::c_long = 4;\npub const SYS_open: ::c_long = 5;\npub const SYS_close: ::c_long = 6;\npub const SYS_creat: ::c_long = 8;\npub const SYS_link: ::c_long = 9;\npub const SYS_unlink: ::c_long = 10;\npub const SYS_execve: ::c_long = 11;\npub const SYS_chdir: ::c_long = 12;\npub const SYS_mknod: ::c_long = 14;\npub const SYS_chmod: ::c_long = 15;\npub const SYS_lchown: ::c_long = 16;\npub const SYS_lseek: ::c_long = 19;\npub const SYS_getpid: ::c_long = 20;\npub const SYS_mount: ::c_long = 21;\npub const SYS_setuid: ::c_long = 23;\npub const SYS_getuid: ::c_long = 24;\npub const SYS_ptrace: ::c_long = 26;\npub const SYS_pause: ::c_long = 29;\npub const SYS_access: ::c_long = 33;\npub const SYS_nice: ::c_long = 34;\npub const SYS_sync: ::c_long = 36;\npub const SYS_kill: ::c_long = 37;\npub const SYS_rename: ::c_long = 38;\npub const SYS_mkdir: ::c_long = 39;\npub const SYS_rmdir: ::c_long = 40;\npub const SYS_dup: ::c_long = 41;\npub const SYS_pipe: ::c_long = 42;\npub const SYS_times: ::c_long = 43;\npub const SYS_brk: ::c_long = 45;\npub const SYS_setgid: ::c_long = 46;\npub const SYS_getgid: ::c_long = 47;\npub const SYS_geteuid: ::c_long = 49;\npub const SYS_getegid: ::c_long = 50;\npub const SYS_acct: ::c_long = 51;\npub const SYS_umount2: ::c_long = 52;\npub const SYS_ioctl: ::c_long = 54;\npub const SYS_fcntl: ::c_long = 55;\npub const SYS_setpgid: ::c_long = 57;\npub const SYS_umask: ::c_long = 60;\npub const SYS_chroot: ::c_long = 61;\npub const SYS_ustat: ::c_long = 62;\npub const SYS_dup2: ::c_long = 63;\npub const SYS_getppid: ::c_long = 64;\npub const SYS_getpgrp: ::c_long = 65;\npub const SYS_setsid: ::c_long = 66;\npub const SYS_sigaction: ::c_long = 67;\npub const SYS_setreuid: ::c_long = 70;\npub const SYS_setregid: ::c_long = 71;\npub const SYS_sigsuspend: ::c_long = 72;\npub const SYS_sigpending: ::c_long = 73;\npub const SYS_sethostname: ::c_long = 74;\npub const SYS_setrlimit: ::c_long = 75;\npub const SYS_getrusage: ::c_long = 77;\npub const SYS_gettimeofday: ::c_long = 78;\npub const SYS_settimeofday: ::c_long = 79;\npub const SYS_getgroups: ::c_long = 80;\npub const SYS_setgroups: ::c_long = 81;\npub const SYS_symlink: ::c_long = 83;\npub const SYS_readlink: ::c_long = 85;\npub const SYS_uselib: ::c_long = 86;\npub const SYS_swapon: ::c_long = 87;\npub const SYS_reboot: ::c_long = 88;\npub const SYS_munmap: ::c_long = 91;\npub const SYS_truncate: ::c_long = 92;\npub const SYS_ftruncate: ::c_long = 93;\npub const SYS_fchmod: ::c_long = 94;\npub const SYS_fchown: ::c_long = 95;\npub const SYS_getpriority: ::c_long = 96;\npub const SYS_setpriority: ::c_long = 97;\npub const SYS_statfs: ::c_long = 99;\npub const SYS_fstatfs: ::c_long = 100;\npub const SYS_syslog: ::c_long = 103;\npub const SYS_setitimer: ::c_long = 104;\npub const SYS_getitimer: ::c_long = 105;\npub const SYS_stat: ::c_long = 106;\npub const SYS_lstat: ::c_long = 107;\npub const SYS_fstat: ::c_long = 108;\npub const SYS_vhangup: ::c_long = 111;\npub const SYS_wait4: ::c_long = 114;\npub const SYS_swapoff: ::c_long = 115;\npub const SYS_sysinfo: ::c_long = 116;\npub const SYS_fsync: ::c_long = 118;\npub const SYS_sigreturn: ::c_long = 119;\npub const SYS_clone: ::c_long = 120;\npub const SYS_setdomainname: ::c_long = 121;\npub const SYS_uname: ::c_long = 122;\npub const SYS_adjtimex: ::c_long = 124;\npub const SYS_mprotect: ::c_long = 125;\npub const SYS_sigprocmask: ::c_long = 126;\npub const SYS_init_module: ::c_long = 128;\npub const SYS_delete_module: ::c_long = 129;\npub const SYS_quotactl: ::c_long = 131;\npub const SYS_getpgid: ::c_long = 132;\npub const SYS_fchdir: ::c_long = 133;\npub const SYS_bdflush: ::c_long = 134;\npub const SYS_sysfs: ::c_long = 135;\npub const SYS_personality: ::c_long = 136;\npub const SYS_setfsuid: ::c_long = 138;\npub const SYS_setfsgid: ::c_long = 139;\npub const SYS__llseek: ::c_long = 140;\npub const SYS_getdents: ::c_long = 141;\npub const SYS__newselect: ::c_long = 142;\npub const SYS_flock: ::c_long = 143;\npub const SYS_msync: ::c_long = 144;\npub const SYS_readv: ::c_long = 145;\npub const SYS_writev: ::c_long = 146;\npub const SYS_getsid: ::c_long = 147;\npub const SYS_fdatasync: ::c_long = 148;\npub const SYS__sysctl: ::c_long = 149;\npub const SYS_mlock: ::c_long = 150;\npub const SYS_munlock: ::c_long = 151;\npub const SYS_mlockall: ::c_long = 152;\npub const SYS_munlockall: ::c_long = 153;\npub const SYS_sched_setparam: ::c_long = 154;\npub const SYS_sched_getparam: ::c_long = 155;\npub const SYS_sched_setscheduler: ::c_long = 156;\npub const SYS_sched_getscheduler: ::c_long = 157;\npub const SYS_sched_yield: ::c_long = 158;\npub const SYS_sched_get_priority_max: ::c_long = 159;\npub const SYS_sched_get_priority_min: ::c_long = 160;\npub const SYS_sched_rr_get_interval: ::c_long = 161;\npub const SYS_nanosleep: ::c_long = 162;\npub const SYS_mremap: ::c_long = 163;\npub const SYS_setresuid: ::c_long = 164;\npub const SYS_getresuid: ::c_long = 165;\npub const SYS_poll: ::c_long = 168;\npub const SYS_nfsservctl: ::c_long = 169;\npub const SYS_setresgid: ::c_long = 170;\npub const SYS_getresgid: ::c_long = 171;\npub const SYS_prctl: ::c_long = 172;\npub const SYS_rt_sigreturn: ::c_long = 173;\npub const SYS_rt_sigaction: ::c_long = 174;\npub const SYS_rt_sigprocmask: ::c_long = 175;\npub const SYS_rt_sigpending: ::c_long = 176;\npub const SYS_rt_sigtimedwait: ::c_long = 177;\npub const SYS_rt_sigqueueinfo: ::c_long = 178;\npub const SYS_rt_sigsuspend: ::c_long = 179;\npub const SYS_pread64: ::c_long = 180;\npub const SYS_pwrite64: ::c_long = 181;\npub const SYS_chown: ::c_long = 182;\npub const SYS_getcwd: ::c_long = 183;\npub const SYS_capget: ::c_long = 184;\npub const SYS_capset: ::c_long = 185;\npub const SYS_sigaltstack: ::c_long = 186;\npub const SYS_sendfile: ::c_long = 187;\npub const SYS_vfork: ::c_long = 190;\npub const SYS_ugetrlimit: ::c_long = 191;\npub const SYS_mmap2: ::c_long = 192;\npub const SYS_truncate64: ::c_long = 193;\npub const SYS_ftruncate64: ::c_long = 194;\npub const SYS_stat64: ::c_long = 195;\npub const SYS_lstat64: ::c_long = 196;\npub const SYS_fstat64: ::c_long = 197;\npub const SYS_lchown32: ::c_long = 198;\npub const SYS_getuid32: ::c_long = 199;\npub const SYS_getgid32: ::c_long = 200;\npub const SYS_geteuid32: ::c_long = 201;\npub const SYS_getegid32: ::c_long = 202;\npub const SYS_setreuid32: ::c_long = 203;\npub const SYS_setregid32: ::c_long = 204;\npub const SYS_getgroups32: ::c_long = 205;\npub const SYS_setgroups32: ::c_long = 206;\npub const SYS_fchown32: ::c_long = 207;\npub const SYS_setresuid32: ::c_long = 208;\npub const SYS_getresuid32: ::c_long = 209;\npub const SYS_setresgid32: ::c_long = 210;\npub const SYS_getresgid32: ::c_long = 211;\npub const SYS_chown32: ::c_long = 212;\npub const SYS_setuid32: ::c_long = 213;\npub const SYS_setgid32: ::c_long = 214;\npub const SYS_setfsuid32: ::c_long = 215;\npub const SYS_setfsgid32: ::c_long = 216;\npub const SYS_getdents64: ::c_long = 217;\npub const SYS_pivot_root: ::c_long = 218;\npub const SYS_mincore: ::c_long = 219;\npub const SYS_madvise: ::c_long = 220;\npub const SYS_fcntl64: ::c_long = 221;\npub const SYS_gettid: ::c_long = 224;\npub const SYS_readahead: ::c_long = 225;\npub const SYS_setxattr: ::c_long = 226;\npub const SYS_lsetxattr: ::c_long = 227;\npub const SYS_fsetxattr: ::c_long = 228;\npub const SYS_getxattr: ::c_long = 229;\npub const SYS_lgetxattr: ::c_long = 230;\npub const SYS_fgetxattr: ::c_long = 231;\npub const SYS_listxattr: ::c_long = 232;\npub const SYS_llistxattr: ::c_long = 233;\npub const SYS_flistxattr: ::c_long = 234;\npub const SYS_removexattr: ::c_long = 235;\npub const SYS_lremovexattr: ::c_long = 236;\npub const SYS_fremovexattr: ::c_long = 237;\npub const SYS_tkill: ::c_long = 238;\npub const SYS_sendfile64: ::c_long = 239;\npub const SYS_futex: ::c_long = 240;\npub const SYS_sched_setaffinity: ::c_long = 241;\npub const SYS_sched_getaffinity: ::c_long = 242;\npub const SYS_io_setup: ::c_long = 243;\npub const SYS_io_destroy: ::c_long = 244;\npub const SYS_io_getevents: ::c_long = 245;\npub const SYS_io_submit: ::c_long = 246;\npub const SYS_io_cancel: ::c_long = 247;\npub const SYS_exit_group: ::c_long = 248;\npub const SYS_lookup_dcookie: ::c_long = 249;\npub const SYS_epoll_create: ::c_long = 250;\npub const SYS_epoll_ctl: ::c_long = 251;\npub const SYS_epoll_wait: ::c_long = 252;\npub const SYS_remap_file_pages: ::c_long = 253;\npub const SYS_set_tid_address: ::c_long = 256;\npub const SYS_timer_create: ::c_long = 257;\npub const SYS_timer_settime: ::c_long = 258;\npub const SYS_timer_gettime: ::c_long = 259;\npub const SYS_timer_getoverrun: ::c_long = 260;\npub const SYS_timer_delete: ::c_long = 261;\npub const SYS_clock_settime: ::c_long = 262;\npub const SYS_clock_gettime: ::c_long = 263;\npub const SYS_clock_getres: ::c_long = 264;\npub const SYS_clock_nanosleep: ::c_long = 265;\npub const SYS_statfs64: ::c_long = 266;\npub const SYS_fstatfs64: ::c_long = 267;\npub const SYS_tgkill: ::c_long = 268;\npub const SYS_utimes: ::c_long = 269;\npub const SYS_arm_fadvise64_64: ::c_long = 270;\npub const SYS_pciconfig_iobase: ::c_long = 271;\npub const SYS_pciconfig_read: ::c_long = 272;\npub const SYS_pciconfig_write: ::c_long = 273;\npub const SYS_mq_open: ::c_long = 274;\npub const SYS_mq_unlink: ::c_long = 275;\npub const SYS_mq_timedsend: ::c_long = 276;\npub const SYS_mq_timedreceive: ::c_long = 277;\npub const SYS_mq_notify: ::c_long = 278;\npub const SYS_mq_getsetattr: ::c_long = 279;\npub const SYS_waitid: ::c_long = 280;\npub const SYS_socket: ::c_long = 281;\npub const SYS_bind: ::c_long = 282;\npub const SYS_connect: ::c_long = 283;\npub const SYS_listen: ::c_long = 284;\npub const SYS_accept: ::c_long = 285;\npub const SYS_getsockname: ::c_long = 286;\npub const SYS_getpeername: ::c_long = 287;\npub const SYS_socketpair: ::c_long = 288;\npub const SYS_send: ::c_long = 289;\npub const SYS_sendto: ::c_long = 290;\npub const SYS_recv: ::c_long = 291;\npub const SYS_recvfrom: ::c_long = 292;\npub const SYS_shutdown: ::c_long = 293;\npub const SYS_setsockopt: ::c_long = 294;\npub const SYS_getsockopt: ::c_long = 295;\npub const SYS_sendmsg: ::c_long = 296;\npub const SYS_recvmsg: ::c_long = 297;\npub const SYS_semop: ::c_long = 298;\npub const SYS_semget: ::c_long = 299;\npub const SYS_semctl: ::c_long = 300;\npub const SYS_msgsnd: ::c_long = 301;\npub const SYS_msgrcv: ::c_long = 302;\npub const SYS_msgget: ::c_long = 303;\npub const SYS_msgctl: ::c_long = 304;\npub const SYS_shmat: ::c_long = 305;\npub const SYS_shmdt: ::c_long = 306;\npub const SYS_shmget: ::c_long = 307;\npub const SYS_shmctl: ::c_long = 308;\npub const SYS_add_key: ::c_long = 309;\npub const SYS_request_key: ::c_long = 310;\npub const SYS_keyctl: ::c_long = 311;\npub const SYS_semtimedop: ::c_long = 312;\npub const SYS_vserver: ::c_long = 313;\npub const SYS_ioprio_set: ::c_long = 314;\npub const SYS_ioprio_get: ::c_long = 315;\npub const SYS_inotify_init: ::c_long = 316;\npub const SYS_inotify_add_watch: ::c_long = 317;\npub const SYS_inotify_rm_watch: ::c_long = 318;\npub const SYS_mbind: ::c_long = 319;\npub const SYS_get_mempolicy: ::c_long = 320;\npub const SYS_set_mempolicy: ::c_long = 321;\npub const SYS_openat: ::c_long = 322;\npub const SYS_mkdirat: ::c_long = 323;\npub const SYS_mknodat: ::c_long = 324;\npub const SYS_fchownat: ::c_long = 325;\npub const SYS_futimesat: ::c_long = 326;\npub const SYS_fstatat64: ::c_long = 327;\npub const SYS_unlinkat: ::c_long = 328;\npub const SYS_renameat: ::c_long = 329;\npub const SYS_linkat: ::c_long = 330;\npub const SYS_symlinkat: ::c_long = 331;\npub const SYS_readlinkat: ::c_long = 332;\npub const SYS_fchmodat: ::c_long = 333;\npub const SYS_faccessat: ::c_long = 334;\npub const SYS_pselect6: ::c_long = 335;\npub const SYS_ppoll: ::c_long = 336;\npub const SYS_unshare: ::c_long = 337;\npub const SYS_set_robust_list: ::c_long = 338;\npub const SYS_get_robust_list: ::c_long = 339;\npub const SYS_splice: ::c_long = 340;\npub const SYS_arm_sync_file_range: ::c_long = 341;\npub const SYS_tee: ::c_long = 342;\npub const SYS_vmsplice: ::c_long = 343;\npub const SYS_move_pages: ::c_long = 344;\npub const SYS_getcpu: ::c_long = 345;\npub const SYS_epoll_pwait: ::c_long = 346;\npub const SYS_kexec_load: ::c_long = 347;\npub const SYS_utimensat: ::c_long = 348;\npub const SYS_signalfd: ::c_long = 349;\npub const SYS_timerfd_create: ::c_long = 350;\npub const SYS_eventfd: ::c_long = 351;\npub const SYS_fallocate: ::c_long = 352;\npub const SYS_timerfd_settime: ::c_long = 353;\npub const SYS_timerfd_gettime: ::c_long = 354;\npub const SYS_signalfd4: ::c_long = 355;\npub const SYS_eventfd2: ::c_long = 356;\npub const SYS_epoll_create1: ::c_long = 357;\npub const SYS_dup3: ::c_long = 358;\npub const SYS_pipe2: ::c_long = 359;\npub const SYS_inotify_init1: ::c_long = 360;\npub const SYS_preadv: ::c_long = 361;\npub const SYS_pwritev: ::c_long = 362;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 363;\npub const SYS_perf_event_open: ::c_long = 364;\npub const SYS_recvmmsg: ::c_long = 365;\npub const SYS_accept4: ::c_long = 366;\npub const SYS_fanotify_init: ::c_long = 367;\npub const SYS_fanotify_mark: ::c_long = 368;\npub const SYS_prlimit64: ::c_long = 369;\npub const SYS_name_to_handle_at: ::c_long = 370;\npub const SYS_open_by_handle_at: ::c_long = 371;\npub const SYS_clock_adjtime: ::c_long = 372;\npub const SYS_syncfs: ::c_long = 373;\npub const SYS_sendmmsg: ::c_long = 374;\npub const SYS_setns: ::c_long = 375;\npub const SYS_process_vm_readv: ::c_long = 376;\npub const SYS_process_vm_writev: ::c_long = 377;\npub const SYS_kcmp: ::c_long = 378;\npub const SYS_finit_module: ::c_long = 379;\npub const SYS_sched_setattr: ::c_long = 380;\npub const SYS_sched_getattr: ::c_long = 381;\npub const SYS_renameat2: ::c_long = 382;\npub const SYS_seccomp: ::c_long = 383;\npub const SYS_getrandom: ::c_long = 384;\npub const SYS_memfd_create: ::c_long = 385;\npub const SYS_bpf: ::c_long = 386;\npub const SYS_execveat: ::c_long = 387;\npub const SYS_userfaultfd: ::c_long = 388;\npub const SYS_membarrier: ::c_long = 389;\npub const SYS_mlock2: ::c_long = 390;\npub const SYS_copy_file_range: ::c_long = 391;\npub const SYS_preadv2: ::c_long = 392;\npub const SYS_pwritev2: ::c_long = 393;\npub const SYS_pkey_mprotect: ::c_long = 394;\npub const SYS_pkey_alloc: ::c_long = 395;\npub const SYS_pkey_free: ::c_long = 396;\npub const SYS_statx: ::c_long = 397;\npub const SYS_pidfd_send_signal: ::c_long = 424;\npub const SYS_io_uring_setup: ::c_long = 425;\npub const SYS_io_uring_enter: ::c_long = 426;\npub const SYS_io_uring_register: ::c_long = 427;\npub const SYS_open_tree: ::c_long = 428;\npub const SYS_move_mount: ::c_long = 429;\npub const SYS_fsopen: ::c_long = 430;\npub const SYS_fsconfig: ::c_long = 431;\npub const SYS_fsmount: ::c_long = 432;\npub const SYS_fspick: ::c_long = 433;\npub const SYS_pidfd_open: ::c_long = 434;\npub const SYS_clone3: ::c_long = 435;\npub const SYS_close_range: ::c_long = 436;\npub const SYS_openat2: ::c_long = 437;\npub const SYS_pidfd_getfd: ::c_long = 438;\npub const SYS_faccessat2: ::c_long = 439;\npub const SYS_process_madvise: ::c_long = 440;\npub const SYS_epoll_pwait2: ::c_long = 441;\npub const SYS_mount_setattr: ::c_long = 442;\n\ncfg_if! {\n    if #[cfg(libc_align)] {\n        mod align;\n        pub use self::align::*;\n    }\n}\n"],["1187","s_no_extra_traits! {\n    #[allow(missing_debug_implementations)]\n    #[repr(align(8))]\n    pub struct max_align_t {\n        priv_: [i64; 2]\n    }\n}\n"],["1188","pub type c_char = u8;\npub type wchar_t = i32;\n\ns! {\n    pub struct sigaction {\n        pub sa_sigaction: ::sighandler_t,\n        pub sa_mask: ::sigset_t,\n        pub sa_flags: ::c_int,\n        pub sa_restorer: ::Option<extern fn()>,\n    }\n\n    pub struct statfs {\n        pub f_type: ::__fsword_t,\n        pub f_bsize: ::__fsword_t,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n\n        pub f_namelen: ::__fsword_t,\n        pub f_frsize: ::__fsword_t,\n        f_spare: [::__fsword_t; 5],\n    }\n\n    pub struct flock {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off_t,\n        pub l_len: ::off_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct flock64 {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off64_t,\n        pub l_len: ::off64_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct ipc_perm {\n        __key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::mode_t,\n        __seq: u32,\n        __pad1: u32,\n        __glibc_reserved1: u64,\n        __glibc_reserved2: u64,\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino64_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        __pad2: ::c_ushort,\n        pub st_size: ::off64_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt64_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __glibc_reserved4: ::c_ulong,\n        __glibc_reserved5: ::c_ulong,\n    }\n\n    pub struct statfs64 {\n        pub f_type: ::__fsword_t,\n        pub f_bsize: ::__fsword_t,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::__fsword_t,\n        pub f_frsize: ::__fsword_t,\n        pub f_flags: ::__fsword_t,\n        pub f_spare: [::__fsword_t; 4],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_favail: u64,\n        pub f_fsid: ::c_ulong,\n        __f_unused: ::c_int,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        __glibc_reserved1: ::c_uint,\n        pub shm_atime: ::time_t,\n        __glibc_reserved2: ::c_uint,\n        pub shm_dtime: ::time_t,\n        __glibc_reserved3: ::c_uint,\n        pub shm_ctime: ::time_t,\n        __glibc_reserved4: ::c_uint,\n        pub shm_segsz: ::size_t,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::shmatt_t,\n        __glibc_reserved5: ::c_ulong,\n        __glibc_reserved6: ::c_ulong,\n    }\n\n    pub struct msqid_ds {\n        pub msg_perm: ::ipc_perm,\n        __glibc_reserved1: ::c_uint,\n        pub msg_stime: ::time_t,\n        __glibc_reserved2: ::c_uint,\n        pub msg_rtime: ::time_t,\n        __glibc_reserved3: ::c_uint,\n        pub msg_ctime: ::time_t,\n        __msg_cbytes: ::c_ulong,\n        pub msg_qnum: ::msgqnum_t,\n        pub msg_qbytes: ::msglen_t,\n        pub msg_lspid: ::pid_t,\n        pub msg_lrpid: ::pid_t,\n        __glibc_reserved4: ::c_ulong,\n        __glibc_reserved5: ::c_ulong,\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_errno: ::c_int,\n        pub si_code: ::c_int,\n        #[doc(hidden)]\n        #[deprecated(\n            since=\"0.2.54\",\n            note=\"Please leave a comment on \\\n                  https://github.com/rust-lang/libc/pull/1316 if you're using \\\n                  this field\"\n        )]\n        pub _pad: [::c_int; 29],\n        _align: [usize; 0],\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_flags: ::c_int,\n        pub ss_size: ::size_t\n    }\n}\n\npub const RLIM_INFINITY: ::rlim_t = !0;\npub const VEOF: usize = 4;\npub const RTLD_DEEPBIND: ::c_int = 0x8;\npub const RTLD_GLOBAL: ::c_int = 0x100;\npub const RTLD_NOLOAD: ::c_int = 0x4;\npub const O_DIRECT: ::c_int = 0x20000;\npub const O_DIRECTORY: ::c_int = 0x4000;\npub const O_NOFOLLOW: ::c_int = 0x8000;\npub const O_LARGEFILE: ::c_int = 0o200000;\npub const O_APPEND: ::c_int = 1024;\npub const O_CREAT: ::c_int = 64;\npub const O_EXCL: ::c_int = 128;\npub const O_NOCTTY: ::c_int = 256;\npub const O_NONBLOCK: ::c_int = 2048;\npub const O_SYNC: ::c_int = 1052672;\npub const O_RSYNC: ::c_int = 1052672;\npub const O_DSYNC: ::c_int = 4096;\npub const O_FSYNC: ::c_int = 0x101000;\npub const O_ASYNC: ::c_int = 0x2000;\npub const O_NDELAY: ::c_int = 0x800;\npub const RLIMIT_NOFILE: ::__rlimit_resource_t = 7;\npub const RLIMIT_NPROC: ::__rlimit_resource_t = 6;\npub const RLIMIT_RSS: ::__rlimit_resource_t = 5;\npub const RLIMIT_AS: ::__rlimit_resource_t = 9;\npub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 8;\npub const TCSANOW: ::c_int = 0;\npub const TCSADRAIN: ::c_int = 1;\npub const TCSAFLUSH: ::c_int = 2;\n\npub const TIOCLINUX: ::c_ulong = 0x541C;\npub const TIOCGSERIAL: ::c_ulong = 0x541E;\npub const TIOCM_ST: ::c_int = 0x008;\npub const TIOCM_SR: ::c_int = 0x010;\npub const TIOCM_CTS: ::c_int = 0x020;\npub const TIOCM_CAR: ::c_int = 0x040;\npub const TIOCM_RNG: ::c_int = 0x080;\npub const TIOCM_DSR: ::c_int = 0x100;\n\npub const MADV_SOFT_OFFLINE: ::c_int = 101;\npub const MAP_LOCKED: ::c_int = 0x00080;\npub const MAP_NORESERVE: ::c_int = 0x00040;\npub const MAP_ANON: ::c_int = 0x0020;\npub const MAP_ANONYMOUS: ::c_int = 0x0020;\npub const MAP_DENYWRITE: ::c_int = 0x0800;\npub const MAP_EXECUTABLE: ::c_int = 0x01000;\npub const MAP_POPULATE: ::c_int = 0x08000;\npub const MAP_NONBLOCK: ::c_int = 0x010000;\npub const MAP_STACK: ::c_int = 0x020000;\npub const MAP_HUGETLB: ::c_int = 0x040000;\npub const MAP_GROWSDOWN: ::c_int = 0x0100;\npub const MAP_SYNC: ::c_int = 0x080000;\n\npub const EDEADLOCK: ::c_int = 58;\npub const EUCLEAN: ::c_int = 117;\npub const ENOTNAM: ::c_int = 118;\npub const ENAVAIL: ::c_int = 119;\npub const EISNAM: ::c_int = 120;\npub const EREMOTEIO: ::c_int = 121;\npub const EDEADLK: ::c_int = 35;\npub const ENAMETOOLONG: ::c_int = 36;\npub const ENOLCK: ::c_int = 37;\npub const ENOSYS: ::c_int = 38;\npub const ENOTEMPTY: ::c_int = 39;\npub const ELOOP: ::c_int = 40;\npub const ENOMSG: ::c_int = 42;\npub const EIDRM: ::c_int = 43;\npub const ECHRNG: ::c_int = 44;\npub const EL2NSYNC: ::c_int = 45;\npub const EL3HLT: ::c_int = 46;\npub const EL3RST: ::c_int = 47;\npub const ELNRNG: ::c_int = 48;\npub const EUNATCH: ::c_int = 49;\npub const ENOCSI: ::c_int = 50;\npub const EL2HLT: ::c_int = 51;\npub const EBADE: ::c_int = 52;\npub const EBADR: ::c_int = 53;\npub const EXFULL: ::c_int = 54;\npub const ENOANO: ::c_int = 55;\npub const EBADRQC: ::c_int = 56;\npub const EBADSLT: ::c_int = 57;\npub const EMULTIHOP: ::c_int = 72;\npub const EOVERFLOW: ::c_int = 75;\npub const ENOTUNIQ: ::c_int = 76;\npub const EBADFD: ::c_int = 77;\npub const EBADMSG: ::c_int = 74;\npub const EREMCHG: ::c_int = 78;\npub const ELIBACC: ::c_int = 79;\npub const ELIBBAD: ::c_int = 80;\npub const ELIBSCN: ::c_int = 81;\npub const ELIBMAX: ::c_int = 82;\npub const ELIBEXEC: ::c_int = 83;\npub const EILSEQ: ::c_int = 84;\npub const ERESTART: ::c_int = 85;\npub const ESTRPIPE: ::c_int = 86;\npub const EUSERS: ::c_int = 87;\npub const ENOTSOCK: ::c_int = 88;\npub const EDESTADDRREQ: ::c_int = 89;\npub const EMSGSIZE: ::c_int = 90;\npub const EPROTOTYPE: ::c_int = 91;\npub const ENOPROTOOPT: ::c_int = 92;\npub const EPROTONOSUPPORT: ::c_int = 93;\npub const ESOCKTNOSUPPORT: ::c_int = 94;\npub const EOPNOTSUPP: ::c_int = 95;\npub const EPFNOSUPPORT: ::c_int = 96;\npub const EAFNOSUPPORT: ::c_int = 97;\npub const EADDRINUSE: ::c_int = 98;\npub const EADDRNOTAVAIL: ::c_int = 99;\npub const ENETDOWN: ::c_int = 100;\npub const ENETUNREACH: ::c_int = 101;\npub const ENETRESET: ::c_int = 102;\npub const ECONNABORTED: ::c_int = 103;\npub const ECONNRESET: ::c_int = 104;\npub const ENOBUFS: ::c_int = 105;\npub const EISCONN: ::c_int = 106;\npub const ENOTCONN: ::c_int = 107;\npub const ESHUTDOWN: ::c_int = 108;\npub const ETOOMANYREFS: ::c_int = 109;\npub const ETIMEDOUT: ::c_int = 110;\npub const ECONNREFUSED: ::c_int = 111;\npub const EHOSTDOWN: ::c_int = 112;\npub const EHOSTUNREACH: ::c_int = 113;\npub const EALREADY: ::c_int = 114;\npub const EINPROGRESS: ::c_int = 115;\npub const ESTALE: ::c_int = 116;\npub const EDQUOT: ::c_int = 122;\npub const ENOMEDIUM: ::c_int = 123;\npub const EMEDIUMTYPE: ::c_int = 124;\npub const ECANCELED: ::c_int = 125;\npub const ENOKEY: ::c_int = 126;\npub const EKEYEXPIRED: ::c_int = 127;\npub const EKEYREVOKED: ::c_int = 128;\npub const EKEYREJECTED: ::c_int = 129;\npub const EOWNERDEAD: ::c_int = 130;\npub const ENOTRECOVERABLE: ::c_int = 131;\npub const EHWPOISON: ::c_int = 133;\npub const ERFKILL: ::c_int = 132;\n\npub const SA_SIGINFO: ::c_int = 0x00000004;\npub const SA_NOCLDWAIT: ::c_int = 0x00000002;\n\npub const SOCK_STREAM: ::c_int = 1;\npub const SOCK_DGRAM: ::c_int = 2;\n\npub const FIOCLEX: ::c_ulong = 0x20006601;\npub const FIONCLEX: ::c_ulong = 0x20006602;\npub const FIONBIO: ::c_ulong = 0x8004667e;\n\npub const MCL_CURRENT: ::c_int = 0x2000;\npub const MCL_FUTURE: ::c_int = 0x4000;\n\npub const POLLWRNORM: ::c_short = 0x100;\npub const POLLWRBAND: ::c_short = 0x200;\n\npub const F_GETLK: ::c_int = 5;\npub const F_GETOWN: ::c_int = 9;\npub const F_SETOWN: ::c_int = 8;\n\npub const EFD_NONBLOCK: ::c_int = 0x800;\npub const SFD_NONBLOCK: ::c_int = 0x0800;\n\npub const TIOCGSOFTCAR: ::c_ulong = 0x5419;\npub const TIOCSSOFTCAR: ::c_ulong = 0x541A;\npub const TIOCEXCL: ::c_ulong = 0x540C;\npub const TIOCNXCL: ::c_ulong = 0x540D;\npub const TIOCSCTTY: ::c_ulong = 0x540E;\npub const TIOCSTI: ::c_ulong = 0x5412;\npub const TIOCMGET: ::c_ulong = 0x5415;\npub const TIOCMBIS: ::c_ulong = 0x5416;\npub const TIOCMBIC: ::c_ulong = 0x5417;\npub const TIOCMSET: ::c_ulong = 0x5418;\npub const TIOCCONS: ::c_ulong = 0x541D;\n\npub const SIGCHLD: ::c_int = 17;\npub const SIGBUS: ::c_int = 7;\npub const SIGUSR1: ::c_int = 10;\npub const SIGUSR2: ::c_int = 12;\npub const SIGCONT: ::c_int = 18;\npub const SIGSTOP: ::c_int = 19;\npub const SIGTSTP: ::c_int = 20;\npub const SIGURG: ::c_int = 23;\npub const SIGIO: ::c_int = 29;\npub const SIGSYS: ::c_int = 31;\npub const SIGSTKFLT: ::c_int = 16;\n#[deprecated(since = \"0.2.55\", note = \"Use SIGSYS instead\")]\npub const SIGUNUSED: ::c_int = 31;\npub const SIGPOLL: ::c_int = 29;\npub const SIGPWR: ::c_int = 30;\npub const SIG_SETMASK: ::c_int = 2;\npub const SIG_BLOCK: ::c_int = 0x000000;\npub const SIG_UNBLOCK: ::c_int = 0x01;\npub const SIGTTIN: ::c_int = 21;\npub const SIGTTOU: ::c_int = 22;\npub const SIGXCPU: ::c_int = 24;\npub const SIGXFSZ: ::c_int = 25;\npub const SIGVTALRM: ::c_int = 26;\npub const SIGPROF: ::c_int = 27;\npub const SIGWINCH: ::c_int = 28;\npub const SIGSTKSZ: ::size_t = 0x4000;\npub const MINSIGSTKSZ: ::size_t = 4096;\npub const CBAUD: ::tcflag_t = 0xff;\npub const TAB1: ::tcflag_t = 0x400;\npub const TAB2: ::tcflag_t = 0x800;\npub const TAB3: ::tcflag_t = 0xc00;\npub const CR1: ::tcflag_t = 0x1000;\npub const CR2: ::tcflag_t = 0x2000;\npub const CR3: ::tcflag_t = 0x3000;\npub const FF1: ::tcflag_t = 0x4000;\npub const BS1: ::tcflag_t = 0x8000;\npub const VT1: ::tcflag_t = 0x10000;\npub const VWERASE: usize = 0xa;\npub const VREPRINT: usize = 0xb;\npub const VSUSP: usize = 0xc;\npub const VSTART: usize = 0xd;\npub const VSTOP: usize = 0xe;\npub const VDISCARD: usize = 0x10;\npub const VTIME: usize = 0x7;\npub const IXON: ::tcflag_t = 0x200;\npub const IXOFF: ::tcflag_t = 0x400;\npub const ONLCR: ::tcflag_t = 0x2;\npub const CSIZE: ::tcflag_t = 0x300;\npub const CS6: ::tcflag_t = 0x100;\npub const CS7: ::tcflag_t = 0x200;\npub const CS8: ::tcflag_t = 0x300;\npub const CSTOPB: ::tcflag_t = 0x400;\npub const CREAD: ::tcflag_t = 0x800;\npub const PARENB: ::tcflag_t = 0x1000;\npub const PARODD: ::tcflag_t = 0x2000;\npub const HUPCL: ::tcflag_t = 0x4000;\npub const CLOCAL: ::tcflag_t = 0x8000;\npub const ECHOKE: ::tcflag_t = 0x1;\npub const ECHOE: ::tcflag_t = 0x2;\npub const ECHOK: ::tcflag_t = 0x4;\npub const ECHONL: ::tcflag_t = 0x10;\npub const ECHOPRT: ::tcflag_t = 0x20;\npub const ECHOCTL: ::tcflag_t = 0x40;\npub const ISIG: ::tcflag_t = 0x80;\npub const ICANON: ::tcflag_t = 0x100;\npub const PENDIN: ::tcflag_t = 0x20000000;\npub const NOFLSH: ::tcflag_t = 0x80000000;\npub const VSWTC: usize = 9;\npub const OLCUC: ::tcflag_t = 0o000004;\npub const NLDLY: ::tcflag_t = 0o001400;\npub const CRDLY: ::tcflag_t = 0o030000;\npub const TABDLY: ::tcflag_t = 0o006000;\npub const BSDLY: ::tcflag_t = 0o100000;\npub const FFDLY: ::tcflag_t = 0o040000;\npub const VTDLY: ::tcflag_t = 0o200000;\npub const XTABS: ::tcflag_t = 0o006000;\n\npub const B0: ::speed_t = 0o000000;\npub const B50: ::speed_t = 0o000001;\npub const B75: ::speed_t = 0o000002;\npub const B110: ::speed_t = 0o000003;\npub const B134: ::speed_t = 0o000004;\npub const B150: ::speed_t = 0o000005;\npub const B200: ::speed_t = 0o000006;\npub const B300: ::speed_t = 0o000007;\npub const B600: ::speed_t = 0o000010;\npub const B1200: ::speed_t = 0o000011;\npub const B1800: ::speed_t = 0o000012;\npub const B2400: ::speed_t = 0o000013;\npub const B4800: ::speed_t = 0o000014;\npub const B9600: ::speed_t = 0o000015;\npub const B19200: ::speed_t = 0o000016;\npub const B38400: ::speed_t = 0o000017;\npub const EXTA: ::speed_t = B19200;\npub const EXTB: ::speed_t = B38400;\npub const CBAUDEX: ::speed_t = 0o000020;\npub const B57600: ::speed_t = 0o0020;\npub const B115200: ::speed_t = 0o0021;\npub const B230400: ::speed_t = 0o0022;\npub const B460800: ::speed_t = 0o0023;\npub const B500000: ::speed_t = 0o0024;\npub const B576000: ::speed_t = 0o0025;\npub const B921600: ::speed_t = 0o0026;\npub const B1000000: ::speed_t = 0o0027;\npub const B1152000: ::speed_t = 0o0030;\npub const B1500000: ::speed_t = 0o0031;\npub const B2000000: ::speed_t = 0o0032;\npub const B2500000: ::speed_t = 0o0033;\npub const B3000000: ::speed_t = 0o0034;\npub const B3500000: ::speed_t = 0o0035;\npub const B4000000: ::speed_t = 0o0036;\npub const BOTHER: ::speed_t = 0o0037;\n\npub const VEOL: usize = 6;\npub const VEOL2: usize = 8;\npub const VMIN: usize = 5;\npub const IEXTEN: ::tcflag_t = 0x400;\npub const TOSTOP: ::tcflag_t = 0x400000;\npub const FLUSHO: ::tcflag_t = 0x800000;\npub const EXTPROC: ::tcflag_t = 0x10000000;\npub const TCGETS: ::c_ulong = 0x403c7413;\npub const TCSETS: ::c_ulong = 0x803c7414;\npub const TCSETSW: ::c_ulong = 0x803c7415;\npub const TCSETSF: ::c_ulong = 0x803c7416;\npub const TCGETA: ::c_ulong = 0x40147417;\npub const TCSETA: ::c_ulong = 0x80147418;\npub const TCSETAW: ::c_ulong = 0x80147419;\npub const TCSETAF: ::c_ulong = 0x8014741c;\npub const TCSBRK: ::c_ulong = 0x2000741d;\npub const TCXONC: ::c_ulong = 0x2000741e;\npub const TCFLSH: ::c_ulong = 0x2000741f;\npub const TIOCINQ: ::c_ulong = 0x4004667f;\npub const TIOCGPGRP: ::c_ulong = 0x40047477;\npub const TIOCSPGRP: ::c_ulong = 0x80047476;\npub const TIOCOUTQ: ::c_ulong = 0x40047473;\npub const TIOCGWINSZ: ::c_ulong = 0x40087468;\npub const TIOCSWINSZ: ::c_ulong = 0x80087467;\npub const TIOCGRS485: ::c_int = 0x542e;\npub const TIOCSRS485: ::c_int = 0x542f;\npub const FIONREAD: ::c_ulong = 0x4004667f;\n\npub const SYS_restart_syscall: ::c_long = 0;\npub const SYS_exit: ::c_long = 1;\npub const SYS_fork: ::c_long = 2;\npub const SYS_read: ::c_long = 3;\npub const SYS_write: ::c_long = 4;\npub const SYS_open: ::c_long = 5;\npub const SYS_close: ::c_long = 6;\npub const SYS_waitpid: ::c_long = 7;\npub const SYS_creat: ::c_long = 8;\npub const SYS_link: ::c_long = 9;\npub const SYS_unlink: ::c_long = 10;\npub const SYS_execve: ::c_long = 11;\npub const SYS_chdir: ::c_long = 12;\npub const SYS_time: ::c_long = 13;\npub const SYS_mknod: ::c_long = 14;\npub const SYS_chmod: ::c_long = 15;\npub const SYS_lchown: ::c_long = 16;\npub const SYS_break: ::c_long = 17;\npub const SYS_oldstat: ::c_long = 18;\npub const SYS_lseek: ::c_long = 19;\npub const SYS_getpid: ::c_long = 20;\npub const SYS_mount: ::c_long = 21;\npub const SYS_umount: ::c_long = 22;\npub const SYS_setuid: ::c_long = 23;\npub const SYS_getuid: ::c_long = 24;\npub const SYS_stime: ::c_long = 25;\npub const SYS_ptrace: ::c_long = 26;\npub const SYS_alarm: ::c_long = 27;\npub const SYS_oldfstat: ::c_long = 28;\npub const SYS_pause: ::c_long = 29;\npub const SYS_utime: ::c_long = 30;\npub const SYS_stty: ::c_long = 31;\npub const SYS_gtty: ::c_long = 32;\npub const SYS_access: ::c_long = 33;\npub const SYS_nice: ::c_long = 34;\npub const SYS_ftime: ::c_long = 35;\npub const SYS_sync: ::c_long = 36;\npub const SYS_kill: ::c_long = 37;\npub const SYS_rename: ::c_long = 38;\npub const SYS_mkdir: ::c_long = 39;\npub const SYS_rmdir: ::c_long = 40;\npub const SYS_dup: ::c_long = 41;\npub const SYS_pipe: ::c_long = 42;\npub const SYS_times: ::c_long = 43;\npub const SYS_prof: ::c_long = 44;\npub const SYS_brk: ::c_long = 45;\npub const SYS_setgid: ::c_long = 46;\npub const SYS_getgid: ::c_long = 47;\npub const SYS_signal: ::c_long = 48;\npub const SYS_geteuid: ::c_long = 49;\npub const SYS_getegid: ::c_long = 50;\npub const SYS_acct: ::c_long = 51;\npub const SYS_umount2: ::c_long = 52;\npub const SYS_lock: ::c_long = 53;\npub const SYS_ioctl: ::c_long = 54;\npub const SYS_fcntl: ::c_long = 55;\npub const SYS_mpx: ::c_long = 56;\npub const SYS_setpgid: ::c_long = 57;\npub const SYS_ulimit: ::c_long = 58;\npub const SYS_oldolduname: ::c_long = 59;\npub const SYS_umask: ::c_long = 60;\npub const SYS_chroot: ::c_long = 61;\npub const SYS_ustat: ::c_long = 62;\npub const SYS_dup2: ::c_long = 63;\npub const SYS_getppid: ::c_long = 64;\npub const SYS_getpgrp: ::c_long = 65;\npub const SYS_setsid: ::c_long = 66;\npub const SYS_sigaction: ::c_long = 67;\npub const SYS_sgetmask: ::c_long = 68;\npub const SYS_ssetmask: ::c_long = 69;\npub const SYS_setreuid: ::c_long = 70;\npub const SYS_setregid: ::c_long = 71;\npub const SYS_sigsuspend: ::c_long = 72;\npub const SYS_sigpending: ::c_long = 73;\npub const SYS_sethostname: ::c_long = 74;\npub const SYS_setrlimit: ::c_long = 75;\npub const SYS_getrlimit: ::c_long = 76;\npub const SYS_getrusage: ::c_long = 77;\npub const SYS_gettimeofday: ::c_long = 78;\npub const SYS_settimeofday: ::c_long = 79;\npub const SYS_getgroups: ::c_long = 80;\npub const SYS_setgroups: ::c_long = 81;\npub const SYS_select: ::c_long = 82;\npub const SYS_symlink: ::c_long = 83;\npub const SYS_oldlstat: ::c_long = 84;\npub const SYS_readlink: ::c_long = 85;\npub const SYS_uselib: ::c_long = 86;\npub const SYS_swapon: ::c_long = 87;\npub const SYS_reboot: ::c_long = 88;\npub const SYS_readdir: ::c_long = 89;\npub const SYS_mmap: ::c_long = 90;\npub const SYS_munmap: ::c_long = 91;\npub const SYS_truncate: ::c_long = 92;\npub const SYS_ftruncate: ::c_long = 93;\npub const SYS_fchmod: ::c_long = 94;\npub const SYS_fchown: ::c_long = 95;\npub const SYS_getpriority: ::c_long = 96;\npub const SYS_setpriority: ::c_long = 97;\npub const SYS_profil: ::c_long = 98;\npub const SYS_statfs: ::c_long = 99;\npub const SYS_fstatfs: ::c_long = 100;\npub const SYS_ioperm: ::c_long = 101;\npub const SYS_socketcall: ::c_long = 102;\npub const SYS_syslog: ::c_long = 103;\npub const SYS_setitimer: ::c_long = 104;\npub const SYS_getitimer: ::c_long = 105;\npub const SYS_stat: ::c_long = 106;\npub const SYS_lstat: ::c_long = 107;\npub const SYS_fstat: ::c_long = 108;\npub const SYS_olduname: ::c_long = 109;\npub const SYS_iopl: ::c_long = 110;\npub const SYS_vhangup: ::c_long = 111;\npub const SYS_idle: ::c_long = 112;\npub const SYS_vm86: ::c_long = 113;\npub const SYS_wait4: ::c_long = 114;\npub const SYS_swapoff: ::c_long = 115;\npub const SYS_sysinfo: ::c_long = 116;\npub const SYS_ipc: ::c_long = 117;\npub const SYS_fsync: ::c_long = 118;\npub const SYS_sigreturn: ::c_long = 119;\npub const SYS_clone: ::c_long = 120;\npub const SYS_setdomainname: ::c_long = 121;\npub const SYS_uname: ::c_long = 122;\npub const SYS_modify_ldt: ::c_long = 123;\npub const SYS_adjtimex: ::c_long = 124;\npub const SYS_mprotect: ::c_long = 125;\npub const SYS_sigprocmask: ::c_long = 126;\npub const SYS_create_module: ::c_long = 127;\npub const SYS_init_module: ::c_long = 128;\npub const SYS_delete_module: ::c_long = 129;\npub const SYS_get_kernel_syms: ::c_long = 130;\npub const SYS_quotactl: ::c_long = 131;\npub const SYS_getpgid: ::c_long = 132;\npub const SYS_fchdir: ::c_long = 133;\npub const SYS_bdflush: ::c_long = 134;\npub const SYS_sysfs: ::c_long = 135;\npub const SYS_personality: ::c_long = 136;\npub const SYS_afs_syscall: ::c_long = 137; /* Syscall for Andrew File System */\npub const SYS_setfsuid: ::c_long = 138;\npub const SYS_setfsgid: ::c_long = 139;\npub const SYS__llseek: ::c_long = 140;\npub const SYS_getdents: ::c_long = 141;\npub const SYS__newselect: ::c_long = 142;\npub const SYS_flock: ::c_long = 143;\npub const SYS_msync: ::c_long = 144;\npub const SYS_readv: ::c_long = 145;\npub const SYS_writev: ::c_long = 146;\npub const SYS_getsid: ::c_long = 147;\npub const SYS_fdatasync: ::c_long = 148;\npub const SYS__sysctl: ::c_long = 149;\npub const SYS_mlock: ::c_long = 150;\npub const SYS_munlock: ::c_long = 151;\npub const SYS_mlockall: ::c_long = 152;\npub const SYS_munlockall: ::c_long = 153;\npub const SYS_sched_setparam: ::c_long = 154;\npub const SYS_sched_getparam: ::c_long = 155;\npub const SYS_sched_setscheduler: ::c_long = 156;\npub const SYS_sched_getscheduler: ::c_long = 157;\npub const SYS_sched_yield: ::c_long = 158;\npub const SYS_sched_get_priority_max: ::c_long = 159;\npub const SYS_sched_get_priority_min: ::c_long = 160;\npub const SYS_sched_rr_get_interval: ::c_long = 161;\npub const SYS_nanosleep: ::c_long = 162;\npub const SYS_mremap: ::c_long = 163;\npub const SYS_setresuid: ::c_long = 164;\npub const SYS_getresuid: ::c_long = 165;\npub const SYS_query_module: ::c_long = 166;\npub const SYS_poll: ::c_long = 167;\npub const SYS_nfsservctl: ::c_long = 168;\npub const SYS_setresgid: ::c_long = 169;\npub const SYS_getresgid: ::c_long = 170;\npub const SYS_prctl: ::c_long = 171;\npub const SYS_rt_sigreturn: ::c_long = 172;\npub const SYS_rt_sigaction: ::c_long = 173;\npub const SYS_rt_sigprocmask: ::c_long = 174;\npub const SYS_rt_sigpending: ::c_long = 175;\npub const SYS_rt_sigtimedwait: ::c_long = 176;\npub const SYS_rt_sigqueueinfo: ::c_long = 177;\npub const SYS_rt_sigsuspend: ::c_long = 178;\npub const SYS_pread64: ::c_long = 179;\npub const SYS_pwrite64: ::c_long = 180;\npub const SYS_chown: ::c_long = 181;\npub const SYS_getcwd: ::c_long = 182;\npub const SYS_capget: ::c_long = 183;\npub const SYS_capset: ::c_long = 184;\npub const SYS_sigaltstack: ::c_long = 185;\npub const SYS_sendfile: ::c_long = 186;\npub const SYS_getpmsg: ::c_long = 187; /* some people actually want streams */\npub const SYS_putpmsg: ::c_long = 188; /* some people actually want streams */\npub const SYS_vfork: ::c_long = 189;\npub const SYS_ugetrlimit: ::c_long = 190; /* SuS compliant getrlimit */\npub const SYS_readahead: ::c_long = 191;\npub const SYS_mmap2: ::c_long = 192;\npub const SYS_truncate64: ::c_long = 193;\npub const SYS_ftruncate64: ::c_long = 194;\npub const SYS_stat64: ::c_long = 195;\npub const SYS_lstat64: ::c_long = 196;\npub const SYS_fstat64: ::c_long = 197;\npub const SYS_pciconfig_read: ::c_long = 198;\npub const SYS_pciconfig_write: ::c_long = 199;\npub const SYS_pciconfig_iobase: ::c_long = 200;\npub const SYS_multiplexer: ::c_long = 201;\npub const SYS_getdents64: ::c_long = 202;\npub const SYS_pivot_root: ::c_long = 203;\npub const SYS_fcntl64: ::c_long = 204;\npub const SYS_madvise: ::c_long = 205;\npub const SYS_mincore: ::c_long = 206;\npub const SYS_gettid: ::c_long = 207;\npub const SYS_tkill: ::c_long = 208;\npub const SYS_setxattr: ::c_long = 209;\npub const SYS_lsetxattr: ::c_long = 210;\npub const SYS_fsetxattr: ::c_long = 211;\npub const SYS_getxattr: ::c_long = 212;\npub const SYS_lgetxattr: ::c_long = 213;\npub const SYS_fgetxattr: ::c_long = 214;\npub const SYS_listxattr: ::c_long = 215;\npub const SYS_llistxattr: ::c_long = 216;\npub const SYS_flistxattr: ::c_long = 217;\npub const SYS_removexattr: ::c_long = 218;\npub const SYS_lremovexattr: ::c_long = 219;\npub const SYS_fremovexattr: ::c_long = 220;\npub const SYS_futex: ::c_long = 221;\npub const SYS_sched_setaffinity: ::c_long = 222;\npub const SYS_sched_getaffinity: ::c_long = 223;\npub const SYS_tuxcall: ::c_long = 225;\npub const SYS_sendfile64: ::c_long = 226;\npub const SYS_io_setup: ::c_long = 227;\npub const SYS_io_destroy: ::c_long = 228;\npub const SYS_io_getevents: ::c_long = 229;\npub const SYS_io_submit: ::c_long = 230;\npub const SYS_io_cancel: ::c_long = 231;\npub const SYS_set_tid_address: ::c_long = 232;\npub const SYS_fadvise64: ::c_long = 233;\npub const SYS_exit_group: ::c_long = 234;\npub const SYS_lookup_dcookie: ::c_long = 235;\npub const SYS_epoll_create: ::c_long = 236;\npub const SYS_epoll_ctl: ::c_long = 237;\npub const SYS_epoll_wait: ::c_long = 238;\npub const SYS_remap_file_pages: ::c_long = 239;\npub const SYS_timer_create: ::c_long = 240;\npub const SYS_timer_settime: ::c_long = 241;\npub const SYS_timer_gettime: ::c_long = 242;\npub const SYS_timer_getoverrun: ::c_long = 243;\npub const SYS_timer_delete: ::c_long = 244;\npub const SYS_clock_settime: ::c_long = 245;\npub const SYS_clock_gettime: ::c_long = 246;\npub const SYS_clock_getres: ::c_long = 247;\npub const SYS_clock_nanosleep: ::c_long = 248;\npub const SYS_swapcontext: ::c_long = 249;\npub const SYS_tgkill: ::c_long = 250;\npub const SYS_utimes: ::c_long = 251;\npub const SYS_statfs64: ::c_long = 252;\npub const SYS_fstatfs64: ::c_long = 253;\npub const SYS_fadvise64_64: ::c_long = 254;\npub const SYS_rtas: ::c_long = 255;\npub const SYS_sys_debug_setcontext: ::c_long = 256;\npub const SYS_migrate_pages: ::c_long = 258;\npub const SYS_mbind: ::c_long = 259;\npub const SYS_get_mempolicy: ::c_long = 260;\npub const SYS_set_mempolicy: ::c_long = 261;\npub const SYS_mq_open: ::c_long = 262;\npub const SYS_mq_unlink: ::c_long = 263;\npub const SYS_mq_timedsend: ::c_long = 264;\npub const SYS_mq_timedreceive: ::c_long = 265;\npub const SYS_mq_notify: ::c_long = 266;\npub const SYS_mq_getsetattr: ::c_long = 267;\npub const SYS_kexec_load: ::c_long = 268;\npub const SYS_add_key: ::c_long = 269;\npub const SYS_request_key: ::c_long = 270;\npub const SYS_keyctl: ::c_long = 271;\npub const SYS_waitid: ::c_long = 272;\npub const SYS_ioprio_set: ::c_long = 273;\npub const SYS_ioprio_get: ::c_long = 274;\npub const SYS_inotify_init: ::c_long = 275;\npub const SYS_inotify_add_watch: ::c_long = 276;\npub const SYS_inotify_rm_watch: ::c_long = 277;\npub const SYS_spu_run: ::c_long = 278;\npub const SYS_spu_create: ::c_long = 279;\npub const SYS_pselect6: ::c_long = 280;\npub const SYS_ppoll: ::c_long = 281;\npub const SYS_unshare: ::c_long = 282;\npub const SYS_splice: ::c_long = 283;\npub const SYS_tee: ::c_long = 284;\npub const SYS_vmsplice: ::c_long = 285;\npub const SYS_openat: ::c_long = 286;\npub const SYS_mkdirat: ::c_long = 287;\npub const SYS_mknodat: ::c_long = 288;\npub const SYS_fchownat: ::c_long = 289;\npub const SYS_futimesat: ::c_long = 290;\npub const SYS_fstatat64: ::c_long = 291;\npub const SYS_unlinkat: ::c_long = 292;\npub const SYS_renameat: ::c_long = 293;\npub const SYS_linkat: ::c_long = 294;\npub const SYS_symlinkat: ::c_long = 295;\npub const SYS_readlinkat: ::c_long = 296;\npub const SYS_fchmodat: ::c_long = 297;\npub const SYS_faccessat: ::c_long = 298;\npub const SYS_get_robust_list: ::c_long = 299;\npub const SYS_set_robust_list: ::c_long = 300;\npub const SYS_move_pages: ::c_long = 301;\npub const SYS_getcpu: ::c_long = 302;\npub const SYS_epoll_pwait: ::c_long = 303;\npub const SYS_utimensat: ::c_long = 304;\npub const SYS_signalfd: ::c_long = 305;\npub const SYS_timerfd_create: ::c_long = 306;\npub const SYS_eventfd: ::c_long = 307;\npub const SYS_sync_file_range2: ::c_long = 308;\npub const SYS_fallocate: ::c_long = 309;\npub const SYS_subpage_prot: ::c_long = 310;\npub const SYS_timerfd_settime: ::c_long = 311;\npub const SYS_timerfd_gettime: ::c_long = 312;\npub const SYS_signalfd4: ::c_long = 313;\npub const SYS_eventfd2: ::c_long = 314;\npub const SYS_epoll_create1: ::c_long = 315;\npub const SYS_dup3: ::c_long = 316;\npub const SYS_pipe2: ::c_long = 317;\npub const SYS_inotify_init1: ::c_long = 318;\npub const SYS_perf_event_open: ::c_long = 319;\npub const SYS_preadv: ::c_long = 320;\npub const SYS_pwritev: ::c_long = 321;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 322;\npub const SYS_fanotify_init: ::c_long = 323;\npub const SYS_fanotify_mark: ::c_long = 324;\npub const SYS_prlimit64: ::c_long = 325;\npub const SYS_socket: ::c_long = 326;\npub const SYS_bind: ::c_long = 327;\npub const SYS_connect: ::c_long = 328;\npub const SYS_listen: ::c_long = 329;\npub const SYS_accept: ::c_long = 330;\npub const SYS_getsockname: ::c_long = 331;\npub const SYS_getpeername: ::c_long = 332;\npub const SYS_socketpair: ::c_long = 333;\npub const SYS_send: ::c_long = 334;\npub const SYS_sendto: ::c_long = 335;\npub const SYS_recv: ::c_long = 336;\npub const SYS_recvfrom: ::c_long = 337;\npub const SYS_shutdown: ::c_long = 338;\npub const SYS_setsockopt: ::c_long = 339;\npub const SYS_getsockopt: ::c_long = 340;\npub const SYS_sendmsg: ::c_long = 341;\npub const SYS_recvmsg: ::c_long = 342;\npub const SYS_recvmmsg: ::c_long = 343;\npub const SYS_accept4: ::c_long = 344;\npub const SYS_name_to_handle_at: ::c_long = 345;\npub const SYS_open_by_handle_at: ::c_long = 346;\npub const SYS_clock_adjtime: ::c_long = 347;\npub const SYS_syncfs: ::c_long = 348;\npub const SYS_sendmmsg: ::c_long = 349;\npub const SYS_setns: ::c_long = 350;\npub const SYS_process_vm_readv: ::c_long = 351;\npub const SYS_process_vm_writev: ::c_long = 352;\npub const SYS_finit_module: ::c_long = 353;\npub const SYS_kcmp: ::c_long = 354;\npub const SYS_sched_setattr: ::c_long = 355;\npub const SYS_sched_getattr: ::c_long = 356;\npub const SYS_renameat2: ::c_long = 357;\npub const SYS_seccomp: ::c_long = 358;\npub const SYS_getrandom: ::c_long = 359;\npub const SYS_memfd_create: ::c_long = 360;\npub const SYS_bpf: ::c_long = 361;\npub const SYS_execveat: ::c_long = 362;\npub const SYS_switch_endian: ::c_long = 363;\npub const SYS_userfaultfd: ::c_long = 364;\npub const SYS_membarrier: ::c_long = 365;\npub const SYS_mlock2: ::c_long = 378;\npub const SYS_copy_file_range: ::c_long = 379;\npub const SYS_preadv2: ::c_long = 380;\npub const SYS_pwritev2: ::c_long = 381;\npub const SYS_kexec_file_load: ::c_long = 382;\npub const SYS_statx: ::c_long = 383;\npub const SYS_pidfd_send_signal: ::c_long = 424;\npub const SYS_io_uring_setup: ::c_long = 425;\npub const SYS_io_uring_enter: ::c_long = 426;\npub const SYS_io_uring_register: ::c_long = 427;\npub const SYS_open_tree: ::c_long = 428;\npub const SYS_move_mount: ::c_long = 429;\npub const SYS_fsopen: ::c_long = 430;\npub const SYS_fsconfig: ::c_long = 431;\npub const SYS_fsmount: ::c_long = 432;\npub const SYS_fspick: ::c_long = 433;\npub const SYS_pidfd_open: ::c_long = 434;\npub const SYS_clone3: ::c_long = 435;\npub const SYS_close_range: ::c_long = 436;\npub const SYS_openat2: ::c_long = 437;\npub const SYS_pidfd_getfd: ::c_long = 438;\npub const SYS_faccessat2: ::c_long = 439;\npub const SYS_process_madvise: ::c_long = 440;\npub const SYS_epoll_pwait2: ::c_long = 441;\npub const SYS_mount_setattr: ::c_long = 442;\n"],["1189","//! SPARC-specific definitions for 32-bit linux-like values\n\npub type c_char = i8;\npub type wchar_t = i32;\n\ns! {\n    pub struct sigaction {\n        pub sa_sigaction: ::sighandler_t,\n        pub sa_mask: ::sigset_t,\n        pub sa_flags: ::c_int,\n        pub sa_restorer: ::Option<extern fn()>,\n    }\n\n    pub struct statfs {\n        pub f_type: ::__fsword_t,\n        pub f_bsize: ::__fsword_t,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n\n        pub f_namelen: ::__fsword_t,\n        pub f_frsize: ::__fsword_t,\n        f_spare: [::__fsword_t; 5],\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_errno: ::c_int,\n        pub si_code: ::c_int,\n        _pad: [::c_int; 29],\n        _align: [usize; 0],\n    }\n\n    pub struct flock {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off_t,\n        pub l_len: ::off_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct flock64 {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off64_t,\n        pub l_len: ::off64_t,\n        pub l_pid: ::pid_t,\n        __reserved:  ::c_short,\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_flags: ::c_int,\n        pub ss_size: ::size_t\n    }\n\n    pub struct stat {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino64_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        __pad2: ::c_ushort,\n        pub st_size: ::off64_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt64_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __unused: [::c_long; 2],\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino64_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        __pad2: ::c_ushort,\n        pub st_size: ::off64_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt64_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __reserved: [::c_long; 2],\n    }\n\n    pub struct statfs64 {\n        pub f_type: ::__fsword_t,\n        pub f_bsize: ::__fsword_t,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::__fsword_t,\n        pub f_frsize: ::__fsword_t,\n        pub f_flags: ::__fsword_t,\n        pub f_spare: [::__fsword_t; 4],\n    }\n\n    pub struct statvfs {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_favail: ::fsfilcnt_t,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_favail: u64,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct ipc_perm {\n        pub __key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        __pad1: ::c_ushort,\n        pub mode: ::c_ushort,\n        __pad2: ::c_ushort,\n        pub __seq: ::c_ushort,\n        __unused1: ::c_ulonglong,\n        __unused2: ::c_ulonglong,\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        __pad1: ::c_uint,\n        pub shm_atime: ::time_t,\n        __pad2: ::c_uint,\n        pub shm_dtime: ::time_t,\n        __pad3: ::c_uint,\n        pub shm_ctime: ::time_t,\n        pub shm_segsz: ::size_t,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::shmatt_t,\n        __reserved1: ::c_ulong,\n        __reserved2: ::c_ulong,\n    }\n\n    pub struct msqid_ds {\n        pub msg_perm: ::ipc_perm,\n        __pad1: ::c_uint,\n        pub msg_stime: ::time_t,\n        __pad2: ::c_uint,\n        pub msg_rtime: ::time_t,\n        __pad3: ::c_uint,\n        pub msg_ctime: ::time_t,\n        __msg_cbytes: ::c_ushort,\n        pub msg_qnum: ::msgqnum_t,\n        pub msg_qbytes: ::msglen_t,\n        pub msg_lspid: ::pid_t,\n        pub msg_lrpid: ::pid_t,\n        __glibc_reserved1: ::c_ulong,\n        __glibc_reserved2: ::c_ulong,\n    }\n\n    pub struct termios2 {\n        pub c_iflag: ::tcflag_t,\n        pub c_oflag: ::tcflag_t,\n        pub c_cflag: ::tcflag_t,\n        pub c_lflag: ::tcflag_t,\n        pub c_line: ::cc_t,\n        pub c_cc: [::cc_t; 19],\n        pub c_ispeed: ::speed_t,\n        pub c_ospeed: ::speed_t,\n    }\n}\n\npub const RLIM_INFINITY: ::rlim_t = !0;\npub const VEOF: usize = 4;\npub const RTLD_DEEPBIND: ::c_int = 0x8;\npub const RTLD_GLOBAL: ::c_int = 0x100;\npub const RTLD_NOLOAD: ::c_int = 0x4;\n\npub const TIOCGSOFTCAR: ::c_ulong = 0x40047464;\npub const TIOCSSOFTCAR: ::c_ulong = 0x80047465;\n\npub const RLIMIT_RSS: ::__rlimit_resource_t = 5;\npub const RLIMIT_AS: ::__rlimit_resource_t = 9;\npub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 8;\npub const RLIMIT_NOFILE: ::__rlimit_resource_t = 6;\npub const RLIMIT_NPROC: ::__rlimit_resource_t = 7;\n\npub const O_APPEND: ::c_int = 0x8;\npub const O_CREAT: ::c_int = 0x200;\npub const O_EXCL: ::c_int = 0x800;\npub const O_NOCTTY: ::c_int = 0x8000;\npub const O_NONBLOCK: ::c_int = 0x4000;\npub const O_SYNC: ::c_int = 0x802000;\npub const O_RSYNC: ::c_int = 0x802000;\npub const O_DSYNC: ::c_int = 0x2000;\npub const O_FSYNC: ::c_int = 0x802000;\n\npub const MADV_SOFT_OFFLINE: ::c_int = 101;\npub const MAP_GROWSDOWN: ::c_int = 0x0200;\npub const MAP_ANON: ::c_int = 0x0020;\npub const MAP_ANONYMOUS: ::c_int = 0x0020;\npub const MAP_DENYWRITE: ::c_int = 0x0800;\npub const MAP_EXECUTABLE: ::c_int = 0x01000;\npub const MAP_POPULATE: ::c_int = 0x08000;\npub const MAP_NONBLOCK: ::c_int = 0x010000;\npub const MAP_STACK: ::c_int = 0x020000;\npub const MAP_HUGETLB: ::c_int = 0x040000;\npub const MAP_SYNC: ::c_int = 0x080000;\n\npub const EDEADLK: ::c_int = 78;\npub const ENAMETOOLONG: ::c_int = 63;\npub const ENOLCK: ::c_int = 79;\npub const ENOSYS: ::c_int = 90;\npub const ENOTEMPTY: ::c_int = 66;\npub const ELOOP: ::c_int = 62;\npub const ENOMSG: ::c_int = 75;\npub const EIDRM: ::c_int = 77;\npub const ECHRNG: ::c_int = 94;\npub const EL2NSYNC: ::c_int = 95;\npub const EL3HLT: ::c_int = 96;\npub const EL3RST: ::c_int = 97;\npub const ELNRNG: ::c_int = 98;\npub const EUNATCH: ::c_int = 99;\npub const ENOCSI: ::c_int = 100;\npub const EL2HLT: ::c_int = 101;\npub const EBADE: ::c_int = 102;\npub const EBADR: ::c_int = 103;\npub const EXFULL: ::c_int = 104;\npub const ENOANO: ::c_int = 105;\npub const EBADRQC: ::c_int = 106;\npub const EBADSLT: ::c_int = 107;\npub const EMULTIHOP: ::c_int = 87;\npub const EOVERFLOW: ::c_int = 92;\npub const ENOTUNIQ: ::c_int = 115;\npub const EBADFD: ::c_int = 93;\npub const EBADMSG: ::c_int = 76;\npub const EREMCHG: ::c_int = 89;\npub const ELIBACC: ::c_int = 114;\npub const ELIBBAD: ::c_int = 112;\npub const ELIBSCN: ::c_int = 124;\npub const ELIBMAX: ::c_int = 123;\npub const ELIBEXEC: ::c_int = 110;\npub const EILSEQ: ::c_int = 122;\npub const ERESTART: ::c_int = 116;\npub const ESTRPIPE: ::c_int = 91;\npub const EUSERS: ::c_int = 68;\npub const ENOTSOCK: ::c_int = 38;\npub const EDESTADDRREQ: ::c_int = 39;\npub const EMSGSIZE: ::c_int = 40;\npub const EPROTOTYPE: ::c_int = 41;\npub const ENOPROTOOPT: ::c_int = 42;\npub const EPROTONOSUPPORT: ::c_int = 43;\npub const ESOCKTNOSUPPORT: ::c_int = 44;\npub const EOPNOTSUPP: ::c_int = 45;\npub const EPFNOSUPPORT: ::c_int = 46;\npub const EAFNOSUPPORT: ::c_int = 47;\npub const EADDRINUSE: ::c_int = 48;\npub const EADDRNOTAVAIL: ::c_int = 49;\npub const ENETDOWN: ::c_int = 50;\npub const ENETUNREACH: ::c_int = 51;\npub const ENETRESET: ::c_int = 52;\npub const ECONNABORTED: ::c_int = 53;\npub const ECONNRESET: ::c_int = 54;\npub const ENOBUFS: ::c_int = 55;\npub const EISCONN: ::c_int = 56;\npub const ENOTCONN: ::c_int = 57;\npub const ESHUTDOWN: ::c_int = 58;\npub const ETOOMANYREFS: ::c_int = 59;\npub const ETIMEDOUT: ::c_int = 60;\npub const ECONNREFUSED: ::c_int = 61;\npub const EHOSTDOWN: ::c_int = 64;\npub const EHOSTUNREACH: ::c_int = 65;\npub const EALREADY: ::c_int = 37;\npub const EINPROGRESS: ::c_int = 36;\npub const ESTALE: ::c_int = 70;\npub const EDQUOT: ::c_int = 69;\npub const ENOMEDIUM: ::c_int = 125;\npub const EMEDIUMTYPE: ::c_int = 126;\npub const ECANCELED: ::c_int = 127;\npub const ENOKEY: ::c_int = 128;\npub const EKEYEXPIRED: ::c_int = 129;\npub const EKEYREVOKED: ::c_int = 130;\npub const EKEYREJECTED: ::c_int = 131;\npub const EOWNERDEAD: ::c_int = 132;\npub const ENOTRECOVERABLE: ::c_int = 133;\npub const EHWPOISON: ::c_int = 135;\npub const ERFKILL: ::c_int = 134;\n\npub const SOCK_STREAM: ::c_int = 1;\npub const SOCK_DGRAM: ::c_int = 2;\n\npub const SA_SIGINFO: ::c_int = 0x200;\npub const SA_NOCLDWAIT: ::c_int = 0x100;\n\npub const SIGTTIN: ::c_int = 21;\npub const SIGTTOU: ::c_int = 22;\npub const SIGXCPU: ::c_int = 24;\npub const SIGXFSZ: ::c_int = 25;\npub const SIGVTALRM: ::c_int = 26;\npub const SIGPROF: ::c_int = 27;\npub const SIGWINCH: ::c_int = 28;\npub const SIGCHLD: ::c_int = 20;\npub const SIGBUS: ::c_int = 10;\npub const SIGUSR1: ::c_int = 30;\npub const SIGUSR2: ::c_int = 31;\npub const SIGCONT: ::c_int = 19;\npub const SIGSTOP: ::c_int = 17;\npub const SIGTSTP: ::c_int = 18;\npub const SIGURG: ::c_int = 16;\npub const SIGIO: ::c_int = 23;\npub const SIGSYS: ::c_int = 12;\npub const SIGPOLL: ::c_int = 23;\npub const SIGPWR: ::c_int = 29;\npub const SIG_SETMASK: ::c_int = 4;\npub const SIG_BLOCK: ::c_int = 1;\npub const SIG_UNBLOCK: ::c_int = 2;\n\npub const POLLWRNORM: ::c_short = 4;\npub const POLLWRBAND: ::c_short = 0x100;\n\npub const O_ASYNC: ::c_int = 0x40;\npub const O_NDELAY: ::c_int = 0x4004;\n\npub const EFD_NONBLOCK: ::c_int = 0x4000;\n\npub const F_GETLK: ::c_int = 7;\npub const F_GETOWN: ::c_int = 5;\npub const F_SETOWN: ::c_int = 6;\n\npub const SFD_NONBLOCK: ::c_int = 0x4000;\n\npub const TCSANOW: ::c_int = 0;\npub const TCSADRAIN: ::c_int = 1;\npub const TCSAFLUSH: ::c_int = 2;\n\npub const TIOCLINUX: ::c_ulong = 0x541C;\npub const TIOCGSERIAL: ::c_ulong = 0x541E;\npub const TIOCEXCL: ::c_ulong = 0x2000740d;\npub const TIOCNXCL: ::c_ulong = 0x2000740e;\npub const TIOCSCTTY: ::c_ulong = 0x20007484;\npub const TIOCSTI: ::c_ulong = 0x80017472;\npub const TIOCMGET: ::c_ulong = 0x4004746a;\npub const TIOCMBIS: ::c_ulong = 0x8004746c;\npub const TIOCMBIC: ::c_ulong = 0x8004746b;\npub const TIOCMSET: ::c_ulong = 0x8004746d;\npub const TIOCCONS: ::c_ulong = 0x20007424;\n\npub const TIOCM_ST: ::c_int = 0x008;\npub const TIOCM_SR: ::c_int = 0x010;\npub const TIOCM_CTS: ::c_int = 0x020;\npub const TIOCM_CAR: ::c_int = 0x040;\npub const TIOCM_RNG: ::c_int = 0x080;\npub const TIOCM_DSR: ::c_int = 0x100;\n\npub const O_DIRECTORY: ::c_int = 0o200000;\npub const O_NOFOLLOW: ::c_int = 0o400000;\npub const O_LARGEFILE: ::c_int = 0x40000;\npub const O_DIRECT: ::c_int = 0x100000;\n\npub const MAP_LOCKED: ::c_int = 0x0100;\npub const MAP_NORESERVE: ::c_int = 0x00040;\n\npub const EDEADLOCK: ::c_int = 108;\npub const EUCLEAN: ::c_int = 117;\npub const ENOTNAM: ::c_int = 118;\npub const ENAVAIL: ::c_int = 119;\npub const EISNAM: ::c_int = 120;\npub const EREMOTEIO: ::c_int = 121;\n\npub const FIOCLEX: ::c_ulong = 0x20006601;\npub const FIONCLEX: ::c_ulong = 0x20006602;\npub const FIONBIO: ::c_ulong = 0x8004667e;\n\npub const MCL_CURRENT: ::c_int = 0x2000;\npub const MCL_FUTURE: ::c_int = 0x4000;\n\npub const SIGSTKSZ: ::size_t = 16384;\npub const MINSIGSTKSZ: ::size_t = 4096;\npub const CBAUD: ::tcflag_t = 0x0000100f;\npub const TAB1: ::tcflag_t = 0x800;\npub const TAB2: ::tcflag_t = 0x1000;\npub const TAB3: ::tcflag_t = 0x1800;\npub const CR1: ::tcflag_t = 0x200;\npub const CR2: ::tcflag_t = 0x400;\npub const CR3: ::tcflag_t = 0x600;\npub const FF1: ::tcflag_t = 0x8000;\npub const BS1: ::tcflag_t = 0x2000;\npub const VT1: ::tcflag_t = 0x4000;\npub const VWERASE: usize = 0xe;\npub const VREPRINT: usize = 0xc;\npub const VSUSP: usize = 0xa;\npub const VSTART: usize = 0x8;\npub const VSTOP: usize = 0x9;\npub const VDISCARD: usize = 0xd;\npub const VTIME: usize = 0x5;\npub const IXON: ::tcflag_t = 0x400;\npub const IXOFF: ::tcflag_t = 0x1000;\npub const ONLCR: ::tcflag_t = 0x4;\npub const CSIZE: ::tcflag_t = 0x30;\npub const CS6: ::tcflag_t = 0x10;\npub const CS7: ::tcflag_t = 0x20;\npub const CS8: ::tcflag_t = 0x30;\npub const CSTOPB: ::tcflag_t = 0x40;\npub const CREAD: ::tcflag_t = 0x80;\npub const PARENB: ::tcflag_t = 0x100;\npub const PARODD: ::tcflag_t = 0x200;\npub const HUPCL: ::tcflag_t = 0x400;\npub const CLOCAL: ::tcflag_t = 0x800;\npub const ECHOKE: ::tcflag_t = 0x800;\npub const ECHOE: ::tcflag_t = 0x10;\npub const ECHOK: ::tcflag_t = 0x20;\npub const ECHONL: ::tcflag_t = 0x40;\npub const ECHOPRT: ::tcflag_t = 0x400;\npub const ECHOCTL: ::tcflag_t = 0x200;\npub const ISIG: ::tcflag_t = 0x1;\npub const ICANON: ::tcflag_t = 0x2;\npub const PENDIN: ::tcflag_t = 0x4000;\npub const NOFLSH: ::tcflag_t = 0x80;\npub const CIBAUD: ::tcflag_t = 0o02003600000;\npub const CBAUDEX: ::tcflag_t = 0x00001000;\npub const VSWTC: usize = 7;\npub const OLCUC: ::tcflag_t = 0o000002;\npub const NLDLY: ::tcflag_t = 0o000400;\npub const CRDLY: ::tcflag_t = 0o003000;\npub const TABDLY: ::tcflag_t = 0o014000;\npub const BSDLY: ::tcflag_t = 0o020000;\npub const FFDLY: ::tcflag_t = 0o100000;\npub const VTDLY: ::tcflag_t = 0o040000;\npub const XTABS: ::tcflag_t = 0o014000;\n\npub const B0: ::speed_t = 0o000000;\npub const B50: ::speed_t = 0o000001;\npub const B75: ::speed_t = 0o000002;\npub const B110: ::speed_t = 0o000003;\npub const B134: ::speed_t = 0o000004;\npub const B150: ::speed_t = 0o000005;\npub const B200: ::speed_t = 0o000006;\npub const B300: ::speed_t = 0o000007;\npub const B600: ::speed_t = 0o000010;\npub const B1200: ::speed_t = 0o000011;\npub const B1800: ::speed_t = 0o000012;\npub const B2400: ::speed_t = 0o000013;\npub const B4800: ::speed_t = 0o000014;\npub const B9600: ::speed_t = 0o000015;\npub const B19200: ::speed_t = 0o000016;\npub const B38400: ::speed_t = 0o000017;\npub const EXTA: ::speed_t = B19200;\npub const EXTB: ::speed_t = B38400;\npub const BOTHER: ::speed_t = 0x1000;\npub const B57600: ::speed_t = 0x1001;\npub const B115200: ::speed_t = 0x1002;\npub const B230400: ::speed_t = 0x1003;\npub const B460800: ::speed_t = 0x1004;\npub const B76800: ::speed_t = 0x1005;\npub const B153600: ::speed_t = 0x1006;\npub const B307200: ::speed_t = 0x1007;\npub const B614400: ::speed_t = 0x1008;\npub const B921600: ::speed_t = 0x1009;\npub const B500000: ::speed_t = 0x100a;\npub const B576000: ::speed_t = 0x100b;\npub const B1000000: ::speed_t = 0x100c;\npub const B1152000: ::speed_t = 0x100d;\npub const B1500000: ::speed_t = 0x100e;\npub const B2000000: ::speed_t = 0x100f;\n\npub const VEOL: usize = 5;\npub const VEOL2: usize = 6;\npub const VMIN: usize = 4;\npub const IEXTEN: ::tcflag_t = 0x8000;\npub const TOSTOP: ::tcflag_t = 0x100;\npub const FLUSHO: ::tcflag_t = 0x1000;\npub const EXTPROC: ::tcflag_t = 0x10000;\npub const TCGETS: ::c_ulong = 0x40245408;\npub const TCSETS: ::c_ulong = 0x80245409;\npub const TCSETSW: ::c_ulong = 0x8024540a;\npub const TCSETSF: ::c_ulong = 0x8024540b;\npub const TCGETA: ::c_ulong = 0x40125401;\npub const TCSETA: ::c_ulong = 0x80125402;\npub const TCSETAW: ::c_ulong = 0x80125403;\npub const TCSETAF: ::c_ulong = 0x80125404;\npub const TCSBRK: ::c_ulong = 0x20005405;\npub const TCXONC: ::c_ulong = 0x20005406;\npub const TCFLSH: ::c_ulong = 0x20005407;\npub const TIOCINQ: ::c_ulong = 0x4004667f;\npub const TIOCGPGRP: ::c_ulong = 0x40047483;\npub const TIOCSPGRP: ::c_ulong = 0x80047482;\npub const TIOCOUTQ: ::c_ulong = 0x40047473;\npub const TIOCGWINSZ: ::c_ulong = 0x40087468;\npub const TIOCSWINSZ: ::c_ulong = 0x80087467;\npub const FIONREAD: ::c_ulong = 0x4004667f;\n\npub const SYS_restart_syscall: ::c_long = 0;\npub const SYS_exit: ::c_long = 1;\npub const SYS_fork: ::c_long = 2;\npub const SYS_read: ::c_long = 3;\npub const SYS_write: ::c_long = 4;\npub const SYS_open: ::c_long = 5;\npub const SYS_close: ::c_long = 6;\npub const SYS_wait4: ::c_long = 7;\npub const SYS_creat: ::c_long = 8;\npub const SYS_link: ::c_long = 9;\npub const SYS_unlink: ::c_long = 10;\npub const SYS_execv: ::c_long = 11;\npub const SYS_chdir: ::c_long = 12;\npub const SYS_chown: ::c_long = 13;\npub const SYS_mknod: ::c_long = 14;\npub const SYS_chmod: ::c_long = 15;\npub const SYS_lchown: ::c_long = 16;\npub const SYS_brk: ::c_long = 17;\npub const SYS_perfctr: ::c_long = 18;\npub const SYS_lseek: ::c_long = 19;\npub const SYS_getpid: ::c_long = 20;\npub const SYS_capget: ::c_long = 21;\npub const SYS_capset: ::c_long = 22;\npub const SYS_setuid: ::c_long = 23;\npub const SYS_getuid: ::c_long = 24;\npub const SYS_vmsplice: ::c_long = 25;\npub const SYS_ptrace: ::c_long = 26;\npub const SYS_alarm: ::c_long = 27;\npub const SYS_sigaltstack: ::c_long = 28;\npub const SYS_pause: ::c_long = 29;\npub const SYS_utime: ::c_long = 30;\npub const SYS_lchown32: ::c_long = 31;\npub const SYS_fchown32: ::c_long = 32;\npub const SYS_access: ::c_long = 33;\npub const SYS_nice: ::c_long = 34;\npub const SYS_chown32: ::c_long = 35;\npub const SYS_sync: ::c_long = 36;\npub const SYS_kill: ::c_long = 37;\npub const SYS_stat: ::c_long = 38;\npub const SYS_sendfile: ::c_long = 39;\npub const SYS_lstat: ::c_long = 40;\npub const SYS_dup: ::c_long = 41;\npub const SYS_pipe: ::c_long = 42;\npub const SYS_times: ::c_long = 43;\npub const SYS_getuid32: ::c_long = 44;\npub const SYS_umount2: ::c_long = 45;\npub const SYS_setgid: ::c_long = 46;\npub const SYS_getgid: ::c_long = 47;\npub const SYS_signal: ::c_long = 48;\npub const SYS_geteuid: ::c_long = 49;\npub const SYS_getegid: ::c_long = 50;\npub const SYS_acct: ::c_long = 51;\npub const SYS_getgid32: ::c_long = 53;\npub const SYS_ioctl: ::c_long = 54;\npub const SYS_reboot: ::c_long = 55;\npub const SYS_mmap2: ::c_long = 56;\npub const SYS_symlink: ::c_long = 57;\npub const SYS_readlink: ::c_long = 58;\npub const SYS_execve: ::c_long = 59;\npub const SYS_umask: ::c_long = 60;\npub const SYS_chroot: ::c_long = 61;\npub const SYS_fstat: ::c_long = 62;\npub const SYS_fstat64: ::c_long = 63;\npub const SYS_getpagesize: ::c_long = 64;\npub const SYS_msync: ::c_long = 65;\npub const SYS_vfork: ::c_long = 66;\npub const SYS_pread64: ::c_long = 67;\npub const SYS_pwrite64: ::c_long = 68;\npub const SYS_geteuid32: ::c_long = 69;\npub const SYS_getegid32: ::c_long = 70;\npub const SYS_mmap: ::c_long = 71;\npub const SYS_setreuid32: ::c_long = 72;\npub const SYS_munmap: ::c_long = 73;\npub const SYS_mprotect: ::c_long = 74;\npub const SYS_madvise: ::c_long = 75;\npub const SYS_vhangup: ::c_long = 76;\npub const SYS_truncate64: ::c_long = 77;\npub const SYS_mincore: ::c_long = 78;\npub const SYS_getgroups: ::c_long = 79;\npub const SYS_setgroups: ::c_long = 80;\npub const SYS_getpgrp: ::c_long = 81;\npub const SYS_setgroups32: ::c_long = 82;\npub const SYS_setitimer: ::c_long = 83;\npub const SYS_ftruncate64: ::c_long = 84;\npub const SYS_swapon: ::c_long = 85;\npub const SYS_getitimer: ::c_long = 86;\npub const SYS_setuid32: ::c_long = 87;\npub const SYS_sethostname: ::c_long = 88;\npub const SYS_setgid32: ::c_long = 89;\npub const SYS_dup2: ::c_long = 90;\npub const SYS_setfsuid32: ::c_long = 91;\npub const SYS_fcntl: ::c_long = 92;\npub const SYS_select: ::c_long = 93;\npub const SYS_setfsgid32: ::c_long = 94;\npub const SYS_fsync: ::c_long = 95;\npub const SYS_setpriority: ::c_long = 96;\npub const SYS_socket: ::c_long = 97;\npub const SYS_connect: ::c_long = 98;\npub const SYS_accept: ::c_long = 99;\npub const SYS_getpriority: ::c_long = 100;\npub const SYS_rt_sigreturn: ::c_long = 101;\npub const SYS_rt_sigaction: ::c_long = 102;\npub const SYS_rt_sigprocmask: ::c_long = 103;\npub const SYS_rt_sigpending: ::c_long = 104;\npub const SYS_rt_sigtimedwait: ::c_long = 105;\npub const SYS_rt_sigqueueinfo: ::c_long = 106;\npub const SYS_rt_sigsuspend: ::c_long = 107;\npub const SYS_setresuid32: ::c_long = 108;\npub const SYS_getresuid32: ::c_long = 109;\npub const SYS_setresgid32: ::c_long = 110;\npub const SYS_getresgid32: ::c_long = 111;\npub const SYS_setregid32: ::c_long = 112;\npub const SYS_recvmsg: ::c_long = 113;\npub const SYS_sendmsg: ::c_long = 114;\npub const SYS_getgroups32: ::c_long = 115;\npub const SYS_gettimeofday: ::c_long = 116;\npub const SYS_getrusage: ::c_long = 117;\npub const SYS_getsockopt: ::c_long = 118;\npub const SYS_getcwd: ::c_long = 119;\npub const SYS_readv: ::c_long = 120;\npub const SYS_writev: ::c_long = 121;\npub const SYS_settimeofday: ::c_long = 122;\npub const SYS_fchown: ::c_long = 123;\npub const SYS_fchmod: ::c_long = 124;\npub const SYS_recvfrom: ::c_long = 125;\npub const SYS_setreuid: ::c_long = 126;\npub const SYS_setregid: ::c_long = 127;\npub const SYS_rename: ::c_long = 128;\npub const SYS_truncate: ::c_long = 129;\npub const SYS_ftruncate: ::c_long = 130;\npub const SYS_flock: ::c_long = 131;\npub const SYS_lstat64: ::c_long = 132;\npub const SYS_sendto: ::c_long = 133;\npub const SYS_shutdown: ::c_long = 134;\npub const SYS_socketpair: ::c_long = 135;\npub const SYS_mkdir: ::c_long = 136;\npub const SYS_rmdir: ::c_long = 137;\npub const SYS_utimes: ::c_long = 138;\npub const SYS_stat64: ::c_long = 139;\npub const SYS_sendfile64: ::c_long = 140;\npub const SYS_getpeername: ::c_long = 141;\npub const SYS_futex: ::c_long = 142;\npub const SYS_gettid: ::c_long = 143;\npub const SYS_getrlimit: ::c_long = 144;\npub const SYS_setrlimit: ::c_long = 145;\npub const SYS_pivot_root: ::c_long = 146;\npub const SYS_prctl: ::c_long = 147;\npub const SYS_pciconfig_read: ::c_long = 148;\npub const SYS_pciconfig_write: ::c_long = 149;\npub const SYS_getsockname: ::c_long = 150;\npub const SYS_inotify_init: ::c_long = 151;\npub const SYS_inotify_add_watch: ::c_long = 152;\npub const SYS_poll: ::c_long = 153;\npub const SYS_getdents64: ::c_long = 154;\npub const SYS_fcntl64: ::c_long = 155;\npub const SYS_inotify_rm_watch: ::c_long = 156;\npub const SYS_statfs: ::c_long = 157;\npub const SYS_fstatfs: ::c_long = 158;\npub const SYS_umount: ::c_long = 159;\npub const SYS_sched_set_affinity: ::c_long = 160;\npub const SYS_sched_get_affinity: ::c_long = 161;\npub const SYS_getdomainname: ::c_long = 162;\npub const SYS_setdomainname: ::c_long = 163;\npub const SYS_quotactl: ::c_long = 165;\npub const SYS_set_tid_address: ::c_long = 166;\npub const SYS_mount: ::c_long = 167;\npub const SYS_ustat: ::c_long = 168;\npub const SYS_setxattr: ::c_long = 169;\npub const SYS_lsetxattr: ::c_long = 170;\npub const SYS_fsetxattr: ::c_long = 171;\npub const SYS_getxattr: ::c_long = 172;\npub const SYS_lgetxattr: ::c_long = 173;\npub const SYS_getdents: ::c_long = 174;\npub const SYS_setsid: ::c_long = 175;\npub const SYS_fchdir: ::c_long = 176;\npub const SYS_fgetxattr: ::c_long = 177;\npub const SYS_listxattr: ::c_long = 178;\npub const SYS_llistxattr: ::c_long = 179;\npub const SYS_flistxattr: ::c_long = 180;\npub const SYS_removexattr: ::c_long = 181;\npub const SYS_lremovexattr: ::c_long = 182;\npub const SYS_sigpending: ::c_long = 183;\npub const SYS_query_module: ::c_long = 184;\npub const SYS_setpgid: ::c_long = 185;\npub const SYS_fremovexattr: ::c_long = 186;\npub const SYS_tkill: ::c_long = 187;\npub const SYS_exit_group: ::c_long = 188;\npub const SYS_uname: ::c_long = 189;\npub const SYS_init_module: ::c_long = 190;\npub const SYS_personality: ::c_long = 191;\npub const SYS_remap_file_pages: ::c_long = 192;\npub const SYS_epoll_create: ::c_long = 193;\npub const SYS_epoll_ctl: ::c_long = 194;\npub const SYS_epoll_wait: ::c_long = 195;\npub const SYS_ioprio_set: ::c_long = 196;\npub const SYS_getppid: ::c_long = 197;\npub const SYS_sigaction: ::c_long = 198;\npub const SYS_sgetmask: ::c_long = 199;\npub const SYS_ssetmask: ::c_long = 200;\npub const SYS_sigsuspend: ::c_long = 201;\npub const SYS_oldlstat: ::c_long = 202;\npub const SYS_uselib: ::c_long = 203;\npub const SYS_readdir: ::c_long = 204;\npub const SYS_readahead: ::c_long = 205;\npub const SYS_socketcall: ::c_long = 206;\npub const SYS_syslog: ::c_long = 207;\npub const SYS_lookup_dcookie: ::c_long = 208;\npub const SYS_fadvise64: ::c_long = 209;\npub const SYS_fadvise64_64: ::c_long = 210;\npub const SYS_tgkill: ::c_long = 211;\npub const SYS_waitpid: ::c_long = 212;\npub const SYS_swapoff: ::c_long = 213;\npub const SYS_sysinfo: ::c_long = 214;\npub const SYS_ipc: ::c_long = 215;\npub const SYS_sigreturn: ::c_long = 216;\npub const SYS_clone: ::c_long = 217;\npub const SYS_ioprio_get: ::c_long = 218;\npub const SYS_adjtimex: ::c_long = 219;\npub const SYS_sigprocmask: ::c_long = 220;\npub const SYS_create_module: ::c_long = 221;\npub const SYS_delete_module: ::c_long = 222;\npub const SYS_get_kernel_syms: ::c_long = 223;\npub const SYS_getpgid: ::c_long = 224;\npub const SYS_bdflush: ::c_long = 225;\npub const SYS_sysfs: ::c_long = 226;\npub const SYS_afs_syscall: ::c_long = 227;\npub const SYS_setfsuid: ::c_long = 228;\npub const SYS_setfsgid: ::c_long = 229;\npub const SYS__newselect: ::c_long = 230;\npub const SYS_time: ::c_long = 231;\npub const SYS_splice: ::c_long = 232;\npub const SYS_stime: ::c_long = 233;\npub const SYS_statfs64: ::c_long = 234;\npub const SYS_fstatfs64: ::c_long = 235;\npub const SYS__llseek: ::c_long = 236;\npub const SYS_mlock: ::c_long = 237;\npub const SYS_munlock: ::c_long = 238;\npub const SYS_mlockall: ::c_long = 239;\npub const SYS_munlockall: ::c_long = 240;\npub const SYS_sched_setparam: ::c_long = 241;\npub const SYS_sched_getparam: ::c_long = 242;\npub const SYS_sched_setscheduler: ::c_long = 243;\npub const SYS_sched_getscheduler: ::c_long = 244;\npub const SYS_sched_yield: ::c_long = 245;\npub const SYS_sched_get_priority_max: ::c_long = 246;\npub const SYS_sched_get_priority_min: ::c_long = 247;\npub const SYS_sched_rr_get_interval: ::c_long = 248;\npub const SYS_nanosleep: ::c_long = 249;\npub const SYS_mremap: ::c_long = 250;\npub const SYS__sysctl: ::c_long = 251;\npub const SYS_getsid: ::c_long = 252;\npub const SYS_fdatasync: ::c_long = 253;\npub const SYS_nfsservctl: ::c_long = 254;\npub const SYS_sync_file_range: ::c_long = 255;\npub const SYS_clock_settime: ::c_long = 256;\npub const SYS_clock_gettime: ::c_long = 257;\npub const SYS_clock_getres: ::c_long = 258;\npub const SYS_clock_nanosleep: ::c_long = 259;\npub const SYS_sched_getaffinity: ::c_long = 260;\npub const SYS_sched_setaffinity: ::c_long = 261;\npub const SYS_timer_settime: ::c_long = 262;\npub const SYS_timer_gettime: ::c_long = 263;\npub const SYS_timer_getoverrun: ::c_long = 264;\npub const SYS_timer_delete: ::c_long = 265;\npub const SYS_timer_create: ::c_long = 266;\npub const SYS_io_setup: ::c_long = 268;\npub const SYS_io_destroy: ::c_long = 269;\npub const SYS_io_submit: ::c_long = 270;\npub const SYS_io_cancel: ::c_long = 271;\npub const SYS_io_getevents: ::c_long = 272;\npub const SYS_mq_open: ::c_long = 273;\npub const SYS_mq_unlink: ::c_long = 274;\npub const SYS_mq_timedsend: ::c_long = 275;\npub const SYS_mq_timedreceive: ::c_long = 276;\npub const SYS_mq_notify: ::c_long = 277;\npub const SYS_mq_getsetattr: ::c_long = 278;\npub const SYS_waitid: ::c_long = 279;\npub const SYS_tee: ::c_long = 280;\npub const SYS_add_key: ::c_long = 281;\npub const SYS_request_key: ::c_long = 282;\npub const SYS_keyctl: ::c_long = 283;\npub const SYS_openat: ::c_long = 284;\npub const SYS_mkdirat: ::c_long = 285;\npub const SYS_mknodat: ::c_long = 286;\npub const SYS_fchownat: ::c_long = 287;\npub const SYS_futimesat: ::c_long = 288;\npub const SYS_fstatat64: ::c_long = 289;\npub const SYS_unlinkat: ::c_long = 290;\npub const SYS_renameat: ::c_long = 291;\npub const SYS_linkat: ::c_long = 292;\npub const SYS_symlinkat: ::c_long = 293;\npub const SYS_readlinkat: ::c_long = 294;\npub const SYS_fchmodat: ::c_long = 295;\npub const SYS_faccessat: ::c_long = 296;\npub const SYS_pselect6: ::c_long = 297;\npub const SYS_ppoll: ::c_long = 298;\npub const SYS_unshare: ::c_long = 299;\npub const SYS_set_robust_list: ::c_long = 300;\npub const SYS_get_robust_list: ::c_long = 301;\npub const SYS_migrate_pages: ::c_long = 302;\npub const SYS_mbind: ::c_long = 303;\npub const SYS_get_mempolicy: ::c_long = 304;\npub const SYS_set_mempolicy: ::c_long = 305;\npub const SYS_kexec_load: ::c_long = 306;\npub const SYS_move_pages: ::c_long = 307;\npub const SYS_getcpu: ::c_long = 308;\npub const SYS_epoll_pwait: ::c_long = 309;\npub const SYS_utimensat: ::c_long = 310;\npub const SYS_signalfd: ::c_long = 311;\npub const SYS_timerfd_create: ::c_long = 312;\npub const SYS_eventfd: ::c_long = 313;\npub const SYS_fallocate: ::c_long = 314;\npub const SYS_timerfd_settime: ::c_long = 315;\npub const SYS_timerfd_gettime: ::c_long = 316;\npub const SYS_signalfd4: ::c_long = 317;\npub const SYS_eventfd2: ::c_long = 318;\npub const SYS_epoll_create1: ::c_long = 319;\npub const SYS_dup3: ::c_long = 320;\npub const SYS_pipe2: ::c_long = 321;\npub const SYS_inotify_init1: ::c_long = 322;\npub const SYS_accept4: ::c_long = 323;\npub const SYS_preadv: ::c_long = 324;\npub const SYS_pwritev: ::c_long = 325;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 326;\npub const SYS_perf_event_open: ::c_long = 327;\npub const SYS_recvmmsg: ::c_long = 328;\npub const SYS_fanotify_init: ::c_long = 329;\npub const SYS_fanotify_mark: ::c_long = 330;\npub const SYS_prlimit64: ::c_long = 331;\npub const SYS_name_to_handle_at: ::c_long = 332;\npub const SYS_open_by_handle_at: ::c_long = 333;\npub const SYS_clock_adjtime: ::c_long = 334;\npub const SYS_syncfs: ::c_long = 335;\npub const SYS_sendmmsg: ::c_long = 336;\npub const SYS_setns: ::c_long = 337;\npub const SYS_process_vm_readv: ::c_long = 338;\npub const SYS_process_vm_writev: ::c_long = 339;\npub const SYS_kern_features: ::c_long = 340;\npub const SYS_kcmp: ::c_long = 341;\npub const SYS_finit_module: ::c_long = 342;\npub const SYS_sched_setattr: ::c_long = 343;\npub const SYS_sched_getattr: ::c_long = 344;\npub const SYS_renameat2: ::c_long = 345;\npub const SYS_seccomp: ::c_long = 346;\npub const SYS_getrandom: ::c_long = 347;\npub const SYS_memfd_create: ::c_long = 348;\npub const SYS_bpf: ::c_long = 349;\npub const SYS_execveat: ::c_long = 350;\npub const SYS_membarrier: ::c_long = 351;\npub const SYS_userfaultfd: ::c_long = 352;\npub const SYS_bind: ::c_long = 353;\npub const SYS_listen: ::c_long = 354;\npub const SYS_setsockopt: ::c_long = 355;\npub const SYS_mlock2: ::c_long = 356;\npub const SYS_copy_file_range: ::c_long = 357;\npub const SYS_preadv2: ::c_long = 358;\npub const SYS_pwritev2: ::c_long = 359;\npub const SYS_statx: ::c_long = 360;\npub const SYS_pidfd_send_signal: ::c_long = 424;\npub const SYS_io_uring_setup: ::c_long = 425;\npub const SYS_io_uring_enter: ::c_long = 426;\npub const SYS_io_uring_register: ::c_long = 427;\npub const SYS_open_tree: ::c_long = 428;\npub const SYS_move_mount: ::c_long = 429;\npub const SYS_fsopen: ::c_long = 430;\npub const SYS_fsconfig: ::c_long = 431;\npub const SYS_fsmount: ::c_long = 432;\npub const SYS_fspick: ::c_long = 433;\npub const SYS_pidfd_open: ::c_long = 434;\n// Reserved in the kernel, but not actually implemented yet\npub const SYS_clone3: ::c_long = 435;\npub const SYS_close_range: ::c_long = 436;\npub const SYS_openat2: ::c_long = 437;\npub const SYS_pidfd_getfd: ::c_long = 438;\npub const SYS_faccessat2: ::c_long = 439;\npub const SYS_process_madvise: ::c_long = 440;\npub const SYS_epoll_pwait2: ::c_long = 441;\npub const SYS_mount_setattr: ::c_long = 442;\n\ncfg_if! {\n    if #[cfg(libc_align)] {\n        mod align;\n        pub use self::align::*;\n    }\n}\n"],["1190","s_no_extra_traits! {\n    #[allow(missing_debug_implementations)]\n    #[repr(align(8))]\n    pub struct max_align_t {\n        priv_: [i64; 3]\n    }\n}\n"],["1191","pub type c_char = i8;\npub type wchar_t = i32;\n\ns! {\n    pub struct stat64 {\n        pub st_dev: ::c_ulong,\n        st_pad1: [::c_long; 3],\n        pub st_ino: ::ino64_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::c_ulong,\n        st_pad2: [::c_long; 2],\n        pub st_size: ::off64_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        pub st_blksize: ::blksize_t,\n        st_pad3: ::c_long,\n        pub st_blocks: ::blkcnt64_t,\n        st_pad5: [::c_long; 14],\n    }\n\n    pub struct statfs {\n        pub f_type: ::c_long,\n        pub f_bsize: ::c_long,\n        pub f_frsize: ::c_long,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_files: ::fsblkcnt_t,\n        pub f_ffree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_fsid: ::fsid_t,\n\n        pub f_namelen: ::c_long,\n        f_spare: [::c_long; 6],\n    }\n\n    pub struct statfs64 {\n        pub f_type: ::c_long,\n        pub f_bsize: ::c_long,\n        pub f_frsize: ::c_long,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_bavail: u64,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_long,\n        pub f_flags: ::c_long,\n        pub f_spare: [::c_long; 5],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_favail: u64,\n        pub f_fsid: ::c_ulong,\n        __f_unused: ::c_int,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct sigaction {\n        pub sa_flags: ::c_int,\n        pub sa_sigaction: ::sighandler_t,\n        pub sa_mask: ::sigset_t,\n        pub sa_restorer: ::Option<extern fn()>,\n        _resv: [::c_int; 1],\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_size: ::size_t,\n        pub ss_flags: ::c_int,\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_code: ::c_int,\n        pub si_errno: ::c_int,\n        pub _pad: [::c_int; 29],\n    }\n\n    pub struct ipc_perm {\n        pub __key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::c_uint,\n        pub __seq: ::c_ushort,\n        __pad1: ::c_ushort,\n        __unused1: ::c_ulong,\n        __unused2: ::c_ulong\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        pub shm_segsz: ::size_t,\n        pub shm_atime: ::time_t,\n        pub shm_dtime: ::time_t,\n        pub shm_ctime: ::time_t,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::shmatt_t,\n        __unused4: ::c_ulong,\n        __unused5: ::c_ulong\n    }\n\n    pub struct msqid_ds {\n        pub msg_perm: ::ipc_perm,\n        #[cfg(target_endian = \"big\")]\n        __glibc_reserved1: ::c_ulong,\n        pub msg_stime: ::time_t,\n        #[cfg(target_endian = \"little\")]\n        __glibc_reserved1: ::c_ulong,\n        #[cfg(target_endian = \"big\")]\n        __glibc_reserved2: ::c_ulong,\n        pub msg_rtime: ::time_t,\n        #[cfg(target_endian = \"little\")]\n        __glibc_reserved2: ::c_ulong,\n        #[cfg(target_endian = \"big\")]\n        __glibc_reserved3: ::c_ulong,\n        pub msg_ctime: ::time_t,\n        #[cfg(target_endian = \"little\")]\n        __glibc_reserved3: ::c_ulong,\n        __msg_cbytes: ::c_ulong,\n        pub msg_qnum: ::msgqnum_t,\n        pub msg_qbytes: ::msglen_t,\n        pub msg_lspid: ::pid_t,\n        pub msg_lrpid: ::pid_t,\n        __glibc_reserved4: ::c_ulong,\n        __glibc_reserved5: ::c_ulong,\n    }\n\n    pub struct flock {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off_t,\n        pub l_len: ::off_t,\n        pub l_sysid: ::c_long,\n        pub l_pid: ::pid_t,\n        pad: [::c_long; 4],\n    }\n\n    pub struct termios2 {\n        pub c_iflag: ::tcflag_t,\n        pub c_oflag: ::tcflag_t,\n        pub c_cflag: ::tcflag_t,\n        pub c_lflag: ::tcflag_t,\n        pub c_line: ::cc_t,\n        pub c_cc: [::cc_t; 23],\n        pub c_ispeed: ::speed_t,\n        pub c_ospeed: ::speed_t,\n    }\n}\n\npub const O_LARGEFILE: ::c_int = 0x2000;\n\npub const SYS_syscall: ::c_long = 4000 + 0;\npub const SYS_exit: ::c_long = 4000 + 1;\npub const SYS_fork: ::c_long = 4000 + 2;\npub const SYS_read: ::c_long = 4000 + 3;\npub const SYS_write: ::c_long = 4000 + 4;\npub const SYS_open: ::c_long = 4000 + 5;\npub const SYS_close: ::c_long = 4000 + 6;\npub const SYS_waitpid: ::c_long = 4000 + 7;\npub const SYS_creat: ::c_long = 4000 + 8;\npub const SYS_link: ::c_long = 4000 + 9;\npub const SYS_unlink: ::c_long = 4000 + 10;\npub const SYS_execve: ::c_long = 4000 + 11;\npub const SYS_chdir: ::c_long = 4000 + 12;\npub const SYS_time: ::c_long = 4000 + 13;\npub const SYS_mknod: ::c_long = 4000 + 14;\npub const SYS_chmod: ::c_long = 4000 + 15;\npub const SYS_lchown: ::c_long = 4000 + 16;\npub const SYS_break: ::c_long = 4000 + 17;\npub const SYS_lseek: ::c_long = 4000 + 19;\npub const SYS_getpid: ::c_long = 4000 + 20;\npub const SYS_mount: ::c_long = 4000 + 21;\npub const SYS_umount: ::c_long = 4000 + 22;\npub const SYS_setuid: ::c_long = 4000 + 23;\npub const SYS_getuid: ::c_long = 4000 + 24;\npub const SYS_stime: ::c_long = 4000 + 25;\npub const SYS_ptrace: ::c_long = 4000 + 26;\npub const SYS_alarm: ::c_long = 4000 + 27;\npub const SYS_pause: ::c_long = 4000 + 29;\npub const SYS_utime: ::c_long = 4000 + 30;\npub const SYS_stty: ::c_long = 4000 + 31;\npub const SYS_gtty: ::c_long = 4000 + 32;\npub const SYS_access: ::c_long = 4000 + 33;\npub const SYS_nice: ::c_long = 4000 + 34;\npub const SYS_ftime: ::c_long = 4000 + 35;\npub const SYS_sync: ::c_long = 4000 + 36;\npub const SYS_kill: ::c_long = 4000 + 37;\npub const SYS_rename: ::c_long = 4000 + 38;\npub const SYS_mkdir: ::c_long = 4000 + 39;\npub const SYS_rmdir: ::c_long = 4000 + 40;\npub const SYS_dup: ::c_long = 4000 + 41;\npub const SYS_pipe: ::c_long = 4000 + 42;\npub const SYS_times: ::c_long = 4000 + 43;\npub const SYS_prof: ::c_long = 4000 + 44;\npub const SYS_brk: ::c_long = 4000 + 45;\npub const SYS_setgid: ::c_long = 4000 + 46;\npub const SYS_getgid: ::c_long = 4000 + 47;\npub const SYS_signal: ::c_long = 4000 + 48;\npub const SYS_geteuid: ::c_long = 4000 + 49;\npub const SYS_getegid: ::c_long = 4000 + 50;\npub const SYS_acct: ::c_long = 4000 + 51;\npub const SYS_umount2: ::c_long = 4000 + 52;\npub const SYS_lock: ::c_long = 4000 + 53;\npub const SYS_ioctl: ::c_long = 4000 + 54;\npub const SYS_fcntl: ::c_long = 4000 + 55;\npub const SYS_mpx: ::c_long = 4000 + 56;\npub const SYS_setpgid: ::c_long = 4000 + 57;\npub const SYS_ulimit: ::c_long = 4000 + 58;\npub const SYS_umask: ::c_long = 4000 + 60;\npub const SYS_chroot: ::c_long = 4000 + 61;\npub const SYS_ustat: ::c_long = 4000 + 62;\npub const SYS_dup2: ::c_long = 4000 + 63;\npub const SYS_getppid: ::c_long = 4000 + 64;\npub const SYS_getpgrp: ::c_long = 4000 + 65;\npub const SYS_setsid: ::c_long = 4000 + 66;\npub const SYS_sigaction: ::c_long = 4000 + 67;\npub const SYS_sgetmask: ::c_long = 4000 + 68;\npub const SYS_ssetmask: ::c_long = 4000 + 69;\npub const SYS_setreuid: ::c_long = 4000 + 70;\npub const SYS_setregid: ::c_long = 4000 + 71;\npub const SYS_sigsuspend: ::c_long = 4000 + 72;\npub const SYS_sigpending: ::c_long = 4000 + 73;\npub const SYS_sethostname: ::c_long = 4000 + 74;\npub const SYS_setrlimit: ::c_long = 4000 + 75;\npub const SYS_getrlimit: ::c_long = 4000 + 76;\npub const SYS_getrusage: ::c_long = 4000 + 77;\npub const SYS_gettimeofday: ::c_long = 4000 + 78;\npub const SYS_settimeofday: ::c_long = 4000 + 79;\npub const SYS_getgroups: ::c_long = 4000 + 80;\npub const SYS_setgroups: ::c_long = 4000 + 81;\npub const SYS_symlink: ::c_long = 4000 + 83;\npub const SYS_readlink: ::c_long = 4000 + 85;\npub const SYS_uselib: ::c_long = 4000 + 86;\npub const SYS_swapon: ::c_long = 4000 + 87;\npub const SYS_reboot: ::c_long = 4000 + 88;\npub const SYS_readdir: ::c_long = 4000 + 89;\npub const SYS_mmap: ::c_long = 4000 + 90;\npub const SYS_munmap: ::c_long = 4000 + 91;\npub const SYS_truncate: ::c_long = 4000 + 92;\npub const SYS_ftruncate: ::c_long = 4000 + 93;\npub const SYS_fchmod: ::c_long = 4000 + 94;\npub const SYS_fchown: ::c_long = 4000 + 95;\npub const SYS_getpriority: ::c_long = 4000 + 96;\npub const SYS_setpriority: ::c_long = 4000 + 97;\npub const SYS_profil: ::c_long = 4000 + 98;\npub const SYS_statfs: ::c_long = 4000 + 99;\npub const SYS_fstatfs: ::c_long = 4000 + 100;\npub const SYS_ioperm: ::c_long = 4000 + 101;\npub const SYS_socketcall: ::c_long = 4000 + 102;\npub const SYS_syslog: ::c_long = 4000 + 103;\npub const SYS_setitimer: ::c_long = 4000 + 104;\npub const SYS_getitimer: ::c_long = 4000 + 105;\npub const SYS_stat: ::c_long = 4000 + 106;\npub const SYS_lstat: ::c_long = 4000 + 107;\npub const SYS_fstat: ::c_long = 4000 + 108;\npub const SYS_iopl: ::c_long = 4000 + 110;\npub const SYS_vhangup: ::c_long = 4000 + 111;\npub const SYS_idle: ::c_long = 4000 + 112;\npub const SYS_vm86: ::c_long = 4000 + 113;\npub const SYS_wait4: ::c_long = 4000 + 114;\npub const SYS_swapoff: ::c_long = 4000 + 115;\npub const SYS_sysinfo: ::c_long = 4000 + 116;\npub const SYS_ipc: ::c_long = 4000 + 117;\npub const SYS_fsync: ::c_long = 4000 + 118;\npub const SYS_sigreturn: ::c_long = 4000 + 119;\npub const SYS_clone: ::c_long = 4000 + 120;\npub const SYS_setdomainname: ::c_long = 4000 + 121;\npub const SYS_uname: ::c_long = 4000 + 122;\npub const SYS_modify_ldt: ::c_long = 4000 + 123;\npub const SYS_adjtimex: ::c_long = 4000 + 124;\npub const SYS_mprotect: ::c_long = 4000 + 125;\npub const SYS_sigprocmask: ::c_long = 4000 + 126;\npub const SYS_create_module: ::c_long = 4000 + 127;\npub const SYS_init_module: ::c_long = 4000 + 128;\npub const SYS_delete_module: ::c_long = 4000 + 129;\npub const SYS_get_kernel_syms: ::c_long = 4000 + 130;\npub const SYS_quotactl: ::c_long = 4000 + 131;\npub const SYS_getpgid: ::c_long = 4000 + 132;\npub const SYS_fchdir: ::c_long = 4000 + 133;\npub const SYS_bdflush: ::c_long = 4000 + 134;\npub const SYS_sysfs: ::c_long = 4000 + 135;\npub const SYS_personality: ::c_long = 4000 + 136;\npub const SYS_afs_syscall: ::c_long = 4000 + 137;\npub const SYS_setfsuid: ::c_long = 4000 + 138;\npub const SYS_setfsgid: ::c_long = 4000 + 139;\npub const SYS__llseek: ::c_long = 4000 + 140;\npub const SYS_getdents: ::c_long = 4000 + 141;\npub const SYS__newselect: ::c_long = 4000 + 142;\npub const SYS_flock: ::c_long = 4000 + 143;\npub const SYS_msync: ::c_long = 4000 + 144;\npub const SYS_readv: ::c_long = 4000 + 145;\npub const SYS_writev: ::c_long = 4000 + 146;\npub const SYS_cacheflush: ::c_long = 4000 + 147;\npub const SYS_cachectl: ::c_long = 4000 + 148;\npub const SYS_sysmips: ::c_long = 4000 + 149;\npub const SYS_getsid: ::c_long = 4000 + 151;\npub const SYS_fdatasync: ::c_long = 4000 + 152;\npub const SYS__sysctl: ::c_long = 4000 + 153;\npub const SYS_mlock: ::c_long = 4000 + 154;\npub const SYS_munlock: ::c_long = 4000 + 155;\npub const SYS_mlockall: ::c_long = 4000 + 156;\npub const SYS_munlockall: ::c_long = 4000 + 157;\npub const SYS_sched_setparam: ::c_long = 4000 + 158;\npub const SYS_sched_getparam: ::c_long = 4000 + 159;\npub const SYS_sched_setscheduler: ::c_long = 4000 + 160;\npub const SYS_sched_getscheduler: ::c_long = 4000 + 161;\npub const SYS_sched_yield: ::c_long = 4000 + 162;\npub const SYS_sched_get_priority_max: ::c_long = 4000 + 163;\npub const SYS_sched_get_priority_min: ::c_long = 4000 + 164;\npub const SYS_sched_rr_get_interval: ::c_long = 4000 + 165;\npub const SYS_nanosleep: ::c_long = 4000 + 166;\npub const SYS_mremap: ::c_long = 4000 + 167;\npub const SYS_accept: ::c_long = 4000 + 168;\npub const SYS_bind: ::c_long = 4000 + 169;\npub const SYS_connect: ::c_long = 4000 + 170;\npub const SYS_getpeername: ::c_long = 4000 + 171;\npub const SYS_getsockname: ::c_long = 4000 + 172;\npub const SYS_getsockopt: ::c_long = 4000 + 173;\npub const SYS_listen: ::c_long = 4000 + 174;\npub const SYS_recv: ::c_long = 4000 + 175;\npub const SYS_recvfrom: ::c_long = 4000 + 176;\npub const SYS_recvmsg: ::c_long = 4000 + 177;\npub const SYS_send: ::c_long = 4000 + 178;\npub const SYS_sendmsg: ::c_long = 4000 + 179;\npub const SYS_sendto: ::c_long = 4000 + 180;\npub const SYS_setsockopt: ::c_long = 4000 + 181;\npub const SYS_shutdown: ::c_long = 4000 + 182;\npub const SYS_socket: ::c_long = 4000 + 183;\npub const SYS_socketpair: ::c_long = 4000 + 184;\npub const SYS_setresuid: ::c_long = 4000 + 185;\npub const SYS_getresuid: ::c_long = 4000 + 186;\npub const SYS_query_module: ::c_long = 4000 + 187;\npub const SYS_poll: ::c_long = 4000 + 188;\npub const SYS_nfsservctl: ::c_long = 4000 + 189;\npub const SYS_setresgid: ::c_long = 4000 + 190;\npub const SYS_getresgid: ::c_long = 4000 + 191;\npub const SYS_prctl: ::c_long = 4000 + 192;\npub const SYS_rt_sigreturn: ::c_long = 4000 + 193;\npub const SYS_rt_sigaction: ::c_long = 4000 + 194;\npub const SYS_rt_sigprocmask: ::c_long = 4000 + 195;\npub const SYS_rt_sigpending: ::c_long = 4000 + 196;\npub const SYS_rt_sigtimedwait: ::c_long = 4000 + 197;\npub const SYS_rt_sigqueueinfo: ::c_long = 4000 + 198;\npub const SYS_rt_sigsuspend: ::c_long = 4000 + 199;\npub const SYS_pread64: ::c_long = 4000 + 200;\npub const SYS_pwrite64: ::c_long = 4000 + 201;\npub const SYS_chown: ::c_long = 4000 + 202;\npub const SYS_getcwd: ::c_long = 4000 + 203;\npub const SYS_capget: ::c_long = 4000 + 204;\npub const SYS_capset: ::c_long = 4000 + 205;\npub const SYS_sigaltstack: ::c_long = 4000 + 206;\npub const SYS_sendfile: ::c_long = 4000 + 207;\npub const SYS_getpmsg: ::c_long = 4000 + 208;\npub const SYS_putpmsg: ::c_long = 4000 + 209;\npub const SYS_mmap2: ::c_long = 4000 + 210;\npub const SYS_truncate64: ::c_long = 4000 + 211;\npub const SYS_ftruncate64: ::c_long = 4000 + 212;\npub const SYS_stat64: ::c_long = 4000 + 213;\npub const SYS_lstat64: ::c_long = 4000 + 214;\npub const SYS_fstat64: ::c_long = 4000 + 215;\npub const SYS_pivot_root: ::c_long = 4000 + 216;\npub const SYS_mincore: ::c_long = 4000 + 217;\npub const SYS_madvise: ::c_long = 4000 + 218;\npub const SYS_getdents64: ::c_long = 4000 + 219;\npub const SYS_fcntl64: ::c_long = 4000 + 220;\npub const SYS_gettid: ::c_long = 4000 + 222;\npub const SYS_readahead: ::c_long = 4000 + 223;\npub const SYS_setxattr: ::c_long = 4000 + 224;\npub const SYS_lsetxattr: ::c_long = 4000 + 225;\npub const SYS_fsetxattr: ::c_long = 4000 + 226;\npub const SYS_getxattr: ::c_long = 4000 + 227;\npub const SYS_lgetxattr: ::c_long = 4000 + 228;\npub const SYS_fgetxattr: ::c_long = 4000 + 229;\npub const SYS_listxattr: ::c_long = 4000 + 230;\npub const SYS_llistxattr: ::c_long = 4000 + 231;\npub const SYS_flistxattr: ::c_long = 4000 + 232;\npub const SYS_removexattr: ::c_long = 4000 + 233;\npub const SYS_lremovexattr: ::c_long = 4000 + 234;\npub const SYS_fremovexattr: ::c_long = 4000 + 235;\npub const SYS_tkill: ::c_long = 4000 + 236;\npub const SYS_sendfile64: ::c_long = 4000 + 237;\npub const SYS_futex: ::c_long = 4000 + 238;\npub const SYS_sched_setaffinity: ::c_long = 4000 + 239;\npub const SYS_sched_getaffinity: ::c_long = 4000 + 240;\npub const SYS_io_setup: ::c_long = 4000 + 241;\npub const SYS_io_destroy: ::c_long = 4000 + 242;\npub const SYS_io_getevents: ::c_long = 4000 + 243;\npub const SYS_io_submit: ::c_long = 4000 + 244;\npub const SYS_io_cancel: ::c_long = 4000 + 245;\npub const SYS_exit_group: ::c_long = 4000 + 246;\npub const SYS_lookup_dcookie: ::c_long = 4000 + 247;\npub const SYS_epoll_create: ::c_long = 4000 + 248;\npub const SYS_epoll_ctl: ::c_long = 4000 + 249;\npub const SYS_epoll_wait: ::c_long = 4000 + 250;\npub const SYS_remap_file_pages: ::c_long = 4000 + 251;\npub const SYS_set_tid_address: ::c_long = 4000 + 252;\npub const SYS_restart_syscall: ::c_long = 4000 + 253;\npub const SYS_fadvise64: ::c_long = 4000 + 254;\npub const SYS_statfs64: ::c_long = 4000 + 255;\npub const SYS_fstatfs64: ::c_long = 4000 + 256;\npub const SYS_timer_create: ::c_long = 4000 + 257;\npub const SYS_timer_settime: ::c_long = 4000 + 258;\npub const SYS_timer_gettime: ::c_long = 4000 + 259;\npub const SYS_timer_getoverrun: ::c_long = 4000 + 260;\npub const SYS_timer_delete: ::c_long = 4000 + 261;\npub const SYS_clock_settime: ::c_long = 4000 + 262;\npub const SYS_clock_gettime: ::c_long = 4000 + 263;\npub const SYS_clock_getres: ::c_long = 4000 + 264;\npub const SYS_clock_nanosleep: ::c_long = 4000 + 265;\npub const SYS_tgkill: ::c_long = 4000 + 266;\npub const SYS_utimes: ::c_long = 4000 + 267;\npub const SYS_mbind: ::c_long = 4000 + 268;\npub const SYS_get_mempolicy: ::c_long = 4000 + 269;\npub const SYS_set_mempolicy: ::c_long = 4000 + 270;\npub const SYS_mq_open: ::c_long = 4000 + 271;\npub const SYS_mq_unlink: ::c_long = 4000 + 272;\npub const SYS_mq_timedsend: ::c_long = 4000 + 273;\npub const SYS_mq_timedreceive: ::c_long = 4000 + 274;\npub const SYS_mq_notify: ::c_long = 4000 + 275;\npub const SYS_mq_getsetattr: ::c_long = 4000 + 276;\npub const SYS_vserver: ::c_long = 4000 + 277;\npub const SYS_waitid: ::c_long = 4000 + 278;\n/* pub const SYS_sys_setaltroot: ::c_long = 4000 + 279; */\npub const SYS_add_key: ::c_long = 4000 + 280;\npub const SYS_request_key: ::c_long = 4000 + 281;\npub const SYS_keyctl: ::c_long = 4000 + 282;\npub const SYS_set_thread_area: ::c_long = 4000 + 283;\npub const SYS_inotify_init: ::c_long = 4000 + 284;\npub const SYS_inotify_add_watch: ::c_long = 4000 + 285;\npub const SYS_inotify_rm_watch: ::c_long = 4000 + 286;\npub const SYS_migrate_pages: ::c_long = 4000 + 287;\npub const SYS_openat: ::c_long = 4000 + 288;\npub const SYS_mkdirat: ::c_long = 4000 + 289;\npub const SYS_mknodat: ::c_long = 4000 + 290;\npub const SYS_fchownat: ::c_long = 4000 + 291;\npub const SYS_futimesat: ::c_long = 4000 + 292;\npub const SYS_fstatat64: ::c_long = 4000 + 293;\npub const SYS_unlinkat: ::c_long = 4000 + 294;\npub const SYS_renameat: ::c_long = 4000 + 295;\npub const SYS_linkat: ::c_long = 4000 + 296;\npub const SYS_symlinkat: ::c_long = 4000 + 297;\npub const SYS_readlinkat: ::c_long = 4000 + 298;\npub const SYS_fchmodat: ::c_long = 4000 + 299;\npub const SYS_faccessat: ::c_long = 4000 + 300;\npub const SYS_pselect6: ::c_long = 4000 + 301;\npub const SYS_ppoll: ::c_long = 4000 + 302;\npub const SYS_unshare: ::c_long = 4000 + 303;\npub const SYS_splice: ::c_long = 4000 + 304;\npub const SYS_sync_file_range: ::c_long = 4000 + 305;\npub const SYS_tee: ::c_long = 4000 + 306;\npub const SYS_vmsplice: ::c_long = 4000 + 307;\npub const SYS_move_pages: ::c_long = 4000 + 308;\npub const SYS_set_robust_list: ::c_long = 4000 + 309;\npub const SYS_get_robust_list: ::c_long = 4000 + 310;\npub const SYS_kexec_load: ::c_long = 4000 + 311;\npub const SYS_getcpu: ::c_long = 4000 + 312;\npub const SYS_epoll_pwait: ::c_long = 4000 + 313;\npub const SYS_ioprio_set: ::c_long = 4000 + 314;\npub const SYS_ioprio_get: ::c_long = 4000 + 315;\npub const SYS_utimensat: ::c_long = 4000 + 316;\npub const SYS_signalfd: ::c_long = 4000 + 317;\npub const SYS_timerfd: ::c_long = 4000 + 318;\npub const SYS_eventfd: ::c_long = 4000 + 319;\npub const SYS_fallocate: ::c_long = 4000 + 320;\npub const SYS_timerfd_create: ::c_long = 4000 + 321;\npub const SYS_timerfd_gettime: ::c_long = 4000 + 322;\npub const SYS_timerfd_settime: ::c_long = 4000 + 323;\npub const SYS_signalfd4: ::c_long = 4000 + 324;\npub const SYS_eventfd2: ::c_long = 4000 + 325;\npub const SYS_epoll_create1: ::c_long = 4000 + 326;\npub const SYS_dup3: ::c_long = 4000 + 327;\npub const SYS_pipe2: ::c_long = 4000 + 328;\npub const SYS_inotify_init1: ::c_long = 4000 + 329;\npub const SYS_preadv: ::c_long = 4000 + 330;\npub const SYS_pwritev: ::c_long = 4000 + 331;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 4000 + 332;\npub const SYS_perf_event_open: ::c_long = 4000 + 333;\npub const SYS_accept4: ::c_long = 4000 + 334;\npub const SYS_recvmmsg: ::c_long = 4000 + 335;\npub const SYS_fanotify_init: ::c_long = 4000 + 336;\npub const SYS_fanotify_mark: ::c_long = 4000 + 337;\npub const SYS_prlimit64: ::c_long = 4000 + 338;\npub const SYS_name_to_handle_at: ::c_long = 4000 + 339;\npub const SYS_open_by_handle_at: ::c_long = 4000 + 340;\npub const SYS_clock_adjtime: ::c_long = 4000 + 341;\npub const SYS_syncfs: ::c_long = 4000 + 342;\npub const SYS_sendmmsg: ::c_long = 4000 + 343;\npub const SYS_setns: ::c_long = 4000 + 344;\npub const SYS_process_vm_readv: ::c_long = 4000 + 345;\npub const SYS_process_vm_writev: ::c_long = 4000 + 346;\npub const SYS_kcmp: ::c_long = 4000 + 347;\npub const SYS_finit_module: ::c_long = 4000 + 348;\npub const SYS_sched_setattr: ::c_long = 4000 + 349;\npub const SYS_sched_getattr: ::c_long = 4000 + 350;\npub const SYS_renameat2: ::c_long = 4000 + 351;\npub const SYS_seccomp: ::c_long = 4000 + 352;\npub const SYS_getrandom: ::c_long = 4000 + 353;\npub const SYS_memfd_create: ::c_long = 4000 + 354;\npub const SYS_bpf: ::c_long = 4000 + 355;\npub const SYS_execveat: ::c_long = 4000 + 356;\npub const SYS_userfaultfd: ::c_long = 4000 + 357;\npub const SYS_membarrier: ::c_long = 4000 + 358;\npub const SYS_mlock2: ::c_long = 4000 + 359;\npub const SYS_copy_file_range: ::c_long = 4000 + 360;\npub const SYS_preadv2: ::c_long = 4000 + 361;\npub const SYS_pwritev2: ::c_long = 4000 + 362;\npub const SYS_pkey_mprotect: ::c_long = 4000 + 363;\npub const SYS_pkey_alloc: ::c_long = 4000 + 364;\npub const SYS_pkey_free: ::c_long = 4000 + 365;\npub const SYS_statx: ::c_long = 4000 + 366;\npub const SYS_pidfd_send_signal: ::c_long = 4000 + 424;\npub const SYS_io_uring_setup: ::c_long = 4000 + 425;\npub const SYS_io_uring_enter: ::c_long = 4000 + 426;\npub const SYS_io_uring_register: ::c_long = 4000 + 427;\npub const SYS_open_tree: ::c_long = 4000 + 428;\npub const SYS_move_mount: ::c_long = 4000 + 429;\npub const SYS_fsopen: ::c_long = 4000 + 430;\npub const SYS_fsconfig: ::c_long = 4000 + 431;\npub const SYS_fsmount: ::c_long = 4000 + 432;\npub const SYS_fspick: ::c_long = 4000 + 433;\npub const SYS_pidfd_open: ::c_long = 4000 + 434;\npub const SYS_clone3: ::c_long = 4000 + 435;\npub const SYS_close_range: ::c_long = 4000 + 436;\npub const SYS_openat2: ::c_long = 4000 + 437;\npub const SYS_pidfd_getfd: ::c_long = 4000 + 438;\npub const SYS_faccessat2: ::c_long = 4000 + 439;\npub const SYS_process_madvise: ::c_long = 4000 + 440;\npub const SYS_epoll_pwait2: ::c_long = 4000 + 441;\npub const SYS_mount_setattr: ::c_long = 4000 + 442;\n\npub const O_DIRECT: ::c_int = 0x8000;\npub const O_DIRECTORY: ::c_int = 0x10000;\npub const O_NOFOLLOW: ::c_int = 0x20000;\n\npub const RLIM_INFINITY: ::rlim_t = 0x7fffffff;\npub const RLIMIT_NOFILE: ::__rlimit_resource_t = 5;\npub const RLIMIT_AS: ::__rlimit_resource_t = 6;\npub const RLIMIT_RSS: ::__rlimit_resource_t = 7;\npub const RLIMIT_NPROC: ::__rlimit_resource_t = 8;\npub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 9;\n\npub const O_APPEND: ::c_int = 8;\npub const O_CREAT: ::c_int = 256;\npub const O_EXCL: ::c_int = 1024;\npub const O_NOCTTY: ::c_int = 2048;\npub const O_NONBLOCK: ::c_int = 128;\npub const O_SYNC: ::c_int = 0x4010;\npub const O_RSYNC: ::c_int = 0x4010;\npub const O_DSYNC: ::c_int = 0x10;\npub const O_FSYNC: ::c_int = 0x4010;\npub const O_ASYNC: ::c_int = 0x1000;\npub const O_NDELAY: ::c_int = 0x80;\n\npub const EDEADLK: ::c_int = 45;\npub const ENAMETOOLONG: ::c_int = 78;\npub const ENOLCK: ::c_int = 46;\npub const ENOSYS: ::c_int = 89;\npub const ENOTEMPTY: ::c_int = 93;\npub const ELOOP: ::c_int = 90;\npub const ENOMSG: ::c_int = 35;\npub const EIDRM: ::c_int = 36;\npub const ECHRNG: ::c_int = 37;\npub const EL2NSYNC: ::c_int = 38;\npub const EL3HLT: ::c_int = 39;\npub const EL3RST: ::c_int = 40;\npub const ELNRNG: ::c_int = 41;\npub const EUNATCH: ::c_int = 42;\npub const ENOCSI: ::c_int = 43;\npub const EL2HLT: ::c_int = 44;\npub const EBADE: ::c_int = 50;\npub const EBADR: ::c_int = 51;\npub const EXFULL: ::c_int = 52;\npub const ENOANO: ::c_int = 53;\npub const EBADRQC: ::c_int = 54;\npub const EBADSLT: ::c_int = 55;\npub const EDEADLOCK: ::c_int = 56;\npub const EMULTIHOP: ::c_int = 74;\npub const EOVERFLOW: ::c_int = 79;\npub const ENOTUNIQ: ::c_int = 80;\npub const EBADFD: ::c_int = 81;\npub const EBADMSG: ::c_int = 77;\npub const EREMCHG: ::c_int = 82;\npub const ELIBACC: ::c_int = 83;\npub const ELIBBAD: ::c_int = 84;\npub const ELIBSCN: ::c_int = 85;\npub const ELIBMAX: ::c_int = 86;\npub const ELIBEXEC: ::c_int = 87;\npub const EILSEQ: ::c_int = 88;\npub const ERESTART: ::c_int = 91;\npub const ESTRPIPE: ::c_int = 92;\npub const EUSERS: ::c_int = 94;\npub const ENOTSOCK: ::c_int = 95;\npub const EDESTADDRREQ: ::c_int = 96;\npub const EMSGSIZE: ::c_int = 97;\npub const EPROTOTYPE: ::c_int = 98;\npub const ENOPROTOOPT: ::c_int = 99;\npub const EPROTONOSUPPORT: ::c_int = 120;\npub const ESOCKTNOSUPPORT: ::c_int = 121;\npub const EOPNOTSUPP: ::c_int = 122;\npub const EPFNOSUPPORT: ::c_int = 123;\npub const EAFNOSUPPORT: ::c_int = 124;\npub const EADDRINUSE: ::c_int = 125;\npub const EADDRNOTAVAIL: ::c_int = 126;\npub const ENETDOWN: ::c_int = 127;\npub const ENETUNREACH: ::c_int = 128;\npub const ENETRESET: ::c_int = 129;\npub const ECONNABORTED: ::c_int = 130;\npub const ECONNRESET: ::c_int = 131;\npub const ENOBUFS: ::c_int = 132;\npub const EISCONN: ::c_int = 133;\npub const ENOTCONN: ::c_int = 134;\npub const ESHUTDOWN: ::c_int = 143;\npub const ETOOMANYREFS: ::c_int = 144;\npub const ETIMEDOUT: ::c_int = 145;\npub const ECONNREFUSED: ::c_int = 146;\npub const EHOSTDOWN: ::c_int = 147;\npub const EHOSTUNREACH: ::c_int = 148;\npub const EALREADY: ::c_int = 149;\npub const EINPROGRESS: ::c_int = 150;\npub const ESTALE: ::c_int = 151;\npub const EUCLEAN: ::c_int = 135;\npub const ENOTNAM: ::c_int = 137;\npub const ENAVAIL: ::c_int = 138;\npub const EISNAM: ::c_int = 139;\npub const EREMOTEIO: ::c_int = 140;\npub const EDQUOT: ::c_int = 1133;\npub const ENOMEDIUM: ::c_int = 159;\npub const EMEDIUMTYPE: ::c_int = 160;\npub const ECANCELED: ::c_int = 158;\npub const ENOKEY: ::c_int = 161;\npub const EKEYEXPIRED: ::c_int = 162;\npub const EKEYREVOKED: ::c_int = 163;\npub const EKEYREJECTED: ::c_int = 164;\npub const EOWNERDEAD: ::c_int = 165;\npub const ENOTRECOVERABLE: ::c_int = 166;\npub const ERFKILL: ::c_int = 167;\n\npub const MAP_NORESERVE: ::c_int = 0x400;\npub const MAP_ANON: ::c_int = 0x800;\npub const MAP_ANONYMOUS: ::c_int = 0x800;\npub const MAP_GROWSDOWN: ::c_int = 0x1000;\npub const MAP_DENYWRITE: ::c_int = 0x2000;\npub const MAP_EXECUTABLE: ::c_int = 0x4000;\npub const MAP_LOCKED: ::c_int = 0x8000;\npub const MAP_POPULATE: ::c_int = 0x10000;\npub const MAP_NONBLOCK: ::c_int = 0x20000;\npub const MAP_STACK: ::c_int = 0x40000;\n\npub const SOCK_STREAM: ::c_int = 2;\npub const SOCK_DGRAM: ::c_int = 1;\n\npub const FIOCLEX: ::c_ulong = 0x6601;\npub const FIONCLEX: ::c_ulong = 0x6602;\npub const FIONBIO: ::c_ulong = 0x667e;\n\npub const SA_SIGINFO: ::c_int = 0x00000008;\npub const SA_NOCLDWAIT: ::c_int = 0x00010000;\n\npub const SIGCHLD: ::c_int = 18;\npub const SIGBUS: ::c_int = 10;\npub const SIGTTIN: ::c_int = 26;\npub const SIGTTOU: ::c_int = 27;\npub const SIGXCPU: ::c_int = 30;\npub const SIGXFSZ: ::c_int = 31;\npub const SIGVTALRM: ::c_int = 28;\npub const SIGPROF: ::c_int = 29;\npub const SIGWINCH: ::c_int = 20;\npub const SIGUSR1: ::c_int = 16;\npub const SIGUSR2: ::c_int = 17;\npub const SIGCONT: ::c_int = 25;\npub const SIGSTOP: ::c_int = 23;\npub const SIGTSTP: ::c_int = 24;\npub const SIGURG: ::c_int = 21;\npub const SIGIO: ::c_int = 22;\npub const SIGSYS: ::c_int = 12;\npub const SIGPOLL: ::c_int = 22;\npub const SIGPWR: ::c_int = 19;\npub const SIG_SETMASK: ::c_int = 3;\npub const SIG_BLOCK: ::c_int = 0x1;\npub const SIG_UNBLOCK: ::c_int = 0x2;\n\npub const POLLWRNORM: ::c_short = 0x004;\npub const POLLWRBAND: ::c_short = 0x100;\n\npub const VEOF: usize = 16;\npub const VEOL: usize = 17;\npub const VEOL2: usize = 6;\npub const VMIN: usize = 4;\npub const IEXTEN: ::tcflag_t = 0x00000100;\npub const TOSTOP: ::tcflag_t = 0x00008000;\npub const FLUSHO: ::tcflag_t = 0x00002000;\npub const EXTPROC: ::tcflag_t = 0o200000;\npub const TCSANOW: ::c_int = 0x540e;\npub const TCSADRAIN: ::c_int = 0x540f;\npub const TCSAFLUSH: ::c_int = 0x5410;\n\npub const PTRACE_GETFPXREGS: ::c_uint = 18;\npub const PTRACE_SETFPXREGS: ::c_uint = 19;\n\npub const MAP_HUGETLB: ::c_int = 0x080000;\n\npub const EFD_NONBLOCK: ::c_int = 0x80;\n\npub const F_GETLK: ::c_int = 14;\npub const F_GETOWN: ::c_int = 23;\npub const F_SETOWN: ::c_int = 24;\n\npub const SFD_NONBLOCK: ::c_int = 0x80;\n\npub const TCGETS: ::c_ulong = 0x540d;\npub const TCSETS: ::c_ulong = 0x540e;\npub const TCSETSW: ::c_ulong = 0x540f;\npub const TCSETSF: ::c_ulong = 0x5410;\npub const TCGETA: ::c_ulong = 0x5401;\npub const TCSETA: ::c_ulong = 0x5402;\npub const TCSETAW: ::c_ulong = 0x5403;\npub const TCSETAF: ::c_ulong = 0x5404;\npub const TCSBRK: ::c_ulong = 0x5405;\npub const TCXONC: ::c_ulong = 0x5406;\npub const TCFLSH: ::c_ulong = 0x5407;\npub const TIOCGSOFTCAR: ::c_ulong = 0x5481;\npub const TIOCSSOFTCAR: ::c_ulong = 0x5482;\npub const TIOCINQ: ::c_ulong = 0x467f;\npub const TIOCLINUX: ::c_ulong = 0x5483;\npub const TIOCGSERIAL: ::c_ulong = 0x5484;\npub const TIOCEXCL: ::c_ulong = 0x740d;\npub const TIOCNXCL: ::c_ulong = 0x740e;\npub const TIOCSCTTY: ::c_ulong = 0x5480;\npub const TIOCGPGRP: ::c_ulong = 0x40047477;\npub const TIOCSPGRP: ::c_ulong = 0x80047476;\npub const TIOCOUTQ: ::c_ulong = 0x7472;\npub const TIOCSTI: ::c_ulong = 0x5472;\npub const TIOCGWINSZ: ::c_ulong = 0x40087468;\npub const TIOCSWINSZ: ::c_ulong = 0x80087467;\npub const TIOCMGET: ::c_ulong = 0x741d;\npub const TIOCMBIS: ::c_ulong = 0x741b;\npub const TIOCMBIC: ::c_ulong = 0x741c;\npub const TIOCMSET: ::c_ulong = 0x741a;\npub const FIONREAD: ::c_ulong = 0x467f;\npub const TIOCCONS: ::c_ulong = 0x80047478;\n\npub const RTLD_DEEPBIND: ::c_int = 0x10;\npub const RTLD_GLOBAL: ::c_int = 0x4;\npub const RTLD_NOLOAD: ::c_int = 0x8;\n\npub const MCL_CURRENT: ::c_int = 0x0001;\npub const MCL_FUTURE: ::c_int = 0x0002;\n\npub const SIGSTKSZ: ::size_t = 8192;\npub const MINSIGSTKSZ: ::size_t = 2048;\npub const CBAUD: ::tcflag_t = 0o0010017;\npub const TAB1: ::tcflag_t = 0x00000800;\npub const TAB2: ::tcflag_t = 0x00001000;\npub const TAB3: ::tcflag_t = 0x00001800;\npub const CR1: ::tcflag_t = 0x00000200;\npub const CR2: ::tcflag_t = 0x00000400;\npub const CR3: ::tcflag_t = 0x00000600;\npub const FF1: ::tcflag_t = 0x00008000;\npub const BS1: ::tcflag_t = 0x00002000;\npub const VT1: ::tcflag_t = 0x00004000;\npub const VWERASE: usize = 14;\npub const VREPRINT: usize = 12;\npub const VSUSP: usize = 10;\npub const VSTART: usize = 8;\npub const VSTOP: usize = 9;\npub const VDISCARD: usize = 13;\npub const VTIME: usize = 5;\npub const IXON: ::tcflag_t = 0x00000400;\npub const IXOFF: ::tcflag_t = 0x00001000;\npub const ONLCR: ::tcflag_t = 0x4;\npub const CSIZE: ::tcflag_t = 0x00000030;\npub const CS6: ::tcflag_t = 0x00000010;\npub const CS7: ::tcflag_t = 0x00000020;\npub const CS8: ::tcflag_t = 0x00000030;\npub const CSTOPB: ::tcflag_t = 0x00000040;\npub const CREAD: ::tcflag_t = 0x00000080;\npub const PARENB: ::tcflag_t = 0x00000100;\npub const PARODD: ::tcflag_t = 0x00000200;\npub const HUPCL: ::tcflag_t = 0x00000400;\npub const CLOCAL: ::tcflag_t = 0x00000800;\npub const ECHOKE: ::tcflag_t = 0x00000800;\npub const ECHOE: ::tcflag_t = 0x00000010;\npub const ECHOK: ::tcflag_t = 0x00000020;\npub const ECHONL: ::tcflag_t = 0x00000040;\npub const ECHOPRT: ::tcflag_t = 0x00000400;\npub const ECHOCTL: ::tcflag_t = 0x00000200;\npub const ISIG: ::tcflag_t = 0x00000001;\npub const ICANON: ::tcflag_t = 0x00000002;\npub const PENDIN: ::tcflag_t = 0x00004000;\npub const NOFLSH: ::tcflag_t = 0x00000080;\npub const CIBAUD: ::tcflag_t = 0o02003600000;\npub const CBAUDEX: ::tcflag_t = 0o010000;\npub const VSWTC: usize = 7;\npub const OLCUC: ::tcflag_t = 0o000002;\npub const NLDLY: ::tcflag_t = 0o000400;\npub const CRDLY: ::tcflag_t = 0o003000;\npub const TABDLY: ::tcflag_t = 0o014000;\npub const BSDLY: ::tcflag_t = 0o020000;\npub const FFDLY: ::tcflag_t = 0o100000;\npub const VTDLY: ::tcflag_t = 0o040000;\npub const XTABS: ::tcflag_t = 0o014000;\n\npub const B0: ::speed_t = 0o000000;\npub const B50: ::speed_t = 0o000001;\npub const B75: ::speed_t = 0o000002;\npub const B110: ::speed_t = 0o000003;\npub const B134: ::speed_t = 0o000004;\npub const B150: ::speed_t = 0o000005;\npub const B200: ::speed_t = 0o000006;\npub const B300: ::speed_t = 0o000007;\npub const B600: ::speed_t = 0o000010;\npub const B1200: ::speed_t = 0o000011;\npub const B1800: ::speed_t = 0o000012;\npub const B2400: ::speed_t = 0o000013;\npub const B4800: ::speed_t = 0o000014;\npub const B9600: ::speed_t = 0o000015;\npub const B19200: ::speed_t = 0o000016;\npub const B38400: ::speed_t = 0o000017;\npub const EXTA: ::speed_t = B19200;\npub const EXTB: ::speed_t = B38400;\npub const BOTHER: ::speed_t = 0o010000;\npub const B57600: ::speed_t = 0o010001;\npub const B115200: ::speed_t = 0o010002;\npub const B230400: ::speed_t = 0o010003;\npub const B460800: ::speed_t = 0o010004;\npub const B500000: ::speed_t = 0o010005;\npub const B576000: ::speed_t = 0o010006;\npub const B921600: ::speed_t = 0o010007;\npub const B1000000: ::speed_t = 0o010010;\npub const B1152000: ::speed_t = 0o010011;\npub const B1500000: ::speed_t = 0o010012;\npub const B2000000: ::speed_t = 0o010013;\npub const B2500000: ::speed_t = 0o010014;\npub const B3000000: ::speed_t = 0o010015;\npub const B3500000: ::speed_t = 0o010016;\npub const B4000000: ::speed_t = 0o010017;\n\npub const TIOCM_ST: ::c_int = 0x010;\npub const TIOCM_SR: ::c_int = 0x020;\npub const TIOCM_CTS: ::c_int = 0x040;\npub const TIOCM_CAR: ::c_int = 0x100;\npub const TIOCM_RNG: ::c_int = 0x200;\npub const TIOCM_DSR: ::c_int = 0x400;\n\npub const EHWPOISON: ::c_int = 168;\n\ncfg_if! {\n    if #[cfg(libc_align)] {\n        mod align;\n        pub use self::align::*;\n    }\n}\n"],["1192","s_no_extra_traits! {\n    #[allow(missing_debug_implementations)]\n    #[repr(align(8))]\n    pub struct max_align_t {\n        priv_: [f32; 4]\n    }\n}\n"],["1193","//! RISC-V-specific definitions for 32-bit linux-like values\n\npub type c_char = u8;\npub type wchar_t = ::c_int;\n\ns! {\n    pub struct pthread_attr_t {\n        __size: [::c_ulong; 7],\n    }\n\n    pub struct msqid_ds {\n        pub msg_perm: ::ipc_perm,\n        pub msg_stime: ::time_t,\n        pub msg_rtime: ::time_t,\n        pub msg_ctime: ::time_t,\n        __msg_cbytes: ::c_ulong,\n        pub msg_qnum: ::msgqnum_t,\n        pub msg_qbytes: ::msglen_t,\n        pub msg_lspid: ::pid_t,\n        pub msg_lrpid: ::pid_t,\n        __glibc_reserved4: ::c_ulong,\n        __glibc_reserved5: ::c_ulong,\n    }\n\n    pub struct stat {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        pub __pad1: ::dev_t,\n        pub st_size: ::off_t,\n        pub st_blksize: ::blksize_t,\n        pub __pad2: ::c_int,\n        pub st_blocks: ::blkcnt_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __unused: [::c_int; 2usize],\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino64_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        pub __pad1: ::dev_t,\n        pub st_size: ::off64_t,\n        pub st_blksize: ::blksize_t,\n        pub __pad2: ::c_int,\n        pub st_blocks: ::blkcnt64_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __unused: [::c_int; 2],\n    }\n\n    pub struct statfs {\n        pub f_type: ::c_long,\n        pub f_bsize: ::c_long,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_long,\n        pub f_frsize: ::c_long,\n        pub f_flags: ::c_long,\n        pub f_spare: [::c_long; 4],\n    }\n\n    pub struct statfs64 {\n        pub f_type: ::c_long,\n        pub f_bsize: ::c_long,\n        pub f_blocks: ::fsblkcnt64_t,\n        pub f_bfree: ::fsblkcnt64_t,\n        pub f_bavail: ::fsblkcnt64_t,\n        pub f_files: ::fsfilcnt64_t,\n        pub f_ffree: ::fsfilcnt64_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_long,\n        pub f_frsize: ::c_long,\n        pub f_flags: ::c_long,\n        pub f_spare: [::c_long; 4],\n    }\n\n    pub struct statvfs {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_favail: ::fsfilcnt_t,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        pub __f_spare: [::c_int; 6],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt64_t,\n        pub f_bfree: ::fsblkcnt64_t,\n        pub f_bavail: ::fsblkcnt64_t,\n        pub f_files: ::fsfilcnt64_t,\n        pub f_ffree: ::fsfilcnt64_t,\n        pub f_favail: ::fsfilcnt64_t,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        pub __f_spare: [::c_int; 6],\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_errno: ::c_int,\n        pub si_code: ::c_int,\n        #[doc(hidden)]\n        #[deprecated(\n            since=\"0.2.54\",\n            note=\"Please leave a comment on \\\n                  https://github.com/rust-lang/libc/pull/1316 if you're using \\\n                  this field\"\n        )]\n        pub _pad: [::c_int; 29],\n        _align: [u64; 0],\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_flags: ::c_int,\n        pub ss_size: ::size_t,\n    }\n\n    pub struct sigaction {\n        pub sa_sigaction: ::sighandler_t,\n        pub sa_mask: ::sigset_t,\n        pub sa_flags: ::c_int,\n        pub sa_restorer: ::Option<unsafe extern \"C\" fn()>,\n    }\n\n    pub struct ipc_perm {\n        pub __key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::c_ushort,\n        __pad1: ::c_ushort,\n        pub __seq: ::c_ushort,\n        __pad2: ::c_ushort,\n        __unused1: ::c_ulong,\n        __unused2: ::c_ulong,\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        pub shm_segsz: ::size_t,\n        pub shm_atime: ::time_t,\n        pub shm_dtime: ::time_t,\n        pub shm_ctime: ::time_t,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::shmatt_t,\n        __unused5: ::c_ulong,\n        __unused6: ::c_ulong,\n    }\n\n    pub struct flock {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off_t,\n        pub l_len: ::off_t,\n        pub l_pid: ::pid_t,\n    }\n\n    pub struct flock64 {\n        pub l_type: ::c_short,\n        pub l_whence: ::c_short,\n        pub l_start: ::off64_t,\n        pub l_len: ::off64_t,\n        pub l_pid: ::pid_t,\n    }\n}\n\npub const RLIM_INFINITY: ::rlim_t = !0;\npub const VEOF: usize = 4;\npub const RTLD_DEEPBIND: ::c_int = 0x8;\npub const RTLD_GLOBAL: ::c_int = 0x100;\npub const RTLD_NOLOAD: ::c_int = 0x4;\npub const TIOCGSOFTCAR: ::c_ulong = 21529;\npub const TIOCSSOFTCAR: ::c_ulong = 21530;\npub const TIOCGRS485: ::c_int = 21550;\npub const TIOCSRS485: ::c_int = 21551;\npub const RLIMIT_RSS: ::__rlimit_resource_t = 5;\npub const RLIMIT_AS: ::__rlimit_resource_t = 9;\npub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 8;\npub const RLIMIT_NOFILE: ::__rlimit_resource_t = 7;\npub const RLIMIT_NPROC: ::__rlimit_resource_t = 6;\npub const O_APPEND: ::c_int = 1024;\npub const O_CREAT: ::c_int = 64;\npub const O_EXCL: ::c_int = 128;\npub const O_NOCTTY: ::c_int = 256;\npub const O_NONBLOCK: ::c_int = 2048;\npub const O_SYNC: ::c_int = 1052672;\npub const O_RSYNC: ::c_int = 1052672;\npub const O_DSYNC: ::c_int = 4096;\npub const O_FSYNC: ::c_int = 1052672;\npub const MAP_GROWSDOWN: ::c_int = 256;\npub const EDEADLK: ::c_int = 35;\npub const ENAMETOOLONG: ::c_int = 36;\npub const ENOLCK: ::c_int = 37;\npub const ENOSYS: ::c_int = 38;\npub const ENOTEMPTY: ::c_int = 39;\npub const ELOOP: ::c_int = 40;\npub const ENOMSG: ::c_int = 42;\npub const EIDRM: ::c_int = 43;\npub const ECHRNG: ::c_int = 44;\npub const EL2NSYNC: ::c_int = 45;\npub const EL3HLT: ::c_int = 46;\npub const EL3RST: ::c_int = 47;\npub const ELNRNG: ::c_int = 48;\npub const EUNATCH: ::c_int = 49;\npub const ENOCSI: ::c_int = 50;\npub const EL2HLT: ::c_int = 51;\npub const EBADE: ::c_int = 52;\npub const EBADR: ::c_int = 53;\npub const EXFULL: ::c_int = 54;\npub const ENOANO: ::c_int = 55;\npub const EBADRQC: ::c_int = 56;\npub const EBADSLT: ::c_int = 57;\npub const EMULTIHOP: ::c_int = 72;\npub const EOVERFLOW: ::c_int = 75;\npub const ENOTUNIQ: ::c_int = 76;\npub const EBADFD: ::c_int = 77;\npub const EBADMSG: ::c_int = 74;\npub const EREMCHG: ::c_int = 78;\npub const ELIBACC: ::c_int = 79;\npub const ELIBBAD: ::c_int = 80;\npub const ELIBSCN: ::c_int = 81;\npub const ELIBMAX: ::c_int = 82;\npub const ELIBEXEC: ::c_int = 83;\npub const EILSEQ: ::c_int = 84;\npub const ERESTART: ::c_int = 85;\npub const ESTRPIPE: ::c_int = 86;\npub const EUSERS: ::c_int = 87;\npub const ENOTSOCK: ::c_int = 88;\npub const EDESTADDRREQ: ::c_int = 89;\npub const EMSGSIZE: ::c_int = 90;\npub const EPROTOTYPE: ::c_int = 91;\npub const ENOPROTOOPT: ::c_int = 92;\npub const EPROTONOSUPPORT: ::c_int = 93;\npub const ESOCKTNOSUPPORT: ::c_int = 94;\npub const EOPNOTSUPP: ::c_int = 95;\npub const EPFNOSUPPORT: ::c_int = 96;\npub const EAFNOSUPPORT: ::c_int = 97;\npub const EADDRINUSE: ::c_int = 98;\npub const EADDRNOTAVAIL: ::c_int = 99;\npub const ENETDOWN: ::c_int = 100;\npub const ENETUNREACH: ::c_int = 101;\npub const ENETRESET: ::c_int = 102;\npub const ECONNABORTED: ::c_int = 103;\npub const ECONNRESET: ::c_int = 104;\npub const ENOBUFS: ::c_int = 105;\npub const EISCONN: ::c_int = 106;\npub const ENOTCONN: ::c_int = 107;\npub const ESHUTDOWN: ::c_int = 108;\npub const ETOOMANYREFS: ::c_int = 109;\npub const ETIMEDOUT: ::c_int = 110;\npub const ECONNREFUSED: ::c_int = 111;\npub const EHOSTDOWN: ::c_int = 112;\npub const EHOSTUNREACH: ::c_int = 113;\npub const EALREADY: ::c_int = 114;\npub const EINPROGRESS: ::c_int = 115;\npub const ESTALE: ::c_int = 116;\npub const EDQUOT: ::c_int = 122;\npub const ENOMEDIUM: ::c_int = 123;\npub const EMEDIUMTYPE: ::c_int = 124;\npub const ECANCELED: ::c_int = 125;\npub const ENOKEY: ::c_int = 126;\npub const EKEYEXPIRED: ::c_int = 127;\npub const EKEYREVOKED: ::c_int = 128;\npub const EKEYREJECTED: ::c_int = 129;\npub const EOWNERDEAD: ::c_int = 130;\npub const ENOTRECOVERABLE: ::c_int = 131;\npub const EHWPOISON: ::c_int = 133;\npub const ERFKILL: ::c_int = 132;\n\npub const SOCK_STREAM: ::c_int = 1;\npub const SOCK_DGRAM: ::c_int = 2;\npub const SA_SIGINFO: ::c_int = 4;\npub const SA_NOCLDWAIT: ::c_int = 2;\npub const SIGTTIN: ::c_int = 21;\npub const SIGTTOU: ::c_int = 22;\npub const SIGXCPU: ::c_int = 24;\npub const SIGXFSZ: ::c_int = 25;\npub const SIGVTALRM: ::c_int = 26;\npub const SIGPROF: ::c_int = 27;\npub const SIGWINCH: ::c_int = 28;\npub const SIGCHLD: ::c_int = 17;\npub const SIGBUS: ::c_int = 7;\npub const SIGUSR1: ::c_int = 10;\npub const SIGUSR2: ::c_int = 12;\npub const SIGCONT: ::c_int = 18;\npub const SIGSTOP: ::c_int = 19;\npub const SIGTSTP: ::c_int = 20;\npub const SIGURG: ::c_int = 23;\npub const SIGIO: ::c_int = 29;\npub const SIGSYS: ::c_int = 31;\npub const SIGSTKFLT: ::c_int = 16;\npub const SIGPOLL: ::c_int = 29;\npub const SIGPWR: ::c_int = 30;\npub const SIG_SETMASK: ::c_int = 2;\npub const SIG_BLOCK: ::c_int = 0;\npub const SIG_UNBLOCK: ::c_int = 1;\npub const POLLWRNORM: ::c_short = 256;\npub const POLLWRBAND: ::c_short = 512;\npub const O_ASYNC: ::c_int = 8192;\npub const O_NDELAY: ::c_int = 2048;\npub const EFD_NONBLOCK: ::c_int = 2048;\npub const F_GETLK: ::c_int = 5;\npub const F_GETOWN: ::c_int = 9;\npub const F_SETOWN: ::c_int = 8;\npub const SFD_NONBLOCK: ::c_int = 2048;\npub const TCSANOW: ::c_int = 0;\npub const TCSADRAIN: ::c_int = 1;\npub const TCSAFLUSH: ::c_int = 2;\npub const TIOCLINUX: ::c_ulong = 21532;\npub const TIOCGSERIAL: ::c_ulong = 21534;\npub const TIOCEXCL: ::c_ulong = 21516;\npub const TIOCNXCL: ::c_ulong = 21517;\npub const TIOCSCTTY: ::c_ulong = 21518;\npub const TIOCSTI: ::c_ulong = 21522;\npub const TIOCMGET: ::c_ulong = 21525;\npub const TIOCMBIS: ::c_ulong = 21526;\npub const TIOCMBIC: ::c_ulong = 21527;\npub const TIOCMSET: ::c_ulong = 21528;\npub const TIOCCONS: ::c_ulong = 21533;\npub const TIOCM_ST: ::c_int = 8;\npub const TIOCM_SR: ::c_int = 16;\npub const TIOCM_CTS: ::c_int = 32;\npub const TIOCM_CAR: ::c_int = 64;\npub const TIOCM_RNG: ::c_int = 128;\npub const TIOCM_DSR: ::c_int = 256;\n\npub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;\npub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;\npub const O_DIRECT: ::c_int = 16384;\npub const O_DIRECTORY: ::c_int = 65536;\npub const O_NOFOLLOW: ::c_int = 131072;\npub const MAP_HUGETLB: ::c_int = 262144;\npub const MAP_LOCKED: ::c_int = 8192;\npub const MAP_NORESERVE: ::c_int = 16384;\npub const MAP_ANON: ::c_int = 32;\npub const MAP_ANONYMOUS: ::c_int = 32;\npub const MAP_DENYWRITE: ::c_int = 2048;\npub const MAP_EXECUTABLE: ::c_int = 4096;\npub const MAP_POPULATE: ::c_int = 32768;\npub const MAP_NONBLOCK: ::c_int = 65536;\npub const MAP_STACK: ::c_int = 131072;\npub const MAP_SYNC: ::c_int = 0x080000;\npub const EDEADLOCK: ::c_int = 35;\npub const EUCLEAN: ::c_int = 117;\npub const ENOTNAM: ::c_int = 118;\npub const ENAVAIL: ::c_int = 119;\npub const EISNAM: ::c_int = 120;\npub const EREMOTEIO: ::c_int = 121;\npub const FIOCLEX: ::c_ulong = 21585;\npub const FIONCLEX: ::c_ulong = 21584;\npub const FIONBIO: ::c_ulong = 21537;\npub const MCL_CURRENT: ::c_int = 1;\npub const MCL_FUTURE: ::c_int = 2;\npub const SIGSTKSZ: ::size_t = 8192;\npub const MINSIGSTKSZ: ::size_t = 2048;\npub const CBAUD: ::tcflag_t = 4111;\npub const TAB1: ::tcflag_t = 2048;\npub const TAB2: ::tcflag_t = 4096;\npub const TAB3: ::tcflag_t = 6144;\npub const CR1: ::tcflag_t = 512;\npub const CR2: ::tcflag_t = 1024;\npub const CR3: ::tcflag_t = 1536;\npub const FF1: ::tcflag_t = 32768;\npub const BS1: ::tcflag_t = 8192;\npub const VT1: ::tcflag_t = 16384;\npub const VWERASE: usize = 14;\npub const VREPRINT: usize = 12;\npub const VSUSP: usize = 10;\npub const VSTART: usize = 8;\npub const VSTOP: usize = 9;\npub const VDISCARD: usize = 13;\npub const VTIME: usize = 5;\npub const IXON: ::tcflag_t = 1024;\npub const IXOFF: ::tcflag_t = 4096;\npub const ONLCR: ::tcflag_t = 4;\npub const CSIZE: ::tcflag_t = 48;\npub const CS6: ::tcflag_t = 16;\npub const CS7: ::tcflag_t = 32;\npub const CS8: ::tcflag_t = 48;\npub const CSTOPB: ::tcflag_t = 64;\npub const CREAD: ::tcflag_t = 128;\npub const PARENB: ::tcflag_t = 256;\npub const PARODD: ::tcflag_t = 512;\npub const HUPCL: ::tcflag_t = 1024;\npub const CLOCAL: ::tcflag_t = 2048;\npub const ECHOKE: ::tcflag_t = 2048;\npub const ECHOE: ::tcflag_t = 16;\npub const ECHOK: ::tcflag_t = 32;\npub const ECHONL: ::tcflag_t = 64;\npub const ECHOPRT: ::tcflag_t = 1024;\npub const ECHOCTL: ::tcflag_t = 512;\npub const ISIG: ::tcflag_t = 1;\npub const ICANON: ::tcflag_t = 2;\npub const PENDIN: ::tcflag_t = 16384;\npub const NOFLSH: ::tcflag_t = 128;\npub const CIBAUD: ::tcflag_t = 269418496;\npub const CBAUDEX: ::tcflag_t = 4096;\npub const VSWTC: usize = 7;\npub const OLCUC: ::tcflag_t = 2;\npub const NLDLY: ::tcflag_t = 256;\npub const CRDLY: ::tcflag_t = 1536;\npub const TABDLY: ::tcflag_t = 6144;\npub const BSDLY: ::tcflag_t = 8192;\npub const FFDLY: ::tcflag_t = 32768;\npub const VTDLY: ::tcflag_t = 16384;\npub const XTABS: ::tcflag_t = 6144;\npub const B0: ::speed_t = 0;\npub const B50: ::speed_t = 1;\npub const B75: ::speed_t = 2;\npub const B110: ::speed_t = 3;\npub const B134: ::speed_t = 4;\npub const B150: ::speed_t = 5;\npub const B200: ::speed_t = 6;\npub const B300: ::speed_t = 7;\npub const B600: ::speed_t = 8;\npub const B1200: ::speed_t = 9;\npub const B1800: ::speed_t = 10;\npub const B2400: ::speed_t = 11;\npub const B4800: ::speed_t = 12;\npub const B9600: ::speed_t = 13;\npub const B19200: ::speed_t = 14;\npub const B38400: ::speed_t = 15;\npub const EXTA: ::speed_t = 14;\npub const EXTB: ::speed_t = 15;\npub const B57600: ::speed_t = 4097;\npub const B115200: ::speed_t = 4098;\npub const B230400: ::speed_t = 4099;\npub const B460800: ::speed_t = 4100;\npub const B500000: ::speed_t = 4101;\npub const B576000: ::speed_t = 4102;\npub const B921600: ::speed_t = 4103;\npub const B1000000: ::speed_t = 4104;\npub const B1152000: ::speed_t = 4105;\npub const B1500000: ::speed_t = 4106;\npub const B2000000: ::speed_t = 4107;\npub const B2500000: ::speed_t = 4108;\npub const B3000000: ::speed_t = 4109;\npub const B3500000: ::speed_t = 4110;\npub const B4000000: ::speed_t = 4111;\npub const VEOL: usize = 11;\npub const VEOL2: usize = 16;\npub const VMIN: usize = 6;\npub const IEXTEN: ::tcflag_t = 32768;\npub const TOSTOP: ::tcflag_t = 256;\npub const FLUSHO: ::tcflag_t = 4096;\npub const EXTPROC: ::tcflag_t = 65536;\npub const TCGETS: ::c_ulong = 21505;\npub const TCSETS: ::c_ulong = 21506;\npub const TCSETSW: ::c_ulong = 21507;\npub const TCSETSF: ::c_ulong = 21508;\npub const TCGETA: ::c_ulong = 21509;\npub const TCSETA: ::c_ulong = 21510;\npub const TCSETAW: ::c_ulong = 21511;\npub const TCSETAF: ::c_ulong = 21512;\npub const TCSBRK: ::c_ulong = 21513;\npub const TCXONC: ::c_ulong = 21514;\npub const TCFLSH: ::c_ulong = 21515;\npub const TIOCINQ: ::c_ulong = 21531;\npub const TIOCGPGRP: ::c_ulong = 21519;\npub const TIOCSPGRP: ::c_ulong = 21520;\npub const TIOCOUTQ: ::c_ulong = 21521;\npub const TIOCGWINSZ: ::c_ulong = 21523;\npub const TIOCSWINSZ: ::c_ulong = 21524;\npub const FIONREAD: ::c_ulong = 21531;\npub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;\npub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;\n\npub const SYS_read: ::c_long = 63;\npub const SYS_write: ::c_long = 64;\npub const SYS_close: ::c_long = 57;\npub const SYS_fstat: ::c_long = 80;\npub const SYS_lseek: ::c_long = 62;\npub const SYS_mmap: ::c_long = 222;\npub const SYS_mprotect: ::c_long = 226;\npub const SYS_munmap: ::c_long = 215;\npub const SYS_brk: ::c_long = 214;\npub const SYS_rt_sigaction: ::c_long = 134;\npub const SYS_rt_sigprocmask: ::c_long = 135;\npub const SYS_rt_sigreturn: ::c_long = 139;\npub const SYS_ioctl: ::c_long = 29;\npub const SYS_pread64: ::c_long = 67;\npub const SYS_pwrite64: ::c_long = 68;\npub const SYS_readv: ::c_long = 65;\npub const SYS_writev: ::c_long = 66;\npub const SYS_sched_yield: ::c_long = 124;\npub const SYS_mremap: ::c_long = 216;\npub const SYS_msync: ::c_long = 227;\npub const SYS_mincore: ::c_long = 232;\npub const SYS_madvise: ::c_long = 233;\npub const SYS_shmget: ::c_long = 194;\npub const SYS_shmat: ::c_long = 196;\npub const SYS_shmctl: ::c_long = 195;\npub const SYS_dup: ::c_long = 23;\npub const SYS_nanosleep: ::c_long = 101;\npub const SYS_getitimer: ::c_long = 102;\npub const SYS_setitimer: ::c_long = 103;\npub const SYS_getpid: ::c_long = 172;\npub const SYS_sendfile: ::c_long = 71;\npub const SYS_socket: ::c_long = 198;\npub const SYS_connect: ::c_long = 203;\npub const SYS_accept: ::c_long = 202;\npub const SYS_sendto: ::c_long = 206;\npub const SYS_recvfrom: ::c_long = 207;\npub const SYS_sendmsg: ::c_long = 211;\npub const SYS_recvmsg: ::c_long = 212;\npub const SYS_shutdown: ::c_long = 210;\npub const SYS_bind: ::c_long = 200;\npub const SYS_listen: ::c_long = 201;\npub const SYS_getsockname: ::c_long = 204;\npub const SYS_getpeername: ::c_long = 205;\npub const SYS_socketpair: ::c_long = 199;\npub const SYS_setsockopt: ::c_long = 208;\npub const SYS_getsockopt: ::c_long = 209;\npub const SYS_clone: ::c_long = 220;\npub const SYS_execve: ::c_long = 221;\npub const SYS_exit: ::c_long = 93;\npub const SYS_wait4: ::c_long = 260;\npub const SYS_kill: ::c_long = 129;\npub const SYS_uname: ::c_long = 160;\npub const SYS_semget: ::c_long = 190;\npub const SYS_semop: ::c_long = 193;\npub const SYS_semctl: ::c_long = 191;\npub const SYS_shmdt: ::c_long = 197;\npub const SYS_msgget: ::c_long = 186;\npub const SYS_msgsnd: ::c_long = 189;\npub const SYS_msgrcv: ::c_long = 188;\npub const SYS_msgctl: ::c_long = 187;\npub const SYS_fcntl: ::c_long = 25;\npub const SYS_flock: ::c_long = 32;\npub const SYS_fsync: ::c_long = 82;\npub const SYS_fdatasync: ::c_long = 83;\npub const SYS_truncate: ::c_long = 45;\npub const SYS_ftruncate: ::c_long = 46;\npub const SYS_getcwd: ::c_long = 17;\npub const SYS_chdir: ::c_long = 49;\npub const SYS_fchdir: ::c_long = 50;\npub const SYS_fchmod: ::c_long = 52;\npub const SYS_fchown: ::c_long = 55;\npub const SYS_umask: ::c_long = 166;\npub const SYS_gettimeofday: ::c_long = 169;\npub const SYS_getrlimit: ::c_long = 163;\npub const SYS_getrusage: ::c_long = 165;\npub const SYS_sysinfo: ::c_long = 179;\npub const SYS_times: ::c_long = 153;\npub const SYS_ptrace: ::c_long = 117;\npub const SYS_getuid: ::c_long = 174;\npub const SYS_syslog: ::c_long = 116;\npub const SYS_getgid: ::c_long = 176;\npub const SYS_setuid: ::c_long = 146;\npub const SYS_setgid: ::c_long = 144;\npub const SYS_geteuid: ::c_long = 175;\npub const SYS_getegid: ::c_long = 177;\npub const SYS_setpgid: ::c_long = 154;\npub const SYS_getppid: ::c_long = 173;\npub const SYS_setsid: ::c_long = 157;\npub const SYS_setreuid: ::c_long = 145;\npub const SYS_setregid: ::c_long = 143;\npub const SYS_getgroups: ::c_long = 158;\npub const SYS_setgroups: ::c_long = 159;\npub const SYS_setresuid: ::c_long = 147;\npub const SYS_getresuid: ::c_long = 148;\npub const SYS_setresgid: ::c_long = 149;\npub const SYS_getresgid: ::c_long = 150;\npub const SYS_getpgid: ::c_long = 155;\npub const SYS_setfsuid: ::c_long = 151;\npub const SYS_setfsgid: ::c_long = 152;\npub const SYS_getsid: ::c_long = 156;\npub const SYS_capget: ::c_long = 90;\npub const SYS_capset: ::c_long = 91;\npub const SYS_rt_sigpending: ::c_long = 136;\npub const SYS_rt_sigtimedwait: ::c_long = 137;\npub const SYS_rt_sigqueueinfo: ::c_long = 138;\npub const SYS_rt_sigsuspend: ::c_long = 133;\npub const SYS_sigaltstack: ::c_long = 132;\npub const SYS_personality: ::c_long = 92;\npub const SYS_statfs: ::c_long = 43;\npub const SYS_fstatfs: ::c_long = 44;\npub const SYS_getpriority: ::c_long = 141;\npub const SYS_setpriority: ::c_long = 140;\npub const SYS_sched_setparam: ::c_long = 118;\npub const SYS_sched_getparam: ::c_long = 121;\npub const SYS_sched_setscheduler: ::c_long = 119;\npub const SYS_sched_getscheduler: ::c_long = 120;\npub const SYS_sched_get_priority_max: ::c_long = 125;\npub const SYS_sched_get_priority_min: ::c_long = 126;\npub const SYS_sched_rr_get_interval: ::c_long = 127;\npub const SYS_mlock: ::c_long = 228;\npub const SYS_munlock: ::c_long = 229;\npub const SYS_mlockall: ::c_long = 230;\npub const SYS_munlockall: ::c_long = 231;\npub const SYS_vhangup: ::c_long = 58;\npub const SYS_pivot_root: ::c_long = 41;\npub const SYS_prctl: ::c_long = 167;\npub const SYS_adjtimex: ::c_long = 171;\npub const SYS_setrlimit: ::c_long = 164;\npub const SYS_chroot: ::c_long = 51;\npub const SYS_sync: ::c_long = 81;\npub const SYS_acct: ::c_long = 89;\npub const SYS_settimeofday: ::c_long = 170;\npub const SYS_mount: ::c_long = 40;\npub const SYS_umount2: ::c_long = 39;\npub const SYS_swapon: ::c_long = 224;\npub const SYS_swapoff: ::c_long = 225;\npub const SYS_reboot: ::c_long = 142;\npub const SYS_sethostname: ::c_long = 161;\npub const SYS_setdomainname: ::c_long = 162;\npub const SYS_init_module: ::c_long = 105;\npub const SYS_delete_module: ::c_long = 106;\npub const SYS_quotactl: ::c_long = 60;\npub const SYS_nfsservctl: ::c_long = 42;\npub const SYS_gettid: ::c_long = 178;\npub const SYS_readahead: ::c_long = 213;\npub const SYS_setxattr: ::c_long = 5;\npub const SYS_lsetxattr: ::c_long = 6;\npub const SYS_fsetxattr: ::c_long = 7;\npub const SYS_getxattr: ::c_long = 8;\npub const SYS_lgetxattr: ::c_long = 9;\npub const SYS_fgetxattr: ::c_long = 10;\npub const SYS_listxattr: ::c_long = 11;\npub const SYS_llistxattr: ::c_long = 12;\npub const SYS_flistxattr: ::c_long = 13;\npub const SYS_removexattr: ::c_long = 14;\npub const SYS_lremovexattr: ::c_long = 15;\npub const SYS_fremovexattr: ::c_long = 16;\npub const SYS_tkill: ::c_long = 130;\npub const SYS_futex: ::c_long = 98;\npub const SYS_sched_setaffinity: ::c_long = 122;\npub const SYS_sched_getaffinity: ::c_long = 123;\npub const SYS_io_setup: ::c_long = 0;\npub const SYS_io_destroy: ::c_long = 1;\npub const SYS_io_getevents: ::c_long = 4;\npub const SYS_io_submit: ::c_long = 2;\npub const SYS_io_cancel: ::c_long = 3;\npub const SYS_lookup_dcookie: ::c_long = 18;\npub const SYS_remap_file_pages: ::c_long = 234;\npub const SYS_getdents64: ::c_long = 61;\npub const SYS_set_tid_address: ::c_long = 96;\npub const SYS_restart_syscall: ::c_long = 128;\npub const SYS_semtimedop: ::c_long = 192;\npub const SYS_fadvise64: ::c_long = 223;\npub const SYS_timer_create: ::c_long = 107;\npub const SYS_timer_settime: ::c_long = 110;\npub const SYS_timer_gettime: ::c_long = 108;\npub const SYS_timer_getoverrun: ::c_long = 109;\npub const SYS_timer_delete: ::c_long = 111;\npub const SYS_clock_settime: ::c_long = 112;\npub const SYS_clock_gettime: ::c_long = 113;\npub const SYS_clock_getres: ::c_long = 114;\npub const SYS_clock_nanosleep: ::c_long = 115;\npub const SYS_exit_group: ::c_long = 94;\npub const SYS_epoll_ctl: ::c_long = 21;\npub const SYS_tgkill: ::c_long = 131;\npub const SYS_mbind: ::c_long = 235;\npub const SYS_set_mempolicy: ::c_long = 237;\npub const SYS_get_mempolicy: ::c_long = 236;\npub const SYS_mq_open: ::c_long = 180;\npub const SYS_mq_unlink: ::c_long = 181;\npub const SYS_mq_timedsend: ::c_long = 182;\npub const SYS_mq_timedreceive: ::c_long = 183;\npub const SYS_mq_notify: ::c_long = 184;\npub const SYS_mq_getsetattr: ::c_long = 185;\npub const SYS_kexec_load: ::c_long = 104;\npub const SYS_waitid: ::c_long = 95;\npub const SYS_add_key: ::c_long = 217;\npub const SYS_request_key: ::c_long = 218;\npub const SYS_keyctl: ::c_long = 219;\npub const SYS_ioprio_set: ::c_long = 30;\npub const SYS_ioprio_get: ::c_long = 31;\npub const SYS_inotify_add_watch: ::c_long = 27;\npub const SYS_inotify_rm_watch: ::c_long = 28;\npub const SYS_migrate_pages: ::c_long = 238;\npub const SYS_openat: ::c_long = 56;\npub const SYS_mkdirat: ::c_long = 34;\npub const SYS_mknodat: ::c_long = 33;\npub const SYS_fchownat: ::c_long = 54;\npub const SYS_newfstatat: ::c_long = 79;\npub const SYS_unlinkat: ::c_long = 35;\npub const SYS_linkat: ::c_long = 37;\npub const SYS_symlinkat: ::c_long = 36;\npub const SYS_readlinkat: ::c_long = 78;\npub const SYS_fchmodat: ::c_long = 53;\npub const SYS_faccessat: ::c_long = 48;\npub const SYS_pselect6: ::c_long = 72;\npub const SYS_ppoll: ::c_long = 73;\npub const SYS_unshare: ::c_long = 97;\npub const SYS_set_robust_list: ::c_long = 99;\npub const SYS_get_robust_list: ::c_long = 100;\npub const SYS_splice: ::c_long = 76;\npub const SYS_tee: ::c_long = 77;\npub const SYS_sync_file_range: ::c_long = 84;\npub const SYS_vmsplice: ::c_long = 75;\npub const SYS_move_pages: ::c_long = 239;\npub const SYS_utimensat: ::c_long = 88;\npub const SYS_epoll_pwait: ::c_long = 22;\npub const SYS_timerfd_create: ::c_long = 85;\npub const SYS_fallocate: ::c_long = 47;\npub const SYS_timerfd_settime: ::c_long = 86;\npub const SYS_timerfd_gettime: ::c_long = 87;\npub const SYS_accept4: ::c_long = 242;\npub const SYS_signalfd4: ::c_long = 74;\npub const SYS_eventfd2: ::c_long = 19;\npub const SYS_epoll_create1: ::c_long = 20;\npub const SYS_dup3: ::c_long = 24;\npub const SYS_pipe2: ::c_long = 59;\npub const SYS_inotify_init1: ::c_long = 26;\npub const SYS_preadv: ::c_long = 69;\npub const SYS_pwritev: ::c_long = 70;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 240;\npub const SYS_perf_event_open: ::c_long = 241;\npub const SYS_recvmmsg: ::c_long = 243;\npub const SYS_fanotify_init: ::c_long = 262;\npub const SYS_fanotify_mark: ::c_long = 263;\npub const SYS_prlimit64: ::c_long = 261;\npub const SYS_name_to_handle_at: ::c_long = 264;\npub const SYS_open_by_handle_at: ::c_long = 265;\npub const SYS_clock_adjtime: ::c_long = 266;\npub const SYS_syncfs: ::c_long = 267;\npub const SYS_sendmmsg: ::c_long = 269;\npub const SYS_setns: ::c_long = 268;\npub const SYS_getcpu: ::c_long = 168;\npub const SYS_process_vm_readv: ::c_long = 270;\npub const SYS_process_vm_writev: ::c_long = 271;\npub const SYS_kcmp: ::c_long = 272;\npub const SYS_finit_module: ::c_long = 273;\npub const SYS_sched_setattr: ::c_long = 274;\npub const SYS_sched_getattr: ::c_long = 275;\npub const SYS_renameat2: ::c_long = 276;\npub const SYS_seccomp: ::c_long = 277;\npub const SYS_getrandom: ::c_long = 278;\npub const SYS_memfd_create: ::c_long = 279;\npub const SYS_bpf: ::c_long = 280;\npub const SYS_execveat: ::c_long = 281;\npub const SYS_userfaultfd: ::c_long = 282;\npub const SYS_membarrier: ::c_long = 283;\npub const SYS_mlock2: ::c_long = 284;\npub const SYS_copy_file_range: ::c_long = 285;\npub const SYS_preadv2: ::c_long = 286;\npub const SYS_pwritev2: ::c_long = 287;\npub const SYS_pkey_mprotect: ::c_long = 288;\npub const SYS_pkey_alloc: ::c_long = 289;\npub const SYS_pkey_free: ::c_long = 290;\npub const SYS_statx: ::c_long = 291;\npub const SYS_pidfd_send_signal: ::c_long = 424;\npub const SYS_io_uring_setup: ::c_long = 425;\npub const SYS_io_uring_enter: ::c_long = 426;\npub const SYS_io_uring_register: ::c_long = 427;\npub const SYS_open_tree: ::c_long = 428;\npub const SYS_move_mount: ::c_long = 429;\npub const SYS_fsopen: ::c_long = 430;\npub const SYS_fsconfig: ::c_long = 431;\npub const SYS_fsmount: ::c_long = 432;\npub const SYS_fspick: ::c_long = 433;\npub const SYS_pidfd_open: ::c_long = 434;\npub const SYS_clone3: ::c_long = 435;\npub const SYS_close_range: ::c_long = 436;\npub const SYS_openat2: ::c_long = 437;\npub const SYS_pidfd_getfd: ::c_long = 438;\npub const SYS_faccessat2: ::c_long = 439;\npub const SYS_process_madvise: ::c_long = 440;\npub const SYS_epoll_pwait2: ::c_long = 441;\npub const SYS_mount_setattr: ::c_long = 442;\n"],["1194","s! {\n    // FIXME this is actually a union\n    #[cfg_attr(target_pointer_width = \"32\",\n               repr(align(4)))]\n    #[cfg_attr(target_pointer_width = \"64\",\n               repr(align(8)))]\n    pub struct sem_t {\n        #[cfg(target_pointer_width = \"32\")]\n        __size: [::c_char; 16],\n        #[cfg(target_pointer_width = \"64\")]\n        __size: [::c_char; 32],\n    }\n}\n"],["1195","pub type c_char = i8;\npub type wchar_t = ::c_int;\n\ns! {\n    pub struct stat {\n        pub st_dev: ::dev_t,\n        __st_padding1: [::c_long; 2],\n        pub st_ino: ::ino_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        __st_padding2: [::c_long; 2],\n        pub st_size: ::off_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        pub st_blksize: ::blksize_t,\n        __st_padding3: ::c_long,\n        pub st_blocks: ::blkcnt_t,\n        __st_padding4: [::c_long; 14],\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::dev_t,\n        __st_padding1: [::c_long; 2],\n        pub st_ino: ::ino64_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        __st_padding2: [::c_long; 2],\n        pub st_size: ::off_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        pub st_blksize: ::blksize_t,\n        __st_padding3: ::c_long,\n        pub st_blocks: ::blkcnt64_t,\n        __st_padding4: [::c_long; 14],\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_size: ::size_t,\n        pub ss_flags: ::c_int,\n    }\n\n    pub struct ipc_perm {\n        pub __ipc_perm_key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::mode_t,\n        pub __seq: ::c_int,\n        __unused1: ::c_long,\n        __unused2: ::c_long\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        pub shm_segsz: ::size_t,\n        pub shm_atime: ::time_t,\n        pub shm_dtime: ::time_t,\n        pub shm_ctime: ::time_t,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::c_ulong,\n        __pad1: ::c_ulong,\n        __pad2: ::c_ulong,\n    }\n\n    pub struct msqid_ds {\n        pub msg_perm: ::ipc_perm,\n        #[cfg(target_endian = \"big\")]\n        __unused1: ::c_int,\n        pub msg_stime: ::time_t,\n        #[cfg(target_endian = \"little\")]\n        __unused1: ::c_int,\n        #[cfg(target_endian = \"big\")]\n        __unused2: ::c_int,\n        pub msg_rtime: ::time_t,\n        #[cfg(target_endian = \"little\")]\n        __unused2: ::c_int,\n        #[cfg(target_endian = \"big\")]\n        __unused3: ::c_int,\n        pub msg_ctime: ::time_t,\n        #[cfg(target_endian = \"little\")]\n        __unused3: ::c_int,\n        __msg_cbytes: ::c_ulong,\n        pub msg_qnum: ::msgqnum_t,\n        pub msg_qbytes: ::msglen_t,\n        pub msg_lspid: ::pid_t,\n        pub msg_lrpid: ::pid_t,\n        __pad1: ::c_ulong,\n        __pad2: ::c_ulong,\n    }\n\n    pub struct statfs {\n        pub f_type: ::c_ulong,\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_ulong,\n        pub f_flags: ::c_ulong,\n        pub f_spare: [::c_ulong; 5],\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_code: ::c_int,\n        pub si_errno: ::c_int,\n        pub _pad: [::c_int; 29],\n        _align: [usize; 0],\n    }\n\n    pub struct statfs64 {\n        pub f_type: ::c_ulong,\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_ulong,\n        pub f_flags: ::c_ulong,\n        pub f_spare: [::c_ulong; 5],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_favail: u64,\n        #[cfg(target_endian = \"little\")]\n        pub f_fsid: ::c_ulong,\n        __f_unused: ::c_int,\n        #[cfg(target_endian = \"big\")]\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n}\n\npub const SIGSTKSZ: ::size_t = 8192;\npub const MINSIGSTKSZ: ::size_t = 2048;\n\npub const O_DIRECT: ::c_int = 0o100000;\npub const O_DIRECTORY: ::c_int = 0o200000;\npub const O_NOFOLLOW: ::c_int = 0o400000;\npub const O_ASYNC: ::c_int = 0o10000;\npub const O_LARGEFILE: ::c_int = 0x2000;\n\npub const FIOCLEX: ::c_int = 0x6601;\npub const FIONCLEX: ::c_int = 0x6602;\npub const FIONBIO: ::c_int = 0x667E;\n\npub const RLIMIT_RSS: ::c_int = 7;\npub const RLIMIT_NOFILE: ::c_int = 5;\npub const RLIMIT_AS: ::c_int = 6;\npub const RLIMIT_NPROC: ::c_int = 8;\npub const RLIMIT_MEMLOCK: ::c_int = 9;\npub const RLIMIT_NLIMITS: ::c_int = 15;\npub const RLIM_NLIMITS: ::c_int = RLIMIT_NLIMITS;\n\npub const MCL_CURRENT: ::c_int = 0x0001;\npub const MCL_FUTURE: ::c_int = 0x0002;\npub const CBAUD: ::tcflag_t = 0o0010017;\npub const TAB1: ::c_int = 0x00000800;\npub const TAB2: ::c_int = 0x00001000;\npub const TAB3: ::c_int = 0x00001800;\npub const CR1: ::c_int = 0x00000200;\npub const CR2: ::c_int = 0x00000400;\npub const CR3: ::c_int = 0x00000600;\npub const FF1: ::c_int = 0x00008000;\npub const BS1: ::c_int = 0x00002000;\npub const VT1: ::c_int = 0x00004000;\npub const VWERASE: usize = 14;\npub const VREPRINT: usize = 12;\npub const VSUSP: usize = 10;\npub const VSTART: usize = 8;\npub const VSTOP: usize = 9;\npub const VDISCARD: usize = 13;\npub const VTIME: usize = 5;\npub const IXON: ::tcflag_t = 0x00000400;\npub const IXOFF: ::tcflag_t = 0x00001000;\npub const ONLCR: ::tcflag_t = 0x4;\npub const CSIZE: ::tcflag_t = 0x00000030;\npub const CS6: ::tcflag_t = 0x00000010;\npub const CS7: ::tcflag_t = 0x00000020;\npub const CS8: ::tcflag_t = 0x00000030;\npub const CSTOPB: ::tcflag_t = 0x00000040;\npub const CREAD: ::tcflag_t = 0x00000080;\npub const PARENB: ::tcflag_t = 0x00000100;\npub const PARODD: ::tcflag_t = 0x00000200;\npub const HUPCL: ::tcflag_t = 0x00000400;\npub const CLOCAL: ::tcflag_t = 0x00000800;\npub const ECHOKE: ::tcflag_t = 0x00000800;\npub const ECHOE: ::tcflag_t = 0x00000010;\npub const ECHOK: ::tcflag_t = 0x00000020;\npub const ECHONL: ::tcflag_t = 0x00000040;\npub const ECHOPRT: ::tcflag_t = 0x00000400;\npub const ECHOCTL: ::tcflag_t = 0x00000200;\npub const ISIG: ::tcflag_t = 0x00000001;\npub const ICANON: ::tcflag_t = 0x00000002;\npub const PENDIN: ::tcflag_t = 0x00004000;\npub const NOFLSH: ::tcflag_t = 0x00000080;\npub const CIBAUD: ::tcflag_t = 0o02003600000;\npub const CBAUDEX: ::tcflag_t = 0o010000;\npub const VSWTC: usize = 7;\npub const OLCUC: ::tcflag_t = 0o000002;\npub const NLDLY: ::tcflag_t = 0o000400;\npub const CRDLY: ::tcflag_t = 0o003000;\npub const TABDLY: ::tcflag_t = 0o014000;\npub const BSDLY: ::tcflag_t = 0o020000;\npub const FFDLY: ::tcflag_t = 0o100000;\npub const VTDLY: ::tcflag_t = 0o040000;\npub const XTABS: ::tcflag_t = 0o014000;\npub const B57600: ::speed_t = 0o010001;\npub const B115200: ::speed_t = 0o010002;\npub const B230400: ::speed_t = 0o010003;\npub const B460800: ::speed_t = 0o010004;\npub const B500000: ::speed_t = 0o010005;\npub const B576000: ::speed_t = 0o010006;\npub const B921600: ::speed_t = 0o010007;\npub const B1000000: ::speed_t = 0o010010;\npub const B1152000: ::speed_t = 0o010011;\npub const B1500000: ::speed_t = 0o010012;\npub const B2000000: ::speed_t = 0o010013;\npub const B2500000: ::speed_t = 0o010014;\npub const B3000000: ::speed_t = 0o010015;\npub const B3500000: ::speed_t = 0o010016;\npub const B4000000: ::speed_t = 0o010017;\n\npub const O_APPEND: ::c_int = 0o010;\npub const O_CREAT: ::c_int = 0o400;\npub const O_EXCL: ::c_int = 0o2000;\npub const O_NOCTTY: ::c_int = 0o4000;\npub const O_NONBLOCK: ::c_int = 0o200;\npub const O_SYNC: ::c_int = 0o40020;\npub const O_RSYNC: ::c_int = 0o40020;\npub const O_DSYNC: ::c_int = 0o020;\n\npub const SOCK_NONBLOCK: ::c_int = 0o200;\n\npub const MAP_ANON: ::c_int = 0x800;\npub const MAP_GROWSDOWN: ::c_int = 0x1000;\npub const MAP_DENYWRITE: ::c_int = 0x2000;\npub const MAP_EXECUTABLE: ::c_int = 0x4000;\npub const MAP_LOCKED: ::c_int = 0x8000;\npub const MAP_NORESERVE: ::c_int = 0x0400;\npub const MAP_POPULATE: ::c_int = 0x10000;\npub const MAP_NONBLOCK: ::c_int = 0x20000;\npub const MAP_STACK: ::c_int = 0x40000;\n\npub const EDEADLK: ::c_int = 45;\npub const ENAMETOOLONG: ::c_int = 78;\npub const ENOLCK: ::c_int = 46;\npub const ENOSYS: ::c_int = 89;\npub const ENOTEMPTY: ::c_int = 93;\npub const ELOOP: ::c_int = 90;\npub const ENOMSG: ::c_int = 35;\npub const EIDRM: ::c_int = 36;\npub const ECHRNG: ::c_int = 37;\npub const EL2NSYNC: ::c_int = 38;\npub const EL3HLT: ::c_int = 39;\npub const EL3RST: ::c_int = 40;\npub const ELNRNG: ::c_int = 41;\npub const EUNATCH: ::c_int = 42;\npub const ENOCSI: ::c_int = 43;\npub const EL2HLT: ::c_int = 44;\npub const EBADE: ::c_int = 50;\npub const EBADR: ::c_int = 51;\npub const EXFULL: ::c_int = 52;\npub const ENOANO: ::c_int = 53;\npub const EBADRQC: ::c_int = 54;\npub const EBADSLT: ::c_int = 55;\npub const EDEADLOCK: ::c_int = 56;\npub const EMULTIHOP: ::c_int = 74;\npub const EOVERFLOW: ::c_int = 79;\npub const ENOTUNIQ: ::c_int = 80;\npub const EBADFD: ::c_int = 81;\npub const EBADMSG: ::c_int = 77;\npub const EREMCHG: ::c_int = 82;\npub const ELIBACC: ::c_int = 83;\npub const ELIBBAD: ::c_int = 84;\npub const ELIBSCN: ::c_int = 85;\npub const ELIBMAX: ::c_int = 86;\npub const ELIBEXEC: ::c_int = 87;\npub const EILSEQ: ::c_int = 88;\npub const ERESTART: ::c_int = 91;\npub const ESTRPIPE: ::c_int = 92;\npub const EUSERS: ::c_int = 94;\npub const ENOTSOCK: ::c_int = 95;\npub const EDESTADDRREQ: ::c_int = 96;\npub const EMSGSIZE: ::c_int = 97;\npub const EPROTOTYPE: ::c_int = 98;\npub const ENOPROTOOPT: ::c_int = 99;\npub const EPROTONOSUPPORT: ::c_int = 120;\npub const ESOCKTNOSUPPORT: ::c_int = 121;\npub const EOPNOTSUPP: ::c_int = 122;\npub const ENOTSUP: ::c_int = EOPNOTSUPP;\npub const EPFNOSUPPORT: ::c_int = 123;\npub const EAFNOSUPPORT: ::c_int = 124;\npub const EADDRINUSE: ::c_int = 125;\npub const EADDRNOTAVAIL: ::c_int = 126;\npub const ENETDOWN: ::c_int = 127;\npub const ENETUNREACH: ::c_int = 128;\npub const ENETRESET: ::c_int = 129;\npub const ECONNABORTED: ::c_int = 130;\npub const ECONNRESET: ::c_int = 131;\npub const ENOBUFS: ::c_int = 132;\npub const EISCONN: ::c_int = 133;\npub const ENOTCONN: ::c_int = 134;\npub const ESHUTDOWN: ::c_int = 143;\npub const ETOOMANYREFS: ::c_int = 144;\npub const ETIMEDOUT: ::c_int = 145;\npub const ECONNREFUSED: ::c_int = 146;\npub const EHOSTDOWN: ::c_int = 147;\npub const EHOSTUNREACH: ::c_int = 148;\npub const EALREADY: ::c_int = 149;\npub const EINPROGRESS: ::c_int = 150;\npub const ESTALE: ::c_int = 151;\npub const EUCLEAN: ::c_int = 135;\npub const ENOTNAM: ::c_int = 137;\npub const ENAVAIL: ::c_int = 138;\npub const EISNAM: ::c_int = 139;\npub const EREMOTEIO: ::c_int = 140;\npub const EDQUOT: ::c_int = 1133;\npub const ENOMEDIUM: ::c_int = 159;\npub const EMEDIUMTYPE: ::c_int = 160;\npub const ECANCELED: ::c_int = 158;\npub const ENOKEY: ::c_int = 161;\npub const EKEYEXPIRED: ::c_int = 162;\npub const EKEYREVOKED: ::c_int = 163;\npub const EKEYREJECTED: ::c_int = 164;\npub const EOWNERDEAD: ::c_int = 165;\npub const ENOTRECOVERABLE: ::c_int = 166;\npub const EHWPOISON: ::c_int = 168;\npub const ERFKILL: ::c_int = 167;\n\npub const SOCK_STREAM: ::c_int = 2;\npub const SOCK_DGRAM: ::c_int = 1;\npub const SOCK_SEQPACKET: ::c_int = 5;\n\npub const SA_ONSTACK: ::c_int = 0x08000000;\npub const SA_SIGINFO: ::c_int = 8;\npub const SA_NOCLDWAIT: ::c_int = 0x10000;\n\npub const SIGCHLD: ::c_int = 18;\npub const SIGBUS: ::c_int = 10;\npub const SIGTTIN: ::c_int = 26;\npub const SIGTTOU: ::c_int = 27;\npub const SIGXCPU: ::c_int = 30;\npub const SIGXFSZ: ::c_int = 31;\npub const SIGVTALRM: ::c_int = 28;\npub const SIGPROF: ::c_int = 29;\npub const SIGWINCH: ::c_int = 20;\npub const SIGUSR1: ::c_int = 16;\npub const SIGUSR2: ::c_int = 17;\npub const SIGCONT: ::c_int = 25;\npub const SIGSTOP: ::c_int = 23;\npub const SIGTSTP: ::c_int = 24;\npub const SIGURG: ::c_int = 21;\npub const SIGIO: ::c_int = 22;\npub const SIGSYS: ::c_int = 12;\npub const SIGSTKFLT: ::c_int = 7;\npub const SIGPOLL: ::c_int = ::SIGIO;\npub const SIGPWR: ::c_int = 19;\npub const SIG_SETMASK: ::c_int = 3;\npub const SIG_BLOCK: ::c_int = 1;\npub const SIG_UNBLOCK: ::c_int = 2;\n\npub const EXTPROC: ::tcflag_t = 0o200000;\n\npub const MAP_HUGETLB: ::c_int = 0x80000;\n\npub const F_GETLK: ::c_int = 33;\npub const F_GETOWN: ::c_int = 23;\npub const F_SETLK: ::c_int = 34;\npub const F_SETLKW: ::c_int = 35;\npub const F_SETOWN: ::c_int = 24;\npub const F_OFD_GETLK: ::c_int = 36;\npub const F_OFD_SETLK: ::c_int = 37;\npub const F_OFD_SETLKW: ::c_int = 38;\n\npub const VEOF: usize = 16;\npub const VEOL: usize = 17;\npub const VEOL2: usize = 6;\npub const VMIN: usize = 4;\npub const IEXTEN: ::tcflag_t = 0o000400;\npub const TOSTOP: ::tcflag_t = 0o100000;\npub const FLUSHO: ::tcflag_t = 0o020000;\n\npub const TCGETS: ::c_int = 0x540D;\npub const TCSETS: ::c_int = 0x540E;\npub const TCSETSW: ::c_int = 0x540F;\npub const TCSETSF: ::c_int = 0x5410;\npub const TCGETA: ::c_int = 0x5401;\npub const TCSETA: ::c_int = 0x5402;\npub const TCSETAW: ::c_int = 0x5403;\npub const TCSETAF: ::c_int = 0x5404;\npub const TCSBRK: ::c_int = 0x5405;\npub const TCXONC: ::c_int = 0x5406;\npub const TCFLSH: ::c_int = 0x5407;\npub const TIOCGSOFTCAR: ::c_int = 0x5481;\npub const TIOCSSOFTCAR: ::c_int = 0x5482;\npub const TIOCLINUX: ::c_int = 0x5483;\npub const TIOCGSERIAL: ::c_int = 0x5484;\npub const TIOCEXCL: ::c_int = 0x740D;\npub const TIOCNXCL: ::c_int = 0x740E;\npub const TIOCSCTTY: ::c_int = 0x5480;\npub const TIOCGPGRP: ::c_int = 0x40047477;\npub const TIOCSPGRP: ::c_int = 0x80047476;\npub const TIOCOUTQ: ::c_int = 0x7472;\npub const TIOCSTI: ::c_int = 0x5472;\npub const TIOCGWINSZ: ::c_int = 0x40087468;\npub const TIOCSWINSZ: ::c_int = 0x80087467;\npub const TIOCMGET: ::c_int = 0x741D;\npub const TIOCMBIS: ::c_int = 0x741B;\npub const TIOCMBIC: ::c_int = 0x741C;\npub const TIOCMSET: ::c_int = 0x741A;\npub const FIONREAD: ::c_int = 0x467F;\npub const TIOCCONS: ::c_int = 0x80047478;\n\npub const TIOCGRS485: ::c_int = 0x4020542E;\npub const TIOCSRS485: ::c_int = 0xC020542F;\n\npub const POLLWRNORM: ::c_short = 0x4;\npub const POLLWRBAND: ::c_short = 0x100;\n\npub const TIOCM_LE: ::c_int = 0x001;\npub const TIOCM_DTR: ::c_int = 0x002;\npub const TIOCM_RTS: ::c_int = 0x004;\npub const TIOCM_ST: ::c_int = 0x010;\npub const TIOCM_SR: ::c_int = 0x020;\npub const TIOCM_CTS: ::c_int = 0x040;\npub const TIOCM_CAR: ::c_int = 0x100;\npub const TIOCM_CD: ::c_int = TIOCM_CAR;\npub const TIOCM_RNG: ::c_int = 0x200;\npub const TIOCM_RI: ::c_int = TIOCM_RNG;\npub const TIOCM_DSR: ::c_int = 0x400;\n\npub const SYS_syscall: ::c_long = 4000 + 0;\npub const SYS_exit: ::c_long = 4000 + 1;\npub const SYS_fork: ::c_long = 4000 + 2;\npub const SYS_read: ::c_long = 4000 + 3;\npub const SYS_write: ::c_long = 4000 + 4;\npub const SYS_open: ::c_long = 4000 + 5;\npub const SYS_close: ::c_long = 4000 + 6;\npub const SYS_waitpid: ::c_long = 4000 + 7;\npub const SYS_creat: ::c_long = 4000 + 8;\npub const SYS_link: ::c_long = 4000 + 9;\npub const SYS_unlink: ::c_long = 4000 + 10;\npub const SYS_execve: ::c_long = 4000 + 11;\npub const SYS_chdir: ::c_long = 4000 + 12;\npub const SYS_time: ::c_long = 4000 + 13;\npub const SYS_mknod: ::c_long = 4000 + 14;\npub const SYS_chmod: ::c_long = 4000 + 15;\npub const SYS_lchown: ::c_long = 4000 + 16;\npub const SYS_break: ::c_long = 4000 + 17;\npub const SYS_lseek: ::c_long = 4000 + 19;\npub const SYS_getpid: ::c_long = 4000 + 20;\npub const SYS_mount: ::c_long = 4000 + 21;\npub const SYS_umount: ::c_long = 4000 + 22;\npub const SYS_setuid: ::c_long = 4000 + 23;\npub const SYS_getuid: ::c_long = 4000 + 24;\npub const SYS_stime: ::c_long = 4000 + 25;\npub const SYS_ptrace: ::c_long = 4000 + 26;\npub const SYS_alarm: ::c_long = 4000 + 27;\npub const SYS_pause: ::c_long = 4000 + 29;\npub const SYS_utime: ::c_long = 4000 + 30;\npub const SYS_stty: ::c_long = 4000 + 31;\npub const SYS_gtty: ::c_long = 4000 + 32;\npub const SYS_access: ::c_long = 4000 + 33;\npub const SYS_nice: ::c_long = 4000 + 34;\npub const SYS_ftime: ::c_long = 4000 + 35;\npub const SYS_sync: ::c_long = 4000 + 36;\npub const SYS_kill: ::c_long = 4000 + 37;\npub const SYS_rename: ::c_long = 4000 + 38;\npub const SYS_mkdir: ::c_long = 4000 + 39;\npub const SYS_rmdir: ::c_long = 4000 + 40;\npub const SYS_dup: ::c_long = 4000 + 41;\npub const SYS_pipe: ::c_long = 4000 + 42;\npub const SYS_times: ::c_long = 4000 + 43;\npub const SYS_prof: ::c_long = 4000 + 44;\npub const SYS_brk: ::c_long = 4000 + 45;\npub const SYS_setgid: ::c_long = 4000 + 46;\npub const SYS_getgid: ::c_long = 4000 + 47;\npub const SYS_signal: ::c_long = 4000 + 48;\npub const SYS_geteuid: ::c_long = 4000 + 49;\npub const SYS_getegid: ::c_long = 4000 + 50;\npub const SYS_acct: ::c_long = 4000 + 51;\npub const SYS_umount2: ::c_long = 4000 + 52;\npub const SYS_lock: ::c_long = 4000 + 53;\npub const SYS_ioctl: ::c_long = 4000 + 54;\npub const SYS_fcntl: ::c_long = 4000 + 55;\npub const SYS_mpx: ::c_long = 4000 + 56;\npub const SYS_setpgid: ::c_long = 4000 + 57;\npub const SYS_ulimit: ::c_long = 4000 + 58;\npub const SYS_umask: ::c_long = 4000 + 60;\npub const SYS_chroot: ::c_long = 4000 + 61;\npub const SYS_ustat: ::c_long = 4000 + 62;\npub const SYS_dup2: ::c_long = 4000 + 63;\npub const SYS_getppid: ::c_long = 4000 + 64;\npub const SYS_getpgrp: ::c_long = 4000 + 65;\npub const SYS_setsid: ::c_long = 4000 + 66;\npub const SYS_sigaction: ::c_long = 4000 + 67;\npub const SYS_sgetmask: ::c_long = 4000 + 68;\npub const SYS_ssetmask: ::c_long = 4000 + 69;\npub const SYS_setreuid: ::c_long = 4000 + 70;\npub const SYS_setregid: ::c_long = 4000 + 71;\npub const SYS_sigsuspend: ::c_long = 4000 + 72;\npub const SYS_sigpending: ::c_long = 4000 + 73;\npub const SYS_sethostname: ::c_long = 4000 + 74;\npub const SYS_setrlimit: ::c_long = 4000 + 75;\npub const SYS_getrlimit: ::c_long = 4000 + 76;\npub const SYS_getrusage: ::c_long = 4000 + 77;\npub const SYS_gettimeofday: ::c_long = 4000 + 78;\npub const SYS_settimeofday: ::c_long = 4000 + 79;\npub const SYS_getgroups: ::c_long = 4000 + 80;\npub const SYS_setgroups: ::c_long = 4000 + 81;\npub const SYS_symlink: ::c_long = 4000 + 83;\npub const SYS_readlink: ::c_long = 4000 + 85;\npub const SYS_uselib: ::c_long = 4000 + 86;\npub const SYS_swapon: ::c_long = 4000 + 87;\npub const SYS_reboot: ::c_long = 4000 + 88;\npub const SYS_readdir: ::c_long = 4000 + 89;\npub const SYS_mmap: ::c_long = 4000 + 90;\npub const SYS_munmap: ::c_long = 4000 + 91;\npub const SYS_truncate: ::c_long = 4000 + 92;\npub const SYS_ftruncate: ::c_long = 4000 + 93;\npub const SYS_fchmod: ::c_long = 4000 + 94;\npub const SYS_fchown: ::c_long = 4000 + 95;\npub const SYS_getpriority: ::c_long = 4000 + 96;\npub const SYS_setpriority: ::c_long = 4000 + 97;\npub const SYS_profil: ::c_long = 4000 + 98;\npub const SYS_statfs: ::c_long = 4000 + 99;\npub const SYS_fstatfs: ::c_long = 4000 + 100;\npub const SYS_ioperm: ::c_long = 4000 + 101;\npub const SYS_socketcall: ::c_long = 4000 + 102;\npub const SYS_syslog: ::c_long = 4000 + 103;\npub const SYS_setitimer: ::c_long = 4000 + 104;\npub const SYS_getitimer: ::c_long = 4000 + 105;\npub const SYS_stat: ::c_long = 4000 + 106;\npub const SYS_lstat: ::c_long = 4000 + 107;\npub const SYS_fstat: ::c_long = 4000 + 108;\npub const SYS_iopl: ::c_long = 4000 + 110;\npub const SYS_vhangup: ::c_long = 4000 + 111;\npub const SYS_idle: ::c_long = 4000 + 112;\npub const SYS_vm86: ::c_long = 4000 + 113;\npub const SYS_wait4: ::c_long = 4000 + 114;\npub const SYS_swapoff: ::c_long = 4000 + 115;\npub const SYS_sysinfo: ::c_long = 4000 + 116;\npub const SYS_ipc: ::c_long = 4000 + 117;\npub const SYS_fsync: ::c_long = 4000 + 118;\npub const SYS_sigreturn: ::c_long = 4000 + 119;\npub const SYS_clone: ::c_long = 4000 + 120;\npub const SYS_setdomainname: ::c_long = 4000 + 121;\npub const SYS_uname: ::c_long = 4000 + 122;\npub const SYS_modify_ldt: ::c_long = 4000 + 123;\npub const SYS_adjtimex: ::c_long = 4000 + 124;\npub const SYS_mprotect: ::c_long = 4000 + 125;\npub const SYS_sigprocmask: ::c_long = 4000 + 126;\npub const SYS_create_module: ::c_long = 4000 + 127;\npub const SYS_init_module: ::c_long = 4000 + 128;\npub const SYS_delete_module: ::c_long = 4000 + 129;\npub const SYS_get_kernel_syms: ::c_long = 4000 + 130;\npub const SYS_quotactl: ::c_long = 4000 + 131;\npub const SYS_getpgid: ::c_long = 4000 + 132;\npub const SYS_fchdir: ::c_long = 4000 + 133;\npub const SYS_bdflush: ::c_long = 4000 + 134;\npub const SYS_sysfs: ::c_long = 4000 + 135;\npub const SYS_personality: ::c_long = 4000 + 136;\npub const SYS_afs_syscall: ::c_long = 4000 + 137;\npub const SYS_setfsuid: ::c_long = 4000 + 138;\npub const SYS_setfsgid: ::c_long = 4000 + 139;\npub const SYS__llseek: ::c_long = 4000 + 140;\npub const SYS_getdents: ::c_long = 4000 + 141;\npub const SYS_flock: ::c_long = 4000 + 143;\npub const SYS_msync: ::c_long = 4000 + 144;\npub const SYS_readv: ::c_long = 4000 + 145;\npub const SYS_writev: ::c_long = 4000 + 146;\npub const SYS_cacheflush: ::c_long = 4000 + 147;\npub const SYS_cachectl: ::c_long = 4000 + 148;\npub const SYS_sysmips: ::c_long = 4000 + 149;\npub const SYS_getsid: ::c_long = 4000 + 151;\npub const SYS_fdatasync: ::c_long = 4000 + 152;\npub const SYS__sysctl: ::c_long = 4000 + 153;\npub const SYS_mlock: ::c_long = 4000 + 154;\npub const SYS_munlock: ::c_long = 4000 + 155;\npub const SYS_mlockall: ::c_long = 4000 + 156;\npub const SYS_munlockall: ::c_long = 4000 + 157;\npub const SYS_sched_setparam: ::c_long = 4000 + 158;\npub const SYS_sched_getparam: ::c_long = 4000 + 159;\npub const SYS_sched_setscheduler: ::c_long = 4000 + 160;\npub const SYS_sched_getscheduler: ::c_long = 4000 + 161;\npub const SYS_sched_yield: ::c_long = 4000 + 162;\npub const SYS_sched_get_priority_max: ::c_long = 4000 + 163;\npub const SYS_sched_get_priority_min: ::c_long = 4000 + 164;\npub const SYS_sched_rr_get_interval: ::c_long = 4000 + 165;\npub const SYS_nanosleep: ::c_long = 4000 + 166;\npub const SYS_mremap: ::c_long = 4000 + 167;\npub const SYS_accept: ::c_long = 4000 + 168;\npub const SYS_bind: ::c_long = 4000 + 169;\npub const SYS_connect: ::c_long = 4000 + 170;\npub const SYS_getpeername: ::c_long = 4000 + 171;\npub const SYS_getsockname: ::c_long = 4000 + 172;\npub const SYS_getsockopt: ::c_long = 4000 + 173;\npub const SYS_listen: ::c_long = 4000 + 174;\npub const SYS_recv: ::c_long = 4000 + 175;\npub const SYS_recvfrom: ::c_long = 4000 + 176;\npub const SYS_recvmsg: ::c_long = 4000 + 177;\npub const SYS_send: ::c_long = 4000 + 178;\npub const SYS_sendmsg: ::c_long = 4000 + 179;\npub const SYS_sendto: ::c_long = 4000 + 180;\npub const SYS_setsockopt: ::c_long = 4000 + 181;\npub const SYS_shutdown: ::c_long = 4000 + 182;\npub const SYS_socket: ::c_long = 4000 + 183;\npub const SYS_socketpair: ::c_long = 4000 + 184;\npub const SYS_setresuid: ::c_long = 4000 + 185;\npub const SYS_getresuid: ::c_long = 4000 + 186;\npub const SYS_query_module: ::c_long = 4000 + 187;\npub const SYS_poll: ::c_long = 4000 + 188;\npub const SYS_nfsservctl: ::c_long = 4000 + 189;\npub const SYS_setresgid: ::c_long = 4000 + 190;\npub const SYS_getresgid: ::c_long = 4000 + 191;\npub const SYS_prctl: ::c_long = 4000 + 192;\npub const SYS_rt_sigreturn: ::c_long = 4000 + 193;\npub const SYS_rt_sigaction: ::c_long = 4000 + 194;\npub const SYS_rt_sigprocmask: ::c_long = 4000 + 195;\npub const SYS_rt_sigpending: ::c_long = 4000 + 196;\npub const SYS_rt_sigtimedwait: ::c_long = 4000 + 197;\npub const SYS_rt_sigqueueinfo: ::c_long = 4000 + 198;\npub const SYS_rt_sigsuspend: ::c_long = 4000 + 199;\npub const SYS_chown: ::c_long = 4000 + 202;\npub const SYS_getcwd: ::c_long = 4000 + 203;\npub const SYS_capget: ::c_long = 4000 + 204;\npub const SYS_capset: ::c_long = 4000 + 205;\npub const SYS_sigaltstack: ::c_long = 4000 + 206;\npub const SYS_sendfile: ::c_long = 4000 + 207;\npub const SYS_getpmsg: ::c_long = 4000 + 208;\npub const SYS_putpmsg: ::c_long = 4000 + 209;\npub const SYS_mmap2: ::c_long = 4000 + 210;\npub const SYS_truncate64: ::c_long = 4000 + 211;\npub const SYS_ftruncate64: ::c_long = 4000 + 212;\npub const SYS_stat64: ::c_long = 4000 + 213;\npub const SYS_lstat64: ::c_long = 4000 + 214;\npub const SYS_fstat64: ::c_long = 4000 + 215;\npub const SYS_pivot_root: ::c_long = 4000 + 216;\npub const SYS_mincore: ::c_long = 4000 + 217;\npub const SYS_madvise: ::c_long = 4000 + 218;\npub const SYS_getdents64: ::c_long = 4000 + 219;\npub const SYS_fcntl64: ::c_long = 4000 + 220;\npub const SYS_gettid: ::c_long = 4000 + 222;\npub const SYS_readahead: ::c_long = 4000 + 223;\npub const SYS_setxattr: ::c_long = 4000 + 224;\npub const SYS_lsetxattr: ::c_long = 4000 + 225;\npub const SYS_fsetxattr: ::c_long = 4000 + 226;\npub const SYS_getxattr: ::c_long = 4000 + 227;\npub const SYS_lgetxattr: ::c_long = 4000 + 228;\npub const SYS_fgetxattr: ::c_long = 4000 + 229;\npub const SYS_listxattr: ::c_long = 4000 + 230;\npub const SYS_llistxattr: ::c_long = 4000 + 231;\npub const SYS_flistxattr: ::c_long = 4000 + 232;\npub const SYS_removexattr: ::c_long = 4000 + 233;\npub const SYS_lremovexattr: ::c_long = 4000 + 234;\npub const SYS_fremovexattr: ::c_long = 4000 + 235;\npub const SYS_tkill: ::c_long = 4000 + 236;\npub const SYS_sendfile64: ::c_long = 4000 + 237;\npub const SYS_futex: ::c_long = 4000 + 238;\npub const SYS_sched_setaffinity: ::c_long = 4000 + 239;\npub const SYS_sched_getaffinity: ::c_long = 4000 + 240;\npub const SYS_io_setup: ::c_long = 4000 + 241;\npub const SYS_io_destroy: ::c_long = 4000 + 242;\npub const SYS_io_getevents: ::c_long = 4000 + 243;\npub const SYS_io_submit: ::c_long = 4000 + 244;\npub const SYS_io_cancel: ::c_long = 4000 + 245;\npub const SYS_exit_group: ::c_long = 4000 + 246;\npub const SYS_lookup_dcookie: ::c_long = 4000 + 247;\npub const SYS_epoll_create: ::c_long = 4000 + 248;\npub const SYS_epoll_ctl: ::c_long = 4000 + 249;\npub const SYS_epoll_wait: ::c_long = 4000 + 250;\npub const SYS_remap_file_pages: ::c_long = 4000 + 251;\npub const SYS_set_tid_address: ::c_long = 4000 + 252;\npub const SYS_restart_syscall: ::c_long = 4000 + 253;\npub const SYS_statfs64: ::c_long = 4000 + 255;\npub const SYS_fstatfs64: ::c_long = 4000 + 256;\npub const SYS_timer_create: ::c_long = 4000 + 257;\npub const SYS_timer_settime: ::c_long = 4000 + 258;\npub const SYS_timer_gettime: ::c_long = 4000 + 259;\npub const SYS_timer_getoverrun: ::c_long = 4000 + 260;\npub const SYS_timer_delete: ::c_long = 4000 + 261;\npub const SYS_clock_settime: ::c_long = 4000 + 262;\npub const SYS_clock_gettime: ::c_long = 4000 + 263;\npub const SYS_clock_getres: ::c_long = 4000 + 264;\npub const SYS_clock_nanosleep: ::c_long = 4000 + 265;\npub const SYS_tgkill: ::c_long = 4000 + 266;\npub const SYS_utimes: ::c_long = 4000 + 267;\npub const SYS_mbind: ::c_long = 4000 + 268;\npub const SYS_get_mempolicy: ::c_long = 4000 + 269;\npub const SYS_set_mempolicy: ::c_long = 4000 + 270;\npub const SYS_mq_open: ::c_long = 4000 + 271;\npub const SYS_mq_unlink: ::c_long = 4000 + 272;\npub const SYS_mq_timedsend: ::c_long = 4000 + 273;\npub const SYS_mq_timedreceive: ::c_long = 4000 + 274;\npub const SYS_mq_notify: ::c_long = 4000 + 275;\npub const SYS_mq_getsetattr: ::c_long = 4000 + 276;\npub const SYS_vserver: ::c_long = 4000 + 277;\npub const SYS_waitid: ::c_long = 4000 + 278;\n/* pub const SYS_sys_setaltroot: ::c_long = 4000 + 279; */\npub const SYS_add_key: ::c_long = 4000 + 280;\npub const SYS_request_key: ::c_long = 4000 + 281;\npub const SYS_keyctl: ::c_long = 4000 + 282;\npub const SYS_set_thread_area: ::c_long = 4000 + 283;\npub const SYS_inotify_init: ::c_long = 4000 + 284;\npub const SYS_inotify_add_watch: ::c_long = 4000 + 285;\npub const SYS_inotify_rm_watch: ::c_long = 4000 + 286;\npub const SYS_migrate_pages: ::c_long = 4000 + 287;\npub const SYS_openat: ::c_long = 4000 + 288;\npub const SYS_mkdirat: ::c_long = 4000 + 289;\npub const SYS_mknodat: ::c_long = 4000 + 290;\npub const SYS_fchownat: ::c_long = 4000 + 291;\npub const SYS_futimesat: ::c_long = 4000 + 292;\npub const SYS_unlinkat: ::c_long = 4000 + 294;\npub const SYS_renameat: ::c_long = 4000 + 295;\npub const SYS_linkat: ::c_long = 4000 + 296;\npub const SYS_symlinkat: ::c_long = 4000 + 297;\npub const SYS_readlinkat: ::c_long = 4000 + 298;\npub const SYS_fchmodat: ::c_long = 4000 + 299;\npub const SYS_faccessat: ::c_long = 4000 + 300;\npub const SYS_pselect6: ::c_long = 4000 + 301;\npub const SYS_ppoll: ::c_long = 4000 + 302;\npub const SYS_unshare: ::c_long = 4000 + 303;\npub const SYS_splice: ::c_long = 4000 + 304;\npub const SYS_sync_file_range: ::c_long = 4000 + 305;\npub const SYS_tee: ::c_long = 4000 + 306;\npub const SYS_vmsplice: ::c_long = 4000 + 307;\npub const SYS_move_pages: ::c_long = 4000 + 308;\npub const SYS_set_robust_list: ::c_long = 4000 + 309;\npub const SYS_get_robust_list: ::c_long = 4000 + 310;\npub const SYS_kexec_load: ::c_long = 4000 + 311;\npub const SYS_getcpu: ::c_long = 4000 + 312;\npub const SYS_epoll_pwait: ::c_long = 4000 + 313;\npub const SYS_ioprio_set: ::c_long = 4000 + 314;\npub const SYS_ioprio_get: ::c_long = 4000 + 315;\npub const SYS_utimensat: ::c_long = 4000 + 316;\npub const SYS_signalfd: ::c_long = 4000 + 317;\npub const SYS_timerfd: ::c_long = 4000 + 318;\npub const SYS_eventfd: ::c_long = 4000 + 319;\npub const SYS_fallocate: ::c_long = 4000 + 320;\npub const SYS_timerfd_create: ::c_long = 4000 + 321;\npub const SYS_timerfd_gettime: ::c_long = 4000 + 322;\npub const SYS_timerfd_settime: ::c_long = 4000 + 323;\npub const SYS_signalfd4: ::c_long = 4000 + 324;\npub const SYS_eventfd2: ::c_long = 4000 + 325;\npub const SYS_epoll_create1: ::c_long = 4000 + 326;\npub const SYS_dup3: ::c_long = 4000 + 327;\npub const SYS_pipe2: ::c_long = 4000 + 328;\npub const SYS_inotify_init1: ::c_long = 4000 + 329;\npub const SYS_preadv: ::c_long = 4000 + 330;\npub const SYS_pwritev: ::c_long = 4000 + 331;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 4000 + 332;\npub const SYS_perf_event_open: ::c_long = 4000 + 333;\npub const SYS_accept4: ::c_long = 4000 + 334;\npub const SYS_recvmmsg: ::c_long = 4000 + 335;\npub const SYS_fanotify_init: ::c_long = 4000 + 336;\npub const SYS_fanotify_mark: ::c_long = 4000 + 337;\npub const SYS_prlimit64: ::c_long = 4000 + 338;\npub const SYS_name_to_handle_at: ::c_long = 4000 + 339;\npub const SYS_open_by_handle_at: ::c_long = 4000 + 340;\npub const SYS_clock_adjtime: ::c_long = 4000 + 341;\npub const SYS_syncfs: ::c_long = 4000 + 342;\npub const SYS_sendmmsg: ::c_long = 4000 + 343;\npub const SYS_setns: ::c_long = 4000 + 344;\npub const SYS_process_vm_readv: ::c_long = 4000 + 345;\npub const SYS_process_vm_writev: ::c_long = 4000 + 346;\npub const SYS_kcmp: ::c_long = 4000 + 347;\npub const SYS_finit_module: ::c_long = 4000 + 348;\npub const SYS_sched_setattr: ::c_long = 4000 + 349;\npub const SYS_sched_getattr: ::c_long = 4000 + 350;\npub const SYS_renameat2: ::c_long = 4000 + 351;\npub const SYS_seccomp: ::c_long = 4000 + 352;\npub const SYS_getrandom: ::c_long = 4000 + 353;\npub const SYS_memfd_create: ::c_long = 4000 + 354;\npub const SYS_bpf: ::c_long = 4000 + 355;\npub const SYS_execveat: ::c_long = 4000 + 356;\npub const SYS_userfaultfd: ::c_long = 4000 + 357;\npub const SYS_membarrier: ::c_long = 4000 + 358;\npub const SYS_mlock2: ::c_long = 4000 + 359;\npub const SYS_copy_file_range: ::c_long = 4000 + 360;\npub const SYS_preadv2: ::c_long = 4000 + 361;\npub const SYS_pwritev2: ::c_long = 4000 + 362;\npub const SYS_pkey_mprotect: ::c_long = 4000 + 363;\npub const SYS_pkey_alloc: ::c_long = 4000 + 364;\npub const SYS_pkey_free: ::c_long = 4000 + 365;\npub const SYS_statx: ::c_long = 4000 + 366;\npub const SYS_pidfd_send_signal: ::c_long = 4000 + 424;\npub const SYS_io_uring_setup: ::c_long = 4000 + 425;\npub const SYS_io_uring_enter: ::c_long = 4000 + 426;\npub const SYS_io_uring_register: ::c_long = 4000 + 427;\npub const SYS_open_tree: ::c_long = 4000 + 428;\npub const SYS_move_mount: ::c_long = 4000 + 429;\npub const SYS_fsopen: ::c_long = 4000 + 430;\npub const SYS_fsconfig: ::c_long = 4000 + 431;\npub const SYS_fsmount: ::c_long = 4000 + 432;\npub const SYS_fspick: ::c_long = 4000 + 433;\npub const SYS_pidfd_open: ::c_long = 4000 + 434;\npub const SYS_clone3: ::c_long = 4000 + 435;\npub const SYS_close_range: ::c_long = 4000 + 436;\npub const SYS_openat2: ::c_long = 4000 + 437;\npub const SYS_pidfd_getfd: ::c_long = 4000 + 438;\npub const SYS_faccessat2: ::c_long = 4000 + 439;\npub const SYS_process_madvise: ::c_long = 4000 + 440;\npub const SYS_epoll_pwait2: ::c_long = 4000 + 441;\npub const SYS_mount_setattr: ::c_long = 4000 + 442;\n\ncfg_if! {\n    if #[cfg(libc_align)] {\n        mod align;\n        pub use self::align::*;\n    }\n}\n"],["1196","s_no_extra_traits! {\n    #[allow(missing_debug_implementations)]\n    #[repr(align(8))]\n    pub struct max_align_t {\n        priv_: [f32; 4]\n    }\n}\n"],["1197","s_no_extra_traits! {\n    #[allow(missing_debug_implementations)]\n    #[repr(align(8))]\n    pub struct max_align_t {\n        priv_: (i64, i64)\n    }\n}\n"],["1198","pub type c_char = u8;\npub type wchar_t = u32;\n\ns! {\n    pub struct stat {\n        pub st_dev: ::dev_t,\n        __st_dev_padding: ::c_int,\n        __st_ino_truncated: ::c_long,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        __st_rdev_padding: ::c_int,\n        pub st_size: ::off_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        pub st_ino: ::ino_t,\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::dev_t,\n        __st_dev_padding: ::c_int,\n        __st_ino_truncated: ::c_long,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        __st_rdev_padding: ::c_int,\n        pub st_size: ::off_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        pub st_ino: ::ino_t,\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_flags: ::c_int,\n        pub ss_size: ::size_t\n    }\n\n    pub struct ipc_perm {\n        pub __ipc_perm_key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::mode_t,\n        pub __seq: ::c_int,\n        __unused1: ::c_long,\n        __unused2: ::c_long\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        pub shm_segsz: ::size_t,\n        pub shm_atime: ::time_t,\n        __unused1: ::c_int,\n        pub shm_dtime: ::time_t,\n        __unused2: ::c_int,\n        pub shm_ctime: ::time_t,\n        __unused3: ::c_int,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::c_ulong,\n        __pad1: ::c_ulong,\n        __pad2: ::c_ulong,\n    }\n\n    pub struct msqid_ds {\n        pub msg_perm: ::ipc_perm,\n        pub msg_stime: ::time_t,\n        __unused1: ::c_int,\n        pub msg_rtime: ::time_t,\n        __unused2: ::c_int,\n        pub msg_ctime: ::time_t,\n        __unused3: ::c_int,\n        __msg_cbytes: ::c_ulong,\n        pub msg_qnum: ::msgqnum_t,\n        pub msg_qbytes: ::msglen_t,\n        pub msg_lspid: ::pid_t,\n        pub msg_lrpid: ::pid_t,\n        __pad1: ::c_ulong,\n        __pad2: ::c_ulong,\n    }\n\n    pub struct statfs {\n        pub f_type: ::c_ulong,\n        pub f_bsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_flags: ::c_ulong,\n        pub f_spare: [::c_ulong; 4],\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_errno: ::c_int,\n        pub si_code: ::c_int,\n        pub _pad: [::c_int; 29],\n        _align: [usize; 0],\n    }\n\n    pub struct statfs64 {\n        pub f_type: ::c_ulong,\n        pub f_bsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_flags: ::c_ulong,\n        pub f_spare: [::c_ulong; 4],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_favail: u64,\n        pub f_fsid: ::c_ulong,\n        __f_unused: ::c_int,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n}\n\npub const SIGSTKSZ: ::size_t = 8192;\npub const MINSIGSTKSZ: ::size_t = 2048;\n\npub const O_DIRECT: ::c_int = 0x10000;\npub const O_DIRECTORY: ::c_int = 0x4000;\npub const O_NOFOLLOW: ::c_int = 0x8000;\npub const O_ASYNC: ::c_int = 0x2000;\npub const O_LARGEFILE: ::c_int = 0o400000;\n\npub const FIOCLEX: ::c_int = 0x5451;\npub const FIONCLEX: ::c_int = 0x5450;\npub const FIONBIO: ::c_int = 0x5421;\n\npub const RLIMIT_RSS: ::c_int = 5;\npub const RLIMIT_NOFILE: ::c_int = 7;\npub const RLIMIT_AS: ::c_int = 9;\npub const RLIMIT_NPROC: ::c_int = 6;\npub const RLIMIT_MEMLOCK: ::c_int = 8;\npub const RLIMIT_NLIMITS: ::c_int = 15;\npub const RLIM_NLIMITS: ::c_int = RLIMIT_NLIMITS;\n\npub const MADV_SOFT_OFFLINE: ::c_int = 101;\npub const MCL_CURRENT: ::c_int = 0x0001;\npub const MCL_FUTURE: ::c_int = 0x0002;\npub const CBAUD: ::tcflag_t = 0o0010017;\npub const TAB1: ::c_int = 0x00000800;\npub const TAB2: ::c_int = 0x00001000;\npub const TAB3: ::c_int = 0x00001800;\npub const CR1: ::c_int = 0x00000200;\npub const CR2: ::c_int = 0x00000400;\npub const CR3: ::c_int = 0x00000600;\npub const FF1: ::c_int = 0x00008000;\npub const BS1: ::c_int = 0x00002000;\npub const VT1: ::c_int = 0x00004000;\npub const VWERASE: usize = 14;\npub const VREPRINT: usize = 12;\npub const VSUSP: usize = 10;\npub const VSTART: usize = 8;\npub const VSTOP: usize = 9;\npub const VDISCARD: usize = 13;\npub const VTIME: usize = 5;\npub const IXON: ::tcflag_t = 0x00000400;\npub const IXOFF: ::tcflag_t = 0x00001000;\npub const ONLCR: ::tcflag_t = 0x4;\npub const CSIZE: ::tcflag_t = 0x00000030;\npub const CS6: ::tcflag_t = 0x00000010;\npub const CS7: ::tcflag_t = 0x00000020;\npub const CS8: ::tcflag_t = 0x00000030;\npub const CSTOPB: ::tcflag_t = 0x00000040;\npub const CREAD: ::tcflag_t = 0x00000080;\npub const PARENB: ::tcflag_t = 0x00000100;\npub const PARODD: ::tcflag_t = 0x00000200;\npub const HUPCL: ::tcflag_t = 0x00000400;\npub const CLOCAL: ::tcflag_t = 0x00000800;\npub const ECHOKE: ::tcflag_t = 0x00000800;\npub const ECHOE: ::tcflag_t = 0x00000010;\npub const ECHOK: ::tcflag_t = 0x00000020;\npub const ECHONL: ::tcflag_t = 0x00000040;\npub const ECHOPRT: ::tcflag_t = 0x00000400;\npub const ECHOCTL: ::tcflag_t = 0x00000200;\npub const ISIG: ::tcflag_t = 0x00000001;\npub const ICANON: ::tcflag_t = 0x00000002;\npub const PENDIN: ::tcflag_t = 0x00004000;\npub const NOFLSH: ::tcflag_t = 0x00000080;\npub const CIBAUD: ::tcflag_t = 0o02003600000;\npub const CBAUDEX: ::tcflag_t = 0o010000;\npub const VSWTC: usize = 7;\npub const OLCUC: ::tcflag_t = 0o000002;\npub const NLDLY: ::tcflag_t = 0o000400;\npub const CRDLY: ::tcflag_t = 0o003000;\npub const TABDLY: ::tcflag_t = 0o014000;\npub const BSDLY: ::tcflag_t = 0o020000;\npub const FFDLY: ::tcflag_t = 0o100000;\npub const VTDLY: ::tcflag_t = 0o040000;\npub const XTABS: ::tcflag_t = 0o014000;\npub const B57600: ::speed_t = 0o010001;\npub const B115200: ::speed_t = 0o010002;\npub const B230400: ::speed_t = 0o010003;\npub const B460800: ::speed_t = 0o010004;\npub const B500000: ::speed_t = 0o010005;\npub const B576000: ::speed_t = 0o010006;\npub const B921600: ::speed_t = 0o010007;\npub const B1000000: ::speed_t = 0o010010;\npub const B1152000: ::speed_t = 0o010011;\npub const B1500000: ::speed_t = 0o010012;\npub const B2000000: ::speed_t = 0o010013;\npub const B2500000: ::speed_t = 0o010014;\npub const B3000000: ::speed_t = 0o010015;\npub const B3500000: ::speed_t = 0o010016;\npub const B4000000: ::speed_t = 0o010017;\n\npub const O_APPEND: ::c_int = 1024;\npub const O_CREAT: ::c_int = 64;\npub const O_EXCL: ::c_int = 128;\npub const O_NOCTTY: ::c_int = 256;\npub const O_NONBLOCK: ::c_int = 2048;\npub const O_SYNC: ::c_int = 1052672;\npub const O_RSYNC: ::c_int = 1052672;\npub const O_DSYNC: ::c_int = 4096;\n\npub const SOCK_NONBLOCK: ::c_int = 2048;\n\npub const MAP_ANON: ::c_int = 0x0020;\npub const MAP_GROWSDOWN: ::c_int = 0x0100;\npub const MAP_DENYWRITE: ::c_int = 0x0800;\npub const MAP_EXECUTABLE: ::c_int = 0x01000;\npub const MAP_LOCKED: ::c_int = 0x02000;\npub const MAP_NORESERVE: ::c_int = 0x04000;\npub const MAP_POPULATE: ::c_int = 0x08000;\npub const MAP_NONBLOCK: ::c_int = 0x010000;\npub const MAP_STACK: ::c_int = 0x020000;\npub const MAP_SYNC: ::c_int = 0x080000;\n\npub const SOCK_STREAM: ::c_int = 1;\npub const SOCK_DGRAM: ::c_int = 2;\npub const SOCK_SEQPACKET: ::c_int = 5;\n\npub const EDEADLK: ::c_int = 35;\npub const ENAMETOOLONG: ::c_int = 36;\npub const ENOLCK: ::c_int = 37;\npub const ENOSYS: ::c_int = 38;\npub const ENOTEMPTY: ::c_int = 39;\npub const ELOOP: ::c_int = 40;\npub const ENOMSG: ::c_int = 42;\npub const EIDRM: ::c_int = 43;\npub const ECHRNG: ::c_int = 44;\npub const EL2NSYNC: ::c_int = 45;\npub const EL3HLT: ::c_int = 46;\npub const EL3RST: ::c_int = 47;\npub const ELNRNG: ::c_int = 48;\npub const EUNATCH: ::c_int = 49;\npub const ENOCSI: ::c_int = 50;\npub const EL2HLT: ::c_int = 51;\npub const EBADE: ::c_int = 52;\npub const EBADR: ::c_int = 53;\npub const EXFULL: ::c_int = 54;\npub const ENOANO: ::c_int = 55;\npub const EBADRQC: ::c_int = 56;\npub const EBADSLT: ::c_int = 57;\npub const EDEADLOCK: ::c_int = EDEADLK;\npub const EMULTIHOP: ::c_int = 72;\npub const EBADMSG: ::c_int = 74;\npub const EOVERFLOW: ::c_int = 75;\npub const ENOTUNIQ: ::c_int = 76;\npub const EBADFD: ::c_int = 77;\npub const EREMCHG: ::c_int = 78;\npub const ELIBACC: ::c_int = 79;\npub const ELIBBAD: ::c_int = 80;\npub const ELIBSCN: ::c_int = 81;\npub const ELIBMAX: ::c_int = 82;\npub const ELIBEXEC: ::c_int = 83;\npub const EILSEQ: ::c_int = 84;\npub const ERESTART: ::c_int = 85;\npub const ESTRPIPE: ::c_int = 86;\npub const EUSERS: ::c_int = 87;\npub const ENOTSOCK: ::c_int = 88;\npub const EDESTADDRREQ: ::c_int = 89;\npub const EMSGSIZE: ::c_int = 90;\npub const EPROTOTYPE: ::c_int = 91;\npub const ENOPROTOOPT: ::c_int = 92;\npub const EPROTONOSUPPORT: ::c_int = 93;\npub const ESOCKTNOSUPPORT: ::c_int = 94;\npub const EOPNOTSUPP: ::c_int = 95;\npub const ENOTSUP: ::c_int = EOPNOTSUPP;\npub const EPFNOSUPPORT: ::c_int = 96;\npub const EAFNOSUPPORT: ::c_int = 97;\npub const EADDRINUSE: ::c_int = 98;\npub const EADDRNOTAVAIL: ::c_int = 99;\npub const ENETDOWN: ::c_int = 100;\npub const ENETUNREACH: ::c_int = 101;\npub const ENETRESET: ::c_int = 102;\npub const ECONNABORTED: ::c_int = 103;\npub const ECONNRESET: ::c_int = 104;\npub const ENOBUFS: ::c_int = 105;\npub const EISCONN: ::c_int = 106;\npub const ENOTCONN: ::c_int = 107;\npub const ESHUTDOWN: ::c_int = 108;\npub const ETOOMANYREFS: ::c_int = 109;\npub const ETIMEDOUT: ::c_int = 110;\npub const ECONNREFUSED: ::c_int = 111;\npub const EHOSTDOWN: ::c_int = 112;\npub const EHOSTUNREACH: ::c_int = 113;\npub const EALREADY: ::c_int = 114;\npub const EINPROGRESS: ::c_int = 115;\npub const ESTALE: ::c_int = 116;\npub const EUCLEAN: ::c_int = 117;\npub const ENOTNAM: ::c_int = 118;\npub const ENAVAIL: ::c_int = 119;\npub const EISNAM: ::c_int = 120;\npub const EREMOTEIO: ::c_int = 121;\npub const EDQUOT: ::c_int = 122;\npub const ENOMEDIUM: ::c_int = 123;\npub const EMEDIUMTYPE: ::c_int = 124;\npub const ECANCELED: ::c_int = 125;\npub const ENOKEY: ::c_int = 126;\npub const EKEYEXPIRED: ::c_int = 127;\npub const EKEYREVOKED: ::c_int = 128;\npub const EKEYREJECTED: ::c_int = 129;\npub const EOWNERDEAD: ::c_int = 130;\npub const ENOTRECOVERABLE: ::c_int = 131;\npub const ERFKILL: ::c_int = 132;\npub const EHWPOISON: ::c_int = 133;\n\npub const SA_ONSTACK: ::c_int = 0x08000000;\npub const SA_SIGINFO: ::c_int = 0x00000004;\npub const SA_NOCLDWAIT: ::c_int = 0x00000002;\n\npub const SIGCHLD: ::c_int = 17;\npub const SIGBUS: ::c_int = 7;\npub const SIGTTIN: ::c_int = 21;\npub const SIGTTOU: ::c_int = 22;\npub const SIGXCPU: ::c_int = 24;\npub const SIGXFSZ: ::c_int = 25;\npub const SIGVTALRM: ::c_int = 26;\npub const SIGPROF: ::c_int = 27;\npub const SIGWINCH: ::c_int = 28;\npub const SIGUSR1: ::c_int = 10;\npub const SIGUSR2: ::c_int = 12;\npub const SIGCONT: ::c_int = 18;\npub const SIGSTOP: ::c_int = 19;\npub const SIGTSTP: ::c_int = 20;\npub const SIGURG: ::c_int = 23;\npub const SIGIO: ::c_int = 29;\npub const SIGSYS: ::c_int = 31;\npub const SIGSTKFLT: ::c_int = 16;\npub const SIGPOLL: ::c_int = 29;\npub const SIGPWR: ::c_int = 30;\npub const SIG_SETMASK: ::c_int = 2;\npub const SIG_BLOCK: ::c_int = 0x000000;\npub const SIG_UNBLOCK: ::c_int = 0x01;\n\npub const EXTPROC: ::tcflag_t = 0x00010000;\n\npub const MAP_HUGETLB: ::c_int = 0x040000;\n\npub const F_GETLK: ::c_int = 12;\npub const F_GETOWN: ::c_int = 9;\npub const F_SETLK: ::c_int = 13;\npub const F_SETLKW: ::c_int = 14;\npub const F_SETOWN: ::c_int = 8;\npub const F_OFD_GETLK: ::c_int = 36;\npub const F_OFD_SETLK: ::c_int = 37;\npub const F_OFD_SETLKW: ::c_int = 38;\n\npub const VEOF: usize = 4;\npub const VEOL: usize = 11;\npub const VEOL2: usize = 16;\npub const VMIN: usize = 6;\npub const IEXTEN: ::tcflag_t = 0x00008000;\npub const TOSTOP: ::tcflag_t = 0x00000100;\npub const FLUSHO: ::tcflag_t = 0x00001000;\n\npub const TCGETS: ::c_int = 0x5401;\npub const TCSETS: ::c_int = 0x5402;\npub const TCSETSW: ::c_int = 0x5403;\npub const TCSETSF: ::c_int = 0x5404;\npub const TCGETA: ::c_int = 0x5405;\npub const TCSETA: ::c_int = 0x5406;\npub const TCSETAW: ::c_int = 0x5407;\npub const TCSETAF: ::c_int = 0x5408;\npub const TCSBRK: ::c_int = 0x5409;\npub const TCXONC: ::c_int = 0x540A;\npub const TCFLSH: ::c_int = 0x540B;\npub const TIOCGSOFTCAR: ::c_int = 0x5419;\npub const TIOCSSOFTCAR: ::c_int = 0x541A;\npub const TIOCLINUX: ::c_int = 0x541C;\npub const TIOCGSERIAL: ::c_int = 0x541E;\npub const TIOCEXCL: ::c_int = 0x540C;\npub const TIOCNXCL: ::c_int = 0x540D;\npub const TIOCSCTTY: ::c_int = 0x540E;\npub const TIOCGPGRP: ::c_int = 0x540F;\npub const TIOCSPGRP: ::c_int = 0x5410;\npub const TIOCOUTQ: ::c_int = 0x5411;\npub const TIOCSTI: ::c_int = 0x5412;\npub const TIOCGWINSZ: ::c_int = 0x5413;\npub const TIOCSWINSZ: ::c_int = 0x5414;\npub const TIOCMGET: ::c_int = 0x5415;\npub const TIOCMBIS: ::c_int = 0x5416;\npub const TIOCMBIC: ::c_int = 0x5417;\npub const TIOCMSET: ::c_int = 0x5418;\npub const FIONREAD: ::c_int = 0x541B;\npub const TIOCCONS: ::c_int = 0x541D;\n\npub const TIOCGRS485: ::c_int = 0x542E;\npub const TIOCSRS485: ::c_int = 0x542F;\n\npub const POLLWRNORM: ::c_short = 0x100;\npub const POLLWRBAND: ::c_short = 0x200;\n\npub const TIOCM_LE: ::c_int = 0x001;\npub const TIOCM_DTR: ::c_int = 0x002;\npub const TIOCM_RTS: ::c_int = 0x004;\npub const TIOCM_ST: ::c_int = 0x008;\npub const TIOCM_SR: ::c_int = 0x010;\npub const TIOCM_CTS: ::c_int = 0x020;\npub const TIOCM_CAR: ::c_int = 0x040;\npub const TIOCM_RNG: ::c_int = 0x080;\npub const TIOCM_DSR: ::c_int = 0x100;\npub const TIOCM_CD: ::c_int = TIOCM_CAR;\npub const TIOCM_RI: ::c_int = TIOCM_RNG;\n\n// Syscall table\npub const SYS_restart_syscall: ::c_long = 0;\npub const SYS_exit: ::c_long = 1;\npub const SYS_fork: ::c_long = 2;\npub const SYS_read: ::c_long = 3;\npub const SYS_write: ::c_long = 4;\npub const SYS_open: ::c_long = 5;\npub const SYS_close: ::c_long = 6;\npub const SYS_creat: ::c_long = 8;\npub const SYS_link: ::c_long = 9;\npub const SYS_unlink: ::c_long = 10;\npub const SYS_execve: ::c_long = 11;\npub const SYS_chdir: ::c_long = 12;\npub const SYS_mknod: ::c_long = 14;\npub const SYS_chmod: ::c_long = 15;\npub const SYS_lchown: ::c_long = 16;\npub const SYS_lseek: ::c_long = 19;\npub const SYS_getpid: ::c_long = 20;\npub const SYS_mount: ::c_long = 21;\npub const SYS_setuid: ::c_long = 23;\npub const SYS_getuid: ::c_long = 24;\npub const SYS_ptrace: ::c_long = 26;\npub const SYS_pause: ::c_long = 29;\npub const SYS_access: ::c_long = 33;\npub const SYS_nice: ::c_long = 34;\npub const SYS_sync: ::c_long = 36;\npub const SYS_kill: ::c_long = 37;\npub const SYS_rename: ::c_long = 38;\npub const SYS_mkdir: ::c_long = 39;\npub const SYS_rmdir: ::c_long = 40;\npub const SYS_dup: ::c_long = 41;\npub const SYS_pipe: ::c_long = 42;\npub const SYS_times: ::c_long = 43;\npub const SYS_brk: ::c_long = 45;\npub const SYS_setgid: ::c_long = 46;\npub const SYS_getgid: ::c_long = 47;\npub const SYS_geteuid: ::c_long = 49;\npub const SYS_getegid: ::c_long = 50;\npub const SYS_acct: ::c_long = 51;\npub const SYS_umount2: ::c_long = 52;\npub const SYS_ioctl: ::c_long = 54;\npub const SYS_fcntl: ::c_long = 55;\npub const SYS_setpgid: ::c_long = 57;\npub const SYS_umask: ::c_long = 60;\npub const SYS_chroot: ::c_long = 61;\npub const SYS_ustat: ::c_long = 62;\npub const SYS_dup2: ::c_long = 63;\npub const SYS_getppid: ::c_long = 64;\npub const SYS_getpgrp: ::c_long = 65;\npub const SYS_setsid: ::c_long = 66;\npub const SYS_sigaction: ::c_long = 67;\npub const SYS_setreuid: ::c_long = 70;\npub const SYS_setregid: ::c_long = 71;\npub const SYS_sigsuspend: ::c_long = 72;\npub const SYS_sigpending: ::c_long = 73;\npub const SYS_sethostname: ::c_long = 74;\npub const SYS_setrlimit: ::c_long = 75;\npub const SYS_getrusage: ::c_long = 77;\npub const SYS_gettimeofday: ::c_long = 78;\npub const SYS_settimeofday: ::c_long = 79;\npub const SYS_getgroups: ::c_long = 80;\npub const SYS_setgroups: ::c_long = 81;\npub const SYS_symlink: ::c_long = 83;\npub const SYS_readlink: ::c_long = 85;\npub const SYS_uselib: ::c_long = 86;\npub const SYS_swapon: ::c_long = 87;\npub const SYS_reboot: ::c_long = 88;\npub const SYS_munmap: ::c_long = 91;\npub const SYS_truncate: ::c_long = 92;\npub const SYS_ftruncate: ::c_long = 93;\npub const SYS_fchmod: ::c_long = 94;\npub const SYS_fchown: ::c_long = 95;\npub const SYS_getpriority: ::c_long = 96;\npub const SYS_setpriority: ::c_long = 97;\npub const SYS_statfs: ::c_long = 99;\npub const SYS_fstatfs: ::c_long = 100;\npub const SYS_syslog: ::c_long = 103;\npub const SYS_setitimer: ::c_long = 104;\npub const SYS_getitimer: ::c_long = 105;\npub const SYS_stat: ::c_long = 106;\npub const SYS_lstat: ::c_long = 107;\npub const SYS_fstat: ::c_long = 108;\npub const SYS_vhangup: ::c_long = 111;\npub const SYS_wait4: ::c_long = 114;\npub const SYS_swapoff: ::c_long = 115;\npub const SYS_sysinfo: ::c_long = 116;\npub const SYS_fsync: ::c_long = 118;\npub const SYS_sigreturn: ::c_long = 119;\npub const SYS_clone: ::c_long = 120;\npub const SYS_setdomainname: ::c_long = 121;\npub const SYS_uname: ::c_long = 122;\npub const SYS_adjtimex: ::c_long = 124;\npub const SYS_mprotect: ::c_long = 125;\npub const SYS_sigprocmask: ::c_long = 126;\npub const SYS_init_module: ::c_long = 128;\npub const SYS_delete_module: ::c_long = 129;\npub const SYS_quotactl: ::c_long = 131;\npub const SYS_getpgid: ::c_long = 132;\npub const SYS_fchdir: ::c_long = 133;\npub const SYS_bdflush: ::c_long = 134;\npub const SYS_sysfs: ::c_long = 135;\npub const SYS_personality: ::c_long = 136;\npub const SYS_setfsuid: ::c_long = 138;\npub const SYS_setfsgid: ::c_long = 139;\npub const SYS__llseek: ::c_long = 140;\npub const SYS_getdents: ::c_long = 141;\npub const SYS__newselect: ::c_long = 142;\npub const SYS_flock: ::c_long = 143;\npub const SYS_msync: ::c_long = 144;\npub const SYS_readv: ::c_long = 145;\npub const SYS_writev: ::c_long = 146;\npub const SYS_getsid: ::c_long = 147;\npub const SYS_fdatasync: ::c_long = 148;\npub const SYS__sysctl: ::c_long = 149;\npub const SYS_mlock: ::c_long = 150;\npub const SYS_munlock: ::c_long = 151;\npub const SYS_mlockall: ::c_long = 152;\npub const SYS_munlockall: ::c_long = 153;\npub const SYS_sched_setparam: ::c_long = 154;\npub const SYS_sched_getparam: ::c_long = 155;\npub const SYS_sched_setscheduler: ::c_long = 156;\npub const SYS_sched_getscheduler: ::c_long = 157;\npub const SYS_sched_yield: ::c_long = 158;\npub const SYS_sched_get_priority_max: ::c_long = 159;\npub const SYS_sched_get_priority_min: ::c_long = 160;\npub const SYS_sched_rr_get_interval: ::c_long = 161;\npub const SYS_nanosleep: ::c_long = 162;\npub const SYS_mremap: ::c_long = 163;\npub const SYS_setresuid: ::c_long = 164;\npub const SYS_getresuid: ::c_long = 165;\npub const SYS_poll: ::c_long = 168;\npub const SYS_nfsservctl: ::c_long = 169;\npub const SYS_setresgid: ::c_long = 170;\npub const SYS_getresgid: ::c_long = 171;\npub const SYS_prctl: ::c_long = 172;\npub const SYS_rt_sigreturn: ::c_long = 173;\npub const SYS_rt_sigaction: ::c_long = 174;\npub const SYS_rt_sigprocmask: ::c_long = 175;\npub const SYS_rt_sigpending: ::c_long = 176;\npub const SYS_rt_sigtimedwait: ::c_long = 177;\npub const SYS_rt_sigqueueinfo: ::c_long = 178;\npub const SYS_rt_sigsuspend: ::c_long = 179;\npub const SYS_pread64: ::c_long = 180;\npub const SYS_pwrite64: ::c_long = 181;\npub const SYS_chown: ::c_long = 182;\npub const SYS_getcwd: ::c_long = 183;\npub const SYS_capget: ::c_long = 184;\npub const SYS_capset: ::c_long = 185;\npub const SYS_sigaltstack: ::c_long = 186;\npub const SYS_sendfile: ::c_long = 187;\npub const SYS_vfork: ::c_long = 190;\npub const SYS_ugetrlimit: ::c_long = 191;\npub const SYS_mmap2: ::c_long = 192;\npub const SYS_truncate64: ::c_long = 193;\npub const SYS_ftruncate64: ::c_long = 194;\npub const SYS_stat64: ::c_long = 195;\npub const SYS_lstat64: ::c_long = 196;\npub const SYS_fstat64: ::c_long = 197;\npub const SYS_lchown32: ::c_long = 198;\npub const SYS_getuid32: ::c_long = 199;\npub const SYS_getgid32: ::c_long = 200;\npub const SYS_geteuid32: ::c_long = 201;\npub const SYS_getegid32: ::c_long = 202;\npub const SYS_setreuid32: ::c_long = 203;\npub const SYS_setregid32: ::c_long = 204;\npub const SYS_getgroups32: ::c_long = 205;\npub const SYS_setgroups32: ::c_long = 206;\npub const SYS_fchown32: ::c_long = 207;\npub const SYS_setresuid32: ::c_long = 208;\npub const SYS_getresuid32: ::c_long = 209;\npub const SYS_setresgid32: ::c_long = 210;\npub const SYS_getresgid32: ::c_long = 211;\npub const SYS_chown32: ::c_long = 212;\npub const SYS_setuid32: ::c_long = 213;\npub const SYS_setgid32: ::c_long = 214;\npub const SYS_setfsuid32: ::c_long = 215;\npub const SYS_setfsgid32: ::c_long = 216;\npub const SYS_getdents64: ::c_long = 217;\npub const SYS_pivot_root: ::c_long = 218;\npub const SYS_mincore: ::c_long = 219;\npub const SYS_madvise: ::c_long = 220;\npub const SYS_fcntl64: ::c_long = 221;\npub const SYS_gettid: ::c_long = 224;\npub const SYS_readahead: ::c_long = 225;\npub const SYS_setxattr: ::c_long = 226;\npub const SYS_lsetxattr: ::c_long = 227;\npub const SYS_fsetxattr: ::c_long = 228;\npub const SYS_getxattr: ::c_long = 229;\npub const SYS_lgetxattr: ::c_long = 230;\npub const SYS_fgetxattr: ::c_long = 231;\npub const SYS_listxattr: ::c_long = 232;\npub const SYS_llistxattr: ::c_long = 233;\npub const SYS_flistxattr: ::c_long = 234;\npub const SYS_removexattr: ::c_long = 235;\npub const SYS_lremovexattr: ::c_long = 236;\npub const SYS_fremovexattr: ::c_long = 237;\npub const SYS_tkill: ::c_long = 238;\npub const SYS_sendfile64: ::c_long = 239;\npub const SYS_futex: ::c_long = 240;\npub const SYS_sched_setaffinity: ::c_long = 241;\npub const SYS_sched_getaffinity: ::c_long = 242;\npub const SYS_io_setup: ::c_long = 243;\npub const SYS_io_destroy: ::c_long = 244;\npub const SYS_io_getevents: ::c_long = 245;\npub const SYS_io_submit: ::c_long = 246;\npub const SYS_io_cancel: ::c_long = 247;\npub const SYS_exit_group: ::c_long = 248;\npub const SYS_lookup_dcookie: ::c_long = 249;\npub const SYS_epoll_create: ::c_long = 250;\npub const SYS_epoll_ctl: ::c_long = 251;\npub const SYS_epoll_wait: ::c_long = 252;\npub const SYS_remap_file_pages: ::c_long = 253;\npub const SYS_set_tid_address: ::c_long = 256;\npub const SYS_timer_create: ::c_long = 257;\npub const SYS_timer_settime: ::c_long = 258;\npub const SYS_timer_gettime: ::c_long = 259;\npub const SYS_timer_getoverrun: ::c_long = 260;\npub const SYS_timer_delete: ::c_long = 261;\npub const SYS_clock_settime: ::c_long = 262;\npub const SYS_clock_gettime: ::c_long = 263;\npub const SYS_clock_getres: ::c_long = 264;\npub const SYS_clock_nanosleep: ::c_long = 265;\npub const SYS_statfs64: ::c_long = 266;\npub const SYS_fstatfs64: ::c_long = 267;\npub const SYS_tgkill: ::c_long = 268;\npub const SYS_utimes: ::c_long = 269;\npub const SYS_pciconfig_iobase: ::c_long = 271;\npub const SYS_pciconfig_read: ::c_long = 272;\npub const SYS_pciconfig_write: ::c_long = 273;\npub const SYS_mq_open: ::c_long = 274;\npub const SYS_mq_unlink: ::c_long = 275;\npub const SYS_mq_timedsend: ::c_long = 276;\npub const SYS_mq_timedreceive: ::c_long = 277;\npub const SYS_mq_notify: ::c_long = 278;\npub const SYS_mq_getsetattr: ::c_long = 279;\npub const SYS_waitid: ::c_long = 280;\npub const SYS_socket: ::c_long = 281;\npub const SYS_bind: ::c_long = 282;\npub const SYS_connect: ::c_long = 283;\npub const SYS_listen: ::c_long = 284;\npub const SYS_accept: ::c_long = 285;\npub const SYS_getsockname: ::c_long = 286;\npub const SYS_getpeername: ::c_long = 287;\npub const SYS_socketpair: ::c_long = 288;\npub const SYS_send: ::c_long = 289;\npub const SYS_sendto: ::c_long = 290;\npub const SYS_recv: ::c_long = 291;\npub const SYS_recvfrom: ::c_long = 292;\npub const SYS_shutdown: ::c_long = 293;\npub const SYS_setsockopt: ::c_long = 294;\npub const SYS_getsockopt: ::c_long = 295;\npub const SYS_sendmsg: ::c_long = 296;\npub const SYS_recvmsg: ::c_long = 297;\npub const SYS_semop: ::c_long = 298;\npub const SYS_semget: ::c_long = 299;\npub const SYS_semctl: ::c_long = 300;\npub const SYS_msgsnd: ::c_long = 301;\npub const SYS_msgrcv: ::c_long = 302;\npub const SYS_msgget: ::c_long = 303;\npub const SYS_msgctl: ::c_long = 304;\npub const SYS_shmat: ::c_long = 305;\npub const SYS_shmdt: ::c_long = 306;\npub const SYS_shmget: ::c_long = 307;\npub const SYS_shmctl: ::c_long = 308;\npub const SYS_add_key: ::c_long = 309;\npub const SYS_request_key: ::c_long = 310;\npub const SYS_keyctl: ::c_long = 311;\npub const SYS_semtimedop: ::c_long = 312;\npub const SYS_vserver: ::c_long = 313;\npub const SYS_ioprio_set: ::c_long = 314;\npub const SYS_ioprio_get: ::c_long = 315;\npub const SYS_inotify_init: ::c_long = 316;\npub const SYS_inotify_add_watch: ::c_long = 317;\npub const SYS_inotify_rm_watch: ::c_long = 318;\npub const SYS_mbind: ::c_long = 319;\npub const SYS_get_mempolicy: ::c_long = 320;\npub const SYS_set_mempolicy: ::c_long = 321;\npub const SYS_openat: ::c_long = 322;\npub const SYS_mkdirat: ::c_long = 323;\npub const SYS_mknodat: ::c_long = 324;\npub const SYS_fchownat: ::c_long = 325;\npub const SYS_futimesat: ::c_long = 326;\npub const SYS_fstatat64: ::c_long = 327;\npub const SYS_unlinkat: ::c_long = 328;\npub const SYS_renameat: ::c_long = 329;\npub const SYS_linkat: ::c_long = 330;\npub const SYS_symlinkat: ::c_long = 331;\npub const SYS_readlinkat: ::c_long = 332;\npub const SYS_fchmodat: ::c_long = 333;\npub const SYS_faccessat: ::c_long = 334;\npub const SYS_pselect6: ::c_long = 335;\npub const SYS_ppoll: ::c_long = 336;\npub const SYS_unshare: ::c_long = 337;\npub const SYS_set_robust_list: ::c_long = 338;\npub const SYS_get_robust_list: ::c_long = 339;\npub const SYS_splice: ::c_long = 340;\npub const SYS_tee: ::c_long = 342;\npub const SYS_vmsplice: ::c_long = 343;\npub const SYS_move_pages: ::c_long = 344;\npub const SYS_getcpu: ::c_long = 345;\npub const SYS_epoll_pwait: ::c_long = 346;\npub const SYS_kexec_load: ::c_long = 347;\npub const SYS_utimensat: ::c_long = 348;\npub const SYS_signalfd: ::c_long = 349;\npub const SYS_timerfd_create: ::c_long = 350;\npub const SYS_eventfd: ::c_long = 351;\npub const SYS_fallocate: ::c_long = 352;\npub const SYS_timerfd_settime: ::c_long = 353;\npub const SYS_timerfd_gettime: ::c_long = 354;\npub const SYS_signalfd4: ::c_long = 355;\npub const SYS_eventfd2: ::c_long = 356;\npub const SYS_epoll_create1: ::c_long = 357;\npub const SYS_dup3: ::c_long = 358;\npub const SYS_pipe2: ::c_long = 359;\npub const SYS_inotify_init1: ::c_long = 360;\npub const SYS_preadv: ::c_long = 361;\npub const SYS_pwritev: ::c_long = 362;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 363;\npub const SYS_perf_event_open: ::c_long = 364;\npub const SYS_recvmmsg: ::c_long = 365;\npub const SYS_accept4: ::c_long = 366;\npub const SYS_fanotify_init: ::c_long = 367;\npub const SYS_fanotify_mark: ::c_long = 368;\npub const SYS_prlimit64: ::c_long = 369;\npub const SYS_name_to_handle_at: ::c_long = 370;\npub const SYS_open_by_handle_at: ::c_long = 371;\npub const SYS_clock_adjtime: ::c_long = 372;\npub const SYS_syncfs: ::c_long = 373;\npub const SYS_sendmmsg: ::c_long = 374;\npub const SYS_setns: ::c_long = 375;\npub const SYS_process_vm_readv: ::c_long = 376;\npub const SYS_process_vm_writev: ::c_long = 377;\npub const SYS_kcmp: ::c_long = 378;\npub const SYS_finit_module: ::c_long = 379;\npub const SYS_sched_setattr: ::c_long = 380;\npub const SYS_sched_getattr: ::c_long = 381;\npub const SYS_renameat2: ::c_long = 382;\npub const SYS_seccomp: ::c_long = 383;\npub const SYS_getrandom: ::c_long = 384;\npub const SYS_memfd_create: ::c_long = 385;\npub const SYS_bpf: ::c_long = 386;\npub const SYS_execveat: ::c_long = 387;\npub const SYS_userfaultfd: ::c_long = 388;\npub const SYS_membarrier: ::c_long = 389;\npub const SYS_mlock2: ::c_long = 390;\npub const SYS_copy_file_range: ::c_long = 391;\npub const SYS_preadv2: ::c_long = 392;\npub const SYS_pwritev2: ::c_long = 393;\npub const SYS_pkey_mprotect: ::c_long = 394;\npub const SYS_pkey_alloc: ::c_long = 395;\npub const SYS_pkey_free: ::c_long = 396;\npub const SYS_statx: ::c_long = 397;\npub const SYS_pidfd_send_signal: ::c_long = 424;\npub const SYS_io_uring_setup: ::c_long = 425;\npub const SYS_io_uring_enter: ::c_long = 426;\npub const SYS_io_uring_register: ::c_long = 427;\npub const SYS_open_tree: ::c_long = 428;\npub const SYS_move_mount: ::c_long = 429;\npub const SYS_fsopen: ::c_long = 430;\npub const SYS_fsconfig: ::c_long = 431;\npub const SYS_fsmount: ::c_long = 432;\npub const SYS_fspick: ::c_long = 433;\npub const SYS_pidfd_open: ::c_long = 434;\npub const SYS_clone3: ::c_long = 435;\npub const SYS_close_range: ::c_long = 436;\npub const SYS_openat2: ::c_long = 437;\npub const SYS_pidfd_getfd: ::c_long = 438;\npub const SYS_faccessat2: ::c_long = 439;\npub const SYS_process_madvise: ::c_long = 440;\npub const SYS_epoll_pwait2: ::c_long = 441;\npub const SYS_mount_setattr: ::c_long = 442;\n\nextern \"C\" {\n    pub fn getrandom(buf: *mut ::c_void, buflen: ::size_t, flags: ::c_uint) -> ::ssize_t;\n}\n\ncfg_if! {\n    if #[cfg(libc_align)] {\n        mod align;\n        pub use self::align::*;\n    }\n}\n"],["1199","s_no_extra_traits! {\n    #[allow(missing_debug_implementations)]\n    #[repr(align(8))]\n    pub struct max_align_t {\n        priv_: [f64; 3]\n    }\n}\n"],["1200","pub type c_char = i8;\npub type wchar_t = i32;\n\ns! {\n    pub struct stat {\n        pub st_dev: ::dev_t,\n        __st_dev_padding: ::c_int,\n        __st_ino_truncated: ::c_long,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        __st_rdev_padding: ::c_int,\n        pub st_size: ::off_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        pub st_ino: ::ino_t,\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::dev_t,\n        __st_dev_padding: ::c_int,\n        __st_ino_truncated: ::c_long,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        __st_rdev_padding: ::c_int,\n        pub st_size: ::off_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        pub st_ino: ::ino_t,\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_flags: ::c_int,\n        pub ss_size: ::size_t\n    }\n\n    pub struct ipc_perm {\n        pub __ipc_perm_key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::mode_t,\n        pub __seq: ::c_int,\n        __unused1: ::c_long,\n        __unused2: ::c_long\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        pub shm_segsz: ::size_t,\n        pub shm_atime: ::time_t,\n        __unused1: ::c_int,\n        pub shm_dtime: ::time_t,\n        __unused2: ::c_int,\n        pub shm_ctime: ::time_t,\n        __unused3: ::c_int,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::c_ulong,\n        __pad1: ::c_ulong,\n        __pad2: ::c_ulong,\n    }\n\n    pub struct msqid_ds {\n        pub msg_perm: ::ipc_perm,\n        pub msg_stime: ::time_t,\n        __unused1: ::c_int,\n        pub msg_rtime: ::time_t,\n        __unused2: ::c_int,\n        pub msg_ctime: ::time_t,\n        __unused3: ::c_int,\n        __msg_cbytes: ::c_ulong,\n        pub msg_qnum: ::msgqnum_t,\n        pub msg_qbytes: ::msglen_t,\n        pub msg_lspid: ::pid_t,\n        pub msg_lrpid: ::pid_t,\n        __pad1: ::c_ulong,\n        __pad2: ::c_ulong,\n    }\n\n    pub struct statfs {\n        pub f_type: ::c_ulong,\n        pub f_bsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_flags: ::c_ulong,\n        pub f_spare: [::c_ulong; 4],\n    }\n\n    pub struct mcontext_t {\n        __private: [u32; 22]\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_errno: ::c_int,\n        pub si_code: ::c_int,\n        pub _pad: [::c_int; 29],\n        _align: [usize; 0],\n    }\n\n    pub struct statfs64 {\n        pub f_type: ::c_ulong,\n        pub f_bsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_flags: ::c_ulong,\n        pub f_spare: [::c_ulong; 4],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_favail: u64,\n        pub f_fsid: ::c_ulong,\n        __f_unused: ::c_int,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n}\n\ns_no_extra_traits! {\n    pub struct ucontext_t {\n        pub uc_flags: ::c_ulong,\n        pub uc_link: *mut ucontext_t,\n        pub uc_stack: ::stack_t,\n        pub uc_mcontext: mcontext_t,\n        pub uc_sigmask: ::sigset_t,\n        __private: [u8; 112],\n    }\n}\n\ncfg_if! {\n    if #[cfg(feature = \"extra_traits\")] {\n        impl PartialEq for ucontext_t {\n            fn eq(&self, other: &ucontext_t) -> bool {\n                self.uc_flags == other.uc_flags\n                    && self.uc_link == other.uc_link\n                    && self.uc_stack == other.uc_stack\n                    && self.uc_mcontext == other.uc_mcontext\n                    && self.uc_sigmask == other.uc_sigmask\n                    && self\n                    .__private\n                    .iter()\n                    .zip(other.__private.iter())\n                    .all(|(a,b)| a == b)\n            }\n        }\n\n        impl Eq for ucontext_t {}\n\n        impl ::fmt::Debug for ucontext_t {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"ucontext_t\")\n                    .field(\"uc_flags\", &self.uc_flags)\n                    .field(\"uc_link\", &self.uc_link)\n                    .field(\"uc_stack\", &self.uc_stack)\n                    .field(\"uc_mcontext\", &self.uc_mcontext)\n                    .field(\"uc_sigmask\", &self.uc_sigmask)\n                // Ignore __private field\n                    .finish()\n            }\n        }\n\n        impl ::hash::Hash for ucontext_t {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.uc_flags.hash(state);\n                self.uc_link.hash(state);\n                self.uc_stack.hash(state);\n                self.uc_mcontext.hash(state);\n                self.uc_sigmask.hash(state);\n                self.__private.hash(state);\n            }\n        }\n    }\n}\n\npub const SIGSTKSZ: ::size_t = 8192;\npub const MINSIGSTKSZ: ::size_t = 2048;\n\npub const O_DIRECT: ::c_int = 0x4000;\npub const O_DIRECTORY: ::c_int = 0x10000;\npub const O_NOFOLLOW: ::c_int = 0x20000;\npub const O_ASYNC: ::c_int = 0x2000;\npub const O_LARGEFILE: ::c_int = 0o0100000;\n\npub const FIOCLEX: ::c_int = 0x5451;\npub const FIONCLEX: ::c_int = 0x5450;\npub const FIONBIO: ::c_int = 0x5421;\n\npub const RLIMIT_RSS: ::c_int = 5;\npub const RLIMIT_NOFILE: ::c_int = 7;\npub const RLIMIT_AS: ::c_int = 9;\npub const RLIMIT_NPROC: ::c_int = 6;\npub const RLIMIT_MEMLOCK: ::c_int = 8;\npub const RLIMIT_NLIMITS: ::c_int = 15;\npub const RLIM_NLIMITS: ::c_int = RLIMIT_NLIMITS;\n\npub const MADV_SOFT_OFFLINE: ::c_int = 101;\npub const MCL_CURRENT: ::c_int = 0x0001;\npub const MCL_FUTURE: ::c_int = 0x0002;\npub const CBAUD: ::tcflag_t = 0o0010017;\npub const TAB1: ::c_int = 0x00000800;\npub const TAB2: ::c_int = 0x00001000;\npub const TAB3: ::c_int = 0x00001800;\npub const CR1: ::c_int = 0x00000200;\npub const CR2: ::c_int = 0x00000400;\npub const CR3: ::c_int = 0x00000600;\npub const FF1: ::c_int = 0x00008000;\npub const BS1: ::c_int = 0x00002000;\npub const VT1: ::c_int = 0x00004000;\npub const VWERASE: usize = 14;\npub const VREPRINT: usize = 12;\npub const VSUSP: usize = 10;\npub const VSTART: usize = 8;\npub const VSTOP: usize = 9;\npub const VDISCARD: usize = 13;\npub const VTIME: usize = 5;\npub const IXON: ::tcflag_t = 0x00000400;\npub const IXOFF: ::tcflag_t = 0x00001000;\npub const ONLCR: ::tcflag_t = 0x4;\npub const CSIZE: ::tcflag_t = 0x00000030;\npub const CS6: ::tcflag_t = 0x00000010;\npub const CS7: ::tcflag_t = 0x00000020;\npub const CS8: ::tcflag_t = 0x00000030;\npub const CSTOPB: ::tcflag_t = 0x00000040;\npub const CREAD: ::tcflag_t = 0x00000080;\npub const PARENB: ::tcflag_t = 0x00000100;\npub const PARODD: ::tcflag_t = 0x00000200;\npub const HUPCL: ::tcflag_t = 0x00000400;\npub const CLOCAL: ::tcflag_t = 0x00000800;\npub const ECHOKE: ::tcflag_t = 0x00000800;\npub const ECHOE: ::tcflag_t = 0x00000010;\npub const ECHOK: ::tcflag_t = 0x00000020;\npub const ECHONL: ::tcflag_t = 0x00000040;\npub const ECHOPRT: ::tcflag_t = 0x00000400;\npub const ECHOCTL: ::tcflag_t = 0x00000200;\npub const ISIG: ::tcflag_t = 0x00000001;\npub const ICANON: ::tcflag_t = 0x00000002;\npub const PENDIN: ::tcflag_t = 0x00004000;\npub const NOFLSH: ::tcflag_t = 0x00000080;\npub const CIBAUD: ::tcflag_t = 0o02003600000;\npub const CBAUDEX: ::tcflag_t = 0o010000;\npub const VSWTC: usize = 7;\npub const OLCUC: ::tcflag_t = 0o000002;\npub const NLDLY: ::tcflag_t = 0o000400;\npub const CRDLY: ::tcflag_t = 0o003000;\npub const TABDLY: ::tcflag_t = 0o014000;\npub const BSDLY: ::tcflag_t = 0o020000;\npub const FFDLY: ::tcflag_t = 0o100000;\npub const VTDLY: ::tcflag_t = 0o040000;\npub const XTABS: ::tcflag_t = 0o014000;\npub const B57600: ::speed_t = 0o010001;\npub const B115200: ::speed_t = 0o010002;\npub const B230400: ::speed_t = 0o010003;\npub const B460800: ::speed_t = 0o010004;\npub const B500000: ::speed_t = 0o010005;\npub const B576000: ::speed_t = 0o010006;\npub const B921600: ::speed_t = 0o010007;\npub const B1000000: ::speed_t = 0o010010;\npub const B1152000: ::speed_t = 0o010011;\npub const B1500000: ::speed_t = 0o010012;\npub const B2000000: ::speed_t = 0o010013;\npub const B2500000: ::speed_t = 0o010014;\npub const B3000000: ::speed_t = 0o010015;\npub const B3500000: ::speed_t = 0o010016;\npub const B4000000: ::speed_t = 0o010017;\n\npub const O_APPEND: ::c_int = 1024;\npub const O_CREAT: ::c_int = 64;\npub const O_EXCL: ::c_int = 128;\npub const O_NOCTTY: ::c_int = 256;\npub const O_NONBLOCK: ::c_int = 2048;\npub const O_SYNC: ::c_int = 1052672;\npub const O_RSYNC: ::c_int = 1052672;\npub const O_DSYNC: ::c_int = 4096;\n\npub const SOCK_NONBLOCK: ::c_int = 2048;\n\npub const MAP_ANON: ::c_int = 0x0020;\npub const MAP_GROWSDOWN: ::c_int = 0x0100;\npub const MAP_DENYWRITE: ::c_int = 0x0800;\npub const MAP_EXECUTABLE: ::c_int = 0x01000;\npub const MAP_LOCKED: ::c_int = 0x02000;\npub const MAP_NORESERVE: ::c_int = 0x04000;\npub const MAP_POPULATE: ::c_int = 0x08000;\npub const MAP_NONBLOCK: ::c_int = 0x010000;\npub const MAP_STACK: ::c_int = 0x020000;\npub const MAP_SYNC: ::c_int = 0x080000;\n\npub const SOCK_STREAM: ::c_int = 1;\npub const SOCK_DGRAM: ::c_int = 2;\npub const SOCK_SEQPACKET: ::c_int = 5;\n\npub const EDEADLK: ::c_int = 35;\npub const ENAMETOOLONG: ::c_int = 36;\npub const ENOLCK: ::c_int = 37;\npub const ENOSYS: ::c_int = 38;\npub const ENOTEMPTY: ::c_int = 39;\npub const ELOOP: ::c_int = 40;\npub const ENOMSG: ::c_int = 42;\npub const EIDRM: ::c_int = 43;\npub const ECHRNG: ::c_int = 44;\npub const EL2NSYNC: ::c_int = 45;\npub const EL3HLT: ::c_int = 46;\npub const EL3RST: ::c_int = 47;\npub const ELNRNG: ::c_int = 48;\npub const EUNATCH: ::c_int = 49;\npub const ENOCSI: ::c_int = 50;\npub const EL2HLT: ::c_int = 51;\npub const EBADE: ::c_int = 52;\npub const EBADR: ::c_int = 53;\npub const EXFULL: ::c_int = 54;\npub const ENOANO: ::c_int = 55;\npub const EBADRQC: ::c_int = 56;\npub const EBADSLT: ::c_int = 57;\npub const EDEADLOCK: ::c_int = EDEADLK;\npub const EMULTIHOP: ::c_int = 72;\npub const EBADMSG: ::c_int = 74;\npub const EOVERFLOW: ::c_int = 75;\npub const ENOTUNIQ: ::c_int = 76;\npub const EBADFD: ::c_int = 77;\npub const EREMCHG: ::c_int = 78;\npub const ELIBACC: ::c_int = 79;\npub const ELIBBAD: ::c_int = 80;\npub const ELIBSCN: ::c_int = 81;\npub const ELIBMAX: ::c_int = 82;\npub const ELIBEXEC: ::c_int = 83;\npub const EILSEQ: ::c_int = 84;\npub const ERESTART: ::c_int = 85;\npub const ESTRPIPE: ::c_int = 86;\npub const EUSERS: ::c_int = 87;\npub const ENOTSOCK: ::c_int = 88;\npub const EDESTADDRREQ: ::c_int = 89;\npub const EMSGSIZE: ::c_int = 90;\npub const EPROTOTYPE: ::c_int = 91;\npub const ENOPROTOOPT: ::c_int = 92;\npub const EPROTONOSUPPORT: ::c_int = 93;\npub const ESOCKTNOSUPPORT: ::c_int = 94;\npub const EOPNOTSUPP: ::c_int = 95;\npub const ENOTSUP: ::c_int = EOPNOTSUPP;\npub const EPFNOSUPPORT: ::c_int = 96;\npub const EAFNOSUPPORT: ::c_int = 97;\npub const EADDRINUSE: ::c_int = 98;\npub const EADDRNOTAVAIL: ::c_int = 99;\npub const ENETDOWN: ::c_int = 100;\npub const ENETUNREACH: ::c_int = 101;\npub const ENETRESET: ::c_int = 102;\npub const ECONNABORTED: ::c_int = 103;\npub const ECONNRESET: ::c_int = 104;\npub const ENOBUFS: ::c_int = 105;\npub const EISCONN: ::c_int = 106;\npub const ENOTCONN: ::c_int = 107;\npub const ESHUTDOWN: ::c_int = 108;\npub const ETOOMANYREFS: ::c_int = 109;\npub const ETIMEDOUT: ::c_int = 110;\npub const ECONNREFUSED: ::c_int = 111;\npub const EHOSTDOWN: ::c_int = 112;\npub const EHOSTUNREACH: ::c_int = 113;\npub const EALREADY: ::c_int = 114;\npub const EINPROGRESS: ::c_int = 115;\npub const ESTALE: ::c_int = 116;\npub const EUCLEAN: ::c_int = 117;\npub const ENOTNAM: ::c_int = 118;\npub const ENAVAIL: ::c_int = 119;\npub const EISNAM: ::c_int = 120;\npub const EREMOTEIO: ::c_int = 121;\npub const EDQUOT: ::c_int = 122;\npub const ENOMEDIUM: ::c_int = 123;\npub const EMEDIUMTYPE: ::c_int = 124;\npub const ECANCELED: ::c_int = 125;\npub const ENOKEY: ::c_int = 126;\npub const EKEYEXPIRED: ::c_int = 127;\npub const EKEYREVOKED: ::c_int = 128;\npub const EKEYREJECTED: ::c_int = 129;\npub const EOWNERDEAD: ::c_int = 130;\npub const ENOTRECOVERABLE: ::c_int = 131;\npub const ERFKILL: ::c_int = 132;\npub const EHWPOISON: ::c_int = 133;\n\npub const SA_ONSTACK: ::c_int = 0x08000000;\npub const SA_SIGINFO: ::c_int = 0x00000004;\npub const SA_NOCLDWAIT: ::c_int = 0x00000002;\n\npub const SIGCHLD: ::c_int = 17;\npub const SIGBUS: ::c_int = 7;\npub const SIGTTIN: ::c_int = 21;\npub const SIGTTOU: ::c_int = 22;\npub const SIGXCPU: ::c_int = 24;\npub const SIGXFSZ: ::c_int = 25;\npub const SIGVTALRM: ::c_int = 26;\npub const SIGPROF: ::c_int = 27;\npub const SIGWINCH: ::c_int = 28;\npub const SIGUSR1: ::c_int = 10;\npub const SIGUSR2: ::c_int = 12;\npub const SIGCONT: ::c_int = 18;\npub const SIGSTOP: ::c_int = 19;\npub const SIGTSTP: ::c_int = 20;\npub const SIGURG: ::c_int = 23;\npub const SIGIO: ::c_int = 29;\npub const SIGSYS: ::c_int = 31;\npub const SIGSTKFLT: ::c_int = 16;\npub const SIGPOLL: ::c_int = 29;\npub const SIGPWR: ::c_int = 30;\npub const SIG_SETMASK: ::c_int = 2;\npub const SIG_BLOCK: ::c_int = 0x000000;\npub const SIG_UNBLOCK: ::c_int = 0x01;\n\npub const EXTPROC: ::tcflag_t = 0x00010000;\n\npub const MAP_HUGETLB: ::c_int = 0x040000;\npub const MAP_32BIT: ::c_int = 0x0040;\n\npub const F_GETLK: ::c_int = 12;\npub const F_GETOWN: ::c_int = 9;\npub const F_SETLK: ::c_int = 13;\npub const F_SETLKW: ::c_int = 14;\npub const F_SETOWN: ::c_int = 8;\npub const F_OFD_GETLK: ::c_int = 36;\npub const F_OFD_SETLK: ::c_int = 37;\npub const F_OFD_SETLKW: ::c_int = 38;\n\npub const VEOF: usize = 4;\npub const VEOL: usize = 11;\npub const VEOL2: usize = 16;\npub const VMIN: usize = 6;\npub const IEXTEN: ::tcflag_t = 0x00008000;\npub const TOSTOP: ::tcflag_t = 0x00000100;\npub const FLUSHO: ::tcflag_t = 0x00001000;\n\npub const TCGETS: ::c_int = 0x5401;\npub const TCSETS: ::c_int = 0x5402;\npub const TCSETSW: ::c_int = 0x5403;\npub const TCSETSF: ::c_int = 0x5404;\npub const TCGETA: ::c_int = 0x5405;\npub const TCSETA: ::c_int = 0x5406;\npub const TCSETAW: ::c_int = 0x5407;\npub const TCSETAF: ::c_int = 0x5408;\npub const TCSBRK: ::c_int = 0x5409;\npub const TCXONC: ::c_int = 0x540A;\npub const TCFLSH: ::c_int = 0x540B;\npub const TIOCGSOFTCAR: ::c_int = 0x5419;\npub const TIOCSSOFTCAR: ::c_int = 0x541A;\npub const TIOCLINUX: ::c_int = 0x541C;\npub const TIOCGSERIAL: ::c_int = 0x541E;\npub const TIOCEXCL: ::c_int = 0x540C;\npub const TIOCNXCL: ::c_int = 0x540D;\npub const TIOCSCTTY: ::c_int = 0x540E;\npub const TIOCGPGRP: ::c_int = 0x540F;\npub const TIOCSPGRP: ::c_int = 0x5410;\npub const TIOCOUTQ: ::c_int = 0x5411;\npub const TIOCSTI: ::c_int = 0x5412;\npub const TIOCGWINSZ: ::c_int = 0x5413;\npub const TIOCSWINSZ: ::c_int = 0x5414;\npub const TIOCMGET: ::c_int = 0x5415;\npub const TIOCMBIS: ::c_int = 0x5416;\npub const TIOCMBIC: ::c_int = 0x5417;\npub const TIOCMSET: ::c_int = 0x5418;\npub const FIONREAD: ::c_int = 0x541B;\npub const TIOCCONS: ::c_int = 0x541D;\n\npub const TIOCGRS485: ::c_int = 0x542E;\npub const TIOCSRS485: ::c_int = 0x542F;\n\npub const POLLWRNORM: ::c_short = 0x100;\npub const POLLWRBAND: ::c_short = 0x200;\n\npub const TIOCM_LE: ::c_int = 0x001;\npub const TIOCM_DTR: ::c_int = 0x002;\npub const TIOCM_RTS: ::c_int = 0x004;\npub const TIOCM_ST: ::c_int = 0x008;\npub const TIOCM_SR: ::c_int = 0x010;\npub const TIOCM_CTS: ::c_int = 0x020;\npub const TIOCM_CAR: ::c_int = 0x040;\npub const TIOCM_RNG: ::c_int = 0x080;\npub const TIOCM_DSR: ::c_int = 0x100;\npub const TIOCM_CD: ::c_int = TIOCM_CAR;\npub const TIOCM_RI: ::c_int = TIOCM_RNG;\n\n// Syscall table\npub const SYS_restart_syscall: ::c_long = 0;\npub const SYS_exit: ::c_long = 1;\npub const SYS_fork: ::c_long = 2;\npub const SYS_read: ::c_long = 3;\npub const SYS_write: ::c_long = 4;\npub const SYS_open: ::c_long = 5;\npub const SYS_close: ::c_long = 6;\npub const SYS_waitpid: ::c_long = 7;\npub const SYS_creat: ::c_long = 8;\npub const SYS_link: ::c_long = 9;\npub const SYS_unlink: ::c_long = 10;\npub const SYS_execve: ::c_long = 11;\npub const SYS_chdir: ::c_long = 12;\npub const SYS_time: ::c_long = 13;\npub const SYS_mknod: ::c_long = 14;\npub const SYS_chmod: ::c_long = 15;\npub const SYS_lchown: ::c_long = 16;\npub const SYS_break: ::c_long = 17;\npub const SYS_oldstat: ::c_long = 18;\npub const SYS_lseek: ::c_long = 19;\npub const SYS_getpid: ::c_long = 20;\npub const SYS_mount: ::c_long = 21;\npub const SYS_umount: ::c_long = 22;\npub const SYS_setuid: ::c_long = 23;\npub const SYS_getuid: ::c_long = 24;\npub const SYS_stime: ::c_long = 25;\npub const SYS_ptrace: ::c_long = 26;\npub const SYS_alarm: ::c_long = 27;\npub const SYS_oldfstat: ::c_long = 28;\npub const SYS_pause: ::c_long = 29;\npub const SYS_utime: ::c_long = 30;\npub const SYS_stty: ::c_long = 31;\npub const SYS_gtty: ::c_long = 32;\npub const SYS_access: ::c_long = 33;\npub const SYS_nice: ::c_long = 34;\npub const SYS_ftime: ::c_long = 35;\npub const SYS_sync: ::c_long = 36;\npub const SYS_kill: ::c_long = 37;\npub const SYS_rename: ::c_long = 38;\npub const SYS_mkdir: ::c_long = 39;\npub const SYS_rmdir: ::c_long = 40;\npub const SYS_dup: ::c_long = 41;\npub const SYS_pipe: ::c_long = 42;\npub const SYS_times: ::c_long = 43;\npub const SYS_prof: ::c_long = 44;\npub const SYS_brk: ::c_long = 45;\npub const SYS_setgid: ::c_long = 46;\npub const SYS_getgid: ::c_long = 47;\npub const SYS_signal: ::c_long = 48;\npub const SYS_geteuid: ::c_long = 49;\npub const SYS_getegid: ::c_long = 50;\npub const SYS_acct: ::c_long = 51;\npub const SYS_umount2: ::c_long = 52;\npub const SYS_lock: ::c_long = 53;\npub const SYS_ioctl: ::c_long = 54;\npub const SYS_fcntl: ::c_long = 55;\npub const SYS_mpx: ::c_long = 56;\npub const SYS_setpgid: ::c_long = 57;\npub const SYS_ulimit: ::c_long = 58;\npub const SYS_oldolduname: ::c_long = 59;\npub const SYS_umask: ::c_long = 60;\npub const SYS_chroot: ::c_long = 61;\npub const SYS_ustat: ::c_long = 62;\npub const SYS_dup2: ::c_long = 63;\npub const SYS_getppid: ::c_long = 64;\npub const SYS_getpgrp: ::c_long = 65;\npub const SYS_setsid: ::c_long = 66;\npub const SYS_sigaction: ::c_long = 67;\npub const SYS_sgetmask: ::c_long = 68;\npub const SYS_ssetmask: ::c_long = 69;\npub const SYS_setreuid: ::c_long = 70;\npub const SYS_setregid: ::c_long = 71;\npub const SYS_sigsuspend: ::c_long = 72;\npub const SYS_sigpending: ::c_long = 73;\npub const SYS_sethostname: ::c_long = 74;\npub const SYS_setrlimit: ::c_long = 75;\npub const SYS_getrlimit: ::c_long = 76;\npub const SYS_getrusage: ::c_long = 77;\npub const SYS_gettimeofday: ::c_long = 78;\npub const SYS_settimeofday: ::c_long = 79;\npub const SYS_getgroups: ::c_long = 80;\npub const SYS_setgroups: ::c_long = 81;\npub const SYS_select: ::c_long = 82;\npub const SYS_symlink: ::c_long = 83;\npub const SYS_oldlstat: ::c_long = 84;\npub const SYS_readlink: ::c_long = 85;\npub const SYS_uselib: ::c_long = 86;\npub const SYS_swapon: ::c_long = 87;\npub const SYS_reboot: ::c_long = 88;\npub const SYS_readdir: ::c_long = 89;\npub const SYS_mmap: ::c_long = 90;\npub const SYS_munmap: ::c_long = 91;\npub const SYS_truncate: ::c_long = 92;\npub const SYS_ftruncate: ::c_long = 93;\npub const SYS_fchmod: ::c_long = 94;\npub const SYS_fchown: ::c_long = 95;\npub const SYS_getpriority: ::c_long = 96;\npub const SYS_setpriority: ::c_long = 97;\npub const SYS_profil: ::c_long = 98;\npub const SYS_statfs: ::c_long = 99;\npub const SYS_fstatfs: ::c_long = 100;\npub const SYS_ioperm: ::c_long = 101;\npub const SYS_socketcall: ::c_long = 102;\npub const SYS_syslog: ::c_long = 103;\npub const SYS_setitimer: ::c_long = 104;\npub const SYS_getitimer: ::c_long = 105;\npub const SYS_stat: ::c_long = 106;\npub const SYS_lstat: ::c_long = 107;\npub const SYS_fstat: ::c_long = 108;\npub const SYS_olduname: ::c_long = 109;\npub const SYS_iopl: ::c_long = 110;\npub const SYS_vhangup: ::c_long = 111;\npub const SYS_idle: ::c_long = 112;\npub const SYS_vm86old: ::c_long = 113;\npub const SYS_wait4: ::c_long = 114;\npub const SYS_swapoff: ::c_long = 115;\npub const SYS_sysinfo: ::c_long = 116;\npub const SYS_ipc: ::c_long = 117;\npub const SYS_fsync: ::c_long = 118;\npub const SYS_sigreturn: ::c_long = 119;\npub const SYS_clone: ::c_long = 120;\npub const SYS_setdomainname: ::c_long = 121;\npub const SYS_uname: ::c_long = 122;\npub const SYS_modify_ldt: ::c_long = 123;\npub const SYS_adjtimex: ::c_long = 124;\npub const SYS_mprotect: ::c_long = 125;\npub const SYS_sigprocmask: ::c_long = 126;\npub const SYS_create_module: ::c_long = 127;\npub const SYS_init_module: ::c_long = 128;\npub const SYS_delete_module: ::c_long = 129;\npub const SYS_get_kernel_syms: ::c_long = 130;\npub const SYS_quotactl: ::c_long = 131;\npub const SYS_getpgid: ::c_long = 132;\npub const SYS_fchdir: ::c_long = 133;\npub const SYS_bdflush: ::c_long = 134;\npub const SYS_sysfs: ::c_long = 135;\npub const SYS_personality: ::c_long = 136;\npub const SYS_afs_syscall: ::c_long = 137;\npub const SYS_setfsuid: ::c_long = 138;\npub const SYS_setfsgid: ::c_long = 139;\npub const SYS__llseek: ::c_long = 140;\npub const SYS_getdents: ::c_long = 141;\npub const SYS__newselect: ::c_long = 142;\npub const SYS_flock: ::c_long = 143;\npub const SYS_msync: ::c_long = 144;\npub const SYS_readv: ::c_long = 145;\npub const SYS_writev: ::c_long = 146;\npub const SYS_getsid: ::c_long = 147;\npub const SYS_fdatasync: ::c_long = 148;\npub const SYS__sysctl: ::c_long = 149;\npub const SYS_mlock: ::c_long = 150;\npub const SYS_munlock: ::c_long = 151;\npub const SYS_mlockall: ::c_long = 152;\npub const SYS_munlockall: ::c_long = 153;\npub const SYS_sched_setparam: ::c_long = 154;\npub const SYS_sched_getparam: ::c_long = 155;\npub const SYS_sched_setscheduler: ::c_long = 156;\npub const SYS_sched_getscheduler: ::c_long = 157;\npub const SYS_sched_yield: ::c_long = 158;\npub const SYS_sched_get_priority_max: ::c_long = 159;\npub const SYS_sched_get_priority_min: ::c_long = 160;\npub const SYS_sched_rr_get_interval: ::c_long = 161;\npub const SYS_nanosleep: ::c_long = 162;\npub const SYS_mremap: ::c_long = 163;\npub const SYS_setresuid: ::c_long = 164;\npub const SYS_getresuid: ::c_long = 165;\npub const SYS_vm86: ::c_long = 166;\npub const SYS_query_module: ::c_long = 167;\npub const SYS_poll: ::c_long = 168;\npub const SYS_nfsservctl: ::c_long = 169;\npub const SYS_setresgid: ::c_long = 170;\npub const SYS_getresgid: ::c_long = 171;\npub const SYS_prctl: ::c_long = 172;\npub const SYS_rt_sigreturn: ::c_long = 173;\npub const SYS_rt_sigaction: ::c_long = 174;\npub const SYS_rt_sigprocmask: ::c_long = 175;\npub const SYS_rt_sigpending: ::c_long = 176;\npub const SYS_rt_sigtimedwait: ::c_long = 177;\npub const SYS_rt_sigqueueinfo: ::c_long = 178;\npub const SYS_rt_sigsuspend: ::c_long = 179;\npub const SYS_pread64: ::c_long = 180;\npub const SYS_pwrite64: ::c_long = 181;\npub const SYS_chown: ::c_long = 182;\npub const SYS_getcwd: ::c_long = 183;\npub const SYS_capget: ::c_long = 184;\npub const SYS_capset: ::c_long = 185;\npub const SYS_sigaltstack: ::c_long = 186;\npub const SYS_sendfile: ::c_long = 187;\npub const SYS_getpmsg: ::c_long = 188;\npub const SYS_putpmsg: ::c_long = 189;\npub const SYS_vfork: ::c_long = 190;\npub const SYS_ugetrlimit: ::c_long = 191;\npub const SYS_mmap2: ::c_long = 192;\npub const SYS_truncate64: ::c_long = 193;\npub const SYS_ftruncate64: ::c_long = 194;\npub const SYS_stat64: ::c_long = 195;\npub const SYS_lstat64: ::c_long = 196;\npub const SYS_fstat64: ::c_long = 197;\npub const SYS_lchown32: ::c_long = 198;\npub const SYS_getuid32: ::c_long = 199;\npub const SYS_getgid32: ::c_long = 200;\npub const SYS_geteuid32: ::c_long = 201;\npub const SYS_getegid32: ::c_long = 202;\npub const SYS_setreuid32: ::c_long = 203;\npub const SYS_setregid32: ::c_long = 204;\npub const SYS_getgroups32: ::c_long = 205;\npub const SYS_setgroups32: ::c_long = 206;\npub const SYS_fchown32: ::c_long = 207;\npub const SYS_setresuid32: ::c_long = 208;\npub const SYS_getresuid32: ::c_long = 209;\npub const SYS_setresgid32: ::c_long = 210;\npub const SYS_getresgid32: ::c_long = 211;\npub const SYS_chown32: ::c_long = 212;\npub const SYS_setuid32: ::c_long = 213;\npub const SYS_setgid32: ::c_long = 214;\npub const SYS_setfsuid32: ::c_long = 215;\npub const SYS_setfsgid32: ::c_long = 216;\npub const SYS_pivot_root: ::c_long = 217;\npub const SYS_mincore: ::c_long = 218;\npub const SYS_madvise: ::c_long = 219;\npub const SYS_getdents64: ::c_long = 220;\npub const SYS_fcntl64: ::c_long = 221;\npub const SYS_gettid: ::c_long = 224;\npub const SYS_readahead: ::c_long = 225;\npub const SYS_setxattr: ::c_long = 226;\npub const SYS_lsetxattr: ::c_long = 227;\npub const SYS_fsetxattr: ::c_long = 228;\npub const SYS_getxattr: ::c_long = 229;\npub const SYS_lgetxattr: ::c_long = 230;\npub const SYS_fgetxattr: ::c_long = 231;\npub const SYS_listxattr: ::c_long = 232;\npub const SYS_llistxattr: ::c_long = 233;\npub const SYS_flistxattr: ::c_long = 234;\npub const SYS_removexattr: ::c_long = 235;\npub const SYS_lremovexattr: ::c_long = 236;\npub const SYS_fremovexattr: ::c_long = 237;\npub const SYS_tkill: ::c_long = 238;\npub const SYS_sendfile64: ::c_long = 239;\npub const SYS_futex: ::c_long = 240;\npub const SYS_sched_setaffinity: ::c_long = 241;\npub const SYS_sched_getaffinity: ::c_long = 242;\npub const SYS_set_thread_area: ::c_long = 243;\npub const SYS_get_thread_area: ::c_long = 244;\npub const SYS_io_setup: ::c_long = 245;\npub const SYS_io_destroy: ::c_long = 246;\npub const SYS_io_getevents: ::c_long = 247;\npub const SYS_io_submit: ::c_long = 248;\npub const SYS_io_cancel: ::c_long = 249;\npub const SYS_fadvise64: ::c_long = 250;\npub const SYS_exit_group: ::c_long = 252;\npub const SYS_lookup_dcookie: ::c_long = 253;\npub const SYS_epoll_create: ::c_long = 254;\npub const SYS_epoll_ctl: ::c_long = 255;\npub const SYS_epoll_wait: ::c_long = 256;\npub const SYS_remap_file_pages: ::c_long = 257;\npub const SYS_set_tid_address: ::c_long = 258;\npub const SYS_timer_create: ::c_long = 259;\npub const SYS_timer_settime: ::c_long = 260;\npub const SYS_timer_gettime: ::c_long = 261;\npub const SYS_timer_getoverrun: ::c_long = 262;\npub const SYS_timer_delete: ::c_long = 263;\npub const SYS_clock_settime: ::c_long = 264;\npub const SYS_clock_gettime: ::c_long = 265;\npub const SYS_clock_getres: ::c_long = 266;\npub const SYS_clock_nanosleep: ::c_long = 267;\npub const SYS_statfs64: ::c_long = 268;\npub const SYS_fstatfs64: ::c_long = 269;\npub const SYS_tgkill: ::c_long = 270;\npub const SYS_utimes: ::c_long = 271;\npub const SYS_fadvise64_64: ::c_long = 272;\npub const SYS_vserver: ::c_long = 273;\npub const SYS_mbind: ::c_long = 274;\npub const SYS_get_mempolicy: ::c_long = 275;\npub const SYS_set_mempolicy: ::c_long = 276;\npub const SYS_mq_open: ::c_long = 277;\npub const SYS_mq_unlink: ::c_long = 278;\npub const SYS_mq_timedsend: ::c_long = 279;\npub const SYS_mq_timedreceive: ::c_long = 280;\npub const SYS_mq_notify: ::c_long = 281;\npub const SYS_mq_getsetattr: ::c_long = 282;\npub const SYS_kexec_load: ::c_long = 283;\npub const SYS_waitid: ::c_long = 284;\npub const SYS_add_key: ::c_long = 286;\npub const SYS_request_key: ::c_long = 287;\npub const SYS_keyctl: ::c_long = 288;\npub const SYS_ioprio_set: ::c_long = 289;\npub const SYS_ioprio_get: ::c_long = 290;\npub const SYS_inotify_init: ::c_long = 291;\npub const SYS_inotify_add_watch: ::c_long = 292;\npub const SYS_inotify_rm_watch: ::c_long = 293;\npub const SYS_migrate_pages: ::c_long = 294;\npub const SYS_openat: ::c_long = 295;\npub const SYS_mkdirat: ::c_long = 296;\npub const SYS_mknodat: ::c_long = 297;\npub const SYS_fchownat: ::c_long = 298;\npub const SYS_futimesat: ::c_long = 299;\npub const SYS_fstatat64: ::c_long = 300;\npub const SYS_unlinkat: ::c_long = 301;\npub const SYS_renameat: ::c_long = 302;\npub const SYS_linkat: ::c_long = 303;\npub const SYS_symlinkat: ::c_long = 304;\npub const SYS_readlinkat: ::c_long = 305;\npub const SYS_fchmodat: ::c_long = 306;\npub const SYS_faccessat: ::c_long = 307;\npub const SYS_pselect6: ::c_long = 308;\npub const SYS_ppoll: ::c_long = 309;\npub const SYS_unshare: ::c_long = 310;\npub const SYS_set_robust_list: ::c_long = 311;\npub const SYS_get_robust_list: ::c_long = 312;\npub const SYS_splice: ::c_long = 313;\npub const SYS_sync_file_range: ::c_long = 314;\npub const SYS_tee: ::c_long = 315;\npub const SYS_vmsplice: ::c_long = 316;\npub const SYS_move_pages: ::c_long = 317;\npub const SYS_getcpu: ::c_long = 318;\npub const SYS_epoll_pwait: ::c_long = 319;\npub const SYS_utimensat: ::c_long = 320;\npub const SYS_signalfd: ::c_long = 321;\npub const SYS_timerfd_create: ::c_long = 322;\npub const SYS_eventfd: ::c_long = 323;\npub const SYS_fallocate: ::c_long = 324;\npub const SYS_timerfd_settime: ::c_long = 325;\npub const SYS_timerfd_gettime: ::c_long = 326;\npub const SYS_signalfd4: ::c_long = 327;\npub const SYS_eventfd2: ::c_long = 328;\npub const SYS_epoll_create1: ::c_long = 329;\npub const SYS_dup3: ::c_long = 330;\npub const SYS_pipe2: ::c_long = 331;\npub const SYS_inotify_init1: ::c_long = 332;\npub const SYS_preadv: ::c_long = 333;\npub const SYS_pwritev: ::c_long = 334;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 335;\npub const SYS_perf_event_open: ::c_long = 336;\npub const SYS_recvmmsg: ::c_long = 337;\npub const SYS_fanotify_init: ::c_long = 338;\npub const SYS_fanotify_mark: ::c_long = 339;\npub const SYS_prlimit64: ::c_long = 340;\npub const SYS_name_to_handle_at: ::c_long = 341;\npub const SYS_open_by_handle_at: ::c_long = 342;\npub const SYS_clock_adjtime: ::c_long = 343;\npub const SYS_syncfs: ::c_long = 344;\npub const SYS_sendmmsg: ::c_long = 345;\npub const SYS_setns: ::c_long = 346;\npub const SYS_process_vm_readv: ::c_long = 347;\npub const SYS_process_vm_writev: ::c_long = 348;\npub const SYS_kcmp: ::c_long = 349;\npub const SYS_finit_module: ::c_long = 350;\npub const SYS_sched_setattr: ::c_long = 351;\npub const SYS_sched_getattr: ::c_long = 352;\npub const SYS_renameat2: ::c_long = 353;\npub const SYS_seccomp: ::c_long = 354;\npub const SYS_getrandom: ::c_long = 355;\npub const SYS_memfd_create: ::c_long = 356;\npub const SYS_bpf: ::c_long = 357;\npub const SYS_execveat: ::c_long = 358;\npub const SYS_socket: ::c_long = 359;\npub const SYS_socketpair: ::c_long = 360;\npub const SYS_bind: ::c_long = 361;\npub const SYS_connect: ::c_long = 362;\npub const SYS_listen: ::c_long = 363;\npub const SYS_accept4: ::c_long = 364;\npub const SYS_getsockopt: ::c_long = 365;\npub const SYS_setsockopt: ::c_long = 366;\npub const SYS_getsockname: ::c_long = 367;\npub const SYS_getpeername: ::c_long = 368;\npub const SYS_sendto: ::c_long = 369;\npub const SYS_sendmsg: ::c_long = 370;\npub const SYS_recvfrom: ::c_long = 371;\npub const SYS_recvmsg: ::c_long = 372;\npub const SYS_shutdown: ::c_long = 373;\npub const SYS_userfaultfd: ::c_long = 374;\npub const SYS_membarrier: ::c_long = 375;\npub const SYS_mlock2: ::c_long = 376;\npub const SYS_copy_file_range: ::c_long = 377;\npub const SYS_preadv2: ::c_long = 378;\npub const SYS_pwritev2: ::c_long = 379;\npub const SYS_pkey_mprotect: ::c_long = 380;\npub const SYS_pkey_alloc: ::c_long = 381;\npub const SYS_pkey_free: ::c_long = 382;\npub const SYS_statx: ::c_long = 383;\npub const SYS_pidfd_send_signal: ::c_long = 424;\npub const SYS_io_uring_setup: ::c_long = 425;\npub const SYS_io_uring_enter: ::c_long = 426;\npub const SYS_io_uring_register: ::c_long = 427;\npub const SYS_open_tree: ::c_long = 428;\npub const SYS_move_mount: ::c_long = 429;\npub const SYS_fsopen: ::c_long = 430;\npub const SYS_fsconfig: ::c_long = 431;\npub const SYS_fsmount: ::c_long = 432;\npub const SYS_fspick: ::c_long = 433;\npub const SYS_pidfd_open: ::c_long = 434;\npub const SYS_clone3: ::c_long = 435;\npub const SYS_close_range: ::c_long = 436;\npub const SYS_openat2: ::c_long = 437;\npub const SYS_pidfd_getfd: ::c_long = 438;\npub const SYS_faccessat2: ::c_long = 439;\npub const SYS_process_madvise: ::c_long = 440;\npub const SYS_epoll_pwait2: ::c_long = 441;\npub const SYS_mount_setattr: ::c_long = 442;\n\n// offsets in user_regs_structs, from sys/reg.h\npub const EBX: ::c_int = 0;\npub const ECX: ::c_int = 1;\npub const EDX: ::c_int = 2;\npub const ESI: ::c_int = 3;\npub const EDI: ::c_int = 4;\npub const EBP: ::c_int = 5;\npub const EAX: ::c_int = 6;\npub const DS: ::c_int = 7;\npub const ES: ::c_int = 8;\npub const FS: ::c_int = 9;\npub const GS: ::c_int = 10;\npub const ORIG_EAX: ::c_int = 11;\npub const EIP: ::c_int = 12;\npub const CS: ::c_int = 13;\npub const EFL: ::c_int = 14;\npub const UESP: ::c_int = 15;\npub const SS: ::c_int = 16;\n\nextern \"C\" {\n    pub fn getrandom(buf: *mut ::c_void, buflen: ::size_t, flags: ::c_uint) -> ::ssize_t;\n}\n\ncfg_if! {\n    if #[cfg(libc_align)] {\n        mod align;\n        pub use self::align::*;\n    }\n}\n"],["1201","pub type c_long = i32;\npub type c_ulong = u32;\npub type nlink_t = u32;\npub type blksize_t = ::c_long;\npub type __u64 = ::c_ulonglong;\npub type regoff_t = ::c_int;\n\ns! {\n    pub struct pthread_attr_t {\n        __size: [u32; 9]\n    }\n\n    pub struct sigset_t {\n        __val: [::c_ulong; 32],\n    }\n\n    pub struct msghdr {\n        pub msg_name: *mut ::c_void,\n        pub msg_namelen: ::socklen_t,\n        pub msg_iov: *mut ::iovec,\n        pub msg_iovlen: ::c_int,\n        pub msg_control: *mut ::c_void,\n        pub msg_controllen: ::socklen_t,\n        pub msg_flags: ::c_int,\n    }\n\n    pub struct cmsghdr {\n        pub cmsg_len: ::socklen_t,\n        pub cmsg_level: ::c_int,\n        pub cmsg_type: ::c_int,\n    }\n\n    pub struct sem_t {\n        __val: [::c_int; 4],\n    }\n}\n\npub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 32;\npub const __SIZEOF_PTHREAD_MUTEX_T: usize = 24;\n\npub const TIOCINQ: ::c_int = ::FIONREAD;\n\nextern \"C\" {\n    pub fn ioctl(fd: ::c_int, request: ::c_int, ...) -> ::c_int;\n}\n\ncfg_if! {\n    if #[cfg(any(target_arch = \"x86\"))] {\n        mod x86;\n        pub use self::x86::*;\n    } else if #[cfg(any(target_arch = \"mips\"))] {\n        mod mips;\n        pub use self::mips::*;\n    } else if #[cfg(any(target_arch = \"arm\"))] {\n        mod arm;\n        pub use self::arm::*;\n    } else if #[cfg(any(target_arch = \"powerpc\"))] {\n        mod powerpc;\n        pub use self::powerpc::*;\n    } else if #[cfg(any(target_arch = \"hexagon\"))] {\n        mod hexagon;\n        pub use self::hexagon::*;\n    } else {\n        // Unknown target_arch\n    }\n}\n"],["1202","pub type c_char = u8;\npub type wchar_t = i32;\n\ns! {\n    pub struct stat {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        __st_rdev_padding: ::c_short,\n        pub st_size: ::off_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __unused: [::c_long; 2],\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        __st_rdev_padding: ::c_short,\n        pub st_size: ::off_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __unused: [::c_long; 2],\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_flags: ::c_int,\n        pub ss_size: ::size_t\n    }\n\n    pub struct ipc_perm {\n        pub __ipc_perm_key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::mode_t,\n        pub __seq: ::c_int,\n        __pad1: ::c_int,\n        __pad2: ::c_longlong,\n        __pad3: ::c_longlong\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        __unused1: ::c_int,\n        pub shm_atime: ::time_t,\n        __unused2: ::c_int,\n        pub shm_dtime: ::time_t,\n        __unused3: ::c_int,\n        pub shm_ctime: ::time_t,\n        __unused4: ::c_int,\n        pub shm_segsz: ::size_t,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::c_ulong,\n        __pad1: ::c_ulong,\n        __pad2: ::c_ulong,\n    }\n\n    pub struct msqid_ds {\n        pub msg_perm: ::ipc_perm,\n        __unused1: ::c_int,\n        pub msg_stime: ::time_t,\n        __unused2: ::c_int,\n        pub msg_rtime: ::time_t,\n        __unused3: ::c_int,\n        pub msg_ctime: ::time_t,\n        __msg_cbytes: ::c_ulong,\n        pub msg_qnum: ::msgqnum_t,\n        pub msg_qbytes: ::msglen_t,\n        pub msg_lspid: ::pid_t,\n        pub msg_lrpid: ::pid_t,\n        __pad1: ::c_ulong,\n        __pad2: ::c_ulong,\n    }\n\n    pub struct statfs {\n        pub f_type: ::c_ulong,\n        pub f_bsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_flags: ::c_ulong,\n        pub f_spare: [::c_ulong; 4],\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_errno: ::c_int,\n        pub si_code: ::c_int,\n        pub _pad: [::c_int; 29],\n        _align: [usize; 0],\n    }\n\n    pub struct statfs64 {\n        pub f_type: ::c_ulong,\n        pub f_bsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_flags: ::c_ulong,\n        pub f_spare: [::c_ulong; 4],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_favail: u64,\n        #[cfg(target_endian = \"little\")]\n        pub f_fsid: ::c_ulong,\n        __f_unused: ::c_int,\n        #[cfg(target_endian = \"big\")]\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n}\n\npub const MADV_SOFT_OFFLINE: ::c_int = 101;\npub const SIGSTKSZ: ::size_t = 10240;\npub const MINSIGSTKSZ: ::size_t = 4096;\n\npub const O_DIRECT: ::c_int = 0x20000;\npub const O_DIRECTORY: ::c_int = 0x4000;\npub const O_NOFOLLOW: ::c_int = 0x8000;\npub const O_ASYNC: ::c_int = 0x2000;\npub const O_LARGEFILE: ::c_int = 0x10000;\n\npub const FIOCLEX: ::c_int = 0x20006601;\npub const FIONCLEX: ::c_int = 0x20006602;\npub const FIONBIO: ::c_int = 0x8004667E;\n\npub const RLIMIT_RSS: ::c_int = 5;\npub const RLIMIT_NOFILE: ::c_int = 7;\npub const RLIMIT_AS: ::c_int = 9;\npub const RLIMIT_NPROC: ::c_int = 6;\npub const RLIMIT_MEMLOCK: ::c_int = 8;\npub const RLIMIT_NLIMITS: ::c_int = 15;\npub const RLIM_NLIMITS: ::c_int = RLIMIT_NLIMITS;\n\npub const MCL_CURRENT: ::c_int = 0x2000;\npub const MCL_FUTURE: ::c_int = 0x4000;\npub const CBAUD: ::tcflag_t = 0o0000377;\npub const TAB1: ::c_int = 0x00000400;\npub const TAB2: ::c_int = 0x00000800;\npub const TAB3: ::c_int = 0x00000C00;\npub const CR1: ::c_int = 0x00001000;\npub const CR2: ::c_int = 0x00002000;\npub const CR3: ::c_int = 0x00003000;\npub const FF1: ::c_int = 0x00004000;\npub const BS1: ::c_int = 0x00008000;\npub const VT1: ::c_int = 0x00010000;\npub const VWERASE: usize = 10;\npub const VREPRINT: usize = 11;\npub const VSUSP: usize = 12;\npub const VSTART: usize = 13;\npub const VSTOP: usize = 14;\npub const VDISCARD: usize = 16;\npub const VTIME: usize = 7;\npub const IXON: ::tcflag_t = 0x00000200;\npub const IXOFF: ::tcflag_t = 0x00000400;\npub const ONLCR: ::tcflag_t = 0x00000002;\npub const CSIZE: ::tcflag_t = 0x00000300;\npub const CS6: ::tcflag_t = 0x00000100;\npub const CS7: ::tcflag_t = 0x00000200;\npub const CS8: ::tcflag_t = 0x00000300;\npub const CSTOPB: ::tcflag_t = 0x00000400;\npub const CREAD: ::tcflag_t = 0x00000800;\npub const PARENB: ::tcflag_t = 0x00001000;\npub const PARODD: ::tcflag_t = 0x00002000;\npub const HUPCL: ::tcflag_t = 0x00004000;\npub const CLOCAL: ::tcflag_t = 0x00008000;\npub const ECHOKE: ::tcflag_t = 0x00000001;\npub const ECHOE: ::tcflag_t = 0x00000002;\npub const ECHOK: ::tcflag_t = 0x00000004;\npub const ECHONL: ::tcflag_t = 0x00000010;\npub const ECHOPRT: ::tcflag_t = 0x00000020;\npub const ECHOCTL: ::tcflag_t = 0x00000040;\npub const ISIG: ::tcflag_t = 0x00000080;\npub const ICANON: ::tcflag_t = 0x00000100;\npub const PENDIN: ::tcflag_t = 0x20000000;\npub const NOFLSH: ::tcflag_t = 0x80000000;\npub const CIBAUD: ::tcflag_t = 0o00077600000;\npub const CBAUDEX: ::tcflag_t = 0o000020;\npub const VSWTC: usize = 9;\npub const OLCUC: ::tcflag_t = 0o000004;\npub const NLDLY: ::tcflag_t = 0o001400;\npub const CRDLY: ::tcflag_t = 0o030000;\npub const TABDLY: ::tcflag_t = 0o006000;\npub const BSDLY: ::tcflag_t = 0o100000;\npub const FFDLY: ::tcflag_t = 0o040000;\npub const VTDLY: ::tcflag_t = 0o200000;\npub const XTABS: ::tcflag_t = 0o006000;\npub const B57600: ::speed_t = 0o000020;\npub const B115200: ::speed_t = 0o000021;\npub const B230400: ::speed_t = 0o000022;\npub const B460800: ::speed_t = 0o000023;\npub const B500000: ::speed_t = 0o000024;\npub const B576000: ::speed_t = 0o000025;\npub const B921600: ::speed_t = 0o000026;\npub const B1000000: ::speed_t = 0o000027;\npub const B1152000: ::speed_t = 0o000030;\npub const B1500000: ::speed_t = 0o000031;\npub const B2000000: ::speed_t = 0o000032;\npub const B2500000: ::speed_t = 0o000033;\npub const B3000000: ::speed_t = 0o000034;\npub const B3500000: ::speed_t = 0o000035;\npub const B4000000: ::speed_t = 0o000036;\n\npub const O_APPEND: ::c_int = 1024;\npub const O_CREAT: ::c_int = 64;\npub const O_EXCL: ::c_int = 128;\npub const O_NOCTTY: ::c_int = 256;\npub const O_NONBLOCK: ::c_int = 2048;\npub const O_SYNC: ::c_int = 1052672;\npub const O_RSYNC: ::c_int = 1052672;\npub const O_DSYNC: ::c_int = 4096;\n\npub const SOCK_NONBLOCK: ::c_int = 2048;\n\npub const MAP_ANON: ::c_int = 0x0020;\npub const MAP_GROWSDOWN: ::c_int = 0x0100;\npub const MAP_DENYWRITE: ::c_int = 0x0800;\npub const MAP_EXECUTABLE: ::c_int = 0x01000;\npub const MAP_LOCKED: ::c_int = 0x00080;\npub const MAP_NORESERVE: ::c_int = 0x00040;\npub const MAP_POPULATE: ::c_int = 0x08000;\npub const MAP_NONBLOCK: ::c_int = 0x010000;\npub const MAP_STACK: ::c_int = 0x020000;\n\npub const SOCK_STREAM: ::c_int = 1;\npub const SOCK_DGRAM: ::c_int = 2;\npub const SOCK_SEQPACKET: ::c_int = 5;\n\npub const EDEADLK: ::c_int = 35;\npub const ENAMETOOLONG: ::c_int = 36;\npub const ENOLCK: ::c_int = 37;\npub const ENOSYS: ::c_int = 38;\npub const ENOTEMPTY: ::c_int = 39;\npub const ELOOP: ::c_int = 40;\npub const ENOMSG: ::c_int = 42;\npub const EIDRM: ::c_int = 43;\npub const ECHRNG: ::c_int = 44;\npub const EL2NSYNC: ::c_int = 45;\npub const EL3HLT: ::c_int = 46;\npub const EL3RST: ::c_int = 47;\npub const ELNRNG: ::c_int = 48;\npub const EUNATCH: ::c_int = 49;\npub const ENOCSI: ::c_int = 50;\npub const EL2HLT: ::c_int = 51;\npub const EBADE: ::c_int = 52;\npub const EBADR: ::c_int = 53;\npub const EXFULL: ::c_int = 54;\npub const ENOANO: ::c_int = 55;\npub const EBADRQC: ::c_int = 56;\npub const EBADSLT: ::c_int = 57;\npub const EDEADLOCK: ::c_int = 58;\npub const EMULTIHOP: ::c_int = 72;\npub const EBADMSG: ::c_int = 74;\npub const EOVERFLOW: ::c_int = 75;\npub const ENOTUNIQ: ::c_int = 76;\npub const EBADFD: ::c_int = 77;\npub const EREMCHG: ::c_int = 78;\npub const ELIBACC: ::c_int = 79;\npub const ELIBBAD: ::c_int = 80;\npub const ELIBSCN: ::c_int = 81;\npub const ELIBMAX: ::c_int = 82;\npub const ELIBEXEC: ::c_int = 83;\npub const EILSEQ: ::c_int = 84;\npub const ERESTART: ::c_int = 85;\npub const ESTRPIPE: ::c_int = 86;\npub const EUSERS: ::c_int = 87;\npub const ENOTSOCK: ::c_int = 88;\npub const EDESTADDRREQ: ::c_int = 89;\npub const EMSGSIZE: ::c_int = 90;\npub const EPROTOTYPE: ::c_int = 91;\npub const ENOPROTOOPT: ::c_int = 92;\npub const EPROTONOSUPPORT: ::c_int = 93;\npub const ESOCKTNOSUPPORT: ::c_int = 94;\npub const EOPNOTSUPP: ::c_int = 95;\npub const ENOTSUP: ::c_int = EOPNOTSUPP;\npub const EPFNOSUPPORT: ::c_int = 96;\npub const EAFNOSUPPORT: ::c_int = 97;\npub const EADDRINUSE: ::c_int = 98;\npub const EADDRNOTAVAIL: ::c_int = 99;\npub const ENETDOWN: ::c_int = 100;\npub const ENETUNREACH: ::c_int = 101;\npub const ENETRESET: ::c_int = 102;\npub const ECONNABORTED: ::c_int = 103;\npub const ECONNRESET: ::c_int = 104;\npub const ENOBUFS: ::c_int = 105;\npub const EISCONN: ::c_int = 106;\npub const ENOTCONN: ::c_int = 107;\npub const ESHUTDOWN: ::c_int = 108;\npub const ETOOMANYREFS: ::c_int = 109;\npub const ETIMEDOUT: ::c_int = 110;\npub const ECONNREFUSED: ::c_int = 111;\npub const EHOSTDOWN: ::c_int = 112;\npub const EHOSTUNREACH: ::c_int = 113;\npub const EALREADY: ::c_int = 114;\npub const EINPROGRESS: ::c_int = 115;\npub const ESTALE: ::c_int = 116;\npub const EUCLEAN: ::c_int = 117;\npub const ENOTNAM: ::c_int = 118;\npub const ENAVAIL: ::c_int = 119;\npub const EISNAM: ::c_int = 120;\npub const EREMOTEIO: ::c_int = 121;\npub const EDQUOT: ::c_int = 122;\npub const ENOMEDIUM: ::c_int = 123;\npub const EMEDIUMTYPE: ::c_int = 124;\npub const ECANCELED: ::c_int = 125;\npub const ENOKEY: ::c_int = 126;\npub const EKEYEXPIRED: ::c_int = 127;\npub const EKEYREVOKED: ::c_int = 128;\npub const EKEYREJECTED: ::c_int = 129;\npub const EOWNERDEAD: ::c_int = 130;\npub const ENOTRECOVERABLE: ::c_int = 131;\npub const ERFKILL: ::c_int = 132;\npub const EHWPOISON: ::c_int = 133;\n\npub const SA_ONSTACK: ::c_int = 0x08000000;\npub const SA_SIGINFO: ::c_int = 0x00000004;\npub const SA_NOCLDWAIT: ::c_int = 0x00000002;\n\npub const SIGCHLD: ::c_int = 17;\npub const SIGBUS: ::c_int = 7;\npub const SIGTTIN: ::c_int = 21;\npub const SIGTTOU: ::c_int = 22;\npub const SIGXCPU: ::c_int = 24;\npub const SIGXFSZ: ::c_int = 25;\npub const SIGVTALRM: ::c_int = 26;\npub const SIGPROF: ::c_int = 27;\npub const SIGWINCH: ::c_int = 28;\npub const SIGUSR1: ::c_int = 10;\npub const SIGUSR2: ::c_int = 12;\npub const SIGCONT: ::c_int = 18;\npub const SIGSTOP: ::c_int = 19;\npub const SIGTSTP: ::c_int = 20;\npub const SIGURG: ::c_int = 23;\npub const SIGIO: ::c_int = 29;\npub const SIGSYS: ::c_int = 31;\npub const SIGSTKFLT: ::c_int = 16;\npub const SIGPOLL: ::c_int = 29;\npub const SIGPWR: ::c_int = 30;\npub const SIG_SETMASK: ::c_int = 2;\npub const SIG_BLOCK: ::c_int = 0x000000;\npub const SIG_UNBLOCK: ::c_int = 0x01;\n\npub const EXTPROC: ::tcflag_t = 0x10000000;\n\npub const MAP_HUGETLB: ::c_int = 0x040000;\n\npub const F_GETLK: ::c_int = 12;\npub const F_GETOWN: ::c_int = 9;\npub const F_SETLK: ::c_int = 13;\npub const F_SETLKW: ::c_int = 14;\npub const F_SETOWN: ::c_int = 8;\npub const F_OFD_GETLK: ::c_int = 36;\npub const F_OFD_SETLK: ::c_int = 37;\npub const F_OFD_SETLKW: ::c_int = 38;\n\npub const VEOF: usize = 4;\npub const VEOL: usize = 6;\npub const VEOL2: usize = 8;\npub const VMIN: usize = 5;\npub const IEXTEN: ::tcflag_t = 0x00000400;\npub const TOSTOP: ::tcflag_t = 0x00400000;\npub const FLUSHO: ::tcflag_t = 0x00800000;\n\npub const TCGETS: ::c_int = 0x402C7413;\npub const TCSETS: ::c_int = 0x802C7414;\npub const TCSETSW: ::c_int = 0x802C7415;\npub const TCSETSF: ::c_int = 0x802C7416;\npub const TCGETA: ::c_int = 0x40147417;\npub const TCSETA: ::c_int = 0x80147418;\npub const TCSETAW: ::c_int = 0x80147419;\npub const TCSETAF: ::c_int = 0x8014741C;\npub const TCSBRK: ::c_int = 0x2000741D;\npub const TCXONC: ::c_int = 0x2000741E;\npub const TCFLSH: ::c_int = 0x2000741F;\npub const TIOCGSOFTCAR: ::c_int = 0x5419;\npub const TIOCSSOFTCAR: ::c_int = 0x541A;\npub const TIOCLINUX: ::c_int = 0x541C;\npub const TIOCGSERIAL: ::c_int = 0x541E;\npub const TIOCEXCL: ::c_int = 0x540C;\npub const TIOCNXCL: ::c_int = 0x540D;\npub const TIOCSCTTY: ::c_int = 0x540E;\npub const TIOCGPGRP: ::c_int = 0x40047477;\npub const TIOCSPGRP: ::c_int = 0x80047476;\npub const TIOCOUTQ: ::c_int = 0x40047473;\npub const TIOCSTI: ::c_int = 0x5412;\npub const TIOCGWINSZ: ::c_int = 0x40087468;\npub const TIOCSWINSZ: ::c_int = 0x80087467;\npub const TIOCMGET: ::c_int = 0x5415;\npub const TIOCMBIS: ::c_int = 0x5416;\npub const TIOCMBIC: ::c_int = 0x5417;\npub const TIOCMSET: ::c_int = 0x5418;\npub const FIONREAD: ::c_int = 0x4004667F;\npub const TIOCCONS: ::c_int = 0x541D;\n\npub const TIOCGRS485: ::c_int = 0x542e;\npub const TIOCSRS485: ::c_int = 0x542f;\n\npub const POLLWRNORM: ::c_short = 0x100;\npub const POLLWRBAND: ::c_short = 0x200;\n\npub const TIOCM_LE: ::c_int = 0x001;\npub const TIOCM_DTR: ::c_int = 0x002;\npub const TIOCM_RTS: ::c_int = 0x004;\npub const TIOCM_ST: ::c_int = 0x008;\npub const TIOCM_SR: ::c_int = 0x010;\npub const TIOCM_CTS: ::c_int = 0x020;\npub const TIOCM_CAR: ::c_int = 0x040;\npub const TIOCM_RNG: ::c_int = 0x080;\npub const TIOCM_DSR: ::c_int = 0x100;\npub const TIOCM_CD: ::c_int = TIOCM_CAR;\npub const TIOCM_RI: ::c_int = TIOCM_RNG;\n\n// Syscall table\npub const SYS_restart_syscall: ::c_long = 0;\npub const SYS_exit: ::c_long = 1;\npub const SYS_fork: ::c_long = 2;\npub const SYS_read: ::c_long = 3;\npub const SYS_write: ::c_long = 4;\npub const SYS_open: ::c_long = 5;\npub const SYS_close: ::c_long = 6;\npub const SYS_waitpid: ::c_long = 7;\npub const SYS_creat: ::c_long = 8;\npub const SYS_link: ::c_long = 9;\npub const SYS_unlink: ::c_long = 10;\npub const SYS_execve: ::c_long = 11;\npub const SYS_chdir: ::c_long = 12;\npub const SYS_time: ::c_long = 13;\npub const SYS_mknod: ::c_long = 14;\npub const SYS_chmod: ::c_long = 15;\npub const SYS_lchown: ::c_long = 16;\npub const SYS_break: ::c_long = 17;\npub const SYS_oldstat: ::c_long = 18;\npub const SYS_lseek: ::c_long = 19;\npub const SYS_getpid: ::c_long = 20;\npub const SYS_mount: ::c_long = 21;\npub const SYS_umount: ::c_long = 22;\npub const SYS_setuid: ::c_long = 23;\npub const SYS_getuid: ::c_long = 24;\npub const SYS_stime: ::c_long = 25;\npub const SYS_ptrace: ::c_long = 26;\npub const SYS_alarm: ::c_long = 27;\npub const SYS_oldfstat: ::c_long = 28;\npub const SYS_pause: ::c_long = 29;\npub const SYS_utime: ::c_long = 30;\npub const SYS_stty: ::c_long = 31;\npub const SYS_gtty: ::c_long = 32;\npub const SYS_access: ::c_long = 33;\npub const SYS_nice: ::c_long = 34;\npub const SYS_ftime: ::c_long = 35;\npub const SYS_sync: ::c_long = 36;\npub const SYS_kill: ::c_long = 37;\npub const SYS_rename: ::c_long = 38;\npub const SYS_mkdir: ::c_long = 39;\npub const SYS_rmdir: ::c_long = 40;\npub const SYS_dup: ::c_long = 41;\npub const SYS_pipe: ::c_long = 42;\npub const SYS_times: ::c_long = 43;\npub const SYS_prof: ::c_long = 44;\npub const SYS_brk: ::c_long = 45;\npub const SYS_setgid: ::c_long = 46;\npub const SYS_getgid: ::c_long = 47;\npub const SYS_signal: ::c_long = 48;\npub const SYS_geteuid: ::c_long = 49;\npub const SYS_getegid: ::c_long = 50;\npub const SYS_acct: ::c_long = 51;\npub const SYS_umount2: ::c_long = 52;\npub const SYS_lock: ::c_long = 53;\npub const SYS_ioctl: ::c_long = 54;\npub const SYS_fcntl: ::c_long = 55;\npub const SYS_mpx: ::c_long = 56;\npub const SYS_setpgid: ::c_long = 57;\npub const SYS_ulimit: ::c_long = 58;\npub const SYS_oldolduname: ::c_long = 59;\npub const SYS_umask: ::c_long = 60;\npub const SYS_chroot: ::c_long = 61;\npub const SYS_ustat: ::c_long = 62;\npub const SYS_dup2: ::c_long = 63;\npub const SYS_getppid: ::c_long = 64;\npub const SYS_getpgrp: ::c_long = 65;\npub const SYS_setsid: ::c_long = 66;\npub const SYS_sigaction: ::c_long = 67;\npub const SYS_sgetmask: ::c_long = 68;\npub const SYS_ssetmask: ::c_long = 69;\npub const SYS_setreuid: ::c_long = 70;\npub const SYS_setregid: ::c_long = 71;\npub const SYS_sigsuspend: ::c_long = 72;\npub const SYS_sigpending: ::c_long = 73;\npub const SYS_sethostname: ::c_long = 74;\npub const SYS_setrlimit: ::c_long = 75;\npub const SYS_getrlimit: ::c_long = 76;\npub const SYS_getrusage: ::c_long = 77;\npub const SYS_gettimeofday: ::c_long = 78;\npub const SYS_settimeofday: ::c_long = 79;\npub const SYS_getgroups: ::c_long = 80;\npub const SYS_setgroups: ::c_long = 81;\npub const SYS_select: ::c_long = 82;\npub const SYS_symlink: ::c_long = 83;\npub const SYS_oldlstat: ::c_long = 84;\npub const SYS_readlink: ::c_long = 85;\npub const SYS_uselib: ::c_long = 86;\npub const SYS_swapon: ::c_long = 87;\npub const SYS_reboot: ::c_long = 88;\npub const SYS_readdir: ::c_long = 89;\npub const SYS_mmap: ::c_long = 90;\npub const SYS_munmap: ::c_long = 91;\npub const SYS_truncate: ::c_long = 92;\npub const SYS_ftruncate: ::c_long = 93;\npub const SYS_fchmod: ::c_long = 94;\npub const SYS_fchown: ::c_long = 95;\npub const SYS_getpriority: ::c_long = 96;\npub const SYS_setpriority: ::c_long = 97;\npub const SYS_profil: ::c_long = 98;\npub const SYS_statfs: ::c_long = 99;\npub const SYS_fstatfs: ::c_long = 100;\npub const SYS_ioperm: ::c_long = 101;\npub const SYS_socketcall: ::c_long = 102;\npub const SYS_syslog: ::c_long = 103;\npub const SYS_setitimer: ::c_long = 104;\npub const SYS_getitimer: ::c_long = 105;\npub const SYS_stat: ::c_long = 106;\npub const SYS_lstat: ::c_long = 107;\npub const SYS_fstat: ::c_long = 108;\npub const SYS_olduname: ::c_long = 109;\npub const SYS_iopl: ::c_long = 110;\npub const SYS_vhangup: ::c_long = 111;\npub const SYS_idle: ::c_long = 112;\npub const SYS_vm86: ::c_long = 113;\npub const SYS_wait4: ::c_long = 114;\npub const SYS_swapoff: ::c_long = 115;\npub const SYS_sysinfo: ::c_long = 116;\npub const SYS_ipc: ::c_long = 117;\npub const SYS_fsync: ::c_long = 118;\npub const SYS_sigreturn: ::c_long = 119;\npub const SYS_clone: ::c_long = 120;\npub const SYS_setdomainname: ::c_long = 121;\npub const SYS_uname: ::c_long = 122;\npub const SYS_modify_ldt: ::c_long = 123;\npub const SYS_adjtimex: ::c_long = 124;\npub const SYS_mprotect: ::c_long = 125;\npub const SYS_sigprocmask: ::c_long = 126;\npub const SYS_create_module: ::c_long = 127;\npub const SYS_init_module: ::c_long = 128;\npub const SYS_delete_module: ::c_long = 129;\npub const SYS_get_kernel_syms: ::c_long = 130;\npub const SYS_quotactl: ::c_long = 131;\npub const SYS_getpgid: ::c_long = 132;\npub const SYS_fchdir: ::c_long = 133;\npub const SYS_bdflush: ::c_long = 134;\npub const SYS_sysfs: ::c_long = 135;\npub const SYS_personality: ::c_long = 136;\npub const SYS_afs_syscall: ::c_long = 137;\npub const SYS_setfsuid: ::c_long = 138;\npub const SYS_setfsgid: ::c_long = 139;\npub const SYS__llseek: ::c_long = 140;\npub const SYS_getdents: ::c_long = 141;\npub const SYS__newselect: ::c_long = 142;\npub const SYS_flock: ::c_long = 143;\npub const SYS_msync: ::c_long = 144;\npub const SYS_readv: ::c_long = 145;\npub const SYS_writev: ::c_long = 146;\npub const SYS_getsid: ::c_long = 147;\npub const SYS_fdatasync: ::c_long = 148;\npub const SYS__sysctl: ::c_long = 149;\npub const SYS_mlock: ::c_long = 150;\npub const SYS_munlock: ::c_long = 151;\npub const SYS_mlockall: ::c_long = 152;\npub const SYS_munlockall: ::c_long = 153;\npub const SYS_sched_setparam: ::c_long = 154;\npub const SYS_sched_getparam: ::c_long = 155;\npub const SYS_sched_setscheduler: ::c_long = 156;\npub const SYS_sched_getscheduler: ::c_long = 157;\npub const SYS_sched_yield: ::c_long = 158;\npub const SYS_sched_get_priority_max: ::c_long = 159;\npub const SYS_sched_get_priority_min: ::c_long = 160;\npub const SYS_sched_rr_get_interval: ::c_long = 161;\npub const SYS_nanosleep: ::c_long = 162;\npub const SYS_mremap: ::c_long = 163;\npub const SYS_setresuid: ::c_long = 164;\npub const SYS_getresuid: ::c_long = 165;\npub const SYS_query_module: ::c_long = 166;\npub const SYS_poll: ::c_long = 167;\npub const SYS_nfsservctl: ::c_long = 168;\npub const SYS_setresgid: ::c_long = 169;\npub const SYS_getresgid: ::c_long = 170;\npub const SYS_prctl: ::c_long = 171;\npub const SYS_rt_sigreturn: ::c_long = 172;\npub const SYS_rt_sigaction: ::c_long = 173;\npub const SYS_rt_sigprocmask: ::c_long = 174;\npub const SYS_rt_sigpending: ::c_long = 175;\npub const SYS_rt_sigtimedwait: ::c_long = 176;\npub const SYS_rt_sigqueueinfo: ::c_long = 177;\npub const SYS_rt_sigsuspend: ::c_long = 178;\npub const SYS_pread64: ::c_long = 179;\npub const SYS_pwrite64: ::c_long = 180;\npub const SYS_chown: ::c_long = 181;\npub const SYS_getcwd: ::c_long = 182;\npub const SYS_capget: ::c_long = 183;\npub const SYS_capset: ::c_long = 184;\npub const SYS_sigaltstack: ::c_long = 185;\npub const SYS_sendfile: ::c_long = 186;\npub const SYS_getpmsg: ::c_long = 187;\npub const SYS_putpmsg: ::c_long = 188;\npub const SYS_vfork: ::c_long = 189;\npub const SYS_ugetrlimit: ::c_long = 190;\npub const SYS_readahead: ::c_long = 191;\npub const SYS_mmap2: ::c_long = 192;\npub const SYS_truncate64: ::c_long = 193;\npub const SYS_ftruncate64: ::c_long = 194;\npub const SYS_stat64: ::c_long = 195;\npub const SYS_lstat64: ::c_long = 196;\npub const SYS_fstat64: ::c_long = 197;\npub const SYS_pciconfig_read: ::c_long = 198;\npub const SYS_pciconfig_write: ::c_long = 199;\npub const SYS_pciconfig_iobase: ::c_long = 200;\npub const SYS_multiplexer: ::c_long = 201;\npub const SYS_getdents64: ::c_long = 202;\npub const SYS_pivot_root: ::c_long = 203;\npub const SYS_fcntl64: ::c_long = 204;\npub const SYS_madvise: ::c_long = 205;\npub const SYS_mincore: ::c_long = 206;\npub const SYS_gettid: ::c_long = 207;\npub const SYS_tkill: ::c_long = 208;\npub const SYS_setxattr: ::c_long = 209;\npub const SYS_lsetxattr: ::c_long = 210;\npub const SYS_fsetxattr: ::c_long = 211;\npub const SYS_getxattr: ::c_long = 212;\npub const SYS_lgetxattr: ::c_long = 213;\npub const SYS_fgetxattr: ::c_long = 214;\npub const SYS_listxattr: ::c_long = 215;\npub const SYS_llistxattr: ::c_long = 216;\npub const SYS_flistxattr: ::c_long = 217;\npub const SYS_removexattr: ::c_long = 218;\npub const SYS_lremovexattr: ::c_long = 219;\npub const SYS_fremovexattr: ::c_long = 220;\npub const SYS_futex: ::c_long = 221;\npub const SYS_sched_setaffinity: ::c_long = 222;\npub const SYS_sched_getaffinity: ::c_long = 223;\npub const SYS_tuxcall: ::c_long = 225;\npub const SYS_sendfile64: ::c_long = 226;\npub const SYS_io_setup: ::c_long = 227;\npub const SYS_io_destroy: ::c_long = 228;\npub const SYS_io_getevents: ::c_long = 229;\npub const SYS_io_submit: ::c_long = 230;\npub const SYS_io_cancel: ::c_long = 231;\npub const SYS_set_tid_address: ::c_long = 232;\npub const SYS_fadvise64: ::c_long = 233;\npub const SYS_exit_group: ::c_long = 234;\npub const SYS_lookup_dcookie: ::c_long = 235;\npub const SYS_epoll_create: ::c_long = 236;\npub const SYS_epoll_ctl: ::c_long = 237;\npub const SYS_epoll_wait: ::c_long = 238;\npub const SYS_remap_file_pages: ::c_long = 239;\npub const SYS_timer_create: ::c_long = 240;\npub const SYS_timer_settime: ::c_long = 241;\npub const SYS_timer_gettime: ::c_long = 242;\npub const SYS_timer_getoverrun: ::c_long = 243;\npub const SYS_timer_delete: ::c_long = 244;\npub const SYS_clock_settime: ::c_long = 245;\npub const SYS_clock_gettime: ::c_long = 246;\npub const SYS_clock_getres: ::c_long = 247;\npub const SYS_clock_nanosleep: ::c_long = 248;\npub const SYS_swapcontext: ::c_long = 249;\npub const SYS_tgkill: ::c_long = 250;\npub const SYS_utimes: ::c_long = 251;\npub const SYS_statfs64: ::c_long = 252;\npub const SYS_fstatfs64: ::c_long = 253;\npub const SYS_fadvise64_64: ::c_long = 254;\npub const SYS_rtas: ::c_long = 255;\npub const SYS_sys_debug_setcontext: ::c_long = 256;\npub const SYS_migrate_pages: ::c_long = 258;\npub const SYS_mbind: ::c_long = 259;\npub const SYS_get_mempolicy: ::c_long = 260;\npub const SYS_set_mempolicy: ::c_long = 261;\npub const SYS_mq_open: ::c_long = 262;\npub const SYS_mq_unlink: ::c_long = 263;\npub const SYS_mq_timedsend: ::c_long = 264;\npub const SYS_mq_timedreceive: ::c_long = 265;\npub const SYS_mq_notify: ::c_long = 266;\npub const SYS_mq_getsetattr: ::c_long = 267;\npub const SYS_kexec_load: ::c_long = 268;\npub const SYS_add_key: ::c_long = 269;\npub const SYS_request_key: ::c_long = 270;\npub const SYS_keyctl: ::c_long = 271;\npub const SYS_waitid: ::c_long = 272;\npub const SYS_ioprio_set: ::c_long = 273;\npub const SYS_ioprio_get: ::c_long = 274;\npub const SYS_inotify_init: ::c_long = 275;\npub const SYS_inotify_add_watch: ::c_long = 276;\npub const SYS_inotify_rm_watch: ::c_long = 277;\npub const SYS_spu_run: ::c_long = 278;\npub const SYS_spu_create: ::c_long = 279;\npub const SYS_pselect6: ::c_long = 280;\npub const SYS_ppoll: ::c_long = 281;\npub const SYS_unshare: ::c_long = 282;\npub const SYS_splice: ::c_long = 283;\npub const SYS_tee: ::c_long = 284;\npub const SYS_vmsplice: ::c_long = 285;\npub const SYS_openat: ::c_long = 286;\npub const SYS_mkdirat: ::c_long = 287;\npub const SYS_mknodat: ::c_long = 288;\npub const SYS_fchownat: ::c_long = 289;\npub const SYS_futimesat: ::c_long = 290;\npub const SYS_fstatat64: ::c_long = 291;\npub const SYS_unlinkat: ::c_long = 292;\npub const SYS_renameat: ::c_long = 293;\npub const SYS_linkat: ::c_long = 294;\npub const SYS_symlinkat: ::c_long = 295;\npub const SYS_readlinkat: ::c_long = 296;\npub const SYS_fchmodat: ::c_long = 297;\npub const SYS_faccessat: ::c_long = 298;\npub const SYS_get_robust_list: ::c_long = 299;\npub const SYS_set_robust_list: ::c_long = 300;\npub const SYS_move_pages: ::c_long = 301;\npub const SYS_getcpu: ::c_long = 302;\npub const SYS_epoll_pwait: ::c_long = 303;\npub const SYS_utimensat: ::c_long = 304;\npub const SYS_signalfd: ::c_long = 305;\npub const SYS_timerfd_create: ::c_long = 306;\npub const SYS_eventfd: ::c_long = 307;\npub const SYS_sync_file_range2: ::c_long = 308;\npub const SYS_fallocate: ::c_long = 309;\npub const SYS_subpage_prot: ::c_long = 310;\npub const SYS_timerfd_settime: ::c_long = 311;\npub const SYS_timerfd_gettime: ::c_long = 312;\npub const SYS_signalfd4: ::c_long = 313;\npub const SYS_eventfd2: ::c_long = 314;\npub const SYS_epoll_create1: ::c_long = 315;\npub const SYS_dup3: ::c_long = 316;\npub const SYS_pipe2: ::c_long = 317;\npub const SYS_inotify_init1: ::c_long = 318;\npub const SYS_perf_event_open: ::c_long = 319;\npub const SYS_preadv: ::c_long = 320;\npub const SYS_pwritev: ::c_long = 321;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 322;\npub const SYS_fanotify_init: ::c_long = 323;\npub const SYS_fanotify_mark: ::c_long = 324;\npub const SYS_prlimit64: ::c_long = 325;\npub const SYS_socket: ::c_long = 326;\npub const SYS_bind: ::c_long = 327;\npub const SYS_connect: ::c_long = 328;\npub const SYS_listen: ::c_long = 329;\npub const SYS_accept: ::c_long = 330;\npub const SYS_getsockname: ::c_long = 331;\npub const SYS_getpeername: ::c_long = 332;\npub const SYS_socketpair: ::c_long = 333;\npub const SYS_send: ::c_long = 334;\npub const SYS_sendto: ::c_long = 335;\npub const SYS_recv: ::c_long = 336;\npub const SYS_recvfrom: ::c_long = 337;\npub const SYS_shutdown: ::c_long = 338;\npub const SYS_setsockopt: ::c_long = 339;\npub const SYS_getsockopt: ::c_long = 340;\npub const SYS_sendmsg: ::c_long = 341;\npub const SYS_recvmsg: ::c_long = 342;\npub const SYS_recvmmsg: ::c_long = 343;\npub const SYS_accept4: ::c_long = 344;\npub const SYS_name_to_handle_at: ::c_long = 345;\npub const SYS_open_by_handle_at: ::c_long = 346;\npub const SYS_clock_adjtime: ::c_long = 347;\npub const SYS_syncfs: ::c_long = 348;\npub const SYS_sendmmsg: ::c_long = 349;\npub const SYS_setns: ::c_long = 350;\npub const SYS_process_vm_readv: ::c_long = 351;\npub const SYS_process_vm_writev: ::c_long = 352;\npub const SYS_finit_module: ::c_long = 353;\npub const SYS_kcmp: ::c_long = 354;\npub const SYS_sched_setattr: ::c_long = 355;\npub const SYS_sched_getattr: ::c_long = 356;\npub const SYS_renameat2: ::c_long = 357;\npub const SYS_seccomp: ::c_long = 358;\npub const SYS_getrandom: ::c_long = 359;\npub const SYS_memfd_create: ::c_long = 360;\npub const SYS_bpf: ::c_long = 361;\npub const SYS_execveat: ::c_long = 362;\npub const SYS_switch_endian: ::c_long = 363;\npub const SYS_userfaultfd: ::c_long = 364;\npub const SYS_membarrier: ::c_long = 365;\npub const SYS_mlock2: ::c_long = 378;\npub const SYS_copy_file_range: ::c_long = 379;\npub const SYS_preadv2: ::c_long = 380;\npub const SYS_pwritev2: ::c_long = 381;\npub const SYS_kexec_file_load: ::c_long = 382;\npub const SYS_statx: ::c_long = 383;\npub const SYS_pkey_alloc: ::c_long = 384;\npub const SYS_pkey_free: ::c_long = 385;\npub const SYS_pkey_mprotect: ::c_long = 386;\npub const SYS_pidfd_send_signal: ::c_long = 424;\npub const SYS_io_uring_setup: ::c_long = 425;\npub const SYS_io_uring_enter: ::c_long = 426;\npub const SYS_io_uring_register: ::c_long = 427;\npub const SYS_open_tree: ::c_long = 428;\npub const SYS_move_mount: ::c_long = 429;\npub const SYS_fsopen: ::c_long = 430;\npub const SYS_fsconfig: ::c_long = 431;\npub const SYS_fsmount: ::c_long = 432;\npub const SYS_fspick: ::c_long = 433;\npub const SYS_pidfd_open: ::c_long = 434;\npub const SYS_clone3: ::c_long = 435;\npub const SYS_close_range: ::c_long = 436;\npub const SYS_openat2: ::c_long = 437;\npub const SYS_pidfd_getfd: ::c_long = 438;\npub const SYS_faccessat2: ::c_long = 439;\npub const SYS_process_madvise: ::c_long = 440;\npub const SYS_epoll_pwait2: ::c_long = 441;\npub const SYS_mount_setattr: ::c_long = 442;\n\nextern \"C\" {\n    pub fn getrandom(buf: *mut ::c_void, buflen: ::size_t, flags: ::c_uint) -> ::ssize_t;\n}\n"],["1203","pub type c_char = u8;\npub type wchar_t = u32;\npub type stat64 = ::stat;\n\ns! {\n\n    pub struct stat {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::c_ulonglong,\n        pub st_mode: ::c_uint,\n        pub st_nlink: ::c_uint,\n        pub st_uid: ::c_uint,\n        pub st_gid: ::c_uint,\n        pub st_rdev: ::c_ulonglong,\n        __st_rdev_padding: ::c_ulong,\n        pub st_size: ::c_longlong,\n        pub st_blksize: ::blksize_t,\n        __st_blksize_padding: ::c_int,\n        pub st_blocks: ::blkcnt_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n\n        __unused: [::c_int;2],\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_flags: ::c_int,\n        pub ss_size: ::size_t\n    }\n\n    pub struct ipc_perm {\n        pub __ipc_perm_key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::mode_t,\n        pub __seq: ::c_ushort,\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        pub shm_segsz: ::size_t,\n        pub shm_atime: ::time_t,\n        __unused1: ::c_int,\n        pub shm_dtime: ::time_t,\n        __unused2: ::c_int,\n        pub shm_ctime: ::time_t,\n        __unused3: ::c_int,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::c_ulong,\n        __pad1: ::c_ulong,\n        __pad2: ::c_ulong,\n    }\n\n    pub struct msqid_ds {\n        pub msg_perm: ::ipc_perm,\n        pub msg_stime: ::time_t,\n        __unused1: ::c_int,\n        pub msg_rtime: ::time_t,\n        __unused2: ::c_int,\n        pub msg_ctime: ::time_t,\n        __unused3: ::c_int,\n        __msg_cbytes: ::c_ulong,\n        pub msg_qnum: ::msgqnum_t,\n        pub msg_qbytes: ::msglen_t,\n        pub msg_lspid: ::pid_t,\n        pub msg_lrpid: ::pid_t,\n        __pad1: ::c_ulong,\n        __pad2: ::c_ulong,\n    }\n\n    pub struct statfs {\n        pub f_type: ::c_ulong,\n        pub f_bsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_flags: ::c_ulong,\n        pub f_spare: [::c_ulong; 4],\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_errno: ::c_int,\n        pub si_code: ::c_int,\n        pub _pad: [::c_int; 29],\n        _align: [usize; 0],\n    }\n\n    pub struct statfs64 {\n        pub f_type: ::c_ulong,\n        pub f_bsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_flags: ::c_ulong,\n        pub f_spare: [::c_ulong; 4],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_favail: u64,\n        pub f_fsid: ::c_ulong,\n        __f_unused: ::c_int,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct termios2 {\n        pub c_iflag: ::tcflag_t,\n        pub c_oflag: ::tcflag_t,\n        pub c_cflag: ::tcflag_t,\n        pub c_lflag: ::tcflag_t,\n        pub c_line: ::cc_t,\n        pub c_cc: [::cc_t; 19],\n        pub c_ispeed: ::speed_t,\n        pub c_ospeed: ::speed_t,\n    }\n}\n\npub const AF_FILE: ::c_int = 1;\npub const AF_KCM: ::c_int = 41;\npub const AF_MAX: ::c_int = 43;\npub const AF_QIPCRTR: ::c_int = 42;\npub const EADDRINUSE: ::c_int = 98;\npub const EADDRNOTAVAIL: ::c_int = 99;\npub const EAFNOSUPPORT: ::c_int = 97;\npub const EALREADY: ::c_int = 114;\npub const EBADE: ::c_int = 52;\npub const EBADMSG: ::c_int = 74;\npub const EBADR: ::c_int = 53;\npub const EBADRQC: ::c_int = 56;\npub const EBADSLT: ::c_int = 57;\npub const ECANCELED: ::c_int = 125;\npub const ECHRNG: ::c_int = 44;\npub const ECONNABORTED: ::c_int = 103;\npub const ECONNREFUSED: ::c_int = 111;\npub const ECONNRESET: ::c_int = 104;\npub const EDEADLK: ::c_int = 35;\npub const EDEADLOCK: ::c_int = 35;\npub const EDESTADDRREQ: ::c_int = 89;\npub const EDQUOT: ::c_int = 122;\npub const EHOSTDOWN: ::c_int = 112;\npub const EHOSTUNREACH: ::c_int = 113;\npub const EHWPOISON: ::c_int = 133;\npub const EIDRM: ::c_int = 43;\npub const EILSEQ: ::c_int = 84;\npub const EINPROGRESS: ::c_int = 115;\npub const EISCONN: ::c_int = 106;\npub const EISNAM: ::c_int = 120;\npub const EKEYEXPIRED: ::c_int = 127;\npub const EKEYREJECTED: ::c_int = 129;\npub const EKEYREVOKED: ::c_int = 128;\npub const EL2HLT: ::c_int = 51;\npub const EL2NSYNC: ::c_int = 45;\npub const EL3HLT: ::c_int = 46;\npub const EL3RST: ::c_int = 47;\npub const ELIBACC: ::c_int = 79;\npub const ELIBBAD: ::c_int = 80;\npub const ELIBEXEC: ::c_int = 83;\npub const ELIBMAX: ::c_int = 82;\npub const ELIBSCN: ::c_int = 81;\npub const ELNRNG: ::c_int = 48;\npub const ELOOP: ::c_int = 40;\npub const EMEDIUMTYPE: ::c_int = 124;\npub const EMSGSIZE: ::c_int = 90;\npub const EMULTIHOP: ::c_int = 72;\npub const ENAMETOOLONG: ::c_int = 36;\npub const ENAVAIL: ::c_int = 119;\npub const ENETDOWN: ::c_int = 100;\npub const ENETRESET: ::c_int = 102;\npub const ENETUNREACH: ::c_int = 101;\npub const ENOANO: ::c_int = 55;\npub const ENOBUFS: ::c_int = 105;\npub const ENOCSI: ::c_int = 50;\npub const ENOKEY: ::c_int = 126;\npub const ENOLCK: ::c_int = 37;\npub const ENOMEDIUM: ::c_int = 123;\npub const ENOMSG: ::c_int = 42;\npub const ENOPROTOOPT: ::c_int = 92;\npub const ENOSYS: ::c_int = 38;\npub const ENOTCONN: ::c_int = 107;\npub const ENOTEMPTY: ::c_int = 39;\npub const ENOTNAM: ::c_int = 118;\npub const ENOTRECOVERABLE: ::c_int = 131;\npub const ENOTSOCK: ::c_int = 88;\npub const ENOTSUP: ::c_int = 95;\npub const ENOTUNIQ: ::c_int = 76;\npub const EOPNOTSUPP: ::c_int = 95;\npub const EOVERFLOW: ::c_int = 75;\npub const EOWNERDEAD: ::c_int = 130;\npub const EPFNOSUPPORT: ::c_int = 96;\npub const EREMCHG: ::c_int = 78;\npub const ERESTART: ::c_int = 85;\npub const ERFKILL: ::c_int = 132;\npub const ESHUTDOWN: ::c_int = 108;\npub const ESOCKTNOSUPPORT: ::c_int = 94;\npub const ESTALE: ::c_int = 116;\npub const ESTRPIPE: ::c_int = 86;\npub const ETOOMANYREFS: ::c_int = 109;\npub const ETIMEDOUT: ::c_int = 110;\npub const EUCLEAN: ::c_int = 117;\npub const EUNATCH: ::c_int = 49;\npub const EUSERS: ::c_int = 87;\npub const EXFULL: ::c_int = 54;\npub const EXTPROC: ::c_int = 65536;\npub const F_EXLCK: ::c_int = 4;\npub const F_GETLK: ::c_int = 12;\npub const F_GETOWN: ::c_int = 9;\npub const F_GETOWNER_UIDS: ::c_int = 17;\npub const F_GETOWN_EX: ::c_int = 16;\npub const F_GETSIG: ::c_int = 11;\npub const FIOASYNC: ::c_int = 21586;\npub const FIOCLEX: ::c_int = 21585;\npub const FIONBIO: ::c_int = 21537;\npub const FIONCLEX: ::c_int = 21584;\npub const FIONREAD: ::c_int = 21531;\npub const FIOQSIZE: ::c_int = 21600;\npub const F_LINUX_SPECIFIC_BASE: ::c_int = 1024;\npub const FLUSHO: ::c_int = 4096;\npub const F_OFD_GETLK: ::c_int = 36;\npub const F_OFD_SETLK: ::c_int = 37;\npub const F_OFD_SETLKW: ::c_int = 38;\npub const F_OWNER_PGRP: ::c_int = 2;\npub const F_OWNER_PID: ::c_int = 1;\npub const F_OWNER_TID: ::c_int = 0;\npub const F_SETLK: ::c_int = 13;\npub const F_SETLKW: ::c_int = 14;\npub const F_SETOWN: ::c_int = 8;\npub const F_SETOWN_EX: ::c_int = 15;\npub const F_SETSIG: ::c_int = 10;\npub const F_SHLCK: ::c_int = 8;\npub const IEXTEN: ::c_int = 32768;\npub const MAP_ANON: ::c_int = 32;\npub const MAP_DENYWRITE: ::c_int = 2048;\npub const MAP_EXECUTABLE: ::c_int = 4096;\npub const MAP_GROWSDOWN: ::c_int = 256;\npub const MAP_HUGETLB: ::c_int = 262144;\npub const MAP_LOCKED: ::c_int = 8192;\npub const MAP_NONBLOCK: ::c_int = 65536;\npub const MAP_NORESERVE: ::c_int = 16384;\npub const MAP_POPULATE: ::c_int = 32768;\npub const MAP_STACK: ::c_int = 131072;\npub const MAP_UNINITIALIZED: ::c_int = 0;\npub const O_APPEND: ::c_int = 1024;\npub const O_ASYNC: ::c_int = 8192;\npub const O_CREAT: ::c_int = 64;\npub const O_DIRECT: ::c_int = 16384;\npub const O_DIRECTORY: ::c_int = 65536;\npub const O_DSYNC: ::c_int = 4096;\npub const O_EXCL: ::c_int = 128;\npub const O_LARGEFILE: ::c_int = 32768;\npub const O_NOCTTY: ::c_int = 256;\npub const O_NOFOLLOW: ::c_int = 131072;\npub const O_NONBLOCK: ::c_int = 2048;\npub const O_SYNC: ::c_int = 1052672;\npub const PF_FILE: ::c_int = 1;\npub const PF_KCM: ::c_int = 41;\npub const PF_MAX: ::c_int = 43;\npub const PF_QIPCRTR: ::c_int = 42;\npub const RLIMIT_AS: ::c_int = 9;\npub const RLIMIT_MEMLOCK: ::c_int = 8;\npub const RLIMIT_NOFILE: ::c_int = 7;\npub const RLIMIT_NPROC: ::c_int = 6;\npub const RLIMIT_RSS: ::c_int = 5;\n#[deprecated(since = \"0.2.64\", note = \"Not stable across OS versions\")]\npub const RLIM_NLIMITS: ::c_int = 16;\npub const SA_ONSTACK: ::c_int = 0x08000000;\npub const SA_SIGINFO: ::c_int = 0x00000004;\npub const SA_NOCLDWAIT: ::c_int = 0x00000002;\npub const SIGBUS: ::c_int = 7;\npub const SIGCHLD: ::c_int = 17;\npub const SIGCONT: ::c_int = 18;\npub const SIGIO: ::c_int = 29;\npub const SIGPOLL: ::c_int = 29;\npub const SIGPROF: ::c_int = 27;\npub const SIGPWR: ::c_int = 30;\npub const SIGSTKFLT: ::c_int = 16;\npub const SIGSTKSZ: ::size_t = 8192;\npub const MINSIGSTKSZ: ::size_t = 2048;\npub const SIGSTOP: ::c_int = 19;\npub const SIGSYS: ::c_int = 31;\npub const SIGTSTP: ::c_int = 20;\npub const SIGTTIN: ::c_int = 21;\npub const SIGTTOU: ::c_int = 22;\npub const SIGURG: ::c_int = 23;\npub const SIGUSR1: ::c_int = 10;\npub const SIGUSR2: ::c_int = 12;\npub const SIGVTALRM: ::c_int = 26;\npub const SIGWINCH: ::c_int = 28;\npub const SIGXCPU: ::c_int = 24;\npub const SIGXFSZ: ::c_int = 25;\npub const SIG_SETMASK: ::c_int = 2; // FIXME check these\npub const SIG_BLOCK: ::c_int = 0x000000;\npub const SIG_UNBLOCK: ::c_int = 0x01;\npub const SOCK_DGRAM: ::c_int = 2;\npub const SOCK_NONBLOCK: ::c_int = 2048;\npub const SOCK_SEQPACKET: ::c_int = 5;\npub const SOCK_STREAM: ::c_int = 1;\npub const SOL_CAIF: ::c_int = 278;\npub const SOL_IUCV: ::c_int = 277;\npub const SOL_KCM: ::c_int = 281;\npub const SOL_NFC: ::c_int = 280;\npub const SOL_PNPIPE: ::c_int = 275;\npub const SOL_PPPOL2TP: ::c_int = 273;\npub const SOL_RDS: ::c_int = 276;\npub const SOL_RXRPC: ::c_int = 272;\n\npub const SYS3264_fadvise64: ::c_int = 223;\npub const SYS3264_fcntl: ::c_int = 25;\npub const SYS3264_fstatat: ::c_int = 79;\npub const SYS3264_fstat: ::c_int = 80;\npub const SYS3264_fstatfs: ::c_int = 44;\npub const SYS3264_ftruncate: ::c_int = 46;\npub const SYS3264_lseek: ::c_int = 62;\npub const SYS3264_lstat: ::c_int = 1039;\npub const SYS3264_mmap: ::c_int = 222;\npub const SYS3264_sendfile: ::c_int = 71;\npub const SYS3264_stat: ::c_int = 1038;\npub const SYS3264_statfs: ::c_int = 43;\npub const SYS3264_truncate: ::c_int = 45;\npub const SYS_accept4: ::c_int = 242;\npub const SYS_accept: ::c_int = 202;\npub const SYS_access: ::c_int = 1033;\npub const SYS_acct: ::c_int = 89;\npub const SYS_add_key: ::c_int = 217;\npub const SYS_adjtimex: ::c_int = 171;\npub const SYS_alarm: ::c_int = 1059;\npub const SYS_arch_specific_syscall: ::c_int = 244;\npub const SYS_bdflush: ::c_int = 1075;\npub const SYS_bind: ::c_int = 200;\npub const SYS_bpf: ::c_int = 280;\npub const SYS_brk: ::c_int = 214;\npub const SYS_capget: ::c_int = 90;\npub const SYS_capset: ::c_int = 91;\npub const SYS_chdir: ::c_int = 49;\npub const SYS_chmod: ::c_int = 1028;\npub const SYS_chown: ::c_int = 1029;\npub const SYS_chroot: ::c_int = 51;\npub const SYS_clock_adjtime: ::c_int = 266;\npub const SYS_clock_getres: ::c_int = 114;\npub const SYS_clock_gettime: ::c_int = 113;\npub const SYS_clock_nanosleep: ::c_int = 115;\npub const SYS_clock_settime: ::c_int = 112;\npub const SYS_clone: ::c_int = 220;\npub const SYS_close: ::c_int = 57;\npub const SYS_connect: ::c_int = 203;\npub const SYS_copy_file_range: ::c_int = -1; // FIXME\npub const SYS_creat: ::c_int = 1064;\npub const SYS_delete_module: ::c_int = 106;\npub const SYS_dup2: ::c_int = 1041;\npub const SYS_dup3: ::c_int = 24;\npub const SYS_dup: ::c_int = 23;\npub const SYS_epoll_create1: ::c_int = 20;\npub const SYS_epoll_create: ::c_int = 1042;\npub const SYS_epoll_ctl: ::c_int = 21;\npub const SYS_epoll_pwait: ::c_int = 22;\npub const SYS_epoll_wait: ::c_int = 1069;\npub const SYS_eventfd2: ::c_int = 19;\npub const SYS_eventfd: ::c_int = 1044;\npub const SYS_execveat: ::c_int = 281;\npub const SYS_execve: ::c_int = 221;\npub const SYS_exit: ::c_int = 93;\npub const SYS_exit_group: ::c_int = 94;\npub const SYS_faccessat: ::c_int = 48;\npub const SYS_fadvise64_64: ::c_int = 223;\npub const SYS_fallocate: ::c_int = 47;\npub const SYS_fanotify_init: ::c_int = 262;\npub const SYS_fanotify_mark: ::c_int = 263;\npub const SYS_fchdir: ::c_int = 50;\npub const SYS_fchmodat: ::c_int = 53;\npub const SYS_fchmod: ::c_int = 52;\npub const SYS_fchownat: ::c_int = 54;\npub const SYS_fchown: ::c_int = 55;\npub const SYS_fcntl64: ::c_int = 25;\npub const SYS_fcntl: ::c_int = 25;\npub const SYS_fdatasync: ::c_int = 83;\npub const SYS_fgetxattr: ::c_int = 10;\npub const SYS_finit_module: ::c_int = 273;\npub const SYS_flistxattr: ::c_int = 13;\npub const SYS_flock: ::c_int = 32;\npub const SYS_fork: ::c_int = 1079;\npub const SYS_fremovexattr: ::c_int = 16;\npub const SYS_fsetxattr: ::c_int = 7;\npub const SYS_fstat64: ::c_int = 80;\npub const SYS_fstatat64: ::c_int = 79;\npub const SYS_fstatfs64: ::c_int = 44;\npub const SYS_fstatfs: ::c_int = 44;\npub const SYS_fsync: ::c_int = 82;\npub const SYS_ftruncate64: ::c_int = 46;\npub const SYS_ftruncate: ::c_int = 46;\npub const SYS_futex: ::c_int = 98;\npub const SYS_futimesat: ::c_int = 1066;\npub const SYS_getcpu: ::c_int = 168;\npub const SYS_getcwd: ::c_int = 17;\npub const SYS_getdents64: ::c_int = 61;\npub const SYS_getdents: ::c_int = 1065;\npub const SYS_getegid: ::c_int = 177;\npub const SYS_geteuid: ::c_int = 175;\npub const SYS_getgid: ::c_int = 176;\npub const SYS_getgroups: ::c_int = 158;\npub const SYS_getitimer: ::c_int = 102;\npub const SYS_get_mempolicy: ::c_int = 236;\npub const SYS_getpeername: ::c_int = 205;\npub const SYS_getpgid: ::c_int = 155;\npub const SYS_getpgrp: ::c_int = 1060;\npub const SYS_getpid: ::c_int = 172;\npub const SYS_getppid: ::c_int = 173;\npub const SYS_getpriority: ::c_int = 141;\npub const SYS_getrandom: ::c_int = 278;\npub const SYS_getresgid: ::c_int = 150;\npub const SYS_getresuid: ::c_int = 148;\npub const SYS_getrlimit: ::c_int = 163;\npub const SYS_get_robust_list: ::c_int = 100;\npub const SYS_getrusage: ::c_int = 165;\npub const SYS_getsid: ::c_int = 156;\npub const SYS_getsockname: ::c_int = 204;\npub const SYS_getsockopt: ::c_int = 209;\npub const SYS_gettid: ::c_int = 178;\npub const SYS_gettimeofday: ::c_int = 169;\npub const SYS_getuid: ::c_int = 174;\npub const SYS_getxattr: ::c_int = 8;\npub const SYS_init_module: ::c_int = 105;\npub const SYS_inotify_add_watch: ::c_int = 27;\npub const SYS_inotify_init1: ::c_int = 26;\npub const SYS_inotify_init: ::c_int = 1043;\npub const SYS_inotify_rm_watch: ::c_int = 28;\npub const SYS_io_cancel: ::c_int = 3;\npub const SYS_ioctl: ::c_int = 29;\npub const SYS_io_destroy: ::c_int = 1;\npub const SYS_io_getevents: ::c_int = 4;\npub const SYS_ioprio_get: ::c_int = 31;\npub const SYS_ioprio_set: ::c_int = 30;\npub const SYS_io_setup: ::c_int = 0;\npub const SYS_io_submit: ::c_int = 2;\npub const SYS_kcmp: ::c_int = 272;\npub const SYS_kexec_load: ::c_int = 104;\npub const SYS_keyctl: ::c_int = 219;\npub const SYS_kill: ::c_int = 129;\npub const SYS_lchown: ::c_int = 1032;\npub const SYS_lgetxattr: ::c_int = 9;\npub const SYS_linkat: ::c_int = 37;\npub const SYS_link: ::c_int = 1025;\npub const SYS_listen: ::c_int = 201;\npub const SYS_listxattr: ::c_int = 11;\npub const SYS_llistxattr: ::c_int = 12;\npub const SYS__llseek: ::c_int = 62;\npub const SYS_lookup_dcookie: ::c_int = 18;\npub const SYS_lremovexattr: ::c_int = 15;\npub const SYS_lseek: ::c_int = 62;\npub const SYS_lsetxattr: ::c_int = 6;\npub const SYS_lstat64: ::c_int = 1039;\npub const SYS_lstat: ::c_int = 1039;\npub const SYS_madvise: ::c_int = 233;\npub const SYS_mbind: ::c_int = 235;\npub const SYS_memfd_create: ::c_int = 279;\npub const SYS_migrate_pages: ::c_int = 238;\npub const SYS_mincore: ::c_int = 232;\npub const SYS_mkdirat: ::c_int = 34;\npub const SYS_mkdir: ::c_int = 1030;\npub const SYS_mknodat: ::c_int = 33;\npub const SYS_mknod: ::c_int = 1027;\npub const SYS_mlockall: ::c_int = 230;\npub const SYS_mlock: ::c_int = 228;\npub const SYS_mmap2: ::c_int = 222;\npub const SYS_mount: ::c_int = 40;\npub const SYS_move_pages: ::c_int = 239;\npub const SYS_mprotect: ::c_int = 226;\npub const SYS_mq_getsetattr: ::c_int = 185;\npub const SYS_mq_notify: ::c_int = 184;\npub const SYS_mq_open: ::c_int = 180;\npub const SYS_mq_timedreceive: ::c_int = 183;\npub const SYS_mq_timedsend: ::c_int = 182;\npub const SYS_mq_unlink: ::c_int = 181;\npub const SYS_mremap: ::c_int = 216;\npub const SYS_msgctl: ::c_int = 187;\npub const SYS_msgget: ::c_int = 186;\npub const SYS_msgrcv: ::c_int = 188;\npub const SYS_msgsnd: ::c_int = 189;\npub const SYS_msync: ::c_int = 227;\npub const SYS_munlockall: ::c_int = 231;\npub const SYS_munlock: ::c_int = 229;\npub const SYS_munmap: ::c_int = 215;\npub const SYS_name_to_handle_at: ::c_int = 264;\npub const SYS_nanosleep: ::c_int = 101;\npub const SYS_newfstatat: ::c_int = 79;\npub const SYS_nfsservctl: ::c_int = 42;\npub const SYS_oldwait4: ::c_int = 1072;\npub const SYS_openat: ::c_int = 56;\npub const SYS_open_by_handle_at: ::c_int = 265;\npub const SYS_open: ::c_int = 1024;\npub const SYS_pause: ::c_int = 1061;\npub const SYS_perf_event_open: ::c_int = 241;\npub const SYS_personality: ::c_int = 92;\npub const SYS_pipe2: ::c_int = 59;\npub const SYS_pipe: ::c_int = 1040;\npub const SYS_pivot_root: ::c_int = 41;\npub const SYS_poll: ::c_int = 1068;\npub const SYS_ppoll: ::c_int = 73;\npub const SYS_prctl: ::c_int = 167;\npub const SYS_pread64: ::c_int = 67;\npub const SYS_preadv: ::c_int = 69;\npub const SYS_prlimit64: ::c_int = 261;\npub const SYS_process_vm_readv: ::c_int = 270;\npub const SYS_process_vm_writev: ::c_int = 271;\npub const SYS_pselect6: ::c_int = 72;\npub const SYS_ptrace: ::c_int = 117;\npub const SYS_pwrite64: ::c_int = 68;\npub const SYS_pwritev: ::c_int = 70;\npub const SYS_quotactl: ::c_int = 60;\npub const SYS_readahead: ::c_int = 213;\npub const SYS_read: ::c_int = 63;\npub const SYS_readlinkat: ::c_int = 78;\npub const SYS_readlink: ::c_int = 1035;\npub const SYS_readv: ::c_int = 65;\npub const SYS_reboot: ::c_int = 142;\npub const SYS_recv: ::c_int = 1073;\npub const SYS_recvfrom: ::c_int = 207;\npub const SYS_recvmmsg: ::c_int = 243;\npub const SYS_recvmsg: ::c_int = 212;\npub const SYS_remap_file_pages: ::c_int = 234;\npub const SYS_removexattr: ::c_int = 14;\npub const SYS_renameat2: ::c_int = 276;\npub const SYS_renameat: ::c_int = 38;\npub const SYS_rename: ::c_int = 1034;\npub const SYS_request_key: ::c_int = 218;\npub const SYS_restart_syscall: ::c_int = 128;\npub const SYS_rmdir: ::c_int = 1031;\npub const SYS_rt_sigaction: ::c_int = 134;\npub const SYS_rt_sigpending: ::c_int = 136;\npub const SYS_rt_sigprocmask: ::c_int = 135;\npub const SYS_rt_sigqueueinfo: ::c_int = 138;\npub const SYS_rt_sigreturn: ::c_int = 139;\npub const SYS_rt_sigsuspend: ::c_int = 133;\npub const SYS_rt_sigtimedwait: ::c_int = 137;\npub const SYS_rt_tgsigqueueinfo: ::c_int = 240;\npub const SYS_sched_getaffinity: ::c_int = 123;\npub const SYS_sched_getattr: ::c_int = 275;\npub const SYS_sched_getparam: ::c_int = 121;\npub const SYS_sched_get_priority_max: ::c_int = 125;\npub const SYS_sched_get_priority_min: ::c_int = 126;\npub const SYS_sched_getscheduler: ::c_int = 120;\npub const SYS_sched_rr_get_interval: ::c_int = 127;\npub const SYS_sched_setaffinity: ::c_int = 122;\npub const SYS_sched_setattr: ::c_int = 274;\npub const SYS_sched_setparam: ::c_int = 118;\npub const SYS_sched_setscheduler: ::c_int = 119;\npub const SYS_sched_yield: ::c_int = 124;\npub const SYS_seccomp: ::c_int = 277;\npub const SYS_select: ::c_int = 1067;\npub const SYS_semctl: ::c_int = 191;\npub const SYS_semget: ::c_int = 190;\npub const SYS_semop: ::c_int = 193;\npub const SYS_semtimedop: ::c_int = 192;\npub const SYS_send: ::c_int = 1074;\npub const SYS_sendfile64: ::c_int = 71;\npub const SYS_sendfile: ::c_int = 71;\npub const SYS_sendmmsg: ::c_int = 269;\npub const SYS_sendmsg: ::c_int = 211;\npub const SYS_sendto: ::c_int = 206;\npub const SYS_setdomainname: ::c_int = 162;\npub const SYS_setfsgid: ::c_int = 152;\npub const SYS_setfsuid: ::c_int = 151;\npub const SYS_setgid: ::c_int = 144;\npub const SYS_setgroups: ::c_int = 159;\npub const SYS_sethostname: ::c_int = 161;\npub const SYS_setitimer: ::c_int = 103;\npub const SYS_set_mempolicy: ::c_int = 237;\npub const SYS_setns: ::c_int = 268;\npub const SYS_setpgid: ::c_int = 154;\npub const SYS_setpriority: ::c_int = 140;\npub const SYS_setregid: ::c_int = 143;\npub const SYS_setresgid: ::c_int = 149;\npub const SYS_setresuid: ::c_int = 147;\npub const SYS_setreuid: ::c_int = 145;\npub const SYS_setrlimit: ::c_int = 164;\npub const SYS_set_robust_list: ::c_int = 99;\npub const SYS_setsid: ::c_int = 157;\npub const SYS_setsockopt: ::c_int = 208;\npub const SYS_set_tid_address: ::c_int = 96;\npub const SYS_settimeofday: ::c_int = 170;\npub const SYS_setuid: ::c_int = 146;\npub const SYS_setxattr: ::c_int = 5;\npub const SYS_shmat: ::c_int = 196;\npub const SYS_shmctl: ::c_int = 195;\npub const SYS_shmdt: ::c_int = 197;\npub const SYS_shmget: ::c_int = 194;\npub const SYS_shutdown: ::c_int = 210;\npub const SYS_sigaltstack: ::c_int = 132;\npub const SYS_signalfd4: ::c_int = 74;\npub const SYS_signalfd: ::c_int = 1045;\npub const SYS_socket: ::c_int = 198;\npub const SYS_socketpair: ::c_int = 199;\npub const SYS_splice: ::c_int = 76;\npub const SYS_stat64: ::c_int = 1038;\npub const SYS_stat: ::c_int = 1038;\npub const SYS_statfs64: ::c_int = 43;\npub const SYS_swapoff: ::c_int = 225;\npub const SYS_swapon: ::c_int = 224;\npub const SYS_symlinkat: ::c_int = 36;\npub const SYS_symlink: ::c_int = 1036;\npub const SYS_sync: ::c_int = 81;\npub const SYS_sync_file_range2: ::c_int = 84;\npub const SYS_sync_file_range: ::c_int = 84;\npub const SYS_syncfs: ::c_int = 267;\npub const SYS_syscalls: ::c_int = 1080;\npub const SYS__sysctl: ::c_int = 1078;\npub const SYS_sysinfo: ::c_int = 179;\npub const SYS_syslog: ::c_int = 116;\npub const SYS_tee: ::c_int = 77;\npub const SYS_tgkill: ::c_int = 131;\npub const SYS_time: ::c_int = 1062;\npub const SYS_timer_create: ::c_int = 107;\npub const SYS_timer_delete: ::c_int = 111;\npub const SYS_timerfd_create: ::c_int = 85;\npub const SYS_timerfd_gettime: ::c_int = 87;\npub const SYS_timerfd_settime: ::c_int = 86;\npub const SYS_timer_getoverrun: ::c_int = 109;\npub const SYS_timer_gettime: ::c_int = 108;\npub const SYS_timer_settime: ::c_int = 110;\npub const SYS_times: ::c_int = 153;\npub const SYS_tkill: ::c_int = 130;\npub const SYS_truncate64: ::c_int = 45;\npub const SYS_truncate: ::c_int = 45;\npub const SYS_umask: ::c_int = 166;\npub const SYS_umount2: ::c_int = 39;\npub const SYS_umount: ::c_int = 1076;\npub const SYS_uname: ::c_int = 160;\npub const SYS_unlinkat: ::c_int = 35;\npub const SYS_unlink: ::c_int = 1026;\npub const SYS_unshare: ::c_int = 97;\npub const SYS_uselib: ::c_int = 1077;\npub const SYS_ustat: ::c_int = 1070;\npub const SYS_utime: ::c_int = 1063;\npub const SYS_utimensat: ::c_int = 88;\npub const SYS_utimes: ::c_int = 1037;\npub const SYS_vfork: ::c_int = 1071;\npub const SYS_vhangup: ::c_int = 58;\npub const SYS_vmsplice: ::c_int = 75;\npub const SYS_wait4: ::c_int = 260;\npub const SYS_waitid: ::c_int = 95;\npub const SYS_write: ::c_int = 64;\npub const SYS_writev: ::c_int = 66;\npub const SYS_statx: ::c_int = 291;\npub const TCFLSH: ::c_int = 21515;\npub const TCGETA: ::c_int = 21509;\npub const TCGETS: ::c_int = 21505;\npub const TCGETX: ::c_int = 21554;\npub const TCSBRK: ::c_int = 21513;\npub const TCSBRKP: ::c_int = 21541;\npub const TCSETA: ::c_int = 21510;\npub const TCSETAF: ::c_int = 21512;\npub const TCSETAW: ::c_int = 21511;\npub const TCSETS: ::c_int = 21506;\npub const TCSETSF: ::c_int = 21508;\npub const TCSETSW: ::c_int = 21507;\npub const TCSETX: ::c_int = 21555;\npub const TCSETXF: ::c_int = 21556;\npub const TCSETXW: ::c_int = 21557;\npub const TCXONC: ::c_int = 21514;\npub const TIOCCONS: ::c_int = 21533;\npub const TIOCEXCL: ::c_int = 21516;\npub const TIOCGETD: ::c_int = 21540;\npub const TIOCGICOUNT: ::c_int = 21597;\npub const TIOCGLCKTRMIOS: ::c_int = 21590;\npub const TIOCGPGRP: ::c_int = 21519;\npub const TIOCGRS485: ::c_int = 21550;\npub const TIOCGSERIAL: ::c_int = 21534;\npub const TIOCGSID: ::c_int = 21545;\npub const TIOCGSOFTCAR: ::c_int = 21529;\npub const TIOCGWINSZ: ::c_int = 21523;\npub const TIOCLINUX: ::c_int = 21532;\npub const TIOCMBIC: ::c_int = 21527;\npub const TIOCMBIS: ::c_int = 21526;\npub const TIOCM_CAR: ::c_int = 64;\npub const TIOCM_CD: ::c_int = 64;\npub const TIOCM_CTS: ::c_int = 32;\npub const TIOCM_DSR: ::c_int = 256;\npub const TIOCM_DTR: ::c_int = 2;\npub const TIOCMGET: ::c_int = 21525;\npub const TIOCMIWAIT: ::c_int = 21596;\npub const TIOCM_LE: ::c_int = 1;\npub const TIOCM_LOOP: ::c_int = 32768;\npub const TIOCM_OUT1: ::c_int = 8192;\npub const TIOCM_OUT2: ::c_int = 16384;\npub const TIOCM_RI: ::c_int = 128;\npub const TIOCM_RNG: ::c_int = 128;\npub const TIOCM_RTS: ::c_int = 4;\npub const TIOCMSET: ::c_int = 21528;\npub const TIOCM_SR: ::c_int = 16;\npub const TIOCM_ST: ::c_int = 8;\npub const TIOCNOTTY: ::c_int = 21538;\npub const TIOCNXCL: ::c_int = 21517;\npub const TIOCOUTQ: ::c_int = 21521;\npub const TIOCPKT: ::c_int = 21536;\npub const TIOCPKT_DATA: ::c_int = 0;\npub const TIOCPKT_DOSTOP: ::c_int = 32;\npub const TIOCPKT_FLUSHREAD: ::c_int = 1;\npub const TIOCPKT_FLUSHWRITE: ::c_int = 2;\npub const TIOCPKT_IOCTL: ::c_int = 64;\npub const TIOCPKT_NOSTOP: ::c_int = 16;\npub const TIOCPKT_START: ::c_int = 8;\npub const TIOCPKT_STOP: ::c_int = 4;\npub const TIOCSCTTY: ::c_int = 21518;\npub const TIOCSERCONFIG: ::c_int = 21587;\npub const TIOCSERGETLSR: ::c_int = 21593;\npub const TIOCSERGETMULTI: ::c_int = 21594;\npub const TIOCSERGSTRUCT: ::c_int = 21592;\npub const TIOCSERGWILD: ::c_int = 21588;\npub const TIOCSERSETMULTI: ::c_int = 21595;\npub const TIOCSERSWILD: ::c_int = 21589;\npub const TIOCSER_TEMT: ::c_int = 1;\npub const TIOCSETD: ::c_int = 21539;\npub const TIOCSLCKTRMIOS: ::c_int = 21591;\npub const TIOCSPGRP: ::c_int = 21520;\npub const TIOCSRS485: ::c_int = 21551;\npub const TIOCSSERIAL: ::c_int = 21535;\npub const TIOCSSOFTCAR: ::c_int = 21530;\npub const TIOCSTI: ::c_int = 21522;\npub const TIOCSWINSZ: ::c_int = 21524;\npub const TIOCVHANGUP: ::c_int = 21559;\npub const TOSTOP: ::c_int = 256;\npub const VEOF: ::c_int = 4;\npub const VEOL2: ::c_int = 16;\npub const VEOL: ::c_int = 11;\npub const VMIN: ::c_int = 6;\n"],["1204","pub type c_char = i8;\npub type wchar_t = i32;\npub type __u64 = ::c_ulong;\npub type nlink_t = u64;\npub type blksize_t = i64;\n\ns! {\n    pub struct stat {\n        pub st_dev: ::dev_t,\n        __pad1: [::c_int; 3],\n        pub st_ino: ::ino_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        __pad2: [::c_uint; 2],\n        pub st_size: ::off_t,\n        __pad3: ::c_int,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        pub st_blksize: ::blksize_t,\n        __pad4: ::c_uint,\n        pub st_blocks: ::blkcnt_t,\n        __pad5: [::c_int; 14],\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::dev_t,\n        __pad1: [::c_int; 3],\n        pub st_ino: ::ino_t,\n        pub st_mode: ::mode_t,\n        pub st_nlink: ::nlink_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        pub st_rdev: ::dev_t,\n        __pad2: [::c_uint; 2],\n        pub st_size: ::off_t,\n        __pad3: ::c_int,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        pub st_blksize: ::blksize_t,\n        __pad4: ::c_uint,\n        pub st_blocks: ::blkcnt_t,\n        __pad5: [::c_int; 14],\n    }\n\n    pub struct statfs {\n        pub f_type: ::c_ulong,\n        pub f_bsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_flags: ::c_ulong,\n        pub f_spare: [::c_ulong; 5],\n    }\n\n    pub struct statfs64 {\n        pub f_type: ::c_ulong,\n        pub f_bsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_flags: ::c_ulong,\n        pub f_spare: [::c_ulong; 5],\n    }\n\n    pub struct ipc_perm {\n        pub __ipc_perm_key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::mode_t,\n        pub __seq: ::c_int,\n        __pad1: ::c_int,\n        __unused1: ::c_ulong,\n        __unused2: ::c_ulong\n    }\n}\n\npub const SIGSTKSZ: ::size_t = 8192;\npub const MINSIGSTKSZ: ::size_t = 2048;\n\npub const SYS_read: ::c_long = 5000 + 0;\npub const SYS_write: ::c_long = 5000 + 1;\npub const SYS_open: ::c_long = 5000 + 2;\npub const SYS_close: ::c_long = 5000 + 3;\npub const SYS_stat: ::c_long = 5000 + 4;\npub const SYS_fstat: ::c_long = 5000 + 5;\npub const SYS_lstat: ::c_long = 5000 + 6;\npub const SYS_poll: ::c_long = 5000 + 7;\npub const SYS_lseek: ::c_long = 5000 + 8;\npub const SYS_mmap: ::c_long = 5000 + 9;\npub const SYS_mprotect: ::c_long = 5000 + 10;\npub const SYS_munmap: ::c_long = 5000 + 11;\npub const SYS_brk: ::c_long = 5000 + 12;\npub const SYS_rt_sigaction: ::c_long = 5000 + 13;\npub const SYS_rt_sigprocmask: ::c_long = 5000 + 14;\npub const SYS_ioctl: ::c_long = 5000 + 15;\npub const SYS_pread64: ::c_long = 5000 + 16;\npub const SYS_pwrite64: ::c_long = 5000 + 17;\npub const SYS_readv: ::c_long = 5000 + 18;\npub const SYS_writev: ::c_long = 5000 + 19;\npub const SYS_access: ::c_long = 5000 + 20;\npub const SYS_pipe: ::c_long = 5000 + 21;\npub const SYS__newselect: ::c_long = 5000 + 22;\npub const SYS_sched_yield: ::c_long = 5000 + 23;\npub const SYS_mremap: ::c_long = 5000 + 24;\npub const SYS_msync: ::c_long = 5000 + 25;\npub const SYS_mincore: ::c_long = 5000 + 26;\npub const SYS_madvise: ::c_long = 5000 + 27;\npub const SYS_shmget: ::c_long = 5000 + 28;\npub const SYS_shmat: ::c_long = 5000 + 29;\npub const SYS_shmctl: ::c_long = 5000 + 30;\npub const SYS_dup: ::c_long = 5000 + 31;\npub const SYS_dup2: ::c_long = 5000 + 32;\npub const SYS_pause: ::c_long = 5000 + 33;\npub const SYS_nanosleep: ::c_long = 5000 + 34;\npub const SYS_getitimer: ::c_long = 5000 + 35;\npub const SYS_setitimer: ::c_long = 5000 + 36;\npub const SYS_alarm: ::c_long = 5000 + 37;\npub const SYS_getpid: ::c_long = 5000 + 38;\npub const SYS_sendfile: ::c_long = 5000 + 39;\npub const SYS_socket: ::c_long = 5000 + 40;\npub const SYS_connect: ::c_long = 5000 + 41;\npub const SYS_accept: ::c_long = 5000 + 42;\npub const SYS_sendto: ::c_long = 5000 + 43;\npub const SYS_recvfrom: ::c_long = 5000 + 44;\npub const SYS_sendmsg: ::c_long = 5000 + 45;\npub const SYS_recvmsg: ::c_long = 5000 + 46;\npub const SYS_shutdown: ::c_long = 5000 + 47;\npub const SYS_bind: ::c_long = 5000 + 48;\npub const SYS_listen: ::c_long = 5000 + 49;\npub const SYS_getsockname: ::c_long = 5000 + 50;\npub const SYS_getpeername: ::c_long = 5000 + 51;\npub const SYS_socketpair: ::c_long = 5000 + 52;\npub const SYS_setsockopt: ::c_long = 5000 + 53;\npub const SYS_getsockopt: ::c_long = 5000 + 54;\npub const SYS_clone: ::c_long = 5000 + 55;\npub const SYS_fork: ::c_long = 5000 + 56;\npub const SYS_execve: ::c_long = 5000 + 57;\npub const SYS_exit: ::c_long = 5000 + 58;\npub const SYS_wait4: ::c_long = 5000 + 59;\npub const SYS_kill: ::c_long = 5000 + 60;\npub const SYS_uname: ::c_long = 5000 + 61;\npub const SYS_semget: ::c_long = 5000 + 62;\npub const SYS_semop: ::c_long = 5000 + 63;\npub const SYS_semctl: ::c_long = 5000 + 64;\npub const SYS_shmdt: ::c_long = 5000 + 65;\npub const SYS_msgget: ::c_long = 5000 + 66;\npub const SYS_msgsnd: ::c_long = 5000 + 67;\npub const SYS_msgrcv: ::c_long = 5000 + 68;\npub const SYS_msgctl: ::c_long = 5000 + 69;\npub const SYS_fcntl: ::c_long = 5000 + 70;\npub const SYS_flock: ::c_long = 5000 + 71;\npub const SYS_fsync: ::c_long = 5000 + 72;\npub const SYS_fdatasync: ::c_long = 5000 + 73;\npub const SYS_truncate: ::c_long = 5000 + 74;\npub const SYS_ftruncate: ::c_long = 5000 + 75;\npub const SYS_getdents: ::c_long = 5000 + 76;\npub const SYS_getcwd: ::c_long = 5000 + 77;\npub const SYS_chdir: ::c_long = 5000 + 78;\npub const SYS_fchdir: ::c_long = 5000 + 79;\npub const SYS_rename: ::c_long = 5000 + 80;\npub const SYS_mkdir: ::c_long = 5000 + 81;\npub const SYS_rmdir: ::c_long = 5000 + 82;\npub const SYS_creat: ::c_long = 5000 + 83;\npub const SYS_link: ::c_long = 5000 + 84;\npub const SYS_unlink: ::c_long = 5000 + 85;\npub const SYS_symlink: ::c_long = 5000 + 86;\npub const SYS_readlink: ::c_long = 5000 + 87;\npub const SYS_chmod: ::c_long = 5000 + 88;\npub const SYS_fchmod: ::c_long = 5000 + 89;\npub const SYS_chown: ::c_long = 5000 + 90;\npub const SYS_fchown: ::c_long = 5000 + 91;\npub const SYS_lchown: ::c_long = 5000 + 92;\npub const SYS_umask: ::c_long = 5000 + 93;\npub const SYS_gettimeofday: ::c_long = 5000 + 94;\npub const SYS_getrlimit: ::c_long = 5000 + 95;\npub const SYS_getrusage: ::c_long = 5000 + 96;\npub const SYS_sysinfo: ::c_long = 5000 + 97;\npub const SYS_times: ::c_long = 5000 + 98;\npub const SYS_ptrace: ::c_long = 5000 + 99;\npub const SYS_getuid: ::c_long = 5000 + 100;\npub const SYS_syslog: ::c_long = 5000 + 101;\npub const SYS_getgid: ::c_long = 5000 + 102;\npub const SYS_setuid: ::c_long = 5000 + 103;\npub const SYS_setgid: ::c_long = 5000 + 104;\npub const SYS_geteuid: ::c_long = 5000 + 105;\npub const SYS_getegid: ::c_long = 5000 + 106;\npub const SYS_setpgid: ::c_long = 5000 + 107;\npub const SYS_getppid: ::c_long = 5000 + 108;\npub const SYS_getpgrp: ::c_long = 5000 + 109;\npub const SYS_setsid: ::c_long = 5000 + 110;\npub const SYS_setreuid: ::c_long = 5000 + 111;\npub const SYS_setregid: ::c_long = 5000 + 112;\npub const SYS_getgroups: ::c_long = 5000 + 113;\npub const SYS_setgroups: ::c_long = 5000 + 114;\npub const SYS_setresuid: ::c_long = 5000 + 115;\npub const SYS_getresuid: ::c_long = 5000 + 116;\npub const SYS_setresgid: ::c_long = 5000 + 117;\npub const SYS_getresgid: ::c_long = 5000 + 118;\npub const SYS_getpgid: ::c_long = 5000 + 119;\npub const SYS_setfsuid: ::c_long = 5000 + 120;\npub const SYS_setfsgid: ::c_long = 5000 + 121;\npub const SYS_getsid: ::c_long = 5000 + 122;\npub const SYS_capget: ::c_long = 5000 + 123;\npub const SYS_capset: ::c_long = 5000 + 124;\npub const SYS_rt_sigpending: ::c_long = 5000 + 125;\npub const SYS_rt_sigtimedwait: ::c_long = 5000 + 126;\npub const SYS_rt_sigqueueinfo: ::c_long = 5000 + 127;\npub const SYS_rt_sigsuspend: ::c_long = 5000 + 128;\npub const SYS_sigaltstack: ::c_long = 5000 + 129;\npub const SYS_utime: ::c_long = 5000 + 130;\npub const SYS_mknod: ::c_long = 5000 + 131;\npub const SYS_personality: ::c_long = 5000 + 132;\npub const SYS_ustat: ::c_long = 5000 + 133;\npub const SYS_statfs: ::c_long = 5000 + 134;\npub const SYS_fstatfs: ::c_long = 5000 + 135;\npub const SYS_sysfs: ::c_long = 5000 + 136;\npub const SYS_getpriority: ::c_long = 5000 + 137;\npub const SYS_setpriority: ::c_long = 5000 + 138;\npub const SYS_sched_setparam: ::c_long = 5000 + 139;\npub const SYS_sched_getparam: ::c_long = 5000 + 140;\npub const SYS_sched_setscheduler: ::c_long = 5000 + 141;\npub const SYS_sched_getscheduler: ::c_long = 5000 + 142;\npub const SYS_sched_get_priority_max: ::c_long = 5000 + 143;\npub const SYS_sched_get_priority_min: ::c_long = 5000 + 144;\npub const SYS_sched_rr_get_interval: ::c_long = 5000 + 145;\npub const SYS_mlock: ::c_long = 5000 + 146;\npub const SYS_munlock: ::c_long = 5000 + 147;\npub const SYS_mlockall: ::c_long = 5000 + 148;\npub const SYS_munlockall: ::c_long = 5000 + 149;\npub const SYS_vhangup: ::c_long = 5000 + 150;\npub const SYS_pivot_root: ::c_long = 5000 + 151;\npub const SYS__sysctl: ::c_long = 5000 + 152;\npub const SYS_prctl: ::c_long = 5000 + 153;\npub const SYS_adjtimex: ::c_long = 5000 + 154;\npub const SYS_setrlimit: ::c_long = 5000 + 155;\npub const SYS_chroot: ::c_long = 5000 + 156;\npub const SYS_sync: ::c_long = 5000 + 157;\npub const SYS_acct: ::c_long = 5000 + 158;\npub const SYS_settimeofday: ::c_long = 5000 + 159;\npub const SYS_mount: ::c_long = 5000 + 160;\npub const SYS_umount2: ::c_long = 5000 + 161;\npub const SYS_swapon: ::c_long = 5000 + 162;\npub const SYS_swapoff: ::c_long = 5000 + 163;\npub const SYS_reboot: ::c_long = 5000 + 164;\npub const SYS_sethostname: ::c_long = 5000 + 165;\npub const SYS_setdomainname: ::c_long = 5000 + 166;\npub const SYS_create_module: ::c_long = 5000 + 167;\npub const SYS_init_module: ::c_long = 5000 + 168;\npub const SYS_delete_module: ::c_long = 5000 + 169;\npub const SYS_get_kernel_syms: ::c_long = 5000 + 170;\npub const SYS_query_module: ::c_long = 5000 + 171;\npub const SYS_quotactl: ::c_long = 5000 + 172;\npub const SYS_nfsservctl: ::c_long = 5000 + 173;\npub const SYS_getpmsg: ::c_long = 5000 + 174;\npub const SYS_putpmsg: ::c_long = 5000 + 175;\npub const SYS_afs_syscall: ::c_long = 5000 + 176;\npub const SYS_gettid: ::c_long = 5000 + 178;\npub const SYS_readahead: ::c_long = 5000 + 179;\npub const SYS_setxattr: ::c_long = 5000 + 180;\npub const SYS_lsetxattr: ::c_long = 5000 + 181;\npub const SYS_fsetxattr: ::c_long = 5000 + 182;\npub const SYS_getxattr: ::c_long = 5000 + 183;\npub const SYS_lgetxattr: ::c_long = 5000 + 184;\npub const SYS_fgetxattr: ::c_long = 5000 + 185;\npub const SYS_listxattr: ::c_long = 5000 + 186;\npub const SYS_llistxattr: ::c_long = 5000 + 187;\npub const SYS_flistxattr: ::c_long = 5000 + 188;\npub const SYS_removexattr: ::c_long = 5000 + 189;\npub const SYS_lremovexattr: ::c_long = 5000 + 190;\npub const SYS_fremovexattr: ::c_long = 5000 + 191;\npub const SYS_tkill: ::c_long = 5000 + 192;\npub const SYS_futex: ::c_long = 5000 + 194;\npub const SYS_sched_setaffinity: ::c_long = 5000 + 195;\npub const SYS_sched_getaffinity: ::c_long = 5000 + 196;\npub const SYS_cacheflush: ::c_long = 5000 + 197;\npub const SYS_cachectl: ::c_long = 5000 + 198;\npub const SYS_sysmips: ::c_long = 5000 + 199;\npub const SYS_io_setup: ::c_long = 5000 + 200;\npub const SYS_io_destroy: ::c_long = 5000 + 201;\npub const SYS_io_getevents: ::c_long = 5000 + 202;\npub const SYS_io_submit: ::c_long = 5000 + 203;\npub const SYS_io_cancel: ::c_long = 5000 + 204;\npub const SYS_exit_group: ::c_long = 5000 + 205;\npub const SYS_lookup_dcookie: ::c_long = 5000 + 206;\npub const SYS_epoll_create: ::c_long = 5000 + 207;\npub const SYS_epoll_ctl: ::c_long = 5000 + 208;\npub const SYS_epoll_wait: ::c_long = 5000 + 209;\npub const SYS_remap_file_pages: ::c_long = 5000 + 210;\npub const SYS_rt_sigreturn: ::c_long = 5000 + 211;\npub const SYS_set_tid_address: ::c_long = 5000 + 212;\npub const SYS_restart_syscall: ::c_long = 5000 + 213;\npub const SYS_semtimedop: ::c_long = 5000 + 214;\npub const SYS_fadvise64: ::c_long = 5000 + 215;\npub const SYS_timer_create: ::c_long = 5000 + 216;\npub const SYS_timer_settime: ::c_long = 5000 + 217;\npub const SYS_timer_gettime: ::c_long = 5000 + 218;\npub const SYS_timer_getoverrun: ::c_long = 5000 + 219;\npub const SYS_timer_delete: ::c_long = 5000 + 220;\npub const SYS_clock_settime: ::c_long = 5000 + 221;\npub const SYS_clock_gettime: ::c_long = 5000 + 222;\npub const SYS_clock_getres: ::c_long = 5000 + 223;\npub const SYS_clock_nanosleep: ::c_long = 5000 + 224;\npub const SYS_tgkill: ::c_long = 5000 + 225;\npub const SYS_utimes: ::c_long = 5000 + 226;\npub const SYS_mbind: ::c_long = 5000 + 227;\npub const SYS_get_mempolicy: ::c_long = 5000 + 228;\npub const SYS_set_mempolicy: ::c_long = 5000 + 229;\npub const SYS_mq_open: ::c_long = 5000 + 230;\npub const SYS_mq_unlink: ::c_long = 5000 + 231;\npub const SYS_mq_timedsend: ::c_long = 5000 + 232;\npub const SYS_mq_timedreceive: ::c_long = 5000 + 233;\npub const SYS_mq_notify: ::c_long = 5000 + 234;\npub const SYS_mq_getsetattr: ::c_long = 5000 + 235;\npub const SYS_vserver: ::c_long = 5000 + 236;\npub const SYS_waitid: ::c_long = 5000 + 237;\n/* pub const SYS_sys_setaltroot: ::c_long = 5000 + 238; */\npub const SYS_add_key: ::c_long = 5000 + 239;\npub const SYS_request_key: ::c_long = 5000 + 240;\npub const SYS_keyctl: ::c_long = 5000 + 241;\npub const SYS_set_thread_area: ::c_long = 5000 + 242;\npub const SYS_inotify_init: ::c_long = 5000 + 243;\npub const SYS_inotify_add_watch: ::c_long = 5000 + 244;\npub const SYS_inotify_rm_watch: ::c_long = 5000 + 245;\npub const SYS_migrate_pages: ::c_long = 5000 + 246;\npub const SYS_openat: ::c_long = 5000 + 247;\npub const SYS_mkdirat: ::c_long = 5000 + 248;\npub const SYS_mknodat: ::c_long = 5000 + 249;\npub const SYS_fchownat: ::c_long = 5000 + 250;\npub const SYS_futimesat: ::c_long = 5000 + 251;\npub const SYS_newfstatat: ::c_long = 5000 + 252;\npub const SYS_unlinkat: ::c_long = 5000 + 253;\npub const SYS_renameat: ::c_long = 5000 + 254;\npub const SYS_linkat: ::c_long = 5000 + 255;\npub const SYS_symlinkat: ::c_long = 5000 + 256;\npub const SYS_readlinkat: ::c_long = 5000 + 257;\npub const SYS_fchmodat: ::c_long = 5000 + 258;\npub const SYS_faccessat: ::c_long = 5000 + 259;\npub const SYS_pselect6: ::c_long = 5000 + 260;\npub const SYS_ppoll: ::c_long = 5000 + 261;\npub const SYS_unshare: ::c_long = 5000 + 262;\npub const SYS_splice: ::c_long = 5000 + 263;\npub const SYS_sync_file_range: ::c_long = 5000 + 264;\npub const SYS_tee: ::c_long = 5000 + 265;\npub const SYS_vmsplice: ::c_long = 5000 + 266;\npub const SYS_move_pages: ::c_long = 5000 + 267;\npub const SYS_set_robust_list: ::c_long = 5000 + 268;\npub const SYS_get_robust_list: ::c_long = 5000 + 269;\npub const SYS_kexec_load: ::c_long = 5000 + 270;\npub const SYS_getcpu: ::c_long = 5000 + 271;\npub const SYS_epoll_pwait: ::c_long = 5000 + 272;\npub const SYS_ioprio_set: ::c_long = 5000 + 273;\npub const SYS_ioprio_get: ::c_long = 5000 + 274;\npub const SYS_utimensat: ::c_long = 5000 + 275;\npub const SYS_signalfd: ::c_long = 5000 + 276;\npub const SYS_timerfd: ::c_long = 5000 + 277;\npub const SYS_eventfd: ::c_long = 5000 + 278;\npub const SYS_fallocate: ::c_long = 5000 + 279;\npub const SYS_timerfd_create: ::c_long = 5000 + 280;\npub const SYS_timerfd_gettime: ::c_long = 5000 + 281;\npub const SYS_timerfd_settime: ::c_long = 5000 + 282;\npub const SYS_signalfd4: ::c_long = 5000 + 283;\npub const SYS_eventfd2: ::c_long = 5000 + 284;\npub const SYS_epoll_create1: ::c_long = 5000 + 285;\npub const SYS_dup3: ::c_long = 5000 + 286;\npub const SYS_pipe2: ::c_long = 5000 + 287;\npub const SYS_inotify_init1: ::c_long = 5000 + 288;\npub const SYS_preadv: ::c_long = 5000 + 289;\npub const SYS_pwritev: ::c_long = 5000 + 290;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 5000 + 291;\npub const SYS_perf_event_open: ::c_long = 5000 + 292;\npub const SYS_accept4: ::c_long = 5000 + 293;\npub const SYS_recvmmsg: ::c_long = 5000 + 294;\npub const SYS_fanotify_init: ::c_long = 5000 + 295;\npub const SYS_fanotify_mark: ::c_long = 5000 + 296;\npub const SYS_prlimit64: ::c_long = 5000 + 297;\npub const SYS_name_to_handle_at: ::c_long = 5000 + 298;\npub const SYS_open_by_handle_at: ::c_long = 5000 + 299;\npub const SYS_clock_adjtime: ::c_long = 5000 + 300;\npub const SYS_syncfs: ::c_long = 5000 + 301;\npub const SYS_sendmmsg: ::c_long = 5000 + 302;\npub const SYS_setns: ::c_long = 5000 + 303;\npub const SYS_process_vm_readv: ::c_long = 5000 + 304;\npub const SYS_process_vm_writev: ::c_long = 5000 + 305;\npub const SYS_kcmp: ::c_long = 5000 + 306;\npub const SYS_finit_module: ::c_long = 5000 + 307;\npub const SYS_getdents64: ::c_long = 5000 + 308;\npub const SYS_sched_setattr: ::c_long = 5000 + 309;\npub const SYS_sched_getattr: ::c_long = 5000 + 310;\npub const SYS_renameat2: ::c_long = 5000 + 311;\npub const SYS_seccomp: ::c_long = 5000 + 312;\npub const SYS_getrandom: ::c_long = 5000 + 313;\npub const SYS_memfd_create: ::c_long = 5000 + 314;\npub const SYS_bpf: ::c_long = 5000 + 315;\npub const SYS_execveat: ::c_long = 5000 + 316;\npub const SYS_userfaultfd: ::c_long = 5000 + 317;\npub const SYS_membarrier: ::c_long = 5000 + 318;\npub const SYS_mlock2: ::c_long = 5000 + 319;\npub const SYS_copy_file_range: ::c_long = 5000 + 320;\npub const SYS_preadv2: ::c_long = 5000 + 321;\npub const SYS_pwritev2: ::c_long = 5000 + 322;\npub const SYS_pkey_mprotect: ::c_long = 5000 + 323;\npub const SYS_pkey_alloc: ::c_long = 5000 + 324;\npub const SYS_pkey_free: ::c_long = 5000 + 325;\npub const SYS_statx: ::c_long = 5000 + 326;\npub const SYS_pidfd_send_signal: ::c_long = 5000 + 424;\npub const SYS_io_uring_setup: ::c_long = 5000 + 425;\npub const SYS_io_uring_enter: ::c_long = 5000 + 426;\npub const SYS_io_uring_register: ::c_long = 5000 + 427;\npub const SYS_open_tree: ::c_long = 5000 + 428;\npub const SYS_move_mount: ::c_long = 5000 + 429;\npub const SYS_fsopen: ::c_long = 5000 + 430;\npub const SYS_fsconfig: ::c_long = 5000 + 431;\npub const SYS_fsmount: ::c_long = 5000 + 432;\npub const SYS_fspick: ::c_long = 5000 + 433;\npub const SYS_pidfd_open: ::c_long = 5000 + 434;\npub const SYS_clone3: ::c_long = 5000 + 435;\npub const SYS_close_range: ::c_long = 5000 + 436;\npub const SYS_openat2: ::c_long = 5000 + 437;\npub const SYS_pidfd_getfd: ::c_long = 5000 + 438;\npub const SYS_faccessat2: ::c_long = 5000 + 439;\npub const SYS_process_madvise: ::c_long = 5000 + 440;\npub const SYS_epoll_pwait2: ::c_long = 5000 + 441;\npub const SYS_mount_setattr: ::c_long = 5000 + 442;\n\npub const O_DIRECT: ::c_int = 0x8000;\npub const O_DIRECTORY: ::c_int = 0x10000;\npub const O_NOFOLLOW: ::c_int = 0x20000;\n\npub const O_APPEND: ::c_int = 8;\npub const O_CREAT: ::c_int = 256;\npub const O_EXCL: ::c_int = 1024;\npub const O_NOCTTY: ::c_int = 2048;\npub const O_NONBLOCK: ::c_int = 128;\npub const O_SYNC: ::c_int = 0x4010;\npub const O_RSYNC: ::c_int = 0x4010;\npub const O_DSYNC: ::c_int = 0x10;\npub const O_ASYNC: ::c_int = 0x1000;\n\npub const EDEADLK: ::c_int = 45;\npub const ENAMETOOLONG: ::c_int = 78;\npub const ENOLCK: ::c_int = 46;\npub const ENOSYS: ::c_int = 89;\npub const ENOTEMPTY: ::c_int = 93;\npub const ELOOP: ::c_int = 90;\npub const ENOMSG: ::c_int = 35;\npub const EIDRM: ::c_int = 36;\npub const ECHRNG: ::c_int = 37;\npub const EL2NSYNC: ::c_int = 38;\npub const EL3HLT: ::c_int = 39;\npub const EL3RST: ::c_int = 40;\npub const ELNRNG: ::c_int = 41;\npub const EUNATCH: ::c_int = 42;\npub const ENOCSI: ::c_int = 43;\npub const EL2HLT: ::c_int = 44;\npub const EBADE: ::c_int = 50;\npub const EBADR: ::c_int = 51;\npub const EXFULL: ::c_int = 52;\npub const ENOANO: ::c_int = 53;\npub const EBADRQC: ::c_int = 54;\npub const EBADSLT: ::c_int = 55;\npub const EDEADLOCK: ::c_int = 56;\npub const EMULTIHOP: ::c_int = 74;\npub const EOVERFLOW: ::c_int = 79;\npub const ENOTUNIQ: ::c_int = 80;\npub const EBADFD: ::c_int = 81;\npub const EBADMSG: ::c_int = 77;\npub const EREMCHG: ::c_int = 82;\npub const ELIBACC: ::c_int = 83;\npub const ELIBBAD: ::c_int = 84;\npub const ELIBSCN: ::c_int = 85;\npub const ELIBMAX: ::c_int = 86;\npub const ELIBEXEC: ::c_int = 87;\npub const EILSEQ: ::c_int = 88;\npub const ERESTART: ::c_int = 91;\npub const ESTRPIPE: ::c_int = 92;\npub const EUSERS: ::c_int = 94;\npub const ENOTSOCK: ::c_int = 95;\npub const EDESTADDRREQ: ::c_int = 96;\npub const EMSGSIZE: ::c_int = 97;\npub const EPROTOTYPE: ::c_int = 98;\npub const ENOPROTOOPT: ::c_int = 99;\npub const EPROTONOSUPPORT: ::c_int = 120;\npub const ESOCKTNOSUPPORT: ::c_int = 121;\npub const EOPNOTSUPP: ::c_int = 122;\npub const EPFNOSUPPORT: ::c_int = 123;\npub const EAFNOSUPPORT: ::c_int = 124;\npub const EADDRINUSE: ::c_int = 125;\npub const EADDRNOTAVAIL: ::c_int = 126;\npub const ENETDOWN: ::c_int = 127;\npub const ENETUNREACH: ::c_int = 128;\npub const ENETRESET: ::c_int = 129;\npub const ECONNABORTED: ::c_int = 130;\npub const ECONNRESET: ::c_int = 131;\npub const ENOBUFS: ::c_int = 132;\npub const EISCONN: ::c_int = 133;\npub const ENOTCONN: ::c_int = 134;\npub const ESHUTDOWN: ::c_int = 143;\npub const ETOOMANYREFS: ::c_int = 144;\npub const ETIMEDOUT: ::c_int = 145;\npub const ECONNREFUSED: ::c_int = 146;\npub const EHOSTDOWN: ::c_int = 147;\npub const EHOSTUNREACH: ::c_int = 148;\npub const EALREADY: ::c_int = 149;\npub const EINPROGRESS: ::c_int = 150;\npub const ESTALE: ::c_int = 151;\npub const EUCLEAN: ::c_int = 135;\npub const ENOTNAM: ::c_int = 137;\npub const ENAVAIL: ::c_int = 138;\npub const EISNAM: ::c_int = 139;\npub const EREMOTEIO: ::c_int = 140;\npub const EDQUOT: ::c_int = 1133;\npub const ENOMEDIUM: ::c_int = 159;\npub const EMEDIUMTYPE: ::c_int = 160;\npub const ECANCELED: ::c_int = 158;\npub const ENOKEY: ::c_int = 161;\npub const EKEYEXPIRED: ::c_int = 162;\npub const EKEYREVOKED: ::c_int = 163;\npub const EKEYREJECTED: ::c_int = 164;\npub const EOWNERDEAD: ::c_int = 165;\npub const ENOTRECOVERABLE: ::c_int = 166;\npub const ERFKILL: ::c_int = 167;\n\npub const MAP_ANON: ::c_int = 0x800;\npub const MAP_GROWSDOWN: ::c_int = 0x1000;\npub const MAP_DENYWRITE: ::c_int = 0x2000;\npub const MAP_EXECUTABLE: ::c_int = 0x4000;\npub const MAP_LOCKED: ::c_int = 0x8000;\npub const MAP_NORESERVE: ::c_int = 0x400;\npub const MAP_POPULATE: ::c_int = 0x10000;\npub const MAP_NONBLOCK: ::c_int = 0x20000;\npub const MAP_STACK: ::c_int = 0x40000;\npub const MAP_HUGETLB: ::c_int = 0x080000;\n\npub const SOCK_STREAM: ::c_int = 2;\npub const SOCK_DGRAM: ::c_int = 1;\n\npub const FIOCLEX: ::c_int = 0x6601;\npub const FIONCLEX: ::c_int = 0x6602;\npub const FIONBIO: ::c_int = 0x667e;\n\npub const SA_ONSTACK: ::c_int = 0x08000000;\npub const SA_SIGINFO: ::c_int = 0x00000008;\npub const SA_NOCLDWAIT: ::c_int = 0x00010000;\n\npub const SIGCHLD: ::c_int = 18;\npub const SIGBUS: ::c_int = 10;\npub const SIGTTIN: ::c_int = 26;\npub const SIGTTOU: ::c_int = 27;\npub const SIGXCPU: ::c_int = 30;\npub const SIGXFSZ: ::c_int = 31;\npub const SIGVTALRM: ::c_int = 28;\npub const SIGPROF: ::c_int = 29;\npub const SIGWINCH: ::c_int = 20;\npub const SIGUSR1: ::c_int = 16;\npub const SIGUSR2: ::c_int = 17;\npub const SIGCONT: ::c_int = 25;\npub const SIGSTOP: ::c_int = 23;\npub const SIGTSTP: ::c_int = 24;\npub const SIGURG: ::c_int = 21;\npub const SIGIO: ::c_int = 22;\npub const SIGSYS: ::c_int = 12;\npub const SIGPOLL: ::c_int = 22;\npub const SIGPWR: ::c_int = 19;\npub const SIG_SETMASK: ::c_int = 3;\npub const SIG_BLOCK: ::c_int = 0x1;\npub const SIG_UNBLOCK: ::c_int = 0x2;\n\npub const POLLWRNORM: ::c_short = 0x004;\npub const POLLWRBAND: ::c_short = 0x100;\n\npub const VEOF: usize = 16;\npub const VEOL: usize = 17;\npub const VEOL2: usize = 6;\npub const VMIN: usize = 4;\npub const IEXTEN: ::tcflag_t = 0x00000100;\npub const TOSTOP: ::tcflag_t = 0x00008000;\npub const FLUSHO: ::tcflag_t = 0x00002000;\npub const EXTPROC: ::tcflag_t = 0o200000;\n\npub const F_GETLK: ::c_int = 14;\npub const F_GETOWN: ::c_int = 23;\npub const F_SETOWN: ::c_int = 24;\npub const F_SETLK: ::c_int = 6;\npub const F_SETLKW: ::c_int = 7;\npub const F_OFD_GETLK: ::c_int = 36;\npub const F_OFD_SETLK: ::c_int = 37;\npub const F_OFD_SETLKW: ::c_int = 38;\n\npub const TCGETS: ::c_int = 0x540d;\npub const TCSETS: ::c_int = 0x540e;\npub const TCSETSW: ::c_int = 0x540f;\npub const TCSETSF: ::c_int = 0x5410;\npub const TCGETA: ::c_int = 0x5401;\npub const TCSETA: ::c_int = 0x5402;\npub const TCSETAW: ::c_int = 0x5403;\npub const TCSETAF: ::c_int = 0x5404;\npub const TCSBRK: ::c_int = 0x5405;\npub const TCXONC: ::c_int = 0x5406;\npub const TCFLSH: ::c_int = 0x5407;\npub const TIOCGSOFTCAR: ::c_int = 0x5481;\npub const TIOCSSOFTCAR: ::c_int = 0x5482;\npub const TIOCINQ: ::c_int = 0x467f;\npub const TIOCLINUX: ::c_int = 0x5483;\npub const TIOCGSERIAL: ::c_int = 0x5484;\npub const TIOCEXCL: ::c_int = 0x740d;\npub const TIOCNXCL: ::c_int = 0x740e;\npub const TIOCSCTTY: ::c_int = 0x5480;\npub const TIOCGPGRP: ::c_int = 0x40047477;\npub const TIOCSPGRP: ::c_int = 0x80047476_u32 as i32;\npub const TIOCOUTQ: ::c_int = 0x7472;\npub const TIOCSTI: ::c_int = 0x5472;\npub const TIOCGWINSZ: ::c_int = 0x40087468;\npub const TIOCSWINSZ: ::c_int = 0x80087467_u32 as i32;\npub const TIOCMGET: ::c_int = 0x741d;\npub const TIOCMBIS: ::c_int = 0x741b;\npub const TIOCMBIC: ::c_int = 0x741c;\npub const TIOCMSET: ::c_int = 0x741a;\npub const FIONREAD: ::c_int = 0x467f;\npub const TIOCCONS: ::c_int = 0x80047478_u32 as i32;\n\npub const MCL_CURRENT: ::c_int = 0x0001;\npub const MCL_FUTURE: ::c_int = 0x0002;\n\npub const CBAUD: ::tcflag_t = 0o0010017;\npub const TAB1: ::tcflag_t = 0x00000800;\npub const TAB2: ::tcflag_t = 0x00001000;\npub const TAB3: ::tcflag_t = 0x00001800;\npub const CR1: ::tcflag_t = 0x00000200;\npub const CR2: ::tcflag_t = 0x00000400;\npub const CR3: ::tcflag_t = 0x00000600;\npub const FF1: ::tcflag_t = 0x00008000;\npub const BS1: ::tcflag_t = 0x00002000;\npub const VT1: ::tcflag_t = 0x00004000;\npub const VWERASE: usize = 14;\npub const VREPRINT: usize = 12;\npub const VSUSP: usize = 10;\npub const VSTART: usize = 8;\npub const VSTOP: usize = 9;\npub const VDISCARD: usize = 13;\npub const VTIME: usize = 5;\npub const IXON: ::tcflag_t = 0x00000400;\npub const IXOFF: ::tcflag_t = 0x00001000;\npub const ONLCR: ::tcflag_t = 0x4;\npub const CSIZE: ::tcflag_t = 0x00000030;\npub const CS6: ::tcflag_t = 0x00000010;\npub const CS7: ::tcflag_t = 0x00000020;\npub const CS8: ::tcflag_t = 0x00000030;\npub const CSTOPB: ::tcflag_t = 0x00000040;\npub const CREAD: ::tcflag_t = 0x00000080;\npub const PARENB: ::tcflag_t = 0x00000100;\npub const PARODD: ::tcflag_t = 0x00000200;\npub const HUPCL: ::tcflag_t = 0x00000400;\npub const CLOCAL: ::tcflag_t = 0x00000800;\npub const ECHOKE: ::tcflag_t = 0x00000800;\npub const ECHOE: ::tcflag_t = 0x00000010;\npub const ECHOK: ::tcflag_t = 0x00000020;\npub const ECHONL: ::tcflag_t = 0x00000040;\npub const ECHOPRT: ::tcflag_t = 0x00000400;\npub const ECHOCTL: ::tcflag_t = 0x00000200;\npub const ISIG: ::tcflag_t = 0x00000001;\npub const ICANON: ::tcflag_t = 0x00000002;\npub const PENDIN: ::tcflag_t = 0x00004000;\npub const NOFLSH: ::tcflag_t = 0x00000080;\npub const CIBAUD: ::tcflag_t = 0o02003600000;\npub const CBAUDEX: ::tcflag_t = 0o010000;\npub const VSWTC: usize = 7;\npub const OLCUC: ::tcflag_t = 0o000002;\npub const NLDLY: ::tcflag_t = 0o000400;\npub const CRDLY: ::tcflag_t = 0o003000;\npub const TABDLY: ::tcflag_t = 0o014000;\npub const BSDLY: ::tcflag_t = 0o020000;\npub const FFDLY: ::tcflag_t = 0o100000;\npub const VTDLY: ::tcflag_t = 0o040000;\npub const XTABS: ::tcflag_t = 0o014000;\n\npub const BOTHER: ::speed_t = 0o010000;\npub const B57600: ::speed_t = 0o010001;\npub const B115200: ::speed_t = 0o010002;\npub const B230400: ::speed_t = 0o010003;\npub const B460800: ::speed_t = 0o010004;\npub const B500000: ::speed_t = 0o010005;\npub const B576000: ::speed_t = 0o010006;\npub const B921600: ::speed_t = 0o010007;\npub const B1000000: ::speed_t = 0o010010;\npub const B1152000: ::speed_t = 0o010011;\npub const B1500000: ::speed_t = 0o010012;\npub const B2000000: ::speed_t = 0o010013;\npub const B2500000: ::speed_t = 0o010014;\npub const B3000000: ::speed_t = 0o010015;\npub const B3500000: ::speed_t = 0o010016;\npub const B4000000: ::speed_t = 0o010017;\n\npub const TIOCM_ST: ::c_int = 0x010;\npub const TIOCM_SR: ::c_int = 0x020;\npub const TIOCM_CTS: ::c_int = 0x040;\npub const TIOCM_CAR: ::c_int = 0x100;\npub const TIOCM_RNG: ::c_int = 0x200;\npub const TIOCM_DSR: ::c_int = 0x400;\n\npub const EHWPOISON: ::c_int = 168;\n\nextern \"C\" {\n    pub fn ioctl(fd: ::c_int, request: ::c_int, ...) -> ::c_int;\n}\n"],["1205","pub type c_long = i64;\npub type c_ulong = u64;\npub type regoff_t = ::c_long;\n\ns! {\n    pub struct statfs64 {\n        pub f_type: ::c_ulong,\n        pub f_bsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_flags: ::c_ulong,\n        pub f_spare: [::c_ulong; 4],\n    }\n\n    pub struct statvfs64 {\n        pub f_bsize: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_blocks: u64,\n        pub f_bfree: u64,\n        pub f_bavail: u64,\n        pub f_files: u64,\n        pub f_ffree: u64,\n        pub f_favail: u64,\n        pub f_fsid: ::c_ulong,\n        pub f_flag: ::c_ulong,\n        pub f_namemax: ::c_ulong,\n        __f_spare: [::c_int; 6],\n    }\n\n    pub struct stack_t {\n        pub ss_sp: *mut ::c_void,\n        pub ss_flags: ::c_int,\n        pub ss_size: ::size_t\n    }\n\n    pub struct pthread_attr_t {\n        __size: [u64; 7]\n    }\n\n    pub struct sigset_t {\n        __val: [::c_ulong; 16],\n    }\n\n    pub struct shmid_ds {\n        pub shm_perm: ::ipc_perm,\n        pub shm_segsz: ::size_t,\n        pub shm_atime: ::time_t,\n        pub shm_dtime: ::time_t,\n        pub shm_ctime: ::time_t,\n        pub shm_cpid: ::pid_t,\n        pub shm_lpid: ::pid_t,\n        pub shm_nattch: ::c_ulong,\n        __pad1: ::c_ulong,\n        __pad2: ::c_ulong,\n    }\n\n    pub struct msqid_ds {\n        pub msg_perm: ::ipc_perm,\n        pub msg_stime: ::time_t,\n        pub msg_rtime: ::time_t,\n        pub msg_ctime: ::time_t,\n        __msg_cbytes: ::c_ulong,\n        pub msg_qnum: ::msgqnum_t,\n        pub msg_qbytes: ::msglen_t,\n        pub msg_lspid: ::pid_t,\n        pub msg_lrpid: ::pid_t,\n        __pad1: ::c_ulong,\n        __pad2: ::c_ulong,\n    }\n\n    pub struct statfs {\n        pub f_type: ::c_ulong,\n        pub f_bsize: ::c_ulong,\n        pub f_blocks: ::fsblkcnt_t,\n        pub f_bfree: ::fsblkcnt_t,\n        pub f_bavail: ::fsblkcnt_t,\n        pub f_files: ::fsfilcnt_t,\n        pub f_ffree: ::fsfilcnt_t,\n        pub f_fsid: ::fsid_t,\n        pub f_namelen: ::c_ulong,\n        pub f_frsize: ::c_ulong,\n        pub f_flags: ::c_ulong,\n        pub f_spare: [::c_ulong; 4],\n    }\n\n    pub struct msghdr {\n        pub msg_name: *mut ::c_void,\n        pub msg_namelen: ::socklen_t,\n        pub msg_iov: *mut ::iovec,\n        #[cfg(target_endian = \"big\")]\n        __pad1: ::c_int,\n        pub msg_iovlen: ::c_int,\n        #[cfg(target_endian = \"little\")]\n        __pad1: ::c_int,\n        pub msg_control: *mut ::c_void,\n        #[cfg(target_endian = \"big\")]\n        __pad2: ::c_int,\n        pub msg_controllen: ::socklen_t,\n        #[cfg(target_endian = \"little\")]\n        __pad2: ::c_int,\n        pub msg_flags: ::c_int,\n    }\n\n    pub struct cmsghdr {\n        #[cfg(target_endian = \"big\")]\n        pub __pad1: ::c_int,\n        pub cmsg_len: ::socklen_t,\n        #[cfg(target_endian = \"little\")]\n        pub __pad1: ::c_int,\n        pub cmsg_level: ::c_int,\n        pub cmsg_type: ::c_int,\n    }\n\n    pub struct sem_t {\n        __val: [::c_int; 8],\n    }\n\n    pub struct siginfo_t {\n        pub si_signo: ::c_int,\n        pub si_errno: ::c_int,\n        pub si_code: ::c_int,\n        pub _pad: [::c_int; 29],\n        _align: [usize; 0],\n    }\n}\n\npub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;\npub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;\n\npub const RLIMIT_RSS: ::c_int = 5;\npub const RLIMIT_NOFILE: ::c_int = 7;\npub const RLIMIT_AS: ::c_int = 9;\npub const RLIMIT_NPROC: ::c_int = 6;\npub const RLIMIT_MEMLOCK: ::c_int = 8;\n\npub const SOCK_NONBLOCK: ::c_int = 2048;\n\npub const SOCK_SEQPACKET: ::c_int = 5;\n\nextern \"C\" {\n    pub fn getrandom(buf: *mut ::c_void, buflen: ::size_t, flags: ::c_uint) -> ::ssize_t;\n}\n\ncfg_if! {\n    if #[cfg(target_arch = \"aarch64\")] {\n        mod aarch64;\n        pub use self::aarch64::*;\n    } else if #[cfg(target_arch = \"mips64\")] {\n        mod mips64;\n        pub use self::mips64::*;\n    } else if #[cfg(any(target_arch = \"powerpc64\"))] {\n        mod powerpc64;\n        pub use self::powerpc64::*;\n    } else if #[cfg(any(target_arch = \"s390x\"))] {\n        mod s390x;\n        pub use self::s390x::*;\n    } else if #[cfg(any(target_arch = \"x86_64\"))] {\n        mod x86_64;\n        pub use self::x86_64::*;\n    } else {\n        // Unknown target_arch\n    }\n}\n"],["1206","pub type c_char = u8;\npub type wchar_t = i32;\npub type __u64 = ::c_ulong;\npub type nlink_t = u64;\npub type blksize_t = ::c_long;\n\ns! {\n    pub struct stat {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino_t,\n        pub st_nlink: ::nlink_t,\n        pub st_mode: ::mode_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        __pad0: ::c_int,\n        pub st_rdev: ::dev_t,\n        pub st_size: ::off_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __unused: [::c_long; 3],\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino64_t,\n        pub st_nlink: ::nlink_t,\n        pub st_mode: ::mode_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        __pad0: ::c_int,\n        pub st_rdev: ::dev_t,\n        pub st_size: ::off_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt64_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __reserved: [::c_long; 3],\n    }\n\n    pub struct ipc_perm {\n        pub __ipc_perm_key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::mode_t,\n        pub __seq: ::c_int,\n        __unused1: ::c_long,\n        __unused2: ::c_long\n    }\n}\n\npub const MADV_SOFT_OFFLINE: ::c_int = 101;\npub const MAP_32BIT: ::c_int = 0x0040;\npub const O_APPEND: ::c_int = 1024;\npub const O_DIRECT: ::c_int = 0x20000;\npub const O_DIRECTORY: ::c_int = 0x4000;\npub const O_LARGEFILE: ::c_int = 0x10000;\npub const O_NOFOLLOW: ::c_int = 0x8000;\npub const O_CREAT: ::c_int = 64;\npub const O_EXCL: ::c_int = 128;\npub const O_NOCTTY: ::c_int = 256;\npub const O_NONBLOCK: ::c_int = 2048;\npub const O_SYNC: ::c_int = 1052672;\npub const O_RSYNC: ::c_int = 1052672;\npub const O_DSYNC: ::c_int = 4096;\npub const O_ASYNC: ::c_int = 0x2000;\n\npub const ENAMETOOLONG: ::c_int = 36;\npub const ENOLCK: ::c_int = 37;\npub const ENOSYS: ::c_int = 38;\npub const ENOTEMPTY: ::c_int = 39;\npub const ELOOP: ::c_int = 40;\npub const ENOMSG: ::c_int = 42;\npub const EIDRM: ::c_int = 43;\npub const ECHRNG: ::c_int = 44;\npub const EL2NSYNC: ::c_int = 45;\npub const EL3HLT: ::c_int = 46;\npub const EL3RST: ::c_int = 47;\npub const ELNRNG: ::c_int = 48;\npub const EUNATCH: ::c_int = 49;\npub const ENOCSI: ::c_int = 50;\npub const EL2HLT: ::c_int = 51;\npub const EBADE: ::c_int = 52;\npub const EBADR: ::c_int = 53;\npub const EXFULL: ::c_int = 54;\npub const ENOANO: ::c_int = 55;\npub const EBADRQC: ::c_int = 56;\npub const EBADSLT: ::c_int = 57;\npub const EMULTIHOP: ::c_int = 72;\npub const EBADMSG: ::c_int = 74;\npub const EOVERFLOW: ::c_int = 75;\npub const ENOTUNIQ: ::c_int = 76;\npub const EBADFD: ::c_int = 77;\npub const EREMCHG: ::c_int = 78;\npub const ELIBACC: ::c_int = 79;\npub const ELIBBAD: ::c_int = 80;\npub const ELIBSCN: ::c_int = 81;\npub const ELIBMAX: ::c_int = 82;\npub const ELIBEXEC: ::c_int = 83;\npub const EILSEQ: ::c_int = 84;\npub const ERESTART: ::c_int = 85;\npub const ESTRPIPE: ::c_int = 86;\npub const EUSERS: ::c_int = 87;\npub const ENOTSOCK: ::c_int = 88;\npub const EDESTADDRREQ: ::c_int = 89;\npub const EMSGSIZE: ::c_int = 90;\npub const EPROTOTYPE: ::c_int = 91;\npub const ENOPROTOOPT: ::c_int = 92;\npub const EPROTONOSUPPORT: ::c_int = 93;\npub const ESOCKTNOSUPPORT: ::c_int = 94;\npub const EOPNOTSUPP: ::c_int = 95;\npub const ENOTSUP: ::c_int = EOPNOTSUPP;\npub const EPFNOSUPPORT: ::c_int = 96;\npub const EAFNOSUPPORT: ::c_int = 97;\npub const EADDRINUSE: ::c_int = 98;\npub const EADDRNOTAVAIL: ::c_int = 99;\npub const ENETDOWN: ::c_int = 100;\npub const ENETUNREACH: ::c_int = 101;\npub const ENETRESET: ::c_int = 102;\npub const ECONNABORTED: ::c_int = 103;\npub const ECONNRESET: ::c_int = 104;\npub const ENOBUFS: ::c_int = 105;\npub const EISCONN: ::c_int = 106;\npub const ENOTCONN: ::c_int = 107;\npub const ESHUTDOWN: ::c_int = 108;\npub const ETOOMANYREFS: ::c_int = 109;\npub const ETIMEDOUT: ::c_int = 110;\npub const ECONNREFUSED: ::c_int = 111;\npub const EHOSTDOWN: ::c_int = 112;\npub const EHOSTUNREACH: ::c_int = 113;\npub const EALREADY: ::c_int = 114;\npub const EINPROGRESS: ::c_int = 115;\npub const ESTALE: ::c_int = 116;\npub const EUCLEAN: ::c_int = 117;\npub const ENOTNAM: ::c_int = 118;\npub const ENAVAIL: ::c_int = 119;\npub const EISNAM: ::c_int = 120;\npub const EREMOTEIO: ::c_int = 121;\npub const EDQUOT: ::c_int = 122;\npub const ENOMEDIUM: ::c_int = 123;\npub const EMEDIUMTYPE: ::c_int = 124;\npub const ECANCELED: ::c_int = 125;\npub const ENOKEY: ::c_int = 126;\npub const EKEYEXPIRED: ::c_int = 127;\npub const EKEYREVOKED: ::c_int = 128;\npub const EKEYREJECTED: ::c_int = 129;\npub const EOWNERDEAD: ::c_int = 130;\npub const ENOTRECOVERABLE: ::c_int = 131;\npub const ERFKILL: ::c_int = 132;\npub const EHWPOISON: ::c_int = 133;\n\npub const MAP_ANON: ::c_int = 0x0020;\npub const MAP_GROWSDOWN: ::c_int = 0x0100;\npub const MAP_DENYWRITE: ::c_int = 0x0800;\npub const MAP_EXECUTABLE: ::c_int = 0x01000;\npub const MAP_LOCKED: ::c_int = 0x02000;\npub const MAP_NORESERVE: ::c_int = 0x04000;\npub const MAP_POPULATE: ::c_int = 0x08000;\npub const MAP_NONBLOCK: ::c_int = 0x010000;\npub const MAP_STACK: ::c_int = 0x020000;\npub const MAP_HUGETLB: ::c_int = 0x040000;\npub const MAP_SYNC: ::c_int = 0x080000;\n\npub const SOCK_STREAM: ::c_int = 1;\npub const SOCK_DGRAM: ::c_int = 2;\n\npub const SA_ONSTACK: ::c_int = 0x08000000;\npub const SA_SIGINFO: ::c_int = 0x00000004;\npub const SA_NOCLDWAIT: ::c_int = 0x00000002;\n\npub const SIGCHLD: ::c_int = 17;\npub const SIGBUS: ::c_int = 7;\npub const SIGTTIN: ::c_int = 21;\npub const SIGTTOU: ::c_int = 22;\npub const SIGXCPU: ::c_int = 24;\npub const SIGXFSZ: ::c_int = 25;\npub const SIGVTALRM: ::c_int = 26;\npub const SIGPROF: ::c_int = 27;\npub const SIGWINCH: ::c_int = 28;\npub const SIGUSR1: ::c_int = 10;\npub const SIGUSR2: ::c_int = 12;\npub const SIGCONT: ::c_int = 18;\npub const SIGSTOP: ::c_int = 19;\npub const SIGTSTP: ::c_int = 20;\npub const SIGURG: ::c_int = 23;\npub const SIGIO: ::c_int = 29;\npub const SIGSYS: ::c_int = 31;\npub const SIGSTKFLT: ::c_int = 16;\npub const SIGPOLL: ::c_int = 29;\npub const SIGPWR: ::c_int = 30;\npub const SIG_SETMASK: ::c_int = 2;\npub const SIG_BLOCK: ::c_int = 0x000000;\npub const SIG_UNBLOCK: ::c_int = 0x01;\n\npub const F_GETLK: ::c_int = 5;\npub const F_GETOWN: ::c_int = 9;\npub const F_SETLK: ::c_int = 6;\npub const F_SETLKW: ::c_int = 7;\npub const F_SETOWN: ::c_int = 8;\npub const F_OFD_GETLK: ::c_int = 36;\npub const F_OFD_SETLK: ::c_int = 37;\npub const F_OFD_SETLKW: ::c_int = 38;\n\npub const VEOF: usize = 4;\n\npub const POLLWRNORM: ::c_short = 0x100;\npub const POLLWRBAND: ::c_short = 0x200;\n\npub const SIGSTKSZ: ::size_t = 10240;\npub const MINSIGSTKSZ: ::size_t = 4096;\n\n// Syscall table\npub const SYS_restart_syscall: ::c_long = 0;\npub const SYS_exit: ::c_long = 1;\npub const SYS_fork: ::c_long = 2;\npub const SYS_read: ::c_long = 3;\npub const SYS_write: ::c_long = 4;\npub const SYS_open: ::c_long = 5;\npub const SYS_close: ::c_long = 6;\npub const SYS_waitpid: ::c_long = 7;\npub const SYS_creat: ::c_long = 8;\npub const SYS_link: ::c_long = 9;\npub const SYS_unlink: ::c_long = 10;\npub const SYS_execve: ::c_long = 11;\npub const SYS_chdir: ::c_long = 12;\npub const SYS_time: ::c_long = 13;\npub const SYS_mknod: ::c_long = 14;\npub const SYS_chmod: ::c_long = 15;\npub const SYS_lchown: ::c_long = 16;\npub const SYS_break: ::c_long = 17;\npub const SYS_oldstat: ::c_long = 18;\npub const SYS_lseek: ::c_long = 19;\npub const SYS_getpid: ::c_long = 20;\npub const SYS_mount: ::c_long = 21;\npub const SYS_umount: ::c_long = 22;\npub const SYS_setuid: ::c_long = 23;\npub const SYS_getuid: ::c_long = 24;\npub const SYS_stime: ::c_long = 25;\npub const SYS_ptrace: ::c_long = 26;\npub const SYS_alarm: ::c_long = 27;\npub const SYS_oldfstat: ::c_long = 28;\npub const SYS_pause: ::c_long = 29;\npub const SYS_utime: ::c_long = 30;\npub const SYS_stty: ::c_long = 31;\npub const SYS_gtty: ::c_long = 32;\npub const SYS_access: ::c_long = 33;\npub const SYS_nice: ::c_long = 34;\npub const SYS_ftime: ::c_long = 35;\npub const SYS_sync: ::c_long = 36;\npub const SYS_kill: ::c_long = 37;\npub const SYS_rename: ::c_long = 38;\npub const SYS_mkdir: ::c_long = 39;\npub const SYS_rmdir: ::c_long = 40;\npub const SYS_dup: ::c_long = 41;\npub const SYS_pipe: ::c_long = 42;\npub const SYS_times: ::c_long = 43;\npub const SYS_prof: ::c_long = 44;\npub const SYS_brk: ::c_long = 45;\npub const SYS_setgid: ::c_long = 46;\npub const SYS_getgid: ::c_long = 47;\npub const SYS_signal: ::c_long = 48;\npub const SYS_geteuid: ::c_long = 49;\npub const SYS_getegid: ::c_long = 50;\npub const SYS_acct: ::c_long = 51;\npub const SYS_umount2: ::c_long = 52;\npub const SYS_lock: ::c_long = 53;\npub const SYS_ioctl: ::c_long = 54;\npub const SYS_fcntl: ::c_long = 55;\npub const SYS_mpx: ::c_long = 56;\npub const SYS_setpgid: ::c_long = 57;\npub const SYS_ulimit: ::c_long = 58;\npub const SYS_oldolduname: ::c_long = 59;\npub const SYS_umask: ::c_long = 60;\npub const SYS_chroot: ::c_long = 61;\npub const SYS_ustat: ::c_long = 62;\npub const SYS_dup2: ::c_long = 63;\npub const SYS_getppid: ::c_long = 64;\npub const SYS_getpgrp: ::c_long = 65;\npub const SYS_setsid: ::c_long = 66;\npub const SYS_sigaction: ::c_long = 67;\npub const SYS_sgetmask: ::c_long = 68;\npub const SYS_ssetmask: ::c_long = 69;\npub const SYS_setreuid: ::c_long = 70;\npub const SYS_setregid: ::c_long = 71;\npub const SYS_sigsuspend: ::c_long = 72;\npub const SYS_sigpending: ::c_long = 73;\npub const SYS_sethostname: ::c_long = 74;\npub const SYS_setrlimit: ::c_long = 75;\npub const SYS_getrlimit: ::c_long = 76;\npub const SYS_getrusage: ::c_long = 77;\npub const SYS_gettimeofday: ::c_long = 78;\npub const SYS_settimeofday: ::c_long = 79;\npub const SYS_getgroups: ::c_long = 80;\npub const SYS_setgroups: ::c_long = 81;\npub const SYS_select: ::c_long = 82;\npub const SYS_symlink: ::c_long = 83;\npub const SYS_oldlstat: ::c_long = 84;\npub const SYS_readlink: ::c_long = 85;\npub const SYS_uselib: ::c_long = 86;\npub const SYS_swapon: ::c_long = 87;\npub const SYS_reboot: ::c_long = 88;\npub const SYS_readdir: ::c_long = 89;\npub const SYS_mmap: ::c_long = 90;\npub const SYS_munmap: ::c_long = 91;\npub const SYS_truncate: ::c_long = 92;\npub const SYS_ftruncate: ::c_long = 93;\npub const SYS_fchmod: ::c_long = 94;\npub const SYS_fchown: ::c_long = 95;\npub const SYS_getpriority: ::c_long = 96;\npub const SYS_setpriority: ::c_long = 97;\npub const SYS_profil: ::c_long = 98;\npub const SYS_statfs: ::c_long = 99;\npub const SYS_fstatfs: ::c_long = 100;\npub const SYS_ioperm: ::c_long = 101;\npub const SYS_socketcall: ::c_long = 102;\npub const SYS_syslog: ::c_long = 103;\npub const SYS_setitimer: ::c_long = 104;\npub const SYS_getitimer: ::c_long = 105;\npub const SYS_stat: ::c_long = 106;\npub const SYS_lstat: ::c_long = 107;\npub const SYS_fstat: ::c_long = 108;\npub const SYS_olduname: ::c_long = 109;\npub const SYS_iopl: ::c_long = 110;\npub const SYS_vhangup: ::c_long = 111;\npub const SYS_idle: ::c_long = 112;\npub const SYS_vm86: ::c_long = 113;\npub const SYS_wait4: ::c_long = 114;\npub const SYS_swapoff: ::c_long = 115;\npub const SYS_sysinfo: ::c_long = 116;\npub const SYS_ipc: ::c_long = 117;\npub const SYS_fsync: ::c_long = 118;\npub const SYS_sigreturn: ::c_long = 119;\npub const SYS_clone: ::c_long = 120;\npub const SYS_setdomainname: ::c_long = 121;\npub const SYS_uname: ::c_long = 122;\npub const SYS_modify_ldt: ::c_long = 123;\npub const SYS_adjtimex: ::c_long = 124;\npub const SYS_mprotect: ::c_long = 125;\npub const SYS_sigprocmask: ::c_long = 126;\npub const SYS_create_module: ::c_long = 127;\npub const SYS_init_module: ::c_long = 128;\npub const SYS_delete_module: ::c_long = 129;\npub const SYS_get_kernel_syms: ::c_long = 130;\npub const SYS_quotactl: ::c_long = 131;\npub const SYS_getpgid: ::c_long = 132;\npub const SYS_fchdir: ::c_long = 133;\npub const SYS_bdflush: ::c_long = 134;\npub const SYS_sysfs: ::c_long = 135;\npub const SYS_personality: ::c_long = 136;\npub const SYS_afs_syscall: ::c_long = 137; /* Syscall for Andrew File System */\npub const SYS_setfsuid: ::c_long = 138;\npub const SYS_setfsgid: ::c_long = 139;\npub const SYS__llseek: ::c_long = 140;\npub const SYS_getdents: ::c_long = 141;\npub const SYS__newselect: ::c_long = 142;\npub const SYS_flock: ::c_long = 143;\npub const SYS_msync: ::c_long = 144;\npub const SYS_readv: ::c_long = 145;\npub const SYS_writev: ::c_long = 146;\npub const SYS_getsid: ::c_long = 147;\npub const SYS_fdatasync: ::c_long = 148;\npub const SYS__sysctl: ::c_long = 149;\npub const SYS_mlock: ::c_long = 150;\npub const SYS_munlock: ::c_long = 151;\npub const SYS_mlockall: ::c_long = 152;\npub const SYS_munlockall: ::c_long = 153;\npub const SYS_sched_setparam: ::c_long = 154;\npub const SYS_sched_getparam: ::c_long = 155;\npub const SYS_sched_setscheduler: ::c_long = 156;\npub const SYS_sched_getscheduler: ::c_long = 157;\npub const SYS_sched_yield: ::c_long = 158;\npub const SYS_sched_get_priority_max: ::c_long = 159;\npub const SYS_sched_get_priority_min: ::c_long = 160;\npub const SYS_sched_rr_get_interval: ::c_long = 161;\npub const SYS_nanosleep: ::c_long = 162;\npub const SYS_mremap: ::c_long = 163;\npub const SYS_setresuid: ::c_long = 164;\npub const SYS_getresuid: ::c_long = 165;\npub const SYS_query_module: ::c_long = 166;\npub const SYS_poll: ::c_long = 167;\npub const SYS_nfsservctl: ::c_long = 168;\npub const SYS_setresgid: ::c_long = 169;\npub const SYS_getresgid: ::c_long = 170;\npub const SYS_prctl: ::c_long = 171;\npub const SYS_rt_sigreturn: ::c_long = 172;\npub const SYS_rt_sigaction: ::c_long = 173;\npub const SYS_rt_sigprocmask: ::c_long = 174;\npub const SYS_rt_sigpending: ::c_long = 175;\npub const SYS_rt_sigtimedwait: ::c_long = 176;\npub const SYS_rt_sigqueueinfo: ::c_long = 177;\npub const SYS_rt_sigsuspend: ::c_long = 178;\npub const SYS_pread64: ::c_long = 179;\npub const SYS_pwrite64: ::c_long = 180;\npub const SYS_chown: ::c_long = 181;\npub const SYS_getcwd: ::c_long = 182;\npub const SYS_capget: ::c_long = 183;\npub const SYS_capset: ::c_long = 184;\npub const SYS_sigaltstack: ::c_long = 185;\npub const SYS_sendfile: ::c_long = 186;\npub const SYS_getpmsg: ::c_long = 187; /* some people actually want streams */\npub const SYS_putpmsg: ::c_long = 188; /* some people actually want streams */\npub const SYS_vfork: ::c_long = 189;\npub const SYS_ugetrlimit: ::c_long = 190; /* SuS compliant getrlimit */\npub const SYS_readahead: ::c_long = 191;\npub const SYS_pciconfig_read: ::c_long = 198;\npub const SYS_pciconfig_write: ::c_long = 199;\npub const SYS_pciconfig_iobase: ::c_long = 200;\npub const SYS_multiplexer: ::c_long = 201;\npub const SYS_getdents64: ::c_long = 202;\npub const SYS_pivot_root: ::c_long = 203;\npub const SYS_madvise: ::c_long = 205;\npub const SYS_mincore: ::c_long = 206;\npub const SYS_gettid: ::c_long = 207;\npub const SYS_tkill: ::c_long = 208;\npub const SYS_setxattr: ::c_long = 209;\npub const SYS_lsetxattr: ::c_long = 210;\npub const SYS_fsetxattr: ::c_long = 211;\npub const SYS_getxattr: ::c_long = 212;\npub const SYS_lgetxattr: ::c_long = 213;\npub const SYS_fgetxattr: ::c_long = 214;\npub const SYS_listxattr: ::c_long = 215;\npub const SYS_llistxattr: ::c_long = 216;\npub const SYS_flistxattr: ::c_long = 217;\npub const SYS_removexattr: ::c_long = 218;\npub const SYS_lremovexattr: ::c_long = 219;\npub const SYS_fremovexattr: ::c_long = 220;\npub const SYS_futex: ::c_long = 221;\npub const SYS_sched_setaffinity: ::c_long = 222;\npub const SYS_sched_getaffinity: ::c_long = 223;\npub const SYS_tuxcall: ::c_long = 225;\npub const SYS_io_setup: ::c_long = 227;\npub const SYS_io_destroy: ::c_long = 228;\npub const SYS_io_getevents: ::c_long = 229;\npub const SYS_io_submit: ::c_long = 230;\npub const SYS_io_cancel: ::c_long = 231;\npub const SYS_set_tid_address: ::c_long = 232;\npub const SYS_exit_group: ::c_long = 234;\npub const SYS_lookup_dcookie: ::c_long = 235;\npub const SYS_epoll_create: ::c_long = 236;\npub const SYS_epoll_ctl: ::c_long = 237;\npub const SYS_epoll_wait: ::c_long = 238;\npub const SYS_remap_file_pages: ::c_long = 239;\npub const SYS_timer_create: ::c_long = 240;\npub const SYS_timer_settime: ::c_long = 241;\npub const SYS_timer_gettime: ::c_long = 242;\npub const SYS_timer_getoverrun: ::c_long = 243;\npub const SYS_timer_delete: ::c_long = 244;\npub const SYS_clock_settime: ::c_long = 245;\npub const SYS_clock_gettime: ::c_long = 246;\npub const SYS_clock_getres: ::c_long = 247;\npub const SYS_clock_nanosleep: ::c_long = 248;\npub const SYS_swapcontext: ::c_long = 249;\npub const SYS_tgkill: ::c_long = 250;\npub const SYS_utimes: ::c_long = 251;\npub const SYS_statfs64: ::c_long = 252;\npub const SYS_fstatfs64: ::c_long = 253;\npub const SYS_rtas: ::c_long = 255;\npub const SYS_sys_debug_setcontext: ::c_long = 256;\npub const SYS_migrate_pages: ::c_long = 258;\npub const SYS_mbind: ::c_long = 259;\npub const SYS_get_mempolicy: ::c_long = 260;\npub const SYS_set_mempolicy: ::c_long = 261;\npub const SYS_mq_open: ::c_long = 262;\npub const SYS_mq_unlink: ::c_long = 263;\npub const SYS_mq_timedsend: ::c_long = 264;\npub const SYS_mq_timedreceive: ::c_long = 265;\npub const SYS_mq_notify: ::c_long = 266;\npub const SYS_mq_getsetattr: ::c_long = 267;\npub const SYS_kexec_load: ::c_long = 268;\npub const SYS_add_key: ::c_long = 269;\npub const SYS_request_key: ::c_long = 270;\npub const SYS_keyctl: ::c_long = 271;\npub const SYS_waitid: ::c_long = 272;\npub const SYS_ioprio_set: ::c_long = 273;\npub const SYS_ioprio_get: ::c_long = 274;\npub const SYS_inotify_init: ::c_long = 275;\npub const SYS_inotify_add_watch: ::c_long = 276;\npub const SYS_inotify_rm_watch: ::c_long = 277;\npub const SYS_spu_run: ::c_long = 278;\npub const SYS_spu_create: ::c_long = 279;\npub const SYS_pselect6: ::c_long = 280;\npub const SYS_ppoll: ::c_long = 281;\npub const SYS_unshare: ::c_long = 282;\npub const SYS_splice: ::c_long = 283;\npub const SYS_tee: ::c_long = 284;\npub const SYS_vmsplice: ::c_long = 285;\npub const SYS_openat: ::c_long = 286;\npub const SYS_mkdirat: ::c_long = 287;\npub const SYS_mknodat: ::c_long = 288;\npub const SYS_fchownat: ::c_long = 289;\npub const SYS_futimesat: ::c_long = 290;\npub const SYS_newfstatat: ::c_long = 291;\npub const SYS_unlinkat: ::c_long = 292;\npub const SYS_renameat: ::c_long = 293;\npub const SYS_linkat: ::c_long = 294;\npub const SYS_symlinkat: ::c_long = 295;\npub const SYS_readlinkat: ::c_long = 296;\npub const SYS_fchmodat: ::c_long = 297;\npub const SYS_faccessat: ::c_long = 298;\npub const SYS_get_robust_list: ::c_long = 299;\npub const SYS_set_robust_list: ::c_long = 300;\npub const SYS_move_pages: ::c_long = 301;\npub const SYS_getcpu: ::c_long = 302;\npub const SYS_epoll_pwait: ::c_long = 303;\npub const SYS_utimensat: ::c_long = 304;\npub const SYS_signalfd: ::c_long = 305;\npub const SYS_timerfd_create: ::c_long = 306;\npub const SYS_eventfd: ::c_long = 307;\npub const SYS_sync_file_range2: ::c_long = 308;\npub const SYS_fallocate: ::c_long = 309;\npub const SYS_subpage_prot: ::c_long = 310;\npub const SYS_timerfd_settime: ::c_long = 311;\npub const SYS_timerfd_gettime: ::c_long = 312;\npub const SYS_signalfd4: ::c_long = 313;\npub const SYS_eventfd2: ::c_long = 314;\npub const SYS_epoll_create1: ::c_long = 315;\npub const SYS_dup3: ::c_long = 316;\npub const SYS_pipe2: ::c_long = 317;\npub const SYS_inotify_init1: ::c_long = 318;\npub const SYS_perf_event_open: ::c_long = 319;\npub const SYS_preadv: ::c_long = 320;\npub const SYS_pwritev: ::c_long = 321;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 322;\npub const SYS_fanotify_init: ::c_long = 323;\npub const SYS_fanotify_mark: ::c_long = 324;\npub const SYS_prlimit64: ::c_long = 325;\npub const SYS_socket: ::c_long = 326;\npub const SYS_bind: ::c_long = 327;\npub const SYS_connect: ::c_long = 328;\npub const SYS_listen: ::c_long = 329;\npub const SYS_accept: ::c_long = 330;\npub const SYS_getsockname: ::c_long = 331;\npub const SYS_getpeername: ::c_long = 332;\npub const SYS_socketpair: ::c_long = 333;\npub const SYS_send: ::c_long = 334;\npub const SYS_sendto: ::c_long = 335;\npub const SYS_recv: ::c_long = 336;\npub const SYS_recvfrom: ::c_long = 337;\npub const SYS_shutdown: ::c_long = 338;\npub const SYS_setsockopt: ::c_long = 339;\npub const SYS_getsockopt: ::c_long = 340;\npub const SYS_sendmsg: ::c_long = 341;\npub const SYS_recvmsg: ::c_long = 342;\npub const SYS_recvmmsg: ::c_long = 343;\npub const SYS_accept4: ::c_long = 344;\npub const SYS_name_to_handle_at: ::c_long = 345;\npub const SYS_open_by_handle_at: ::c_long = 346;\npub const SYS_clock_adjtime: ::c_long = 347;\npub const SYS_syncfs: ::c_long = 348;\npub const SYS_sendmmsg: ::c_long = 349;\npub const SYS_setns: ::c_long = 350;\npub const SYS_process_vm_readv: ::c_long = 351;\npub const SYS_process_vm_writev: ::c_long = 352;\npub const SYS_finit_module: ::c_long = 353;\npub const SYS_kcmp: ::c_long = 354;\npub const SYS_sched_setattr: ::c_long = 355;\npub const SYS_sched_getattr: ::c_long = 356;\npub const SYS_renameat2: ::c_long = 357;\npub const SYS_seccomp: ::c_long = 358;\npub const SYS_getrandom: ::c_long = 359;\npub const SYS_memfd_create: ::c_long = 360;\npub const SYS_bpf: ::c_long = 361;\npub const SYS_execveat: ::c_long = 362;\npub const SYS_switch_endian: ::c_long = 363;\npub const SYS_userfaultfd: ::c_long = 364;\npub const SYS_membarrier: ::c_long = 365;\npub const SYS_mlock2: ::c_long = 378;\npub const SYS_copy_file_range: ::c_long = 379;\npub const SYS_preadv2: ::c_long = 380;\npub const SYS_pwritev2: ::c_long = 381;\npub const SYS_kexec_file_load: ::c_long = 382;\npub const SYS_statx: ::c_long = 383;\npub const SYS_pidfd_send_signal: ::c_long = 424;\npub const SYS_io_uring_setup: ::c_long = 425;\npub const SYS_io_uring_enter: ::c_long = 426;\npub const SYS_io_uring_register: ::c_long = 427;\npub const SYS_open_tree: ::c_long = 428;\npub const SYS_move_mount: ::c_long = 429;\npub const SYS_fsopen: ::c_long = 430;\npub const SYS_fsconfig: ::c_long = 431;\npub const SYS_fsmount: ::c_long = 432;\npub const SYS_fspick: ::c_long = 433;\npub const SYS_pidfd_open: ::c_long = 434;\npub const SYS_clone3: ::c_long = 435;\npub const SYS_close_range: ::c_long = 436;\npub const SYS_openat2: ::c_long = 437;\npub const SYS_pidfd_getfd: ::c_long = 438;\npub const SYS_faccessat2: ::c_long = 439;\npub const SYS_process_madvise: ::c_long = 440;\npub const SYS_epoll_pwait2: ::c_long = 441;\npub const SYS_mount_setattr: ::c_long = 442;\n\npub const FIOCLEX: ::c_int = 0x20006601;\npub const FIONCLEX: ::c_int = 0x20006602;\npub const FIONBIO: ::c_int = 0x8004667e;\npub const EDEADLK: ::c_int = 58;\npub const EDEADLOCK: ::c_int = EDEADLK;\n\npub const EXTPROC: ::tcflag_t = 0x10000000;\npub const VEOL: usize = 6;\npub const VEOL2: usize = 8;\npub const VMIN: usize = 5;\npub const IEXTEN: ::tcflag_t = 0x00000400;\npub const TOSTOP: ::tcflag_t = 0x00400000;\npub const FLUSHO: ::tcflag_t = 0x00800000;\npub const TCGETS: ::c_int = 0x403c7413;\npub const TCSETS: ::c_int = 0x803c7414;\npub const TCSETSW: ::c_int = 0x803c7415;\npub const TCSETSF: ::c_int = 0x803c7416;\npub const TCGETA: ::c_int = 0x40147417;\npub const TCSETA: ::c_int = 0x80147418;\npub const TCSETAW: ::c_int = 0x80147419;\npub const TCSETAF: ::c_int = 0x8014741c;\npub const TCSBRK: ::c_int = 0x2000741d;\npub const TCXONC: ::c_int = 0x2000741e;\npub const TCFLSH: ::c_int = 0x2000741f;\npub const TIOCGSOFTCAR: ::c_int = 0x5419;\npub const TIOCSSOFTCAR: ::c_int = 0x541A;\npub const TIOCLINUX: ::c_int = 0x541C;\npub const TIOCGSERIAL: ::c_int = 0x541E;\npub const TIOCEXCL: ::c_int = 0x540C;\npub const TIOCNXCL: ::c_int = 0x540D;\npub const TIOCSCTTY: ::c_int = 0x540E;\npub const TIOCGPGRP: ::c_int = 0x40047477;\npub const TIOCSPGRP: ::c_int = 0x80047476;\npub const TIOCOUTQ: ::c_int = 0x40047473;\npub const TIOCGWINSZ: ::c_int = 0x40087468;\npub const TIOCSWINSZ: ::c_int = 0x80087467;\npub const TIOCMGET: ::c_int = 0x5415;\npub const TIOCMBIS: ::c_int = 0x5416;\npub const TIOCMBIC: ::c_int = 0x5417;\npub const TIOCMSET: ::c_int = 0x5418;\npub const FIONREAD: ::c_int = 0x4004667f;\npub const TIOCCONS: ::c_int = 0x541D;\npub const TIOCM_LE: ::c_int = 0x001;\npub const TIOCM_DTR: ::c_int = 0x002;\npub const TIOCM_RTS: ::c_int = 0x004;\npub const TIOCM_ST: ::c_int = 0x008;\npub const TIOCM_SR: ::c_int = 0x010;\npub const TIOCM_CTS: ::c_int = 0x020;\npub const TIOCM_CAR: ::c_int = 0x040;\npub const TIOCM_RNG: ::c_int = 0x080;\npub const TIOCM_DSR: ::c_int = 0x100;\npub const TIOCM_CD: ::c_int = TIOCM_CAR;\npub const TIOCM_RI: ::c_int = TIOCM_RNG;\n\npub const TIOCGRS485: ::c_int = 0x542E;\npub const TIOCSRS485: ::c_int = 0x542F;\n\npub const RLIMIT_NLIMITS: ::c_int = 15;\npub const RLIM_NLIMITS: ::c_int = RLIMIT_NLIMITS;\npub const TIOCINQ: ::c_int = ::FIONREAD;\npub const MCL_CURRENT: ::c_int = 0x2000;\npub const MCL_FUTURE: ::c_int = 0x4000;\npub const CBAUD: ::tcflag_t = 0xff;\npub const TAB1: ::c_int = 0x400;\npub const TAB2: ::c_int = 0x800;\npub const TAB3: ::c_int = 0xc00;\npub const CR1: ::c_int = 0x1000;\npub const CR2: ::c_int = 0x2000;\npub const CR3: ::c_int = 0x3000;\npub const FF1: ::c_int = 0x4000;\npub const BS1: ::c_int = 0x8000;\npub const VT1: ::c_int = 0x10000;\npub const VWERASE: usize = 10;\npub const VREPRINT: usize = 11;\npub const VSUSP: usize = 12;\npub const VSTART: usize = 13;\npub const VSTOP: usize = 14;\npub const VDISCARD: usize = 16;\npub const VTIME: usize = 7;\npub const IXON: ::tcflag_t = 0x00000200;\npub const IXOFF: ::tcflag_t = 0x00000400;\npub const ONLCR: ::tcflag_t = 0x2;\npub const CSIZE: ::tcflag_t = 0x00000300;\n\npub const CS6: ::tcflag_t = 0x00000100;\npub const CS7: ::tcflag_t = 0x00000200;\npub const CS8: ::tcflag_t = 0x00000300;\npub const CSTOPB: ::tcflag_t = 0x00000400;\npub const CREAD: ::tcflag_t = 0x00000800;\npub const PARENB: ::tcflag_t = 0x00001000;\npub const PARODD: ::tcflag_t = 0x00002000;\npub const HUPCL: ::tcflag_t = 0x00004000;\npub const CLOCAL: ::tcflag_t = 0x00008000;\npub const ECHOKE: ::tcflag_t = 0x00000001;\npub const ECHOE: ::tcflag_t = 0x00000002;\npub const ECHOK: ::tcflag_t = 0x00000004;\npub const ECHONL: ::tcflag_t = 0x00000010;\npub const ECHOPRT: ::tcflag_t = 0x00000020;\npub const ECHOCTL: ::tcflag_t = 0x00000040;\npub const ISIG: ::tcflag_t = 0x00000080;\npub const ICANON: ::tcflag_t = 0x00000100;\npub const PENDIN: ::tcflag_t = 0x20000000;\npub const NOFLSH: ::tcflag_t = 0x80000000;\n\npub const CIBAUD: ::tcflag_t = 0o77600000;\npub const CBAUDEX: ::tcflag_t = 0o0000020;\npub const VSWTC: usize = 9;\npub const OLCUC: ::tcflag_t = 0o000004;\npub const NLDLY: ::tcflag_t = 0o0001400;\npub const CRDLY: ::tcflag_t = 0o0030000;\npub const TABDLY: ::tcflag_t = 0o0006000;\npub const BSDLY: ::tcflag_t = 0o0100000;\npub const FFDLY: ::tcflag_t = 0o0040000;\npub const VTDLY: ::tcflag_t = 0o0200000;\npub const XTABS: ::tcflag_t = 0o00006000;\n\npub const B57600: ::speed_t = 0o00020;\npub const B115200: ::speed_t = 0o00021;\npub const B230400: ::speed_t = 0o00022;\npub const B460800: ::speed_t = 0o00023;\npub const B500000: ::speed_t = 0o00024;\npub const B576000: ::speed_t = 0o00025;\npub const B921600: ::speed_t = 0o00026;\npub const B1000000: ::speed_t = 0o00027;\npub const B1152000: ::speed_t = 0o00030;\npub const B1500000: ::speed_t = 0o00031;\npub const B2000000: ::speed_t = 0o00032;\npub const B2500000: ::speed_t = 0o00033;\npub const B3000000: ::speed_t = 0o00034;\npub const B3500000: ::speed_t = 0o00035;\npub const B4000000: ::speed_t = 0o00036;\n\nextern \"C\" {\n    pub fn ioctl(fd: ::c_int, request: ::c_int, ...) -> ::c_int;\n}\n"],["1207","pub type c_char = i8;\npub type wchar_t = i32;\npub type nlink_t = u64;\npub type blksize_t = ::c_long;\npub type __u64 = ::c_ulonglong;\npub type greg_t = i64;\n\ns! {\n    pub struct stat {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino_t,\n        pub st_nlink: ::nlink_t,\n        pub st_mode: ::mode_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        __pad0: ::c_int,\n        pub st_rdev: ::dev_t,\n        pub st_size: ::off_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __unused: [::c_long; 3],\n    }\n\n    pub struct stat64 {\n        pub st_dev: ::dev_t,\n        pub st_ino: ::ino64_t,\n        pub st_nlink: ::nlink_t,\n        pub st_mode: ::mode_t,\n        pub st_uid: ::uid_t,\n        pub st_gid: ::gid_t,\n        __pad0: ::c_int,\n        pub st_rdev: ::dev_t,\n        pub st_size: ::off_t,\n        pub st_blksize: ::blksize_t,\n        pub st_blocks: ::blkcnt64_t,\n        pub st_atime: ::time_t,\n        pub st_atime_nsec: ::c_long,\n        pub st_mtime: ::time_t,\n        pub st_mtime_nsec: ::c_long,\n        pub st_ctime: ::time_t,\n        pub st_ctime_nsec: ::c_long,\n        __reserved: [::c_long; 3],\n    }\n\n    pub struct user_regs_struct {\n        pub r15: ::c_ulong,\n        pub r14: ::c_ulong,\n        pub r13: ::c_ulong,\n        pub r12: ::c_ulong,\n        pub rbp: ::c_ulong,\n        pub rbx: ::c_ulong,\n        pub r11: ::c_ulong,\n        pub r10: ::c_ulong,\n        pub r9: ::c_ulong,\n        pub r8: ::c_ulong,\n        pub rax: ::c_ulong,\n        pub rcx: ::c_ulong,\n        pub rdx: ::c_ulong,\n        pub rsi: ::c_ulong,\n        pub rdi: ::c_ulong,\n        pub orig_rax: ::c_ulong,\n        pub rip: ::c_ulong,\n        pub cs: ::c_ulong,\n        pub eflags: ::c_ulong,\n        pub rsp: ::c_ulong,\n        pub ss: ::c_ulong,\n        pub fs_base: ::c_ulong,\n        pub gs_base: ::c_ulong,\n        pub ds: ::c_ulong,\n        pub es: ::c_ulong,\n        pub fs: ::c_ulong,\n        pub gs: ::c_ulong,\n    }\n\n    pub struct user {\n        pub regs: user_regs_struct,\n        pub u_fpvalid: ::c_int,\n        pub i387: user_fpregs_struct,\n        pub u_tsize: ::c_ulong,\n        pub u_dsize: ::c_ulong,\n        pub u_ssize: ::c_ulong,\n        pub start_code: ::c_ulong,\n        pub start_stack: ::c_ulong,\n        pub signal: ::c_long,\n        __reserved: ::c_int,\n        #[cfg(target_pointer_width = \"32\")]\n        __pad1: u32,\n        pub u_ar0: *mut user_regs_struct,\n        #[cfg(target_pointer_width = \"32\")]\n        __pad2: u32,\n        pub u_fpstate: *mut user_fpregs_struct,\n        pub magic: ::c_ulong,\n        pub u_comm: [::c_char; 32],\n        pub u_debugreg: [::c_ulong; 8],\n    }\n\n    // GitHub repo: ifduyue/musl/\n    // commit: b4b1e10364c8737a632be61582e05a8d3acf5690\n    // file: arch/x86_64/bits/signal.h#L80-L84\n    pub struct mcontext_t {\n        pub gregs: [greg_t; 23],\n        __private: [u64; 9],\n    }\n\n    pub struct ipc_perm {\n        pub __ipc_perm_key: ::key_t,\n        pub uid: ::uid_t,\n        pub gid: ::gid_t,\n        pub cuid: ::uid_t,\n        pub cgid: ::gid_t,\n        pub mode: ::mode_t,\n        pub __seq: ::c_int,\n        __unused1: ::c_long,\n        __unused2: ::c_long\n    }\n}\n\ns_no_extra_traits! {\n    pub struct user_fpregs_struct {\n        pub cwd: ::c_ushort,\n        pub swd: ::c_ushort,\n        pub ftw: ::c_ushort,\n        pub fop: ::c_ushort,\n        pub rip: ::c_ulong,\n        pub rdp: ::c_ulong,\n        pub mxcsr: ::c_uint,\n        pub mxcr_mask: ::c_uint,\n        pub st_space: [::c_uint; 32],\n        pub xmm_space: [::c_uint; 64],\n        padding: [::c_uint; 24],\n    }\n\n    pub struct ucontext_t {\n        pub uc_flags: ::c_ulong,\n        pub uc_link: *mut ucontext_t,\n        pub uc_stack: ::stack_t,\n        pub uc_mcontext: mcontext_t,\n        pub uc_sigmask: ::sigset_t,\n        __private: [u8; 512],\n    }\n}\n\ncfg_if! {\n    if #[cfg(feature = \"extra_traits\")] {\n        impl PartialEq for user_fpregs_struct {\n            fn eq(&self, other: &user_fpregs_struct) -> bool {\n                self.cwd == other.cwd\n                    && self.swd == other.swd\n                    && self.ftw == other.ftw\n                    && self.fop == other.fop\n                    && self.rip == other.rip\n                    && self.rdp == other.rdp\n                    && self.mxcsr == other.mxcsr\n                    && self.mxcr_mask == other.mxcr_mask\n                    && self.st_space == other.st_space\n                    && self\n                    .xmm_space\n                    .iter()\n                    .zip(other.xmm_space.iter())\n                    .all(|(a,b)| a == b)\n                // Ignore padding field\n            }\n        }\n\n        impl Eq for user_fpregs_struct {}\n\n        impl ::fmt::Debug for user_fpregs_struct {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"user_fpregs_struct\")\n                    .field(\"cwd\", &self.cwd)\n                    .field(\"ftw\", &self.ftw)\n                    .field(\"fop\", &self.fop)\n                    .field(\"rip\", &self.rip)\n                    .field(\"rdp\", &self.rdp)\n                    .field(\"mxcsr\", &self.mxcsr)\n                    .field(\"mxcr_mask\", &self.mxcr_mask)\n                    .field(\"st_space\", &self.st_space)\n                // FIXME: .field(\"xmm_space\", &self.xmm_space)\n                // Ignore padding field\n                    .finish()\n            }\n        }\n\n        impl ::hash::Hash for user_fpregs_struct {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.cwd.hash(state);\n                self.ftw.hash(state);\n                self.fop.hash(state);\n                self.rip.hash(state);\n                self.rdp.hash(state);\n                self.mxcsr.hash(state);\n                self.mxcr_mask.hash(state);\n                self.st_space.hash(state);\n                self.xmm_space.hash(state);\n                // Ignore padding field\n            }\n        }\n\n        impl PartialEq for ucontext_t {\n            fn eq(&self, other: &ucontext_t) -> bool {\n                self.uc_flags == other.uc_flags\n                    && self.uc_link == other.uc_link\n                    && self.uc_stack == other.uc_stack\n                    && self.uc_mcontext == other.uc_mcontext\n                    && self.uc_sigmask == other.uc_sigmask\n                    && self\n                    .__private\n                    .iter()\n                    .zip(other.__private.iter())\n                    .all(|(a,b)| a == b)\n            }\n        }\n\n        impl Eq for ucontext_t {}\n\n        impl ::fmt::Debug for ucontext_t {\n            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n                f.debug_struct(\"ucontext_t\")\n                    .field(\"uc_flags\", &self.uc_flags)\n                    .field(\"uc_link\", &self.uc_link)\n                    .field(\"uc_stack\", &self.uc_stack)\n                    .field(\"uc_mcontext\", &self.uc_mcontext)\n                    .field(\"uc_sigmask\", &self.uc_sigmask)\n                // Ignore __private field\n                    .finish()\n            }\n        }\n\n        impl ::hash::Hash for ucontext_t {\n            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n                self.uc_flags.hash(state);\n                self.uc_link.hash(state);\n                self.uc_stack.hash(state);\n                self.uc_mcontext.hash(state);\n                self.uc_sigmask.hash(state);\n                self.__private.hash(state);\n            }\n        }\n    }\n}\n\n// Syscall table\n\npub const SYS_read: ::c_long = 0;\npub const SYS_write: ::c_long = 1;\npub const SYS_open: ::c_long = 2;\npub const SYS_close: ::c_long = 3;\npub const SYS_stat: ::c_long = 4;\npub const SYS_fstat: ::c_long = 5;\npub const SYS_lstat: ::c_long = 6;\npub const SYS_poll: ::c_long = 7;\npub const SYS_lseek: ::c_long = 8;\npub const SYS_mmap: ::c_long = 9;\npub const SYS_mprotect: ::c_long = 10;\npub const SYS_munmap: ::c_long = 11;\npub const SYS_brk: ::c_long = 12;\npub const SYS_rt_sigaction: ::c_long = 13;\npub const SYS_rt_sigprocmask: ::c_long = 14;\npub const SYS_rt_sigreturn: ::c_long = 15;\npub const SYS_ioctl: ::c_long = 16;\npub const SYS_pread64: ::c_long = 17;\npub const SYS_pwrite64: ::c_long = 18;\npub const SYS_readv: ::c_long = 19;\npub const SYS_writev: ::c_long = 20;\npub const SYS_access: ::c_long = 21;\npub const SYS_pipe: ::c_long = 22;\npub const SYS_select: ::c_long = 23;\npub const SYS_sched_yield: ::c_long = 24;\npub const SYS_mremap: ::c_long = 25;\npub const SYS_msync: ::c_long = 26;\npub const SYS_mincore: ::c_long = 27;\npub const SYS_madvise: ::c_long = 28;\npub const SYS_shmget: ::c_long = 29;\npub const SYS_shmat: ::c_long = 30;\npub const SYS_shmctl: ::c_long = 31;\npub const SYS_dup: ::c_long = 32;\npub const SYS_dup2: ::c_long = 33;\npub const SYS_pause: ::c_long = 34;\npub const SYS_nanosleep: ::c_long = 35;\npub const SYS_getitimer: ::c_long = 36;\npub const SYS_alarm: ::c_long = 37;\npub const SYS_setitimer: ::c_long = 38;\npub const SYS_getpid: ::c_long = 39;\npub const SYS_sendfile: ::c_long = 40;\npub const SYS_socket: ::c_long = 41;\npub const SYS_connect: ::c_long = 42;\npub const SYS_accept: ::c_long = 43;\npub const SYS_sendto: ::c_long = 44;\npub const SYS_recvfrom: ::c_long = 45;\npub const SYS_sendmsg: ::c_long = 46;\npub const SYS_recvmsg: ::c_long = 47;\npub const SYS_shutdown: ::c_long = 48;\npub const SYS_bind: ::c_long = 49;\npub const SYS_listen: ::c_long = 50;\npub const SYS_getsockname: ::c_long = 51;\npub const SYS_getpeername: ::c_long = 52;\npub const SYS_socketpair: ::c_long = 53;\npub const SYS_setsockopt: ::c_long = 54;\npub const SYS_getsockopt: ::c_long = 55;\npub const SYS_clone: ::c_long = 56;\npub const SYS_fork: ::c_long = 57;\npub const SYS_vfork: ::c_long = 58;\npub const SYS_execve: ::c_long = 59;\npub const SYS_exit: ::c_long = 60;\npub const SYS_wait4: ::c_long = 61;\npub const SYS_kill: ::c_long = 62;\npub const SYS_uname: ::c_long = 63;\npub const SYS_semget: ::c_long = 64;\npub const SYS_semop: ::c_long = 65;\npub const SYS_semctl: ::c_long = 66;\npub const SYS_shmdt: ::c_long = 67;\npub const SYS_msgget: ::c_long = 68;\npub const SYS_msgsnd: ::c_long = 69;\npub const SYS_msgrcv: ::c_long = 70;\npub const SYS_msgctl: ::c_long = 71;\npub const SYS_fcntl: ::c_long = 72;\npub const SYS_flock: ::c_long = 73;\npub const SYS_fsync: ::c_long = 74;\npub const SYS_fdatasync: ::c_long = 75;\npub const SYS_truncate: ::c_long = 76;\npub const SYS_ftruncate: ::c_long = 77;\npub const SYS_getdents: ::c_long = 78;\npub const SYS_getcwd: ::c_long = 79;\npub const SYS_chdir: ::c_long = 80;\npub const SYS_fchdir: ::c_long = 81;\npub const SYS_rename: ::c_long = 82;\npub const SYS_mkdir: ::c_long = 83;\npub const SYS_rmdir: ::c_long = 84;\npub const SYS_creat: ::c_long = 85;\npub const SYS_link: ::c_long = 86;\npub const SYS_unlink: ::c_long = 87;\npub const SYS_symlink: ::c_long = 88;\npub const SYS_readlink: ::c_long = 89;\npub const SYS_chmod: ::c_long = 90;\npub const SYS_fchmod: ::c_long = 91;\npub const SYS_chown: ::c_long = 92;\npub const SYS_fchown: ::c_long = 93;\npub const SYS_lchown: ::c_long = 94;\npub const SYS_umask: ::c_long = 95;\npub const SYS_gettimeofday: ::c_long = 96;\npub const SYS_getrlimit: ::c_long = 97;\npub const SYS_getrusage: ::c_long = 98;\npub const SYS_sysinfo: ::c_long = 99;\npub const SYS_times: ::c_long = 100;\npub const SYS_ptrace: ::c_long = 101;\npub const SYS_getuid: ::c_long = 102;\npub const SYS_syslog: ::c_long = 103;\npub const SYS_getgid: ::c_long = 104;\npub const SYS_setuid: ::c_long = 105;\npub const SYS_setgid: ::c_long = 106;\npub const SYS_geteuid: ::c_long = 107;\npub const SYS_getegid: ::c_long = 108;\npub const SYS_setpgid: ::c_long = 109;\npub const SYS_getppid: ::c_long = 110;\npub const SYS_getpgrp: ::c_long = 111;\npub const SYS_setsid: ::c_long = 112;\npub const SYS_setreuid: ::c_long = 113;\npub const SYS_setregid: ::c_long = 114;\npub const SYS_getgroups: ::c_long = 115;\npub const SYS_setgroups: ::c_long = 116;\npub const SYS_setresuid: ::c_long = 117;\npub const SYS_getresuid: ::c_long = 118;\npub const SYS_setresgid: ::c_long = 119;\npub const SYS_getresgid: ::c_long = 120;\npub const SYS_getpgid: ::c_long = 121;\npub const SYS_setfsuid: ::c_long = 122;\npub const SYS_setfsgid: ::c_long = 123;\npub const SYS_getsid: ::c_long = 124;\npub const SYS_capget: ::c_long = 125;\npub const SYS_capset: ::c_long = 126;\npub const SYS_rt_sigpending: ::c_long = 127;\npub const SYS_rt_sigtimedwait: ::c_long = 128;\npub const SYS_rt_sigqueueinfo: ::c_long = 129;\npub const SYS_rt_sigsuspend: ::c_long = 130;\npub const SYS_sigaltstack: ::c_long = 131;\npub const SYS_utime: ::c_long = 132;\npub const SYS_mknod: ::c_long = 133;\npub const SYS_uselib: ::c_long = 134;\npub const SYS_personality: ::c_long = 135;\npub const SYS_ustat: ::c_long = 136;\npub const SYS_statfs: ::c_long = 137;\npub const SYS_fstatfs: ::c_long = 138;\npub const SYS_sysfs: ::c_long = 139;\npub const SYS_getpriority: ::c_long = 140;\npub const SYS_setpriority: ::c_long = 141;\npub const SYS_sched_setparam: ::c_long = 142;\npub const SYS_sched_getparam: ::c_long = 143;\npub const SYS_sched_setscheduler: ::c_long = 144;\npub const SYS_sched_getscheduler: ::c_long = 145;\npub const SYS_sched_get_priority_max: ::c_long = 146;\npub const SYS_sched_get_priority_min: ::c_long = 147;\npub const SYS_sched_rr_get_interval: ::c_long = 148;\npub const SYS_mlock: ::c_long = 149;\npub const SYS_munlock: ::c_long = 150;\npub const SYS_mlockall: ::c_long = 151;\npub const SYS_munlockall: ::c_long = 152;\npub const SYS_vhangup: ::c_long = 153;\npub const SYS_modify_ldt: ::c_long = 154;\npub const SYS_pivot_root: ::c_long = 155;\npub const SYS__sysctl: ::c_long = 156;\npub const SYS_prctl: ::c_long = 157;\npub const SYS_arch_prctl: ::c_long = 158;\npub const SYS_adjtimex: ::c_long = 159;\npub const SYS_setrlimit: ::c_long = 160;\npub const SYS_chroot: ::c_long = 161;\npub const SYS_sync: ::c_long = 162;\npub const SYS_acct: ::c_long = 163;\npub const SYS_settimeofday: ::c_long = 164;\npub const SYS_mount: ::c_long = 165;\npub const SYS_umount2: ::c_long = 166;\npub const SYS_swapon: ::c_long = 167;\npub const SYS_swapoff: ::c_long = 168;\npub const SYS_reboot: ::c_long = 169;\npub const SYS_sethostname: ::c_long = 170;\npub const SYS_setdomainname: ::c_long = 171;\npub const SYS_iopl: ::c_long = 172;\npub const SYS_ioperm: ::c_long = 173;\npub const SYS_create_module: ::c_long = 174;\npub const SYS_init_module: ::c_long = 175;\npub const SYS_delete_module: ::c_long = 176;\npub const SYS_get_kernel_syms: ::c_long = 177;\npub const SYS_query_module: ::c_long = 178;\npub const SYS_quotactl: ::c_long = 179;\npub const SYS_nfsservctl: ::c_long = 180;\npub const SYS_getpmsg: ::c_long = 181;\npub const SYS_putpmsg: ::c_long = 182;\npub const SYS_afs_syscall: ::c_long = 183;\npub const SYS_tuxcall: ::c_long = 184;\npub const SYS_security: ::c_long = 185;\npub const SYS_gettid: ::c_long = 186;\npub const SYS_readahead: ::c_long = 187;\npub const SYS_setxattr: ::c_long = 188;\npub const SYS_lsetxattr: ::c_long = 189;\npub const SYS_fsetxattr: ::c_long = 190;\npub const SYS_getxattr: ::c_long = 191;\npub const SYS_lgetxattr: ::c_long = 192;\npub const SYS_fgetxattr: ::c_long = 193;\npub const SYS_listxattr: ::c_long = 194;\npub const SYS_llistxattr: ::c_long = 195;\npub const SYS_flistxattr: ::c_long = 196;\npub const SYS_removexattr: ::c_long = 197;\npub const SYS_lremovexattr: ::c_long = 198;\npub const SYS_fremovexattr: ::c_long = 199;\npub const SYS_tkill: ::c_long = 200;\npub const SYS_time: ::c_long = 201;\npub const SYS_futex: ::c_long = 202;\npub const SYS_sched_setaffinity: ::c_long = 203;\npub const SYS_sched_getaffinity: ::c_long = 204;\npub const SYS_set_thread_area: ::c_long = 205;\npub const SYS_io_setup: ::c_long = 206;\npub const SYS_io_destroy: ::c_long = 207;\npub const SYS_io_getevents: ::c_long = 208;\npub const SYS_io_submit: ::c_long = 209;\npub const SYS_io_cancel: ::c_long = 210;\npub const SYS_get_thread_area: ::c_long = 211;\npub const SYS_lookup_dcookie: ::c_long = 212;\npub const SYS_epoll_create: ::c_long = 213;\npub const SYS_epoll_ctl_old: ::c_long = 214;\npub const SYS_epoll_wait_old: ::c_long = 215;\npub const SYS_remap_file_pages: ::c_long = 216;\npub const SYS_getdents64: ::c_long = 217;\npub const SYS_set_tid_address: ::c_long = 218;\npub const SYS_restart_syscall: ::c_long = 219;\npub const SYS_semtimedop: ::c_long = 220;\npub const SYS_fadvise64: ::c_long = 221;\npub const SYS_timer_create: ::c_long = 222;\npub const SYS_timer_settime: ::c_long = 223;\npub const SYS_timer_gettime: ::c_long = 224;\npub const SYS_timer_getoverrun: ::c_long = 225;\npub const SYS_timer_delete: ::c_long = 226;\npub const SYS_clock_settime: ::c_long = 227;\npub const SYS_clock_gettime: ::c_long = 228;\npub const SYS_clock_getres: ::c_long = 229;\npub const SYS_clock_nanosleep: ::c_long = 230;\npub const SYS_exit_group: ::c_long = 231;\npub const SYS_epoll_wait: ::c_long = 232;\npub const SYS_epoll_ctl: ::c_long = 233;\npub const SYS_tgkill: ::c_long = 234;\npub const SYS_utimes: ::c_long = 235;\npub const SYS_vserver: ::c_long = 236;\npub const SYS_mbind: ::c_long = 237;\npub const SYS_set_mempolicy: ::c_long = 238;\npub const SYS_get_mempolicy: ::c_long = 239;\npub const SYS_mq_open: ::c_long = 240;\npub const SYS_mq_unlink: ::c_long = 241;\npub const SYS_mq_timedsend: ::c_long = 242;\npub const SYS_mq_timedreceive: ::c_long = 243;\npub const SYS_mq_notify: ::c_long = 244;\npub const SYS_mq_getsetattr: ::c_long = 245;\npub const SYS_kexec_load: ::c_long = 246;\npub const SYS_waitid: ::c_long = 247;\npub const SYS_add_key: ::c_long = 248;\npub const SYS_request_key: ::c_long = 249;\npub const SYS_keyctl: ::c_long = 250;\npub const SYS_ioprio_set: ::c_long = 251;\npub const SYS_ioprio_get: ::c_long = 252;\npub const SYS_inotify_init: ::c_long = 253;\npub const SYS_inotify_add_watch: ::c_long = 254;\npub const SYS_inotify_rm_watch: ::c_long = 255;\npub const SYS_migrate_pages: ::c_long = 256;\npub const SYS_openat: ::c_long = 257;\npub const SYS_mkdirat: ::c_long = 258;\npub const SYS_mknodat: ::c_long = 259;\npub const SYS_fchownat: ::c_long = 260;\npub const SYS_futimesat: ::c_long = 261;\npub const SYS_newfstatat: ::c_long = 262;\npub const SYS_unlinkat: ::c_long = 263;\npub const SYS_renameat: ::c_long = 264;\npub const SYS_linkat: ::c_long = 265;\npub const SYS_symlinkat: ::c_long = 266;\npub const SYS_readlinkat: ::c_long = 267;\npub const SYS_fchmodat: ::c_long = 268;\npub const SYS_faccessat: ::c_long = 269;\npub const SYS_pselect6: ::c_long = 270;\npub const SYS_ppoll: ::c_long = 271;\npub const SYS_unshare: ::c_long = 272;\npub const SYS_set_robust_list: ::c_long = 273;\npub const SYS_get_robust_list: ::c_long = 274;\npub const SYS_splice: ::c_long = 275;\npub const SYS_tee: ::c_long = 276;\npub const SYS_sync_file_range: ::c_long = 277;\npub const SYS_vmsplice: ::c_long = 278;\npub const SYS_move_pages: ::c_long = 279;\npub const SYS_utimensat: ::c_long = 280;\npub const SYS_epoll_pwait: ::c_long = 281;\npub const SYS_signalfd: ::c_long = 282;\npub const SYS_timerfd_create: ::c_long = 283;\npub const SYS_eventfd: ::c_long = 284;\npub const SYS_fallocate: ::c_long = 285;\npub const SYS_timerfd_settime: ::c_long = 286;\npub const SYS_timerfd_gettime: ::c_long = 287;\npub const SYS_accept4: ::c_long = 288;\npub const SYS_signalfd4: ::c_long = 289;\npub const SYS_eventfd2: ::c_long = 290;\npub const SYS_epoll_create1: ::c_long = 291;\npub const SYS_dup3: ::c_long = 292;\npub const SYS_pipe2: ::c_long = 293;\npub const SYS_inotify_init1: ::c_long = 294;\npub const SYS_preadv: ::c_long = 295;\npub const SYS_pwritev: ::c_long = 296;\npub const SYS_rt_tgsigqueueinfo: ::c_long = 297;\npub const SYS_perf_event_open: ::c_long = 298;\npub const SYS_recvmmsg: ::c_long = 299;\npub const SYS_fanotify_init: ::c_long = 300;\npub const SYS_fanotify_mark: ::c_long = 301;\npub const SYS_prlimit64: ::c_long = 302;\npub const SYS_name_to_handle_at: ::c_long = 303;\npub const SYS_open_by_handle_at: ::c_long = 304;\npub const SYS_clock_adjtime: ::c_long = 305;\npub const SYS_syncfs: ::c_long = 306;\npub const SYS_sendmmsg: ::c_long = 307;\npub const SYS_setns: ::c_long = 308;\npub const SYS_getcpu: ::c_long = 309;\npub const SYS_process_vm_readv: ::c_long = 310;\npub const SYS_process_vm_writev: ::c_long = 311;\npub const SYS_kcmp: ::c_long = 312;\npub const SYS_finit_module: ::c_long = 313;\npub const SYS_sched_setattr: ::c_long = 314;\npub const SYS_sched_getattr: ::c_long = 315;\npub const SYS_renameat2: ::c_long = 316;\npub const SYS_seccomp: ::c_long = 317;\npub const SYS_getrandom: ::c_long = 318;\npub const SYS_memfd_create: ::c_long = 319;\npub const SYS_kexec_file_load: ::c_long = 320;\npub const SYS_bpf: ::c_long = 321;\npub const SYS_execveat: ::c_long = 322;\npub const SYS_userfaultfd: ::c_long = 323;\npub const SYS_membarrier: ::c_long = 324;\npub const SYS_mlock2: ::c_long = 325;\npub const SYS_copy_file_range: ::c_long = 326;\npub const SYS_preadv2: ::c_long = 327;\npub const SYS_pwritev2: ::c_long = 328;\npub const SYS_pkey_mprotect: ::c_long = 329;\npub const SYS_pkey_alloc: ::c_long = 330;\npub const SYS_pkey_free: ::c_long = 331;\npub const SYS_statx: ::c_long = 332;\npub const SYS_pidfd_send_signal: ::c_long = 424;\npub const SYS_io_uring_setup: ::c_long = 425;\npub const SYS_io_uring_enter: ::c_long = 426;\npub const SYS_io_uring_register: ::c_long = 427;\npub const SYS_open_tree: ::c_long = 428;\npub const SYS_move_mount: ::c_long = 429;\npub const SYS_fsopen: ::c_long = 430;\npub const SYS_fsconfig: ::c_long = 431;\npub const SYS_fsmount: ::c_long = 432;\npub const SYS_fspick: ::c_long = 433;\npub const SYS_pidfd_open: ::c_long = 434;\npub const SYS_clone3: ::c_long = 435;\npub const SYS_close_range: ::c_long = 436;\npub const SYS_openat2: ::c_long = 437;\npub const SYS_pidfd_getfd: ::c_long = 438;\npub const SYS_faccessat2: ::c_long = 439;\npub const SYS_process_madvise: ::c_long = 440;\npub const SYS_epoll_pwait2: ::c_long = 441;\npub const SYS_mount_setattr: ::c_long = 442;\n\n// offsets in user_regs_structs, from sys/reg.h\npub const R15: ::c_int = 0;\npub const R14: ::c_int = 1;\npub const R13: ::c_int = 2;\npub const R12: ::c_int = 3;\npub const RBP: ::c_int = 4;\npub const RBX: ::c_int = 5;\npub const R11: ::c_int = 6;\npub const R10: ::c_int = 7;\npub const R9: ::c_int = 8;\npub const R8: ::c_int = 9;\npub const RAX: ::c_int = 10;\npub const RCX: ::c_int = 11;\npub const RDX: ::c_int = 12;\npub const RSI: ::c_int = 13;\npub const RDI: ::c_int = 14;\npub const ORIG_RAX: ::c_int = 15;\npub const RIP: ::c_int = 16;\npub const CS: ::c_int = 17;\npub const EFLAGS: ::c_int = 18;\npub const RSP: ::c_int = 19;\npub const SS: ::c_int = 20;\npub const FS_BASE: ::c_int = 21;\npub const GS_BASE: ::c_int = 22;\npub const DS: ::c_int = 23;\npub const ES: ::c_int = 24;\npub const FS: ::c_int = 25;\npub const GS: ::c_int = 26;\n\n// offsets in mcontext_t.gregs from bits/signal.h\n// GitHub repo: ifduyue/musl/\n// commit: b4b1e10364c8737a632be61582e05a8d3acf5690\n// file: arch/x86_64/bits/signal.h#L9-L56\npub const REG_R8: ::c_int = 0;\npub const REG_R9: ::c_int = 1;\npub const REG_R10: ::c_int = 2;\npub const REG_R11: ::c_int = 3;\npub const REG_R12: ::c_int = 4;\npub const REG_R13: ::c_int = 5;\npub const REG_R14: ::c_int = 6;\npub const REG_R15: ::c_int = 7;\npub const REG_RDI: ::c_int = 8;\npub const REG_RSI: ::c_int = 9;\npub const REG_RBP: ::c_int = 10;\npub const REG_RBX: ::c_int = 11;\npub const REG_RDX: ::c_int = 12;\npub const REG_RAX: ::c_int = 13;\npub const REG_RCX: ::c_int = 14;\npub const REG_RSP: ::c_int = 15;\npub const REG_RIP: ::c_int = 16;\npub const REG_EFL: ::c_int = 17;\npub const REG_CSGSFS: ::c_int = 18;\npub const REG_ERR: ::c_int = 19;\npub const REG_TRAPNO: ::c_int = 20;\npub const REG_OLDMASK: ::c_int = 21;\npub const REG_CR2: ::c_int = 22;\n\npub const MADV_SOFT_OFFLINE: ::c_int = 101;\npub const MAP_32BIT: ::c_int = 0x0040;\npub const O_APPEND: ::c_int = 1024;\npub const O_DIRECT: ::c_int = 0x4000;\npub const O_DIRECTORY: ::c_int = 0x10000;\npub const O_LARGEFILE: ::c_int = 0;\npub const O_NOFOLLOW: ::c_int = 0x20000;\npub const O_CREAT: ::c_int = 64;\npub const O_EXCL: ::c_int = 128;\npub const O_NOCTTY: ::c_int = 256;\npub const O_NONBLOCK: ::c_int = 2048;\npub const O_SYNC: ::c_int = 1052672;\npub const O_RSYNC: ::c_int = 1052672;\npub const O_DSYNC: ::c_int = 4096;\npub const O_ASYNC: ::c_int = 0x2000;\n\npub const TIOCGRS485: ::c_int = 0x542E;\npub const TIOCSRS485: ::c_int = 0x542F;\n\npub const SIGSTKSZ: ::size_t = 8192;\npub const MINSIGSTKSZ: ::size_t = 2048;\n\npub const ENAMETOOLONG: ::c_int = 36;\npub const ENOLCK: ::c_int = 37;\npub const ENOSYS: ::c_int = 38;\npub const ENOTEMPTY: ::c_int = 39;\npub const ELOOP: ::c_int = 40;\npub const ENOMSG: ::c_int = 42;\npub const EIDRM: ::c_int = 43;\npub const ECHRNG: ::c_int = 44;\npub const EL2NSYNC: ::c_int = 45;\npub const EL3HLT: ::c_int = 46;\npub const EL3RST: ::c_int = 47;\npub const ELNRNG: ::c_int = 48;\npub const EUNATCH: ::c_int = 49;\npub const ENOCSI: ::c_int = 50;\npub const EL2HLT: ::c_int = 51;\npub const EBADE: ::c_int = 52;\npub const EBADR: ::c_int = 53;\npub const EXFULL: ::c_int = 54;\npub const ENOANO: ::c_int = 55;\npub const EBADRQC: ::c_int = 56;\npub const EBADSLT: ::c_int = 57;\npub const EMULTIHOP: ::c_int = 72;\npub const EBADMSG: ::c_int = 74;\npub const EOVERFLOW: ::c_int = 75;\npub const ENOTUNIQ: ::c_int = 76;\npub const EBADFD: ::c_int = 77;\npub const EREMCHG: ::c_int = 78;\npub const ELIBACC: ::c_int = 79;\npub const ELIBBAD: ::c_int = 80;\npub const ELIBSCN: ::c_int = 81;\npub const ELIBMAX: ::c_int = 82;\npub const ELIBEXEC: ::c_int = 83;\npub const EILSEQ: ::c_int = 84;\npub const ERESTART: ::c_int = 85;\npub const ESTRPIPE: ::c_int = 86;\npub const EUSERS: ::c_int = 87;\npub const ENOTSOCK: ::c_int = 88;\npub const EDESTADDRREQ: ::c_int = 89;\npub const EMSGSIZE: ::c_int = 90;\npub const EPROTOTYPE: ::c_int = 91;\npub const ENOPROTOOPT: ::c_int = 92;\npub const EPROTONOSUPPORT: ::c_int = 93;\npub const ESOCKTNOSUPPORT: ::c_int = 94;\npub const EOPNOTSUPP: ::c_int = 95;\npub const ENOTSUP: ::c_int = EOPNOTSUPP;\npub const EPFNOSUPPORT: ::c_int = 96;\npub const EAFNOSUPPORT: ::c_int = 97;\npub const EADDRINUSE: ::c_int = 98;\npub const EADDRNOTAVAIL: ::c_int = 99;\npub const ENETDOWN: ::c_int = 100;\npub const ENETUNREACH: ::c_int = 101;\npub const ENETRESET: ::c_int = 102;\npub const ECONNABORTED: ::c_int = 103;\npub const ECONNRESET: ::c_int = 104;\npub const ENOBUFS: ::c_int = 105;\npub const EISCONN: ::c_int = 106;\npub const ENOTCONN: ::c_int = 107;\npub const ESHUTDOWN: ::c_int = 108;\npub const ETOOMANYREFS: ::c_int = 109;\npub const ETIMEDOUT: ::c_int = 110;\npub const ECONNREFUSED: ::c_int = 111;\npub const EHOSTDOWN: ::c_int = 112;\npub const EHOSTUNREACH: ::c_int = 113;\npub const EALREADY: ::c_int = 114;\npub const EINPROGRESS: ::c_int = 115;\npub const ESTALE: ::c_int = 116;\npub const EUCLEAN: ::c_int = 117;\npub const ENOTNAM: ::c_int = 118;\npub const ENAVAIL: ::c_int = 119;\npub const EISNAM: ::c_int = 120;\npub const EREMOTEIO: ::c_int = 121;\npub const EDQUOT: ::c_int = 122;\npub const ENOMEDIUM: ::c_int = 123;\npub const EMEDIUMTYPE: ::c_int = 124;\npub const ECANCELED: ::c_int = 125;\npub const ENOKEY: ::c_int = 126;\npub const EKEYEXPIRED: ::c_int = 127;\npub const EKEYREVOKED: ::c_int = 128;\npub const EKEYREJECTED: ::c_int = 129;\npub const EOWNERDEAD: ::c_int = 130;\npub const ENOTRECOVERABLE: ::c_int = 131;\npub const ERFKILL: ::c_int = 132;\npub const EHWPOISON: ::c_int = 133;\n\npub const SA_ONSTACK: ::c_int = 0x08000000;\npub const SA_SIGINFO: ::c_int = 0x00000004;\npub const SA_NOCLDWAIT: ::c_int = 0x00000002;\n\npub const SIGCHLD: ::c_int = 17;\npub const SIGBUS: ::c_int = 7;\npub const SIGTTIN: ::c_int = 21;\npub const SIGTTOU: ::c_int = 22;\npub const SIGXCPU: ::c_int = 24;\npub const SIGXFSZ: ::c_int = 25;\npub const SIGVTALRM: ::c_int = 26;\npub const SIGPROF: ::c_int = 27;\npub const SIGWINCH: ::c_int = 28;\npub const SIGUSR1: ::c_int = 10;\npub const SIGUSR2: ::c_int = 12;\npub const SIGCONT: ::c_int = 18;\npub const SIGSTOP: ::c_int = 19;\npub const SIGTSTP: ::c_int = 20;\npub const SIGURG: ::c_int = 23;\npub const SIGIO: ::c_int = 29;\npub const SIGSYS: ::c_int = 31;\npub const SIGSTKFLT: ::c_int = 16;\npub const SIGPOLL: ::c_int = 29;\npub const SIGPWR: ::c_int = 30;\npub const SIG_SETMASK: ::c_int = 2;\npub const SIG_BLOCK: ::c_int = 0x000000;\npub const SIG_UNBLOCK: ::c_int = 0x01;\n\npub const F_GETLK: ::c_int = 5;\npub const F_GETOWN: ::c_int = 9;\npub const F_SETLK: ::c_int = 6;\npub const F_SETLKW: ::c_int = 7;\npub const F_SETOWN: ::c_int = 8;\npub const F_OFD_GETLK: ::c_int = 36;\npub const F_OFD_SETLK: ::c_int = 37;\npub const F_OFD_SETLKW: ::c_int = 38;\n\npub const VEOF: usize = 4;\n\npub const POLLWRNORM: ::c_short = 0x100;\npub const POLLWRBAND: ::c_short = 0x200;\n\npub const SOCK_STREAM: ::c_int = 1;\npub const SOCK_DGRAM: ::c_int = 2;\n\npub const MAP_ANON: ::c_int = 0x0020;\npub const MAP_GROWSDOWN: ::c_int = 0x0100;\npub const MAP_DENYWRITE: ::c_int = 0x0800;\npub const MAP_EXECUTABLE: ::c_int = 0x01000;\npub const MAP_LOCKED: ::c_int = 0x02000;\npub const MAP_NORESERVE: ::c_int = 0x04000;\npub const MAP_POPULATE: ::c_int = 0x08000;\npub const MAP_NONBLOCK: ::c_int = 0x010000;\npub const MAP_STACK: ::c_int = 0x020000;\npub const MAP_HUGETLB: ::c_int = 0x040000;\npub const MAP_SYNC: ::c_int = 0x080000;\n\npub const RLIMIT_NLIMITS: ::c_int = 15;\npub const RLIM_NLIMITS: ::c_int = RLIMIT_NLIMITS;\npub const TIOCINQ: ::c_int = ::FIONREAD;\npub const MCL_CURRENT: ::c_int = 0x0001;\npub const MCL_FUTURE: ::c_int = 0x0002;\npub const CBAUD: ::tcflag_t = 0o0010017;\npub const TAB1: ::c_int = 0x00000800;\npub const TAB2: ::c_int = 0x00001000;\npub const TAB3: ::c_int = 0x00001800;\npub const CR1: ::c_int = 0x00000200;\npub const CR2: ::c_int = 0x00000400;\npub const CR3: ::c_int = 0x00000600;\npub const FF1: ::c_int = 0x00008000;\npub const BS1: ::c_int = 0x00002000;\npub const VT1: ::c_int = 0x00004000;\npub const VWERASE: usize = 14;\npub const VREPRINT: usize = 12;\npub const VSUSP: usize = 10;\npub const VSTART: usize = 8;\npub const VSTOP: usize = 9;\npub const VDISCARD: usize = 13;\npub const VTIME: usize = 5;\npub const IXON: ::tcflag_t = 0x00000400;\npub const IXOFF: ::tcflag_t = 0x00001000;\npub const ONLCR: ::tcflag_t = 0x4;\npub const CSIZE: ::tcflag_t = 0x00000030;\npub const CS6: ::tcflag_t = 0x00000010;\npub const CS7: ::tcflag_t = 0x00000020;\npub const CS8: ::tcflag_t = 0x00000030;\npub const CSTOPB: ::tcflag_t = 0x00000040;\npub const CREAD: ::tcflag_t = 0x00000080;\npub const PARENB: ::tcflag_t = 0x00000100;\npub const PARODD: ::tcflag_t = 0x00000200;\npub const HUPCL: ::tcflag_t = 0x00000400;\npub const CLOCAL: ::tcflag_t = 0x00000800;\npub const ECHOKE: ::tcflag_t = 0x00000800;\npub const ECHOE: ::tcflag_t = 0x00000010;\npub const ECHOK: ::tcflag_t = 0x00000020;\npub const ECHONL: ::tcflag_t = 0x00000040;\npub const ECHOPRT: ::tcflag_t = 0x00000400;\npub const ECHOCTL: ::tcflag_t = 0x00000200;\npub const ISIG: ::tcflag_t = 0x00000001;\npub const ICANON: ::tcflag_t = 0x00000002;\npub const PENDIN: ::tcflag_t = 0x00004000;\npub const NOFLSH: ::tcflag_t = 0x00000080;\npub const CIBAUD: ::tcflag_t = 0o02003600000;\npub const CBAUDEX: ::tcflag_t = 0o010000;\npub const VSWTC: usize = 7;\npub const OLCUC: ::tcflag_t = 0o000002;\npub const NLDLY: ::tcflag_t = 0o000400;\npub const CRDLY: ::tcflag_t = 0o003000;\npub const TABDLY: ::tcflag_t = 0o014000;\npub const BSDLY: ::tcflag_t = 0o020000;\npub const FFDLY: ::tcflag_t = 0o100000;\npub const VTDLY: ::tcflag_t = 0o040000;\npub const XTABS: ::tcflag_t = 0o014000;\npub const B57600: ::speed_t = 0o010001;\npub const B115200: ::speed_t = 0o010002;\npub const B230400: ::speed_t = 0o010003;\npub const B460800: ::speed_t = 0o010004;\npub const B500000: ::speed_t = 0o010005;\npub const B576000: ::speed_t = 0o010006;\npub const B921600: ::speed_t = 0o010007;\npub const B1000000: ::speed_t = 0o010010;\npub const B1152000: ::speed_t = 0o010011;\npub const B1500000: ::speed_t = 0o010012;\npub const B2000000: ::speed_t = 0o010013;\npub const B2500000: ::speed_t = 0o010014;\npub const B3000000: ::speed_t = 0o010015;\npub const B3500000: ::speed_t = 0o010016;\npub const B4000000: ::speed_t = 0o010017;\n\npub const FIOCLEX: ::c_int = 0x5451;\npub const FIONCLEX: ::c_int = 0x5450;\npub const FIONBIO: ::c_int = 0x5421;\npub const EDEADLK: ::c_int = 35;\npub const EDEADLOCK: ::c_int = EDEADLK;\n\npub const EXTPROC: ::tcflag_t = 0x00010000;\npub const VEOL: usize = 11;\npub const VEOL2: usize = 16;\npub const VMIN: usize = 6;\npub const IEXTEN: ::tcflag_t = 0x00008000;\npub const TOSTOP: ::tcflag_t = 0x00000100;\npub const FLUSHO: ::tcflag_t = 0x00001000;\npub const TCGETS: ::c_int = 0x5401;\npub const TCSETS: ::c_int = 0x5402;\npub const TCSETSW: ::c_int = 0x5403;\npub const TCSETSF: ::c_int = 0x5404;\npub const TCGETA: ::c_int = 0x5405;\npub const TCSETA: ::c_int = 0x5406;\npub const TCSETAW: ::c_int = 0x5407;\npub const TCSETAF: ::c_int = 0x5408;\npub const TCSBRK: ::c_int = 0x5409;\npub const TCXONC: ::c_int = 0x540A;\npub const TCFLSH: ::c_int = 0x540B;\npub const TIOCGSOFTCAR: ::c_int = 0x5419;\npub const TIOCSSOFTCAR: ::c_int = 0x541A;\npub const TIOCLINUX: ::c_int = 0x541C;\npub const TIOCGSERIAL: ::c_int = 0x541E;\npub const TIOCEXCL: ::c_int = 0x540C;\npub const TIOCNXCL: ::c_int = 0x540D;\npub const TIOCSCTTY: ::c_int = 0x540E;\npub const TIOCGPGRP: ::c_int = 0x540F;\npub const TIOCSPGRP: ::c_int = 0x5410;\npub const TIOCOUTQ: ::c_int = 0x5411;\npub const TIOCSTI: ::c_int = 0x5412;\npub const TIOCGWINSZ: ::c_int = 0x5413;\npub const TIOCSWINSZ: ::c_int = 0x5414;\npub const TIOCMGET: ::c_int = 0x5415;\npub const TIOCMBIS: ::c_int = 0x5416;\npub const TIOCMBIC: ::c_int = 0x5417;\npub const TIOCMSET: ::c_int = 0x5418;\npub const FIONREAD: ::c_int = 0x541B;\npub const TIOCCONS: ::c_int = 0x541D;\n\npub const TIOCM_LE: ::c_int = 0x001;\npub const TIOCM_DTR: ::c_int = 0x002;\npub const TIOCM_RTS: ::c_int = 0x004;\npub const TIOCM_ST: ::c_int = 0x008;\npub const TIOCM_SR: ::c_int = 0x010;\npub const TIOCM_CTS: ::c_int = 0x020;\npub const TIOCM_CAR: ::c_int = 0x040;\npub const TIOCM_RNG: ::c_int = 0x080;\npub const TIOCM_DSR: ::c_int = 0x100;\npub const TIOCM_CD: ::c_int = TIOCM_CAR;\npub const TIOCM_RI: ::c_int = TIOCM_RNG;\n\nextern \"C\" {\n    pub fn ioctl(fd: ::c_int, request: ::c_int, ...) -> ::c_int;\n}\n\ncfg_if! {\n    if #[cfg(libc_align)] {\n        mod align;\n        pub use self::align::*;\n    }\n}\n"]]}